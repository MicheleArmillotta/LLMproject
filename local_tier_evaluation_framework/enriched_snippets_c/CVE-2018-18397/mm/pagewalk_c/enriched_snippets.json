[
  {
    "function_name": "walk_page_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
    "lines": "342-358",
    "snippet": "int walk_page_vma(struct vm_area_struct *vma, struct mm_walk *walk)\n{\n\tint err;\n\n\tif (!walk->mm)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON(!rwsem_is_locked(&walk->mm->mmap_sem));\n\tVM_BUG_ON(!vma);\n\twalk->vma = vma;\n\terr = walk_page_test(vma->vm_start, vma->vm_end, walk);\n\tif (err > 0)\n\t\treturn 0;\n\tif (err < 0)\n\t\treturn err;\n\treturn __walk_page_range(vma->vm_start, vma->vm_end, walk);\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__walk_page_range",
          "args": [
            "vma->vm_start",
            "vma->vm_end",
            "walk"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "__walk_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
          "lines": "244-257",
          "snippet": "static int __walk_page_range(unsigned long start, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tint err = 0;\n\tstruct vm_area_struct *vma = walk->vma;\n\n\tif (vma && is_vm_hugetlb_page(vma)) {\n\t\tif (walk->hugetlb_entry)\n\t\t\terr = walk_hugetlb_range(start, end, walk);\n\t} else\n\t\terr = walk_pgd_range(start, end, walk);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic int __walk_page_range(unsigned long start, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tint err = 0;\n\tstruct vm_area_struct *vma = walk->vma;\n\n\tif (vma && is_vm_hugetlb_page(vma)) {\n\t\tif (walk->hugetlb_entry)\n\t\t\terr = walk_hugetlb_range(start, end, walk);\n\t} else\n\t\terr = walk_pgd_range(start, end, walk);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "walk_page_test",
          "args": [
            "vma->vm_start",
            "vma->vm_end",
            "walk"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "walk_page_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
          "lines": "219-242",
          "snippet": "static int walk_page_test(unsigned long start, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\n\tif (walk->test_walk)\n\t\treturn walk->test_walk(start, end, walk);\n\n\t/*\n\t * vma(VM_PFNMAP) doesn't have any valid struct pages behind VM_PFNMAP\n\t * range, so we don't walk over it as we do for normal vmas. However,\n\t * Some callers are interested in handling hole range and they don't\n\t * want to just ignore any single address range. Such users certainly\n\t * define their ->pte_hole() callbacks, so let's delegate them to handle\n\t * vma(VM_PFNMAP).\n\t */\n\tif (vma->vm_flags & VM_PFNMAP) {\n\t\tint err = 1;\n\t\tif (walk->pte_hole)\n\t\t\terr = walk->pte_hole(start, end, walk);\n\t\treturn err ? err : 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic int walk_page_test(unsigned long start, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\n\tif (walk->test_walk)\n\t\treturn walk->test_walk(start, end, walk);\n\n\t/*\n\t * vma(VM_PFNMAP) doesn't have any valid struct pages behind VM_PFNMAP\n\t * range, so we don't walk over it as we do for normal vmas. However,\n\t * Some callers are interested in handling hole range and they don't\n\t * want to just ignore any single address range. Such users certainly\n\t * define their ->pte_hole() callbacks, so let's delegate them to handle\n\t * vma(VM_PFNMAP).\n\t */\n\tif (vma->vm_flags & VM_PFNMAP) {\n\t\tint err = 1;\n\t\tif (walk->pte_hole)\n\t\t\terr = walk->pte_hole(start, end, walk);\n\t\treturn err ? err : 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!vma"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!rwsem_is_locked(&walk->mm->mmap_sem)"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwsem_is_locked",
          "args": [
            "&walk->mm->mmap_sem"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nint walk_page_vma(struct vm_area_struct *vma, struct mm_walk *walk)\n{\n\tint err;\n\n\tif (!walk->mm)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON(!rwsem_is_locked(&walk->mm->mmap_sem));\n\tVM_BUG_ON(!vma);\n\twalk->vma = vma;\n\terr = walk_page_test(vma->vm_start, vma->vm_end, walk);\n\tif (err > 0)\n\t\treturn 0;\n\tif (err < 0)\n\t\treturn err;\n\treturn __walk_page_range(vma->vm_start, vma->vm_end, walk);\n}"
  },
  {
    "function_name": "walk_page_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
    "lines": "293-340",
    "snippet": "int walk_page_range(unsigned long start, unsigned long end,\n\t\t    struct mm_walk *walk)\n{\n\tint err = 0;\n\tunsigned long next;\n\tstruct vm_area_struct *vma;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tif (!walk->mm)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON_MM(!rwsem_is_locked(&walk->mm->mmap_sem), walk->mm);\n\n\tvma = find_vma(walk->mm, start);\n\tdo {\n\t\tif (!vma) { /* after the last vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = end;\n\t\t} else if (start < vma->vm_start) { /* outside vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = min(end, vma->vm_start);\n\t\t} else { /* inside vma */\n\t\t\twalk->vma = vma;\n\t\t\tnext = min(end, vma->vm_end);\n\t\t\tvma = vma->vm_next;\n\n\t\t\terr = walk_page_test(start, next, walk);\n\t\t\tif (err > 0) {\n\t\t\t\t/*\n\t\t\t\t * positive return values are purely for\n\t\t\t\t * controlling the pagewalk, so should never\n\t\t\t\t * be passed to the callers.\n\t\t\t\t */\n\t\t\t\terr = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (walk->vma || walk->pte_hole)\n\t\t\terr = __walk_page_range(start, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (start = next, start < end);\n\treturn err;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__walk_page_range",
          "args": [
            "start",
            "next",
            "walk"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "__walk_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
          "lines": "244-257",
          "snippet": "static int __walk_page_range(unsigned long start, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tint err = 0;\n\tstruct vm_area_struct *vma = walk->vma;\n\n\tif (vma && is_vm_hugetlb_page(vma)) {\n\t\tif (walk->hugetlb_entry)\n\t\t\terr = walk_hugetlb_range(start, end, walk);\n\t} else\n\t\terr = walk_pgd_range(start, end, walk);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic int __walk_page_range(unsigned long start, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tint err = 0;\n\tstruct vm_area_struct *vma = walk->vma;\n\n\tif (vma && is_vm_hugetlb_page(vma)) {\n\t\tif (walk->hugetlb_entry)\n\t\t\terr = walk_hugetlb_range(start, end, walk);\n\t} else\n\t\terr = walk_pgd_range(start, end, walk);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "walk_page_test",
          "args": [
            "start",
            "next",
            "walk"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "walk_page_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
          "lines": "219-242",
          "snippet": "static int walk_page_test(unsigned long start, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\n\tif (walk->test_walk)\n\t\treturn walk->test_walk(start, end, walk);\n\n\t/*\n\t * vma(VM_PFNMAP) doesn't have any valid struct pages behind VM_PFNMAP\n\t * range, so we don't walk over it as we do for normal vmas. However,\n\t * Some callers are interested in handling hole range and they don't\n\t * want to just ignore any single address range. Such users certainly\n\t * define their ->pte_hole() callbacks, so let's delegate them to handle\n\t * vma(VM_PFNMAP).\n\t */\n\tif (vma->vm_flags & VM_PFNMAP) {\n\t\tint err = 1;\n\t\tif (walk->pte_hole)\n\t\t\terr = walk->pte_hole(start, end, walk);\n\t\treturn err ? err : 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic int walk_page_test(unsigned long start, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\n\tif (walk->test_walk)\n\t\treturn walk->test_walk(start, end, walk);\n\n\t/*\n\t * vma(VM_PFNMAP) doesn't have any valid struct pages behind VM_PFNMAP\n\t * range, so we don't walk over it as we do for normal vmas. However,\n\t * Some callers are interested in handling hole range and they don't\n\t * want to just ignore any single address range. Such users certainly\n\t * define their ->pte_hole() callbacks, so let's delegate them to handle\n\t * vma(VM_PFNMAP).\n\t */\n\tif (vma->vm_flags & VM_PFNMAP) {\n\t\tint err = 1;\n\t\tif (walk->pte_hole)\n\t\t\terr = walk->pte_hole(start, end, walk);\n\t\treturn err ? err : 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "end",
            "vma->vm_end"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "walk->mm",
            "start"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "775-796",
          "snippet": "struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_MM",
          "args": [
            "!rwsem_is_locked(&walk->mm->mmap_sem)",
            "walk->mm"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwsem_is_locked",
          "args": [
            "&walk->mm->mmap_sem"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nint walk_page_range(unsigned long start, unsigned long end,\n\t\t    struct mm_walk *walk)\n{\n\tint err = 0;\n\tunsigned long next;\n\tstruct vm_area_struct *vma;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tif (!walk->mm)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON_MM(!rwsem_is_locked(&walk->mm->mmap_sem), walk->mm);\n\n\tvma = find_vma(walk->mm, start);\n\tdo {\n\t\tif (!vma) { /* after the last vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = end;\n\t\t} else if (start < vma->vm_start) { /* outside vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = min(end, vma->vm_start);\n\t\t} else { /* inside vma */\n\t\t\twalk->vma = vma;\n\t\t\tnext = min(end, vma->vm_end);\n\t\t\tvma = vma->vm_next;\n\n\t\t\terr = walk_page_test(start, next, walk);\n\t\t\tif (err > 0) {\n\t\t\t\t/*\n\t\t\t\t * positive return values are purely for\n\t\t\t\t * controlling the pagewalk, so should never\n\t\t\t\t * be passed to the callers.\n\t\t\t\t */\n\t\t\t\terr = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (walk->vma || walk->pte_hole)\n\t\t\terr = __walk_page_range(start, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (start = next, start < end);\n\treturn err;\n}"
  },
  {
    "function_name": "__walk_page_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
    "lines": "244-257",
    "snippet": "static int __walk_page_range(unsigned long start, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tint err = 0;\n\tstruct vm_area_struct *vma = walk->vma;\n\n\tif (vma && is_vm_hugetlb_page(vma)) {\n\t\tif (walk->hugetlb_entry)\n\t\t\terr = walk_hugetlb_range(start, end, walk);\n\t} else\n\t\terr = walk_pgd_range(start, end, walk);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_pgd_range",
          "args": [
            "start",
            "end",
            "walk"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "walk_pgd_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
          "lines": "143-167",
          "snippet": "static int walk_pgd_range(unsigned long addr, unsigned long end,\n\t\t\t  struct mm_walk *walk)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\tint err = 0;\n\n\tpgd = pgd_offset(walk->mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd)) {\n\t\t\tif (walk->pte_hole)\n\t\t\t\terr = walk->pte_hole(addr, next, walk);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (walk->pmd_entry || walk->pte_entry)\n\t\t\terr = walk_p4d_range(pgd, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pgd++, addr = next, addr != end);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic int walk_pgd_range(unsigned long addr, unsigned long end,\n\t\t\t  struct mm_walk *walk)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\tint err = 0;\n\n\tpgd = pgd_offset(walk->mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd)) {\n\t\t\tif (walk->pte_hole)\n\t\t\t\terr = walk->pte_hole(addr, next, walk);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (walk->pmd_entry || walk->pte_entry)\n\t\t\terr = walk_p4d_range(pgd, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pgd++, addr = next, addr != end);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "walk_hugetlb_range",
          "args": [
            "start",
            "end",
            "walk"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "walk_hugetlb_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
          "lines": "205-209",
          "snippet": "static int walk_hugetlb_range(unsigned long addr, unsigned long end,\n\t\t\t      struct mm_walk *walk)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic int walk_hugetlb_range(unsigned long addr, unsigned long end,\n\t\t\t      struct mm_walk *walk)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic int __walk_page_range(unsigned long start, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tint err = 0;\n\tstruct vm_area_struct *vma = walk->vma;\n\n\tif (vma && is_vm_hugetlb_page(vma)) {\n\t\tif (walk->hugetlb_entry)\n\t\t\terr = walk_hugetlb_range(start, end, walk);\n\t} else\n\t\terr = walk_pgd_range(start, end, walk);\n\n\treturn err;\n}"
  },
  {
    "function_name": "walk_page_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
    "lines": "219-242",
    "snippet": "static int walk_page_test(unsigned long start, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\n\tif (walk->test_walk)\n\t\treturn walk->test_walk(start, end, walk);\n\n\t/*\n\t * vma(VM_PFNMAP) doesn't have any valid struct pages behind VM_PFNMAP\n\t * range, so we don't walk over it as we do for normal vmas. However,\n\t * Some callers are interested in handling hole range and they don't\n\t * want to just ignore any single address range. Such users certainly\n\t * define their ->pte_hole() callbacks, so let's delegate them to handle\n\t * vma(VM_PFNMAP).\n\t */\n\tif (vma->vm_flags & VM_PFNMAP) {\n\t\tint err = 1;\n\t\tif (walk->pte_hole)\n\t\t\terr = walk->pte_hole(start, end, walk);\n\t\treturn err ? err : 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk->pte_hole",
          "args": [
            "start",
            "end",
            "walk"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk->test_walk",
          "args": [
            "start",
            "end",
            "walk"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic int walk_page_test(unsigned long start, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\n\tif (walk->test_walk)\n\t\treturn walk->test_walk(start, end, walk);\n\n\t/*\n\t * vma(VM_PFNMAP) doesn't have any valid struct pages behind VM_PFNMAP\n\t * range, so we don't walk over it as we do for normal vmas. However,\n\t * Some callers are interested in handling hole range and they don't\n\t * want to just ignore any single address range. Such users certainly\n\t * define their ->pte_hole() callbacks, so let's delegate them to handle\n\t * vma(VM_PFNMAP).\n\t */\n\tif (vma->vm_flags & VM_PFNMAP) {\n\t\tint err = 1;\n\t\tif (walk->pte_hole)\n\t\t\terr = walk->pte_hole(start, end, walk);\n\t\treturn err ? err : 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "walk_hugetlb_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
    "lines": "205-209",
    "snippet": "static int walk_hugetlb_range(unsigned long addr, unsigned long end,\n\t\t\t      struct mm_walk *walk)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic int walk_hugetlb_range(unsigned long addr, unsigned long end,\n\t\t\t      struct mm_walk *walk)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "walk_hugetlb_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
    "lines": "177-202",
    "snippet": "static int walk_hugetlb_range(unsigned long addr, unsigned long end,\n\t\t\t      struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct hstate *h = hstate_vma(vma);\n\tunsigned long next;\n\tunsigned long hmask = huge_page_mask(h);\n\tunsigned long sz = huge_page_size(h);\n\tpte_t *pte;\n\tint err = 0;\n\n\tdo {\n\t\tnext = hugetlb_entry_end(h, addr, end);\n\t\tpte = huge_pte_offset(walk->mm, addr & hmask, sz);\n\n\t\tif (pte)\n\t\t\terr = walk->hugetlb_entry(pte, hmask, addr, next, walk);\n\t\telse if (walk->pte_hole)\n\t\t\terr = walk->pte_hole(addr, next, walk);\n\n\t\tif (err)\n\t\t\tbreak;\n\t} while (addr = next, addr != end);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk->pte_hole",
          "args": [
            "addr",
            "next",
            "walk"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk->hugetlb_entry",
          "args": [
            "pte",
            "hmask",
            "addr",
            "next",
            "walk"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_offset",
          "args": [
            "walk->mm",
            "addr & hmask",
            "sz"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pte_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4782-4812",
          "snippet": "pte_t *huge_pte_offset(struct mm_struct *mm,\n\t\t       unsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tif (!pgd_present(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (!p4d_present(*p4d))\n\t\treturn NULL;\n\n\tpud = pud_offset(p4d, addr);\n\tif (sz != PUD_SIZE && pud_none(*pud))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pud_huge(*pud) || !pud_present(*pud))\n\t\treturn (pte_t *)pud;\n\n\tpmd = pmd_offset(pud, addr);\n\tif (sz != PMD_SIZE && pmd_none(*pmd))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pmd_huge(*pmd) || !pmd_present(*pmd))\n\t\treturn (pte_t *)pmd;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\npte_t *huge_pte_offset(struct mm_struct *mm,\n\t\t       unsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tif (!pgd_present(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (!p4d_present(*p4d))\n\t\treturn NULL;\n\n\tpud = pud_offset(p4d, addr);\n\tif (sz != PUD_SIZE && pud_none(*pud))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pud_huge(*pud) || !pud_present(*pud))\n\t\treturn (pte_t *)pud;\n\n\tpmd = pmd_offset(pud, addr);\n\tif (sz != PMD_SIZE && pmd_none(*pmd))\n\t\treturn NULL;\n\t/* hugepage or swap? */\n\tif (pmd_huge(*pmd) || !pmd_present(*pmd))\n\t\treturn (pte_t *)pmd;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugetlb_entry_end",
          "args": [
            "h",
            "addr",
            "end"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_entry_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
          "lines": "170-175",
          "snippet": "static unsigned long hugetlb_entry_end(struct hstate *h, unsigned long addr,\n\t\t\t\t       unsigned long end)\n{\n\tunsigned long boundary = (addr & huge_page_mask(h)) + huge_page_size(h);\n\treturn boundary < end ? boundary : end;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic unsigned long hugetlb_entry_end(struct hstate *h, unsigned long addr,\n\t\t\t\t       unsigned long end)\n{\n\tunsigned long boundary = (addr & huge_page_mask(h)) + huge_page_size(h);\n\treturn boundary < end ? boundary : end;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "h"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_mask",
          "args": [
            "h"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_vma",
          "args": [
            "vma"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic int walk_hugetlb_range(unsigned long addr, unsigned long end,\n\t\t\t      struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct hstate *h = hstate_vma(vma);\n\tunsigned long next;\n\tunsigned long hmask = huge_page_mask(h);\n\tunsigned long sz = huge_page_size(h);\n\tpte_t *pte;\n\tint err = 0;\n\n\tdo {\n\t\tnext = hugetlb_entry_end(h, addr, end);\n\t\tpte = huge_pte_offset(walk->mm, addr & hmask, sz);\n\n\t\tif (pte)\n\t\t\terr = walk->hugetlb_entry(pte, hmask, addr, next, walk);\n\t\telse if (walk->pte_hole)\n\t\t\terr = walk->pte_hole(addr, next, walk);\n\n\t\tif (err)\n\t\t\tbreak;\n\t} while (addr = next, addr != end);\n\n\treturn err;\n}"
  },
  {
    "function_name": "hugetlb_entry_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
    "lines": "170-175",
    "snippet": "static unsigned long hugetlb_entry_end(struct hstate *h, unsigned long addr,\n\t\t\t\t       unsigned long end)\n{\n\tunsigned long boundary = (addr & huge_page_mask(h)) + huge_page_size(h);\n\treturn boundary < end ? boundary : end;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "h"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_mask",
          "args": [
            "h"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic unsigned long hugetlb_entry_end(struct hstate *h, unsigned long addr,\n\t\t\t\t       unsigned long end)\n{\n\tunsigned long boundary = (addr & huge_page_mask(h)) + huge_page_size(h);\n\treturn boundary < end ? boundary : end;\n}"
  },
  {
    "function_name": "walk_pgd_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
    "lines": "143-167",
    "snippet": "static int walk_pgd_range(unsigned long addr, unsigned long end,\n\t\t\t  struct mm_walk *walk)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\tint err = 0;\n\n\tpgd = pgd_offset(walk->mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd)) {\n\t\t\tif (walk->pte_hole)\n\t\t\t\terr = walk->pte_hole(addr, next, walk);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (walk->pmd_entry || walk->pte_entry)\n\t\t\terr = walk_p4d_range(pgd, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pgd++, addr = next, addr != end);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_p4d_range",
          "args": [
            "pgd",
            "addr",
            "next",
            "walk"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "walk_p4d_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
          "lines": "117-141",
          "snippet": "static int walk_p4d_range(pgd_t *pgd, unsigned long addr, unsigned long end,\n\t\t\t  struct mm_walk *walk)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\tint err = 0;\n\n\tp4d = p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none_or_clear_bad(p4d)) {\n\t\t\tif (walk->pte_hole)\n\t\t\t\terr = walk->pte_hole(addr, next, walk);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (walk->pmd_entry || walk->pte_entry)\n\t\t\terr = walk_pud_range(p4d, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (p4d++, addr = next, addr != end);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic int walk_p4d_range(pgd_t *pgd, unsigned long addr, unsigned long end,\n\t\t\t  struct mm_walk *walk)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\tint err = 0;\n\n\tp4d = p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none_or_clear_bad(p4d)) {\n\t\t\tif (walk->pte_hole)\n\t\t\t\terr = walk->pte_hole(addr, next, walk);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (walk->pmd_entry || walk->pte_entry)\n\t\t\terr = walk_pud_range(p4d, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (p4d++, addr = next, addr != end);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "walk->pte_hole",
          "args": [
            "addr",
            "next",
            "walk"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_none_or_clear_bad",
          "args": [
            "pgd"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_offset",
          "args": [
            "walk->mm",
            "addr"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic int walk_pgd_range(unsigned long addr, unsigned long end,\n\t\t\t  struct mm_walk *walk)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\tint err = 0;\n\n\tpgd = pgd_offset(walk->mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd)) {\n\t\t\tif (walk->pte_hole)\n\t\t\t\terr = walk->pte_hole(addr, next, walk);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (walk->pmd_entry || walk->pte_entry)\n\t\t\terr = walk_p4d_range(pgd, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pgd++, addr = next, addr != end);\n\n\treturn err;\n}"
  },
  {
    "function_name": "walk_p4d_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
    "lines": "117-141",
    "snippet": "static int walk_p4d_range(pgd_t *pgd, unsigned long addr, unsigned long end,\n\t\t\t  struct mm_walk *walk)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\tint err = 0;\n\n\tp4d = p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none_or_clear_bad(p4d)) {\n\t\t\tif (walk->pte_hole)\n\t\t\t\terr = walk->pte_hole(addr, next, walk);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (walk->pmd_entry || walk->pte_entry)\n\t\t\terr = walk_pud_range(p4d, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (p4d++, addr = next, addr != end);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_pud_range",
          "args": [
            "p4d",
            "addr",
            "next",
            "walk"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "walk_pud_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
          "lines": "73-115",
          "snippet": "static int walk_pud_range(p4d_t *p4d, unsigned long addr, unsigned long end,\n\t\t\t  struct mm_walk *walk)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tint err = 0;\n\n\tpud = pud_offset(p4d, addr);\n\tdo {\n again:\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none(*pud) || !walk->vma) {\n\t\t\tif (walk->pte_hole)\n\t\t\t\terr = walk->pte_hole(addr, next, walk);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (walk->pud_entry) {\n\t\t\tspinlock_t *ptl = pud_trans_huge_lock(pud, walk->vma);\n\n\t\t\tif (ptl) {\n\t\t\t\terr = walk->pud_entry(pud, addr, next, walk);\n\t\t\t\tspin_unlock(ptl);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tsplit_huge_pud(walk->vma, pud, addr);\n\t\tif (pud_none(*pud))\n\t\t\tgoto again;\n\n\t\tif (walk->pmd_entry || walk->pte_entry)\n\t\t\terr = walk_pmd_range(pud, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pud++, addr = next, addr != end);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic int walk_pud_range(p4d_t *p4d, unsigned long addr, unsigned long end,\n\t\t\t  struct mm_walk *walk)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tint err = 0;\n\n\tpud = pud_offset(p4d, addr);\n\tdo {\n again:\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none(*pud) || !walk->vma) {\n\t\t\tif (walk->pte_hole)\n\t\t\t\terr = walk->pte_hole(addr, next, walk);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (walk->pud_entry) {\n\t\t\tspinlock_t *ptl = pud_trans_huge_lock(pud, walk->vma);\n\n\t\t\tif (ptl) {\n\t\t\t\terr = walk->pud_entry(pud, addr, next, walk);\n\t\t\t\tspin_unlock(ptl);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tsplit_huge_pud(walk->vma, pud, addr);\n\t\tif (pud_none(*pud))\n\t\t\tgoto again;\n\n\t\tif (walk->pmd_entry || walk->pte_entry)\n\t\t\terr = walk_pmd_range(pud, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pud++, addr = next, addr != end);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "walk->pte_hole",
          "args": [
            "addr",
            "next",
            "walk"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_none_or_clear_bad",
          "args": [
            "p4d"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_offset",
          "args": [
            "pgd",
            "addr"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic int walk_p4d_range(pgd_t *pgd, unsigned long addr, unsigned long end,\n\t\t\t  struct mm_walk *walk)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\tint err = 0;\n\n\tp4d = p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none_or_clear_bad(p4d)) {\n\t\t\tif (walk->pte_hole)\n\t\t\t\terr = walk->pte_hole(addr, next, walk);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (walk->pmd_entry || walk->pte_entry)\n\t\t\terr = walk_pud_range(p4d, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (p4d++, addr = next, addr != end);\n\n\treturn err;\n}"
  },
  {
    "function_name": "walk_pud_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
    "lines": "73-115",
    "snippet": "static int walk_pud_range(p4d_t *p4d, unsigned long addr, unsigned long end,\n\t\t\t  struct mm_walk *walk)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tint err = 0;\n\n\tpud = pud_offset(p4d, addr);\n\tdo {\n again:\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none(*pud) || !walk->vma) {\n\t\t\tif (walk->pte_hole)\n\t\t\t\terr = walk->pte_hole(addr, next, walk);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (walk->pud_entry) {\n\t\t\tspinlock_t *ptl = pud_trans_huge_lock(pud, walk->vma);\n\n\t\t\tif (ptl) {\n\t\t\t\terr = walk->pud_entry(pud, addr, next, walk);\n\t\t\t\tspin_unlock(ptl);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tsplit_huge_pud(walk->vma, pud, addr);\n\t\tif (pud_none(*pud))\n\t\t\tgoto again;\n\n\t\tif (walk->pmd_entry || walk->pte_entry)\n\t\t\terr = walk_pmd_range(pud, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pud++, addr = next, addr != end);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_pmd_range",
          "args": [
            "pud",
            "addr",
            "next",
            "walk"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "walk_pmd_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
          "lines": "28-71",
          "snippet": "static int walk_pmd_range(pud_t *pud, unsigned long addr, unsigned long end,\n\t\t\t  struct mm_walk *walk)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tint err = 0;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\nagain:\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_none(*pmd) || !walk->vma) {\n\t\t\tif (walk->pte_hole)\n\t\t\t\terr = walk->pte_hole(addr, next, walk);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * This implies that each ->pmd_entry() handler\n\t\t * needs to know about pmd_trans_huge() pmds\n\t\t */\n\t\tif (walk->pmd_entry)\n\t\t\terr = walk->pmd_entry(pmd, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Check this here so we only break down trans_huge\n\t\t * pages when we _need_ to\n\t\t */\n\t\tif (!walk->pte_entry)\n\t\t\tcontinue;\n\n\t\tsplit_huge_pmd(walk->vma, pmd, addr);\n\t\tif (pmd_trans_unstable(pmd))\n\t\t\tgoto again;\n\t\terr = walk_pte_range(pmd, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic int walk_pmd_range(pud_t *pud, unsigned long addr, unsigned long end,\n\t\t\t  struct mm_walk *walk)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tint err = 0;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\nagain:\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_none(*pmd) || !walk->vma) {\n\t\t\tif (walk->pte_hole)\n\t\t\t\terr = walk->pte_hole(addr, next, walk);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * This implies that each ->pmd_entry() handler\n\t\t * needs to know about pmd_trans_huge() pmds\n\t\t */\n\t\tif (walk->pmd_entry)\n\t\t\terr = walk->pmd_entry(pmd, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Check this here so we only break down trans_huge\n\t\t * pages when we _need_ to\n\t\t */\n\t\tif (!walk->pte_entry)\n\t\t\tcontinue;\n\n\t\tsplit_huge_pmd(walk->vma, pmd, addr);\n\t\tif (pmd_trans_unstable(pmd))\n\t\t\tgoto again;\n\t\terr = walk_pte_range(pmd, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pud_none",
          "args": [
            "*pud"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split_huge_pud",
          "args": [
            "walk->vma",
            "pud",
            "addr"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "__split_huge_pud",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2027-2048",
          "snippet": "void __split_huge_pud(struct vm_area_struct *vma, pud_t *pud,\n\t\tunsigned long address)\n{\n\tspinlock_t *ptl;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long haddr = address & HPAGE_PUD_MASK;\n\n\tmmu_notifier_invalidate_range_start(mm, haddr, haddr + HPAGE_PUD_SIZE);\n\tptl = pud_lock(mm, pud);\n\tif (unlikely(!pud_trans_huge(*pud) && !pud_devmap(*pud)))\n\t\tgoto out;\n\t__split_huge_pud_locked(vma, pud, haddr);\n\nout:\n\tspin_unlock(ptl);\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback as\n\t * the above pudp_huge_clear_flush_notify() did already call it.\n\t */\n\tmmu_notifier_invalidate_range_only_end(mm, haddr, haddr +\n\t\t\t\t\t       HPAGE_PUD_SIZE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid __split_huge_pud(struct vm_area_struct *vma, pud_t *pud,\n\t\tunsigned long address)\n{\n\tspinlock_t *ptl;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long haddr = address & HPAGE_PUD_MASK;\n\n\tmmu_notifier_invalidate_range_start(mm, haddr, haddr + HPAGE_PUD_SIZE);\n\tptl = pud_lock(mm, pud);\n\tif (unlikely(!pud_trans_huge(*pud) && !pud_devmap(*pud)))\n\t\tgoto out;\n\t__split_huge_pud_locked(vma, pud, haddr);\n\nout:\n\tspin_unlock(ptl);\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback as\n\t * the above pudp_huge_clear_flush_notify() did already call it.\n\t */\n\tmmu_notifier_invalidate_range_only_end(mm, haddr, haddr +\n\t\t\t\t\t       HPAGE_PUD_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk->pud_entry",
          "args": [
            "pud",
            "addr",
            "next",
            "walk"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_trans_huge_lock",
          "args": [
            "pud",
            "walk->vma"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "__pud_trans_huge_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1974-1983",
          "snippet": "spinlock_t *__pud_trans_huge_lock(pud_t *pud, struct vm_area_struct *vma)\n{\n\tspinlock_t *ptl;\n\n\tptl = pud_lock(vma->vm_mm, pud);\n\tif (likely(pud_trans_huge(*pud) || pud_devmap(*pud)))\n\t\treturn ptl;\n\tspin_unlock(ptl);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nspinlock_t *__pud_trans_huge_lock(pud_t *pud, struct vm_area_struct *vma)\n{\n\tspinlock_t *ptl;\n\n\tptl = pud_lock(vma->vm_mm, pud);\n\tif (likely(pud_trans_huge(*pud) || pud_devmap(*pud)))\n\t\treturn ptl;\n\tspin_unlock(ptl);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "walk->pte_hole",
          "args": [
            "addr",
            "next",
            "walk"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_none",
          "args": [
            "*pud"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_offset",
          "args": [
            "p4d",
            "addr"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic int walk_pud_range(p4d_t *p4d, unsigned long addr, unsigned long end,\n\t\t\t  struct mm_walk *walk)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tint err = 0;\n\n\tpud = pud_offset(p4d, addr);\n\tdo {\n again:\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none(*pud) || !walk->vma) {\n\t\t\tif (walk->pte_hole)\n\t\t\t\terr = walk->pte_hole(addr, next, walk);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (walk->pud_entry) {\n\t\t\tspinlock_t *ptl = pud_trans_huge_lock(pud, walk->vma);\n\n\t\t\tif (ptl) {\n\t\t\t\terr = walk->pud_entry(pud, addr, next, walk);\n\t\t\t\tspin_unlock(ptl);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tsplit_huge_pud(walk->vma, pud, addr);\n\t\tif (pud_none(*pud))\n\t\t\tgoto again;\n\n\t\tif (walk->pmd_entry || walk->pte_entry)\n\t\t\terr = walk_pmd_range(pud, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pud++, addr = next, addr != end);\n\n\treturn err;\n}"
  },
  {
    "function_name": "walk_pmd_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
    "lines": "28-71",
    "snippet": "static int walk_pmd_range(pud_t *pud, unsigned long addr, unsigned long end,\n\t\t\t  struct mm_walk *walk)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tint err = 0;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\nagain:\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_none(*pmd) || !walk->vma) {\n\t\t\tif (walk->pte_hole)\n\t\t\t\terr = walk->pte_hole(addr, next, walk);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * This implies that each ->pmd_entry() handler\n\t\t * needs to know about pmd_trans_huge() pmds\n\t\t */\n\t\tif (walk->pmd_entry)\n\t\t\terr = walk->pmd_entry(pmd, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Check this here so we only break down trans_huge\n\t\t * pages when we _need_ to\n\t\t */\n\t\tif (!walk->pte_entry)\n\t\t\tcontinue;\n\n\t\tsplit_huge_pmd(walk->vma, pmd, addr);\n\t\tif (pmd_trans_unstable(pmd))\n\t\t\tgoto again;\n\t\terr = walk_pte_range(pmd, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_pte_range",
          "args": [
            "pmd",
            "addr",
            "next",
            "walk"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "walk_pte_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
          "lines": "7-26",
          "snippet": "static int walk_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\t  struct mm_walk *walk)\n{\n\tpte_t *pte;\n\tint err = 0;\n\n\tpte = pte_offset_map(pmd, addr);\n\tfor (;;) {\n\t\terr = walk->pte_entry(pte, addr, addr + PAGE_SIZE, walk);\n\t\tif (err)\n\t\t       break;\n\t\taddr += PAGE_SIZE;\n\t\tif (addr == end)\n\t\t\tbreak;\n\t\tpte++;\n\t}\n\n\tpte_unmap(pte);\n\treturn err;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic int walk_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\t  struct mm_walk *walk)\n{\n\tpte_t *pte;\n\tint err = 0;\n\n\tpte = pte_offset_map(pmd, addr);\n\tfor (;;) {\n\t\terr = walk->pte_entry(pte, addr, addr + PAGE_SIZE, walk);\n\t\tif (err)\n\t\t       break;\n\t\taddr += PAGE_SIZE;\n\t\tif (addr == end)\n\t\t\tbreak;\n\t\tpte++;\n\t}\n\n\tpte_unmap(pte);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_trans_unstable",
          "args": [
            "pmd"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split_huge_pmd",
          "args": [
            "walk->vma",
            "pmd",
            "addr"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk->pmd_entry",
          "args": [
            "pmd",
            "addr",
            "next",
            "walk"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk->pte_hole",
          "args": [
            "addr",
            "next",
            "walk"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "*pmd"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_offset",
          "args": [
            "pud",
            "addr"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic int walk_pmd_range(pud_t *pud, unsigned long addr, unsigned long end,\n\t\t\t  struct mm_walk *walk)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tint err = 0;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\nagain:\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_none(*pmd) || !walk->vma) {\n\t\t\tif (walk->pte_hole)\n\t\t\t\terr = walk->pte_hole(addr, next, walk);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * This implies that each ->pmd_entry() handler\n\t\t * needs to know about pmd_trans_huge() pmds\n\t\t */\n\t\tif (walk->pmd_entry)\n\t\t\terr = walk->pmd_entry(pmd, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Check this here so we only break down trans_huge\n\t\t * pages when we _need_ to\n\t\t */\n\t\tif (!walk->pte_entry)\n\t\t\tcontinue;\n\n\t\tsplit_huge_pmd(walk->vma, pmd, addr);\n\t\tif (pmd_trans_unstable(pmd))\n\t\t\tgoto again;\n\t\terr = walk_pte_range(pmd, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn err;\n}"
  },
  {
    "function_name": "walk_pte_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
    "lines": "7-26",
    "snippet": "static int walk_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\t  struct mm_walk *walk)\n{\n\tpte_t *pte;\n\tint err = 0;\n\n\tpte = pte_offset_map(pmd, addr);\n\tfor (;;) {\n\t\terr = walk->pte_entry(pte, addr, addr + PAGE_SIZE, walk);\n\t\tif (err)\n\t\t       break;\n\t\taddr += PAGE_SIZE;\n\t\tif (addr == end)\n\t\t\tbreak;\n\t\tpte++;\n\t}\n\n\tpte_unmap(pte);\n\treturn err;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_unmap",
          "args": [
            "pte"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk->pte_entry",
          "args": [
            "pte",
            "addr",
            "addr + PAGE_SIZE",
            "walk"
          ],
          "line": 15
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map",
          "args": [
            "pmd",
            "addr"
          ],
          "line": 13
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic int walk_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\t  struct mm_walk *walk)\n{\n\tpte_t *pte;\n\tint err = 0;\n\n\tpte = pte_offset_map(pmd, addr);\n\tfor (;;) {\n\t\terr = walk->pte_entry(pte, addr, addr + PAGE_SIZE, walk);\n\t\tif (err)\n\t\t       break;\n\t\taddr += PAGE_SIZE;\n\t\tif (addr == end)\n\t\t\tbreak;\n\t\tpte++;\n\t}\n\n\tpte_unmap(pte);\n\treturn err;\n}"
  }
]