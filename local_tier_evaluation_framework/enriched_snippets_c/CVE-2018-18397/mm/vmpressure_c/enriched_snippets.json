[
  {
    "function_name": "vmpressure_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmpressure.c",
    "lines": "465-472",
    "snippet": "void vmpressure_cleanup(struct vmpressure *vmpr)\n{\n\t/*\n\t * Make sure there is no pending work before eventfd infrastructure\n\t * goes away.\n\t */\n\tflush_work(&vmpr->work);\n}",
    "includes": [
      "#include <linux/vmpressure.h>",
      "#include <linux/printk.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_work",
          "args": [
            "&vmpr->work"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmpressure.h>\n#include <linux/printk.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/eventfd.h>\n#include <linux/vmstat.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n\nvoid vmpressure_cleanup(struct vmpressure *vmpr)\n{\n\t/*\n\t * Make sure there is no pending work before eventfd infrastructure\n\t * goes away.\n\t */\n\tflush_work(&vmpr->work);\n}"
  },
  {
    "function_name": "vmpressure_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmpressure.c",
    "lines": "450-456",
    "snippet": "void vmpressure_init(struct vmpressure *vmpr)\n{\n\tspin_lock_init(&vmpr->sr_lock);\n\tmutex_init(&vmpr->events_lock);\n\tINIT_LIST_HEAD(&vmpr->events);\n\tINIT_WORK(&vmpr->work, vmpressure_work_fn);\n}",
    "includes": [
      "#include <linux/vmpressure.h>",
      "#include <linux/printk.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&vmpr->work",
            "vmpressure_work_fn"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&vmpr->events"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&vmpr->events_lock"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&vmpr->sr_lock"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmpressure.h>\n#include <linux/printk.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/eventfd.h>\n#include <linux/vmstat.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n\nvoid vmpressure_init(struct vmpressure *vmpr)\n{\n\tspin_lock_init(&vmpr->sr_lock);\n\tmutex_init(&vmpr->events_lock);\n\tINIT_LIST_HEAD(&vmpr->events);\n\tINIT_WORK(&vmpr->work, vmpressure_work_fn);\n}"
  },
  {
    "function_name": "vmpressure_unregister_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmpressure.c",
    "lines": "426-441",
    "snippet": "void vmpressure_unregister_event(struct mem_cgroup *memcg,\n\t\t\t\t struct eventfd_ctx *eventfd)\n{\n\tstruct vmpressure *vmpr = memcg_to_vmpressure(memcg);\n\tstruct vmpressure_event *ev;\n\n\tmutex_lock(&vmpr->events_lock);\n\tlist_for_each_entry(ev, &vmpr->events, node) {\n\t\tif (ev->efd != eventfd)\n\t\t\tcontinue;\n\t\tlist_del(&ev->node);\n\t\tkfree(ev);\n\t\tbreak;\n\t}\n\tmutex_unlock(&vmpr->events_lock);\n}",
    "includes": [
      "#include <linux/vmpressure.h>",
      "#include <linux/printk.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vmpr->events_lock"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ev"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ev->node"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ev",
            "&vmpr->events",
            "node"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vmpr->events_lock"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_to_vmpressure",
          "args": [
            "memcg"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_to_vmpressure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "252-257",
          "snippet": "struct vmpressure *memcg_to_vmpressure(struct mem_cgroup *memcg)\n{\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\treturn &memcg->vmpressure;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct vmpressure *memcg_to_vmpressure(struct mem_cgroup *memcg)\n{\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\treturn &memcg->vmpressure;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/vmpressure.h>\n#include <linux/printk.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/eventfd.h>\n#include <linux/vmstat.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n\nvoid vmpressure_unregister_event(struct mem_cgroup *memcg,\n\t\t\t\t struct eventfd_ctx *eventfd)\n{\n\tstruct vmpressure *vmpr = memcg_to_vmpressure(memcg);\n\tstruct vmpressure_event *ev;\n\n\tmutex_lock(&vmpr->events_lock);\n\tlist_for_each_entry(ev, &vmpr->events, node) {\n\t\tif (ev->efd != eventfd)\n\t\t\tcontinue;\n\t\tlist_del(&ev->node);\n\t\tkfree(ev);\n\t\tbreak;\n\t}\n\tmutex_unlock(&vmpr->events_lock);\n}"
  },
  {
    "function_name": "vmpressure_register_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmpressure.c",
    "lines": "362-413",
    "snippet": "int vmpressure_register_event(struct mem_cgroup *memcg,\n\t\t\t      struct eventfd_ctx *eventfd, const char *args)\n{\n\tstruct vmpressure *vmpr = memcg_to_vmpressure(memcg);\n\tstruct vmpressure_event *ev;\n\tenum vmpressure_modes mode = VMPRESSURE_NO_PASSTHROUGH;\n\tenum vmpressure_levels level = -1;\n\tchar *spec, *spec_orig;\n\tchar *token;\n\tint ret = 0;\n\n\tspec_orig = spec = kstrndup(args, MAX_VMPRESSURE_ARGS_LEN, GFP_KERNEL);\n\tif (!spec) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* Find required level */\n\ttoken = strsep(&spec, \",\");\n\tlevel = match_string(vmpressure_str_levels, VMPRESSURE_NUM_LEVELS, token);\n\tif (level < 0) {\n\t\tret = level;\n\t\tgoto out;\n\t}\n\n\t/* Find optional mode */\n\ttoken = strsep(&spec, \",\");\n\tif (token) {\n\t\tmode = match_string(vmpressure_str_modes, VMPRESSURE_NUM_MODES, token);\n\t\tif (mode < 0) {\n\t\t\tret = mode;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tev = kzalloc(sizeof(*ev), GFP_KERNEL);\n\tif (!ev) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tev->efd = eventfd;\n\tev->level = level;\n\tev->mode = mode;\n\n\tmutex_lock(&vmpr->events_lock);\n\tlist_add(&ev->node, &vmpr->events);\n\tmutex_unlock(&vmpr->events_lock);\nout:\n\tkfree(spec_orig);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/vmpressure.h>",
      "#include <linux/printk.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [
      "#define MAX_VMPRESSURE_ARGS_LEN\t(strlen(\"critical\") + strlen(\"hierarchy\") + 2)"
    ],
    "globals_used": [
      "static const char * const vmpressure_str_levels[] = {\n\t[VMPRESSURE_LOW] = \"low\",\n\t[VMPRESSURE_MEDIUM] = \"medium\",\n\t[VMPRESSURE_CRITICAL] = \"critical\",\n};",
      "static const char * const vmpressure_str_modes[] = {\n\t[VMPRESSURE_NO_PASSTHROUGH] = \"default\",\n\t[VMPRESSURE_HIERARCHY] = \"hierarchy\",\n\t[VMPRESSURE_LOCAL] = \"local\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "spec_orig"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vmpr->events_lock"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ev->node",
            "&vmpr->events"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vmpr->events_lock"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ev)",
            "GFP_KERNEL"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_string",
          "args": [
            "vmpressure_str_modes",
            "VMPRESSURE_NUM_MODES",
            "token"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&spec",
            "\",\""
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_string",
          "args": [
            "vmpressure_str_levels",
            "VMPRESSURE_NUM_LEVELS",
            "token"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&spec",
            "\",\""
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrndup",
          "args": [
            "args",
            "MAX_VMPRESSURE_ARGS_LEN",
            "GFP_KERNEL"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "kstrndup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "82-97",
          "snippet": "char *kstrndup(const char *s, size_t max, gfp_t gfp)\n{\n\tsize_t len;\n\tchar *buf;\n\n\tif (!s)\n\t\treturn NULL;\n\n\tlen = strnlen(s, max);\n\tbuf = kmalloc_track_caller(len+1, gfp);\n\tif (buf) {\n\t\tmemcpy(buf, s, len);\n\t\tbuf[len] = '\\0';\n\t}\n\treturn buf;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nchar *kstrndup(const char *s, size_t max, gfp_t gfp)\n{\n\tsize_t len;\n\tchar *buf;\n\n\tif (!s)\n\t\treturn NULL;\n\n\tlen = strnlen(s, max);\n\tbuf = kmalloc_track_caller(len+1, gfp);\n\tif (buf) {\n\t\tmemcpy(buf, s, len);\n\t\tbuf[len] = '\\0';\n\t}\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_to_vmpressure",
          "args": [
            "memcg"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_to_vmpressure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "252-257",
          "snippet": "struct vmpressure *memcg_to_vmpressure(struct mem_cgroup *memcg)\n{\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\treturn &memcg->vmpressure;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct vmpressure *memcg_to_vmpressure(struct mem_cgroup *memcg)\n{\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\treturn &memcg->vmpressure;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/vmpressure.h>\n#include <linux/printk.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/eventfd.h>\n#include <linux/vmstat.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n\n#define MAX_VMPRESSURE_ARGS_LEN\t(strlen(\"critical\") + strlen(\"hierarchy\") + 2)\n\nstatic const char * const vmpressure_str_levels[] = {\n\t[VMPRESSURE_LOW] = \"low\",\n\t[VMPRESSURE_MEDIUM] = \"medium\",\n\t[VMPRESSURE_CRITICAL] = \"critical\",\n};\nstatic const char * const vmpressure_str_modes[] = {\n\t[VMPRESSURE_NO_PASSTHROUGH] = \"default\",\n\t[VMPRESSURE_HIERARCHY] = \"hierarchy\",\n\t[VMPRESSURE_LOCAL] = \"local\",\n};\n\nint vmpressure_register_event(struct mem_cgroup *memcg,\n\t\t\t      struct eventfd_ctx *eventfd, const char *args)\n{\n\tstruct vmpressure *vmpr = memcg_to_vmpressure(memcg);\n\tstruct vmpressure_event *ev;\n\tenum vmpressure_modes mode = VMPRESSURE_NO_PASSTHROUGH;\n\tenum vmpressure_levels level = -1;\n\tchar *spec, *spec_orig;\n\tchar *token;\n\tint ret = 0;\n\n\tspec_orig = spec = kstrndup(args, MAX_VMPRESSURE_ARGS_LEN, GFP_KERNEL);\n\tif (!spec) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* Find required level */\n\ttoken = strsep(&spec, \",\");\n\tlevel = match_string(vmpressure_str_levels, VMPRESSURE_NUM_LEVELS, token);\n\tif (level < 0) {\n\t\tret = level;\n\t\tgoto out;\n\t}\n\n\t/* Find optional mode */\n\ttoken = strsep(&spec, \",\");\n\tif (token) {\n\t\tmode = match_string(vmpressure_str_modes, VMPRESSURE_NUM_MODES, token);\n\t\tif (mode < 0) {\n\t\t\tret = mode;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tev = kzalloc(sizeof(*ev), GFP_KERNEL);\n\tif (!ev) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tev->efd = eventfd;\n\tev->level = level;\n\tev->mode = mode;\n\n\tmutex_lock(&vmpr->events_lock);\n\tlist_add(&ev->node, &vmpr->events);\n\tmutex_unlock(&vmpr->events_lock);\nout:\n\tkfree(spec_orig);\n\treturn ret;\n}"
  },
  {
    "function_name": "vmpressure_prio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmpressure.c",
    "lines": "326-343",
    "snippet": "void vmpressure_prio(gfp_t gfp, struct mem_cgroup *memcg, int prio)\n{\n\t/*\n\t * We only use prio for accounting critical level. For more info\n\t * see comment for vmpressure_level_critical_prio variable above.\n\t */\n\tif (prio > vmpressure_level_critical_prio)\n\t\treturn;\n\n\t/*\n\t * OK, the prio is below the threshold, updating vmpressure\n\t * information before shrinker dives into long shrinking of long\n\t * range vmscan. Passing scanned = vmpressure_win, reclaimed = 0\n\t * to the vmpressure() basically means that we signal 'critical'\n\t * level.\n\t */\n\tvmpressure(gfp, memcg, true, vmpressure_win, 0);\n}",
    "includes": [
      "#include <linux/vmpressure.h>",
      "#include <linux/printk.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const unsigned long vmpressure_win = SWAP_CLUSTER_MAX * 16;",
      "static const unsigned int vmpressure_level_critical_prio = ilog2(100 / 10);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmpressure",
          "args": [
            "gfp",
            "memcg",
            "true",
            "vmpressure_win",
            "0"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "vmpressure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmpressure.c",
          "lines": "243-313",
          "snippet": "void vmpressure(gfp_t gfp, struct mem_cgroup *memcg, bool tree,\n\t\tunsigned long scanned, unsigned long reclaimed)\n{\n\tstruct vmpressure *vmpr = memcg_to_vmpressure(memcg);\n\n\t/*\n\t * Here we only want to account pressure that userland is able to\n\t * help us with. For example, suppose that DMA zone is under\n\t * pressure; if we notify userland about that kind of pressure,\n\t * then it will be mostly a waste as it will trigger unnecessary\n\t * freeing of memory by userland (since userland is more likely to\n\t * have HIGHMEM/MOVABLE pages instead of the DMA fallback). That\n\t * is why we include only movable, highmem and FS/IO pages.\n\t * Indirect reclaim (kswapd) sets sc->gfp_mask to GFP_KERNEL, so\n\t * we account it too.\n\t */\n\tif (!(gfp & (__GFP_HIGHMEM | __GFP_MOVABLE | __GFP_IO | __GFP_FS)))\n\t\treturn;\n\n\t/*\n\t * If we got here with no pages scanned, then that is an indicator\n\t * that reclaimer was unable to find any shrinkable LRUs at the\n\t * current scanning depth. But it does not mean that we should\n\t * report the critical pressure, yet. If the scanning priority\n\t * (scanning depth) goes too high (deep), we will be notified\n\t * through vmpressure_prio(). But so far, keep calm.\n\t */\n\tif (!scanned)\n\t\treturn;\n\n\tif (tree) {\n\t\tspin_lock(&vmpr->sr_lock);\n\t\tscanned = vmpr->tree_scanned += scanned;\n\t\tvmpr->tree_reclaimed += reclaimed;\n\t\tspin_unlock(&vmpr->sr_lock);\n\n\t\tif (scanned < vmpressure_win)\n\t\t\treturn;\n\t\tschedule_work(&vmpr->work);\n\t} else {\n\t\tenum vmpressure_levels level;\n\n\t\t/* For now, no users for root-level efficiency */\n\t\tif (!memcg || memcg == root_mem_cgroup)\n\t\t\treturn;\n\n\t\tspin_lock(&vmpr->sr_lock);\n\t\tscanned = vmpr->scanned += scanned;\n\t\treclaimed = vmpr->reclaimed += reclaimed;\n\t\tif (scanned < vmpressure_win) {\n\t\t\tspin_unlock(&vmpr->sr_lock);\n\t\t\treturn;\n\t\t}\n\t\tvmpr->scanned = vmpr->reclaimed = 0;\n\t\tspin_unlock(&vmpr->sr_lock);\n\n\t\tlevel = vmpressure_calc_level(scanned, reclaimed);\n\n\t\tif (level > VMPRESSURE_LOW) {\n\t\t\t/*\n\t\t\t * Let the socket buffer allocator know that\n\t\t\t * we are having trouble reclaiming LRU pages.\n\t\t\t *\n\t\t\t * For hysteresis keep the pressure state\n\t\t\t * asserted for a second in which subsequent\n\t\t\t * pressure events can occur.\n\t\t\t */\n\t\t\tmemcg->socket_pressure = jiffies + HZ;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/vmpressure.h>",
            "#include <linux/printk.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned long vmpressure_win = SWAP_CLUSTER_MAX * 16;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmpressure.h>\n#include <linux/printk.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/eventfd.h>\n#include <linux/vmstat.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n\nstatic const unsigned long vmpressure_win = SWAP_CLUSTER_MAX * 16;\n\nvoid vmpressure(gfp_t gfp, struct mem_cgroup *memcg, bool tree,\n\t\tunsigned long scanned, unsigned long reclaimed)\n{\n\tstruct vmpressure *vmpr = memcg_to_vmpressure(memcg);\n\n\t/*\n\t * Here we only want to account pressure that userland is able to\n\t * help us with. For example, suppose that DMA zone is under\n\t * pressure; if we notify userland about that kind of pressure,\n\t * then it will be mostly a waste as it will trigger unnecessary\n\t * freeing of memory by userland (since userland is more likely to\n\t * have HIGHMEM/MOVABLE pages instead of the DMA fallback). That\n\t * is why we include only movable, highmem and FS/IO pages.\n\t * Indirect reclaim (kswapd) sets sc->gfp_mask to GFP_KERNEL, so\n\t * we account it too.\n\t */\n\tif (!(gfp & (__GFP_HIGHMEM | __GFP_MOVABLE | __GFP_IO | __GFP_FS)))\n\t\treturn;\n\n\t/*\n\t * If we got here with no pages scanned, then that is an indicator\n\t * that reclaimer was unable to find any shrinkable LRUs at the\n\t * current scanning depth. But it does not mean that we should\n\t * report the critical pressure, yet. If the scanning priority\n\t * (scanning depth) goes too high (deep), we will be notified\n\t * through vmpressure_prio(). But so far, keep calm.\n\t */\n\tif (!scanned)\n\t\treturn;\n\n\tif (tree) {\n\t\tspin_lock(&vmpr->sr_lock);\n\t\tscanned = vmpr->tree_scanned += scanned;\n\t\tvmpr->tree_reclaimed += reclaimed;\n\t\tspin_unlock(&vmpr->sr_lock);\n\n\t\tif (scanned < vmpressure_win)\n\t\t\treturn;\n\t\tschedule_work(&vmpr->work);\n\t} else {\n\t\tenum vmpressure_levels level;\n\n\t\t/* For now, no users for root-level efficiency */\n\t\tif (!memcg || memcg == root_mem_cgroup)\n\t\t\treturn;\n\n\t\tspin_lock(&vmpr->sr_lock);\n\t\tscanned = vmpr->scanned += scanned;\n\t\treclaimed = vmpr->reclaimed += reclaimed;\n\t\tif (scanned < vmpressure_win) {\n\t\t\tspin_unlock(&vmpr->sr_lock);\n\t\t\treturn;\n\t\t}\n\t\tvmpr->scanned = vmpr->reclaimed = 0;\n\t\tspin_unlock(&vmpr->sr_lock);\n\n\t\tlevel = vmpressure_calc_level(scanned, reclaimed);\n\n\t\tif (level > VMPRESSURE_LOW) {\n\t\t\t/*\n\t\t\t * Let the socket buffer allocator know that\n\t\t\t * we are having trouble reclaiming LRU pages.\n\t\t\t *\n\t\t\t * For hysteresis keep the pressure state\n\t\t\t * asserted for a second in which subsequent\n\t\t\t * pressure events can occur.\n\t\t\t */\n\t\t\tmemcg->socket_pressure = jiffies + HZ;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/vmpressure.h>\n#include <linux/printk.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/eventfd.h>\n#include <linux/vmstat.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n\nstatic const unsigned long vmpressure_win = SWAP_CLUSTER_MAX * 16;\nstatic const unsigned int vmpressure_level_critical_prio = ilog2(100 / 10);\n\nvoid vmpressure_prio(gfp_t gfp, struct mem_cgroup *memcg, int prio)\n{\n\t/*\n\t * We only use prio for accounting critical level. For more info\n\t * see comment for vmpressure_level_critical_prio variable above.\n\t */\n\tif (prio > vmpressure_level_critical_prio)\n\t\treturn;\n\n\t/*\n\t * OK, the prio is below the threshold, updating vmpressure\n\t * information before shrinker dives into long shrinking of long\n\t * range vmscan. Passing scanned = vmpressure_win, reclaimed = 0\n\t * to the vmpressure() basically means that we signal 'critical'\n\t * level.\n\t */\n\tvmpressure(gfp, memcg, true, vmpressure_win, 0);\n}"
  },
  {
    "function_name": "vmpressure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmpressure.c",
    "lines": "243-313",
    "snippet": "void vmpressure(gfp_t gfp, struct mem_cgroup *memcg, bool tree,\n\t\tunsigned long scanned, unsigned long reclaimed)\n{\n\tstruct vmpressure *vmpr = memcg_to_vmpressure(memcg);\n\n\t/*\n\t * Here we only want to account pressure that userland is able to\n\t * help us with. For example, suppose that DMA zone is under\n\t * pressure; if we notify userland about that kind of pressure,\n\t * then it will be mostly a waste as it will trigger unnecessary\n\t * freeing of memory by userland (since userland is more likely to\n\t * have HIGHMEM/MOVABLE pages instead of the DMA fallback). That\n\t * is why we include only movable, highmem and FS/IO pages.\n\t * Indirect reclaim (kswapd) sets sc->gfp_mask to GFP_KERNEL, so\n\t * we account it too.\n\t */\n\tif (!(gfp & (__GFP_HIGHMEM | __GFP_MOVABLE | __GFP_IO | __GFP_FS)))\n\t\treturn;\n\n\t/*\n\t * If we got here with no pages scanned, then that is an indicator\n\t * that reclaimer was unable to find any shrinkable LRUs at the\n\t * current scanning depth. But it does not mean that we should\n\t * report the critical pressure, yet. If the scanning priority\n\t * (scanning depth) goes too high (deep), we will be notified\n\t * through vmpressure_prio(). But so far, keep calm.\n\t */\n\tif (!scanned)\n\t\treturn;\n\n\tif (tree) {\n\t\tspin_lock(&vmpr->sr_lock);\n\t\tscanned = vmpr->tree_scanned += scanned;\n\t\tvmpr->tree_reclaimed += reclaimed;\n\t\tspin_unlock(&vmpr->sr_lock);\n\n\t\tif (scanned < vmpressure_win)\n\t\t\treturn;\n\t\tschedule_work(&vmpr->work);\n\t} else {\n\t\tenum vmpressure_levels level;\n\n\t\t/* For now, no users for root-level efficiency */\n\t\tif (!memcg || memcg == root_mem_cgroup)\n\t\t\treturn;\n\n\t\tspin_lock(&vmpr->sr_lock);\n\t\tscanned = vmpr->scanned += scanned;\n\t\treclaimed = vmpr->reclaimed += reclaimed;\n\t\tif (scanned < vmpressure_win) {\n\t\t\tspin_unlock(&vmpr->sr_lock);\n\t\t\treturn;\n\t\t}\n\t\tvmpr->scanned = vmpr->reclaimed = 0;\n\t\tspin_unlock(&vmpr->sr_lock);\n\n\t\tlevel = vmpressure_calc_level(scanned, reclaimed);\n\n\t\tif (level > VMPRESSURE_LOW) {\n\t\t\t/*\n\t\t\t * Let the socket buffer allocator know that\n\t\t\t * we are having trouble reclaiming LRU pages.\n\t\t\t *\n\t\t\t * For hysteresis keep the pressure state\n\t\t\t * asserted for a second in which subsequent\n\t\t\t * pressure events can occur.\n\t\t\t */\n\t\t\tmemcg->socket_pressure = jiffies + HZ;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/vmpressure.h>",
      "#include <linux/printk.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const unsigned long vmpressure_win = SWAP_CLUSTER_MAX * 16;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmpressure_calc_level",
          "args": [
            "scanned",
            "reclaimed"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "vmpressure_calc_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmpressure.c",
          "lines": "124-152",
          "snippet": "static enum vmpressure_levels vmpressure_calc_level(unsigned long scanned,\n\t\t\t\t\t\t    unsigned long reclaimed)\n{\n\tunsigned long scale = scanned + reclaimed;\n\tunsigned long pressure = 0;\n\n\t/*\n\t * reclaimed can be greater than scanned for things such as reclaimed\n\t * slab pages. shrink_node() just adds reclaimed pages without a\n\t * related increment to scanned pages.\n\t */\n\tif (reclaimed >= scanned)\n\t\tgoto out;\n\t/*\n\t * We calculate the ratio (in percents) of how many pages were\n\t * scanned vs. reclaimed in a given time frame (window). Note that\n\t * time is in VM reclaimer's \"ticks\", i.e. number of pages\n\t * scanned. This makes it possible to set desired reaction time\n\t * and serves as a ratelimit.\n\t */\n\tpressure = scale - (reclaimed * scale / scanned);\n\tpressure = pressure * 100 / scale;\n\nout:\n\tpr_debug(\"%s: %3lu  (s: %lu  r: %lu)\\n\", __func__, pressure,\n\t\t scanned, reclaimed);\n\n\treturn vmpressure_level(pressure);\n}",
          "includes": [
            "#include <linux/vmpressure.h>",
            "#include <linux/printk.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmpressure.h>\n#include <linux/printk.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/eventfd.h>\n#include <linux/vmstat.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n\nstatic enum vmpressure_levels vmpressure_calc_level(unsigned long scanned,\n\t\t\t\t\t\t    unsigned long reclaimed)\n{\n\tunsigned long scale = scanned + reclaimed;\n\tunsigned long pressure = 0;\n\n\t/*\n\t * reclaimed can be greater than scanned for things such as reclaimed\n\t * slab pages. shrink_node() just adds reclaimed pages without a\n\t * related increment to scanned pages.\n\t */\n\tif (reclaimed >= scanned)\n\t\tgoto out;\n\t/*\n\t * We calculate the ratio (in percents) of how many pages were\n\t * scanned vs. reclaimed in a given time frame (window). Note that\n\t * time is in VM reclaimer's \"ticks\", i.e. number of pages\n\t * scanned. This makes it possible to set desired reaction time\n\t * and serves as a ratelimit.\n\t */\n\tpressure = scale - (reclaimed * scale / scanned);\n\tpressure = pressure * 100 / scale;\n\nout:\n\tpr_debug(\"%s: %3lu  (s: %lu  r: %lu)\\n\", __func__, pressure,\n\t\t scanned, reclaimed);\n\n\treturn vmpressure_level(pressure);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vmpr->sr_lock"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vmpr->sr_lock"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vmpr->sr_lock"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&vmpr->work"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vmpr->sr_lock"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vmpr->sr_lock"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_to_vmpressure",
          "args": [
            "memcg"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_to_vmpressure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "252-257",
          "snippet": "struct vmpressure *memcg_to_vmpressure(struct mem_cgroup *memcg)\n{\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\treturn &memcg->vmpressure;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct vmpressure *memcg_to_vmpressure(struct mem_cgroup *memcg)\n{\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\treturn &memcg->vmpressure;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/vmpressure.h>\n#include <linux/printk.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/eventfd.h>\n#include <linux/vmstat.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n\nstatic const unsigned long vmpressure_win = SWAP_CLUSTER_MAX * 16;\n\nvoid vmpressure(gfp_t gfp, struct mem_cgroup *memcg, bool tree,\n\t\tunsigned long scanned, unsigned long reclaimed)\n{\n\tstruct vmpressure *vmpr = memcg_to_vmpressure(memcg);\n\n\t/*\n\t * Here we only want to account pressure that userland is able to\n\t * help us with. For example, suppose that DMA zone is under\n\t * pressure; if we notify userland about that kind of pressure,\n\t * then it will be mostly a waste as it will trigger unnecessary\n\t * freeing of memory by userland (since userland is more likely to\n\t * have HIGHMEM/MOVABLE pages instead of the DMA fallback). That\n\t * is why we include only movable, highmem and FS/IO pages.\n\t * Indirect reclaim (kswapd) sets sc->gfp_mask to GFP_KERNEL, so\n\t * we account it too.\n\t */\n\tif (!(gfp & (__GFP_HIGHMEM | __GFP_MOVABLE | __GFP_IO | __GFP_FS)))\n\t\treturn;\n\n\t/*\n\t * If we got here with no pages scanned, then that is an indicator\n\t * that reclaimer was unable to find any shrinkable LRUs at the\n\t * current scanning depth. But it does not mean that we should\n\t * report the critical pressure, yet. If the scanning priority\n\t * (scanning depth) goes too high (deep), we will be notified\n\t * through vmpressure_prio(). But so far, keep calm.\n\t */\n\tif (!scanned)\n\t\treturn;\n\n\tif (tree) {\n\t\tspin_lock(&vmpr->sr_lock);\n\t\tscanned = vmpr->tree_scanned += scanned;\n\t\tvmpr->tree_reclaimed += reclaimed;\n\t\tspin_unlock(&vmpr->sr_lock);\n\n\t\tif (scanned < vmpressure_win)\n\t\t\treturn;\n\t\tschedule_work(&vmpr->work);\n\t} else {\n\t\tenum vmpressure_levels level;\n\n\t\t/* For now, no users for root-level efficiency */\n\t\tif (!memcg || memcg == root_mem_cgroup)\n\t\t\treturn;\n\n\t\tspin_lock(&vmpr->sr_lock);\n\t\tscanned = vmpr->scanned += scanned;\n\t\treclaimed = vmpr->reclaimed += reclaimed;\n\t\tif (scanned < vmpressure_win) {\n\t\t\tspin_unlock(&vmpr->sr_lock);\n\t\t\treturn;\n\t\t}\n\t\tvmpr->scanned = vmpr->reclaimed = 0;\n\t\tspin_unlock(&vmpr->sr_lock);\n\n\t\tlevel = vmpressure_calc_level(scanned, reclaimed);\n\n\t\tif (level > VMPRESSURE_LOW) {\n\t\t\t/*\n\t\t\t * Let the socket buffer allocator know that\n\t\t\t * we are having trouble reclaiming LRU pages.\n\t\t\t *\n\t\t\t * For hysteresis keep the pressure state\n\t\t\t * asserted for a second in which subsequent\n\t\t\t * pressure events can occur.\n\t\t\t */\n\t\t\tmemcg->socket_pressure = jiffies + HZ;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "vmpressure_work_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmpressure.c",
    "lines": "184-220",
    "snippet": "static void vmpressure_work_fn(struct work_struct *work)\n{\n\tstruct vmpressure *vmpr = work_to_vmpressure(work);\n\tunsigned long scanned;\n\tunsigned long reclaimed;\n\tenum vmpressure_levels level;\n\tbool ancestor = false;\n\tbool signalled = false;\n\n\tspin_lock(&vmpr->sr_lock);\n\t/*\n\t * Several contexts might be calling vmpressure(), so it is\n\t * possible that the work was rescheduled again before the old\n\t * work context cleared the counters. In that case we will run\n\t * just after the old work returns, but then scanned might be zero\n\t * here. No need for any locks here since we don't care if\n\t * vmpr->reclaimed is in sync.\n\t */\n\tscanned = vmpr->tree_scanned;\n\tif (!scanned) {\n\t\tspin_unlock(&vmpr->sr_lock);\n\t\treturn;\n\t}\n\n\treclaimed = vmpr->tree_reclaimed;\n\tvmpr->tree_scanned = 0;\n\tvmpr->tree_reclaimed = 0;\n\tspin_unlock(&vmpr->sr_lock);\n\n\tlevel = vmpressure_calc_level(scanned, reclaimed);\n\n\tdo {\n\t\tif (vmpressure_event(vmpr, level, ancestor, signalled))\n\t\t\tsignalled = true;\n\t\tancestor = true;\n\t} while ((vmpr = vmpressure_parent(vmpr)));\n}",
    "includes": [
      "#include <linux/vmpressure.h>",
      "#include <linux/printk.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmpressure_parent",
          "args": [
            "vmpr"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "vmpressure_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmpressure.c",
          "lines": "78-87",
          "snippet": "static struct vmpressure *vmpressure_parent(struct vmpressure *vmpr)\n{\n\tstruct cgroup_subsys_state *css = vmpressure_to_css(vmpr);\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\n\tmemcg = parent_mem_cgroup(memcg);\n\tif (!memcg)\n\t\treturn NULL;\n\treturn memcg_to_vmpressure(memcg);\n}",
          "includes": [
            "#include <linux/vmpressure.h>",
            "#include <linux/printk.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmpressure.h>\n#include <linux/printk.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/eventfd.h>\n#include <linux/vmstat.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n\nstatic struct vmpressure *vmpressure_parent(struct vmpressure *vmpr)\n{\n\tstruct cgroup_subsys_state *css = vmpressure_to_css(vmpr);\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\n\tmemcg = parent_mem_cgroup(memcg);\n\tif (!memcg)\n\t\treturn NULL;\n\treturn memcg_to_vmpressure(memcg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmpressure_event",
          "args": [
            "vmpr",
            "level",
            "ancestor",
            "signalled"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "vmpressure_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmpressure.c",
          "lines": "161-182",
          "snippet": "static bool vmpressure_event(struct vmpressure *vmpr,\n\t\t\t     const enum vmpressure_levels level,\n\t\t\t     bool ancestor, bool signalled)\n{\n\tstruct vmpressure_event *ev;\n\tbool ret = false;\n\n\tmutex_lock(&vmpr->events_lock);\n\tlist_for_each_entry(ev, &vmpr->events, node) {\n\t\tif (ancestor && ev->mode == VMPRESSURE_LOCAL)\n\t\t\tcontinue;\n\t\tif (signalled && ev->mode == VMPRESSURE_NO_PASSTHROUGH)\n\t\t\tcontinue;\n\t\tif (level < ev->level)\n\t\t\tcontinue;\n\t\teventfd_signal(ev->efd, 1);\n\t\tret = true;\n\t}\n\tmutex_unlock(&vmpr->events_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/vmpressure.h>",
            "#include <linux/printk.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmpressure.h>\n#include <linux/printk.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/eventfd.h>\n#include <linux/vmstat.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n\nstatic bool vmpressure_event(struct vmpressure *vmpr,\n\t\t\t     const enum vmpressure_levels level,\n\t\t\t     bool ancestor, bool signalled)\n{\n\tstruct vmpressure_event *ev;\n\tbool ret = false;\n\n\tmutex_lock(&vmpr->events_lock);\n\tlist_for_each_entry(ev, &vmpr->events, node) {\n\t\tif (ancestor && ev->mode == VMPRESSURE_LOCAL)\n\t\t\tcontinue;\n\t\tif (signalled && ev->mode == VMPRESSURE_NO_PASSTHROUGH)\n\t\t\tcontinue;\n\t\tif (level < ev->level)\n\t\t\tcontinue;\n\t\teventfd_signal(ev->efd, 1);\n\t\tret = true;\n\t}\n\tmutex_unlock(&vmpr->events_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmpressure_calc_level",
          "args": [
            "scanned",
            "reclaimed"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "vmpressure_calc_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmpressure.c",
          "lines": "124-152",
          "snippet": "static enum vmpressure_levels vmpressure_calc_level(unsigned long scanned,\n\t\t\t\t\t\t    unsigned long reclaimed)\n{\n\tunsigned long scale = scanned + reclaimed;\n\tunsigned long pressure = 0;\n\n\t/*\n\t * reclaimed can be greater than scanned for things such as reclaimed\n\t * slab pages. shrink_node() just adds reclaimed pages without a\n\t * related increment to scanned pages.\n\t */\n\tif (reclaimed >= scanned)\n\t\tgoto out;\n\t/*\n\t * We calculate the ratio (in percents) of how many pages were\n\t * scanned vs. reclaimed in a given time frame (window). Note that\n\t * time is in VM reclaimer's \"ticks\", i.e. number of pages\n\t * scanned. This makes it possible to set desired reaction time\n\t * and serves as a ratelimit.\n\t */\n\tpressure = scale - (reclaimed * scale / scanned);\n\tpressure = pressure * 100 / scale;\n\nout:\n\tpr_debug(\"%s: %3lu  (s: %lu  r: %lu)\\n\", __func__, pressure,\n\t\t scanned, reclaimed);\n\n\treturn vmpressure_level(pressure);\n}",
          "includes": [
            "#include <linux/vmpressure.h>",
            "#include <linux/printk.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmpressure.h>\n#include <linux/printk.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/eventfd.h>\n#include <linux/vmstat.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n\nstatic enum vmpressure_levels vmpressure_calc_level(unsigned long scanned,\n\t\t\t\t\t\t    unsigned long reclaimed)\n{\n\tunsigned long scale = scanned + reclaimed;\n\tunsigned long pressure = 0;\n\n\t/*\n\t * reclaimed can be greater than scanned for things such as reclaimed\n\t * slab pages. shrink_node() just adds reclaimed pages without a\n\t * related increment to scanned pages.\n\t */\n\tif (reclaimed >= scanned)\n\t\tgoto out;\n\t/*\n\t * We calculate the ratio (in percents) of how many pages were\n\t * scanned vs. reclaimed in a given time frame (window). Note that\n\t * time is in VM reclaimer's \"ticks\", i.e. number of pages\n\t * scanned. This makes it possible to set desired reaction time\n\t * and serves as a ratelimit.\n\t */\n\tpressure = scale - (reclaimed * scale / scanned);\n\tpressure = pressure * 100 / scale;\n\nout:\n\tpr_debug(\"%s: %3lu  (s: %lu  r: %lu)\\n\", __func__, pressure,\n\t\t scanned, reclaimed);\n\n\treturn vmpressure_level(pressure);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vmpr->sr_lock"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vmpr->sr_lock"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vmpr->sr_lock"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_to_vmpressure",
          "args": [
            "work"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "work_to_vmpressure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmpressure.c",
          "lines": "73-76",
          "snippet": "static struct vmpressure *work_to_vmpressure(struct work_struct *work)\n{\n\treturn container_of(work, struct vmpressure, work);\n}",
          "includes": [
            "#include <linux/vmpressure.h>",
            "#include <linux/printk.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmpressure.h>\n#include <linux/printk.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/eventfd.h>\n#include <linux/vmstat.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n\nstatic struct vmpressure *work_to_vmpressure(struct work_struct *work)\n{\n\treturn container_of(work, struct vmpressure, work);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/vmpressure.h>\n#include <linux/printk.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/eventfd.h>\n#include <linux/vmstat.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n\nstatic void vmpressure_work_fn(struct work_struct *work)\n{\n\tstruct vmpressure *vmpr = work_to_vmpressure(work);\n\tunsigned long scanned;\n\tunsigned long reclaimed;\n\tenum vmpressure_levels level;\n\tbool ancestor = false;\n\tbool signalled = false;\n\n\tspin_lock(&vmpr->sr_lock);\n\t/*\n\t * Several contexts might be calling vmpressure(), so it is\n\t * possible that the work was rescheduled again before the old\n\t * work context cleared the counters. In that case we will run\n\t * just after the old work returns, but then scanned might be zero\n\t * here. No need for any locks here since we don't care if\n\t * vmpr->reclaimed is in sync.\n\t */\n\tscanned = vmpr->tree_scanned;\n\tif (!scanned) {\n\t\tspin_unlock(&vmpr->sr_lock);\n\t\treturn;\n\t}\n\n\treclaimed = vmpr->tree_reclaimed;\n\tvmpr->tree_scanned = 0;\n\tvmpr->tree_reclaimed = 0;\n\tspin_unlock(&vmpr->sr_lock);\n\n\tlevel = vmpressure_calc_level(scanned, reclaimed);\n\n\tdo {\n\t\tif (vmpressure_event(vmpr, level, ancestor, signalled))\n\t\t\tsignalled = true;\n\t\tancestor = true;\n\t} while ((vmpr = vmpressure_parent(vmpr)));\n}"
  },
  {
    "function_name": "vmpressure_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmpressure.c",
    "lines": "161-182",
    "snippet": "static bool vmpressure_event(struct vmpressure *vmpr,\n\t\t\t     const enum vmpressure_levels level,\n\t\t\t     bool ancestor, bool signalled)\n{\n\tstruct vmpressure_event *ev;\n\tbool ret = false;\n\n\tmutex_lock(&vmpr->events_lock);\n\tlist_for_each_entry(ev, &vmpr->events, node) {\n\t\tif (ancestor && ev->mode == VMPRESSURE_LOCAL)\n\t\t\tcontinue;\n\t\tif (signalled && ev->mode == VMPRESSURE_NO_PASSTHROUGH)\n\t\t\tcontinue;\n\t\tif (level < ev->level)\n\t\t\tcontinue;\n\t\teventfd_signal(ev->efd, 1);\n\t\tret = true;\n\t}\n\tmutex_unlock(&vmpr->events_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/vmpressure.h>",
      "#include <linux/printk.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vmpr->events_lock"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventfd_signal",
          "args": [
            "ev->efd",
            "1"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ev",
            "&vmpr->events",
            "node"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vmpr->events_lock"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmpressure.h>\n#include <linux/printk.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/eventfd.h>\n#include <linux/vmstat.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n\nstatic bool vmpressure_event(struct vmpressure *vmpr,\n\t\t\t     const enum vmpressure_levels level,\n\t\t\t     bool ancestor, bool signalled)\n{\n\tstruct vmpressure_event *ev;\n\tbool ret = false;\n\n\tmutex_lock(&vmpr->events_lock);\n\tlist_for_each_entry(ev, &vmpr->events, node) {\n\t\tif (ancestor && ev->mode == VMPRESSURE_LOCAL)\n\t\t\tcontinue;\n\t\tif (signalled && ev->mode == VMPRESSURE_NO_PASSTHROUGH)\n\t\t\tcontinue;\n\t\tif (level < ev->level)\n\t\t\tcontinue;\n\t\teventfd_signal(ev->efd, 1);\n\t\tret = true;\n\t}\n\tmutex_unlock(&vmpr->events_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "vmpressure_calc_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmpressure.c",
    "lines": "124-152",
    "snippet": "static enum vmpressure_levels vmpressure_calc_level(unsigned long scanned,\n\t\t\t\t\t\t    unsigned long reclaimed)\n{\n\tunsigned long scale = scanned + reclaimed;\n\tunsigned long pressure = 0;\n\n\t/*\n\t * reclaimed can be greater than scanned for things such as reclaimed\n\t * slab pages. shrink_node() just adds reclaimed pages without a\n\t * related increment to scanned pages.\n\t */\n\tif (reclaimed >= scanned)\n\t\tgoto out;\n\t/*\n\t * We calculate the ratio (in percents) of how many pages were\n\t * scanned vs. reclaimed in a given time frame (window). Note that\n\t * time is in VM reclaimer's \"ticks\", i.e. number of pages\n\t * scanned. This makes it possible to set desired reaction time\n\t * and serves as a ratelimit.\n\t */\n\tpressure = scale - (reclaimed * scale / scanned);\n\tpressure = pressure * 100 / scale;\n\nout:\n\tpr_debug(\"%s: %3lu  (s: %lu  r: %lu)\\n\", __func__, pressure,\n\t\t scanned, reclaimed);\n\n\treturn vmpressure_level(pressure);\n}",
    "includes": [
      "#include <linux/vmpressure.h>",
      "#include <linux/printk.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmpressure_level",
          "args": [
            "pressure"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "vmpressure_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmpressure.c",
          "lines": "115-122",
          "snippet": "static enum vmpressure_levels vmpressure_level(unsigned long pressure)\n{\n\tif (pressure >= vmpressure_level_critical)\n\t\treturn VMPRESSURE_CRITICAL;\n\telse if (pressure >= vmpressure_level_med)\n\t\treturn VMPRESSURE_MEDIUM;\n\treturn VMPRESSURE_LOW;\n}",
          "includes": [
            "#include <linux/vmpressure.h>",
            "#include <linux/printk.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int vmpressure_level_med = 60;",
            "static const unsigned int vmpressure_level_critical = 95;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmpressure.h>\n#include <linux/printk.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/eventfd.h>\n#include <linux/vmstat.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n\nstatic const unsigned int vmpressure_level_med = 60;\nstatic const unsigned int vmpressure_level_critical = 95;\n\nstatic enum vmpressure_levels vmpressure_level(unsigned long pressure)\n{\n\tif (pressure >= vmpressure_level_critical)\n\t\treturn VMPRESSURE_CRITICAL;\n\telse if (pressure >= vmpressure_level_med)\n\t\treturn VMPRESSURE_MEDIUM;\n\treturn VMPRESSURE_LOW;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: %3lu  (s: %lu  r: %lu)\\n\"",
            "__func__",
            "pressure",
            "scanned",
            "reclaimed"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmpressure.h>\n#include <linux/printk.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/eventfd.h>\n#include <linux/vmstat.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n\nstatic enum vmpressure_levels vmpressure_calc_level(unsigned long scanned,\n\t\t\t\t\t\t    unsigned long reclaimed)\n{\n\tunsigned long scale = scanned + reclaimed;\n\tunsigned long pressure = 0;\n\n\t/*\n\t * reclaimed can be greater than scanned for things such as reclaimed\n\t * slab pages. shrink_node() just adds reclaimed pages without a\n\t * related increment to scanned pages.\n\t */\n\tif (reclaimed >= scanned)\n\t\tgoto out;\n\t/*\n\t * We calculate the ratio (in percents) of how many pages were\n\t * scanned vs. reclaimed in a given time frame (window). Note that\n\t * time is in VM reclaimer's \"ticks\", i.e. number of pages\n\t * scanned. This makes it possible to set desired reaction time\n\t * and serves as a ratelimit.\n\t */\n\tpressure = scale - (reclaimed * scale / scanned);\n\tpressure = pressure * 100 / scale;\n\nout:\n\tpr_debug(\"%s: %3lu  (s: %lu  r: %lu)\\n\", __func__, pressure,\n\t\t scanned, reclaimed);\n\n\treturn vmpressure_level(pressure);\n}"
  },
  {
    "function_name": "vmpressure_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmpressure.c",
    "lines": "115-122",
    "snippet": "static enum vmpressure_levels vmpressure_level(unsigned long pressure)\n{\n\tif (pressure >= vmpressure_level_critical)\n\t\treturn VMPRESSURE_CRITICAL;\n\telse if (pressure >= vmpressure_level_med)\n\t\treturn VMPRESSURE_MEDIUM;\n\treturn VMPRESSURE_LOW;\n}",
    "includes": [
      "#include <linux/vmpressure.h>",
      "#include <linux/printk.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const unsigned int vmpressure_level_med = 60;",
      "static const unsigned int vmpressure_level_critical = 95;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/vmpressure.h>\n#include <linux/printk.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/eventfd.h>\n#include <linux/vmstat.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n\nstatic const unsigned int vmpressure_level_med = 60;\nstatic const unsigned int vmpressure_level_critical = 95;\n\nstatic enum vmpressure_levels vmpressure_level(unsigned long pressure)\n{\n\tif (pressure >= vmpressure_level_critical)\n\t\treturn VMPRESSURE_CRITICAL;\n\telse if (pressure >= vmpressure_level_med)\n\t\treturn VMPRESSURE_MEDIUM;\n\treturn VMPRESSURE_LOW;\n}"
  },
  {
    "function_name": "vmpressure_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmpressure.c",
    "lines": "78-87",
    "snippet": "static struct vmpressure *vmpressure_parent(struct vmpressure *vmpr)\n{\n\tstruct cgroup_subsys_state *css = vmpressure_to_css(vmpr);\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\n\tmemcg = parent_mem_cgroup(memcg);\n\tif (!memcg)\n\t\treturn NULL;\n\treturn memcg_to_vmpressure(memcg);\n}",
    "includes": [
      "#include <linux/vmpressure.h>",
      "#include <linux/printk.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcg_to_vmpressure",
          "args": [
            "memcg"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_to_vmpressure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "252-257",
          "snippet": "struct vmpressure *memcg_to_vmpressure(struct mem_cgroup *memcg)\n{\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\treturn &memcg->vmpressure;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct vmpressure *memcg_to_vmpressure(struct mem_cgroup *memcg)\n{\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\treturn &memcg->vmpressure;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_mem_cgroup",
          "args": [
            "memcg"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "css"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmpressure_to_css",
          "args": [
            "vmpr"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "vmpressure_to_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "259-262",
          "snippet": "struct cgroup_subsys_state *vmpressure_to_css(struct vmpressure *vmpr)\n{\n\treturn &container_of(vmpr, struct mem_cgroup, vmpressure)->css;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nstruct cgroup_subsys_state *vmpressure_to_css(struct vmpressure *vmpr)\n{\n\treturn &container_of(vmpr, struct mem_cgroup, vmpressure)->css;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/vmpressure.h>\n#include <linux/printk.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/eventfd.h>\n#include <linux/vmstat.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n\nstatic struct vmpressure *vmpressure_parent(struct vmpressure *vmpr)\n{\n\tstruct cgroup_subsys_state *css = vmpressure_to_css(vmpr);\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\n\tmemcg = parent_mem_cgroup(memcg);\n\tif (!memcg)\n\t\treturn NULL;\n\treturn memcg_to_vmpressure(memcg);\n}"
  },
  {
    "function_name": "work_to_vmpressure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmpressure.c",
    "lines": "73-76",
    "snippet": "static struct vmpressure *work_to_vmpressure(struct work_struct *work)\n{\n\treturn container_of(work, struct vmpressure, work);\n}",
    "includes": [
      "#include <linux/vmpressure.h>",
      "#include <linux/printk.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structvmpressure",
            "work"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmpressure.h>\n#include <linux/printk.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/eventfd.h>\n#include <linux/vmstat.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n\nstatic struct vmpressure *work_to_vmpressure(struct work_struct *work)\n{\n\treturn container_of(work, struct vmpressure, work);\n}"
  }
]