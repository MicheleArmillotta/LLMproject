[
  {
    "function_name": "frame_vector_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frame_vector.c",
    "lines": "233-238",
    "snippet": "void frame_vector_destroy(struct frame_vector *vec)\n{\n\t/* Make sure put_vaddr_frames() got called properly... */\n\tVM_BUG_ON(vec->nr_frames > 0);\n\tkvfree(vec);\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "vec"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "kvfree_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "395-401",
          "snippet": "static void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "vec->nr_frames > 0"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nvoid frame_vector_destroy(struct frame_vector *vec)\n{\n\t/* Make sure put_vaddr_frames() got called properly... */\n\tVM_BUG_ON(vec->nr_frames > 0);\n\tkvfree(vec);\n}"
  },
  {
    "function_name": "frame_vector_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frame_vector.c",
    "lines": "201-224",
    "snippet": "struct frame_vector *frame_vector_create(unsigned int nr_frames)\n{\n\tstruct frame_vector *vec;\n\tint size = sizeof(struct frame_vector) + sizeof(void *) * nr_frames;\n\n\tif (WARN_ON_ONCE(nr_frames == 0))\n\t\treturn NULL;\n\t/*\n\t * This is absurdly high. It's here just to avoid strange effects when\n\t * arithmetics overflows.\n\t */\n\tif (WARN_ON_ONCE(nr_frames > INT_MAX / sizeof(void *) / 2))\n\t\treturn NULL;\n\t/*\n\t * Avoid higher order allocations, use vmalloc instead. It should\n\t * be rare anyway.\n\t */\n\tvec = kvmalloc(size, GFP_KERNEL);\n\tif (!vec)\n\t\treturn NULL;\n\tvec->nr_allocated = nr_frames;\n\tvec->nr_frames = 0;\n\treturn vec;\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "nr_frames > INT_MAX / sizeof(void *) / 2"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "nr_frames == 0"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstruct frame_vector *frame_vector_create(unsigned int nr_frames)\n{\n\tstruct frame_vector *vec;\n\tint size = sizeof(struct frame_vector) + sizeof(void *) * nr_frames;\n\n\tif (WARN_ON_ONCE(nr_frames == 0))\n\t\treturn NULL;\n\t/*\n\t * This is absurdly high. It's here just to avoid strange effects when\n\t * arithmetics overflows.\n\t */\n\tif (WARN_ON_ONCE(nr_frames > INT_MAX / sizeof(void *) / 2))\n\t\treturn NULL;\n\t/*\n\t * Avoid higher order allocations, use vmalloc instead. It should\n\t * be rare anyway.\n\t */\n\tvec = kvmalloc(size, GFP_KERNEL);\n\tif (!vec)\n\t\treturn NULL;\n\tvec->nr_allocated = nr_frames;\n\tvec->nr_frames = 0;\n\treturn vec;\n}"
  },
  {
    "function_name": "frame_vector_to_pfns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frame_vector.c",
    "lines": "178-191",
    "snippet": "void frame_vector_to_pfns(struct frame_vector *vec)\n{\n\tint i;\n\tunsigned long *nums;\n\tstruct page **pages;\n\n\tif (vec->is_pfns)\n\t\treturn;\n\tpages = (struct page **)(vec->ptrs);\n\tnums = (unsigned long *)pages;\n\tfor (i = 0; i < vec->nr_frames; i++)\n\t\tnums[i] = page_to_pfn(pages[i]);\n\tvec->is_pfns = true;\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "pages[i]"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nvoid frame_vector_to_pfns(struct frame_vector *vec)\n{\n\tint i;\n\tunsigned long *nums;\n\tstruct page **pages;\n\n\tif (vec->is_pfns)\n\t\treturn;\n\tpages = (struct page **)(vec->ptrs);\n\tnums = (unsigned long *)pages;\n\tfor (i = 0; i < vec->nr_frames; i++)\n\t\tnums[i] = page_to_pfn(pages[i]);\n\tvec->is_pfns = true;\n}"
  },
  {
    "function_name": "frame_vector_to_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frame_vector.c",
    "lines": "152-169",
    "snippet": "int frame_vector_to_pages(struct frame_vector *vec)\n{\n\tint i;\n\tunsigned long *nums;\n\tstruct page **pages;\n\n\tif (!vec->is_pfns)\n\t\treturn 0;\n\tnums = frame_vector_pfns(vec);\n\tfor (i = 0; i < vec->nr_frames; i++)\n\t\tif (!pfn_valid(nums[i]))\n\t\t\treturn -EINVAL;\n\tpages = (struct page **)nums;\n\tfor (i = 0; i < vec->nr_frames; i++)\n\t\tpages[i] = pfn_to_page(nums[i]);\n\tvec->is_pfns = false;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "nums[i]"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "nums[i]"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "frame_vector_pfns",
          "args": [
            "vec"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nint frame_vector_to_pages(struct frame_vector *vec)\n{\n\tint i;\n\tunsigned long *nums;\n\tstruct page **pages;\n\n\tif (!vec->is_pfns)\n\t\treturn 0;\n\tnums = frame_vector_pfns(vec);\n\tfor (i = 0; i < vec->nr_frames; i++)\n\t\tif (!pfn_valid(nums[i]))\n\t\t\treturn -EINVAL;\n\tpages = (struct page **)nums;\n\tfor (i = 0; i < vec->nr_frames; i++)\n\t\tpages[i] = pfn_to_page(nums[i]);\n\tvec->is_pfns = false;\n\treturn 0;\n}"
  },
  {
    "function_name": "put_vaddr_frames",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frame_vector.c",
    "lines": "121-141",
    "snippet": "void put_vaddr_frames(struct frame_vector *vec)\n{\n\tint i;\n\tstruct page **pages;\n\n\tif (!vec->got_ref)\n\t\tgoto out;\n\tpages = frame_vector_pages(vec);\n\t/*\n\t * frame_vector_pages() might needed to do a conversion when\n\t * get_vaddr_frames() got pages but vec was later converted to pfns.\n\t * But it shouldn't really fail to convert pfns back...\n\t */\n\tif (WARN_ON(IS_ERR(pages)))\n\t\tgoto out;\n\tfor (i = 0; i < vec->nr_frames; i++)\n\t\tput_page(pages[i]);\n\tvec->got_ref = false;\nout:\n\tvec->nr_frames = 0;\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "pages[i]"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "IS_ERR(pages)"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pages"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "frame_vector_pages",
          "args": [
            "vec"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nvoid put_vaddr_frames(struct frame_vector *vec)\n{\n\tint i;\n\tstruct page **pages;\n\n\tif (!vec->got_ref)\n\t\tgoto out;\n\tpages = frame_vector_pages(vec);\n\t/*\n\t * frame_vector_pages() might needed to do a conversion when\n\t * get_vaddr_frames() got pages but vec was later converted to pfns.\n\t * But it shouldn't really fail to convert pfns back...\n\t */\n\tif (WARN_ON(IS_ERR(pages)))\n\t\tgoto out;\n\tfor (i = 0; i < vec->nr_frames; i++)\n\t\tput_page(pages[i]);\n\tvec->got_ref = false;\nout:\n\tvec->nr_frames = 0;\n}"
  },
  {
    "function_name": "get_vaddr_frames",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frame_vector.c",
    "lines": "34-109",
    "snippet": "int get_vaddr_frames(unsigned long start, unsigned int nr_frames,\n\t\t     unsigned int gup_flags, struct frame_vector *vec)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tint ret = 0;\n\tint err;\n\tint locked;\n\n\tif (nr_frames == 0)\n\t\treturn 0;\n\n\tif (WARN_ON_ONCE(nr_frames > vec->nr_allocated))\n\t\tnr_frames = vec->nr_allocated;\n\n\tdown_read(&mm->mmap_sem);\n\tlocked = 1;\n\tvma = find_vma_intersection(mm, start, start + 1);\n\tif (!vma) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * While get_vaddr_frames() could be used for transient (kernel\n\t * controlled lifetime) pinning of memory pages all current\n\t * users establish long term (userspace controlled lifetime)\n\t * page pinning. Treat get_vaddr_frames() like\n\t * get_user_pages_longterm() and disallow it for filesystem-dax\n\t * mappings.\n\t */\n\tif (vma_is_fsdax(vma)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (!(vma->vm_flags & (VM_IO | VM_PFNMAP))) {\n\t\tvec->got_ref = true;\n\t\tvec->is_pfns = false;\n\t\tret = get_user_pages_locked(start, nr_frames,\n\t\t\tgup_flags, (struct page **)(vec->ptrs), &locked);\n\t\tgoto out;\n\t}\n\n\tvec->got_ref = false;\n\tvec->is_pfns = true;\n\tdo {\n\t\tunsigned long *nums = frame_vector_pfns(vec);\n\n\t\twhile (ret < nr_frames && start + PAGE_SIZE <= vma->vm_end) {\n\t\t\terr = follow_pfn(vma, start, &nums[ret]);\n\t\t\tif (err) {\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tret = err;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tstart += PAGE_SIZE;\n\t\t\tret++;\n\t\t}\n\t\t/*\n\t\t * We stop if we have enough pages or if VMA doesn't completely\n\t\t * cover the tail page.\n\t\t */\n\t\tif (ret >= nr_frames || start < vma->vm_end)\n\t\t\tbreak;\n\t\tvma = find_vma_intersection(mm, start, start + 1);\n\t} while (vma && vma->vm_flags & (VM_IO | VM_PFNMAP));\nout:\n\tif (locked)\n\t\tup_read(&mm->mmap_sem);\n\tif (!ret)\n\t\tret = -EFAULT;\n\tif (ret > 0)\n\t\tvec->nr_frames = ret;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/err.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_vma_intersection",
          "args": [
            "mm",
            "start",
            "start + 1"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_pfn",
          "args": [
            "vma",
            "start",
            "&nums[ret]"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "follow_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "211-219",
          "snippet": "int follow_pfn(struct vm_area_struct *vma, unsigned long address,\n\tunsigned long *pfn)\n{\n\tif (!(vma->vm_flags & (VM_IO | VM_PFNMAP)))\n\t\treturn -EINVAL;\n\n\t*pfn = address >> PAGE_SHIFT;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nint follow_pfn(struct vm_area_struct *vma, unsigned long address,\n\tunsigned long *pfn)\n{\n\tif (!(vma->vm_flags & (VM_IO | VM_PFNMAP)))\n\t\treturn -EINVAL;\n\n\t*pfn = address >> PAGE_SHIFT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "frame_vector_pfns",
          "args": [
            "vec"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_pages_locked",
          "args": [
            "start",
            "nr_frames",
            "gup_flags",
            "(struct page **)(vec->ptrs)",
            "&locked"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_pages_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "172-177",
          "snippet": "long get_user_pages_locked(unsigned long start, unsigned long nr_pages,\n\t\t\t    unsigned int gup_flags, struct page **pages,\n\t\t\t    int *locked)\n{\n\treturn get_user_pages(start, nr_pages, gup_flags, pages, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nlong get_user_pages_locked(unsigned long start, unsigned long nr_pages,\n\t\t\t    unsigned int gup_flags, struct page **pages,\n\t\t\t    int *locked)\n{\n\treturn get_user_pages(start, nr_pages, gup_flags, pages, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_is_fsdax",
          "args": [
            "vma"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_vma_intersection",
          "args": [
            "mm",
            "start",
            "start + 1"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "nr_frames > vec->nr_allocated"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nint get_vaddr_frames(unsigned long start, unsigned int nr_frames,\n\t\t     unsigned int gup_flags, struct frame_vector *vec)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tint ret = 0;\n\tint err;\n\tint locked;\n\n\tif (nr_frames == 0)\n\t\treturn 0;\n\n\tif (WARN_ON_ONCE(nr_frames > vec->nr_allocated))\n\t\tnr_frames = vec->nr_allocated;\n\n\tdown_read(&mm->mmap_sem);\n\tlocked = 1;\n\tvma = find_vma_intersection(mm, start, start + 1);\n\tif (!vma) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * While get_vaddr_frames() could be used for transient (kernel\n\t * controlled lifetime) pinning of memory pages all current\n\t * users establish long term (userspace controlled lifetime)\n\t * page pinning. Treat get_vaddr_frames() like\n\t * get_user_pages_longterm() and disallow it for filesystem-dax\n\t * mappings.\n\t */\n\tif (vma_is_fsdax(vma)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (!(vma->vm_flags & (VM_IO | VM_PFNMAP))) {\n\t\tvec->got_ref = true;\n\t\tvec->is_pfns = false;\n\t\tret = get_user_pages_locked(start, nr_frames,\n\t\t\tgup_flags, (struct page **)(vec->ptrs), &locked);\n\t\tgoto out;\n\t}\n\n\tvec->got_ref = false;\n\tvec->is_pfns = true;\n\tdo {\n\t\tunsigned long *nums = frame_vector_pfns(vec);\n\n\t\twhile (ret < nr_frames && start + PAGE_SIZE <= vma->vm_end) {\n\t\t\terr = follow_pfn(vma, start, &nums[ret]);\n\t\t\tif (err) {\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tret = err;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tstart += PAGE_SIZE;\n\t\t\tret++;\n\t\t}\n\t\t/*\n\t\t * We stop if we have enough pages or if VMA doesn't completely\n\t\t * cover the tail page.\n\t\t */\n\t\tif (ret >= nr_frames || start < vma->vm_end)\n\t\t\tbreak;\n\t\tvma = find_vma_intersection(mm, start, start + 1);\n\t} while (vma && vma->vm_flags & (VM_IO | VM_PFNMAP));\nout:\n\tif (locked)\n\t\tup_read(&mm->mmap_sem);\n\tif (!ret)\n\t\tret = -EFAULT;\n\tif (ret > 0)\n\t\tvec->nr_frames = ret;\n\treturn ret;\n}"
  }
]