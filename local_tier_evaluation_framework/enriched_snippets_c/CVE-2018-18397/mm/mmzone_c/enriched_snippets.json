[
  {
    "function_name": "page_cpupid_xchg_last",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmzone.c",
    "lines": "100-114",
    "snippet": "int page_cpupid_xchg_last(struct page *page, int cpupid)\n{\n\tunsigned long old_flags, flags;\n\tint last_cpupid;\n\n\tdo {\n\t\told_flags = flags = page->flags;\n\t\tlast_cpupid = page_cpupid_last(page);\n\n\t\tflags &= ~(LAST_CPUPID_MASK << LAST_CPUPID_PGSHIFT);\n\t\tflags |= (cpupid & LAST_CPUPID_MASK) << LAST_CPUPID_PGSHIFT;\n\t} while (unlikely(cmpxchg(&page->flags, old_flags, flags) != old_flags));\n\n\treturn last_cpupid;\n}",
    "includes": [
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cmpxchg(&page->flags, old_flags, flags) != old_flags"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&page->flags",
            "old_flags",
            "flags"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "note_cmpxchg_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1992-2014",
          "snippet": "static inline void note_cmpxchg_failure(const char *n,\n\t\tconst struct kmem_cache *s, unsigned long tid)\n{\n#ifdef SLUB_DEBUG_CMPXCHG\n\tunsigned long actual_tid = __this_cpu_read(s->cpu_slab->tid);\n\n\tpr_info(\"%s %s: cmpxchg redo \", n, s->name);\n\n#ifdef CONFIG_PREEMPT\n\tif (tid_to_cpu(tid) != tid_to_cpu(actual_tid))\n\t\tpr_warn(\"due to cpu change %d -> %d\\n\",\n\t\t\ttid_to_cpu(tid), tid_to_cpu(actual_tid));\n\telse\n#endif\n\tif (tid_to_event(tid) != tid_to_event(actual_tid))\n\t\tpr_warn(\"due to cpu running other code. Event %ld->%ld\\n\",\n\t\t\ttid_to_event(tid), tid_to_event(actual_tid));\n\telse\n\t\tpr_warn(\"for unknown reason: actual=%lx was=%lx target=%lx\\n\",\n\t\t\tactual_tid, tid, next_tid(tid));\n#endif\n\tstat(s, CMPXCHG_DOUBLE_CPU_FAIL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void note_cmpxchg_failure(const char *n,\n\t\tconst struct kmem_cache *s, unsigned long tid)\n{\n#ifdef SLUB_DEBUG_CMPXCHG\n\tunsigned long actual_tid = __this_cpu_read(s->cpu_slab->tid);\n\n\tpr_info(\"%s %s: cmpxchg redo \", n, s->name);\n\n#ifdef CONFIG_PREEMPT\n\tif (tid_to_cpu(tid) != tid_to_cpu(actual_tid))\n\t\tpr_warn(\"due to cpu change %d -> %d\\n\",\n\t\t\ttid_to_cpu(tid), tid_to_cpu(actual_tid));\n\telse\n#endif\n\tif (tid_to_event(tid) != tid_to_event(actual_tid))\n\t\tpr_warn(\"due to cpu running other code. Event %ld->%ld\\n\",\n\t\t\ttid_to_event(tid), tid_to_event(actual_tid));\n\telse\n\t\tpr_warn(\"for unknown reason: actual=%lx was=%lx target=%lx\\n\",\n\t\t\tactual_tid, tid, next_tid(tid));\n#endif\n\tstat(s, CMPXCHG_DOUBLE_CPU_FAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cpupid_last",
          "args": [
            "page"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint page_cpupid_xchg_last(struct page *page, int cpupid)\n{\n\tunsigned long old_flags, flags;\n\tint last_cpupid;\n\n\tdo {\n\t\told_flags = flags = page->flags;\n\t\tlast_cpupid = page_cpupid_last(page);\n\n\t\tflags &= ~(LAST_CPUPID_MASK << LAST_CPUPID_PGSHIFT);\n\t\tflags |= (cpupid & LAST_CPUPID_MASK) << LAST_CPUPID_PGSHIFT;\n\t} while (unlikely(cmpxchg(&page->flags, old_flags, flags) != old_flags));\n\n\treturn last_cpupid;\n}"
  },
  {
    "function_name": "lruvec_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmzone.c",
    "lines": "89-97",
    "snippet": "void lruvec_init(struct lruvec *lruvec)\n{\n\tenum lru_list lru;\n\n\tmemset(lruvec, 0, sizeof(struct lruvec));\n\n\tfor_each_lru(lru)\n\t\tINIT_LIST_HEAD(&lruvec->lists[lru]);\n}",
    "includes": [
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "lruvec",
            "0",
            "sizeof(struct lruvec)"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid lruvec_init(struct lruvec *lruvec)\n{\n\tenum lru_list lru;\n\n\tmemset(lruvec, 0, sizeof(struct lruvec));\n\n\tfor_each_lru(lru)\n\t\tINIT_LIST_HEAD(&lruvec->lists[lru]);\n}"
  },
  {
    "function_name": "memmap_valid_within",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmzone.c",
    "lines": "76-86",
    "snippet": "bool memmap_valid_within(unsigned long pfn,\n\t\t\t\t\tstruct page *page, struct zone *zone)\n{\n\tif (page_to_pfn(page) != pfn)\n\t\treturn false;\n\n\tif (page_zone(page) != zone)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nbool memmap_valid_within(unsigned long pfn,\n\t\t\t\t\tstruct page *page, struct zone *zone)\n{\n\tif (page_to_pfn(page) != pfn)\n\t\treturn false;\n\n\tif (page_zone(page) != zone)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "__next_zones_zonelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmzone.c",
    "lines": "56-73",
    "snippet": "struct zoneref *__next_zones_zonelist(struct zoneref *z,\n\t\t\t\t\tenum zone_type highest_zoneidx,\n\t\t\t\t\tnodemask_t *nodes)\n{\n\t/*\n\t * Find the next suitable zone to use for the allocation.\n\t * Only filter based on nodemask if it's set\n\t */\n\tif (unlikely(nodes == NULL))\n\t\twhile (zonelist_zone_idx(z) > highest_zoneidx)\n\t\t\tz++;\n\telse\n\t\twhile (zonelist_zone_idx(z) > highest_zoneidx ||\n\t\t\t\t(z->zone && !zref_in_nodemask(z, nodes)))\n\t\t\tz++;\n\n\treturn z;\n}",
    "includes": [
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zref_in_nodemask",
          "args": [
            "z",
            "nodes"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "zref_in_nodemask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmzone.c",
          "lines": "46-53",
          "snippet": "static inline int zref_in_nodemask(struct zoneref *zref, nodemask_t *nodes)\n{\n#ifdef CONFIG_NUMA\n\treturn node_isset(zonelist_node_idx(zref), *nodes);\n#else\n\treturn 1;\n#endif /* CONFIG_NUMA */\n}",
          "includes": [
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic inline int zref_in_nodemask(struct zoneref *zref, nodemask_t *nodes)\n{\n#ifdef CONFIG_NUMA\n\treturn node_isset(zonelist_node_idx(zref), *nodes);\n#else\n\treturn 1;\n#endif /* CONFIG_NUMA */\n}"
        }
      },
      {
        "call_info": {
          "callee": "zonelist_zone_idx",
          "args": [
            "z"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zonelist_zone_idx",
          "args": [
            "z"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nodes == NULL"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstruct zoneref *__next_zones_zonelist(struct zoneref *z,\n\t\t\t\t\tenum zone_type highest_zoneidx,\n\t\t\t\t\tnodemask_t *nodes)\n{\n\t/*\n\t * Find the next suitable zone to use for the allocation.\n\t * Only filter based on nodemask if it's set\n\t */\n\tif (unlikely(nodes == NULL))\n\t\twhile (zonelist_zone_idx(z) > highest_zoneidx)\n\t\t\tz++;\n\telse\n\t\twhile (zonelist_zone_idx(z) > highest_zoneidx ||\n\t\t\t\t(z->zone && !zref_in_nodemask(z, nodes)))\n\t\t\tz++;\n\n\treturn z;\n}"
  },
  {
    "function_name": "zref_in_nodemask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmzone.c",
    "lines": "46-53",
    "snippet": "static inline int zref_in_nodemask(struct zoneref *zref, nodemask_t *nodes)\n{\n#ifdef CONFIG_NUMA\n\treturn node_isset(zonelist_node_idx(zref), *nodes);\n#else\n\treturn 1;\n#endif /* CONFIG_NUMA */\n}",
    "includes": [
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_isset",
          "args": [
            "zonelist_node_idx(zref)",
            "*nodes"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zonelist_node_idx",
          "args": [
            "zref"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic inline int zref_in_nodemask(struct zoneref *zref, nodemask_t *nodes)\n{\n#ifdef CONFIG_NUMA\n\treturn node_isset(zonelist_node_idx(zref), *nodes);\n#else\n\treturn 1;\n#endif /* CONFIG_NUMA */\n}"
  },
  {
    "function_name": "next_zone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmzone.c",
    "lines": "30-44",
    "snippet": "struct zone *next_zone(struct zone *zone)\n{\n\tpg_data_t *pgdat = zone->zone_pgdat;\n\n\tif (zone < pgdat->node_zones + MAX_NR_ZONES - 1)\n\t\tzone++;\n\telse {\n\t\tpgdat = next_online_pgdat(pgdat);\n\t\tif (pgdat)\n\t\t\tzone = pgdat->node_zones;\n\t\telse\n\t\t\tzone = NULL;\n\t}\n\treturn zone;\n}",
    "includes": [
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next_online_pgdat",
          "args": [
            "pgdat"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "next_online_pgdat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmzone.c",
          "lines": "18-25",
          "snippet": "struct pglist_data *next_online_pgdat(struct pglist_data *pgdat)\n{\n\tint nid = next_online_node(pgdat->node_id);\n\n\tif (nid == MAX_NUMNODES)\n\t\treturn NULL;\n\treturn NODE_DATA(nid);\n}",
          "includes": [
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstruct pglist_data *next_online_pgdat(struct pglist_data *pgdat)\n{\n\tint nid = next_online_node(pgdat->node_id);\n\n\tif (nid == MAX_NUMNODES)\n\t\treturn NULL;\n\treturn NODE_DATA(nid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstruct zone *next_zone(struct zone *zone)\n{\n\tpg_data_t *pgdat = zone->zone_pgdat;\n\n\tif (zone < pgdat->node_zones + MAX_NR_ZONES - 1)\n\t\tzone++;\n\telse {\n\t\tpgdat = next_online_pgdat(pgdat);\n\t\tif (pgdat)\n\t\t\tzone = pgdat->node_zones;\n\t\telse\n\t\t\tzone = NULL;\n\t}\n\treturn zone;\n}"
  },
  {
    "function_name": "next_online_pgdat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmzone.c",
    "lines": "18-25",
    "snippet": "struct pglist_data *next_online_pgdat(struct pglist_data *pgdat)\n{\n\tint nid = next_online_node(pgdat->node_id);\n\n\tif (nid == MAX_NUMNODES)\n\t\treturn NULL;\n\treturn NODE_DATA(nid);\n}",
    "includes": [
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_online_node",
          "args": [
            "pgdat->node_id"
          ],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstruct pglist_data *next_online_pgdat(struct pglist_data *pgdat)\n{\n\tint nid = next_online_node(pgdat->node_id);\n\n\tif (nid == MAX_NUMNODES)\n\t\treturn NULL;\n\treturn NODE_DATA(nid);\n}"
  },
  {
    "function_name": "first_online_pgdat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmzone.c",
    "lines": "13-16",
    "snippet": "struct pglist_data *first_online_pgdat(void)\n{\n\treturn NODE_DATA(first_online_node);\n}",
    "includes": [
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "first_online_node"
          ],
          "line": 15
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstruct pglist_data *first_online_pgdat(void)\n{\n\treturn NODE_DATA(first_online_node);\n}"
  }
]