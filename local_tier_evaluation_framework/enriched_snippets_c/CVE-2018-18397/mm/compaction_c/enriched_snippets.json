[
  {
    "function_name": "kcompactd_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "2144-2160",
    "snippet": "static int __init kcompactd_init(void)\n{\n\tint nid;\n\tint ret;\n\n\tret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\t\"mm/compaction:online\",\n\t\t\t\t\tkcompactd_cpu_online, NULL);\n\tif (ret < 0) {\n\t\tpr_err(\"kcompactd: failed to register hotplug callbacks.\\n\");\n\t\treturn ret;\n\t}\n\n\tfor_each_node_state(nid, N_MEMORY)\n\t\tkcompactd_run(nid);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcompactd_run",
          "args": [
            "nid"
          ],
          "line": 2158
        },
        "resolved": true,
        "details": {
          "function_name": "kcompactd_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "2090-2105",
          "snippet": "int kcompactd_run(int nid)\n{\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\tint ret = 0;\n\n\tif (pgdat->kcompactd)\n\t\treturn 0;\n\n\tpgdat->kcompactd = kthread_run(kcompactd, pgdat, \"kcompactd%d\", nid);\n\tif (IS_ERR(pgdat->kcompactd)) {\n\t\tpr_err(\"Failed to start kcompactd on node %d\\n\", nid);\n\t\tret = PTR_ERR(pgdat->kcompactd);\n\t\tpgdat->kcompactd = NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nint kcompactd_run(int nid)\n{\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\tint ret = 0;\n\n\tif (pgdat->kcompactd)\n\t\treturn 0;\n\n\tpgdat->kcompactd = kthread_run(kcompactd, pgdat, \"kcompactd%d\", nid);\n\tif (IS_ERR(pgdat->kcompactd)) {\n\t\tpr_err(\"Failed to start kcompactd on node %d\\n\", nid);\n\t\tret = PTR_ERR(pgdat->kcompactd);\n\t\tpgdat->kcompactd = NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_node_state",
          "args": [
            "nid",
            "N_MEMORY"
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"kcompactd: failed to register hotplug callbacks.\\n\""
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_setup_state_nocalls",
          "args": [
            "CPUHP_AP_ONLINE_DYN",
            "\"mm/compaction:online\"",
            "kcompactd_cpu_online",
            "NULL"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic int __init kcompactd_init(void)\n{\n\tint nid;\n\tint ret;\n\n\tret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\t\"mm/compaction:online\",\n\t\t\t\t\tkcompactd_cpu_online, NULL);\n\tif (ret < 0) {\n\t\tpr_err(\"kcompactd: failed to register hotplug callbacks.\\n\");\n\t\treturn ret;\n\t}\n\n\tfor_each_node_state(nid, N_MEMORY)\n\t\tkcompactd_run(nid);\n\treturn 0;\n}"
  },
  {
    "function_name": "kcompactd_cpu_online",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "2127-2142",
    "snippet": "static int kcompactd_cpu_online(unsigned int cpu)\n{\n\tint nid;\n\n\tfor_each_node_state(nid, N_MEMORY) {\n\t\tpg_data_t *pgdat = NODE_DATA(nid);\n\t\tconst struct cpumask *mask;\n\n\t\tmask = cpumask_of_node(pgdat->node_id);\n\n\t\tif (cpumask_any_and(cpu_online_mask, mask) < nr_cpu_ids)\n\t\t\t/* One of our CPUs online: restore mask */\n\t\t\tset_cpus_allowed_ptr(pgdat->kcompactd, mask);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "pgdat->kcompactd",
            "mask"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_any_and",
          "args": [
            "cpu_online_mask",
            "mask"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of_node",
          "args": [
            "pgdat->node_id"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_node_state",
          "args": [
            "nid",
            "N_MEMORY"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic int kcompactd_cpu_online(unsigned int cpu)\n{\n\tint nid;\n\n\tfor_each_node_state(nid, N_MEMORY) {\n\t\tpg_data_t *pgdat = NODE_DATA(nid);\n\t\tconst struct cpumask *mask;\n\n\t\tmask = cpumask_of_node(pgdat->node_id);\n\n\t\tif (cpumask_any_and(cpu_online_mask, mask) < nr_cpu_ids)\n\t\t\t/* One of our CPUs online: restore mask */\n\t\t\tset_cpus_allowed_ptr(pgdat->kcompactd, mask);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kcompactd_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "2111-2119",
    "snippet": "void kcompactd_stop(int nid)\n{\n\tstruct task_struct *kcompactd = NODE_DATA(nid)->kcompactd;\n\n\tif (kcompactd) {\n\t\tkthread_stop(kcompactd);\n\t\tNODE_DATA(nid)->kcompactd = NULL;\n\t}\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "kcompactd"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nvoid kcompactd_stop(int nid)\n{\n\tstruct task_struct *kcompactd = NODE_DATA(nid)->kcompactd;\n\n\tif (kcompactd) {\n\t\tkthread_stop(kcompactd);\n\t\tNODE_DATA(nid)->kcompactd = NULL;\n\t}\n}"
  },
  {
    "function_name": "kcompactd_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "2090-2105",
    "snippet": "int kcompactd_run(int nid)\n{\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\tint ret = 0;\n\n\tif (pgdat->kcompactd)\n\t\treturn 0;\n\n\tpgdat->kcompactd = kthread_run(kcompactd, pgdat, \"kcompactd%d\", nid);\n\tif (IS_ERR(pgdat->kcompactd)) {\n\t\tpr_err(\"Failed to start kcompactd on node %d\\n\", nid);\n\t\tret = PTR_ERR(pgdat->kcompactd);\n\t\tpgdat->kcompactd = NULL;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "pgdat->kcompactd"
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to start kcompactd on node %d\\n\"",
            "nid"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pgdat->kcompactd"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "kcompactd",
            "pgdat",
            "\"kcompactd%d\"",
            "nid"
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nint kcompactd_run(int nid)\n{\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\tint ret = 0;\n\n\tif (pgdat->kcompactd)\n\t\treturn 0;\n\n\tpgdat->kcompactd = kthread_run(kcompactd, pgdat, \"kcompactd%d\", nid);\n\tif (IS_ERR(pgdat->kcompactd)) {\n\t\tpr_err(\"Failed to start kcompactd on node %d\\n\", nid);\n\t\tret = PTR_ERR(pgdat->kcompactd);\n\t\tpgdat->kcompactd = NULL;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "kcompactd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "2056-2084",
    "snippet": "static int kcompactd(void *p)\n{\n\tpg_data_t *pgdat = (pg_data_t*)p;\n\tstruct task_struct *tsk = current;\n\n\tconst struct cpumask *cpumask = cpumask_of_node(pgdat->node_id);\n\n\tif (!cpumask_empty(cpumask))\n\t\tset_cpus_allowed_ptr(tsk, cpumask);\n\n\tset_freezable();\n\n\tpgdat->kcompactd_max_order = 0;\n\tpgdat->kcompactd_classzone_idx = pgdat->nr_zones - 1;\n\n\twhile (!kthread_should_stop()) {\n\t\tunsigned long pflags;\n\n\t\ttrace_mm_compaction_kcompactd_sleep(pgdat->node_id);\n\t\twait_event_freezable(pgdat->kcompactd_wait,\n\t\t\t\tkcompactd_work_requested(pgdat));\n\n\t\tpsi_memstall_enter(&pflags);\n\t\tkcompactd_do_work(pgdat);\n\t\tpsi_memstall_leave(&pflags);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "psi_memstall_leave",
          "args": [
            "&pflags"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcompactd_do_work",
          "args": [
            "pgdat"
          ],
          "line": 2079
        },
        "resolved": true,
        "details": {
          "function_name": "kcompactd_do_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1941-2024",
          "snippet": "static void kcompactd_do_work(pg_data_t *pgdat)\n{\n\t/*\n\t * With no special task, compact all zones so that a page of requested\n\t * order is allocatable.\n\t */\n\tint zoneid;\n\tstruct zone *zone;\n\tstruct compact_control cc = {\n\t\t.order = pgdat->kcompactd_max_order,\n\t\t.total_migrate_scanned = 0,\n\t\t.total_free_scanned = 0,\n\t\t.classzone_idx = pgdat->kcompactd_classzone_idx,\n\t\t.mode = MIGRATE_SYNC_LIGHT,\n\t\t.ignore_skip_hint = false,\n\t\t.gfp_mask = GFP_KERNEL,\n\t};\n\ttrace_mm_compaction_kcompactd_wake(pgdat->node_id, cc.order,\n\t\t\t\t\t\t\tcc.classzone_idx);\n\tcount_compact_event(KCOMPACTD_WAKE);\n\n\tfor (zoneid = 0; zoneid <= cc.classzone_idx; zoneid++) {\n\t\tint status;\n\n\t\tzone = &pgdat->node_zones[zoneid];\n\t\tif (!populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (compaction_deferred(zone, cc.order))\n\t\t\tcontinue;\n\n\t\tif (compaction_suitable(zone, cc.order, 0, zoneid) !=\n\t\t\t\t\t\t\tCOMPACT_CONTINUE)\n\t\t\tcontinue;\n\n\t\tcc.nr_freepages = 0;\n\t\tcc.nr_migratepages = 0;\n\t\tcc.total_migrate_scanned = 0;\n\t\tcc.total_free_scanned = 0;\n\t\tcc.zone = zone;\n\t\tINIT_LIST_HEAD(&cc.freepages);\n\t\tINIT_LIST_HEAD(&cc.migratepages);\n\n\t\tif (kthread_should_stop())\n\t\t\treturn;\n\t\tstatus = compact_zone(zone, &cc);\n\n\t\tif (status == COMPACT_SUCCESS) {\n\t\t\tcompaction_defer_reset(zone, cc.order, false);\n\t\t} else if (status == COMPACT_PARTIAL_SKIPPED || status == COMPACT_COMPLETE) {\n\t\t\t/*\n\t\t\t * Buddy pages may become stranded on pcps that could\n\t\t\t * otherwise coalesce on the zone's free area for\n\t\t\t * order >= cc.order.  This is ratelimited by the\n\t\t\t * upcoming deferral.\n\t\t\t */\n\t\t\tdrain_all_pages(zone);\n\n\t\t\t/*\n\t\t\t * We use sync migration mode here, so we defer like\n\t\t\t * sync direct compaction does.\n\t\t\t */\n\t\t\tdefer_compaction(zone, cc.order);\n\t\t}\n\n\t\tcount_compact_events(KCOMPACTD_MIGRATE_SCANNED,\n\t\t\t\t     cc.total_migrate_scanned);\n\t\tcount_compact_events(KCOMPACTD_FREE_SCANNED,\n\t\t\t\t     cc.total_free_scanned);\n\n\t\tVM_BUG_ON(!list_empty(&cc.freepages));\n\t\tVM_BUG_ON(!list_empty(&cc.migratepages));\n\t}\n\n\t/*\n\t * Regardless of success, we are done until woken up next. But remember\n\t * the requested order/classzone_idx in case it was higher/tighter than\n\t * our current ones\n\t */\n\tif (pgdat->kcompactd_max_order <= cc.order)\n\t\tpgdat->kcompactd_max_order = 0;\n\tif (pgdat->kcompactd_classzone_idx >= cc.classzone_idx)\n\t\tpgdat->kcompactd_classzone_idx = pgdat->nr_zones - 1;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic void kcompactd_do_work(pg_data_t *pgdat)\n{\n\t/*\n\t * With no special task, compact all zones so that a page of requested\n\t * order is allocatable.\n\t */\n\tint zoneid;\n\tstruct zone *zone;\n\tstruct compact_control cc = {\n\t\t.order = pgdat->kcompactd_max_order,\n\t\t.total_migrate_scanned = 0,\n\t\t.total_free_scanned = 0,\n\t\t.classzone_idx = pgdat->kcompactd_classzone_idx,\n\t\t.mode = MIGRATE_SYNC_LIGHT,\n\t\t.ignore_skip_hint = false,\n\t\t.gfp_mask = GFP_KERNEL,\n\t};\n\ttrace_mm_compaction_kcompactd_wake(pgdat->node_id, cc.order,\n\t\t\t\t\t\t\tcc.classzone_idx);\n\tcount_compact_event(KCOMPACTD_WAKE);\n\n\tfor (zoneid = 0; zoneid <= cc.classzone_idx; zoneid++) {\n\t\tint status;\n\n\t\tzone = &pgdat->node_zones[zoneid];\n\t\tif (!populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (compaction_deferred(zone, cc.order))\n\t\t\tcontinue;\n\n\t\tif (compaction_suitable(zone, cc.order, 0, zoneid) !=\n\t\t\t\t\t\t\tCOMPACT_CONTINUE)\n\t\t\tcontinue;\n\n\t\tcc.nr_freepages = 0;\n\t\tcc.nr_migratepages = 0;\n\t\tcc.total_migrate_scanned = 0;\n\t\tcc.total_free_scanned = 0;\n\t\tcc.zone = zone;\n\t\tINIT_LIST_HEAD(&cc.freepages);\n\t\tINIT_LIST_HEAD(&cc.migratepages);\n\n\t\tif (kthread_should_stop())\n\t\t\treturn;\n\t\tstatus = compact_zone(zone, &cc);\n\n\t\tif (status == COMPACT_SUCCESS) {\n\t\t\tcompaction_defer_reset(zone, cc.order, false);\n\t\t} else if (status == COMPACT_PARTIAL_SKIPPED || status == COMPACT_COMPLETE) {\n\t\t\t/*\n\t\t\t * Buddy pages may become stranded on pcps that could\n\t\t\t * otherwise coalesce on the zone's free area for\n\t\t\t * order >= cc.order.  This is ratelimited by the\n\t\t\t * upcoming deferral.\n\t\t\t */\n\t\t\tdrain_all_pages(zone);\n\n\t\t\t/*\n\t\t\t * We use sync migration mode here, so we defer like\n\t\t\t * sync direct compaction does.\n\t\t\t */\n\t\t\tdefer_compaction(zone, cc.order);\n\t\t}\n\n\t\tcount_compact_events(KCOMPACTD_MIGRATE_SCANNED,\n\t\t\t\t     cc.total_migrate_scanned);\n\t\tcount_compact_events(KCOMPACTD_FREE_SCANNED,\n\t\t\t\t     cc.total_free_scanned);\n\n\t\tVM_BUG_ON(!list_empty(&cc.freepages));\n\t\tVM_BUG_ON(!list_empty(&cc.migratepages));\n\t}\n\n\t/*\n\t * Regardless of success, we are done until woken up next. But remember\n\t * the requested order/classzone_idx in case it was higher/tighter than\n\t * our current ones\n\t */\n\tif (pgdat->kcompactd_max_order <= cc.order)\n\t\tpgdat->kcompactd_max_order = 0;\n\tif (pgdat->kcompactd_classzone_idx >= cc.classzone_idx)\n\t\tpgdat->kcompactd_classzone_idx = pgdat->nr_zones - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "psi_memstall_enter",
          "args": [
            "&pflags"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_freezable",
          "args": [
            "pgdat->kcompactd_wait",
            "kcompactd_work_requested(pgdat)"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcompactd_work_requested",
          "args": [
            "pgdat"
          ],
          "line": 2076
        },
        "resolved": true,
        "details": {
          "function_name": "kcompactd_work_requested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1916-1919",
          "snippet": "static inline bool kcompactd_work_requested(pg_data_t *pgdat)\n{\n\treturn pgdat->kcompactd_max_order > 0 || kthread_should_stop();\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline bool kcompactd_work_requested(pg_data_t *pgdat)\n{\n\treturn pgdat->kcompactd_max_order > 0 || kthread_should_stop();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_mm_compaction_kcompactd_sleep",
          "args": [
            "pgdat->node_id"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_freezable",
          "args": [],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "tsk",
            "cpumask"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "cpumask"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of_node",
          "args": [
            "pgdat->node_id"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic int kcompactd(void *p)\n{\n\tpg_data_t *pgdat = (pg_data_t*)p;\n\tstruct task_struct *tsk = current;\n\n\tconst struct cpumask *cpumask = cpumask_of_node(pgdat->node_id);\n\n\tif (!cpumask_empty(cpumask))\n\t\tset_cpus_allowed_ptr(tsk, cpumask);\n\n\tset_freezable();\n\n\tpgdat->kcompactd_max_order = 0;\n\tpgdat->kcompactd_classzone_idx = pgdat->nr_zones - 1;\n\n\twhile (!kthread_should_stop()) {\n\t\tunsigned long pflags;\n\n\t\ttrace_mm_compaction_kcompactd_sleep(pgdat->node_id);\n\t\twait_event_freezable(pgdat->kcompactd_wait,\n\t\t\t\tkcompactd_work_requested(pgdat));\n\n\t\tpsi_memstall_enter(&pflags);\n\t\tkcompactd_do_work(pgdat);\n\t\tpsi_memstall_leave(&pflags);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "wakeup_kcompactd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "2026-2050",
    "snippet": "void wakeup_kcompactd(pg_data_t *pgdat, int order, int classzone_idx)\n{\n\tif (!order)\n\t\treturn;\n\n\tif (pgdat->kcompactd_max_order < order)\n\t\tpgdat->kcompactd_max_order = order;\n\n\tif (pgdat->kcompactd_classzone_idx > classzone_idx)\n\t\tpgdat->kcompactd_classzone_idx = classzone_idx;\n\n\t/*\n\t * Pairs with implicit barrier in wait_event_freezable()\n\t * such that wakeups are not missed.\n\t */\n\tif (!wq_has_sleeper(&pgdat->kcompactd_wait))\n\t\treturn;\n\n\tif (!kcompactd_node_suitable(pgdat))\n\t\treturn;\n\n\ttrace_mm_compaction_wakeup_kcompactd(pgdat->node_id, order,\n\t\t\t\t\t\t\tclasszone_idx);\n\twake_up_interruptible(&pgdat->kcompactd_wait);\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&pgdat->kcompactd_wait"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_mm_compaction_wakeup_kcompactd",
          "args": [
            "pgdat->node_id",
            "order",
            "classzone_idx"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcompactd_node_suitable",
          "args": [
            "pgdat"
          ],
          "line": 2044
        },
        "resolved": true,
        "details": {
          "function_name": "kcompactd_node_suitable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1921-1939",
          "snippet": "static bool kcompactd_node_suitable(pg_data_t *pgdat)\n{\n\tint zoneid;\n\tstruct zone *zone;\n\tenum zone_type classzone_idx = pgdat->kcompactd_classzone_idx;\n\n\tfor (zoneid = 0; zoneid <= classzone_idx; zoneid++) {\n\t\tzone = &pgdat->node_zones[zoneid];\n\n\t\tif (!populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (compaction_suitable(zone, pgdat->kcompactd_max_order, 0,\n\t\t\t\t\tclasszone_idx) == COMPACT_CONTINUE)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic bool kcompactd_node_suitable(pg_data_t *pgdat)\n{\n\tint zoneid;\n\tstruct zone *zone;\n\tenum zone_type classzone_idx = pgdat->kcompactd_classzone_idx;\n\n\tfor (zoneid = 0; zoneid <= classzone_idx; zoneid++) {\n\t\tzone = &pgdat->node_zones[zoneid];\n\n\t\tif (!populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (compaction_suitable(zone, pgdat->kcompactd_max_order, 0,\n\t\t\t\t\tclasszone_idx) == COMPACT_CONTINUE)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wq_has_sleeper",
          "args": [
            "&pgdat->kcompactd_wait"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nvoid wakeup_kcompactd(pg_data_t *pgdat, int order, int classzone_idx)\n{\n\tif (!order)\n\t\treturn;\n\n\tif (pgdat->kcompactd_max_order < order)\n\t\tpgdat->kcompactd_max_order = order;\n\n\tif (pgdat->kcompactd_classzone_idx > classzone_idx)\n\t\tpgdat->kcompactd_classzone_idx = classzone_idx;\n\n\t/*\n\t * Pairs with implicit barrier in wait_event_freezable()\n\t * such that wakeups are not missed.\n\t */\n\tif (!wq_has_sleeper(&pgdat->kcompactd_wait))\n\t\treturn;\n\n\tif (!kcompactd_node_suitable(pgdat))\n\t\treturn;\n\n\ttrace_mm_compaction_wakeup_kcompactd(pgdat->node_id, order,\n\t\t\t\t\t\t\tclasszone_idx);\n\twake_up_interruptible(&pgdat->kcompactd_wait);\n}"
  },
  {
    "function_name": "kcompactd_do_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "1941-2024",
    "snippet": "static void kcompactd_do_work(pg_data_t *pgdat)\n{\n\t/*\n\t * With no special task, compact all zones so that a page of requested\n\t * order is allocatable.\n\t */\n\tint zoneid;\n\tstruct zone *zone;\n\tstruct compact_control cc = {\n\t\t.order = pgdat->kcompactd_max_order,\n\t\t.total_migrate_scanned = 0,\n\t\t.total_free_scanned = 0,\n\t\t.classzone_idx = pgdat->kcompactd_classzone_idx,\n\t\t.mode = MIGRATE_SYNC_LIGHT,\n\t\t.ignore_skip_hint = false,\n\t\t.gfp_mask = GFP_KERNEL,\n\t};\n\ttrace_mm_compaction_kcompactd_wake(pgdat->node_id, cc.order,\n\t\t\t\t\t\t\tcc.classzone_idx);\n\tcount_compact_event(KCOMPACTD_WAKE);\n\n\tfor (zoneid = 0; zoneid <= cc.classzone_idx; zoneid++) {\n\t\tint status;\n\n\t\tzone = &pgdat->node_zones[zoneid];\n\t\tif (!populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (compaction_deferred(zone, cc.order))\n\t\t\tcontinue;\n\n\t\tif (compaction_suitable(zone, cc.order, 0, zoneid) !=\n\t\t\t\t\t\t\tCOMPACT_CONTINUE)\n\t\t\tcontinue;\n\n\t\tcc.nr_freepages = 0;\n\t\tcc.nr_migratepages = 0;\n\t\tcc.total_migrate_scanned = 0;\n\t\tcc.total_free_scanned = 0;\n\t\tcc.zone = zone;\n\t\tINIT_LIST_HEAD(&cc.freepages);\n\t\tINIT_LIST_HEAD(&cc.migratepages);\n\n\t\tif (kthread_should_stop())\n\t\t\treturn;\n\t\tstatus = compact_zone(zone, &cc);\n\n\t\tif (status == COMPACT_SUCCESS) {\n\t\t\tcompaction_defer_reset(zone, cc.order, false);\n\t\t} else if (status == COMPACT_PARTIAL_SKIPPED || status == COMPACT_COMPLETE) {\n\t\t\t/*\n\t\t\t * Buddy pages may become stranded on pcps that could\n\t\t\t * otherwise coalesce on the zone's free area for\n\t\t\t * order >= cc.order.  This is ratelimited by the\n\t\t\t * upcoming deferral.\n\t\t\t */\n\t\t\tdrain_all_pages(zone);\n\n\t\t\t/*\n\t\t\t * We use sync migration mode here, so we defer like\n\t\t\t * sync direct compaction does.\n\t\t\t */\n\t\t\tdefer_compaction(zone, cc.order);\n\t\t}\n\n\t\tcount_compact_events(KCOMPACTD_MIGRATE_SCANNED,\n\t\t\t\t     cc.total_migrate_scanned);\n\t\tcount_compact_events(KCOMPACTD_FREE_SCANNED,\n\t\t\t\t     cc.total_free_scanned);\n\n\t\tVM_BUG_ON(!list_empty(&cc.freepages));\n\t\tVM_BUG_ON(!list_empty(&cc.migratepages));\n\t}\n\n\t/*\n\t * Regardless of success, we are done until woken up next. But remember\n\t * the requested order/classzone_idx in case it was higher/tighter than\n\t * our current ones\n\t */\n\tif (pgdat->kcompactd_max_order <= cc.order)\n\t\tpgdat->kcompactd_max_order = 0;\n\tif (pgdat->kcompactd_classzone_idx >= cc.classzone_idx)\n\t\tpgdat->kcompactd_classzone_idx = pgdat->nr_zones - 1;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!list_empty(&cc.migratepages)"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cc.migratepages"
          ],
          "line": 2012
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!list_empty(&cc.freepages)"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_compact_events",
          "args": [
            "KCOMPACTD_FREE_SCANNED",
            "cc.total_free_scanned"
          ],
          "line": 2008
        },
        "resolved": true,
        "details": {
          "function_name": "count_compact_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "34-37",
          "snippet": "static inline void count_compact_events(enum vm_event_item item, long delta)\n{\n\tcount_vm_events(item, delta);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline void count_compact_events(enum vm_event_item item, long delta)\n{\n\tcount_vm_events(item, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "defer_compaction",
          "args": [
            "zone",
            "cc.order"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "defer_compaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "142-154",
          "snippet": "void defer_compaction(struct zone *zone, int order)\n{\n\tzone->compact_considered = 0;\n\tzone->compact_defer_shift++;\n\n\tif (order < zone->compact_order_failed)\n\t\tzone->compact_order_failed = order;\n\n\tif (zone->compact_defer_shift > COMPACT_MAX_DEFER_SHIFT)\n\t\tzone->compact_defer_shift = COMPACT_MAX_DEFER_SHIFT;\n\n\ttrace_mm_compaction_defer_compaction(zone, order);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define COMPACT_MAX_DEFER_SHIFT 6"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\n#define COMPACT_MAX_DEFER_SHIFT 6\n\nvoid defer_compaction(struct zone *zone, int order)\n{\n\tzone->compact_considered = 0;\n\tzone->compact_defer_shift++;\n\n\tif (order < zone->compact_order_failed)\n\t\tzone->compact_order_failed = order;\n\n\tif (zone->compact_defer_shift > COMPACT_MAX_DEFER_SHIFT)\n\t\tzone->compact_defer_shift = COMPACT_MAX_DEFER_SHIFT;\n\n\ttrace_mm_compaction_defer_compaction(zone, order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drain_all_pages",
          "args": [
            "zone"
          ],
          "line": 1997
        },
        "resolved": true,
        "details": {
          "function_name": "drain_all_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2614-2682",
          "snippet": "void drain_all_pages(struct zone *zone)\n{\n\tint cpu;\n\n\t/*\n\t * Allocate in the BSS so we wont require allocation in\n\t * direct reclaim path for CONFIG_CPUMASK_OFFSTACK=y\n\t */\n\tstatic cpumask_t cpus_with_pcps;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON_ONCE(!mm_percpu_wq))\n\t\treturn;\n\n\t/*\n\t * Do not drain if one is already in progress unless it's specific to\n\t * a zone. Such callers are primarily CMA and memory hotplug and need\n\t * the drain to be complete when the call returns.\n\t */\n\tif (unlikely(!mutex_trylock(&pcpu_drain_mutex))) {\n\t\tif (!zone)\n\t\t\treturn;\n\t\tmutex_lock(&pcpu_drain_mutex);\n\t}\n\n\t/*\n\t * We don't care about racing with CPU hotplug event\n\t * as offline notification will cause the notified\n\t * cpu to drain that CPU pcps and on_each_cpu_mask\n\t * disables preemption as part of its processing\n\t */\n\tfor_each_online_cpu(cpu) {\n\t\tstruct per_cpu_pageset *pcp;\n\t\tstruct zone *z;\n\t\tbool has_pcps = false;\n\n\t\tif (zone) {\n\t\t\tpcp = per_cpu_ptr(zone->pageset, cpu);\n\t\t\tif (pcp->pcp.count)\n\t\t\t\thas_pcps = true;\n\t\t} else {\n\t\t\tfor_each_populated_zone(z) {\n\t\t\t\tpcp = per_cpu_ptr(z->pageset, cpu);\n\t\t\t\tif (pcp->pcp.count) {\n\t\t\t\t\thas_pcps = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (has_pcps)\n\t\t\tcpumask_set_cpu(cpu, &cpus_with_pcps);\n\t\telse\n\t\t\tcpumask_clear_cpu(cpu, &cpus_with_pcps);\n\t}\n\n\tfor_each_cpu(cpu, &cpus_with_pcps) {\n\t\tstruct work_struct *work = per_cpu_ptr(&pcpu_drain, cpu);\n\t\tINIT_WORK(work, drain_local_pages_wq);\n\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t}\n\tfor_each_cpu(cpu, &cpus_with_pcps)\n\t\tflush_work(per_cpu_ptr(&pcpu_drain, cpu));\n\n\tmutex_unlock(&pcpu_drain_mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid drain_all_pages(struct zone *zone)\n{\n\tint cpu;\n\n\t/*\n\t * Allocate in the BSS so we wont require allocation in\n\t * direct reclaim path for CONFIG_CPUMASK_OFFSTACK=y\n\t */\n\tstatic cpumask_t cpus_with_pcps;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON_ONCE(!mm_percpu_wq))\n\t\treturn;\n\n\t/*\n\t * Do not drain if one is already in progress unless it's specific to\n\t * a zone. Such callers are primarily CMA and memory hotplug and need\n\t * the drain to be complete when the call returns.\n\t */\n\tif (unlikely(!mutex_trylock(&pcpu_drain_mutex))) {\n\t\tif (!zone)\n\t\t\treturn;\n\t\tmutex_lock(&pcpu_drain_mutex);\n\t}\n\n\t/*\n\t * We don't care about racing with CPU hotplug event\n\t * as offline notification will cause the notified\n\t * cpu to drain that CPU pcps and on_each_cpu_mask\n\t * disables preemption as part of its processing\n\t */\n\tfor_each_online_cpu(cpu) {\n\t\tstruct per_cpu_pageset *pcp;\n\t\tstruct zone *z;\n\t\tbool has_pcps = false;\n\n\t\tif (zone) {\n\t\t\tpcp = per_cpu_ptr(zone->pageset, cpu);\n\t\t\tif (pcp->pcp.count)\n\t\t\t\thas_pcps = true;\n\t\t} else {\n\t\t\tfor_each_populated_zone(z) {\n\t\t\t\tpcp = per_cpu_ptr(z->pageset, cpu);\n\t\t\t\tif (pcp->pcp.count) {\n\t\t\t\t\thas_pcps = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (has_pcps)\n\t\t\tcpumask_set_cpu(cpu, &cpus_with_pcps);\n\t\telse\n\t\t\tcpumask_clear_cpu(cpu, &cpus_with_pcps);\n\t}\n\n\tfor_each_cpu(cpu, &cpus_with_pcps) {\n\t\tstruct work_struct *work = per_cpu_ptr(&pcpu_drain, cpu);\n\t\tINIT_WORK(work, drain_local_pages_wq);\n\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t}\n\tfor_each_cpu(cpu, &cpus_with_pcps)\n\t\tflush_work(per_cpu_ptr(&pcpu_drain, cpu));\n\n\tmutex_unlock(&pcpu_drain_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compaction_defer_reset",
          "args": [
            "zone",
            "cc.order",
            "false"
          ],
          "line": 1989
        },
        "resolved": true,
        "details": {
          "function_name": "compaction_defer_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "181-192",
          "snippet": "void compaction_defer_reset(struct zone *zone, int order,\n\t\tbool alloc_success)\n{\n\tif (alloc_success) {\n\t\tzone->compact_considered = 0;\n\t\tzone->compact_defer_shift = 0;\n\t}\n\tif (order >= zone->compact_order_failed)\n\t\tzone->compact_order_failed = order + 1;\n\n\ttrace_mm_compaction_defer_reset(zone, order);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nvoid compaction_defer_reset(struct zone *zone, int order,\n\t\tbool alloc_success)\n{\n\tif (alloc_success) {\n\t\tzone->compact_considered = 0;\n\t\tzone->compact_defer_shift = 0;\n\t}\n\tif (order >= zone->compact_order_failed)\n\t\tzone->compact_order_failed = order + 1;\n\n\ttrace_mm_compaction_defer_reset(zone, order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact_zone",
          "args": [
            "zone",
            "&cc"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "compact_zone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1537-1699",
          "snippet": "static enum compact_result compact_zone(struct zone *zone, struct compact_control *cc)\n{\n\tenum compact_result ret;\n\tunsigned long start_pfn = zone->zone_start_pfn;\n\tunsigned long end_pfn = zone_end_pfn(zone);\n\tconst bool sync = cc->mode != MIGRATE_ASYNC;\n\n\tcc->migratetype = gfpflags_to_migratetype(cc->gfp_mask);\n\tret = compaction_suitable(zone, cc->order, cc->alloc_flags,\n\t\t\t\t\t\t\tcc->classzone_idx);\n\t/* Compaction is likely to fail */\n\tif (ret == COMPACT_SUCCESS || ret == COMPACT_SKIPPED)\n\t\treturn ret;\n\n\t/* huh, compaction_suitable is returning something unexpected */\n\tVM_BUG_ON(ret != COMPACT_CONTINUE);\n\n\t/*\n\t * Clear pageblock skip if there were failures recently and compaction\n\t * is about to be retried after being deferred.\n\t */\n\tif (compaction_restarting(zone, cc->order))\n\t\t__reset_isolation_suitable(zone);\n\n\t/*\n\t * Setup to move all movable pages to the end of the zone. Used cached\n\t * information on where the scanners should start (unless we explicitly\n\t * want to compact the whole zone), but check that it is initialised\n\t * by ensuring the values are within zone boundaries.\n\t */\n\tif (cc->whole_zone) {\n\t\tcc->migrate_pfn = start_pfn;\n\t\tcc->free_pfn = pageblock_start_pfn(end_pfn - 1);\n\t} else {\n\t\tcc->migrate_pfn = zone->compact_cached_migrate_pfn[sync];\n\t\tcc->free_pfn = zone->compact_cached_free_pfn;\n\t\tif (cc->free_pfn < start_pfn || cc->free_pfn >= end_pfn) {\n\t\t\tcc->free_pfn = pageblock_start_pfn(end_pfn - 1);\n\t\t\tzone->compact_cached_free_pfn = cc->free_pfn;\n\t\t}\n\t\tif (cc->migrate_pfn < start_pfn || cc->migrate_pfn >= end_pfn) {\n\t\t\tcc->migrate_pfn = start_pfn;\n\t\t\tzone->compact_cached_migrate_pfn[0] = cc->migrate_pfn;\n\t\t\tzone->compact_cached_migrate_pfn[1] = cc->migrate_pfn;\n\t\t}\n\n\t\tif (cc->migrate_pfn == start_pfn)\n\t\t\tcc->whole_zone = true;\n\t}\n\n\tcc->last_migrated_pfn = 0;\n\n\ttrace_mm_compaction_begin(start_pfn, cc->migrate_pfn,\n\t\t\t\tcc->free_pfn, end_pfn, sync);\n\n\tmigrate_prep_local();\n\n\twhile ((ret = compact_finished(zone, cc)) == COMPACT_CONTINUE) {\n\t\tint err;\n\n\t\tswitch (isolate_migratepages(zone, cc)) {\n\t\tcase ISOLATE_ABORT:\n\t\t\tret = COMPACT_CONTENDED;\n\t\t\tputback_movable_pages(&cc->migratepages);\n\t\t\tcc->nr_migratepages = 0;\n\t\t\tgoto out;\n\t\tcase ISOLATE_NONE:\n\t\t\t/*\n\t\t\t * We haven't isolated and migrated anything, but\n\t\t\t * there might still be unflushed migrations from\n\t\t\t * previous cc->order aligned block.\n\t\t\t */\n\t\t\tgoto check_drain;\n\t\tcase ISOLATE_SUCCESS:\n\t\t\t;\n\t\t}\n\n\t\terr = migrate_pages(&cc->migratepages, compaction_alloc,\n\t\t\t\tcompaction_free, (unsigned long)cc, cc->mode,\n\t\t\t\tMR_COMPACTION);\n\n\t\ttrace_mm_compaction_migratepages(cc->nr_migratepages, err,\n\t\t\t\t\t\t\t&cc->migratepages);\n\n\t\t/* All pages were either migrated or will be released */\n\t\tcc->nr_migratepages = 0;\n\t\tif (err) {\n\t\t\tputback_movable_pages(&cc->migratepages);\n\t\t\t/*\n\t\t\t * migrate_pages() may return -ENOMEM when scanners meet\n\t\t\t * and we want compact_finished() to detect it\n\t\t\t */\n\t\t\tif (err == -ENOMEM && !compact_scanners_met(cc)) {\n\t\t\t\tret = COMPACT_CONTENDED;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We failed to migrate at least one page in the current\n\t\t\t * order-aligned block, so skip the rest of it.\n\t\t\t */\n\t\t\tif (cc->direct_compaction &&\n\t\t\t\t\t\t(cc->mode == MIGRATE_ASYNC)) {\n\t\t\t\tcc->migrate_pfn = block_end_pfn(\n\t\t\t\t\t\tcc->migrate_pfn - 1, cc->order);\n\t\t\t\t/* Draining pcplists is useless in this case */\n\t\t\t\tcc->last_migrated_pfn = 0;\n\n\t\t\t}\n\t\t}\n\ncheck_drain:\n\t\t/*\n\t\t * Has the migration scanner moved away from the previous\n\t\t * cc->order aligned block where we migrated from? If yes,\n\t\t * flush the pages that were freed, so that they can merge and\n\t\t * compact_finished() can detect immediately if allocation\n\t\t * would succeed.\n\t\t */\n\t\tif (cc->order > 0 && cc->last_migrated_pfn) {\n\t\t\tint cpu;\n\t\t\tunsigned long current_block_start =\n\t\t\t\tblock_start_pfn(cc->migrate_pfn, cc->order);\n\n\t\t\tif (cc->last_migrated_pfn < current_block_start) {\n\t\t\t\tcpu = get_cpu();\n\t\t\t\tlru_add_drain_cpu(cpu);\n\t\t\t\tdrain_local_pages(zone);\n\t\t\t\tput_cpu();\n\t\t\t\t/* No more flushing until we migrate again */\n\t\t\t\tcc->last_migrated_pfn = 0;\n\t\t\t}\n\t\t}\n\n\t}\n\nout:\n\t/*\n\t * Release free pages and update where the free scanner should restart,\n\t * so we don't leave any returned pages behind in the next attempt.\n\t */\n\tif (cc->nr_freepages > 0) {\n\t\tunsigned long free_pfn = release_freepages(&cc->freepages);\n\n\t\tcc->nr_freepages = 0;\n\t\tVM_BUG_ON(free_pfn == 0);\n\t\t/* The cached pfn is always the first in a pageblock */\n\t\tfree_pfn = pageblock_start_pfn(free_pfn);\n\t\t/*\n\t\t * Only go back, not forward. The cached pfn might have been\n\t\t * already reset to zone end in compact_finished()\n\t\t */\n\t\tif (free_pfn > zone->compact_cached_free_pfn)\n\t\t\tzone->compact_cached_free_pfn = free_pfn;\n\t}\n\n\tcount_compact_events(COMPACTMIGRATE_SCANNED, cc->total_migrate_scanned);\n\tcount_compact_events(COMPACTFREE_SCANNED, cc->total_free_scanned);\n\n\ttrace_mm_compaction_end(start_pfn, cc->migrate_pfn,\n\t\t\t\tcc->free_pfn, end_pfn, sync, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic enum compact_result compact_zone(struct zone *zone, struct compact_control *cc)\n{\n\tenum compact_result ret;\n\tunsigned long start_pfn = zone->zone_start_pfn;\n\tunsigned long end_pfn = zone_end_pfn(zone);\n\tconst bool sync = cc->mode != MIGRATE_ASYNC;\n\n\tcc->migratetype = gfpflags_to_migratetype(cc->gfp_mask);\n\tret = compaction_suitable(zone, cc->order, cc->alloc_flags,\n\t\t\t\t\t\t\tcc->classzone_idx);\n\t/* Compaction is likely to fail */\n\tif (ret == COMPACT_SUCCESS || ret == COMPACT_SKIPPED)\n\t\treturn ret;\n\n\t/* huh, compaction_suitable is returning something unexpected */\n\tVM_BUG_ON(ret != COMPACT_CONTINUE);\n\n\t/*\n\t * Clear pageblock skip if there were failures recently and compaction\n\t * is about to be retried after being deferred.\n\t */\n\tif (compaction_restarting(zone, cc->order))\n\t\t__reset_isolation_suitable(zone);\n\n\t/*\n\t * Setup to move all movable pages to the end of the zone. Used cached\n\t * information on where the scanners should start (unless we explicitly\n\t * want to compact the whole zone), but check that it is initialised\n\t * by ensuring the values are within zone boundaries.\n\t */\n\tif (cc->whole_zone) {\n\t\tcc->migrate_pfn = start_pfn;\n\t\tcc->free_pfn = pageblock_start_pfn(end_pfn - 1);\n\t} else {\n\t\tcc->migrate_pfn = zone->compact_cached_migrate_pfn[sync];\n\t\tcc->free_pfn = zone->compact_cached_free_pfn;\n\t\tif (cc->free_pfn < start_pfn || cc->free_pfn >= end_pfn) {\n\t\t\tcc->free_pfn = pageblock_start_pfn(end_pfn - 1);\n\t\t\tzone->compact_cached_free_pfn = cc->free_pfn;\n\t\t}\n\t\tif (cc->migrate_pfn < start_pfn || cc->migrate_pfn >= end_pfn) {\n\t\t\tcc->migrate_pfn = start_pfn;\n\t\t\tzone->compact_cached_migrate_pfn[0] = cc->migrate_pfn;\n\t\t\tzone->compact_cached_migrate_pfn[1] = cc->migrate_pfn;\n\t\t}\n\n\t\tif (cc->migrate_pfn == start_pfn)\n\t\t\tcc->whole_zone = true;\n\t}\n\n\tcc->last_migrated_pfn = 0;\n\n\ttrace_mm_compaction_begin(start_pfn, cc->migrate_pfn,\n\t\t\t\tcc->free_pfn, end_pfn, sync);\n\n\tmigrate_prep_local();\n\n\twhile ((ret = compact_finished(zone, cc)) == COMPACT_CONTINUE) {\n\t\tint err;\n\n\t\tswitch (isolate_migratepages(zone, cc)) {\n\t\tcase ISOLATE_ABORT:\n\t\t\tret = COMPACT_CONTENDED;\n\t\t\tputback_movable_pages(&cc->migratepages);\n\t\t\tcc->nr_migratepages = 0;\n\t\t\tgoto out;\n\t\tcase ISOLATE_NONE:\n\t\t\t/*\n\t\t\t * We haven't isolated and migrated anything, but\n\t\t\t * there might still be unflushed migrations from\n\t\t\t * previous cc->order aligned block.\n\t\t\t */\n\t\t\tgoto check_drain;\n\t\tcase ISOLATE_SUCCESS:\n\t\t\t;\n\t\t}\n\n\t\terr = migrate_pages(&cc->migratepages, compaction_alloc,\n\t\t\t\tcompaction_free, (unsigned long)cc, cc->mode,\n\t\t\t\tMR_COMPACTION);\n\n\t\ttrace_mm_compaction_migratepages(cc->nr_migratepages, err,\n\t\t\t\t\t\t\t&cc->migratepages);\n\n\t\t/* All pages were either migrated or will be released */\n\t\tcc->nr_migratepages = 0;\n\t\tif (err) {\n\t\t\tputback_movable_pages(&cc->migratepages);\n\t\t\t/*\n\t\t\t * migrate_pages() may return -ENOMEM when scanners meet\n\t\t\t * and we want compact_finished() to detect it\n\t\t\t */\n\t\t\tif (err == -ENOMEM && !compact_scanners_met(cc)) {\n\t\t\t\tret = COMPACT_CONTENDED;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We failed to migrate at least one page in the current\n\t\t\t * order-aligned block, so skip the rest of it.\n\t\t\t */\n\t\t\tif (cc->direct_compaction &&\n\t\t\t\t\t\t(cc->mode == MIGRATE_ASYNC)) {\n\t\t\t\tcc->migrate_pfn = block_end_pfn(\n\t\t\t\t\t\tcc->migrate_pfn - 1, cc->order);\n\t\t\t\t/* Draining pcplists is useless in this case */\n\t\t\t\tcc->last_migrated_pfn = 0;\n\n\t\t\t}\n\t\t}\n\ncheck_drain:\n\t\t/*\n\t\t * Has the migration scanner moved away from the previous\n\t\t * cc->order aligned block where we migrated from? If yes,\n\t\t * flush the pages that were freed, so that they can merge and\n\t\t * compact_finished() can detect immediately if allocation\n\t\t * would succeed.\n\t\t */\n\t\tif (cc->order > 0 && cc->last_migrated_pfn) {\n\t\t\tint cpu;\n\t\t\tunsigned long current_block_start =\n\t\t\t\tblock_start_pfn(cc->migrate_pfn, cc->order);\n\n\t\t\tif (cc->last_migrated_pfn < current_block_start) {\n\t\t\t\tcpu = get_cpu();\n\t\t\t\tlru_add_drain_cpu(cpu);\n\t\t\t\tdrain_local_pages(zone);\n\t\t\t\tput_cpu();\n\t\t\t\t/* No more flushing until we migrate again */\n\t\t\t\tcc->last_migrated_pfn = 0;\n\t\t\t}\n\t\t}\n\n\t}\n\nout:\n\t/*\n\t * Release free pages and update where the free scanner should restart,\n\t * so we don't leave any returned pages behind in the next attempt.\n\t */\n\tif (cc->nr_freepages > 0) {\n\t\tunsigned long free_pfn = release_freepages(&cc->freepages);\n\n\t\tcc->nr_freepages = 0;\n\t\tVM_BUG_ON(free_pfn == 0);\n\t\t/* The cached pfn is always the first in a pageblock */\n\t\tfree_pfn = pageblock_start_pfn(free_pfn);\n\t\t/*\n\t\t * Only go back, not forward. The cached pfn might have been\n\t\t * already reset to zone end in compact_finished()\n\t\t */\n\t\tif (free_pfn > zone->compact_cached_free_pfn)\n\t\t\tzone->compact_cached_free_pfn = free_pfn;\n\t}\n\n\tcount_compact_events(COMPACTMIGRATE_SCANNED, cc->total_migrate_scanned);\n\tcount_compact_events(COMPACTFREE_SCANNED, cc->total_free_scanned);\n\n\ttrace_mm_compaction_end(start_pfn, cc->migrate_pfn,\n\t\t\t\tcc->free_pfn, end_pfn, sync, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cc.migratepages"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cc.freepages"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compaction_suitable",
          "args": [
            "zone",
            "cc.order",
            "0",
            "zoneid"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "compaction_suitable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1467-1503",
          "snippet": "enum compact_result compaction_suitable(struct zone *zone, int order,\n\t\t\t\t\tunsigned int alloc_flags,\n\t\t\t\t\tint classzone_idx)\n{\n\tenum compact_result ret;\n\tint fragindex;\n\n\tret = __compaction_suitable(zone, order, alloc_flags, classzone_idx,\n\t\t\t\t    zone_page_state(zone, NR_FREE_PAGES));\n\t/*\n\t * fragmentation index determines if allocation failures are due to\n\t * low memory or external fragmentation\n\t *\n\t * index of -1000 would imply allocations might succeed depending on\n\t * watermarks, but we already failed the high-order watermark check\n\t * index towards 0 implies failure is due to lack of memory\n\t * index towards 1000 implies failure is due to fragmentation\n\t *\n\t * Only compact if a failure would be due to fragmentation. Also\n\t * ignore fragindex for non-costly orders where the alternative to\n\t * a successful reclaim/compaction is OOM. Fragindex and the\n\t * vm.extfrag_threshold sysctl is meant as a heuristic to prevent\n\t * excessive compaction for costly orders, but it should not be at the\n\t * expense of system stability.\n\t */\n\tif (ret == COMPACT_CONTINUE && (order > PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tfragindex = fragmentation_index(zone, order);\n\t\tif (fragindex >= 0 && fragindex <= sysctl_extfrag_threshold)\n\t\t\tret = COMPACT_NOT_SUITABLE_ZONE;\n\t}\n\n\ttrace_mm_compaction_suitable(zone, order, ret);\n\tif (ret == COMPACT_NOT_SUITABLE_ZONE)\n\t\tret = COMPACT_SKIPPED;\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nenum compact_result compaction_suitable(struct zone *zone, int order,\n\t\t\t\t\tunsigned int alloc_flags,\n\t\t\t\t\tint classzone_idx)\n{\n\tenum compact_result ret;\n\tint fragindex;\n\n\tret = __compaction_suitable(zone, order, alloc_flags, classzone_idx,\n\t\t\t\t    zone_page_state(zone, NR_FREE_PAGES));\n\t/*\n\t * fragmentation index determines if allocation failures are due to\n\t * low memory or external fragmentation\n\t *\n\t * index of -1000 would imply allocations might succeed depending on\n\t * watermarks, but we already failed the high-order watermark check\n\t * index towards 0 implies failure is due to lack of memory\n\t * index towards 1000 implies failure is due to fragmentation\n\t *\n\t * Only compact if a failure would be due to fragmentation. Also\n\t * ignore fragindex for non-costly orders where the alternative to\n\t * a successful reclaim/compaction is OOM. Fragindex and the\n\t * vm.extfrag_threshold sysctl is meant as a heuristic to prevent\n\t * excessive compaction for costly orders, but it should not be at the\n\t * expense of system stability.\n\t */\n\tif (ret == COMPACT_CONTINUE && (order > PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tfragindex = fragmentation_index(zone, order);\n\t\tif (fragindex >= 0 && fragindex <= sysctl_extfrag_threshold)\n\t\t\tret = COMPACT_NOT_SUITABLE_ZONE;\n\t}\n\n\ttrace_mm_compaction_suitable(zone, order, ret);\n\tif (ret == COMPACT_NOT_SUITABLE_ZONE)\n\t\tret = COMPACT_SKIPPED;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compaction_deferred",
          "args": [
            "zone",
            "cc.order"
          ],
          "line": 1969
        },
        "resolved": true,
        "details": {
          "function_name": "compaction_deferred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "157-174",
          "snippet": "bool compaction_deferred(struct zone *zone, int order)\n{\n\tunsigned long defer_limit = 1UL << zone->compact_defer_shift;\n\n\tif (order < zone->compact_order_failed)\n\t\treturn false;\n\n\t/* Avoid possible overflow */\n\tif (++zone->compact_considered > defer_limit)\n\t\tzone->compact_considered = defer_limit;\n\n\tif (zone->compact_considered >= defer_limit)\n\t\treturn false;\n\n\ttrace_mm_compaction_deferred(zone, order);\n\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nbool compaction_deferred(struct zone *zone, int order)\n{\n\tunsigned long defer_limit = 1UL << zone->compact_defer_shift;\n\n\tif (order < zone->compact_order_failed)\n\t\treturn false;\n\n\t/* Avoid possible overflow */\n\tif (++zone->compact_considered > defer_limit)\n\t\tzone->compact_considered = defer_limit;\n\n\tif (zone->compact_considered >= defer_limit)\n\t\treturn false;\n\n\ttrace_mm_compaction_deferred(zone, order);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "populated_zone",
          "args": [
            "zone"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_compact_event",
          "args": [
            "KCOMPACTD_WAKE"
          ],
          "line": 1960
        },
        "resolved": true,
        "details": {
          "function_name": "count_compact_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "29-32",
          "snippet": "static inline void count_compact_event(enum vm_event_item item)\n{\n\tcount_vm_event(item);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline void count_compact_event(enum vm_event_item item)\n{\n\tcount_vm_event(item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_mm_compaction_kcompactd_wake",
          "args": [
            "pgdat->node_id",
            "cc.order",
            "cc.classzone_idx"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic void kcompactd_do_work(pg_data_t *pgdat)\n{\n\t/*\n\t * With no special task, compact all zones so that a page of requested\n\t * order is allocatable.\n\t */\n\tint zoneid;\n\tstruct zone *zone;\n\tstruct compact_control cc = {\n\t\t.order = pgdat->kcompactd_max_order,\n\t\t.total_migrate_scanned = 0,\n\t\t.total_free_scanned = 0,\n\t\t.classzone_idx = pgdat->kcompactd_classzone_idx,\n\t\t.mode = MIGRATE_SYNC_LIGHT,\n\t\t.ignore_skip_hint = false,\n\t\t.gfp_mask = GFP_KERNEL,\n\t};\n\ttrace_mm_compaction_kcompactd_wake(pgdat->node_id, cc.order,\n\t\t\t\t\t\t\tcc.classzone_idx);\n\tcount_compact_event(KCOMPACTD_WAKE);\n\n\tfor (zoneid = 0; zoneid <= cc.classzone_idx; zoneid++) {\n\t\tint status;\n\n\t\tzone = &pgdat->node_zones[zoneid];\n\t\tif (!populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (compaction_deferred(zone, cc.order))\n\t\t\tcontinue;\n\n\t\tif (compaction_suitable(zone, cc.order, 0, zoneid) !=\n\t\t\t\t\t\t\tCOMPACT_CONTINUE)\n\t\t\tcontinue;\n\n\t\tcc.nr_freepages = 0;\n\t\tcc.nr_migratepages = 0;\n\t\tcc.total_migrate_scanned = 0;\n\t\tcc.total_free_scanned = 0;\n\t\tcc.zone = zone;\n\t\tINIT_LIST_HEAD(&cc.freepages);\n\t\tINIT_LIST_HEAD(&cc.migratepages);\n\n\t\tif (kthread_should_stop())\n\t\t\treturn;\n\t\tstatus = compact_zone(zone, &cc);\n\n\t\tif (status == COMPACT_SUCCESS) {\n\t\t\tcompaction_defer_reset(zone, cc.order, false);\n\t\t} else if (status == COMPACT_PARTIAL_SKIPPED || status == COMPACT_COMPLETE) {\n\t\t\t/*\n\t\t\t * Buddy pages may become stranded on pcps that could\n\t\t\t * otherwise coalesce on the zone's free area for\n\t\t\t * order >= cc.order.  This is ratelimited by the\n\t\t\t * upcoming deferral.\n\t\t\t */\n\t\t\tdrain_all_pages(zone);\n\n\t\t\t/*\n\t\t\t * We use sync migration mode here, so we defer like\n\t\t\t * sync direct compaction does.\n\t\t\t */\n\t\t\tdefer_compaction(zone, cc.order);\n\t\t}\n\n\t\tcount_compact_events(KCOMPACTD_MIGRATE_SCANNED,\n\t\t\t\t     cc.total_migrate_scanned);\n\t\tcount_compact_events(KCOMPACTD_FREE_SCANNED,\n\t\t\t\t     cc.total_free_scanned);\n\n\t\tVM_BUG_ON(!list_empty(&cc.freepages));\n\t\tVM_BUG_ON(!list_empty(&cc.migratepages));\n\t}\n\n\t/*\n\t * Regardless of success, we are done until woken up next. But remember\n\t * the requested order/classzone_idx in case it was higher/tighter than\n\t * our current ones\n\t */\n\tif (pgdat->kcompactd_max_order <= cc.order)\n\t\tpgdat->kcompactd_max_order = 0;\n\tif (pgdat->kcompactd_classzone_idx >= cc.classzone_idx)\n\t\tpgdat->kcompactd_classzone_idx = pgdat->nr_zones - 1;\n}"
  },
  {
    "function_name": "kcompactd_node_suitable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "1921-1939",
    "snippet": "static bool kcompactd_node_suitable(pg_data_t *pgdat)\n{\n\tint zoneid;\n\tstruct zone *zone;\n\tenum zone_type classzone_idx = pgdat->kcompactd_classzone_idx;\n\n\tfor (zoneid = 0; zoneid <= classzone_idx; zoneid++) {\n\t\tzone = &pgdat->node_zones[zoneid];\n\n\t\tif (!populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (compaction_suitable(zone, pgdat->kcompactd_max_order, 0,\n\t\t\t\t\tclasszone_idx) == COMPACT_CONTINUE)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compaction_suitable",
          "args": [
            "zone",
            "pgdat->kcompactd_max_order",
            "0",
            "classzone_idx"
          ],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "compaction_suitable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1467-1503",
          "snippet": "enum compact_result compaction_suitable(struct zone *zone, int order,\n\t\t\t\t\tunsigned int alloc_flags,\n\t\t\t\t\tint classzone_idx)\n{\n\tenum compact_result ret;\n\tint fragindex;\n\n\tret = __compaction_suitable(zone, order, alloc_flags, classzone_idx,\n\t\t\t\t    zone_page_state(zone, NR_FREE_PAGES));\n\t/*\n\t * fragmentation index determines if allocation failures are due to\n\t * low memory or external fragmentation\n\t *\n\t * index of -1000 would imply allocations might succeed depending on\n\t * watermarks, but we already failed the high-order watermark check\n\t * index towards 0 implies failure is due to lack of memory\n\t * index towards 1000 implies failure is due to fragmentation\n\t *\n\t * Only compact if a failure would be due to fragmentation. Also\n\t * ignore fragindex for non-costly orders where the alternative to\n\t * a successful reclaim/compaction is OOM. Fragindex and the\n\t * vm.extfrag_threshold sysctl is meant as a heuristic to prevent\n\t * excessive compaction for costly orders, but it should not be at the\n\t * expense of system stability.\n\t */\n\tif (ret == COMPACT_CONTINUE && (order > PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tfragindex = fragmentation_index(zone, order);\n\t\tif (fragindex >= 0 && fragindex <= sysctl_extfrag_threshold)\n\t\t\tret = COMPACT_NOT_SUITABLE_ZONE;\n\t}\n\n\ttrace_mm_compaction_suitable(zone, order, ret);\n\tif (ret == COMPACT_NOT_SUITABLE_ZONE)\n\t\tret = COMPACT_SKIPPED;\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nenum compact_result compaction_suitable(struct zone *zone, int order,\n\t\t\t\t\tunsigned int alloc_flags,\n\t\t\t\t\tint classzone_idx)\n{\n\tenum compact_result ret;\n\tint fragindex;\n\n\tret = __compaction_suitable(zone, order, alloc_flags, classzone_idx,\n\t\t\t\t    zone_page_state(zone, NR_FREE_PAGES));\n\t/*\n\t * fragmentation index determines if allocation failures are due to\n\t * low memory or external fragmentation\n\t *\n\t * index of -1000 would imply allocations might succeed depending on\n\t * watermarks, but we already failed the high-order watermark check\n\t * index towards 0 implies failure is due to lack of memory\n\t * index towards 1000 implies failure is due to fragmentation\n\t *\n\t * Only compact if a failure would be due to fragmentation. Also\n\t * ignore fragindex for non-costly orders where the alternative to\n\t * a successful reclaim/compaction is OOM. Fragindex and the\n\t * vm.extfrag_threshold sysctl is meant as a heuristic to prevent\n\t * excessive compaction for costly orders, but it should not be at the\n\t * expense of system stability.\n\t */\n\tif (ret == COMPACT_CONTINUE && (order > PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tfragindex = fragmentation_index(zone, order);\n\t\tif (fragindex >= 0 && fragindex <= sysctl_extfrag_threshold)\n\t\t\tret = COMPACT_NOT_SUITABLE_ZONE;\n\t}\n\n\ttrace_mm_compaction_suitable(zone, order, ret);\n\tif (ret == COMPACT_NOT_SUITABLE_ZONE)\n\t\tret = COMPACT_SKIPPED;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "populated_zone",
          "args": [
            "zone"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic bool kcompactd_node_suitable(pg_data_t *pgdat)\n{\n\tint zoneid;\n\tstruct zone *zone;\n\tenum zone_type classzone_idx = pgdat->kcompactd_classzone_idx;\n\n\tfor (zoneid = 0; zoneid <= classzone_idx; zoneid++) {\n\t\tzone = &pgdat->node_zones[zoneid];\n\n\t\tif (!populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (compaction_suitable(zone, pgdat->kcompactd_max_order, 0,\n\t\t\t\t\tclasszone_idx) == COMPACT_CONTINUE)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "kcompactd_work_requested",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "1916-1919",
    "snippet": "static inline bool kcompactd_work_requested(pg_data_t *pgdat)\n{\n\treturn pgdat->kcompactd_max_order > 0 || kthread_should_stop();\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline bool kcompactd_work_requested(pg_data_t *pgdat)\n{\n\treturn pgdat->kcompactd_max_order > 0 || kthread_should_stop();\n}"
  },
  {
    "function_name": "compaction_unregister_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "1910-1913",
    "snippet": "void compaction_unregister_node(struct node *node)\n{\n\treturn device_remove_file(&node->dev, &dev_attr_compact);\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_remove_file",
          "args": [
            "&node->dev",
            "&dev_attr_compact"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nvoid compaction_unregister_node(struct node *node)\n{\n\treturn device_remove_file(&node->dev, &dev_attr_compact);\n}"
  },
  {
    "function_name": "compaction_register_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "1905-1908",
    "snippet": "int compaction_register_node(struct node *node)\n{\n\treturn device_create_file(&node->dev, &dev_attr_compact);\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_create_file",
          "args": [
            "&node->dev",
            "&dev_attr_compact"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nint compaction_register_node(struct node *node)\n{\n\treturn device_create_file(&node->dev, &dev_attr_compact);\n}"
  },
  {
    "function_name": "sysfs_compact_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "1888-1902",
    "snippet": "static ssize_t sysfs_compact_node(struct device *dev,\n\t\t\tstruct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tint nid = dev->id;\n\n\tif (nid >= 0 && nid < nr_node_ids && node_online(nid)) {\n\t\t/* Flush pending updates to the LRU lists */\n\t\tlru_add_drain_all();\n\n\t\tcompact_node(nid);\n\t}\n\n\treturn count;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compact_node",
          "args": [
            "nid"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "compact_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1816-1849",
          "snippet": "static void compact_node(int nid)\n{\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\tint zoneid;\n\tstruct zone *zone;\n\tstruct compact_control cc = {\n\t\t.order = -1,\n\t\t.total_migrate_scanned = 0,\n\t\t.total_free_scanned = 0,\n\t\t.mode = MIGRATE_SYNC,\n\t\t.ignore_skip_hint = true,\n\t\t.whole_zone = true,\n\t\t.gfp_mask = GFP_KERNEL,\n\t};\n\n\n\tfor (zoneid = 0; zoneid < MAX_NR_ZONES; zoneid++) {\n\n\t\tzone = &pgdat->node_zones[zoneid];\n\t\tif (!populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tcc.nr_freepages = 0;\n\t\tcc.nr_migratepages = 0;\n\t\tcc.zone = zone;\n\t\tINIT_LIST_HEAD(&cc.freepages);\n\t\tINIT_LIST_HEAD(&cc.migratepages);\n\n\t\tcompact_zone(zone, &cc);\n\n\t\tVM_BUG_ON(!list_empty(&cc.freepages));\n\t\tVM_BUG_ON(!list_empty(&cc.migratepages));\n\t}\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic void compact_node(int nid)\n{\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\tint zoneid;\n\tstruct zone *zone;\n\tstruct compact_control cc = {\n\t\t.order = -1,\n\t\t.total_migrate_scanned = 0,\n\t\t.total_free_scanned = 0,\n\t\t.mode = MIGRATE_SYNC,\n\t\t.ignore_skip_hint = true,\n\t\t.whole_zone = true,\n\t\t.gfp_mask = GFP_KERNEL,\n\t};\n\n\n\tfor (zoneid = 0; zoneid < MAX_NR_ZONES; zoneid++) {\n\n\t\tzone = &pgdat->node_zones[zoneid];\n\t\tif (!populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tcc.nr_freepages = 0;\n\t\tcc.nr_migratepages = 0;\n\t\tcc.zone = zone;\n\t\tINIT_LIST_HEAD(&cc.freepages);\n\t\tINIT_LIST_HEAD(&cc.migratepages);\n\n\t\tcompact_zone(zone, &cc);\n\n\t\tVM_BUG_ON(!list_empty(&cc.freepages));\n\t\tVM_BUG_ON(!list_empty(&cc.migratepages));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_add_drain_all",
          "args": [],
          "line": 1896
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_online",
          "args": [
            "nid"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic ssize_t sysfs_compact_node(struct device *dev,\n\t\t\tstruct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tint nid = dev->id;\n\n\tif (nid >= 0 && nid < nr_node_ids && node_online(nid)) {\n\t\t/* Flush pending updates to the LRU lists */\n\t\tlru_add_drain_all();\n\n\t\tcompact_node(nid);\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "sysctl_extfrag_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "1879-1885",
    "snippet": "int sysctl_extfrag_handler(struct ctl_table *table, int write,\n\t\t\tvoid __user *buffer, size_t *length, loff_t *ppos)\n{\n\tproc_dointvec_minmax(table, write, buffer, length, ppos);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "length",
            "ppos"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nint sysctl_extfrag_handler(struct ctl_table *table, int write,\n\t\t\tvoid __user *buffer, size_t *length, loff_t *ppos)\n{\n\tproc_dointvec_minmax(table, write, buffer, length, ppos);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sysctl_compaction_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "1870-1877",
    "snippet": "int sysctl_compaction_handler(struct ctl_table *table, int write,\n\t\t\tvoid __user *buffer, size_t *length, loff_t *ppos)\n{\n\tif (write)\n\t\tcompact_nodes();\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compact_nodes",
          "args": [],
          "line": 1874
        },
        "resolved": true,
        "details": {
          "function_name": "compact_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1852-1861",
          "snippet": "static void compact_nodes(void)\n{\n\tint nid;\n\n\t/* Flush pending updates to the LRU lists */\n\tlru_add_drain_all();\n\n\tfor_each_online_node(nid)\n\t\tcompact_node(nid);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic void compact_nodes(void)\n{\n\tint nid;\n\n\t/* Flush pending updates to the LRU lists */\n\tlru_add_drain_all();\n\n\tfor_each_online_node(nid)\n\t\tcompact_node(nid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nint sysctl_compaction_handler(struct ctl_table *table, int write,\n\t\t\tvoid __user *buffer, size_t *length, loff_t *ppos)\n{\n\tif (write)\n\t\tcompact_nodes();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "compact_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "1852-1861",
    "snippet": "static void compact_nodes(void)\n{\n\tint nid;\n\n\t/* Flush pending updates to the LRU lists */\n\tlru_add_drain_all();\n\n\tfor_each_online_node(nid)\n\t\tcompact_node(nid);\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lru_add_drain_all",
          "args": [],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic void compact_nodes(void)\n{\n\tint nid;\n\n\t/* Flush pending updates to the LRU lists */\n\tlru_add_drain_all();\n\n\tfor_each_online_node(nid)\n\t\tcompact_node(nid);\n}"
  },
  {
    "function_name": "compact_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "1816-1849",
    "snippet": "static void compact_node(int nid)\n{\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\tint zoneid;\n\tstruct zone *zone;\n\tstruct compact_control cc = {\n\t\t.order = -1,\n\t\t.total_migrate_scanned = 0,\n\t\t.total_free_scanned = 0,\n\t\t.mode = MIGRATE_SYNC,\n\t\t.ignore_skip_hint = true,\n\t\t.whole_zone = true,\n\t\t.gfp_mask = GFP_KERNEL,\n\t};\n\n\n\tfor (zoneid = 0; zoneid < MAX_NR_ZONES; zoneid++) {\n\n\t\tzone = &pgdat->node_zones[zoneid];\n\t\tif (!populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tcc.nr_freepages = 0;\n\t\tcc.nr_migratepages = 0;\n\t\tcc.zone = zone;\n\t\tINIT_LIST_HEAD(&cc.freepages);\n\t\tINIT_LIST_HEAD(&cc.migratepages);\n\n\t\tcompact_zone(zone, &cc);\n\n\t\tVM_BUG_ON(!list_empty(&cc.freepages));\n\t\tVM_BUG_ON(!list_empty(&cc.migratepages));\n\t}\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!list_empty(&cc.migratepages)"
          ],
          "line": 1847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cc.migratepages"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!list_empty(&cc.freepages)"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compact_zone",
          "args": [
            "zone",
            "&cc"
          ],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "compact_zone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1537-1699",
          "snippet": "static enum compact_result compact_zone(struct zone *zone, struct compact_control *cc)\n{\n\tenum compact_result ret;\n\tunsigned long start_pfn = zone->zone_start_pfn;\n\tunsigned long end_pfn = zone_end_pfn(zone);\n\tconst bool sync = cc->mode != MIGRATE_ASYNC;\n\n\tcc->migratetype = gfpflags_to_migratetype(cc->gfp_mask);\n\tret = compaction_suitable(zone, cc->order, cc->alloc_flags,\n\t\t\t\t\t\t\tcc->classzone_idx);\n\t/* Compaction is likely to fail */\n\tif (ret == COMPACT_SUCCESS || ret == COMPACT_SKIPPED)\n\t\treturn ret;\n\n\t/* huh, compaction_suitable is returning something unexpected */\n\tVM_BUG_ON(ret != COMPACT_CONTINUE);\n\n\t/*\n\t * Clear pageblock skip if there were failures recently and compaction\n\t * is about to be retried after being deferred.\n\t */\n\tif (compaction_restarting(zone, cc->order))\n\t\t__reset_isolation_suitable(zone);\n\n\t/*\n\t * Setup to move all movable pages to the end of the zone. Used cached\n\t * information on where the scanners should start (unless we explicitly\n\t * want to compact the whole zone), but check that it is initialised\n\t * by ensuring the values are within zone boundaries.\n\t */\n\tif (cc->whole_zone) {\n\t\tcc->migrate_pfn = start_pfn;\n\t\tcc->free_pfn = pageblock_start_pfn(end_pfn - 1);\n\t} else {\n\t\tcc->migrate_pfn = zone->compact_cached_migrate_pfn[sync];\n\t\tcc->free_pfn = zone->compact_cached_free_pfn;\n\t\tif (cc->free_pfn < start_pfn || cc->free_pfn >= end_pfn) {\n\t\t\tcc->free_pfn = pageblock_start_pfn(end_pfn - 1);\n\t\t\tzone->compact_cached_free_pfn = cc->free_pfn;\n\t\t}\n\t\tif (cc->migrate_pfn < start_pfn || cc->migrate_pfn >= end_pfn) {\n\t\t\tcc->migrate_pfn = start_pfn;\n\t\t\tzone->compact_cached_migrate_pfn[0] = cc->migrate_pfn;\n\t\t\tzone->compact_cached_migrate_pfn[1] = cc->migrate_pfn;\n\t\t}\n\n\t\tif (cc->migrate_pfn == start_pfn)\n\t\t\tcc->whole_zone = true;\n\t}\n\n\tcc->last_migrated_pfn = 0;\n\n\ttrace_mm_compaction_begin(start_pfn, cc->migrate_pfn,\n\t\t\t\tcc->free_pfn, end_pfn, sync);\n\n\tmigrate_prep_local();\n\n\twhile ((ret = compact_finished(zone, cc)) == COMPACT_CONTINUE) {\n\t\tint err;\n\n\t\tswitch (isolate_migratepages(zone, cc)) {\n\t\tcase ISOLATE_ABORT:\n\t\t\tret = COMPACT_CONTENDED;\n\t\t\tputback_movable_pages(&cc->migratepages);\n\t\t\tcc->nr_migratepages = 0;\n\t\t\tgoto out;\n\t\tcase ISOLATE_NONE:\n\t\t\t/*\n\t\t\t * We haven't isolated and migrated anything, but\n\t\t\t * there might still be unflushed migrations from\n\t\t\t * previous cc->order aligned block.\n\t\t\t */\n\t\t\tgoto check_drain;\n\t\tcase ISOLATE_SUCCESS:\n\t\t\t;\n\t\t}\n\n\t\terr = migrate_pages(&cc->migratepages, compaction_alloc,\n\t\t\t\tcompaction_free, (unsigned long)cc, cc->mode,\n\t\t\t\tMR_COMPACTION);\n\n\t\ttrace_mm_compaction_migratepages(cc->nr_migratepages, err,\n\t\t\t\t\t\t\t&cc->migratepages);\n\n\t\t/* All pages were either migrated or will be released */\n\t\tcc->nr_migratepages = 0;\n\t\tif (err) {\n\t\t\tputback_movable_pages(&cc->migratepages);\n\t\t\t/*\n\t\t\t * migrate_pages() may return -ENOMEM when scanners meet\n\t\t\t * and we want compact_finished() to detect it\n\t\t\t */\n\t\t\tif (err == -ENOMEM && !compact_scanners_met(cc)) {\n\t\t\t\tret = COMPACT_CONTENDED;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We failed to migrate at least one page in the current\n\t\t\t * order-aligned block, so skip the rest of it.\n\t\t\t */\n\t\t\tif (cc->direct_compaction &&\n\t\t\t\t\t\t(cc->mode == MIGRATE_ASYNC)) {\n\t\t\t\tcc->migrate_pfn = block_end_pfn(\n\t\t\t\t\t\tcc->migrate_pfn - 1, cc->order);\n\t\t\t\t/* Draining pcplists is useless in this case */\n\t\t\t\tcc->last_migrated_pfn = 0;\n\n\t\t\t}\n\t\t}\n\ncheck_drain:\n\t\t/*\n\t\t * Has the migration scanner moved away from the previous\n\t\t * cc->order aligned block where we migrated from? If yes,\n\t\t * flush the pages that were freed, so that they can merge and\n\t\t * compact_finished() can detect immediately if allocation\n\t\t * would succeed.\n\t\t */\n\t\tif (cc->order > 0 && cc->last_migrated_pfn) {\n\t\t\tint cpu;\n\t\t\tunsigned long current_block_start =\n\t\t\t\tblock_start_pfn(cc->migrate_pfn, cc->order);\n\n\t\t\tif (cc->last_migrated_pfn < current_block_start) {\n\t\t\t\tcpu = get_cpu();\n\t\t\t\tlru_add_drain_cpu(cpu);\n\t\t\t\tdrain_local_pages(zone);\n\t\t\t\tput_cpu();\n\t\t\t\t/* No more flushing until we migrate again */\n\t\t\t\tcc->last_migrated_pfn = 0;\n\t\t\t}\n\t\t}\n\n\t}\n\nout:\n\t/*\n\t * Release free pages and update where the free scanner should restart,\n\t * so we don't leave any returned pages behind in the next attempt.\n\t */\n\tif (cc->nr_freepages > 0) {\n\t\tunsigned long free_pfn = release_freepages(&cc->freepages);\n\n\t\tcc->nr_freepages = 0;\n\t\tVM_BUG_ON(free_pfn == 0);\n\t\t/* The cached pfn is always the first in a pageblock */\n\t\tfree_pfn = pageblock_start_pfn(free_pfn);\n\t\t/*\n\t\t * Only go back, not forward. The cached pfn might have been\n\t\t * already reset to zone end in compact_finished()\n\t\t */\n\t\tif (free_pfn > zone->compact_cached_free_pfn)\n\t\t\tzone->compact_cached_free_pfn = free_pfn;\n\t}\n\n\tcount_compact_events(COMPACTMIGRATE_SCANNED, cc->total_migrate_scanned);\n\tcount_compact_events(COMPACTFREE_SCANNED, cc->total_free_scanned);\n\n\ttrace_mm_compaction_end(start_pfn, cc->migrate_pfn,\n\t\t\t\tcc->free_pfn, end_pfn, sync, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic enum compact_result compact_zone(struct zone *zone, struct compact_control *cc)\n{\n\tenum compact_result ret;\n\tunsigned long start_pfn = zone->zone_start_pfn;\n\tunsigned long end_pfn = zone_end_pfn(zone);\n\tconst bool sync = cc->mode != MIGRATE_ASYNC;\n\n\tcc->migratetype = gfpflags_to_migratetype(cc->gfp_mask);\n\tret = compaction_suitable(zone, cc->order, cc->alloc_flags,\n\t\t\t\t\t\t\tcc->classzone_idx);\n\t/* Compaction is likely to fail */\n\tif (ret == COMPACT_SUCCESS || ret == COMPACT_SKIPPED)\n\t\treturn ret;\n\n\t/* huh, compaction_suitable is returning something unexpected */\n\tVM_BUG_ON(ret != COMPACT_CONTINUE);\n\n\t/*\n\t * Clear pageblock skip if there were failures recently and compaction\n\t * is about to be retried after being deferred.\n\t */\n\tif (compaction_restarting(zone, cc->order))\n\t\t__reset_isolation_suitable(zone);\n\n\t/*\n\t * Setup to move all movable pages to the end of the zone. Used cached\n\t * information on where the scanners should start (unless we explicitly\n\t * want to compact the whole zone), but check that it is initialised\n\t * by ensuring the values are within zone boundaries.\n\t */\n\tif (cc->whole_zone) {\n\t\tcc->migrate_pfn = start_pfn;\n\t\tcc->free_pfn = pageblock_start_pfn(end_pfn - 1);\n\t} else {\n\t\tcc->migrate_pfn = zone->compact_cached_migrate_pfn[sync];\n\t\tcc->free_pfn = zone->compact_cached_free_pfn;\n\t\tif (cc->free_pfn < start_pfn || cc->free_pfn >= end_pfn) {\n\t\t\tcc->free_pfn = pageblock_start_pfn(end_pfn - 1);\n\t\t\tzone->compact_cached_free_pfn = cc->free_pfn;\n\t\t}\n\t\tif (cc->migrate_pfn < start_pfn || cc->migrate_pfn >= end_pfn) {\n\t\t\tcc->migrate_pfn = start_pfn;\n\t\t\tzone->compact_cached_migrate_pfn[0] = cc->migrate_pfn;\n\t\t\tzone->compact_cached_migrate_pfn[1] = cc->migrate_pfn;\n\t\t}\n\n\t\tif (cc->migrate_pfn == start_pfn)\n\t\t\tcc->whole_zone = true;\n\t}\n\n\tcc->last_migrated_pfn = 0;\n\n\ttrace_mm_compaction_begin(start_pfn, cc->migrate_pfn,\n\t\t\t\tcc->free_pfn, end_pfn, sync);\n\n\tmigrate_prep_local();\n\n\twhile ((ret = compact_finished(zone, cc)) == COMPACT_CONTINUE) {\n\t\tint err;\n\n\t\tswitch (isolate_migratepages(zone, cc)) {\n\t\tcase ISOLATE_ABORT:\n\t\t\tret = COMPACT_CONTENDED;\n\t\t\tputback_movable_pages(&cc->migratepages);\n\t\t\tcc->nr_migratepages = 0;\n\t\t\tgoto out;\n\t\tcase ISOLATE_NONE:\n\t\t\t/*\n\t\t\t * We haven't isolated and migrated anything, but\n\t\t\t * there might still be unflushed migrations from\n\t\t\t * previous cc->order aligned block.\n\t\t\t */\n\t\t\tgoto check_drain;\n\t\tcase ISOLATE_SUCCESS:\n\t\t\t;\n\t\t}\n\n\t\terr = migrate_pages(&cc->migratepages, compaction_alloc,\n\t\t\t\tcompaction_free, (unsigned long)cc, cc->mode,\n\t\t\t\tMR_COMPACTION);\n\n\t\ttrace_mm_compaction_migratepages(cc->nr_migratepages, err,\n\t\t\t\t\t\t\t&cc->migratepages);\n\n\t\t/* All pages were either migrated or will be released */\n\t\tcc->nr_migratepages = 0;\n\t\tif (err) {\n\t\t\tputback_movable_pages(&cc->migratepages);\n\t\t\t/*\n\t\t\t * migrate_pages() may return -ENOMEM when scanners meet\n\t\t\t * and we want compact_finished() to detect it\n\t\t\t */\n\t\t\tif (err == -ENOMEM && !compact_scanners_met(cc)) {\n\t\t\t\tret = COMPACT_CONTENDED;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We failed to migrate at least one page in the current\n\t\t\t * order-aligned block, so skip the rest of it.\n\t\t\t */\n\t\t\tif (cc->direct_compaction &&\n\t\t\t\t\t\t(cc->mode == MIGRATE_ASYNC)) {\n\t\t\t\tcc->migrate_pfn = block_end_pfn(\n\t\t\t\t\t\tcc->migrate_pfn - 1, cc->order);\n\t\t\t\t/* Draining pcplists is useless in this case */\n\t\t\t\tcc->last_migrated_pfn = 0;\n\n\t\t\t}\n\t\t}\n\ncheck_drain:\n\t\t/*\n\t\t * Has the migration scanner moved away from the previous\n\t\t * cc->order aligned block where we migrated from? If yes,\n\t\t * flush the pages that were freed, so that they can merge and\n\t\t * compact_finished() can detect immediately if allocation\n\t\t * would succeed.\n\t\t */\n\t\tif (cc->order > 0 && cc->last_migrated_pfn) {\n\t\t\tint cpu;\n\t\t\tunsigned long current_block_start =\n\t\t\t\tblock_start_pfn(cc->migrate_pfn, cc->order);\n\n\t\t\tif (cc->last_migrated_pfn < current_block_start) {\n\t\t\t\tcpu = get_cpu();\n\t\t\t\tlru_add_drain_cpu(cpu);\n\t\t\t\tdrain_local_pages(zone);\n\t\t\t\tput_cpu();\n\t\t\t\t/* No more flushing until we migrate again */\n\t\t\t\tcc->last_migrated_pfn = 0;\n\t\t\t}\n\t\t}\n\n\t}\n\nout:\n\t/*\n\t * Release free pages and update where the free scanner should restart,\n\t * so we don't leave any returned pages behind in the next attempt.\n\t */\n\tif (cc->nr_freepages > 0) {\n\t\tunsigned long free_pfn = release_freepages(&cc->freepages);\n\n\t\tcc->nr_freepages = 0;\n\t\tVM_BUG_ON(free_pfn == 0);\n\t\t/* The cached pfn is always the first in a pageblock */\n\t\tfree_pfn = pageblock_start_pfn(free_pfn);\n\t\t/*\n\t\t * Only go back, not forward. The cached pfn might have been\n\t\t * already reset to zone end in compact_finished()\n\t\t */\n\t\tif (free_pfn > zone->compact_cached_free_pfn)\n\t\t\tzone->compact_cached_free_pfn = free_pfn;\n\t}\n\n\tcount_compact_events(COMPACTMIGRATE_SCANNED, cc->total_migrate_scanned);\n\tcount_compact_events(COMPACTFREE_SCANNED, cc->total_free_scanned);\n\n\ttrace_mm_compaction_end(start_pfn, cc->migrate_pfn,\n\t\t\t\tcc->free_pfn, end_pfn, sync, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cc.migratepages"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cc.freepages"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "populated_zone",
          "args": [
            "zone"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic void compact_node(int nid)\n{\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\tint zoneid;\n\tstruct zone *zone;\n\tstruct compact_control cc = {\n\t\t.order = -1,\n\t\t.total_migrate_scanned = 0,\n\t\t.total_free_scanned = 0,\n\t\t.mode = MIGRATE_SYNC,\n\t\t.ignore_skip_hint = true,\n\t\t.whole_zone = true,\n\t\t.gfp_mask = GFP_KERNEL,\n\t};\n\n\n\tfor (zoneid = 0; zoneid < MAX_NR_ZONES; zoneid++) {\n\n\t\tzone = &pgdat->node_zones[zoneid];\n\t\tif (!populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tcc.nr_freepages = 0;\n\t\tcc.nr_migratepages = 0;\n\t\tcc.zone = zone;\n\t\tINIT_LIST_HEAD(&cc.freepages);\n\t\tINIT_LIST_HEAD(&cc.migratepages);\n\n\t\tcompact_zone(zone, &cc);\n\n\t\tVM_BUG_ON(!list_empty(&cc.freepages));\n\t\tVM_BUG_ON(!list_empty(&cc.migratepages));\n\t}\n}"
  },
  {
    "function_name": "try_to_compact_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "1746-1812",
    "snippet": "enum compact_result try_to_compact_pages(gfp_t gfp_mask, unsigned int order,\n\t\tunsigned int alloc_flags, const struct alloc_context *ac,\n\t\tenum compact_priority prio)\n{\n\tint may_perform_io = gfp_mask & __GFP_IO;\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tenum compact_result rc = COMPACT_SKIPPED;\n\n\t/*\n\t * Check if the GFP flags allow compaction - GFP_NOIO is really\n\t * tricky context because the migration might require IO\n\t */\n\tif (!may_perform_io)\n\t\treturn COMPACT_SKIPPED;\n\n\ttrace_mm_compaction_try_to_compact_pages(order, gfp_mask, prio);\n\n\t/* Compact each zone in the list */\n\tfor_each_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\t\t\t\tac->nodemask) {\n\t\tenum compact_result status;\n\n\t\tif (prio > MIN_COMPACT_PRIORITY\n\t\t\t\t\t&& compaction_deferred(zone, order)) {\n\t\t\trc = max_t(enum compact_result, COMPACT_DEFERRED, rc);\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = compact_zone_order(zone, order, gfp_mask, prio,\n\t\t\t\t\talloc_flags, ac_classzone_idx(ac));\n\t\trc = max(status, rc);\n\n\t\t/* The allocation should succeed, stop compacting */\n\t\tif (status == COMPACT_SUCCESS) {\n\t\t\t/*\n\t\t\t * We think the allocation will succeed in this zone,\n\t\t\t * but it is not certain, hence the false. The caller\n\t\t\t * will repeat this with true if allocation indeed\n\t\t\t * succeeds in this zone.\n\t\t\t */\n\t\t\tcompaction_defer_reset(zone, order, false);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (prio != COMPACT_PRIO_ASYNC && (status == COMPACT_COMPLETE ||\n\t\t\t\t\tstatus == COMPACT_PARTIAL_SKIPPED))\n\t\t\t/*\n\t\t\t * We think that allocation won't succeed in this zone\n\t\t\t * so we defer compaction there. If it ends up\n\t\t\t * succeeding after all, it will be reset.\n\t\t\t */\n\t\t\tdefer_compaction(zone, order);\n\n\t\t/*\n\t\t * We might have stopped compacting due to need_resched() in\n\t\t * async compaction, or due to a fatal signal detected. In that\n\t\t * case do not try further zones\n\t\t */\n\t\tif ((prio == COMPACT_PRIO_ASYNC && need_resched())\n\t\t\t\t\t|| fatal_signal_pending(current))\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "defer_compaction",
          "args": [
            "zone",
            "order"
          ],
          "line": 1799
        },
        "resolved": true,
        "details": {
          "function_name": "defer_compaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "142-154",
          "snippet": "void defer_compaction(struct zone *zone, int order)\n{\n\tzone->compact_considered = 0;\n\tzone->compact_defer_shift++;\n\n\tif (order < zone->compact_order_failed)\n\t\tzone->compact_order_failed = order;\n\n\tif (zone->compact_defer_shift > COMPACT_MAX_DEFER_SHIFT)\n\t\tzone->compact_defer_shift = COMPACT_MAX_DEFER_SHIFT;\n\n\ttrace_mm_compaction_defer_compaction(zone, order);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define COMPACT_MAX_DEFER_SHIFT 6"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\n#define COMPACT_MAX_DEFER_SHIFT 6\n\nvoid defer_compaction(struct zone *zone, int order)\n{\n\tzone->compact_considered = 0;\n\tzone->compact_defer_shift++;\n\n\tif (order < zone->compact_order_failed)\n\t\tzone->compact_order_failed = order;\n\n\tif (zone->compact_defer_shift > COMPACT_MAX_DEFER_SHIFT)\n\t\tzone->compact_defer_shift = COMPACT_MAX_DEFER_SHIFT;\n\n\ttrace_mm_compaction_defer_compaction(zone, order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compaction_defer_reset",
          "args": [
            "zone",
            "order",
            "false"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "compaction_defer_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "181-192",
          "snippet": "void compaction_defer_reset(struct zone *zone, int order,\n\t\tbool alloc_success)\n{\n\tif (alloc_success) {\n\t\tzone->compact_considered = 0;\n\t\tzone->compact_defer_shift = 0;\n\t}\n\tif (order >= zone->compact_order_failed)\n\t\tzone->compact_order_failed = order + 1;\n\n\ttrace_mm_compaction_defer_reset(zone, order);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nvoid compaction_defer_reset(struct zone *zone, int order,\n\t\tbool alloc_success)\n{\n\tif (alloc_success) {\n\t\tzone->compact_considered = 0;\n\t\tzone->compact_defer_shift = 0;\n\t}\n\tif (order >= zone->compact_order_failed)\n\t\tzone->compact_order_failed = order + 1;\n\n\ttrace_mm_compaction_defer_reset(zone, order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "status",
            "rc"
          ],
          "line": 1777
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact_zone_order",
          "args": [
            "zone",
            "order",
            "gfp_mask",
            "prio",
            "alloc_flags",
            "ac_classzone_idx(ac)"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "compact_zone_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1701-1732",
          "snippet": "static enum compact_result compact_zone_order(struct zone *zone, int order,\n\t\tgfp_t gfp_mask, enum compact_priority prio,\n\t\tunsigned int alloc_flags, int classzone_idx)\n{\n\tenum compact_result ret;\n\tstruct compact_control cc = {\n\t\t.nr_freepages = 0,\n\t\t.nr_migratepages = 0,\n\t\t.total_migrate_scanned = 0,\n\t\t.total_free_scanned = 0,\n\t\t.order = order,\n\t\t.gfp_mask = gfp_mask,\n\t\t.zone = zone,\n\t\t.mode = (prio == COMPACT_PRIO_ASYNC) ?\n\t\t\t\t\tMIGRATE_ASYNC :\tMIGRATE_SYNC_LIGHT,\n\t\t.alloc_flags = alloc_flags,\n\t\t.classzone_idx = classzone_idx,\n\t\t.direct_compaction = true,\n\t\t.whole_zone = (prio == MIN_COMPACT_PRIORITY),\n\t\t.ignore_skip_hint = (prio == MIN_COMPACT_PRIORITY),\n\t\t.ignore_block_suitable = (prio == MIN_COMPACT_PRIORITY)\n\t};\n\tINIT_LIST_HEAD(&cc.freepages);\n\tINIT_LIST_HEAD(&cc.migratepages);\n\n\tret = compact_zone(zone, &cc);\n\n\tVM_BUG_ON(!list_empty(&cc.freepages));\n\tVM_BUG_ON(!list_empty(&cc.migratepages));\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic enum compact_result compact_zone_order(struct zone *zone, int order,\n\t\tgfp_t gfp_mask, enum compact_priority prio,\n\t\tunsigned int alloc_flags, int classzone_idx)\n{\n\tenum compact_result ret;\n\tstruct compact_control cc = {\n\t\t.nr_freepages = 0,\n\t\t.nr_migratepages = 0,\n\t\t.total_migrate_scanned = 0,\n\t\t.total_free_scanned = 0,\n\t\t.order = order,\n\t\t.gfp_mask = gfp_mask,\n\t\t.zone = zone,\n\t\t.mode = (prio == COMPACT_PRIO_ASYNC) ?\n\t\t\t\t\tMIGRATE_ASYNC :\tMIGRATE_SYNC_LIGHT,\n\t\t.alloc_flags = alloc_flags,\n\t\t.classzone_idx = classzone_idx,\n\t\t.direct_compaction = true,\n\t\t.whole_zone = (prio == MIN_COMPACT_PRIORITY),\n\t\t.ignore_skip_hint = (prio == MIN_COMPACT_PRIORITY),\n\t\t.ignore_block_suitable = (prio == MIN_COMPACT_PRIORITY)\n\t};\n\tINIT_LIST_HEAD(&cc.freepages);\n\tINIT_LIST_HEAD(&cc.migratepages);\n\n\tret = compact_zone(zone, &cc);\n\n\tVM_BUG_ON(!list_empty(&cc.freepages));\n\tVM_BUG_ON(!list_empty(&cc.migratepages));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ac_classzone_idx",
          "args": [
            "ac"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "enumcompact_result",
            "COMPACT_DEFERRED",
            "rc"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compaction_deferred",
          "args": [
            "zone",
            "order"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "compaction_deferred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "157-174",
          "snippet": "bool compaction_deferred(struct zone *zone, int order)\n{\n\tunsigned long defer_limit = 1UL << zone->compact_defer_shift;\n\n\tif (order < zone->compact_order_failed)\n\t\treturn false;\n\n\t/* Avoid possible overflow */\n\tif (++zone->compact_considered > defer_limit)\n\t\tzone->compact_considered = defer_limit;\n\n\tif (zone->compact_considered >= defer_limit)\n\t\treturn false;\n\n\ttrace_mm_compaction_deferred(zone, order);\n\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nbool compaction_deferred(struct zone *zone, int order)\n{\n\tunsigned long defer_limit = 1UL << zone->compact_defer_shift;\n\n\tif (order < zone->compact_order_failed)\n\t\treturn false;\n\n\t/* Avoid possible overflow */\n\tif (++zone->compact_considered > defer_limit)\n\t\tzone->compact_considered = defer_limit;\n\n\tif (zone->compact_considered >= defer_limit)\n\t\treturn false;\n\n\ttrace_mm_compaction_deferred(zone, order);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_zone_zonelist_nodemask",
          "args": [
            "zone",
            "z",
            "ac->zonelist",
            "ac->high_zoneidx",
            "ac->nodemask"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_mm_compaction_try_to_compact_pages",
          "args": [
            "order",
            "gfp_mask",
            "prio"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nenum compact_result try_to_compact_pages(gfp_t gfp_mask, unsigned int order,\n\t\tunsigned int alloc_flags, const struct alloc_context *ac,\n\t\tenum compact_priority prio)\n{\n\tint may_perform_io = gfp_mask & __GFP_IO;\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tenum compact_result rc = COMPACT_SKIPPED;\n\n\t/*\n\t * Check if the GFP flags allow compaction - GFP_NOIO is really\n\t * tricky context because the migration might require IO\n\t */\n\tif (!may_perform_io)\n\t\treturn COMPACT_SKIPPED;\n\n\ttrace_mm_compaction_try_to_compact_pages(order, gfp_mask, prio);\n\n\t/* Compact each zone in the list */\n\tfor_each_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\t\t\t\tac->nodemask) {\n\t\tenum compact_result status;\n\n\t\tif (prio > MIN_COMPACT_PRIORITY\n\t\t\t\t\t&& compaction_deferred(zone, order)) {\n\t\t\trc = max_t(enum compact_result, COMPACT_DEFERRED, rc);\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = compact_zone_order(zone, order, gfp_mask, prio,\n\t\t\t\t\talloc_flags, ac_classzone_idx(ac));\n\t\trc = max(status, rc);\n\n\t\t/* The allocation should succeed, stop compacting */\n\t\tif (status == COMPACT_SUCCESS) {\n\t\t\t/*\n\t\t\t * We think the allocation will succeed in this zone,\n\t\t\t * but it is not certain, hence the false. The caller\n\t\t\t * will repeat this with true if allocation indeed\n\t\t\t * succeeds in this zone.\n\t\t\t */\n\t\t\tcompaction_defer_reset(zone, order, false);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (prio != COMPACT_PRIO_ASYNC && (status == COMPACT_COMPLETE ||\n\t\t\t\t\tstatus == COMPACT_PARTIAL_SKIPPED))\n\t\t\t/*\n\t\t\t * We think that allocation won't succeed in this zone\n\t\t\t * so we defer compaction there. If it ends up\n\t\t\t * succeeding after all, it will be reset.\n\t\t\t */\n\t\t\tdefer_compaction(zone, order);\n\n\t\t/*\n\t\t * We might have stopped compacting due to need_resched() in\n\t\t * async compaction, or due to a fatal signal detected. In that\n\t\t * case do not try further zones\n\t\t */\n\t\tif ((prio == COMPACT_PRIO_ASYNC && need_resched())\n\t\t\t\t\t|| fatal_signal_pending(current))\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "compact_zone_order",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "1701-1732",
    "snippet": "static enum compact_result compact_zone_order(struct zone *zone, int order,\n\t\tgfp_t gfp_mask, enum compact_priority prio,\n\t\tunsigned int alloc_flags, int classzone_idx)\n{\n\tenum compact_result ret;\n\tstruct compact_control cc = {\n\t\t.nr_freepages = 0,\n\t\t.nr_migratepages = 0,\n\t\t.total_migrate_scanned = 0,\n\t\t.total_free_scanned = 0,\n\t\t.order = order,\n\t\t.gfp_mask = gfp_mask,\n\t\t.zone = zone,\n\t\t.mode = (prio == COMPACT_PRIO_ASYNC) ?\n\t\t\t\t\tMIGRATE_ASYNC :\tMIGRATE_SYNC_LIGHT,\n\t\t.alloc_flags = alloc_flags,\n\t\t.classzone_idx = classzone_idx,\n\t\t.direct_compaction = true,\n\t\t.whole_zone = (prio == MIN_COMPACT_PRIORITY),\n\t\t.ignore_skip_hint = (prio == MIN_COMPACT_PRIORITY),\n\t\t.ignore_block_suitable = (prio == MIN_COMPACT_PRIORITY)\n\t};\n\tINIT_LIST_HEAD(&cc.freepages);\n\tINIT_LIST_HEAD(&cc.migratepages);\n\n\tret = compact_zone(zone, &cc);\n\n\tVM_BUG_ON(!list_empty(&cc.freepages));\n\tVM_BUG_ON(!list_empty(&cc.migratepages));\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!list_empty(&cc.migratepages)"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cc.migratepages"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!list_empty(&cc.freepages)"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compact_zone",
          "args": [
            "zone",
            "&cc"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "compact_zone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1537-1699",
          "snippet": "static enum compact_result compact_zone(struct zone *zone, struct compact_control *cc)\n{\n\tenum compact_result ret;\n\tunsigned long start_pfn = zone->zone_start_pfn;\n\tunsigned long end_pfn = zone_end_pfn(zone);\n\tconst bool sync = cc->mode != MIGRATE_ASYNC;\n\n\tcc->migratetype = gfpflags_to_migratetype(cc->gfp_mask);\n\tret = compaction_suitable(zone, cc->order, cc->alloc_flags,\n\t\t\t\t\t\t\tcc->classzone_idx);\n\t/* Compaction is likely to fail */\n\tif (ret == COMPACT_SUCCESS || ret == COMPACT_SKIPPED)\n\t\treturn ret;\n\n\t/* huh, compaction_suitable is returning something unexpected */\n\tVM_BUG_ON(ret != COMPACT_CONTINUE);\n\n\t/*\n\t * Clear pageblock skip if there were failures recently and compaction\n\t * is about to be retried after being deferred.\n\t */\n\tif (compaction_restarting(zone, cc->order))\n\t\t__reset_isolation_suitable(zone);\n\n\t/*\n\t * Setup to move all movable pages to the end of the zone. Used cached\n\t * information on where the scanners should start (unless we explicitly\n\t * want to compact the whole zone), but check that it is initialised\n\t * by ensuring the values are within zone boundaries.\n\t */\n\tif (cc->whole_zone) {\n\t\tcc->migrate_pfn = start_pfn;\n\t\tcc->free_pfn = pageblock_start_pfn(end_pfn - 1);\n\t} else {\n\t\tcc->migrate_pfn = zone->compact_cached_migrate_pfn[sync];\n\t\tcc->free_pfn = zone->compact_cached_free_pfn;\n\t\tif (cc->free_pfn < start_pfn || cc->free_pfn >= end_pfn) {\n\t\t\tcc->free_pfn = pageblock_start_pfn(end_pfn - 1);\n\t\t\tzone->compact_cached_free_pfn = cc->free_pfn;\n\t\t}\n\t\tif (cc->migrate_pfn < start_pfn || cc->migrate_pfn >= end_pfn) {\n\t\t\tcc->migrate_pfn = start_pfn;\n\t\t\tzone->compact_cached_migrate_pfn[0] = cc->migrate_pfn;\n\t\t\tzone->compact_cached_migrate_pfn[1] = cc->migrate_pfn;\n\t\t}\n\n\t\tif (cc->migrate_pfn == start_pfn)\n\t\t\tcc->whole_zone = true;\n\t}\n\n\tcc->last_migrated_pfn = 0;\n\n\ttrace_mm_compaction_begin(start_pfn, cc->migrate_pfn,\n\t\t\t\tcc->free_pfn, end_pfn, sync);\n\n\tmigrate_prep_local();\n\n\twhile ((ret = compact_finished(zone, cc)) == COMPACT_CONTINUE) {\n\t\tint err;\n\n\t\tswitch (isolate_migratepages(zone, cc)) {\n\t\tcase ISOLATE_ABORT:\n\t\t\tret = COMPACT_CONTENDED;\n\t\t\tputback_movable_pages(&cc->migratepages);\n\t\t\tcc->nr_migratepages = 0;\n\t\t\tgoto out;\n\t\tcase ISOLATE_NONE:\n\t\t\t/*\n\t\t\t * We haven't isolated and migrated anything, but\n\t\t\t * there might still be unflushed migrations from\n\t\t\t * previous cc->order aligned block.\n\t\t\t */\n\t\t\tgoto check_drain;\n\t\tcase ISOLATE_SUCCESS:\n\t\t\t;\n\t\t}\n\n\t\terr = migrate_pages(&cc->migratepages, compaction_alloc,\n\t\t\t\tcompaction_free, (unsigned long)cc, cc->mode,\n\t\t\t\tMR_COMPACTION);\n\n\t\ttrace_mm_compaction_migratepages(cc->nr_migratepages, err,\n\t\t\t\t\t\t\t&cc->migratepages);\n\n\t\t/* All pages were either migrated or will be released */\n\t\tcc->nr_migratepages = 0;\n\t\tif (err) {\n\t\t\tputback_movable_pages(&cc->migratepages);\n\t\t\t/*\n\t\t\t * migrate_pages() may return -ENOMEM when scanners meet\n\t\t\t * and we want compact_finished() to detect it\n\t\t\t */\n\t\t\tif (err == -ENOMEM && !compact_scanners_met(cc)) {\n\t\t\t\tret = COMPACT_CONTENDED;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We failed to migrate at least one page in the current\n\t\t\t * order-aligned block, so skip the rest of it.\n\t\t\t */\n\t\t\tif (cc->direct_compaction &&\n\t\t\t\t\t\t(cc->mode == MIGRATE_ASYNC)) {\n\t\t\t\tcc->migrate_pfn = block_end_pfn(\n\t\t\t\t\t\tcc->migrate_pfn - 1, cc->order);\n\t\t\t\t/* Draining pcplists is useless in this case */\n\t\t\t\tcc->last_migrated_pfn = 0;\n\n\t\t\t}\n\t\t}\n\ncheck_drain:\n\t\t/*\n\t\t * Has the migration scanner moved away from the previous\n\t\t * cc->order aligned block where we migrated from? If yes,\n\t\t * flush the pages that were freed, so that they can merge and\n\t\t * compact_finished() can detect immediately if allocation\n\t\t * would succeed.\n\t\t */\n\t\tif (cc->order > 0 && cc->last_migrated_pfn) {\n\t\t\tint cpu;\n\t\t\tunsigned long current_block_start =\n\t\t\t\tblock_start_pfn(cc->migrate_pfn, cc->order);\n\n\t\t\tif (cc->last_migrated_pfn < current_block_start) {\n\t\t\t\tcpu = get_cpu();\n\t\t\t\tlru_add_drain_cpu(cpu);\n\t\t\t\tdrain_local_pages(zone);\n\t\t\t\tput_cpu();\n\t\t\t\t/* No more flushing until we migrate again */\n\t\t\t\tcc->last_migrated_pfn = 0;\n\t\t\t}\n\t\t}\n\n\t}\n\nout:\n\t/*\n\t * Release free pages and update where the free scanner should restart,\n\t * so we don't leave any returned pages behind in the next attempt.\n\t */\n\tif (cc->nr_freepages > 0) {\n\t\tunsigned long free_pfn = release_freepages(&cc->freepages);\n\n\t\tcc->nr_freepages = 0;\n\t\tVM_BUG_ON(free_pfn == 0);\n\t\t/* The cached pfn is always the first in a pageblock */\n\t\tfree_pfn = pageblock_start_pfn(free_pfn);\n\t\t/*\n\t\t * Only go back, not forward. The cached pfn might have been\n\t\t * already reset to zone end in compact_finished()\n\t\t */\n\t\tif (free_pfn > zone->compact_cached_free_pfn)\n\t\t\tzone->compact_cached_free_pfn = free_pfn;\n\t}\n\n\tcount_compact_events(COMPACTMIGRATE_SCANNED, cc->total_migrate_scanned);\n\tcount_compact_events(COMPACTFREE_SCANNED, cc->total_free_scanned);\n\n\ttrace_mm_compaction_end(start_pfn, cc->migrate_pfn,\n\t\t\t\tcc->free_pfn, end_pfn, sync, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic enum compact_result compact_zone(struct zone *zone, struct compact_control *cc)\n{\n\tenum compact_result ret;\n\tunsigned long start_pfn = zone->zone_start_pfn;\n\tunsigned long end_pfn = zone_end_pfn(zone);\n\tconst bool sync = cc->mode != MIGRATE_ASYNC;\n\n\tcc->migratetype = gfpflags_to_migratetype(cc->gfp_mask);\n\tret = compaction_suitable(zone, cc->order, cc->alloc_flags,\n\t\t\t\t\t\t\tcc->classzone_idx);\n\t/* Compaction is likely to fail */\n\tif (ret == COMPACT_SUCCESS || ret == COMPACT_SKIPPED)\n\t\treturn ret;\n\n\t/* huh, compaction_suitable is returning something unexpected */\n\tVM_BUG_ON(ret != COMPACT_CONTINUE);\n\n\t/*\n\t * Clear pageblock skip if there were failures recently and compaction\n\t * is about to be retried after being deferred.\n\t */\n\tif (compaction_restarting(zone, cc->order))\n\t\t__reset_isolation_suitable(zone);\n\n\t/*\n\t * Setup to move all movable pages to the end of the zone. Used cached\n\t * information on where the scanners should start (unless we explicitly\n\t * want to compact the whole zone), but check that it is initialised\n\t * by ensuring the values are within zone boundaries.\n\t */\n\tif (cc->whole_zone) {\n\t\tcc->migrate_pfn = start_pfn;\n\t\tcc->free_pfn = pageblock_start_pfn(end_pfn - 1);\n\t} else {\n\t\tcc->migrate_pfn = zone->compact_cached_migrate_pfn[sync];\n\t\tcc->free_pfn = zone->compact_cached_free_pfn;\n\t\tif (cc->free_pfn < start_pfn || cc->free_pfn >= end_pfn) {\n\t\t\tcc->free_pfn = pageblock_start_pfn(end_pfn - 1);\n\t\t\tzone->compact_cached_free_pfn = cc->free_pfn;\n\t\t}\n\t\tif (cc->migrate_pfn < start_pfn || cc->migrate_pfn >= end_pfn) {\n\t\t\tcc->migrate_pfn = start_pfn;\n\t\t\tzone->compact_cached_migrate_pfn[0] = cc->migrate_pfn;\n\t\t\tzone->compact_cached_migrate_pfn[1] = cc->migrate_pfn;\n\t\t}\n\n\t\tif (cc->migrate_pfn == start_pfn)\n\t\t\tcc->whole_zone = true;\n\t}\n\n\tcc->last_migrated_pfn = 0;\n\n\ttrace_mm_compaction_begin(start_pfn, cc->migrate_pfn,\n\t\t\t\tcc->free_pfn, end_pfn, sync);\n\n\tmigrate_prep_local();\n\n\twhile ((ret = compact_finished(zone, cc)) == COMPACT_CONTINUE) {\n\t\tint err;\n\n\t\tswitch (isolate_migratepages(zone, cc)) {\n\t\tcase ISOLATE_ABORT:\n\t\t\tret = COMPACT_CONTENDED;\n\t\t\tputback_movable_pages(&cc->migratepages);\n\t\t\tcc->nr_migratepages = 0;\n\t\t\tgoto out;\n\t\tcase ISOLATE_NONE:\n\t\t\t/*\n\t\t\t * We haven't isolated and migrated anything, but\n\t\t\t * there might still be unflushed migrations from\n\t\t\t * previous cc->order aligned block.\n\t\t\t */\n\t\t\tgoto check_drain;\n\t\tcase ISOLATE_SUCCESS:\n\t\t\t;\n\t\t}\n\n\t\terr = migrate_pages(&cc->migratepages, compaction_alloc,\n\t\t\t\tcompaction_free, (unsigned long)cc, cc->mode,\n\t\t\t\tMR_COMPACTION);\n\n\t\ttrace_mm_compaction_migratepages(cc->nr_migratepages, err,\n\t\t\t\t\t\t\t&cc->migratepages);\n\n\t\t/* All pages were either migrated or will be released */\n\t\tcc->nr_migratepages = 0;\n\t\tif (err) {\n\t\t\tputback_movable_pages(&cc->migratepages);\n\t\t\t/*\n\t\t\t * migrate_pages() may return -ENOMEM when scanners meet\n\t\t\t * and we want compact_finished() to detect it\n\t\t\t */\n\t\t\tif (err == -ENOMEM && !compact_scanners_met(cc)) {\n\t\t\t\tret = COMPACT_CONTENDED;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We failed to migrate at least one page in the current\n\t\t\t * order-aligned block, so skip the rest of it.\n\t\t\t */\n\t\t\tif (cc->direct_compaction &&\n\t\t\t\t\t\t(cc->mode == MIGRATE_ASYNC)) {\n\t\t\t\tcc->migrate_pfn = block_end_pfn(\n\t\t\t\t\t\tcc->migrate_pfn - 1, cc->order);\n\t\t\t\t/* Draining pcplists is useless in this case */\n\t\t\t\tcc->last_migrated_pfn = 0;\n\n\t\t\t}\n\t\t}\n\ncheck_drain:\n\t\t/*\n\t\t * Has the migration scanner moved away from the previous\n\t\t * cc->order aligned block where we migrated from? If yes,\n\t\t * flush the pages that were freed, so that they can merge and\n\t\t * compact_finished() can detect immediately if allocation\n\t\t * would succeed.\n\t\t */\n\t\tif (cc->order > 0 && cc->last_migrated_pfn) {\n\t\t\tint cpu;\n\t\t\tunsigned long current_block_start =\n\t\t\t\tblock_start_pfn(cc->migrate_pfn, cc->order);\n\n\t\t\tif (cc->last_migrated_pfn < current_block_start) {\n\t\t\t\tcpu = get_cpu();\n\t\t\t\tlru_add_drain_cpu(cpu);\n\t\t\t\tdrain_local_pages(zone);\n\t\t\t\tput_cpu();\n\t\t\t\t/* No more flushing until we migrate again */\n\t\t\t\tcc->last_migrated_pfn = 0;\n\t\t\t}\n\t\t}\n\n\t}\n\nout:\n\t/*\n\t * Release free pages and update where the free scanner should restart,\n\t * so we don't leave any returned pages behind in the next attempt.\n\t */\n\tif (cc->nr_freepages > 0) {\n\t\tunsigned long free_pfn = release_freepages(&cc->freepages);\n\n\t\tcc->nr_freepages = 0;\n\t\tVM_BUG_ON(free_pfn == 0);\n\t\t/* The cached pfn is always the first in a pageblock */\n\t\tfree_pfn = pageblock_start_pfn(free_pfn);\n\t\t/*\n\t\t * Only go back, not forward. The cached pfn might have been\n\t\t * already reset to zone end in compact_finished()\n\t\t */\n\t\tif (free_pfn > zone->compact_cached_free_pfn)\n\t\t\tzone->compact_cached_free_pfn = free_pfn;\n\t}\n\n\tcount_compact_events(COMPACTMIGRATE_SCANNED, cc->total_migrate_scanned);\n\tcount_compact_events(COMPACTFREE_SCANNED, cc->total_free_scanned);\n\n\ttrace_mm_compaction_end(start_pfn, cc->migrate_pfn,\n\t\t\t\tcc->free_pfn, end_pfn, sync, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cc.migratepages"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cc.freepages"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic enum compact_result compact_zone_order(struct zone *zone, int order,\n\t\tgfp_t gfp_mask, enum compact_priority prio,\n\t\tunsigned int alloc_flags, int classzone_idx)\n{\n\tenum compact_result ret;\n\tstruct compact_control cc = {\n\t\t.nr_freepages = 0,\n\t\t.nr_migratepages = 0,\n\t\t.total_migrate_scanned = 0,\n\t\t.total_free_scanned = 0,\n\t\t.order = order,\n\t\t.gfp_mask = gfp_mask,\n\t\t.zone = zone,\n\t\t.mode = (prio == COMPACT_PRIO_ASYNC) ?\n\t\t\t\t\tMIGRATE_ASYNC :\tMIGRATE_SYNC_LIGHT,\n\t\t.alloc_flags = alloc_flags,\n\t\t.classzone_idx = classzone_idx,\n\t\t.direct_compaction = true,\n\t\t.whole_zone = (prio == MIN_COMPACT_PRIORITY),\n\t\t.ignore_skip_hint = (prio == MIN_COMPACT_PRIORITY),\n\t\t.ignore_block_suitable = (prio == MIN_COMPACT_PRIORITY)\n\t};\n\tINIT_LIST_HEAD(&cc.freepages);\n\tINIT_LIST_HEAD(&cc.migratepages);\n\n\tret = compact_zone(zone, &cc);\n\n\tVM_BUG_ON(!list_empty(&cc.freepages));\n\tVM_BUG_ON(!list_empty(&cc.migratepages));\n\n\treturn ret;\n}"
  },
  {
    "function_name": "compact_zone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "1537-1699",
    "snippet": "static enum compact_result compact_zone(struct zone *zone, struct compact_control *cc)\n{\n\tenum compact_result ret;\n\tunsigned long start_pfn = zone->zone_start_pfn;\n\tunsigned long end_pfn = zone_end_pfn(zone);\n\tconst bool sync = cc->mode != MIGRATE_ASYNC;\n\n\tcc->migratetype = gfpflags_to_migratetype(cc->gfp_mask);\n\tret = compaction_suitable(zone, cc->order, cc->alloc_flags,\n\t\t\t\t\t\t\tcc->classzone_idx);\n\t/* Compaction is likely to fail */\n\tif (ret == COMPACT_SUCCESS || ret == COMPACT_SKIPPED)\n\t\treturn ret;\n\n\t/* huh, compaction_suitable is returning something unexpected */\n\tVM_BUG_ON(ret != COMPACT_CONTINUE);\n\n\t/*\n\t * Clear pageblock skip if there were failures recently and compaction\n\t * is about to be retried after being deferred.\n\t */\n\tif (compaction_restarting(zone, cc->order))\n\t\t__reset_isolation_suitable(zone);\n\n\t/*\n\t * Setup to move all movable pages to the end of the zone. Used cached\n\t * information on where the scanners should start (unless we explicitly\n\t * want to compact the whole zone), but check that it is initialised\n\t * by ensuring the values are within zone boundaries.\n\t */\n\tif (cc->whole_zone) {\n\t\tcc->migrate_pfn = start_pfn;\n\t\tcc->free_pfn = pageblock_start_pfn(end_pfn - 1);\n\t} else {\n\t\tcc->migrate_pfn = zone->compact_cached_migrate_pfn[sync];\n\t\tcc->free_pfn = zone->compact_cached_free_pfn;\n\t\tif (cc->free_pfn < start_pfn || cc->free_pfn >= end_pfn) {\n\t\t\tcc->free_pfn = pageblock_start_pfn(end_pfn - 1);\n\t\t\tzone->compact_cached_free_pfn = cc->free_pfn;\n\t\t}\n\t\tif (cc->migrate_pfn < start_pfn || cc->migrate_pfn >= end_pfn) {\n\t\t\tcc->migrate_pfn = start_pfn;\n\t\t\tzone->compact_cached_migrate_pfn[0] = cc->migrate_pfn;\n\t\t\tzone->compact_cached_migrate_pfn[1] = cc->migrate_pfn;\n\t\t}\n\n\t\tif (cc->migrate_pfn == start_pfn)\n\t\t\tcc->whole_zone = true;\n\t}\n\n\tcc->last_migrated_pfn = 0;\n\n\ttrace_mm_compaction_begin(start_pfn, cc->migrate_pfn,\n\t\t\t\tcc->free_pfn, end_pfn, sync);\n\n\tmigrate_prep_local();\n\n\twhile ((ret = compact_finished(zone, cc)) == COMPACT_CONTINUE) {\n\t\tint err;\n\n\t\tswitch (isolate_migratepages(zone, cc)) {\n\t\tcase ISOLATE_ABORT:\n\t\t\tret = COMPACT_CONTENDED;\n\t\t\tputback_movable_pages(&cc->migratepages);\n\t\t\tcc->nr_migratepages = 0;\n\t\t\tgoto out;\n\t\tcase ISOLATE_NONE:\n\t\t\t/*\n\t\t\t * We haven't isolated and migrated anything, but\n\t\t\t * there might still be unflushed migrations from\n\t\t\t * previous cc->order aligned block.\n\t\t\t */\n\t\t\tgoto check_drain;\n\t\tcase ISOLATE_SUCCESS:\n\t\t\t;\n\t\t}\n\n\t\terr = migrate_pages(&cc->migratepages, compaction_alloc,\n\t\t\t\tcompaction_free, (unsigned long)cc, cc->mode,\n\t\t\t\tMR_COMPACTION);\n\n\t\ttrace_mm_compaction_migratepages(cc->nr_migratepages, err,\n\t\t\t\t\t\t\t&cc->migratepages);\n\n\t\t/* All pages were either migrated or will be released */\n\t\tcc->nr_migratepages = 0;\n\t\tif (err) {\n\t\t\tputback_movable_pages(&cc->migratepages);\n\t\t\t/*\n\t\t\t * migrate_pages() may return -ENOMEM when scanners meet\n\t\t\t * and we want compact_finished() to detect it\n\t\t\t */\n\t\t\tif (err == -ENOMEM && !compact_scanners_met(cc)) {\n\t\t\t\tret = COMPACT_CONTENDED;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We failed to migrate at least one page in the current\n\t\t\t * order-aligned block, so skip the rest of it.\n\t\t\t */\n\t\t\tif (cc->direct_compaction &&\n\t\t\t\t\t\t(cc->mode == MIGRATE_ASYNC)) {\n\t\t\t\tcc->migrate_pfn = block_end_pfn(\n\t\t\t\t\t\tcc->migrate_pfn - 1, cc->order);\n\t\t\t\t/* Draining pcplists is useless in this case */\n\t\t\t\tcc->last_migrated_pfn = 0;\n\n\t\t\t}\n\t\t}\n\ncheck_drain:\n\t\t/*\n\t\t * Has the migration scanner moved away from the previous\n\t\t * cc->order aligned block where we migrated from? If yes,\n\t\t * flush the pages that were freed, so that they can merge and\n\t\t * compact_finished() can detect immediately if allocation\n\t\t * would succeed.\n\t\t */\n\t\tif (cc->order > 0 && cc->last_migrated_pfn) {\n\t\t\tint cpu;\n\t\t\tunsigned long current_block_start =\n\t\t\t\tblock_start_pfn(cc->migrate_pfn, cc->order);\n\n\t\t\tif (cc->last_migrated_pfn < current_block_start) {\n\t\t\t\tcpu = get_cpu();\n\t\t\t\tlru_add_drain_cpu(cpu);\n\t\t\t\tdrain_local_pages(zone);\n\t\t\t\tput_cpu();\n\t\t\t\t/* No more flushing until we migrate again */\n\t\t\t\tcc->last_migrated_pfn = 0;\n\t\t\t}\n\t\t}\n\n\t}\n\nout:\n\t/*\n\t * Release free pages and update where the free scanner should restart,\n\t * so we don't leave any returned pages behind in the next attempt.\n\t */\n\tif (cc->nr_freepages > 0) {\n\t\tunsigned long free_pfn = release_freepages(&cc->freepages);\n\n\t\tcc->nr_freepages = 0;\n\t\tVM_BUG_ON(free_pfn == 0);\n\t\t/* The cached pfn is always the first in a pageblock */\n\t\tfree_pfn = pageblock_start_pfn(free_pfn);\n\t\t/*\n\t\t * Only go back, not forward. The cached pfn might have been\n\t\t * already reset to zone end in compact_finished()\n\t\t */\n\t\tif (free_pfn > zone->compact_cached_free_pfn)\n\t\t\tzone->compact_cached_free_pfn = free_pfn;\n\t}\n\n\tcount_compact_events(COMPACTMIGRATE_SCANNED, cc->total_migrate_scanned);\n\tcount_compact_events(COMPACTFREE_SCANNED, cc->total_free_scanned);\n\n\ttrace_mm_compaction_end(start_pfn, cc->migrate_pfn,\n\t\t\t\tcc->free_pfn, end_pfn, sync, ret);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_mm_compaction_end",
          "args": [
            "start_pfn",
            "cc->migrate_pfn",
            "cc->free_pfn",
            "end_pfn",
            "sync",
            "ret"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_compact_events",
          "args": [
            "COMPACTFREE_SCANNED",
            "cc->total_free_scanned"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "count_compact_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "34-37",
          "snippet": "static inline void count_compact_events(enum vm_event_item item, long delta)\n{\n\tcount_vm_events(item, delta);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline void count_compact_events(enum vm_event_item item, long delta)\n{\n\tcount_vm_events(item, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pageblock_start_pfn",
          "args": [
            "free_pfn"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "free_pfn == 0"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_freepages",
          "args": [
            "&cc->freepages"
          ],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "release_freepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "53-67",
          "snippet": "static unsigned long release_freepages(struct list_head *freelist)\n{\n\tstruct page *page, *next;\n\tunsigned long high_pfn = 0;\n\n\tlist_for_each_entry_safe(page, next, freelist, lru) {\n\t\tunsigned long pfn = page_to_pfn(page);\n\t\tlist_del(&page->lru);\n\t\t__free_page(page);\n\t\tif (pfn > high_pfn)\n\t\t\thigh_pfn = pfn;\n\t}\n\n\treturn high_pfn;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic unsigned long release_freepages(struct list_head *freelist)\n{\n\tstruct page *page, *next;\n\tunsigned long high_pfn = 0;\n\n\tlist_for_each_entry_safe(page, next, freelist, lru) {\n\t\tunsigned long pfn = page_to_pfn(page);\n\t\tlist_del(&page->lru);\n\t\t__free_page(page);\n\t\tif (pfn > high_pfn)\n\t\t\thigh_pfn = pfn;\n\t}\n\n\treturn high_pfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drain_local_pages",
          "args": [
            "zone"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "drain_local_pages_wq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2593-2605",
          "snippet": "static void drain_local_pages_wq(struct work_struct *work)\n{\n\t/*\n\t * drain_all_pages doesn't use proper cpu hotplug protection so\n\t * we can race with cpu offline when the WQ can move this from\n\t * a cpu pinned worker to an unbound one. We can operate on a different\n\t * cpu which is allright but we also have to make sure to not move to\n\t * a different one.\n\t */\n\tpreempt_disable();\n\tdrain_local_pages(NULL);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void drain_local_pages_wq(struct work_struct *work)\n{\n\t/*\n\t * drain_all_pages doesn't use proper cpu hotplug protection so\n\t * we can race with cpu offline when the WQ can move this from\n\t * a cpu pinned worker to an unbound one. We can operate on a different\n\t * cpu which is allright but we also have to make sure to not move to\n\t * a different one.\n\t */\n\tpreempt_disable();\n\tdrain_local_pages(NULL);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_add_drain_cpu",
          "args": [
            "cpu"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "576-602",
          "snippet": "void lru_add_drain_cpu(int cpu)\n{\n\tstruct pagevec *pvec = &per_cpu(lru_add_pvec, cpu);\n\n\tif (pagevec_count(pvec))\n\t\t__pagevec_lru_add(pvec);\n\n\tpvec = &per_cpu(lru_rotate_pvecs, cpu);\n\tif (pagevec_count(pvec)) {\n\t\tunsigned long flags;\n\n\t\t/* No harm done if a racing interrupt already did this */\n\t\tlocal_irq_save(flags);\n\t\tpagevec_move_tail(pvec);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\tpvec = &per_cpu(lru_deactivate_file_pvecs, cpu);\n\tif (pagevec_count(pvec))\n\t\tpagevec_lru_move_fn(pvec, lru_deactivate_file_fn, NULL);\n\n\tpvec = &per_cpu(lru_lazyfree_pvecs, cpu);\n\tif (pagevec_count(pvec))\n\t\tpagevec_lru_move_fn(pvec, lru_lazyfree_fn, NULL);\n\n\tactivate_page_drain(cpu);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\n\nvoid lru_add_drain_cpu(int cpu)\n{\n\tstruct pagevec *pvec = &per_cpu(lru_add_pvec, cpu);\n\n\tif (pagevec_count(pvec))\n\t\t__pagevec_lru_add(pvec);\n\n\tpvec = &per_cpu(lru_rotate_pvecs, cpu);\n\tif (pagevec_count(pvec)) {\n\t\tunsigned long flags;\n\n\t\t/* No harm done if a racing interrupt already did this */\n\t\tlocal_irq_save(flags);\n\t\tpagevec_move_tail(pvec);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\tpvec = &per_cpu(lru_deactivate_file_pvecs, cpu);\n\tif (pagevec_count(pvec))\n\t\tpagevec_lru_move_fn(pvec, lru_deactivate_file_fn, NULL);\n\n\tpvec = &per_cpu(lru_lazyfree_pvecs, cpu);\n\tif (pagevec_count(pvec))\n\t\tpagevec_lru_move_fn(pvec, lru_lazyfree_fn, NULL);\n\n\tactivate_page_drain(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_start_pfn",
          "args": [
            "cc->migrate_pfn",
            "cc->order"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_end_pfn",
          "args": [
            "cc->migrate_pfn - 1",
            "cc->order"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compact_scanners_met",
          "args": [
            "cc"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "compact_scanners_met",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1057-1061",
          "snippet": "static inline bool compact_scanners_met(struct compact_control *cc)\n{\n\treturn (cc->free_pfn >> pageblock_order)\n\t\t<= (cc->migrate_pfn >> pageblock_order);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline bool compact_scanners_met(struct compact_control *cc)\n{\n\treturn (cc->free_pfn >> pageblock_order)\n\t\t<= (cc->migrate_pfn >> pageblock_order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "putback_movable_pages",
          "args": [
            "&cc->migratepages"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "putback_movable_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "167-198",
          "snippet": "void putback_movable_pages(struct list_head *l)\n{\n\tstruct page *page;\n\tstruct page *page2;\n\n\tlist_for_each_entry_safe(page, page2, l, lru) {\n\t\tif (unlikely(PageHuge(page))) {\n\t\t\tputback_active_hugepage(page);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&page->lru);\n\t\t/*\n\t\t * We isolated non-lru movable page so here we can use\n\t\t * __PageMovable because LRU page's mapping cannot have\n\t\t * PAGE_MAPPING_MOVABLE.\n\t\t */\n\t\tif (unlikely(__PageMovable(page))) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\t\tlock_page(page);\n\t\t\tif (PageMovable(page))\n\t\t\t\tputback_movable_page(page);\n\t\t\telse\n\t\t\t\t__ClearPageIsolated(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t} else {\n\t\t\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page), -hpage_nr_pages(page));\n\t\t\tputback_lru_page(page);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid putback_movable_pages(struct list_head *l)\n{\n\tstruct page *page;\n\tstruct page *page2;\n\n\tlist_for_each_entry_safe(page, page2, l, lru) {\n\t\tif (unlikely(PageHuge(page))) {\n\t\t\tputback_active_hugepage(page);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&page->lru);\n\t\t/*\n\t\t * We isolated non-lru movable page so here we can use\n\t\t * __PageMovable because LRU page's mapping cannot have\n\t\t * PAGE_MAPPING_MOVABLE.\n\t\t */\n\t\tif (unlikely(__PageMovable(page))) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\t\tlock_page(page);\n\t\t\tif (PageMovable(page))\n\t\t\t\tputback_movable_page(page);\n\t\t\telse\n\t\t\t\t__ClearPageIsolated(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t} else {\n\t\t\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page), -hpage_nr_pages(page));\n\t\t\tputback_lru_page(page);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_mm_compaction_migratepages",
          "args": [
            "cc->nr_migratepages",
            "err",
            "&cc->migratepages"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_pages",
          "args": [
            "&cc->migratepages",
            "compaction_alloc",
            "compaction_free",
            "(unsigned long)cc",
            "cc->mode",
            "MR_COMPACTION"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "1362-1449",
          "snippet": "int migrate_pages(struct list_head *from, new_page_t get_new_page,\n\t\tfree_page_t put_new_page, unsigned long private,\n\t\tenum migrate_mode mode, int reason)\n{\n\tint retry = 1;\n\tint nr_failed = 0;\n\tint nr_succeeded = 0;\n\tint pass = 0;\n\tstruct page *page;\n\tstruct page *page2;\n\tint swapwrite = current->flags & PF_SWAPWRITE;\n\tint rc;\n\n\tif (!swapwrite)\n\t\tcurrent->flags |= PF_SWAPWRITE;\n\n\tfor(pass = 0; pass < 10 && retry; pass++) {\n\t\tretry = 0;\n\n\t\tlist_for_each_entry_safe(page, page2, from, lru) {\nretry:\n\t\t\tcond_resched();\n\n\t\t\tif (PageHuge(page))\n\t\t\t\trc = unmap_and_move_huge_page(get_new_page,\n\t\t\t\t\t\tput_new_page, private, page,\n\t\t\t\t\t\tpass > 2, mode, reason);\n\t\t\telse\n\t\t\t\trc = unmap_and_move(get_new_page, put_new_page,\n\t\t\t\t\t\tprivate, page, pass > 2, mode,\n\t\t\t\t\t\treason);\n\n\t\t\tswitch(rc) {\n\t\t\tcase -ENOMEM:\n\t\t\t\t/*\n\t\t\t\t * THP migration might be unsupported or the\n\t\t\t\t * allocation could've failed so we should\n\t\t\t\t * retry on the same page with the THP split\n\t\t\t\t * to base pages.\n\t\t\t\t *\n\t\t\t\t * Head page is retried immediately and tail\n\t\t\t\t * pages are added to the tail of the list so\n\t\t\t\t * we encounter them after the rest of the list\n\t\t\t\t * is processed.\n\t\t\t\t */\n\t\t\t\tif (PageTransHuge(page) && !PageHuge(page)) {\n\t\t\t\t\tlock_page(page);\n\t\t\t\t\trc = split_huge_page_to_list(page, from);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tif (!rc) {\n\t\t\t\t\t\tlist_safe_reset_next(page, page2, lru);\n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnr_failed++;\n\t\t\t\tgoto out;\n\t\t\tcase -EAGAIN:\n\t\t\t\tretry++;\n\t\t\t\tbreak;\n\t\t\tcase MIGRATEPAGE_SUCCESS:\n\t\t\t\tnr_succeeded++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Permanent failure (-EBUSY, -ENOSYS, etc.):\n\t\t\t\t * unlike -EAGAIN case, the failed page is\n\t\t\t\t * removed from migration page list and not\n\t\t\t\t * retried in the next outer loop.\n\t\t\t\t */\n\t\t\t\tnr_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tnr_failed += retry;\n\trc = nr_failed;\nout:\n\tif (nr_succeeded)\n\t\tcount_vm_events(PGMIGRATE_SUCCESS, nr_succeeded);\n\tif (nr_failed)\n\t\tcount_vm_events(PGMIGRATE_FAIL, nr_failed);\n\ttrace_mm_migrate_pages(nr_succeeded, nr_failed, mode, reason);\n\n\tif (!swapwrite)\n\t\tcurrent->flags &= ~PF_SWAPWRITE;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint migrate_pages(struct list_head *from, new_page_t get_new_page,\n\t\tfree_page_t put_new_page, unsigned long private,\n\t\tenum migrate_mode mode, int reason)\n{\n\tint retry = 1;\n\tint nr_failed = 0;\n\tint nr_succeeded = 0;\n\tint pass = 0;\n\tstruct page *page;\n\tstruct page *page2;\n\tint swapwrite = current->flags & PF_SWAPWRITE;\n\tint rc;\n\n\tif (!swapwrite)\n\t\tcurrent->flags |= PF_SWAPWRITE;\n\n\tfor(pass = 0; pass < 10 && retry; pass++) {\n\t\tretry = 0;\n\n\t\tlist_for_each_entry_safe(page, page2, from, lru) {\nretry:\n\t\t\tcond_resched();\n\n\t\t\tif (PageHuge(page))\n\t\t\t\trc = unmap_and_move_huge_page(get_new_page,\n\t\t\t\t\t\tput_new_page, private, page,\n\t\t\t\t\t\tpass > 2, mode, reason);\n\t\t\telse\n\t\t\t\trc = unmap_and_move(get_new_page, put_new_page,\n\t\t\t\t\t\tprivate, page, pass > 2, mode,\n\t\t\t\t\t\treason);\n\n\t\t\tswitch(rc) {\n\t\t\tcase -ENOMEM:\n\t\t\t\t/*\n\t\t\t\t * THP migration might be unsupported or the\n\t\t\t\t * allocation could've failed so we should\n\t\t\t\t * retry on the same page with the THP split\n\t\t\t\t * to base pages.\n\t\t\t\t *\n\t\t\t\t * Head page is retried immediately and tail\n\t\t\t\t * pages are added to the tail of the list so\n\t\t\t\t * we encounter them after the rest of the list\n\t\t\t\t * is processed.\n\t\t\t\t */\n\t\t\t\tif (PageTransHuge(page) && !PageHuge(page)) {\n\t\t\t\t\tlock_page(page);\n\t\t\t\t\trc = split_huge_page_to_list(page, from);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tif (!rc) {\n\t\t\t\t\t\tlist_safe_reset_next(page, page2, lru);\n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnr_failed++;\n\t\t\t\tgoto out;\n\t\t\tcase -EAGAIN:\n\t\t\t\tretry++;\n\t\t\t\tbreak;\n\t\t\tcase MIGRATEPAGE_SUCCESS:\n\t\t\t\tnr_succeeded++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Permanent failure (-EBUSY, -ENOSYS, etc.):\n\t\t\t\t * unlike -EAGAIN case, the failed page is\n\t\t\t\t * removed from migration page list and not\n\t\t\t\t * retried in the next outer loop.\n\t\t\t\t */\n\t\t\t\tnr_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tnr_failed += retry;\n\trc = nr_failed;\nout:\n\tif (nr_succeeded)\n\t\tcount_vm_events(PGMIGRATE_SUCCESS, nr_succeeded);\n\tif (nr_failed)\n\t\tcount_vm_events(PGMIGRATE_FAIL, nr_failed);\n\ttrace_mm_migrate_pages(nr_succeeded, nr_failed, mode, reason);\n\n\tif (!swapwrite)\n\t\tcurrent->flags &= ~PF_SWAPWRITE;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isolate_migratepages",
          "args": [
            "zone",
            "cc"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_migratepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1225-1302",
          "snippet": "static isolate_migrate_t isolate_migratepages(struct zone *zone,\n\t\t\t\t\tstruct compact_control *cc)\n{\n\tunsigned long block_start_pfn;\n\tunsigned long block_end_pfn;\n\tunsigned long low_pfn;\n\tstruct page *page;\n\tconst isolate_mode_t isolate_mode =\n\t\t(sysctl_compact_unevictable_allowed ? ISOLATE_UNEVICTABLE : 0) |\n\t\t(cc->mode != MIGRATE_SYNC ? ISOLATE_ASYNC_MIGRATE : 0);\n\n\t/*\n\t * Start at where we last stopped, or beginning of the zone as\n\t * initialized by compact_zone()\n\t */\n\tlow_pfn = cc->migrate_pfn;\n\tblock_start_pfn = pageblock_start_pfn(low_pfn);\n\tif (block_start_pfn < zone->zone_start_pfn)\n\t\tblock_start_pfn = zone->zone_start_pfn;\n\n\t/* Only scan within a pageblock boundary */\n\tblock_end_pfn = pageblock_end_pfn(low_pfn);\n\n\t/*\n\t * Iterate over whole pageblocks until we find the first suitable.\n\t * Do not cross the free scanner.\n\t */\n\tfor (; block_end_pfn <= cc->free_pfn;\n\t\t\tlow_pfn = block_end_pfn,\n\t\t\tblock_start_pfn = block_end_pfn,\n\t\t\tblock_end_pfn += pageblock_nr_pages) {\n\n\t\t/*\n\t\t * This can potentially iterate a massively long zone with\n\t\t * many pageblocks unsuitable, so periodically check if we\n\t\t * need to schedule, or even abort async compaction.\n\t\t */\n\t\tif (!(low_pfn % (SWAP_CLUSTER_MAX * pageblock_nr_pages))\n\t\t\t\t\t\t&& compact_should_abort(cc))\n\t\t\tbreak;\n\n\t\tpage = pageblock_pfn_to_page(block_start_pfn, block_end_pfn,\n\t\t\t\t\t\t\t\t\tzone);\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\t/* If isolation recently failed, do not retry */\n\t\tif (!isolation_suitable(cc, page))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * For async compaction, also only scan in MOVABLE blocks.\n\t\t * Async compaction is optimistic to see if the minimum amount\n\t\t * of work satisfies the allocation.\n\t\t */\n\t\tif (!suitable_migration_source(cc, page))\n\t\t\tcontinue;\n\n\t\t/* Perform the isolation */\n\t\tlow_pfn = isolate_migratepages_block(cc, low_pfn,\n\t\t\t\t\t\tblock_end_pfn, isolate_mode);\n\n\t\tif (!low_pfn || cc->contended)\n\t\t\treturn ISOLATE_ABORT;\n\n\t\t/*\n\t\t * Either we isolated something and proceed with migration. Or\n\t\t * we failed and compact_zone should decide if we should\n\t\t * continue or not.\n\t\t */\n\t\tbreak;\n\t}\n\n\t/* Record where migration scanner will be restarted. */\n\tcc->migrate_pfn = low_pfn;\n\n\treturn cc->nr_migratepages ? ISOLATE_SUCCESS : ISOLATE_NONE;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic isolate_migrate_t isolate_migratepages(struct zone *zone,\n\t\t\t\t\tstruct compact_control *cc)\n{\n\tunsigned long block_start_pfn;\n\tunsigned long block_end_pfn;\n\tunsigned long low_pfn;\n\tstruct page *page;\n\tconst isolate_mode_t isolate_mode =\n\t\t(sysctl_compact_unevictable_allowed ? ISOLATE_UNEVICTABLE : 0) |\n\t\t(cc->mode != MIGRATE_SYNC ? ISOLATE_ASYNC_MIGRATE : 0);\n\n\t/*\n\t * Start at where we last stopped, or beginning of the zone as\n\t * initialized by compact_zone()\n\t */\n\tlow_pfn = cc->migrate_pfn;\n\tblock_start_pfn = pageblock_start_pfn(low_pfn);\n\tif (block_start_pfn < zone->zone_start_pfn)\n\t\tblock_start_pfn = zone->zone_start_pfn;\n\n\t/* Only scan within a pageblock boundary */\n\tblock_end_pfn = pageblock_end_pfn(low_pfn);\n\n\t/*\n\t * Iterate over whole pageblocks until we find the first suitable.\n\t * Do not cross the free scanner.\n\t */\n\tfor (; block_end_pfn <= cc->free_pfn;\n\t\t\tlow_pfn = block_end_pfn,\n\t\t\tblock_start_pfn = block_end_pfn,\n\t\t\tblock_end_pfn += pageblock_nr_pages) {\n\n\t\t/*\n\t\t * This can potentially iterate a massively long zone with\n\t\t * many pageblocks unsuitable, so periodically check if we\n\t\t * need to schedule, or even abort async compaction.\n\t\t */\n\t\tif (!(low_pfn % (SWAP_CLUSTER_MAX * pageblock_nr_pages))\n\t\t\t\t\t\t&& compact_should_abort(cc))\n\t\t\tbreak;\n\n\t\tpage = pageblock_pfn_to_page(block_start_pfn, block_end_pfn,\n\t\t\t\t\t\t\t\t\tzone);\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\t/* If isolation recently failed, do not retry */\n\t\tif (!isolation_suitable(cc, page))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * For async compaction, also only scan in MOVABLE blocks.\n\t\t * Async compaction is optimistic to see if the minimum amount\n\t\t * of work satisfies the allocation.\n\t\t */\n\t\tif (!suitable_migration_source(cc, page))\n\t\t\tcontinue;\n\n\t\t/* Perform the isolation */\n\t\tlow_pfn = isolate_migratepages_block(cc, low_pfn,\n\t\t\t\t\t\tblock_end_pfn, isolate_mode);\n\n\t\tif (!low_pfn || cc->contended)\n\t\t\treturn ISOLATE_ABORT;\n\n\t\t/*\n\t\t * Either we isolated something and proceed with migration. Or\n\t\t * we failed and compact_zone should decide if we should\n\t\t * continue or not.\n\t\t */\n\t\tbreak;\n\t}\n\n\t/* Record where migration scanner will be restarted. */\n\tcc->migrate_pfn = low_pfn;\n\n\treturn cc->nr_migratepages ? ISOLATE_SUCCESS : ISOLATE_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact_finished",
          "args": [
            "zone",
            "cc"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "compact_finished",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1404-1415",
          "snippet": "static enum compact_result compact_finished(struct zone *zone,\n\t\t\tstruct compact_control *cc)\n{\n\tint ret;\n\n\tret = __compact_finished(zone, cc);\n\ttrace_mm_compaction_finished(zone, cc->order, ret);\n\tif (ret == COMPACT_NO_SUITABLE_PAGE)\n\t\tret = COMPACT_CONTINUE;\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic enum compact_result compact_finished(struct zone *zone,\n\t\t\tstruct compact_control *cc)\n{\n\tint ret;\n\n\tret = __compact_finished(zone, cc);\n\ttrace_mm_compaction_finished(zone, cc->order, ret);\n\tif (ret == COMPACT_NO_SUITABLE_PAGE)\n\t\tret = COMPACT_CONTINUE;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "migrate_prep_local",
          "args": [],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_prep_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "77-82",
          "snippet": "int migrate_prep_local(void)\n{\n\tlru_add_drain();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint migrate_prep_local(void)\n{\n\tlru_add_drain();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_mm_compaction_begin",
          "args": [
            "start_pfn",
            "cc->migrate_pfn",
            "cc->free_pfn",
            "end_pfn",
            "sync"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pageblock_start_pfn",
          "args": [
            "end_pfn - 1"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pageblock_start_pfn",
          "args": [
            "end_pfn - 1"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__reset_isolation_suitable",
          "args": [
            "zone"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "__reset_isolation_suitable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "245-271",
          "snippet": "static void __reset_isolation_suitable(struct zone *zone)\n{\n\tunsigned long start_pfn = zone->zone_start_pfn;\n\tunsigned long end_pfn = zone_end_pfn(zone);\n\tunsigned long pfn;\n\n\tzone->compact_blockskip_flush = false;\n\n\t/* Walk the zone and mark every pageblock as suitable for isolation */\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += pageblock_nr_pages) {\n\t\tstruct page *page;\n\n\t\tcond_resched();\n\n\t\tpage = pfn_to_online_page(pfn);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (zone != page_zone(page))\n\t\t\tcontinue;\n\t\tif (pageblock_skip_persistent(page))\n\t\t\tcontinue;\n\n\t\tclear_pageblock_skip(page);\n\t}\n\n\treset_cached_positions(zone);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic void __reset_isolation_suitable(struct zone *zone)\n{\n\tunsigned long start_pfn = zone->zone_start_pfn;\n\tunsigned long end_pfn = zone_end_pfn(zone);\n\tunsigned long pfn;\n\n\tzone->compact_blockskip_flush = false;\n\n\t/* Walk the zone and mark every pageblock as suitable for isolation */\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += pageblock_nr_pages) {\n\t\tstruct page *page;\n\n\t\tcond_resched();\n\n\t\tpage = pfn_to_online_page(pfn);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (zone != page_zone(page))\n\t\t\tcontinue;\n\t\tif (pageblock_skip_persistent(page))\n\t\t\tcontinue;\n\n\t\tclear_pageblock_skip(page);\n\t}\n\n\treset_cached_positions(zone);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compaction_restarting",
          "args": [
            "zone",
            "cc->order"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "compaction_restarting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "195-202",
          "snippet": "bool compaction_restarting(struct zone *zone, int order)\n{\n\tif (order < zone->compact_order_failed)\n\t\treturn false;\n\n\treturn zone->compact_defer_shift == COMPACT_MAX_DEFER_SHIFT &&\n\t\tzone->compact_considered >= 1UL << zone->compact_defer_shift;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define COMPACT_MAX_DEFER_SHIFT 6"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\n#define COMPACT_MAX_DEFER_SHIFT 6\n\nbool compaction_restarting(struct zone *zone, int order)\n{\n\tif (order < zone->compact_order_failed)\n\t\treturn false;\n\n\treturn zone->compact_defer_shift == COMPACT_MAX_DEFER_SHIFT &&\n\t\tzone->compact_considered >= 1UL << zone->compact_defer_shift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "ret != COMPACT_CONTINUE"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compaction_suitable",
          "args": [
            "zone",
            "cc->order",
            "cc->alloc_flags",
            "cc->classzone_idx"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "compaction_suitable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1467-1503",
          "snippet": "enum compact_result compaction_suitable(struct zone *zone, int order,\n\t\t\t\t\tunsigned int alloc_flags,\n\t\t\t\t\tint classzone_idx)\n{\n\tenum compact_result ret;\n\tint fragindex;\n\n\tret = __compaction_suitable(zone, order, alloc_flags, classzone_idx,\n\t\t\t\t    zone_page_state(zone, NR_FREE_PAGES));\n\t/*\n\t * fragmentation index determines if allocation failures are due to\n\t * low memory or external fragmentation\n\t *\n\t * index of -1000 would imply allocations might succeed depending on\n\t * watermarks, but we already failed the high-order watermark check\n\t * index towards 0 implies failure is due to lack of memory\n\t * index towards 1000 implies failure is due to fragmentation\n\t *\n\t * Only compact if a failure would be due to fragmentation. Also\n\t * ignore fragindex for non-costly orders where the alternative to\n\t * a successful reclaim/compaction is OOM. Fragindex and the\n\t * vm.extfrag_threshold sysctl is meant as a heuristic to prevent\n\t * excessive compaction for costly orders, but it should not be at the\n\t * expense of system stability.\n\t */\n\tif (ret == COMPACT_CONTINUE && (order > PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tfragindex = fragmentation_index(zone, order);\n\t\tif (fragindex >= 0 && fragindex <= sysctl_extfrag_threshold)\n\t\t\tret = COMPACT_NOT_SUITABLE_ZONE;\n\t}\n\n\ttrace_mm_compaction_suitable(zone, order, ret);\n\tif (ret == COMPACT_NOT_SUITABLE_ZONE)\n\t\tret = COMPACT_SKIPPED;\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nenum compact_result compaction_suitable(struct zone *zone, int order,\n\t\t\t\t\tunsigned int alloc_flags,\n\t\t\t\t\tint classzone_idx)\n{\n\tenum compact_result ret;\n\tint fragindex;\n\n\tret = __compaction_suitable(zone, order, alloc_flags, classzone_idx,\n\t\t\t\t    zone_page_state(zone, NR_FREE_PAGES));\n\t/*\n\t * fragmentation index determines if allocation failures are due to\n\t * low memory or external fragmentation\n\t *\n\t * index of -1000 would imply allocations might succeed depending on\n\t * watermarks, but we already failed the high-order watermark check\n\t * index towards 0 implies failure is due to lack of memory\n\t * index towards 1000 implies failure is due to fragmentation\n\t *\n\t * Only compact if a failure would be due to fragmentation. Also\n\t * ignore fragindex for non-costly orders where the alternative to\n\t * a successful reclaim/compaction is OOM. Fragindex and the\n\t * vm.extfrag_threshold sysctl is meant as a heuristic to prevent\n\t * excessive compaction for costly orders, but it should not be at the\n\t * expense of system stability.\n\t */\n\tif (ret == COMPACT_CONTINUE && (order > PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tfragindex = fragmentation_index(zone, order);\n\t\tif (fragindex >= 0 && fragindex <= sysctl_extfrag_threshold)\n\t\t\tret = COMPACT_NOT_SUITABLE_ZONE;\n\t}\n\n\ttrace_mm_compaction_suitable(zone, order, ret);\n\tif (ret == COMPACT_NOT_SUITABLE_ZONE)\n\t\tret = COMPACT_SKIPPED;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfpflags_to_migratetype",
          "args": [
            "cc->gfp_mask"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_end_pfn",
          "args": [
            "zone"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic enum compact_result compact_zone(struct zone *zone, struct compact_control *cc)\n{\n\tenum compact_result ret;\n\tunsigned long start_pfn = zone->zone_start_pfn;\n\tunsigned long end_pfn = zone_end_pfn(zone);\n\tconst bool sync = cc->mode != MIGRATE_ASYNC;\n\n\tcc->migratetype = gfpflags_to_migratetype(cc->gfp_mask);\n\tret = compaction_suitable(zone, cc->order, cc->alloc_flags,\n\t\t\t\t\t\t\tcc->classzone_idx);\n\t/* Compaction is likely to fail */\n\tif (ret == COMPACT_SUCCESS || ret == COMPACT_SKIPPED)\n\t\treturn ret;\n\n\t/* huh, compaction_suitable is returning something unexpected */\n\tVM_BUG_ON(ret != COMPACT_CONTINUE);\n\n\t/*\n\t * Clear pageblock skip if there were failures recently and compaction\n\t * is about to be retried after being deferred.\n\t */\n\tif (compaction_restarting(zone, cc->order))\n\t\t__reset_isolation_suitable(zone);\n\n\t/*\n\t * Setup to move all movable pages to the end of the zone. Used cached\n\t * information on where the scanners should start (unless we explicitly\n\t * want to compact the whole zone), but check that it is initialised\n\t * by ensuring the values are within zone boundaries.\n\t */\n\tif (cc->whole_zone) {\n\t\tcc->migrate_pfn = start_pfn;\n\t\tcc->free_pfn = pageblock_start_pfn(end_pfn - 1);\n\t} else {\n\t\tcc->migrate_pfn = zone->compact_cached_migrate_pfn[sync];\n\t\tcc->free_pfn = zone->compact_cached_free_pfn;\n\t\tif (cc->free_pfn < start_pfn || cc->free_pfn >= end_pfn) {\n\t\t\tcc->free_pfn = pageblock_start_pfn(end_pfn - 1);\n\t\t\tzone->compact_cached_free_pfn = cc->free_pfn;\n\t\t}\n\t\tif (cc->migrate_pfn < start_pfn || cc->migrate_pfn >= end_pfn) {\n\t\t\tcc->migrate_pfn = start_pfn;\n\t\t\tzone->compact_cached_migrate_pfn[0] = cc->migrate_pfn;\n\t\t\tzone->compact_cached_migrate_pfn[1] = cc->migrate_pfn;\n\t\t}\n\n\t\tif (cc->migrate_pfn == start_pfn)\n\t\t\tcc->whole_zone = true;\n\t}\n\n\tcc->last_migrated_pfn = 0;\n\n\ttrace_mm_compaction_begin(start_pfn, cc->migrate_pfn,\n\t\t\t\tcc->free_pfn, end_pfn, sync);\n\n\tmigrate_prep_local();\n\n\twhile ((ret = compact_finished(zone, cc)) == COMPACT_CONTINUE) {\n\t\tint err;\n\n\t\tswitch (isolate_migratepages(zone, cc)) {\n\t\tcase ISOLATE_ABORT:\n\t\t\tret = COMPACT_CONTENDED;\n\t\t\tputback_movable_pages(&cc->migratepages);\n\t\t\tcc->nr_migratepages = 0;\n\t\t\tgoto out;\n\t\tcase ISOLATE_NONE:\n\t\t\t/*\n\t\t\t * We haven't isolated and migrated anything, but\n\t\t\t * there might still be unflushed migrations from\n\t\t\t * previous cc->order aligned block.\n\t\t\t */\n\t\t\tgoto check_drain;\n\t\tcase ISOLATE_SUCCESS:\n\t\t\t;\n\t\t}\n\n\t\terr = migrate_pages(&cc->migratepages, compaction_alloc,\n\t\t\t\tcompaction_free, (unsigned long)cc, cc->mode,\n\t\t\t\tMR_COMPACTION);\n\n\t\ttrace_mm_compaction_migratepages(cc->nr_migratepages, err,\n\t\t\t\t\t\t\t&cc->migratepages);\n\n\t\t/* All pages were either migrated or will be released */\n\t\tcc->nr_migratepages = 0;\n\t\tif (err) {\n\t\t\tputback_movable_pages(&cc->migratepages);\n\t\t\t/*\n\t\t\t * migrate_pages() may return -ENOMEM when scanners meet\n\t\t\t * and we want compact_finished() to detect it\n\t\t\t */\n\t\t\tif (err == -ENOMEM && !compact_scanners_met(cc)) {\n\t\t\t\tret = COMPACT_CONTENDED;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We failed to migrate at least one page in the current\n\t\t\t * order-aligned block, so skip the rest of it.\n\t\t\t */\n\t\t\tif (cc->direct_compaction &&\n\t\t\t\t\t\t(cc->mode == MIGRATE_ASYNC)) {\n\t\t\t\tcc->migrate_pfn = block_end_pfn(\n\t\t\t\t\t\tcc->migrate_pfn - 1, cc->order);\n\t\t\t\t/* Draining pcplists is useless in this case */\n\t\t\t\tcc->last_migrated_pfn = 0;\n\n\t\t\t}\n\t\t}\n\ncheck_drain:\n\t\t/*\n\t\t * Has the migration scanner moved away from the previous\n\t\t * cc->order aligned block where we migrated from? If yes,\n\t\t * flush the pages that were freed, so that they can merge and\n\t\t * compact_finished() can detect immediately if allocation\n\t\t * would succeed.\n\t\t */\n\t\tif (cc->order > 0 && cc->last_migrated_pfn) {\n\t\t\tint cpu;\n\t\t\tunsigned long current_block_start =\n\t\t\t\tblock_start_pfn(cc->migrate_pfn, cc->order);\n\n\t\t\tif (cc->last_migrated_pfn < current_block_start) {\n\t\t\t\tcpu = get_cpu();\n\t\t\t\tlru_add_drain_cpu(cpu);\n\t\t\t\tdrain_local_pages(zone);\n\t\t\t\tput_cpu();\n\t\t\t\t/* No more flushing until we migrate again */\n\t\t\t\tcc->last_migrated_pfn = 0;\n\t\t\t}\n\t\t}\n\n\t}\n\nout:\n\t/*\n\t * Release free pages and update where the free scanner should restart,\n\t * so we don't leave any returned pages behind in the next attempt.\n\t */\n\tif (cc->nr_freepages > 0) {\n\t\tunsigned long free_pfn = release_freepages(&cc->freepages);\n\n\t\tcc->nr_freepages = 0;\n\t\tVM_BUG_ON(free_pfn == 0);\n\t\t/* The cached pfn is always the first in a pageblock */\n\t\tfree_pfn = pageblock_start_pfn(free_pfn);\n\t\t/*\n\t\t * Only go back, not forward. The cached pfn might have been\n\t\t * already reset to zone end in compact_finished()\n\t\t */\n\t\tif (free_pfn > zone->compact_cached_free_pfn)\n\t\t\tzone->compact_cached_free_pfn = free_pfn;\n\t}\n\n\tcount_compact_events(COMPACTMIGRATE_SCANNED, cc->total_migrate_scanned);\n\tcount_compact_events(COMPACTFREE_SCANNED, cc->total_free_scanned);\n\n\ttrace_mm_compaction_end(start_pfn, cc->migrate_pfn,\n\t\t\t\tcc->free_pfn, end_pfn, sync, ret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "compaction_zonelist_suitable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "1505-1535",
    "snippet": "bool compaction_zonelist_suitable(struct alloc_context *ac, int order,\n\t\tint alloc_flags)\n{\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\n\t/*\n\t * Make sure at least one zone would pass __compaction_suitable if we continue\n\t * retrying the reclaim.\n\t */\n\tfor_each_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\tac->nodemask) {\n\t\tunsigned long available;\n\t\tenum compact_result compact_result;\n\n\t\t/*\n\t\t * Do not consider all the reclaimable memory because we do not\n\t\t * want to trash just for a single high order allocation which\n\t\t * is even not guaranteed to appear even if __compaction_suitable\n\t\t * is happy about the watermark check.\n\t\t */\n\t\tavailable = zone_reclaimable_pages(zone) / order;\n\t\tavailable += zone_page_state_snapshot(zone, NR_FREE_PAGES);\n\t\tcompact_result = __compaction_suitable(zone, order, alloc_flags,\n\t\t\t\tac_classzone_idx(ac), available);\n\t\tif (compact_result != COMPACT_SKIPPED)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__compaction_suitable",
          "args": [
            "zone",
            "order",
            "alloc_flags",
            "ac_classzone_idx(ac)",
            "available"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "__compaction_suitable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1424-1465",
          "snippet": "static enum compact_result __compaction_suitable(struct zone *zone, int order,\n\t\t\t\t\tunsigned int alloc_flags,\n\t\t\t\t\tint classzone_idx,\n\t\t\t\t\tunsigned long wmark_target)\n{\n\tunsigned long watermark;\n\n\tif (is_via_compact_memory(order))\n\t\treturn COMPACT_CONTINUE;\n\n\twatermark = zone->watermark[alloc_flags & ALLOC_WMARK_MASK];\n\t/*\n\t * If watermarks for high-order allocation are already met, there\n\t * should be no need for compaction at all.\n\t */\n\tif (zone_watermark_ok(zone, order, watermark, classzone_idx,\n\t\t\t\t\t\t\t\talloc_flags))\n\t\treturn COMPACT_SUCCESS;\n\n\t/*\n\t * Watermarks for order-0 must be met for compaction to be able to\n\t * isolate free pages for migration targets. This means that the\n\t * watermark and alloc_flags have to match, or be more pessimistic than\n\t * the check in __isolate_free_page(). We don't use the direct\n\t * compactor's alloc_flags, as they are not relevant for freepage\n\t * isolation. We however do use the direct compactor's classzone_idx to\n\t * skip over zones where lowmem reserves would prevent allocation even\n\t * if compaction succeeds.\n\t * For costly orders, we require low watermark instead of min for\n\t * compaction to proceed to increase its chances.\n\t * ALLOC_CMA is used, as pages in CMA pageblocks are considered\n\t * suitable migration targets\n\t */\n\twatermark = (order > PAGE_ALLOC_COSTLY_ORDER) ?\n\t\t\t\tlow_wmark_pages(zone) : min_wmark_pages(zone);\n\twatermark += compact_gap(order);\n\tif (!__zone_watermark_ok(zone, 0, watermark, classzone_idx,\n\t\t\t\t\t\tALLOC_CMA, wmark_target))\n\t\treturn COMPACT_SKIPPED;\n\n\treturn COMPACT_CONTINUE;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic enum compact_result __compaction_suitable(struct zone *zone, int order,\n\t\t\t\t\tunsigned int alloc_flags,\n\t\t\t\t\tint classzone_idx,\n\t\t\t\t\tunsigned long wmark_target)\n{\n\tunsigned long watermark;\n\n\tif (is_via_compact_memory(order))\n\t\treturn COMPACT_CONTINUE;\n\n\twatermark = zone->watermark[alloc_flags & ALLOC_WMARK_MASK];\n\t/*\n\t * If watermarks for high-order allocation are already met, there\n\t * should be no need for compaction at all.\n\t */\n\tif (zone_watermark_ok(zone, order, watermark, classzone_idx,\n\t\t\t\t\t\t\t\talloc_flags))\n\t\treturn COMPACT_SUCCESS;\n\n\t/*\n\t * Watermarks for order-0 must be met for compaction to be able to\n\t * isolate free pages for migration targets. This means that the\n\t * watermark and alloc_flags have to match, or be more pessimistic than\n\t * the check in __isolate_free_page(). We don't use the direct\n\t * compactor's alloc_flags, as they are not relevant for freepage\n\t * isolation. We however do use the direct compactor's classzone_idx to\n\t * skip over zones where lowmem reserves would prevent allocation even\n\t * if compaction succeeds.\n\t * For costly orders, we require low watermark instead of min for\n\t * compaction to proceed to increase its chances.\n\t * ALLOC_CMA is used, as pages in CMA pageblocks are considered\n\t * suitable migration targets\n\t */\n\twatermark = (order > PAGE_ALLOC_COSTLY_ORDER) ?\n\t\t\t\tlow_wmark_pages(zone) : min_wmark_pages(zone);\n\twatermark += compact_gap(order);\n\tif (!__zone_watermark_ok(zone, 0, watermark, classzone_idx,\n\t\t\t\t\t\tALLOC_CMA, wmark_target))\n\t\treturn COMPACT_SKIPPED;\n\n\treturn COMPACT_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ac_classzone_idx",
          "args": [
            "ac"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_page_state_snapshot",
          "args": [
            "zone",
            "NR_FREE_PAGES"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_reclaimable_pages",
          "args": [
            "zone"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "zone_reclaimable_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "320-331",
          "snippet": "unsigned long zone_reclaimable_pages(struct zone *zone)\n{\n\tunsigned long nr;\n\n\tnr = zone_page_state_snapshot(zone, NR_ZONE_INACTIVE_FILE) +\n\t\tzone_page_state_snapshot(zone, NR_ZONE_ACTIVE_FILE);\n\tif (get_nr_swap_pages() > 0)\n\t\tnr += zone_page_state_snapshot(zone, NR_ZONE_INACTIVE_ANON) +\n\t\t\tzone_page_state_snapshot(zone, NR_ZONE_ACTIVE_ANON);\n\n\treturn nr;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long zone_reclaimable_pages(struct zone *zone)\n{\n\tunsigned long nr;\n\n\tnr = zone_page_state_snapshot(zone, NR_ZONE_INACTIVE_FILE) +\n\t\tzone_page_state_snapshot(zone, NR_ZONE_ACTIVE_FILE);\n\tif (get_nr_swap_pages() > 0)\n\t\tnr += zone_page_state_snapshot(zone, NR_ZONE_INACTIVE_ANON) +\n\t\t\tzone_page_state_snapshot(zone, NR_ZONE_ACTIVE_ANON);\n\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_zone_zonelist_nodemask",
          "args": [
            "zone",
            "z",
            "ac->zonelist",
            "ac->high_zoneidx",
            "ac->nodemask"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nbool compaction_zonelist_suitable(struct alloc_context *ac, int order,\n\t\tint alloc_flags)\n{\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\n\t/*\n\t * Make sure at least one zone would pass __compaction_suitable if we continue\n\t * retrying the reclaim.\n\t */\n\tfor_each_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\tac->nodemask) {\n\t\tunsigned long available;\n\t\tenum compact_result compact_result;\n\n\t\t/*\n\t\t * Do not consider all the reclaimable memory because we do not\n\t\t * want to trash just for a single high order allocation which\n\t\t * is even not guaranteed to appear even if __compaction_suitable\n\t\t * is happy about the watermark check.\n\t\t */\n\t\tavailable = zone_reclaimable_pages(zone) / order;\n\t\tavailable += zone_page_state_snapshot(zone, NR_FREE_PAGES);\n\t\tcompact_result = __compaction_suitable(zone, order, alloc_flags,\n\t\t\t\tac_classzone_idx(ac), available);\n\t\tif (compact_result != COMPACT_SKIPPED)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "compaction_suitable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "1467-1503",
    "snippet": "enum compact_result compaction_suitable(struct zone *zone, int order,\n\t\t\t\t\tunsigned int alloc_flags,\n\t\t\t\t\tint classzone_idx)\n{\n\tenum compact_result ret;\n\tint fragindex;\n\n\tret = __compaction_suitable(zone, order, alloc_flags, classzone_idx,\n\t\t\t\t    zone_page_state(zone, NR_FREE_PAGES));\n\t/*\n\t * fragmentation index determines if allocation failures are due to\n\t * low memory or external fragmentation\n\t *\n\t * index of -1000 would imply allocations might succeed depending on\n\t * watermarks, but we already failed the high-order watermark check\n\t * index towards 0 implies failure is due to lack of memory\n\t * index towards 1000 implies failure is due to fragmentation\n\t *\n\t * Only compact if a failure would be due to fragmentation. Also\n\t * ignore fragindex for non-costly orders where the alternative to\n\t * a successful reclaim/compaction is OOM. Fragindex and the\n\t * vm.extfrag_threshold sysctl is meant as a heuristic to prevent\n\t * excessive compaction for costly orders, but it should not be at the\n\t * expense of system stability.\n\t */\n\tif (ret == COMPACT_CONTINUE && (order > PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tfragindex = fragmentation_index(zone, order);\n\t\tif (fragindex >= 0 && fragindex <= sysctl_extfrag_threshold)\n\t\t\tret = COMPACT_NOT_SUITABLE_ZONE;\n\t}\n\n\ttrace_mm_compaction_suitable(zone, order, ret);\n\tif (ret == COMPACT_NOT_SUITABLE_ZONE)\n\t\tret = COMPACT_SKIPPED;\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_mm_compaction_suitable",
          "args": [
            "zone",
            "order",
            "ret"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fragmentation_index",
          "args": [
            "zone",
            "order"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "fragmentation_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "1077-1083",
          "snippet": "int fragmentation_index(struct zone *zone, unsigned int order)\n{\n\tstruct contig_page_info info;\n\n\tfill_contig_page_info(zone, order, &info);\n\treturn __fragmentation_index(order, &info);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nint fragmentation_index(struct zone *zone, unsigned int order)\n{\n\tstruct contig_page_info info;\n\n\tfill_contig_page_info(zone, order, &info);\n\treturn __fragmentation_index(order, &info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__compaction_suitable",
          "args": [
            "zone",
            "order",
            "alloc_flags",
            "classzone_idx",
            "zone_page_state(zone, NR_FREE_PAGES)"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "__compaction_suitable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1424-1465",
          "snippet": "static enum compact_result __compaction_suitable(struct zone *zone, int order,\n\t\t\t\t\tunsigned int alloc_flags,\n\t\t\t\t\tint classzone_idx,\n\t\t\t\t\tunsigned long wmark_target)\n{\n\tunsigned long watermark;\n\n\tif (is_via_compact_memory(order))\n\t\treturn COMPACT_CONTINUE;\n\n\twatermark = zone->watermark[alloc_flags & ALLOC_WMARK_MASK];\n\t/*\n\t * If watermarks for high-order allocation are already met, there\n\t * should be no need for compaction at all.\n\t */\n\tif (zone_watermark_ok(zone, order, watermark, classzone_idx,\n\t\t\t\t\t\t\t\talloc_flags))\n\t\treturn COMPACT_SUCCESS;\n\n\t/*\n\t * Watermarks for order-0 must be met for compaction to be able to\n\t * isolate free pages for migration targets. This means that the\n\t * watermark and alloc_flags have to match, or be more pessimistic than\n\t * the check in __isolate_free_page(). We don't use the direct\n\t * compactor's alloc_flags, as they are not relevant for freepage\n\t * isolation. We however do use the direct compactor's classzone_idx to\n\t * skip over zones where lowmem reserves would prevent allocation even\n\t * if compaction succeeds.\n\t * For costly orders, we require low watermark instead of min for\n\t * compaction to proceed to increase its chances.\n\t * ALLOC_CMA is used, as pages in CMA pageblocks are considered\n\t * suitable migration targets\n\t */\n\twatermark = (order > PAGE_ALLOC_COSTLY_ORDER) ?\n\t\t\t\tlow_wmark_pages(zone) : min_wmark_pages(zone);\n\twatermark += compact_gap(order);\n\tif (!__zone_watermark_ok(zone, 0, watermark, classzone_idx,\n\t\t\t\t\t\tALLOC_CMA, wmark_target))\n\t\treturn COMPACT_SKIPPED;\n\n\treturn COMPACT_CONTINUE;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic enum compact_result __compaction_suitable(struct zone *zone, int order,\n\t\t\t\t\tunsigned int alloc_flags,\n\t\t\t\t\tint classzone_idx,\n\t\t\t\t\tunsigned long wmark_target)\n{\n\tunsigned long watermark;\n\n\tif (is_via_compact_memory(order))\n\t\treturn COMPACT_CONTINUE;\n\n\twatermark = zone->watermark[alloc_flags & ALLOC_WMARK_MASK];\n\t/*\n\t * If watermarks for high-order allocation are already met, there\n\t * should be no need for compaction at all.\n\t */\n\tif (zone_watermark_ok(zone, order, watermark, classzone_idx,\n\t\t\t\t\t\t\t\talloc_flags))\n\t\treturn COMPACT_SUCCESS;\n\n\t/*\n\t * Watermarks for order-0 must be met for compaction to be able to\n\t * isolate free pages for migration targets. This means that the\n\t * watermark and alloc_flags have to match, or be more pessimistic than\n\t * the check in __isolate_free_page(). We don't use the direct\n\t * compactor's alloc_flags, as they are not relevant for freepage\n\t * isolation. We however do use the direct compactor's classzone_idx to\n\t * skip over zones where lowmem reserves would prevent allocation even\n\t * if compaction succeeds.\n\t * For costly orders, we require low watermark instead of min for\n\t * compaction to proceed to increase its chances.\n\t * ALLOC_CMA is used, as pages in CMA pageblocks are considered\n\t * suitable migration targets\n\t */\n\twatermark = (order > PAGE_ALLOC_COSTLY_ORDER) ?\n\t\t\t\tlow_wmark_pages(zone) : min_wmark_pages(zone);\n\twatermark += compact_gap(order);\n\tif (!__zone_watermark_ok(zone, 0, watermark, classzone_idx,\n\t\t\t\t\t\tALLOC_CMA, wmark_target))\n\t\treturn COMPACT_SKIPPED;\n\n\treturn COMPACT_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_page_state",
          "args": [
            "zone",
            "NR_FREE_PAGES"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "dec_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "624-631",
          "snippet": "void dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nenum compact_result compaction_suitable(struct zone *zone, int order,\n\t\t\t\t\tunsigned int alloc_flags,\n\t\t\t\t\tint classzone_idx)\n{\n\tenum compact_result ret;\n\tint fragindex;\n\n\tret = __compaction_suitable(zone, order, alloc_flags, classzone_idx,\n\t\t\t\t    zone_page_state(zone, NR_FREE_PAGES));\n\t/*\n\t * fragmentation index determines if allocation failures are due to\n\t * low memory or external fragmentation\n\t *\n\t * index of -1000 would imply allocations might succeed depending on\n\t * watermarks, but we already failed the high-order watermark check\n\t * index towards 0 implies failure is due to lack of memory\n\t * index towards 1000 implies failure is due to fragmentation\n\t *\n\t * Only compact if a failure would be due to fragmentation. Also\n\t * ignore fragindex for non-costly orders where the alternative to\n\t * a successful reclaim/compaction is OOM. Fragindex and the\n\t * vm.extfrag_threshold sysctl is meant as a heuristic to prevent\n\t * excessive compaction for costly orders, but it should not be at the\n\t * expense of system stability.\n\t */\n\tif (ret == COMPACT_CONTINUE && (order > PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tfragindex = fragmentation_index(zone, order);\n\t\tif (fragindex >= 0 && fragindex <= sysctl_extfrag_threshold)\n\t\t\tret = COMPACT_NOT_SUITABLE_ZONE;\n\t}\n\n\ttrace_mm_compaction_suitable(zone, order, ret);\n\tif (ret == COMPACT_NOT_SUITABLE_ZONE)\n\t\tret = COMPACT_SKIPPED;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__compaction_suitable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "1424-1465",
    "snippet": "static enum compact_result __compaction_suitable(struct zone *zone, int order,\n\t\t\t\t\tunsigned int alloc_flags,\n\t\t\t\t\tint classzone_idx,\n\t\t\t\t\tunsigned long wmark_target)\n{\n\tunsigned long watermark;\n\n\tif (is_via_compact_memory(order))\n\t\treturn COMPACT_CONTINUE;\n\n\twatermark = zone->watermark[alloc_flags & ALLOC_WMARK_MASK];\n\t/*\n\t * If watermarks for high-order allocation are already met, there\n\t * should be no need for compaction at all.\n\t */\n\tif (zone_watermark_ok(zone, order, watermark, classzone_idx,\n\t\t\t\t\t\t\t\talloc_flags))\n\t\treturn COMPACT_SUCCESS;\n\n\t/*\n\t * Watermarks for order-0 must be met for compaction to be able to\n\t * isolate free pages for migration targets. This means that the\n\t * watermark and alloc_flags have to match, or be more pessimistic than\n\t * the check in __isolate_free_page(). We don't use the direct\n\t * compactor's alloc_flags, as they are not relevant for freepage\n\t * isolation. We however do use the direct compactor's classzone_idx to\n\t * skip over zones where lowmem reserves would prevent allocation even\n\t * if compaction succeeds.\n\t * For costly orders, we require low watermark instead of min for\n\t * compaction to proceed to increase its chances.\n\t * ALLOC_CMA is used, as pages in CMA pageblocks are considered\n\t * suitable migration targets\n\t */\n\twatermark = (order > PAGE_ALLOC_COSTLY_ORDER) ?\n\t\t\t\tlow_wmark_pages(zone) : min_wmark_pages(zone);\n\twatermark += compact_gap(order);\n\tif (!__zone_watermark_ok(zone, 0, watermark, classzone_idx,\n\t\t\t\t\t\tALLOC_CMA, wmark_target))\n\t\treturn COMPACT_SKIPPED;\n\n\treturn COMPACT_CONTINUE;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__zone_watermark_ok",
          "args": [
            "zone",
            "0",
            "watermark",
            "classzone_idx",
            "ALLOC_CMA",
            "wmark_target"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "__zone_watermark_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3119-3196",
          "snippet": "bool __zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t\t int classzone_idx, unsigned int alloc_flags,\n\t\t\t long free_pages)\n{\n\tlong min = mark;\n\tint o;\n\tconst bool alloc_harder = (alloc_flags & (ALLOC_HARDER|ALLOC_OOM));\n\n\t/* free_pages may go negative - that's OK */\n\tfree_pages -= (1 << order) - 1;\n\n\tif (alloc_flags & ALLOC_HIGH)\n\t\tmin -= min / 2;\n\n\t/*\n\t * If the caller does not have rights to ALLOC_HARDER then subtract\n\t * the high-atomic reserves. This will over-estimate the size of the\n\t * atomic reserve but it avoids a search.\n\t */\n\tif (likely(!alloc_harder)) {\n\t\tfree_pages -= z->nr_reserved_highatomic;\n\t} else {\n\t\t/*\n\t\t * OOM victims can try even harder than normal ALLOC_HARDER\n\t\t * users on the grounds that it's definitely going to be in\n\t\t * the exit path shortly and free memory. Any allocation it\n\t\t * makes during the free path will be small and short-lived.\n\t\t */\n\t\tif (alloc_flags & ALLOC_OOM)\n\t\t\tmin -= min / 2;\n\t\telse\n\t\t\tmin -= min / 4;\n\t}\n\n\n#ifdef CONFIG_CMA\n\t/* If allocation can't use CMA areas don't use free CMA pages */\n\tif (!(alloc_flags & ALLOC_CMA))\n\t\tfree_pages -= zone_page_state(z, NR_FREE_CMA_PAGES);\n#endif\n\n\t/*\n\t * Check watermarks for an order-0 allocation request. If these\n\t * are not met, then a high-order request also cannot go ahead\n\t * even if a suitable page happened to be free.\n\t */\n\tif (free_pages <= min + z->lowmem_reserve[classzone_idx])\n\t\treturn false;\n\n\t/* If this is an order-0 request then the watermark is fine */\n\tif (!order)\n\t\treturn true;\n\n\t/* For a high-order request, check at least one suitable page is free */\n\tfor (o = order; o < MAX_ORDER; o++) {\n\t\tstruct free_area *area = &z->free_area[o];\n\t\tint mt;\n\n\t\tif (!area->nr_free)\n\t\t\tcontinue;\n\n\t\tfor (mt = 0; mt < MIGRATE_PCPTYPES; mt++) {\n\t\t\tif (!list_empty(&area->free_list[mt]))\n\t\t\t\treturn true;\n\t\t}\n\n#ifdef CONFIG_CMA\n\t\tif ((alloc_flags & ALLOC_CMA) &&\n\t\t    !list_empty(&area->free_list[MIGRATE_CMA])) {\n\t\t\treturn true;\n\t\t}\n#endif\n\t\tif (alloc_harder &&\n\t\t\t!list_empty(&area->free_list[MIGRATE_HIGHATOMIC]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nbool __zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t\t int classzone_idx, unsigned int alloc_flags,\n\t\t\t long free_pages)\n{\n\tlong min = mark;\n\tint o;\n\tconst bool alloc_harder = (alloc_flags & (ALLOC_HARDER|ALLOC_OOM));\n\n\t/* free_pages may go negative - that's OK */\n\tfree_pages -= (1 << order) - 1;\n\n\tif (alloc_flags & ALLOC_HIGH)\n\t\tmin -= min / 2;\n\n\t/*\n\t * If the caller does not have rights to ALLOC_HARDER then subtract\n\t * the high-atomic reserves. This will over-estimate the size of the\n\t * atomic reserve but it avoids a search.\n\t */\n\tif (likely(!alloc_harder)) {\n\t\tfree_pages -= z->nr_reserved_highatomic;\n\t} else {\n\t\t/*\n\t\t * OOM victims can try even harder than normal ALLOC_HARDER\n\t\t * users on the grounds that it's definitely going to be in\n\t\t * the exit path shortly and free memory. Any allocation it\n\t\t * makes during the free path will be small and short-lived.\n\t\t */\n\t\tif (alloc_flags & ALLOC_OOM)\n\t\t\tmin -= min / 2;\n\t\telse\n\t\t\tmin -= min / 4;\n\t}\n\n\n#ifdef CONFIG_CMA\n\t/* If allocation can't use CMA areas don't use free CMA pages */\n\tif (!(alloc_flags & ALLOC_CMA))\n\t\tfree_pages -= zone_page_state(z, NR_FREE_CMA_PAGES);\n#endif\n\n\t/*\n\t * Check watermarks for an order-0 allocation request. If these\n\t * are not met, then a high-order request also cannot go ahead\n\t * even if a suitable page happened to be free.\n\t */\n\tif (free_pages <= min + z->lowmem_reserve[classzone_idx])\n\t\treturn false;\n\n\t/* If this is an order-0 request then the watermark is fine */\n\tif (!order)\n\t\treturn true;\n\n\t/* For a high-order request, check at least one suitable page is free */\n\tfor (o = order; o < MAX_ORDER; o++) {\n\t\tstruct free_area *area = &z->free_area[o];\n\t\tint mt;\n\n\t\tif (!area->nr_free)\n\t\t\tcontinue;\n\n\t\tfor (mt = 0; mt < MIGRATE_PCPTYPES; mt++) {\n\t\t\tif (!list_empty(&area->free_list[mt]))\n\t\t\t\treturn true;\n\t\t}\n\n#ifdef CONFIG_CMA\n\t\tif ((alloc_flags & ALLOC_CMA) &&\n\t\t    !list_empty(&area->free_list[MIGRATE_CMA])) {\n\t\t\treturn true;\n\t\t}\n#endif\n\t\tif (alloc_harder &&\n\t\t\t!list_empty(&area->free_list[MIGRATE_HIGHATOMIC]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact_gap",
          "args": [
            "order"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_wmark_pages",
          "args": [
            "zone"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "low_wmark_pages",
          "args": [
            "zone"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_watermark_ok",
          "args": [
            "zone",
            "order",
            "watermark",
            "classzone_idx",
            "alloc_flags"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "zone_watermark_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3198-3203",
          "snippet": "bool zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t      int classzone_idx, unsigned int alloc_flags)\n{\n\treturn __zone_watermark_ok(z, order, mark, classzone_idx, alloc_flags,\n\t\t\t\t\tzone_page_state(z, NR_FREE_PAGES));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nbool zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t      int classzone_idx, unsigned int alloc_flags)\n{\n\treturn __zone_watermark_ok(z, order, mark, classzone_idx, alloc_flags,\n\t\t\t\t\tzone_page_state(z, NR_FREE_PAGES));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_via_compact_memory",
          "args": [
            "order"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "is_via_compact_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1308-1311",
          "snippet": "static inline bool is_via_compact_memory(int order)\n{\n\treturn order == -1;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline bool is_via_compact_memory(int order)\n{\n\treturn order == -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic enum compact_result __compaction_suitable(struct zone *zone, int order,\n\t\t\t\t\tunsigned int alloc_flags,\n\t\t\t\t\tint classzone_idx,\n\t\t\t\t\tunsigned long wmark_target)\n{\n\tunsigned long watermark;\n\n\tif (is_via_compact_memory(order))\n\t\treturn COMPACT_CONTINUE;\n\n\twatermark = zone->watermark[alloc_flags & ALLOC_WMARK_MASK];\n\t/*\n\t * If watermarks for high-order allocation are already met, there\n\t * should be no need for compaction at all.\n\t */\n\tif (zone_watermark_ok(zone, order, watermark, classzone_idx,\n\t\t\t\t\t\t\t\talloc_flags))\n\t\treturn COMPACT_SUCCESS;\n\n\t/*\n\t * Watermarks for order-0 must be met for compaction to be able to\n\t * isolate free pages for migration targets. This means that the\n\t * watermark and alloc_flags have to match, or be more pessimistic than\n\t * the check in __isolate_free_page(). We don't use the direct\n\t * compactor's alloc_flags, as they are not relevant for freepage\n\t * isolation. We however do use the direct compactor's classzone_idx to\n\t * skip over zones where lowmem reserves would prevent allocation even\n\t * if compaction succeeds.\n\t * For costly orders, we require low watermark instead of min for\n\t * compaction to proceed to increase its chances.\n\t * ALLOC_CMA is used, as pages in CMA pageblocks are considered\n\t * suitable migration targets\n\t */\n\twatermark = (order > PAGE_ALLOC_COSTLY_ORDER) ?\n\t\t\t\tlow_wmark_pages(zone) : min_wmark_pages(zone);\n\twatermark += compact_gap(order);\n\tif (!__zone_watermark_ok(zone, 0, watermark, classzone_idx,\n\t\t\t\t\t\tALLOC_CMA, wmark_target))\n\t\treturn COMPACT_SKIPPED;\n\n\treturn COMPACT_CONTINUE;\n}"
  },
  {
    "function_name": "compact_finished",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "1404-1415",
    "snippet": "static enum compact_result compact_finished(struct zone *zone,\n\t\t\tstruct compact_control *cc)\n{\n\tint ret;\n\n\tret = __compact_finished(zone, cc);\n\ttrace_mm_compaction_finished(zone, cc->order, ret);\n\tif (ret == COMPACT_NO_SUITABLE_PAGE)\n\t\tret = COMPACT_CONTINUE;\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_mm_compaction_finished",
          "args": [
            "zone",
            "cc->order",
            "ret"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__compact_finished",
          "args": [
            "zone",
            "cc"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "__compact_finished",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1313-1402",
          "snippet": "static enum compact_result __compact_finished(struct zone *zone,\n\t\t\t\t\t\tstruct compact_control *cc)\n{\n\tunsigned int order;\n\tconst int migratetype = cc->migratetype;\n\n\tif (cc->contended || fatal_signal_pending(current))\n\t\treturn COMPACT_CONTENDED;\n\n\t/* Compaction run completes if the migrate and free scanner meet */\n\tif (compact_scanners_met(cc)) {\n\t\t/* Let the next compaction start anew. */\n\t\treset_cached_positions(zone);\n\n\t\t/*\n\t\t * Mark that the PG_migrate_skip information should be cleared\n\t\t * by kswapd when it goes to sleep. kcompactd does not set the\n\t\t * flag itself as the decision to be clear should be directly\n\t\t * based on an allocation request.\n\t\t */\n\t\tif (cc->direct_compaction)\n\t\t\tzone->compact_blockskip_flush = true;\n\n\t\tif (cc->whole_zone)\n\t\t\treturn COMPACT_COMPLETE;\n\t\telse\n\t\t\treturn COMPACT_PARTIAL_SKIPPED;\n\t}\n\n\tif (is_via_compact_memory(cc->order))\n\t\treturn COMPACT_CONTINUE;\n\n\tif (cc->finishing_block) {\n\t\t/*\n\t\t * We have finished the pageblock, but better check again that\n\t\t * we really succeeded.\n\t\t */\n\t\tif (IS_ALIGNED(cc->migrate_pfn, pageblock_nr_pages))\n\t\t\tcc->finishing_block = false;\n\t\telse\n\t\t\treturn COMPACT_CONTINUE;\n\t}\n\n\t/* Direct compactor: Is a suitable page free? */\n\tfor (order = cc->order; order < MAX_ORDER; order++) {\n\t\tstruct free_area *area = &zone->free_area[order];\n\t\tbool can_steal;\n\n\t\t/* Job done if page is free of the right migratetype */\n\t\tif (!list_empty(&area->free_list[migratetype]))\n\t\t\treturn COMPACT_SUCCESS;\n\n#ifdef CONFIG_CMA\n\t\t/* MIGRATE_MOVABLE can fallback on MIGRATE_CMA */\n\t\tif (migratetype == MIGRATE_MOVABLE &&\n\t\t\t!list_empty(&area->free_list[MIGRATE_CMA]))\n\t\t\treturn COMPACT_SUCCESS;\n#endif\n\t\t/*\n\t\t * Job done if allocation would steal freepages from\n\t\t * other migratetype buddy lists.\n\t\t */\n\t\tif (find_suitable_fallback(area, order, migratetype,\n\t\t\t\t\t\ttrue, &can_steal) != -1) {\n\n\t\t\t/* movable pages are OK in any pageblock */\n\t\t\tif (migratetype == MIGRATE_MOVABLE)\n\t\t\t\treturn COMPACT_SUCCESS;\n\n\t\t\t/*\n\t\t\t * We are stealing for a non-movable allocation. Make\n\t\t\t * sure we finish compacting the current pageblock\n\t\t\t * first so it is as free as possible and we won't\n\t\t\t * have to steal another one soon. This only applies\n\t\t\t * to sync compaction, as async compaction operates\n\t\t\t * on pageblocks of the same migratetype.\n\t\t\t */\n\t\t\tif (cc->mode == MIGRATE_ASYNC ||\n\t\t\t\t\tIS_ALIGNED(cc->migrate_pfn,\n\t\t\t\t\t\t\tpageblock_nr_pages)) {\n\t\t\t\treturn COMPACT_SUCCESS;\n\t\t\t}\n\n\t\t\tcc->finishing_block = true;\n\t\t\treturn COMPACT_CONTINUE;\n\t\t}\n\t}\n\n\treturn COMPACT_NO_SUITABLE_PAGE;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic enum compact_result __compact_finished(struct zone *zone,\n\t\t\t\t\t\tstruct compact_control *cc)\n{\n\tunsigned int order;\n\tconst int migratetype = cc->migratetype;\n\n\tif (cc->contended || fatal_signal_pending(current))\n\t\treturn COMPACT_CONTENDED;\n\n\t/* Compaction run completes if the migrate and free scanner meet */\n\tif (compact_scanners_met(cc)) {\n\t\t/* Let the next compaction start anew. */\n\t\treset_cached_positions(zone);\n\n\t\t/*\n\t\t * Mark that the PG_migrate_skip information should be cleared\n\t\t * by kswapd when it goes to sleep. kcompactd does not set the\n\t\t * flag itself as the decision to be clear should be directly\n\t\t * based on an allocation request.\n\t\t */\n\t\tif (cc->direct_compaction)\n\t\t\tzone->compact_blockskip_flush = true;\n\n\t\tif (cc->whole_zone)\n\t\t\treturn COMPACT_COMPLETE;\n\t\telse\n\t\t\treturn COMPACT_PARTIAL_SKIPPED;\n\t}\n\n\tif (is_via_compact_memory(cc->order))\n\t\treturn COMPACT_CONTINUE;\n\n\tif (cc->finishing_block) {\n\t\t/*\n\t\t * We have finished the pageblock, but better check again that\n\t\t * we really succeeded.\n\t\t */\n\t\tif (IS_ALIGNED(cc->migrate_pfn, pageblock_nr_pages))\n\t\t\tcc->finishing_block = false;\n\t\telse\n\t\t\treturn COMPACT_CONTINUE;\n\t}\n\n\t/* Direct compactor: Is a suitable page free? */\n\tfor (order = cc->order; order < MAX_ORDER; order++) {\n\t\tstruct free_area *area = &zone->free_area[order];\n\t\tbool can_steal;\n\n\t\t/* Job done if page is free of the right migratetype */\n\t\tif (!list_empty(&area->free_list[migratetype]))\n\t\t\treturn COMPACT_SUCCESS;\n\n#ifdef CONFIG_CMA\n\t\t/* MIGRATE_MOVABLE can fallback on MIGRATE_CMA */\n\t\tif (migratetype == MIGRATE_MOVABLE &&\n\t\t\t!list_empty(&area->free_list[MIGRATE_CMA]))\n\t\t\treturn COMPACT_SUCCESS;\n#endif\n\t\t/*\n\t\t * Job done if allocation would steal freepages from\n\t\t * other migratetype buddy lists.\n\t\t */\n\t\tif (find_suitable_fallback(area, order, migratetype,\n\t\t\t\t\t\ttrue, &can_steal) != -1) {\n\n\t\t\t/* movable pages are OK in any pageblock */\n\t\t\tif (migratetype == MIGRATE_MOVABLE)\n\t\t\t\treturn COMPACT_SUCCESS;\n\n\t\t\t/*\n\t\t\t * We are stealing for a non-movable allocation. Make\n\t\t\t * sure we finish compacting the current pageblock\n\t\t\t * first so it is as free as possible and we won't\n\t\t\t * have to steal another one soon. This only applies\n\t\t\t * to sync compaction, as async compaction operates\n\t\t\t * on pageblocks of the same migratetype.\n\t\t\t */\n\t\t\tif (cc->mode == MIGRATE_ASYNC ||\n\t\t\t\t\tIS_ALIGNED(cc->migrate_pfn,\n\t\t\t\t\t\t\tpageblock_nr_pages)) {\n\t\t\t\treturn COMPACT_SUCCESS;\n\t\t\t}\n\n\t\t\tcc->finishing_block = true;\n\t\t\treturn COMPACT_CONTINUE;\n\t\t}\n\t}\n\n\treturn COMPACT_NO_SUITABLE_PAGE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic enum compact_result compact_finished(struct zone *zone,\n\t\t\tstruct compact_control *cc)\n{\n\tint ret;\n\n\tret = __compact_finished(zone, cc);\n\ttrace_mm_compaction_finished(zone, cc->order, ret);\n\tif (ret == COMPACT_NO_SUITABLE_PAGE)\n\t\tret = COMPACT_CONTINUE;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__compact_finished",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "1313-1402",
    "snippet": "static enum compact_result __compact_finished(struct zone *zone,\n\t\t\t\t\t\tstruct compact_control *cc)\n{\n\tunsigned int order;\n\tconst int migratetype = cc->migratetype;\n\n\tif (cc->contended || fatal_signal_pending(current))\n\t\treturn COMPACT_CONTENDED;\n\n\t/* Compaction run completes if the migrate and free scanner meet */\n\tif (compact_scanners_met(cc)) {\n\t\t/* Let the next compaction start anew. */\n\t\treset_cached_positions(zone);\n\n\t\t/*\n\t\t * Mark that the PG_migrate_skip information should be cleared\n\t\t * by kswapd when it goes to sleep. kcompactd does not set the\n\t\t * flag itself as the decision to be clear should be directly\n\t\t * based on an allocation request.\n\t\t */\n\t\tif (cc->direct_compaction)\n\t\t\tzone->compact_blockskip_flush = true;\n\n\t\tif (cc->whole_zone)\n\t\t\treturn COMPACT_COMPLETE;\n\t\telse\n\t\t\treturn COMPACT_PARTIAL_SKIPPED;\n\t}\n\n\tif (is_via_compact_memory(cc->order))\n\t\treturn COMPACT_CONTINUE;\n\n\tif (cc->finishing_block) {\n\t\t/*\n\t\t * We have finished the pageblock, but better check again that\n\t\t * we really succeeded.\n\t\t */\n\t\tif (IS_ALIGNED(cc->migrate_pfn, pageblock_nr_pages))\n\t\t\tcc->finishing_block = false;\n\t\telse\n\t\t\treturn COMPACT_CONTINUE;\n\t}\n\n\t/* Direct compactor: Is a suitable page free? */\n\tfor (order = cc->order; order < MAX_ORDER; order++) {\n\t\tstruct free_area *area = &zone->free_area[order];\n\t\tbool can_steal;\n\n\t\t/* Job done if page is free of the right migratetype */\n\t\tif (!list_empty(&area->free_list[migratetype]))\n\t\t\treturn COMPACT_SUCCESS;\n\n#ifdef CONFIG_CMA\n\t\t/* MIGRATE_MOVABLE can fallback on MIGRATE_CMA */\n\t\tif (migratetype == MIGRATE_MOVABLE &&\n\t\t\t!list_empty(&area->free_list[MIGRATE_CMA]))\n\t\t\treturn COMPACT_SUCCESS;\n#endif\n\t\t/*\n\t\t * Job done if allocation would steal freepages from\n\t\t * other migratetype buddy lists.\n\t\t */\n\t\tif (find_suitable_fallback(area, order, migratetype,\n\t\t\t\t\t\ttrue, &can_steal) != -1) {\n\n\t\t\t/* movable pages are OK in any pageblock */\n\t\t\tif (migratetype == MIGRATE_MOVABLE)\n\t\t\t\treturn COMPACT_SUCCESS;\n\n\t\t\t/*\n\t\t\t * We are stealing for a non-movable allocation. Make\n\t\t\t * sure we finish compacting the current pageblock\n\t\t\t * first so it is as free as possible and we won't\n\t\t\t * have to steal another one soon. This only applies\n\t\t\t * to sync compaction, as async compaction operates\n\t\t\t * on pageblocks of the same migratetype.\n\t\t\t */\n\t\t\tif (cc->mode == MIGRATE_ASYNC ||\n\t\t\t\t\tIS_ALIGNED(cc->migrate_pfn,\n\t\t\t\t\t\t\tpageblock_nr_pages)) {\n\t\t\t\treturn COMPACT_SUCCESS;\n\t\t\t}\n\n\t\t\tcc->finishing_block = true;\n\t\t\treturn COMPACT_CONTINUE;\n\t\t}\n\t}\n\n\treturn COMPACT_NO_SUITABLE_PAGE;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "cc->migrate_pfn",
            "pageblock_nr_pages"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_suitable_fallback",
          "args": [
            "area",
            "order",
            "migratetype",
            "true",
            "&can_steal"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "find_suitable_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2216-2245",
          "snippet": "int find_suitable_fallback(struct free_area *area, unsigned int order,\n\t\t\tint migratetype, bool only_stealable, bool *can_steal)\n{\n\tint i;\n\tint fallback_mt;\n\n\tif (area->nr_free == 0)\n\t\treturn -1;\n\n\t*can_steal = false;\n\tfor (i = 0;; i++) {\n\t\tfallback_mt = fallbacks[migratetype][i];\n\t\tif (fallback_mt == MIGRATE_TYPES)\n\t\t\tbreak;\n\n\t\tif (list_empty(&area->free_list[fallback_mt]))\n\t\t\tcontinue;\n\n\t\tif (can_steal_fallback(order, migratetype))\n\t\t\t*can_steal = true;\n\n\t\tif (!only_stealable)\n\t\t\treturn fallback_mt;\n\n\t\tif (*can_steal)\n\t\t\treturn fallback_mt;\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static int fallbacks[MIGRATE_TYPES][4] = {\n\t[MIGRATE_UNMOVABLE]   = { MIGRATE_RECLAIMABLE, MIGRATE_MOVABLE,   MIGRATE_TYPES },\n\t[MIGRATE_RECLAIMABLE] = { MIGRATE_UNMOVABLE,   MIGRATE_MOVABLE,   MIGRATE_TYPES },\n\t[MIGRATE_MOVABLE]     = { MIGRATE_RECLAIMABLE, MIGRATE_UNMOVABLE, MIGRATE_TYPES },\n#ifdef CONFIG_CMA\n\t[MIGRATE_CMA]         = { MIGRATE_TYPES }, /* Never used */\n#endif\n#ifdef CONFIG_MEMORY_ISOLATION\n\t[MIGRATE_ISOLATE]     = { MIGRATE_TYPES }, /* Never used */\n#endif\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic int fallbacks[MIGRATE_TYPES][4] = {\n\t[MIGRATE_UNMOVABLE]   = { MIGRATE_RECLAIMABLE, MIGRATE_MOVABLE,   MIGRATE_TYPES },\n\t[MIGRATE_RECLAIMABLE] = { MIGRATE_UNMOVABLE,   MIGRATE_MOVABLE,   MIGRATE_TYPES },\n\t[MIGRATE_MOVABLE]     = { MIGRATE_RECLAIMABLE, MIGRATE_UNMOVABLE, MIGRATE_TYPES },\n#ifdef CONFIG_CMA\n\t[MIGRATE_CMA]         = { MIGRATE_TYPES }, /* Never used */\n#endif\n#ifdef CONFIG_MEMORY_ISOLATION\n\t[MIGRATE_ISOLATE]     = { MIGRATE_TYPES }, /* Never used */\n#endif\n};\nstatic __always_inline struct;\n\nint find_suitable_fallback(struct free_area *area, unsigned int order,\n\t\t\tint migratetype, bool only_stealable, bool *can_steal)\n{\n\tint i;\n\tint fallback_mt;\n\n\tif (area->nr_free == 0)\n\t\treturn -1;\n\n\t*can_steal = false;\n\tfor (i = 0;; i++) {\n\t\tfallback_mt = fallbacks[migratetype][i];\n\t\tif (fallback_mt == MIGRATE_TYPES)\n\t\t\tbreak;\n\n\t\tif (list_empty(&area->free_list[fallback_mt]))\n\t\t\tcontinue;\n\n\t\tif (can_steal_fallback(order, migratetype))\n\t\t\t*can_steal = true;\n\n\t\tif (!only_stealable)\n\t\t\treturn fallback_mt;\n\n\t\tif (*can_steal)\n\t\t\treturn fallback_mt;\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&area->free_list[MIGRATE_CMA]"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "cc->migrate_pfn",
            "pageblock_nr_pages"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_via_compact_memory",
          "args": [
            "cc->order"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "is_via_compact_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1308-1311",
          "snippet": "static inline bool is_via_compact_memory(int order)\n{\n\treturn order == -1;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline bool is_via_compact_memory(int order)\n{\n\treturn order == -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_cached_positions",
          "args": [
            "zone"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "reset_cached_positions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "214-220",
          "snippet": "static void reset_cached_positions(struct zone *zone)\n{\n\tzone->compact_cached_migrate_pfn[0] = zone->zone_start_pfn;\n\tzone->compact_cached_migrate_pfn[1] = zone->zone_start_pfn;\n\tzone->compact_cached_free_pfn =\n\t\t\t\tpageblock_start_pfn(zone_end_pfn(zone) - 1);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic void reset_cached_positions(struct zone *zone)\n{\n\tzone->compact_cached_migrate_pfn[0] = zone->zone_start_pfn;\n\tzone->compact_cached_migrate_pfn[1] = zone->zone_start_pfn;\n\tzone->compact_cached_free_pfn =\n\t\t\t\tpageblock_start_pfn(zone_end_pfn(zone) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact_scanners_met",
          "args": [
            "cc"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "compact_scanners_met",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1057-1061",
          "snippet": "static inline bool compact_scanners_met(struct compact_control *cc)\n{\n\treturn (cc->free_pfn >> pageblock_order)\n\t\t<= (cc->migrate_pfn >> pageblock_order);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline bool compact_scanners_met(struct compact_control *cc)\n{\n\treturn (cc->free_pfn >> pageblock_order)\n\t\t<= (cc->migrate_pfn >> pageblock_order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic enum compact_result __compact_finished(struct zone *zone,\n\t\t\t\t\t\tstruct compact_control *cc)\n{\n\tunsigned int order;\n\tconst int migratetype = cc->migratetype;\n\n\tif (cc->contended || fatal_signal_pending(current))\n\t\treturn COMPACT_CONTENDED;\n\n\t/* Compaction run completes if the migrate and free scanner meet */\n\tif (compact_scanners_met(cc)) {\n\t\t/* Let the next compaction start anew. */\n\t\treset_cached_positions(zone);\n\n\t\t/*\n\t\t * Mark that the PG_migrate_skip information should be cleared\n\t\t * by kswapd when it goes to sleep. kcompactd does not set the\n\t\t * flag itself as the decision to be clear should be directly\n\t\t * based on an allocation request.\n\t\t */\n\t\tif (cc->direct_compaction)\n\t\t\tzone->compact_blockskip_flush = true;\n\n\t\tif (cc->whole_zone)\n\t\t\treturn COMPACT_COMPLETE;\n\t\telse\n\t\t\treturn COMPACT_PARTIAL_SKIPPED;\n\t}\n\n\tif (is_via_compact_memory(cc->order))\n\t\treturn COMPACT_CONTINUE;\n\n\tif (cc->finishing_block) {\n\t\t/*\n\t\t * We have finished the pageblock, but better check again that\n\t\t * we really succeeded.\n\t\t */\n\t\tif (IS_ALIGNED(cc->migrate_pfn, pageblock_nr_pages))\n\t\t\tcc->finishing_block = false;\n\t\telse\n\t\t\treturn COMPACT_CONTINUE;\n\t}\n\n\t/* Direct compactor: Is a suitable page free? */\n\tfor (order = cc->order; order < MAX_ORDER; order++) {\n\t\tstruct free_area *area = &zone->free_area[order];\n\t\tbool can_steal;\n\n\t\t/* Job done if page is free of the right migratetype */\n\t\tif (!list_empty(&area->free_list[migratetype]))\n\t\t\treturn COMPACT_SUCCESS;\n\n#ifdef CONFIG_CMA\n\t\t/* MIGRATE_MOVABLE can fallback on MIGRATE_CMA */\n\t\tif (migratetype == MIGRATE_MOVABLE &&\n\t\t\t!list_empty(&area->free_list[MIGRATE_CMA]))\n\t\t\treturn COMPACT_SUCCESS;\n#endif\n\t\t/*\n\t\t * Job done if allocation would steal freepages from\n\t\t * other migratetype buddy lists.\n\t\t */\n\t\tif (find_suitable_fallback(area, order, migratetype,\n\t\t\t\t\t\ttrue, &can_steal) != -1) {\n\n\t\t\t/* movable pages are OK in any pageblock */\n\t\t\tif (migratetype == MIGRATE_MOVABLE)\n\t\t\t\treturn COMPACT_SUCCESS;\n\n\t\t\t/*\n\t\t\t * We are stealing for a non-movable allocation. Make\n\t\t\t * sure we finish compacting the current pageblock\n\t\t\t * first so it is as free as possible and we won't\n\t\t\t * have to steal another one soon. This only applies\n\t\t\t * to sync compaction, as async compaction operates\n\t\t\t * on pageblocks of the same migratetype.\n\t\t\t */\n\t\t\tif (cc->mode == MIGRATE_ASYNC ||\n\t\t\t\t\tIS_ALIGNED(cc->migrate_pfn,\n\t\t\t\t\t\t\tpageblock_nr_pages)) {\n\t\t\t\treturn COMPACT_SUCCESS;\n\t\t\t}\n\n\t\t\tcc->finishing_block = true;\n\t\t\treturn COMPACT_CONTINUE;\n\t\t}\n\t}\n\n\treturn COMPACT_NO_SUITABLE_PAGE;\n}"
  },
  {
    "function_name": "is_via_compact_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "1308-1311",
    "snippet": "static inline bool is_via_compact_memory(int order)\n{\n\treturn order == -1;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline bool is_via_compact_memory(int order)\n{\n\treturn order == -1;\n}"
  },
  {
    "function_name": "isolate_migratepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "1225-1302",
    "snippet": "static isolate_migrate_t isolate_migratepages(struct zone *zone,\n\t\t\t\t\tstruct compact_control *cc)\n{\n\tunsigned long block_start_pfn;\n\tunsigned long block_end_pfn;\n\tunsigned long low_pfn;\n\tstruct page *page;\n\tconst isolate_mode_t isolate_mode =\n\t\t(sysctl_compact_unevictable_allowed ? ISOLATE_UNEVICTABLE : 0) |\n\t\t(cc->mode != MIGRATE_SYNC ? ISOLATE_ASYNC_MIGRATE : 0);\n\n\t/*\n\t * Start at where we last stopped, or beginning of the zone as\n\t * initialized by compact_zone()\n\t */\n\tlow_pfn = cc->migrate_pfn;\n\tblock_start_pfn = pageblock_start_pfn(low_pfn);\n\tif (block_start_pfn < zone->zone_start_pfn)\n\t\tblock_start_pfn = zone->zone_start_pfn;\n\n\t/* Only scan within a pageblock boundary */\n\tblock_end_pfn = pageblock_end_pfn(low_pfn);\n\n\t/*\n\t * Iterate over whole pageblocks until we find the first suitable.\n\t * Do not cross the free scanner.\n\t */\n\tfor (; block_end_pfn <= cc->free_pfn;\n\t\t\tlow_pfn = block_end_pfn,\n\t\t\tblock_start_pfn = block_end_pfn,\n\t\t\tblock_end_pfn += pageblock_nr_pages) {\n\n\t\t/*\n\t\t * This can potentially iterate a massively long zone with\n\t\t * many pageblocks unsuitable, so periodically check if we\n\t\t * need to schedule, or even abort async compaction.\n\t\t */\n\t\tif (!(low_pfn % (SWAP_CLUSTER_MAX * pageblock_nr_pages))\n\t\t\t\t\t\t&& compact_should_abort(cc))\n\t\t\tbreak;\n\n\t\tpage = pageblock_pfn_to_page(block_start_pfn, block_end_pfn,\n\t\t\t\t\t\t\t\t\tzone);\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\t/* If isolation recently failed, do not retry */\n\t\tif (!isolation_suitable(cc, page))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * For async compaction, also only scan in MOVABLE blocks.\n\t\t * Async compaction is optimistic to see if the minimum amount\n\t\t * of work satisfies the allocation.\n\t\t */\n\t\tif (!suitable_migration_source(cc, page))\n\t\t\tcontinue;\n\n\t\t/* Perform the isolation */\n\t\tlow_pfn = isolate_migratepages_block(cc, low_pfn,\n\t\t\t\t\t\tblock_end_pfn, isolate_mode);\n\n\t\tif (!low_pfn || cc->contended)\n\t\t\treturn ISOLATE_ABORT;\n\n\t\t/*\n\t\t * Either we isolated something and proceed with migration. Or\n\t\t * we failed and compact_zone should decide if we should\n\t\t * continue or not.\n\t\t */\n\t\tbreak;\n\t}\n\n\t/* Record where migration scanner will be restarted. */\n\tcc->migrate_pfn = low_pfn;\n\n\treturn cc->nr_migratepages ? ISOLATE_SUCCESS : ISOLATE_NONE;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isolate_migratepages_block",
          "args": [
            "cc",
            "low_pfn",
            "block_end_pfn",
            "isolate_mode"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_migratepages_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "692-960",
          "snippet": "static unsigned long\nisolate_migratepages_block(struct compact_control *cc, unsigned long low_pfn,\n\t\t\tunsigned long end_pfn, isolate_mode_t isolate_mode)\n{\n\tstruct zone *zone = cc->zone;\n\tunsigned long nr_scanned = 0, nr_isolated = 0;\n\tstruct lruvec *lruvec;\n\tunsigned long flags = 0;\n\tbool locked = false;\n\tstruct page *page = NULL, *valid_page = NULL;\n\tunsigned long start_pfn = low_pfn;\n\tbool skip_on_failure = false;\n\tunsigned long next_skip_pfn = 0;\n\n\t/*\n\t * Ensure that there are not too many pages isolated from the LRU\n\t * list by either parallel reclaimers or compaction. If there are,\n\t * delay for some time until fewer pages are isolated\n\t */\n\twhile (unlikely(too_many_isolated(zone))) {\n\t\t/* async migration should just abort */\n\t\tif (cc->mode == MIGRATE_ASYNC)\n\t\t\treturn 0;\n\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/10);\n\n\t\tif (fatal_signal_pending(current))\n\t\t\treturn 0;\n\t}\n\n\tif (compact_should_abort(cc))\n\t\treturn 0;\n\n\tif (cc->direct_compaction && (cc->mode == MIGRATE_ASYNC)) {\n\t\tskip_on_failure = true;\n\t\tnext_skip_pfn = block_end_pfn(low_pfn, cc->order);\n\t}\n\n\t/* Time to isolate some pages for migration */\n\tfor (; low_pfn < end_pfn; low_pfn++) {\n\n\t\tif (skip_on_failure && low_pfn >= next_skip_pfn) {\n\t\t\t/*\n\t\t\t * We have isolated all migration candidates in the\n\t\t\t * previous order-aligned block, and did not skip it due\n\t\t\t * to failure. We should migrate the pages now and\n\t\t\t * hopefully succeed compaction.\n\t\t\t */\n\t\t\tif (nr_isolated)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * We failed to isolate in the previous order-aligned\n\t\t\t * block. Set the new boundary to the end of the\n\t\t\t * current block. Note we can't simply increase\n\t\t\t * next_skip_pfn by 1 << order, as low_pfn might have\n\t\t\t * been incremented by a higher number due to skipping\n\t\t\t * a compound or a high-order buddy page in the\n\t\t\t * previous loop iteration.\n\t\t\t */\n\t\t\tnext_skip_pfn = block_end_pfn(low_pfn, cc->order);\n\t\t}\n\n\t\t/*\n\t\t * Periodically drop the lock (if held) regardless of its\n\t\t * contention, to give chance to IRQs. Abort async compaction\n\t\t * if contended.\n\t\t */\n\t\tif (!(low_pfn % SWAP_CLUSTER_MAX)\n\t\t    && compact_unlock_should_abort(zone_lru_lock(zone), flags,\n\t\t\t\t\t\t\t\t&locked, cc))\n\t\t\tbreak;\n\n\t\tif (!pfn_valid_within(low_pfn))\n\t\t\tgoto isolate_fail;\n\t\tnr_scanned++;\n\n\t\tpage = pfn_to_page(low_pfn);\n\n\t\tif (!valid_page)\n\t\t\tvalid_page = page;\n\n\t\t/*\n\t\t * Skip if free. We read page order here without zone lock\n\t\t * which is generally unsafe, but the race window is small and\n\t\t * the worst thing that can happen is that we skip some\n\t\t * potential isolation targets.\n\t\t */\n\t\tif (PageBuddy(page)) {\n\t\t\tunsigned long freepage_order = page_order_unsafe(page);\n\n\t\t\t/*\n\t\t\t * Without lock, we cannot be sure that what we got is\n\t\t\t * a valid page order. Consider only values in the\n\t\t\t * valid order range to prevent low_pfn overflow.\n\t\t\t */\n\t\t\tif (freepage_order > 0 && freepage_order < MAX_ORDER)\n\t\t\t\tlow_pfn += (1UL << freepage_order) - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Regardless of being on LRU, compound pages such as THP and\n\t\t * hugetlbfs are not to be compacted. We can potentially save\n\t\t * a lot of iterations if we skip them at once. The check is\n\t\t * racy, but we can consider only valid values and the only\n\t\t * danger is skipping too much.\n\t\t */\n\t\tif (PageCompound(page)) {\n\t\t\tconst unsigned int order = compound_order(page);\n\n\t\t\tif (likely(order < MAX_ORDER))\n\t\t\t\tlow_pfn += (1UL << order) - 1;\n\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\t/*\n\t\t * Check may be lockless but that's ok as we recheck later.\n\t\t * It's possible to migrate LRU and non-lru movable pages.\n\t\t * Skip any other type of page\n\t\t */\n\t\tif (!PageLRU(page)) {\n\t\t\t/*\n\t\t\t * __PageMovable can return false positive so we need\n\t\t\t * to verify it under page_lock.\n\t\t\t */\n\t\t\tif (unlikely(__PageMovable(page)) &&\n\t\t\t\t\t!PageIsolated(page)) {\n\t\t\t\tif (locked) {\n\t\t\t\t\tspin_unlock_irqrestore(zone_lru_lock(zone),\n\t\t\t\t\t\t\t\t\tflags);\n\t\t\t\t\tlocked = false;\n\t\t\t\t}\n\n\t\t\t\tif (!isolate_movable_page(page, isolate_mode))\n\t\t\t\t\tgoto isolate_success;\n\t\t\t}\n\n\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\t/*\n\t\t * Migration will fail if an anonymous page is pinned in memory,\n\t\t * so avoid taking lru_lock and isolating it unnecessarily in an\n\t\t * admittedly racy check.\n\t\t */\n\t\tif (!page_mapping(page) &&\n\t\t    page_count(page) > page_mapcount(page))\n\t\t\tgoto isolate_fail;\n\n\t\t/*\n\t\t * Only allow to migrate anonymous pages in GFP_NOFS context\n\t\t * because those do not depend on fs locks.\n\t\t */\n\t\tif (!(cc->gfp_mask & __GFP_FS) && page_mapping(page))\n\t\t\tgoto isolate_fail;\n\n\t\t/* If we already hold the lock, we can skip some rechecking */\n\t\tif (!locked) {\n\t\t\tlocked = compact_trylock_irqsave(zone_lru_lock(zone),\n\t\t\t\t\t\t\t\t&flags, cc);\n\t\t\tif (!locked)\n\t\t\t\tbreak;\n\n\t\t\t/* Recheck PageLRU and PageCompound under lock */\n\t\t\tif (!PageLRU(page))\n\t\t\t\tgoto isolate_fail;\n\n\t\t\t/*\n\t\t\t * Page become compound since the non-locked check,\n\t\t\t * and it's on LRU. It can only be a THP so the order\n\t\t\t * is safe to read and it's 0 for tail pages.\n\t\t\t */\n\t\t\tif (unlikely(PageCompound(page))) {\n\t\t\t\tlow_pfn += (1UL << compound_order(page)) - 1;\n\t\t\t\tgoto isolate_fail;\n\t\t\t}\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\n\t\t/* Try isolate the page */\n\t\tif (__isolate_lru_page(page, isolate_mode) != 0)\n\t\t\tgoto isolate_fail;\n\n\t\tVM_BUG_ON_PAGE(PageCompound(page), page);\n\n\t\t/* Successfully isolated */\n\t\tdel_page_from_lru_list(page, lruvec, page_lru(page));\n\t\tinc_node_page_state(page,\n\t\t\t\tNR_ISOLATED_ANON + page_is_file_cache(page));\n\nisolate_success:\n\t\tlist_add(&page->lru, &cc->migratepages);\n\t\tcc->nr_migratepages++;\n\t\tnr_isolated++;\n\n\t\t/*\n\t\t * Record where we could have freed pages by migration and not\n\t\t * yet flushed them to buddy allocator.\n\t\t * - this is the lowest page that was isolated and likely be\n\t\t * then freed by migration.\n\t\t */\n\t\tif (!cc->last_migrated_pfn)\n\t\t\tcc->last_migrated_pfn = low_pfn;\n\n\t\t/* Avoid isolating too much */\n\t\tif (cc->nr_migratepages == COMPACT_CLUSTER_MAX) {\n\t\t\t++low_pfn;\n\t\t\tbreak;\n\t\t}\n\n\t\tcontinue;\nisolate_fail:\n\t\tif (!skip_on_failure)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We have isolated some pages, but then failed. Release them\n\t\t * instead of migrating, as we cannot form the cc->order buddy\n\t\t * page anyway.\n\t\t */\n\t\tif (nr_isolated) {\n\t\t\tif (locked) {\n\t\t\t\tspin_unlock_irqrestore(zone_lru_lock(zone), flags);\n\t\t\t\tlocked = false;\n\t\t\t}\n\t\t\tputback_movable_pages(&cc->migratepages);\n\t\t\tcc->nr_migratepages = 0;\n\t\t\tcc->last_migrated_pfn = 0;\n\t\t\tnr_isolated = 0;\n\t\t}\n\n\t\tif (low_pfn < next_skip_pfn) {\n\t\t\tlow_pfn = next_skip_pfn - 1;\n\t\t\t/*\n\t\t\t * The check near the loop beginning would have updated\n\t\t\t * next_skip_pfn too, but this is a bit simpler.\n\t\t\t */\n\t\t\tnext_skip_pfn += 1UL << cc->order;\n\t\t}\n\t}\n\n\t/*\n\t * The PageBuddy() check could have potentially brought us outside\n\t * the range to be scanned.\n\t */\n\tif (unlikely(low_pfn > end_pfn))\n\t\tlow_pfn = end_pfn;\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(zone_lru_lock(zone), flags);\n\n\t/*\n\t * Update the pageblock-skip information and cached scanner pfn,\n\t * if the whole pageblock was scanned without isolating any page.\n\t */\n\tif (low_pfn == end_pfn)\n\t\tupdate_pageblock_skip(cc, valid_page, nr_isolated, true);\n\n\ttrace_mm_compaction_isolate_migratepages(start_pfn, low_pfn,\n\t\t\t\t\t\tnr_scanned, nr_isolated);\n\n\tcc->total_migrate_scanned += nr_scanned;\n\tif (nr_isolated)\n\t\tcount_compact_events(COMPACTISOLATED, nr_isolated);\n\n\treturn low_pfn;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic unsigned long\nisolate_migratepages_block(struct compact_control *cc, unsigned long low_pfn,\n\t\t\tunsigned long end_pfn, isolate_mode_t isolate_mode)\n{\n\tstruct zone *zone = cc->zone;\n\tunsigned long nr_scanned = 0, nr_isolated = 0;\n\tstruct lruvec *lruvec;\n\tunsigned long flags = 0;\n\tbool locked = false;\n\tstruct page *page = NULL, *valid_page = NULL;\n\tunsigned long start_pfn = low_pfn;\n\tbool skip_on_failure = false;\n\tunsigned long next_skip_pfn = 0;\n\n\t/*\n\t * Ensure that there are not too many pages isolated from the LRU\n\t * list by either parallel reclaimers or compaction. If there are,\n\t * delay for some time until fewer pages are isolated\n\t */\n\twhile (unlikely(too_many_isolated(zone))) {\n\t\t/* async migration should just abort */\n\t\tif (cc->mode == MIGRATE_ASYNC)\n\t\t\treturn 0;\n\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/10);\n\n\t\tif (fatal_signal_pending(current))\n\t\t\treturn 0;\n\t}\n\n\tif (compact_should_abort(cc))\n\t\treturn 0;\n\n\tif (cc->direct_compaction && (cc->mode == MIGRATE_ASYNC)) {\n\t\tskip_on_failure = true;\n\t\tnext_skip_pfn = block_end_pfn(low_pfn, cc->order);\n\t}\n\n\t/* Time to isolate some pages for migration */\n\tfor (; low_pfn < end_pfn; low_pfn++) {\n\n\t\tif (skip_on_failure && low_pfn >= next_skip_pfn) {\n\t\t\t/*\n\t\t\t * We have isolated all migration candidates in the\n\t\t\t * previous order-aligned block, and did not skip it due\n\t\t\t * to failure. We should migrate the pages now and\n\t\t\t * hopefully succeed compaction.\n\t\t\t */\n\t\t\tif (nr_isolated)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * We failed to isolate in the previous order-aligned\n\t\t\t * block. Set the new boundary to the end of the\n\t\t\t * current block. Note we can't simply increase\n\t\t\t * next_skip_pfn by 1 << order, as low_pfn might have\n\t\t\t * been incremented by a higher number due to skipping\n\t\t\t * a compound or a high-order buddy page in the\n\t\t\t * previous loop iteration.\n\t\t\t */\n\t\t\tnext_skip_pfn = block_end_pfn(low_pfn, cc->order);\n\t\t}\n\n\t\t/*\n\t\t * Periodically drop the lock (if held) regardless of its\n\t\t * contention, to give chance to IRQs. Abort async compaction\n\t\t * if contended.\n\t\t */\n\t\tif (!(low_pfn % SWAP_CLUSTER_MAX)\n\t\t    && compact_unlock_should_abort(zone_lru_lock(zone), flags,\n\t\t\t\t\t\t\t\t&locked, cc))\n\t\t\tbreak;\n\n\t\tif (!pfn_valid_within(low_pfn))\n\t\t\tgoto isolate_fail;\n\t\tnr_scanned++;\n\n\t\tpage = pfn_to_page(low_pfn);\n\n\t\tif (!valid_page)\n\t\t\tvalid_page = page;\n\n\t\t/*\n\t\t * Skip if free. We read page order here without zone lock\n\t\t * which is generally unsafe, but the race window is small and\n\t\t * the worst thing that can happen is that we skip some\n\t\t * potential isolation targets.\n\t\t */\n\t\tif (PageBuddy(page)) {\n\t\t\tunsigned long freepage_order = page_order_unsafe(page);\n\n\t\t\t/*\n\t\t\t * Without lock, we cannot be sure that what we got is\n\t\t\t * a valid page order. Consider only values in the\n\t\t\t * valid order range to prevent low_pfn overflow.\n\t\t\t */\n\t\t\tif (freepage_order > 0 && freepage_order < MAX_ORDER)\n\t\t\t\tlow_pfn += (1UL << freepage_order) - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Regardless of being on LRU, compound pages such as THP and\n\t\t * hugetlbfs are not to be compacted. We can potentially save\n\t\t * a lot of iterations if we skip them at once. The check is\n\t\t * racy, but we can consider only valid values and the only\n\t\t * danger is skipping too much.\n\t\t */\n\t\tif (PageCompound(page)) {\n\t\t\tconst unsigned int order = compound_order(page);\n\n\t\t\tif (likely(order < MAX_ORDER))\n\t\t\t\tlow_pfn += (1UL << order) - 1;\n\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\t/*\n\t\t * Check may be lockless but that's ok as we recheck later.\n\t\t * It's possible to migrate LRU and non-lru movable pages.\n\t\t * Skip any other type of page\n\t\t */\n\t\tif (!PageLRU(page)) {\n\t\t\t/*\n\t\t\t * __PageMovable can return false positive so we need\n\t\t\t * to verify it under page_lock.\n\t\t\t */\n\t\t\tif (unlikely(__PageMovable(page)) &&\n\t\t\t\t\t!PageIsolated(page)) {\n\t\t\t\tif (locked) {\n\t\t\t\t\tspin_unlock_irqrestore(zone_lru_lock(zone),\n\t\t\t\t\t\t\t\t\tflags);\n\t\t\t\t\tlocked = false;\n\t\t\t\t}\n\n\t\t\t\tif (!isolate_movable_page(page, isolate_mode))\n\t\t\t\t\tgoto isolate_success;\n\t\t\t}\n\n\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\t/*\n\t\t * Migration will fail if an anonymous page is pinned in memory,\n\t\t * so avoid taking lru_lock and isolating it unnecessarily in an\n\t\t * admittedly racy check.\n\t\t */\n\t\tif (!page_mapping(page) &&\n\t\t    page_count(page) > page_mapcount(page))\n\t\t\tgoto isolate_fail;\n\n\t\t/*\n\t\t * Only allow to migrate anonymous pages in GFP_NOFS context\n\t\t * because those do not depend on fs locks.\n\t\t */\n\t\tif (!(cc->gfp_mask & __GFP_FS) && page_mapping(page))\n\t\t\tgoto isolate_fail;\n\n\t\t/* If we already hold the lock, we can skip some rechecking */\n\t\tif (!locked) {\n\t\t\tlocked = compact_trylock_irqsave(zone_lru_lock(zone),\n\t\t\t\t\t\t\t\t&flags, cc);\n\t\t\tif (!locked)\n\t\t\t\tbreak;\n\n\t\t\t/* Recheck PageLRU and PageCompound under lock */\n\t\t\tif (!PageLRU(page))\n\t\t\t\tgoto isolate_fail;\n\n\t\t\t/*\n\t\t\t * Page become compound since the non-locked check,\n\t\t\t * and it's on LRU. It can only be a THP so the order\n\t\t\t * is safe to read and it's 0 for tail pages.\n\t\t\t */\n\t\t\tif (unlikely(PageCompound(page))) {\n\t\t\t\tlow_pfn += (1UL << compound_order(page)) - 1;\n\t\t\t\tgoto isolate_fail;\n\t\t\t}\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\n\t\t/* Try isolate the page */\n\t\tif (__isolate_lru_page(page, isolate_mode) != 0)\n\t\t\tgoto isolate_fail;\n\n\t\tVM_BUG_ON_PAGE(PageCompound(page), page);\n\n\t\t/* Successfully isolated */\n\t\tdel_page_from_lru_list(page, lruvec, page_lru(page));\n\t\tinc_node_page_state(page,\n\t\t\t\tNR_ISOLATED_ANON + page_is_file_cache(page));\n\nisolate_success:\n\t\tlist_add(&page->lru, &cc->migratepages);\n\t\tcc->nr_migratepages++;\n\t\tnr_isolated++;\n\n\t\t/*\n\t\t * Record where we could have freed pages by migration and not\n\t\t * yet flushed them to buddy allocator.\n\t\t * - this is the lowest page that was isolated and likely be\n\t\t * then freed by migration.\n\t\t */\n\t\tif (!cc->last_migrated_pfn)\n\t\t\tcc->last_migrated_pfn = low_pfn;\n\n\t\t/* Avoid isolating too much */\n\t\tif (cc->nr_migratepages == COMPACT_CLUSTER_MAX) {\n\t\t\t++low_pfn;\n\t\t\tbreak;\n\t\t}\n\n\t\tcontinue;\nisolate_fail:\n\t\tif (!skip_on_failure)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We have isolated some pages, but then failed. Release them\n\t\t * instead of migrating, as we cannot form the cc->order buddy\n\t\t * page anyway.\n\t\t */\n\t\tif (nr_isolated) {\n\t\t\tif (locked) {\n\t\t\t\tspin_unlock_irqrestore(zone_lru_lock(zone), flags);\n\t\t\t\tlocked = false;\n\t\t\t}\n\t\t\tputback_movable_pages(&cc->migratepages);\n\t\t\tcc->nr_migratepages = 0;\n\t\t\tcc->last_migrated_pfn = 0;\n\t\t\tnr_isolated = 0;\n\t\t}\n\n\t\tif (low_pfn < next_skip_pfn) {\n\t\t\tlow_pfn = next_skip_pfn - 1;\n\t\t\t/*\n\t\t\t * The check near the loop beginning would have updated\n\t\t\t * next_skip_pfn too, but this is a bit simpler.\n\t\t\t */\n\t\t\tnext_skip_pfn += 1UL << cc->order;\n\t\t}\n\t}\n\n\t/*\n\t * The PageBuddy() check could have potentially brought us outside\n\t * the range to be scanned.\n\t */\n\tif (unlikely(low_pfn > end_pfn))\n\t\tlow_pfn = end_pfn;\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(zone_lru_lock(zone), flags);\n\n\t/*\n\t * Update the pageblock-skip information and cached scanner pfn,\n\t * if the whole pageblock was scanned without isolating any page.\n\t */\n\tif (low_pfn == end_pfn)\n\t\tupdate_pageblock_skip(cc, valid_page, nr_isolated, true);\n\n\ttrace_mm_compaction_isolate_migratepages(start_pfn, low_pfn,\n\t\t\t\t\t\tnr_scanned, nr_isolated);\n\n\tcc->total_migrate_scanned += nr_scanned;\n\tif (nr_isolated)\n\t\tcount_compact_events(COMPACTISOLATED, nr_isolated);\n\n\treturn low_pfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "suitable_migration_source",
          "args": [
            "cc",
            "page"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "suitable_migration_source",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1011-1025",
          "snippet": "static bool suitable_migration_source(struct compact_control *cc,\n\t\t\t\t\t\t\tstruct page *page)\n{\n\tint block_mt;\n\n\tif ((cc->mode != MIGRATE_ASYNC) || !cc->direct_compaction)\n\t\treturn true;\n\n\tblock_mt = get_pageblock_migratetype(page);\n\n\tif (cc->migratetype == MIGRATE_MOVABLE)\n\t\treturn is_migrate_movable(block_mt);\n\telse\n\t\treturn block_mt == cc->migratetype;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic bool suitable_migration_source(struct compact_control *cc,\n\t\t\t\t\t\t\tstruct page *page)\n{\n\tint block_mt;\n\n\tif ((cc->mode != MIGRATE_ASYNC) || !cc->direct_compaction)\n\t\treturn true;\n\n\tblock_mt = get_pageblock_migratetype(page);\n\n\tif (cc->migratetype == MIGRATE_MOVABLE)\n\t\treturn is_migrate_movable(block_mt);\n\telse\n\t\treturn block_mt == cc->migratetype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isolation_suitable",
          "args": [
            "cc",
            "page"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "isolation_suitable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "325-329",
          "snippet": "static inline bool isolation_suitable(struct compact_control *cc,\n\t\t\t\t\tstruct page *page)\n{\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline bool isolation_suitable(struct compact_control *cc,\n\t\t\t\t\tstruct page *page)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pageblock_pfn_to_page",
          "args": [
            "block_start_pfn",
            "block_end_pfn",
            "zone"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "__pageblock_pfn_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1366-1392",
          "snippet": "struct page *__pageblock_pfn_to_page(unsigned long start_pfn,\n\t\t\t\t     unsigned long end_pfn, struct zone *zone)\n{\n\tstruct page *start_page;\n\tstruct page *end_page;\n\n\t/* end_pfn is one past the range we are checking */\n\tend_pfn--;\n\n\tif (!pfn_valid(start_pfn) || !pfn_valid(end_pfn))\n\t\treturn NULL;\n\n\tstart_page = pfn_to_online_page(start_pfn);\n\tif (!start_page)\n\t\treturn NULL;\n\n\tif (page_zone(start_page) != zone)\n\t\treturn NULL;\n\n\tend_page = pfn_to_page(end_pfn);\n\n\t/* This gives a shorter code than deriving page_zone(end_page) */\n\tif (page_zone_id(start_page) != page_zone_id(end_page))\n\t\treturn NULL;\n\n\treturn start_page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstruct page *__pageblock_pfn_to_page(unsigned long start_pfn,\n\t\t\t\t     unsigned long end_pfn, struct zone *zone)\n{\n\tstruct page *start_page;\n\tstruct page *end_page;\n\n\t/* end_pfn is one past the range we are checking */\n\tend_pfn--;\n\n\tif (!pfn_valid(start_pfn) || !pfn_valid(end_pfn))\n\t\treturn NULL;\n\n\tstart_page = pfn_to_online_page(start_pfn);\n\tif (!start_page)\n\t\treturn NULL;\n\n\tif (page_zone(start_page) != zone)\n\t\treturn NULL;\n\n\tend_page = pfn_to_page(end_pfn);\n\n\t/* This gives a shorter code than deriving page_zone(end_page) */\n\tif (page_zone_id(start_page) != page_zone_id(end_page))\n\t\treturn NULL;\n\n\treturn start_page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact_should_abort",
          "args": [
            "cc"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "compact_should_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "414-427",
          "snippet": "static inline bool compact_should_abort(struct compact_control *cc)\n{\n\t/* async compaction aborts if contended */\n\tif (need_resched()) {\n\t\tif (cc->mode == MIGRATE_ASYNC) {\n\t\t\tcc->contended = true;\n\t\t\treturn true;\n\t\t}\n\n\t\tcond_resched();\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline bool compact_should_abort(struct compact_control *cc)\n{\n\t/* async compaction aborts if contended */\n\tif (need_resched()) {\n\t\tif (cc->mode == MIGRATE_ASYNC) {\n\t\t\tcc->contended = true;\n\t\t\treturn true;\n\t\t}\n\n\t\tcond_resched();\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pageblock_end_pfn",
          "args": [
            "low_pfn"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pageblock_start_pfn",
          "args": [
            "low_pfn"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic isolate_migrate_t isolate_migratepages(struct zone *zone,\n\t\t\t\t\tstruct compact_control *cc)\n{\n\tunsigned long block_start_pfn;\n\tunsigned long block_end_pfn;\n\tunsigned long low_pfn;\n\tstruct page *page;\n\tconst isolate_mode_t isolate_mode =\n\t\t(sysctl_compact_unevictable_allowed ? ISOLATE_UNEVICTABLE : 0) |\n\t\t(cc->mode != MIGRATE_SYNC ? ISOLATE_ASYNC_MIGRATE : 0);\n\n\t/*\n\t * Start at where we last stopped, or beginning of the zone as\n\t * initialized by compact_zone()\n\t */\n\tlow_pfn = cc->migrate_pfn;\n\tblock_start_pfn = pageblock_start_pfn(low_pfn);\n\tif (block_start_pfn < zone->zone_start_pfn)\n\t\tblock_start_pfn = zone->zone_start_pfn;\n\n\t/* Only scan within a pageblock boundary */\n\tblock_end_pfn = pageblock_end_pfn(low_pfn);\n\n\t/*\n\t * Iterate over whole pageblocks until we find the first suitable.\n\t * Do not cross the free scanner.\n\t */\n\tfor (; block_end_pfn <= cc->free_pfn;\n\t\t\tlow_pfn = block_end_pfn,\n\t\t\tblock_start_pfn = block_end_pfn,\n\t\t\tblock_end_pfn += pageblock_nr_pages) {\n\n\t\t/*\n\t\t * This can potentially iterate a massively long zone with\n\t\t * many pageblocks unsuitable, so periodically check if we\n\t\t * need to schedule, or even abort async compaction.\n\t\t */\n\t\tif (!(low_pfn % (SWAP_CLUSTER_MAX * pageblock_nr_pages))\n\t\t\t\t\t\t&& compact_should_abort(cc))\n\t\t\tbreak;\n\n\t\tpage = pageblock_pfn_to_page(block_start_pfn, block_end_pfn,\n\t\t\t\t\t\t\t\t\tzone);\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\t/* If isolation recently failed, do not retry */\n\t\tif (!isolation_suitable(cc, page))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * For async compaction, also only scan in MOVABLE blocks.\n\t\t * Async compaction is optimistic to see if the minimum amount\n\t\t * of work satisfies the allocation.\n\t\t */\n\t\tif (!suitable_migration_source(cc, page))\n\t\t\tcontinue;\n\n\t\t/* Perform the isolation */\n\t\tlow_pfn = isolate_migratepages_block(cc, low_pfn,\n\t\t\t\t\t\tblock_end_pfn, isolate_mode);\n\n\t\tif (!low_pfn || cc->contended)\n\t\t\treturn ISOLATE_ABORT;\n\n\t\t/*\n\t\t * Either we isolated something and proceed with migration. Or\n\t\t * we failed and compact_zone should decide if we should\n\t\t * continue or not.\n\t\t */\n\t\tbreak;\n\t}\n\n\t/* Record where migration scanner will be restarted. */\n\tcc->migrate_pfn = low_pfn;\n\n\treturn cc->nr_migratepages ? ISOLATE_SUCCESS : ISOLATE_NONE;\n}"
  },
  {
    "function_name": "compaction_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "1199-1205",
    "snippet": "static void compaction_free(struct page *page, unsigned long data)\n{\n\tstruct compact_control *cc = (struct compact_control *)data;\n\n\tlist_add(&page->lru, &cc->freepages);\n\tcc->nr_freepages++;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->lru",
            "&cc->freepages"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic void compaction_free(struct page *page, unsigned long data)\n{\n\tstruct compact_control *cc = (struct compact_control *)data;\n\n\tlist_add(&page->lru, &cc->freepages);\n\tcc->nr_freepages++;\n}"
  },
  {
    "function_name": "compaction_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "1169-1192",
    "snippet": "static struct page *compaction_alloc(struct page *migratepage,\n\t\t\t\t\tunsigned long data)\n{\n\tstruct compact_control *cc = (struct compact_control *)data;\n\tstruct page *freepage;\n\n\t/*\n\t * Isolate free pages if necessary, and if we are not aborting due to\n\t * contention.\n\t */\n\tif (list_empty(&cc->freepages)) {\n\t\tif (!cc->contended)\n\t\t\tisolate_freepages(cc);\n\n\t\tif (list_empty(&cc->freepages))\n\t\t\treturn NULL;\n\t}\n\n\tfreepage = list_entry(cc->freepages.next, struct page, lru);\n\tlist_del(&freepage->lru);\n\tcc->nr_freepages--;\n\n\treturn freepage;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&freepage->lru"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "cc->freepages.next",
            "structpage",
            "lru"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cc->freepages"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isolate_freepages",
          "args": [
            "cc"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_freepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1067-1163",
          "snippet": "static void isolate_freepages(struct compact_control *cc)\n{\n\tstruct zone *zone = cc->zone;\n\tstruct page *page;\n\tunsigned long block_start_pfn;\t/* start of current pageblock */\n\tunsigned long isolate_start_pfn; /* exact pfn we start at */\n\tunsigned long block_end_pfn;\t/* end of current pageblock */\n\tunsigned long low_pfn;\t     /* lowest pfn scanner is able to scan */\n\tstruct list_head *freelist = &cc->freepages;\n\n\t/*\n\t * Initialise the free scanner. The starting point is where we last\n\t * successfully isolated from, zone-cached value, or the end of the\n\t * zone when isolating for the first time. For looping we also need\n\t * this pfn aligned down to the pageblock boundary, because we do\n\t * block_start_pfn -= pageblock_nr_pages in the for loop.\n\t * For ending point, take care when isolating in last pageblock of a\n\t * a zone which ends in the middle of a pageblock.\n\t * The low boundary is the end of the pageblock the migration scanner\n\t * is using.\n\t */\n\tisolate_start_pfn = cc->free_pfn;\n\tblock_start_pfn = pageblock_start_pfn(cc->free_pfn);\n\tblock_end_pfn = min(block_start_pfn + pageblock_nr_pages,\n\t\t\t\t\t\tzone_end_pfn(zone));\n\tlow_pfn = pageblock_end_pfn(cc->migrate_pfn);\n\n\t/*\n\t * Isolate free pages until enough are available to migrate the\n\t * pages on cc->migratepages. We stop searching if the migrate\n\t * and free page scanners meet or enough free pages are isolated.\n\t */\n\tfor (; block_start_pfn >= low_pfn;\n\t\t\t\tblock_end_pfn = block_start_pfn,\n\t\t\t\tblock_start_pfn -= pageblock_nr_pages,\n\t\t\t\tisolate_start_pfn = block_start_pfn) {\n\t\t/*\n\t\t * This can iterate a massively long zone without finding any\n\t\t * suitable migration targets, so periodically check if we need\n\t\t * to schedule, or even abort async compaction.\n\t\t */\n\t\tif (!(block_start_pfn % (SWAP_CLUSTER_MAX * pageblock_nr_pages))\n\t\t\t\t\t\t&& compact_should_abort(cc))\n\t\t\tbreak;\n\n\t\tpage = pageblock_pfn_to_page(block_start_pfn, block_end_pfn,\n\t\t\t\t\t\t\t\t\tzone);\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\t/* Check the block is suitable for migration */\n\t\tif (!suitable_migration_target(cc, page))\n\t\t\tcontinue;\n\n\t\t/* If isolation recently failed, do not retry */\n\t\tif (!isolation_suitable(cc, page))\n\t\t\tcontinue;\n\n\t\t/* Found a block suitable for isolating free pages from. */\n\t\tisolate_freepages_block(cc, &isolate_start_pfn, block_end_pfn,\n\t\t\t\t\tfreelist, false);\n\n\t\t/*\n\t\t * If we isolated enough freepages, or aborted due to lock\n\t\t * contention, terminate.\n\t\t */\n\t\tif ((cc->nr_freepages >= cc->nr_migratepages)\n\t\t\t\t\t\t\t|| cc->contended) {\n\t\t\tif (isolate_start_pfn >= block_end_pfn) {\n\t\t\t\t/*\n\t\t\t\t * Restart at previous pageblock if more\n\t\t\t\t * freepages can be isolated next time.\n\t\t\t\t */\n\t\t\t\tisolate_start_pfn =\n\t\t\t\t\tblock_start_pfn - pageblock_nr_pages;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (isolate_start_pfn < block_end_pfn) {\n\t\t\t/*\n\t\t\t * If isolation failed early, do not continue\n\t\t\t * needlessly.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* __isolate_free_page() does not map the pages */\n\tmap_pages(freelist);\n\n\t/*\n\t * Record where the free scanner will restart next time. Either we\n\t * broke from the loop and set isolate_start_pfn based on the last\n\t * call to isolate_freepages_block(), or we met the migration scanner\n\t * and the loop terminated due to isolate_start_pfn < low_pfn\n\t */\n\tcc->free_pfn = isolate_start_pfn;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic void isolate_freepages(struct compact_control *cc)\n{\n\tstruct zone *zone = cc->zone;\n\tstruct page *page;\n\tunsigned long block_start_pfn;\t/* start of current pageblock */\n\tunsigned long isolate_start_pfn; /* exact pfn we start at */\n\tunsigned long block_end_pfn;\t/* end of current pageblock */\n\tunsigned long low_pfn;\t     /* lowest pfn scanner is able to scan */\n\tstruct list_head *freelist = &cc->freepages;\n\n\t/*\n\t * Initialise the free scanner. The starting point is where we last\n\t * successfully isolated from, zone-cached value, or the end of the\n\t * zone when isolating for the first time. For looping we also need\n\t * this pfn aligned down to the pageblock boundary, because we do\n\t * block_start_pfn -= pageblock_nr_pages in the for loop.\n\t * For ending point, take care when isolating in last pageblock of a\n\t * a zone which ends in the middle of a pageblock.\n\t * The low boundary is the end of the pageblock the migration scanner\n\t * is using.\n\t */\n\tisolate_start_pfn = cc->free_pfn;\n\tblock_start_pfn = pageblock_start_pfn(cc->free_pfn);\n\tblock_end_pfn = min(block_start_pfn + pageblock_nr_pages,\n\t\t\t\t\t\tzone_end_pfn(zone));\n\tlow_pfn = pageblock_end_pfn(cc->migrate_pfn);\n\n\t/*\n\t * Isolate free pages until enough are available to migrate the\n\t * pages on cc->migratepages. We stop searching if the migrate\n\t * and free page scanners meet or enough free pages are isolated.\n\t */\n\tfor (; block_start_pfn >= low_pfn;\n\t\t\t\tblock_end_pfn = block_start_pfn,\n\t\t\t\tblock_start_pfn -= pageblock_nr_pages,\n\t\t\t\tisolate_start_pfn = block_start_pfn) {\n\t\t/*\n\t\t * This can iterate a massively long zone without finding any\n\t\t * suitable migration targets, so periodically check if we need\n\t\t * to schedule, or even abort async compaction.\n\t\t */\n\t\tif (!(block_start_pfn % (SWAP_CLUSTER_MAX * pageblock_nr_pages))\n\t\t\t\t\t\t&& compact_should_abort(cc))\n\t\t\tbreak;\n\n\t\tpage = pageblock_pfn_to_page(block_start_pfn, block_end_pfn,\n\t\t\t\t\t\t\t\t\tzone);\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\t/* Check the block is suitable for migration */\n\t\tif (!suitable_migration_target(cc, page))\n\t\t\tcontinue;\n\n\t\t/* If isolation recently failed, do not retry */\n\t\tif (!isolation_suitable(cc, page))\n\t\t\tcontinue;\n\n\t\t/* Found a block suitable for isolating free pages from. */\n\t\tisolate_freepages_block(cc, &isolate_start_pfn, block_end_pfn,\n\t\t\t\t\tfreelist, false);\n\n\t\t/*\n\t\t * If we isolated enough freepages, or aborted due to lock\n\t\t * contention, terminate.\n\t\t */\n\t\tif ((cc->nr_freepages >= cc->nr_migratepages)\n\t\t\t\t\t\t\t|| cc->contended) {\n\t\t\tif (isolate_start_pfn >= block_end_pfn) {\n\t\t\t\t/*\n\t\t\t\t * Restart at previous pageblock if more\n\t\t\t\t * freepages can be isolated next time.\n\t\t\t\t */\n\t\t\t\tisolate_start_pfn =\n\t\t\t\t\tblock_start_pfn - pageblock_nr_pages;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (isolate_start_pfn < block_end_pfn) {\n\t\t\t/*\n\t\t\t * If isolation failed early, do not continue\n\t\t\t * needlessly.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* __isolate_free_page() does not map the pages */\n\tmap_pages(freelist);\n\n\t/*\n\t * Record where the free scanner will restart next time. Either we\n\t * broke from the loop and set isolate_start_pfn based on the last\n\t * call to isolate_freepages_block(), or we met the migration scanner\n\t * and the loop terminated due to isolate_start_pfn < low_pfn\n\t */\n\tcc->free_pfn = isolate_start_pfn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic struct page *compaction_alloc(struct page *migratepage,\n\t\t\t\t\tunsigned long data)\n{\n\tstruct compact_control *cc = (struct compact_control *)data;\n\tstruct page *freepage;\n\n\t/*\n\t * Isolate free pages if necessary, and if we are not aborting due to\n\t * contention.\n\t */\n\tif (list_empty(&cc->freepages)) {\n\t\tif (!cc->contended)\n\t\t\tisolate_freepages(cc);\n\n\t\tif (list_empty(&cc->freepages))\n\t\t\treturn NULL;\n\t}\n\n\tfreepage = list_entry(cc->freepages.next, struct page, lru);\n\tlist_del(&freepage->lru);\n\tcc->nr_freepages--;\n\n\treturn freepage;\n}"
  },
  {
    "function_name": "isolate_freepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "1067-1163",
    "snippet": "static void isolate_freepages(struct compact_control *cc)\n{\n\tstruct zone *zone = cc->zone;\n\tstruct page *page;\n\tunsigned long block_start_pfn;\t/* start of current pageblock */\n\tunsigned long isolate_start_pfn; /* exact pfn we start at */\n\tunsigned long block_end_pfn;\t/* end of current pageblock */\n\tunsigned long low_pfn;\t     /* lowest pfn scanner is able to scan */\n\tstruct list_head *freelist = &cc->freepages;\n\n\t/*\n\t * Initialise the free scanner. The starting point is where we last\n\t * successfully isolated from, zone-cached value, or the end of the\n\t * zone when isolating for the first time. For looping we also need\n\t * this pfn aligned down to the pageblock boundary, because we do\n\t * block_start_pfn -= pageblock_nr_pages in the for loop.\n\t * For ending point, take care when isolating in last pageblock of a\n\t * a zone which ends in the middle of a pageblock.\n\t * The low boundary is the end of the pageblock the migration scanner\n\t * is using.\n\t */\n\tisolate_start_pfn = cc->free_pfn;\n\tblock_start_pfn = pageblock_start_pfn(cc->free_pfn);\n\tblock_end_pfn = min(block_start_pfn + pageblock_nr_pages,\n\t\t\t\t\t\tzone_end_pfn(zone));\n\tlow_pfn = pageblock_end_pfn(cc->migrate_pfn);\n\n\t/*\n\t * Isolate free pages until enough are available to migrate the\n\t * pages on cc->migratepages. We stop searching if the migrate\n\t * and free page scanners meet or enough free pages are isolated.\n\t */\n\tfor (; block_start_pfn >= low_pfn;\n\t\t\t\tblock_end_pfn = block_start_pfn,\n\t\t\t\tblock_start_pfn -= pageblock_nr_pages,\n\t\t\t\tisolate_start_pfn = block_start_pfn) {\n\t\t/*\n\t\t * This can iterate a massively long zone without finding any\n\t\t * suitable migration targets, so periodically check if we need\n\t\t * to schedule, or even abort async compaction.\n\t\t */\n\t\tif (!(block_start_pfn % (SWAP_CLUSTER_MAX * pageblock_nr_pages))\n\t\t\t\t\t\t&& compact_should_abort(cc))\n\t\t\tbreak;\n\n\t\tpage = pageblock_pfn_to_page(block_start_pfn, block_end_pfn,\n\t\t\t\t\t\t\t\t\tzone);\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\t/* Check the block is suitable for migration */\n\t\tif (!suitable_migration_target(cc, page))\n\t\t\tcontinue;\n\n\t\t/* If isolation recently failed, do not retry */\n\t\tif (!isolation_suitable(cc, page))\n\t\t\tcontinue;\n\n\t\t/* Found a block suitable for isolating free pages from. */\n\t\tisolate_freepages_block(cc, &isolate_start_pfn, block_end_pfn,\n\t\t\t\t\tfreelist, false);\n\n\t\t/*\n\t\t * If we isolated enough freepages, or aborted due to lock\n\t\t * contention, terminate.\n\t\t */\n\t\tif ((cc->nr_freepages >= cc->nr_migratepages)\n\t\t\t\t\t\t\t|| cc->contended) {\n\t\t\tif (isolate_start_pfn >= block_end_pfn) {\n\t\t\t\t/*\n\t\t\t\t * Restart at previous pageblock if more\n\t\t\t\t * freepages can be isolated next time.\n\t\t\t\t */\n\t\t\t\tisolate_start_pfn =\n\t\t\t\t\tblock_start_pfn - pageblock_nr_pages;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (isolate_start_pfn < block_end_pfn) {\n\t\t\t/*\n\t\t\t * If isolation failed early, do not continue\n\t\t\t * needlessly.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* __isolate_free_page() does not map the pages */\n\tmap_pages(freelist);\n\n\t/*\n\t * Record where the free scanner will restart next time. Either we\n\t * broke from the loop and set isolate_start_pfn based on the last\n\t * call to isolate_freepages_block(), or we met the migration scanner\n\t * and the loop terminated due to isolate_start_pfn < low_pfn\n\t */\n\tcc->free_pfn = isolate_start_pfn;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map_pages",
          "args": [
            "freelist"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "map_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "69-92",
          "snippet": "static void map_pages(struct list_head *list)\n{\n\tunsigned int i, order, nr_pages;\n\tstruct page *page, *next;\n\tLIST_HEAD(tmp_list);\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\n\t\torder = page_private(page);\n\t\tnr_pages = 1 << order;\n\n\t\tpost_alloc_hook(page, order, __GFP_MOVABLE);\n\t\tif (order)\n\t\t\tsplit_page(page, order);\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tlist_add(&page->lru, &tmp_list);\n\t\t\tpage++;\n\t\t}\n\t}\n\n\tlist_splice(&tmp_list, list);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic void map_pages(struct list_head *list)\n{\n\tunsigned int i, order, nr_pages;\n\tstruct page *page, *next;\n\tLIST_HEAD(tmp_list);\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\n\t\torder = page_private(page);\n\t\tnr_pages = 1 << order;\n\n\t\tpost_alloc_hook(page, order, __GFP_MOVABLE);\n\t\tif (order)\n\t\t\tsplit_page(page, order);\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tlist_add(&page->lru, &tmp_list);\n\t\t\tpage++;\n\t\t}\n\t}\n\n\tlist_splice(&tmp_list, list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isolate_freepages_block",
          "args": [
            "cc",
            "&isolate_start_pfn",
            "block_end_pfn",
            "freelist",
            "false"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_freepages_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "434-576",
          "snippet": "static unsigned long isolate_freepages_block(struct compact_control *cc,\n\t\t\t\tunsigned long *start_pfn,\n\t\t\t\tunsigned long end_pfn,\n\t\t\t\tstruct list_head *freelist,\n\t\t\t\tbool strict)\n{\n\tint nr_scanned = 0, total_isolated = 0;\n\tstruct page *cursor, *valid_page = NULL;\n\tunsigned long flags = 0;\n\tbool locked = false;\n\tunsigned long blockpfn = *start_pfn;\n\tunsigned int order;\n\n\tcursor = pfn_to_page(blockpfn);\n\n\t/* Isolate free pages. */\n\tfor (; blockpfn < end_pfn; blockpfn++, cursor++) {\n\t\tint isolated;\n\t\tstruct page *page = cursor;\n\n\t\t/*\n\t\t * Periodically drop the lock (if held) regardless of its\n\t\t * contention, to give chance to IRQs. Abort if fatal signal\n\t\t * pending or async compaction detects need_resched()\n\t\t */\n\t\tif (!(blockpfn % SWAP_CLUSTER_MAX)\n\t\t    && compact_unlock_should_abort(&cc->zone->lock, flags,\n\t\t\t\t\t\t\t\t&locked, cc))\n\t\t\tbreak;\n\n\t\tnr_scanned++;\n\t\tif (!pfn_valid_within(blockpfn))\n\t\t\tgoto isolate_fail;\n\n\t\tif (!valid_page)\n\t\t\tvalid_page = page;\n\n\t\t/*\n\t\t * For compound pages such as THP and hugetlbfs, we can save\n\t\t * potentially a lot of iterations if we skip them at once.\n\t\t * The check is racy, but we can consider only valid values\n\t\t * and the only danger is skipping too much.\n\t\t */\n\t\tif (PageCompound(page)) {\n\t\t\tconst unsigned int order = compound_order(page);\n\n\t\t\tif (likely(order < MAX_ORDER)) {\n\t\t\t\tblockpfn += (1UL << order) - 1;\n\t\t\t\tcursor += (1UL << order) - 1;\n\t\t\t}\n\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\tif (!PageBuddy(page))\n\t\t\tgoto isolate_fail;\n\n\t\t/*\n\t\t * If we already hold the lock, we can skip some rechecking.\n\t\t * Note that if we hold the lock now, checked_pageblock was\n\t\t * already set in some previous iteration (or strict is true),\n\t\t * so it is correct to skip the suitable migration target\n\t\t * recheck as well.\n\t\t */\n\t\tif (!locked) {\n\t\t\t/*\n\t\t\t * The zone lock must be held to isolate freepages.\n\t\t\t * Unfortunately this is a very coarse lock and can be\n\t\t\t * heavily contended if there are parallel allocations\n\t\t\t * or parallel compactions. For async compaction do not\n\t\t\t * spin on the lock and we acquire the lock as late as\n\t\t\t * possible.\n\t\t\t */\n\t\t\tlocked = compact_trylock_irqsave(&cc->zone->lock,\n\t\t\t\t\t\t\t\t&flags, cc);\n\t\t\tif (!locked)\n\t\t\t\tbreak;\n\n\t\t\t/* Recheck this is a buddy page under lock */\n\t\t\tif (!PageBuddy(page))\n\t\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\t/* Found a free page, will break it into order-0 pages */\n\t\torder = page_order(page);\n\t\tisolated = __isolate_free_page(page, order);\n\t\tif (!isolated)\n\t\t\tbreak;\n\t\tset_page_private(page, order);\n\n\t\ttotal_isolated += isolated;\n\t\tcc->nr_freepages += isolated;\n\t\tlist_add_tail(&page->lru, freelist);\n\n\t\tif (!strict && cc->nr_migratepages <= cc->nr_freepages) {\n\t\t\tblockpfn += isolated;\n\t\t\tbreak;\n\t\t}\n\t\t/* Advance to the end of split page */\n\t\tblockpfn += isolated - 1;\n\t\tcursor += isolated - 1;\n\t\tcontinue;\n\nisolate_fail:\n\t\tif (strict)\n\t\t\tbreak;\n\t\telse\n\t\t\tcontinue;\n\n\t}\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(&cc->zone->lock, flags);\n\n\t/*\n\t * There is a tiny chance that we have read bogus compound_order(),\n\t * so be careful to not go outside of the pageblock.\n\t */\n\tif (unlikely(blockpfn > end_pfn))\n\t\tblockpfn = end_pfn;\n\n\ttrace_mm_compaction_isolate_freepages(*start_pfn, blockpfn,\n\t\t\t\t\tnr_scanned, total_isolated);\n\n\t/* Record how far we have got within the block */\n\t*start_pfn = blockpfn;\n\n\t/*\n\t * If strict isolation is requested by CMA then check that all the\n\t * pages requested were isolated. If there were any failures, 0 is\n\t * returned and CMA will fail.\n\t */\n\tif (strict && blockpfn < end_pfn)\n\t\ttotal_isolated = 0;\n\n\t/* Update the pageblock-skip if the whole pageblock was scanned */\n\tif (blockpfn == end_pfn)\n\t\tupdate_pageblock_skip(cc, valid_page, total_isolated, false);\n\n\tcc->total_free_scanned += nr_scanned;\n\tif (total_isolated)\n\t\tcount_compact_events(COMPACTISOLATED, total_isolated);\n\treturn total_isolated;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic unsigned long isolate_freepages_block(struct compact_control *cc,\n\t\t\t\tunsigned long *start_pfn,\n\t\t\t\tunsigned long end_pfn,\n\t\t\t\tstruct list_head *freelist,\n\t\t\t\tbool strict)\n{\n\tint nr_scanned = 0, total_isolated = 0;\n\tstruct page *cursor, *valid_page = NULL;\n\tunsigned long flags = 0;\n\tbool locked = false;\n\tunsigned long blockpfn = *start_pfn;\n\tunsigned int order;\n\n\tcursor = pfn_to_page(blockpfn);\n\n\t/* Isolate free pages. */\n\tfor (; blockpfn < end_pfn; blockpfn++, cursor++) {\n\t\tint isolated;\n\t\tstruct page *page = cursor;\n\n\t\t/*\n\t\t * Periodically drop the lock (if held) regardless of its\n\t\t * contention, to give chance to IRQs. Abort if fatal signal\n\t\t * pending or async compaction detects need_resched()\n\t\t */\n\t\tif (!(blockpfn % SWAP_CLUSTER_MAX)\n\t\t    && compact_unlock_should_abort(&cc->zone->lock, flags,\n\t\t\t\t\t\t\t\t&locked, cc))\n\t\t\tbreak;\n\n\t\tnr_scanned++;\n\t\tif (!pfn_valid_within(blockpfn))\n\t\t\tgoto isolate_fail;\n\n\t\tif (!valid_page)\n\t\t\tvalid_page = page;\n\n\t\t/*\n\t\t * For compound pages such as THP and hugetlbfs, we can save\n\t\t * potentially a lot of iterations if we skip them at once.\n\t\t * The check is racy, but we can consider only valid values\n\t\t * and the only danger is skipping too much.\n\t\t */\n\t\tif (PageCompound(page)) {\n\t\t\tconst unsigned int order = compound_order(page);\n\n\t\t\tif (likely(order < MAX_ORDER)) {\n\t\t\t\tblockpfn += (1UL << order) - 1;\n\t\t\t\tcursor += (1UL << order) - 1;\n\t\t\t}\n\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\tif (!PageBuddy(page))\n\t\t\tgoto isolate_fail;\n\n\t\t/*\n\t\t * If we already hold the lock, we can skip some rechecking.\n\t\t * Note that if we hold the lock now, checked_pageblock was\n\t\t * already set in some previous iteration (or strict is true),\n\t\t * so it is correct to skip the suitable migration target\n\t\t * recheck as well.\n\t\t */\n\t\tif (!locked) {\n\t\t\t/*\n\t\t\t * The zone lock must be held to isolate freepages.\n\t\t\t * Unfortunately this is a very coarse lock and can be\n\t\t\t * heavily contended if there are parallel allocations\n\t\t\t * or parallel compactions. For async compaction do not\n\t\t\t * spin on the lock and we acquire the lock as late as\n\t\t\t * possible.\n\t\t\t */\n\t\t\tlocked = compact_trylock_irqsave(&cc->zone->lock,\n\t\t\t\t\t\t\t\t&flags, cc);\n\t\t\tif (!locked)\n\t\t\t\tbreak;\n\n\t\t\t/* Recheck this is a buddy page under lock */\n\t\t\tif (!PageBuddy(page))\n\t\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\t/* Found a free page, will break it into order-0 pages */\n\t\torder = page_order(page);\n\t\tisolated = __isolate_free_page(page, order);\n\t\tif (!isolated)\n\t\t\tbreak;\n\t\tset_page_private(page, order);\n\n\t\ttotal_isolated += isolated;\n\t\tcc->nr_freepages += isolated;\n\t\tlist_add_tail(&page->lru, freelist);\n\n\t\tif (!strict && cc->nr_migratepages <= cc->nr_freepages) {\n\t\t\tblockpfn += isolated;\n\t\t\tbreak;\n\t\t}\n\t\t/* Advance to the end of split page */\n\t\tblockpfn += isolated - 1;\n\t\tcursor += isolated - 1;\n\t\tcontinue;\n\nisolate_fail:\n\t\tif (strict)\n\t\t\tbreak;\n\t\telse\n\t\t\tcontinue;\n\n\t}\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(&cc->zone->lock, flags);\n\n\t/*\n\t * There is a tiny chance that we have read bogus compound_order(),\n\t * so be careful to not go outside of the pageblock.\n\t */\n\tif (unlikely(blockpfn > end_pfn))\n\t\tblockpfn = end_pfn;\n\n\ttrace_mm_compaction_isolate_freepages(*start_pfn, blockpfn,\n\t\t\t\t\tnr_scanned, total_isolated);\n\n\t/* Record how far we have got within the block */\n\t*start_pfn = blockpfn;\n\n\t/*\n\t * If strict isolation is requested by CMA then check that all the\n\t * pages requested were isolated. If there were any failures, 0 is\n\t * returned and CMA will fail.\n\t */\n\tif (strict && blockpfn < end_pfn)\n\t\ttotal_isolated = 0;\n\n\t/* Update the pageblock-skip if the whole pageblock was scanned */\n\tif (blockpfn == end_pfn)\n\t\tupdate_pageblock_skip(cc, valid_page, total_isolated, false);\n\n\tcc->total_free_scanned += nr_scanned;\n\tif (total_isolated)\n\t\tcount_compact_events(COMPACTISOLATED, total_isolated);\n\treturn total_isolated;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isolation_suitable",
          "args": [
            "cc",
            "page"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "isolation_suitable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "325-329",
          "snippet": "static inline bool isolation_suitable(struct compact_control *cc,\n\t\t\t\t\tstruct page *page)\n{\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline bool isolation_suitable(struct compact_control *cc,\n\t\t\t\t\tstruct page *page)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "suitable_migration_target",
          "args": [
            "cc",
            "page"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "suitable_migration_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1028-1051",
          "snippet": "static bool suitable_migration_target(struct compact_control *cc,\n\t\t\t\t\t\t\tstruct page *page)\n{\n\t/* If the page is a large free page, then disallow migration */\n\tif (PageBuddy(page)) {\n\t\t/*\n\t\t * We are checking page_order without zone->lock taken. But\n\t\t * the only small danger is that we skip a potentially suitable\n\t\t * pageblock, so it's not worth to check order for valid range.\n\t\t */\n\t\tif (page_order_unsafe(page) >= pageblock_order)\n\t\t\treturn false;\n\t}\n\n\tif (cc->ignore_block_suitable)\n\t\treturn true;\n\n\t/* If the block is MIGRATE_MOVABLE or MIGRATE_CMA, allow migration */\n\tif (is_migrate_movable(get_pageblock_migratetype(page)))\n\t\treturn true;\n\n\t/* Otherwise skip the block */\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic bool suitable_migration_target(struct compact_control *cc,\n\t\t\t\t\t\t\tstruct page *page)\n{\n\t/* If the page is a large free page, then disallow migration */\n\tif (PageBuddy(page)) {\n\t\t/*\n\t\t * We are checking page_order without zone->lock taken. But\n\t\t * the only small danger is that we skip a potentially suitable\n\t\t * pageblock, so it's not worth to check order for valid range.\n\t\t */\n\t\tif (page_order_unsafe(page) >= pageblock_order)\n\t\t\treturn false;\n\t}\n\n\tif (cc->ignore_block_suitable)\n\t\treturn true;\n\n\t/* If the block is MIGRATE_MOVABLE or MIGRATE_CMA, allow migration */\n\tif (is_migrate_movable(get_pageblock_migratetype(page)))\n\t\treturn true;\n\n\t/* Otherwise skip the block */\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pageblock_pfn_to_page",
          "args": [
            "block_start_pfn",
            "block_end_pfn",
            "zone"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "__pageblock_pfn_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1366-1392",
          "snippet": "struct page *__pageblock_pfn_to_page(unsigned long start_pfn,\n\t\t\t\t     unsigned long end_pfn, struct zone *zone)\n{\n\tstruct page *start_page;\n\tstruct page *end_page;\n\n\t/* end_pfn is one past the range we are checking */\n\tend_pfn--;\n\n\tif (!pfn_valid(start_pfn) || !pfn_valid(end_pfn))\n\t\treturn NULL;\n\n\tstart_page = pfn_to_online_page(start_pfn);\n\tif (!start_page)\n\t\treturn NULL;\n\n\tif (page_zone(start_page) != zone)\n\t\treturn NULL;\n\n\tend_page = pfn_to_page(end_pfn);\n\n\t/* This gives a shorter code than deriving page_zone(end_page) */\n\tif (page_zone_id(start_page) != page_zone_id(end_page))\n\t\treturn NULL;\n\n\treturn start_page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstruct page *__pageblock_pfn_to_page(unsigned long start_pfn,\n\t\t\t\t     unsigned long end_pfn, struct zone *zone)\n{\n\tstruct page *start_page;\n\tstruct page *end_page;\n\n\t/* end_pfn is one past the range we are checking */\n\tend_pfn--;\n\n\tif (!pfn_valid(start_pfn) || !pfn_valid(end_pfn))\n\t\treturn NULL;\n\n\tstart_page = pfn_to_online_page(start_pfn);\n\tif (!start_page)\n\t\treturn NULL;\n\n\tif (page_zone(start_page) != zone)\n\t\treturn NULL;\n\n\tend_page = pfn_to_page(end_pfn);\n\n\t/* This gives a shorter code than deriving page_zone(end_page) */\n\tif (page_zone_id(start_page) != page_zone_id(end_page))\n\t\treturn NULL;\n\n\treturn start_page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact_should_abort",
          "args": [
            "cc"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "compact_should_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "414-427",
          "snippet": "static inline bool compact_should_abort(struct compact_control *cc)\n{\n\t/* async compaction aborts if contended */\n\tif (need_resched()) {\n\t\tif (cc->mode == MIGRATE_ASYNC) {\n\t\t\tcc->contended = true;\n\t\t\treturn true;\n\t\t}\n\n\t\tcond_resched();\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline bool compact_should_abort(struct compact_control *cc)\n{\n\t/* async compaction aborts if contended */\n\tif (need_resched()) {\n\t\tif (cc->mode == MIGRATE_ASYNC) {\n\t\t\tcc->contended = true;\n\t\t\treturn true;\n\t\t}\n\n\t\tcond_resched();\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pageblock_end_pfn",
          "args": [
            "cc->migrate_pfn"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "block_start_pfn + pageblock_nr_pages",
            "zone_end_pfn(zone)"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_end_pfn",
          "args": [
            "zone"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pageblock_start_pfn",
          "args": [
            "cc->free_pfn"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic void isolate_freepages(struct compact_control *cc)\n{\n\tstruct zone *zone = cc->zone;\n\tstruct page *page;\n\tunsigned long block_start_pfn;\t/* start of current pageblock */\n\tunsigned long isolate_start_pfn; /* exact pfn we start at */\n\tunsigned long block_end_pfn;\t/* end of current pageblock */\n\tunsigned long low_pfn;\t     /* lowest pfn scanner is able to scan */\n\tstruct list_head *freelist = &cc->freepages;\n\n\t/*\n\t * Initialise the free scanner. The starting point is where we last\n\t * successfully isolated from, zone-cached value, or the end of the\n\t * zone when isolating for the first time. For looping we also need\n\t * this pfn aligned down to the pageblock boundary, because we do\n\t * block_start_pfn -= pageblock_nr_pages in the for loop.\n\t * For ending point, take care when isolating in last pageblock of a\n\t * a zone which ends in the middle of a pageblock.\n\t * The low boundary is the end of the pageblock the migration scanner\n\t * is using.\n\t */\n\tisolate_start_pfn = cc->free_pfn;\n\tblock_start_pfn = pageblock_start_pfn(cc->free_pfn);\n\tblock_end_pfn = min(block_start_pfn + pageblock_nr_pages,\n\t\t\t\t\t\tzone_end_pfn(zone));\n\tlow_pfn = pageblock_end_pfn(cc->migrate_pfn);\n\n\t/*\n\t * Isolate free pages until enough are available to migrate the\n\t * pages on cc->migratepages. We stop searching if the migrate\n\t * and free page scanners meet or enough free pages are isolated.\n\t */\n\tfor (; block_start_pfn >= low_pfn;\n\t\t\t\tblock_end_pfn = block_start_pfn,\n\t\t\t\tblock_start_pfn -= pageblock_nr_pages,\n\t\t\t\tisolate_start_pfn = block_start_pfn) {\n\t\t/*\n\t\t * This can iterate a massively long zone without finding any\n\t\t * suitable migration targets, so periodically check if we need\n\t\t * to schedule, or even abort async compaction.\n\t\t */\n\t\tif (!(block_start_pfn % (SWAP_CLUSTER_MAX * pageblock_nr_pages))\n\t\t\t\t\t\t&& compact_should_abort(cc))\n\t\t\tbreak;\n\n\t\tpage = pageblock_pfn_to_page(block_start_pfn, block_end_pfn,\n\t\t\t\t\t\t\t\t\tzone);\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\t/* Check the block is suitable for migration */\n\t\tif (!suitable_migration_target(cc, page))\n\t\t\tcontinue;\n\n\t\t/* If isolation recently failed, do not retry */\n\t\tif (!isolation_suitable(cc, page))\n\t\t\tcontinue;\n\n\t\t/* Found a block suitable for isolating free pages from. */\n\t\tisolate_freepages_block(cc, &isolate_start_pfn, block_end_pfn,\n\t\t\t\t\tfreelist, false);\n\n\t\t/*\n\t\t * If we isolated enough freepages, or aborted due to lock\n\t\t * contention, terminate.\n\t\t */\n\t\tif ((cc->nr_freepages >= cc->nr_migratepages)\n\t\t\t\t\t\t\t|| cc->contended) {\n\t\t\tif (isolate_start_pfn >= block_end_pfn) {\n\t\t\t\t/*\n\t\t\t\t * Restart at previous pageblock if more\n\t\t\t\t * freepages can be isolated next time.\n\t\t\t\t */\n\t\t\t\tisolate_start_pfn =\n\t\t\t\t\tblock_start_pfn - pageblock_nr_pages;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (isolate_start_pfn < block_end_pfn) {\n\t\t\t/*\n\t\t\t * If isolation failed early, do not continue\n\t\t\t * needlessly.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* __isolate_free_page() does not map the pages */\n\tmap_pages(freelist);\n\n\t/*\n\t * Record where the free scanner will restart next time. Either we\n\t * broke from the loop and set isolate_start_pfn based on the last\n\t * call to isolate_freepages_block(), or we met the migration scanner\n\t * and the loop terminated due to isolate_start_pfn < low_pfn\n\t */\n\tcc->free_pfn = isolate_start_pfn;\n}"
  },
  {
    "function_name": "compact_scanners_met",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "1057-1061",
    "snippet": "static inline bool compact_scanners_met(struct compact_control *cc)\n{\n\treturn (cc->free_pfn >> pageblock_order)\n\t\t<= (cc->migrate_pfn >> pageblock_order);\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline bool compact_scanners_met(struct compact_control *cc)\n{\n\treturn (cc->free_pfn >> pageblock_order)\n\t\t<= (cc->migrate_pfn >> pageblock_order);\n}"
  },
  {
    "function_name": "suitable_migration_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "1028-1051",
    "snippet": "static bool suitable_migration_target(struct compact_control *cc,\n\t\t\t\t\t\t\tstruct page *page)\n{\n\t/* If the page is a large free page, then disallow migration */\n\tif (PageBuddy(page)) {\n\t\t/*\n\t\t * We are checking page_order without zone->lock taken. But\n\t\t * the only small danger is that we skip a potentially suitable\n\t\t * pageblock, so it's not worth to check order for valid range.\n\t\t */\n\t\tif (page_order_unsafe(page) >= pageblock_order)\n\t\t\treturn false;\n\t}\n\n\tif (cc->ignore_block_suitable)\n\t\treturn true;\n\n\t/* If the block is MIGRATE_MOVABLE or MIGRATE_CMA, allow migration */\n\tif (is_migrate_movable(get_pageblock_migratetype(page)))\n\t\treturn true;\n\n\t/* Otherwise skip the block */\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_migrate_movable",
          "args": [
            "get_pageblock_migratetype(page)"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pageblock_migratetype",
          "args": [
            "page"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_order_unsafe",
          "args": [
            "page"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageBuddy",
          "args": [
            "page"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic bool suitable_migration_target(struct compact_control *cc,\n\t\t\t\t\t\t\tstruct page *page)\n{\n\t/* If the page is a large free page, then disallow migration */\n\tif (PageBuddy(page)) {\n\t\t/*\n\t\t * We are checking page_order without zone->lock taken. But\n\t\t * the only small danger is that we skip a potentially suitable\n\t\t * pageblock, so it's not worth to check order for valid range.\n\t\t */\n\t\tif (page_order_unsafe(page) >= pageblock_order)\n\t\t\treturn false;\n\t}\n\n\tif (cc->ignore_block_suitable)\n\t\treturn true;\n\n\t/* If the block is MIGRATE_MOVABLE or MIGRATE_CMA, allow migration */\n\tif (is_migrate_movable(get_pageblock_migratetype(page)))\n\t\treturn true;\n\n\t/* Otherwise skip the block */\n\treturn false;\n}"
  },
  {
    "function_name": "suitable_migration_source",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "1011-1025",
    "snippet": "static bool suitable_migration_source(struct compact_control *cc,\n\t\t\t\t\t\t\tstruct page *page)\n{\n\tint block_mt;\n\n\tif ((cc->mode != MIGRATE_ASYNC) || !cc->direct_compaction)\n\t\treturn true;\n\n\tblock_mt = get_pageblock_migratetype(page);\n\n\tif (cc->migratetype == MIGRATE_MOVABLE)\n\t\treturn is_migrate_movable(block_mt);\n\telse\n\t\treturn block_mt == cc->migratetype;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_migrate_movable",
          "args": [
            "block_mt"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pageblock_migratetype",
          "args": [
            "page"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic bool suitable_migration_source(struct compact_control *cc,\n\t\t\t\t\t\t\tstruct page *page)\n{\n\tint block_mt;\n\n\tif ((cc->mode != MIGRATE_ASYNC) || !cc->direct_compaction)\n\t\treturn true;\n\n\tblock_mt = get_pageblock_migratetype(page);\n\n\tif (cc->migratetype == MIGRATE_MOVABLE)\n\t\treturn is_migrate_movable(block_mt);\n\telse\n\t\treturn block_mt == cc->migratetype;\n}"
  },
  {
    "function_name": "isolate_migratepages_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "972-1006",
    "snippet": "unsigned long\nisolate_migratepages_range(struct compact_control *cc, unsigned long start_pfn,\n\t\t\t\t\t\t\tunsigned long end_pfn)\n{\n\tunsigned long pfn, block_start_pfn, block_end_pfn;\n\n\t/* Scan block by block. First and last block may be incomplete */\n\tpfn = start_pfn;\n\tblock_start_pfn = pageblock_start_pfn(pfn);\n\tif (block_start_pfn < cc->zone->zone_start_pfn)\n\t\tblock_start_pfn = cc->zone->zone_start_pfn;\n\tblock_end_pfn = pageblock_end_pfn(pfn);\n\n\tfor (; pfn < end_pfn; pfn = block_end_pfn,\n\t\t\t\tblock_start_pfn = block_end_pfn,\n\t\t\t\tblock_end_pfn += pageblock_nr_pages) {\n\n\t\tblock_end_pfn = min(block_end_pfn, end_pfn);\n\n\t\tif (!pageblock_pfn_to_page(block_start_pfn,\n\t\t\t\t\tblock_end_pfn, cc->zone))\n\t\t\tcontinue;\n\n\t\tpfn = isolate_migratepages_block(cc, pfn, block_end_pfn,\n\t\t\t\t\t\t\tISOLATE_UNEVICTABLE);\n\n\t\tif (!pfn)\n\t\t\tbreak;\n\n\t\tif (cc->nr_migratepages == COMPACT_CLUSTER_MAX)\n\t\t\tbreak;\n\t}\n\n\treturn pfn;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isolate_migratepages_block",
          "args": [
            "cc",
            "pfn",
            "block_end_pfn",
            "ISOLATE_UNEVICTABLE"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_migratepages_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "692-960",
          "snippet": "static unsigned long\nisolate_migratepages_block(struct compact_control *cc, unsigned long low_pfn,\n\t\t\tunsigned long end_pfn, isolate_mode_t isolate_mode)\n{\n\tstruct zone *zone = cc->zone;\n\tunsigned long nr_scanned = 0, nr_isolated = 0;\n\tstruct lruvec *lruvec;\n\tunsigned long flags = 0;\n\tbool locked = false;\n\tstruct page *page = NULL, *valid_page = NULL;\n\tunsigned long start_pfn = low_pfn;\n\tbool skip_on_failure = false;\n\tunsigned long next_skip_pfn = 0;\n\n\t/*\n\t * Ensure that there are not too many pages isolated from the LRU\n\t * list by either parallel reclaimers or compaction. If there are,\n\t * delay for some time until fewer pages are isolated\n\t */\n\twhile (unlikely(too_many_isolated(zone))) {\n\t\t/* async migration should just abort */\n\t\tif (cc->mode == MIGRATE_ASYNC)\n\t\t\treturn 0;\n\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/10);\n\n\t\tif (fatal_signal_pending(current))\n\t\t\treturn 0;\n\t}\n\n\tif (compact_should_abort(cc))\n\t\treturn 0;\n\n\tif (cc->direct_compaction && (cc->mode == MIGRATE_ASYNC)) {\n\t\tskip_on_failure = true;\n\t\tnext_skip_pfn = block_end_pfn(low_pfn, cc->order);\n\t}\n\n\t/* Time to isolate some pages for migration */\n\tfor (; low_pfn < end_pfn; low_pfn++) {\n\n\t\tif (skip_on_failure && low_pfn >= next_skip_pfn) {\n\t\t\t/*\n\t\t\t * We have isolated all migration candidates in the\n\t\t\t * previous order-aligned block, and did not skip it due\n\t\t\t * to failure. We should migrate the pages now and\n\t\t\t * hopefully succeed compaction.\n\t\t\t */\n\t\t\tif (nr_isolated)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * We failed to isolate in the previous order-aligned\n\t\t\t * block. Set the new boundary to the end of the\n\t\t\t * current block. Note we can't simply increase\n\t\t\t * next_skip_pfn by 1 << order, as low_pfn might have\n\t\t\t * been incremented by a higher number due to skipping\n\t\t\t * a compound or a high-order buddy page in the\n\t\t\t * previous loop iteration.\n\t\t\t */\n\t\t\tnext_skip_pfn = block_end_pfn(low_pfn, cc->order);\n\t\t}\n\n\t\t/*\n\t\t * Periodically drop the lock (if held) regardless of its\n\t\t * contention, to give chance to IRQs. Abort async compaction\n\t\t * if contended.\n\t\t */\n\t\tif (!(low_pfn % SWAP_CLUSTER_MAX)\n\t\t    && compact_unlock_should_abort(zone_lru_lock(zone), flags,\n\t\t\t\t\t\t\t\t&locked, cc))\n\t\t\tbreak;\n\n\t\tif (!pfn_valid_within(low_pfn))\n\t\t\tgoto isolate_fail;\n\t\tnr_scanned++;\n\n\t\tpage = pfn_to_page(low_pfn);\n\n\t\tif (!valid_page)\n\t\t\tvalid_page = page;\n\n\t\t/*\n\t\t * Skip if free. We read page order here without zone lock\n\t\t * which is generally unsafe, but the race window is small and\n\t\t * the worst thing that can happen is that we skip some\n\t\t * potential isolation targets.\n\t\t */\n\t\tif (PageBuddy(page)) {\n\t\t\tunsigned long freepage_order = page_order_unsafe(page);\n\n\t\t\t/*\n\t\t\t * Without lock, we cannot be sure that what we got is\n\t\t\t * a valid page order. Consider only values in the\n\t\t\t * valid order range to prevent low_pfn overflow.\n\t\t\t */\n\t\t\tif (freepage_order > 0 && freepage_order < MAX_ORDER)\n\t\t\t\tlow_pfn += (1UL << freepage_order) - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Regardless of being on LRU, compound pages such as THP and\n\t\t * hugetlbfs are not to be compacted. We can potentially save\n\t\t * a lot of iterations if we skip them at once. The check is\n\t\t * racy, but we can consider only valid values and the only\n\t\t * danger is skipping too much.\n\t\t */\n\t\tif (PageCompound(page)) {\n\t\t\tconst unsigned int order = compound_order(page);\n\n\t\t\tif (likely(order < MAX_ORDER))\n\t\t\t\tlow_pfn += (1UL << order) - 1;\n\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\t/*\n\t\t * Check may be lockless but that's ok as we recheck later.\n\t\t * It's possible to migrate LRU and non-lru movable pages.\n\t\t * Skip any other type of page\n\t\t */\n\t\tif (!PageLRU(page)) {\n\t\t\t/*\n\t\t\t * __PageMovable can return false positive so we need\n\t\t\t * to verify it under page_lock.\n\t\t\t */\n\t\t\tif (unlikely(__PageMovable(page)) &&\n\t\t\t\t\t!PageIsolated(page)) {\n\t\t\t\tif (locked) {\n\t\t\t\t\tspin_unlock_irqrestore(zone_lru_lock(zone),\n\t\t\t\t\t\t\t\t\tflags);\n\t\t\t\t\tlocked = false;\n\t\t\t\t}\n\n\t\t\t\tif (!isolate_movable_page(page, isolate_mode))\n\t\t\t\t\tgoto isolate_success;\n\t\t\t}\n\n\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\t/*\n\t\t * Migration will fail if an anonymous page is pinned in memory,\n\t\t * so avoid taking lru_lock and isolating it unnecessarily in an\n\t\t * admittedly racy check.\n\t\t */\n\t\tif (!page_mapping(page) &&\n\t\t    page_count(page) > page_mapcount(page))\n\t\t\tgoto isolate_fail;\n\n\t\t/*\n\t\t * Only allow to migrate anonymous pages in GFP_NOFS context\n\t\t * because those do not depend on fs locks.\n\t\t */\n\t\tif (!(cc->gfp_mask & __GFP_FS) && page_mapping(page))\n\t\t\tgoto isolate_fail;\n\n\t\t/* If we already hold the lock, we can skip some rechecking */\n\t\tif (!locked) {\n\t\t\tlocked = compact_trylock_irqsave(zone_lru_lock(zone),\n\t\t\t\t\t\t\t\t&flags, cc);\n\t\t\tif (!locked)\n\t\t\t\tbreak;\n\n\t\t\t/* Recheck PageLRU and PageCompound under lock */\n\t\t\tif (!PageLRU(page))\n\t\t\t\tgoto isolate_fail;\n\n\t\t\t/*\n\t\t\t * Page become compound since the non-locked check,\n\t\t\t * and it's on LRU. It can only be a THP so the order\n\t\t\t * is safe to read and it's 0 for tail pages.\n\t\t\t */\n\t\t\tif (unlikely(PageCompound(page))) {\n\t\t\t\tlow_pfn += (1UL << compound_order(page)) - 1;\n\t\t\t\tgoto isolate_fail;\n\t\t\t}\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\n\t\t/* Try isolate the page */\n\t\tif (__isolate_lru_page(page, isolate_mode) != 0)\n\t\t\tgoto isolate_fail;\n\n\t\tVM_BUG_ON_PAGE(PageCompound(page), page);\n\n\t\t/* Successfully isolated */\n\t\tdel_page_from_lru_list(page, lruvec, page_lru(page));\n\t\tinc_node_page_state(page,\n\t\t\t\tNR_ISOLATED_ANON + page_is_file_cache(page));\n\nisolate_success:\n\t\tlist_add(&page->lru, &cc->migratepages);\n\t\tcc->nr_migratepages++;\n\t\tnr_isolated++;\n\n\t\t/*\n\t\t * Record where we could have freed pages by migration and not\n\t\t * yet flushed them to buddy allocator.\n\t\t * - this is the lowest page that was isolated and likely be\n\t\t * then freed by migration.\n\t\t */\n\t\tif (!cc->last_migrated_pfn)\n\t\t\tcc->last_migrated_pfn = low_pfn;\n\n\t\t/* Avoid isolating too much */\n\t\tif (cc->nr_migratepages == COMPACT_CLUSTER_MAX) {\n\t\t\t++low_pfn;\n\t\t\tbreak;\n\t\t}\n\n\t\tcontinue;\nisolate_fail:\n\t\tif (!skip_on_failure)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We have isolated some pages, but then failed. Release them\n\t\t * instead of migrating, as we cannot form the cc->order buddy\n\t\t * page anyway.\n\t\t */\n\t\tif (nr_isolated) {\n\t\t\tif (locked) {\n\t\t\t\tspin_unlock_irqrestore(zone_lru_lock(zone), flags);\n\t\t\t\tlocked = false;\n\t\t\t}\n\t\t\tputback_movable_pages(&cc->migratepages);\n\t\t\tcc->nr_migratepages = 0;\n\t\t\tcc->last_migrated_pfn = 0;\n\t\t\tnr_isolated = 0;\n\t\t}\n\n\t\tif (low_pfn < next_skip_pfn) {\n\t\t\tlow_pfn = next_skip_pfn - 1;\n\t\t\t/*\n\t\t\t * The check near the loop beginning would have updated\n\t\t\t * next_skip_pfn too, but this is a bit simpler.\n\t\t\t */\n\t\t\tnext_skip_pfn += 1UL << cc->order;\n\t\t}\n\t}\n\n\t/*\n\t * The PageBuddy() check could have potentially brought us outside\n\t * the range to be scanned.\n\t */\n\tif (unlikely(low_pfn > end_pfn))\n\t\tlow_pfn = end_pfn;\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(zone_lru_lock(zone), flags);\n\n\t/*\n\t * Update the pageblock-skip information and cached scanner pfn,\n\t * if the whole pageblock was scanned without isolating any page.\n\t */\n\tif (low_pfn == end_pfn)\n\t\tupdate_pageblock_skip(cc, valid_page, nr_isolated, true);\n\n\ttrace_mm_compaction_isolate_migratepages(start_pfn, low_pfn,\n\t\t\t\t\t\tnr_scanned, nr_isolated);\n\n\tcc->total_migrate_scanned += nr_scanned;\n\tif (nr_isolated)\n\t\tcount_compact_events(COMPACTISOLATED, nr_isolated);\n\n\treturn low_pfn;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic unsigned long\nisolate_migratepages_block(struct compact_control *cc, unsigned long low_pfn,\n\t\t\tunsigned long end_pfn, isolate_mode_t isolate_mode)\n{\n\tstruct zone *zone = cc->zone;\n\tunsigned long nr_scanned = 0, nr_isolated = 0;\n\tstruct lruvec *lruvec;\n\tunsigned long flags = 0;\n\tbool locked = false;\n\tstruct page *page = NULL, *valid_page = NULL;\n\tunsigned long start_pfn = low_pfn;\n\tbool skip_on_failure = false;\n\tunsigned long next_skip_pfn = 0;\n\n\t/*\n\t * Ensure that there are not too many pages isolated from the LRU\n\t * list by either parallel reclaimers or compaction. If there are,\n\t * delay for some time until fewer pages are isolated\n\t */\n\twhile (unlikely(too_many_isolated(zone))) {\n\t\t/* async migration should just abort */\n\t\tif (cc->mode == MIGRATE_ASYNC)\n\t\t\treturn 0;\n\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/10);\n\n\t\tif (fatal_signal_pending(current))\n\t\t\treturn 0;\n\t}\n\n\tif (compact_should_abort(cc))\n\t\treturn 0;\n\n\tif (cc->direct_compaction && (cc->mode == MIGRATE_ASYNC)) {\n\t\tskip_on_failure = true;\n\t\tnext_skip_pfn = block_end_pfn(low_pfn, cc->order);\n\t}\n\n\t/* Time to isolate some pages for migration */\n\tfor (; low_pfn < end_pfn; low_pfn++) {\n\n\t\tif (skip_on_failure && low_pfn >= next_skip_pfn) {\n\t\t\t/*\n\t\t\t * We have isolated all migration candidates in the\n\t\t\t * previous order-aligned block, and did not skip it due\n\t\t\t * to failure. We should migrate the pages now and\n\t\t\t * hopefully succeed compaction.\n\t\t\t */\n\t\t\tif (nr_isolated)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * We failed to isolate in the previous order-aligned\n\t\t\t * block. Set the new boundary to the end of the\n\t\t\t * current block. Note we can't simply increase\n\t\t\t * next_skip_pfn by 1 << order, as low_pfn might have\n\t\t\t * been incremented by a higher number due to skipping\n\t\t\t * a compound or a high-order buddy page in the\n\t\t\t * previous loop iteration.\n\t\t\t */\n\t\t\tnext_skip_pfn = block_end_pfn(low_pfn, cc->order);\n\t\t}\n\n\t\t/*\n\t\t * Periodically drop the lock (if held) regardless of its\n\t\t * contention, to give chance to IRQs. Abort async compaction\n\t\t * if contended.\n\t\t */\n\t\tif (!(low_pfn % SWAP_CLUSTER_MAX)\n\t\t    && compact_unlock_should_abort(zone_lru_lock(zone), flags,\n\t\t\t\t\t\t\t\t&locked, cc))\n\t\t\tbreak;\n\n\t\tif (!pfn_valid_within(low_pfn))\n\t\t\tgoto isolate_fail;\n\t\tnr_scanned++;\n\n\t\tpage = pfn_to_page(low_pfn);\n\n\t\tif (!valid_page)\n\t\t\tvalid_page = page;\n\n\t\t/*\n\t\t * Skip if free. We read page order here without zone lock\n\t\t * which is generally unsafe, but the race window is small and\n\t\t * the worst thing that can happen is that we skip some\n\t\t * potential isolation targets.\n\t\t */\n\t\tif (PageBuddy(page)) {\n\t\t\tunsigned long freepage_order = page_order_unsafe(page);\n\n\t\t\t/*\n\t\t\t * Without lock, we cannot be sure that what we got is\n\t\t\t * a valid page order. Consider only values in the\n\t\t\t * valid order range to prevent low_pfn overflow.\n\t\t\t */\n\t\t\tif (freepage_order > 0 && freepage_order < MAX_ORDER)\n\t\t\t\tlow_pfn += (1UL << freepage_order) - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Regardless of being on LRU, compound pages such as THP and\n\t\t * hugetlbfs are not to be compacted. We can potentially save\n\t\t * a lot of iterations if we skip them at once. The check is\n\t\t * racy, but we can consider only valid values and the only\n\t\t * danger is skipping too much.\n\t\t */\n\t\tif (PageCompound(page)) {\n\t\t\tconst unsigned int order = compound_order(page);\n\n\t\t\tif (likely(order < MAX_ORDER))\n\t\t\t\tlow_pfn += (1UL << order) - 1;\n\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\t/*\n\t\t * Check may be lockless but that's ok as we recheck later.\n\t\t * It's possible to migrate LRU and non-lru movable pages.\n\t\t * Skip any other type of page\n\t\t */\n\t\tif (!PageLRU(page)) {\n\t\t\t/*\n\t\t\t * __PageMovable can return false positive so we need\n\t\t\t * to verify it under page_lock.\n\t\t\t */\n\t\t\tif (unlikely(__PageMovable(page)) &&\n\t\t\t\t\t!PageIsolated(page)) {\n\t\t\t\tif (locked) {\n\t\t\t\t\tspin_unlock_irqrestore(zone_lru_lock(zone),\n\t\t\t\t\t\t\t\t\tflags);\n\t\t\t\t\tlocked = false;\n\t\t\t\t}\n\n\t\t\t\tif (!isolate_movable_page(page, isolate_mode))\n\t\t\t\t\tgoto isolate_success;\n\t\t\t}\n\n\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\t/*\n\t\t * Migration will fail if an anonymous page is pinned in memory,\n\t\t * so avoid taking lru_lock and isolating it unnecessarily in an\n\t\t * admittedly racy check.\n\t\t */\n\t\tif (!page_mapping(page) &&\n\t\t    page_count(page) > page_mapcount(page))\n\t\t\tgoto isolate_fail;\n\n\t\t/*\n\t\t * Only allow to migrate anonymous pages in GFP_NOFS context\n\t\t * because those do not depend on fs locks.\n\t\t */\n\t\tif (!(cc->gfp_mask & __GFP_FS) && page_mapping(page))\n\t\t\tgoto isolate_fail;\n\n\t\t/* If we already hold the lock, we can skip some rechecking */\n\t\tif (!locked) {\n\t\t\tlocked = compact_trylock_irqsave(zone_lru_lock(zone),\n\t\t\t\t\t\t\t\t&flags, cc);\n\t\t\tif (!locked)\n\t\t\t\tbreak;\n\n\t\t\t/* Recheck PageLRU and PageCompound under lock */\n\t\t\tif (!PageLRU(page))\n\t\t\t\tgoto isolate_fail;\n\n\t\t\t/*\n\t\t\t * Page become compound since the non-locked check,\n\t\t\t * and it's on LRU. It can only be a THP so the order\n\t\t\t * is safe to read and it's 0 for tail pages.\n\t\t\t */\n\t\t\tif (unlikely(PageCompound(page))) {\n\t\t\t\tlow_pfn += (1UL << compound_order(page)) - 1;\n\t\t\t\tgoto isolate_fail;\n\t\t\t}\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\n\t\t/* Try isolate the page */\n\t\tif (__isolate_lru_page(page, isolate_mode) != 0)\n\t\t\tgoto isolate_fail;\n\n\t\tVM_BUG_ON_PAGE(PageCompound(page), page);\n\n\t\t/* Successfully isolated */\n\t\tdel_page_from_lru_list(page, lruvec, page_lru(page));\n\t\tinc_node_page_state(page,\n\t\t\t\tNR_ISOLATED_ANON + page_is_file_cache(page));\n\nisolate_success:\n\t\tlist_add(&page->lru, &cc->migratepages);\n\t\tcc->nr_migratepages++;\n\t\tnr_isolated++;\n\n\t\t/*\n\t\t * Record where we could have freed pages by migration and not\n\t\t * yet flushed them to buddy allocator.\n\t\t * - this is the lowest page that was isolated and likely be\n\t\t * then freed by migration.\n\t\t */\n\t\tif (!cc->last_migrated_pfn)\n\t\t\tcc->last_migrated_pfn = low_pfn;\n\n\t\t/* Avoid isolating too much */\n\t\tif (cc->nr_migratepages == COMPACT_CLUSTER_MAX) {\n\t\t\t++low_pfn;\n\t\t\tbreak;\n\t\t}\n\n\t\tcontinue;\nisolate_fail:\n\t\tif (!skip_on_failure)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We have isolated some pages, but then failed. Release them\n\t\t * instead of migrating, as we cannot form the cc->order buddy\n\t\t * page anyway.\n\t\t */\n\t\tif (nr_isolated) {\n\t\t\tif (locked) {\n\t\t\t\tspin_unlock_irqrestore(zone_lru_lock(zone), flags);\n\t\t\t\tlocked = false;\n\t\t\t}\n\t\t\tputback_movable_pages(&cc->migratepages);\n\t\t\tcc->nr_migratepages = 0;\n\t\t\tcc->last_migrated_pfn = 0;\n\t\t\tnr_isolated = 0;\n\t\t}\n\n\t\tif (low_pfn < next_skip_pfn) {\n\t\t\tlow_pfn = next_skip_pfn - 1;\n\t\t\t/*\n\t\t\t * The check near the loop beginning would have updated\n\t\t\t * next_skip_pfn too, but this is a bit simpler.\n\t\t\t */\n\t\t\tnext_skip_pfn += 1UL << cc->order;\n\t\t}\n\t}\n\n\t/*\n\t * The PageBuddy() check could have potentially brought us outside\n\t * the range to be scanned.\n\t */\n\tif (unlikely(low_pfn > end_pfn))\n\t\tlow_pfn = end_pfn;\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(zone_lru_lock(zone), flags);\n\n\t/*\n\t * Update the pageblock-skip information and cached scanner pfn,\n\t * if the whole pageblock was scanned without isolating any page.\n\t */\n\tif (low_pfn == end_pfn)\n\t\tupdate_pageblock_skip(cc, valid_page, nr_isolated, true);\n\n\ttrace_mm_compaction_isolate_migratepages(start_pfn, low_pfn,\n\t\t\t\t\t\tnr_scanned, nr_isolated);\n\n\tcc->total_migrate_scanned += nr_scanned;\n\tif (nr_isolated)\n\t\tcount_compact_events(COMPACTISOLATED, nr_isolated);\n\n\treturn low_pfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pageblock_pfn_to_page",
          "args": [
            "block_start_pfn",
            "block_end_pfn",
            "cc->zone"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "__pageblock_pfn_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1366-1392",
          "snippet": "struct page *__pageblock_pfn_to_page(unsigned long start_pfn,\n\t\t\t\t     unsigned long end_pfn, struct zone *zone)\n{\n\tstruct page *start_page;\n\tstruct page *end_page;\n\n\t/* end_pfn is one past the range we are checking */\n\tend_pfn--;\n\n\tif (!pfn_valid(start_pfn) || !pfn_valid(end_pfn))\n\t\treturn NULL;\n\n\tstart_page = pfn_to_online_page(start_pfn);\n\tif (!start_page)\n\t\treturn NULL;\n\n\tif (page_zone(start_page) != zone)\n\t\treturn NULL;\n\n\tend_page = pfn_to_page(end_pfn);\n\n\t/* This gives a shorter code than deriving page_zone(end_page) */\n\tif (page_zone_id(start_page) != page_zone_id(end_page))\n\t\treturn NULL;\n\n\treturn start_page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstruct page *__pageblock_pfn_to_page(unsigned long start_pfn,\n\t\t\t\t     unsigned long end_pfn, struct zone *zone)\n{\n\tstruct page *start_page;\n\tstruct page *end_page;\n\n\t/* end_pfn is one past the range we are checking */\n\tend_pfn--;\n\n\tif (!pfn_valid(start_pfn) || !pfn_valid(end_pfn))\n\t\treturn NULL;\n\n\tstart_page = pfn_to_online_page(start_pfn);\n\tif (!start_page)\n\t\treturn NULL;\n\n\tif (page_zone(start_page) != zone)\n\t\treturn NULL;\n\n\tend_page = pfn_to_page(end_pfn);\n\n\t/* This gives a shorter code than deriving page_zone(end_page) */\n\tif (page_zone_id(start_page) != page_zone_id(end_page))\n\t\treturn NULL;\n\n\treturn start_page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "block_end_pfn",
            "end_pfn"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pageblock_end_pfn",
          "args": [
            "pfn"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pageblock_start_pfn",
          "args": [
            "pfn"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nunsigned long\nisolate_migratepages_range(struct compact_control *cc, unsigned long start_pfn,\n\t\t\t\t\t\t\tunsigned long end_pfn)\n{\n\tunsigned long pfn, block_start_pfn, block_end_pfn;\n\n\t/* Scan block by block. First and last block may be incomplete */\n\tpfn = start_pfn;\n\tblock_start_pfn = pageblock_start_pfn(pfn);\n\tif (block_start_pfn < cc->zone->zone_start_pfn)\n\t\tblock_start_pfn = cc->zone->zone_start_pfn;\n\tblock_end_pfn = pageblock_end_pfn(pfn);\n\n\tfor (; pfn < end_pfn; pfn = block_end_pfn,\n\t\t\t\tblock_start_pfn = block_end_pfn,\n\t\t\t\tblock_end_pfn += pageblock_nr_pages) {\n\n\t\tblock_end_pfn = min(block_end_pfn, end_pfn);\n\n\t\tif (!pageblock_pfn_to_page(block_start_pfn,\n\t\t\t\t\tblock_end_pfn, cc->zone))\n\t\t\tcontinue;\n\n\t\tpfn = isolate_migratepages_block(cc, pfn, block_end_pfn,\n\t\t\t\t\t\t\tISOLATE_UNEVICTABLE);\n\n\t\tif (!pfn)\n\t\t\tbreak;\n\n\t\tif (cc->nr_migratepages == COMPACT_CLUSTER_MAX)\n\t\t\tbreak;\n\t}\n\n\treturn pfn;\n}"
  },
  {
    "function_name": "isolate_migratepages_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "692-960",
    "snippet": "static unsigned long\nisolate_migratepages_block(struct compact_control *cc, unsigned long low_pfn,\n\t\t\tunsigned long end_pfn, isolate_mode_t isolate_mode)\n{\n\tstruct zone *zone = cc->zone;\n\tunsigned long nr_scanned = 0, nr_isolated = 0;\n\tstruct lruvec *lruvec;\n\tunsigned long flags = 0;\n\tbool locked = false;\n\tstruct page *page = NULL, *valid_page = NULL;\n\tunsigned long start_pfn = low_pfn;\n\tbool skip_on_failure = false;\n\tunsigned long next_skip_pfn = 0;\n\n\t/*\n\t * Ensure that there are not too many pages isolated from the LRU\n\t * list by either parallel reclaimers or compaction. If there are,\n\t * delay for some time until fewer pages are isolated\n\t */\n\twhile (unlikely(too_many_isolated(zone))) {\n\t\t/* async migration should just abort */\n\t\tif (cc->mode == MIGRATE_ASYNC)\n\t\t\treturn 0;\n\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/10);\n\n\t\tif (fatal_signal_pending(current))\n\t\t\treturn 0;\n\t}\n\n\tif (compact_should_abort(cc))\n\t\treturn 0;\n\n\tif (cc->direct_compaction && (cc->mode == MIGRATE_ASYNC)) {\n\t\tskip_on_failure = true;\n\t\tnext_skip_pfn = block_end_pfn(low_pfn, cc->order);\n\t}\n\n\t/* Time to isolate some pages for migration */\n\tfor (; low_pfn < end_pfn; low_pfn++) {\n\n\t\tif (skip_on_failure && low_pfn >= next_skip_pfn) {\n\t\t\t/*\n\t\t\t * We have isolated all migration candidates in the\n\t\t\t * previous order-aligned block, and did not skip it due\n\t\t\t * to failure. We should migrate the pages now and\n\t\t\t * hopefully succeed compaction.\n\t\t\t */\n\t\t\tif (nr_isolated)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * We failed to isolate in the previous order-aligned\n\t\t\t * block. Set the new boundary to the end of the\n\t\t\t * current block. Note we can't simply increase\n\t\t\t * next_skip_pfn by 1 << order, as low_pfn might have\n\t\t\t * been incremented by a higher number due to skipping\n\t\t\t * a compound or a high-order buddy page in the\n\t\t\t * previous loop iteration.\n\t\t\t */\n\t\t\tnext_skip_pfn = block_end_pfn(low_pfn, cc->order);\n\t\t}\n\n\t\t/*\n\t\t * Periodically drop the lock (if held) regardless of its\n\t\t * contention, to give chance to IRQs. Abort async compaction\n\t\t * if contended.\n\t\t */\n\t\tif (!(low_pfn % SWAP_CLUSTER_MAX)\n\t\t    && compact_unlock_should_abort(zone_lru_lock(zone), flags,\n\t\t\t\t\t\t\t\t&locked, cc))\n\t\t\tbreak;\n\n\t\tif (!pfn_valid_within(low_pfn))\n\t\t\tgoto isolate_fail;\n\t\tnr_scanned++;\n\n\t\tpage = pfn_to_page(low_pfn);\n\n\t\tif (!valid_page)\n\t\t\tvalid_page = page;\n\n\t\t/*\n\t\t * Skip if free. We read page order here without zone lock\n\t\t * which is generally unsafe, but the race window is small and\n\t\t * the worst thing that can happen is that we skip some\n\t\t * potential isolation targets.\n\t\t */\n\t\tif (PageBuddy(page)) {\n\t\t\tunsigned long freepage_order = page_order_unsafe(page);\n\n\t\t\t/*\n\t\t\t * Without lock, we cannot be sure that what we got is\n\t\t\t * a valid page order. Consider only values in the\n\t\t\t * valid order range to prevent low_pfn overflow.\n\t\t\t */\n\t\t\tif (freepage_order > 0 && freepage_order < MAX_ORDER)\n\t\t\t\tlow_pfn += (1UL << freepage_order) - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Regardless of being on LRU, compound pages such as THP and\n\t\t * hugetlbfs are not to be compacted. We can potentially save\n\t\t * a lot of iterations if we skip them at once. The check is\n\t\t * racy, but we can consider only valid values and the only\n\t\t * danger is skipping too much.\n\t\t */\n\t\tif (PageCompound(page)) {\n\t\t\tconst unsigned int order = compound_order(page);\n\n\t\t\tif (likely(order < MAX_ORDER))\n\t\t\t\tlow_pfn += (1UL << order) - 1;\n\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\t/*\n\t\t * Check may be lockless but that's ok as we recheck later.\n\t\t * It's possible to migrate LRU and non-lru movable pages.\n\t\t * Skip any other type of page\n\t\t */\n\t\tif (!PageLRU(page)) {\n\t\t\t/*\n\t\t\t * __PageMovable can return false positive so we need\n\t\t\t * to verify it under page_lock.\n\t\t\t */\n\t\t\tif (unlikely(__PageMovable(page)) &&\n\t\t\t\t\t!PageIsolated(page)) {\n\t\t\t\tif (locked) {\n\t\t\t\t\tspin_unlock_irqrestore(zone_lru_lock(zone),\n\t\t\t\t\t\t\t\t\tflags);\n\t\t\t\t\tlocked = false;\n\t\t\t\t}\n\n\t\t\t\tif (!isolate_movable_page(page, isolate_mode))\n\t\t\t\t\tgoto isolate_success;\n\t\t\t}\n\n\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\t/*\n\t\t * Migration will fail if an anonymous page is pinned in memory,\n\t\t * so avoid taking lru_lock and isolating it unnecessarily in an\n\t\t * admittedly racy check.\n\t\t */\n\t\tif (!page_mapping(page) &&\n\t\t    page_count(page) > page_mapcount(page))\n\t\t\tgoto isolate_fail;\n\n\t\t/*\n\t\t * Only allow to migrate anonymous pages in GFP_NOFS context\n\t\t * because those do not depend on fs locks.\n\t\t */\n\t\tif (!(cc->gfp_mask & __GFP_FS) && page_mapping(page))\n\t\t\tgoto isolate_fail;\n\n\t\t/* If we already hold the lock, we can skip some rechecking */\n\t\tif (!locked) {\n\t\t\tlocked = compact_trylock_irqsave(zone_lru_lock(zone),\n\t\t\t\t\t\t\t\t&flags, cc);\n\t\t\tif (!locked)\n\t\t\t\tbreak;\n\n\t\t\t/* Recheck PageLRU and PageCompound under lock */\n\t\t\tif (!PageLRU(page))\n\t\t\t\tgoto isolate_fail;\n\n\t\t\t/*\n\t\t\t * Page become compound since the non-locked check,\n\t\t\t * and it's on LRU. It can only be a THP so the order\n\t\t\t * is safe to read and it's 0 for tail pages.\n\t\t\t */\n\t\t\tif (unlikely(PageCompound(page))) {\n\t\t\t\tlow_pfn += (1UL << compound_order(page)) - 1;\n\t\t\t\tgoto isolate_fail;\n\t\t\t}\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\n\t\t/* Try isolate the page */\n\t\tif (__isolate_lru_page(page, isolate_mode) != 0)\n\t\t\tgoto isolate_fail;\n\n\t\tVM_BUG_ON_PAGE(PageCompound(page), page);\n\n\t\t/* Successfully isolated */\n\t\tdel_page_from_lru_list(page, lruvec, page_lru(page));\n\t\tinc_node_page_state(page,\n\t\t\t\tNR_ISOLATED_ANON + page_is_file_cache(page));\n\nisolate_success:\n\t\tlist_add(&page->lru, &cc->migratepages);\n\t\tcc->nr_migratepages++;\n\t\tnr_isolated++;\n\n\t\t/*\n\t\t * Record where we could have freed pages by migration and not\n\t\t * yet flushed them to buddy allocator.\n\t\t * - this is the lowest page that was isolated and likely be\n\t\t * then freed by migration.\n\t\t */\n\t\tif (!cc->last_migrated_pfn)\n\t\t\tcc->last_migrated_pfn = low_pfn;\n\n\t\t/* Avoid isolating too much */\n\t\tif (cc->nr_migratepages == COMPACT_CLUSTER_MAX) {\n\t\t\t++low_pfn;\n\t\t\tbreak;\n\t\t}\n\n\t\tcontinue;\nisolate_fail:\n\t\tif (!skip_on_failure)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We have isolated some pages, but then failed. Release them\n\t\t * instead of migrating, as we cannot form the cc->order buddy\n\t\t * page anyway.\n\t\t */\n\t\tif (nr_isolated) {\n\t\t\tif (locked) {\n\t\t\t\tspin_unlock_irqrestore(zone_lru_lock(zone), flags);\n\t\t\t\tlocked = false;\n\t\t\t}\n\t\t\tputback_movable_pages(&cc->migratepages);\n\t\t\tcc->nr_migratepages = 0;\n\t\t\tcc->last_migrated_pfn = 0;\n\t\t\tnr_isolated = 0;\n\t\t}\n\n\t\tif (low_pfn < next_skip_pfn) {\n\t\t\tlow_pfn = next_skip_pfn - 1;\n\t\t\t/*\n\t\t\t * The check near the loop beginning would have updated\n\t\t\t * next_skip_pfn too, but this is a bit simpler.\n\t\t\t */\n\t\t\tnext_skip_pfn += 1UL << cc->order;\n\t\t}\n\t}\n\n\t/*\n\t * The PageBuddy() check could have potentially brought us outside\n\t * the range to be scanned.\n\t */\n\tif (unlikely(low_pfn > end_pfn))\n\t\tlow_pfn = end_pfn;\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(zone_lru_lock(zone), flags);\n\n\t/*\n\t * Update the pageblock-skip information and cached scanner pfn,\n\t * if the whole pageblock was scanned without isolating any page.\n\t */\n\tif (low_pfn == end_pfn)\n\t\tupdate_pageblock_skip(cc, valid_page, nr_isolated, true);\n\n\ttrace_mm_compaction_isolate_migratepages(start_pfn, low_pfn,\n\t\t\t\t\t\tnr_scanned, nr_isolated);\n\n\tcc->total_migrate_scanned += nr_scanned;\n\tif (nr_isolated)\n\t\tcount_compact_events(COMPACTISOLATED, nr_isolated);\n\n\treturn low_pfn;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "count_compact_events",
          "args": [
            "COMPACTISOLATED",
            "nr_isolated"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "count_compact_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "34-37",
          "snippet": "static inline void count_compact_events(enum vm_event_item item, long delta)\n{\n\tcount_vm_events(item, delta);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline void count_compact_events(enum vm_event_item item, long delta)\n{\n\tcount_vm_events(item, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_mm_compaction_isolate_migratepages",
          "args": [
            "start_pfn",
            "low_pfn",
            "nr_scanned",
            "nr_isolated"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_pageblock_skip",
          "args": [
            "cc",
            "valid_page",
            "nr_isolated",
            "true"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "update_pageblock_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "336-340",
          "snippet": "static inline void update_pageblock_skip(struct compact_control *cc,\n\t\t\tstruct page *page, unsigned long nr_isolated,\n\t\t\tbool migrate_scanner)\n{\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline void update_pageblock_skip(struct compact_control *cc,\n\t\t\tstruct page *page, unsigned long nr_isolated,\n\t\t\tbool migrate_scanner)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "zone_lru_lock(zone)",
            "flags"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_lru_lock",
          "args": [
            "zone"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "low_pfn > end_pfn"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putback_movable_pages",
          "args": [
            "&cc->migratepages"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "putback_movable_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "167-198",
          "snippet": "void putback_movable_pages(struct list_head *l)\n{\n\tstruct page *page;\n\tstruct page *page2;\n\n\tlist_for_each_entry_safe(page, page2, l, lru) {\n\t\tif (unlikely(PageHuge(page))) {\n\t\t\tputback_active_hugepage(page);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&page->lru);\n\t\t/*\n\t\t * We isolated non-lru movable page so here we can use\n\t\t * __PageMovable because LRU page's mapping cannot have\n\t\t * PAGE_MAPPING_MOVABLE.\n\t\t */\n\t\tif (unlikely(__PageMovable(page))) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\t\tlock_page(page);\n\t\t\tif (PageMovable(page))\n\t\t\t\tputback_movable_page(page);\n\t\t\telse\n\t\t\t\t__ClearPageIsolated(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t} else {\n\t\t\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page), -hpage_nr_pages(page));\n\t\t\tputback_lru_page(page);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid putback_movable_pages(struct list_head *l)\n{\n\tstruct page *page;\n\tstruct page *page2;\n\n\tlist_for_each_entry_safe(page, page2, l, lru) {\n\t\tif (unlikely(PageHuge(page))) {\n\t\t\tputback_active_hugepage(page);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&page->lru);\n\t\t/*\n\t\t * We isolated non-lru movable page so here we can use\n\t\t * __PageMovable because LRU page's mapping cannot have\n\t\t * PAGE_MAPPING_MOVABLE.\n\t\t */\n\t\tif (unlikely(__PageMovable(page))) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\t\tlock_page(page);\n\t\t\tif (PageMovable(page))\n\t\t\t\tputback_movable_page(page);\n\t\t\telse\n\t\t\t\t__ClearPageIsolated(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t} else {\n\t\t\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page), -hpage_nr_pages(page));\n\t\t\tputback_lru_page(page);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "zone_lru_lock(zone)",
            "flags"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_lru_lock",
          "args": [
            "zone"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->lru",
            "&cc->migratepages"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_node_page_state",
          "args": [
            "page",
            "NR_ISOLATED_ANON + page_is_file_cache(page)"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "inc_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "655-664",
          "snippet": "void inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tunsigned long flags;\n\tstruct pglist_data *pgdat;\n\n\tpgdat = page_pgdat(page);\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tunsigned long flags;\n\tstruct pglist_data *pgdat;\n\n\tpgdat = page_pgdat(page);\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_is_file_cache",
          "args": [
            "page"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_page_from_lru_list",
          "args": [
            "page",
            "lruvec",
            "page_lru(page)"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_lru",
          "args": [
            "page"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageCompound(page)",
            "page"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__isolate_lru_page",
          "args": [
            "page",
            "isolate_mode"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "__isolate_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1556-1621",
          "snippet": "int __isolate_lru_page(struct page *page, isolate_mode_t mode)\n{\n\tint ret = -EINVAL;\n\n\t/* Only take pages on the LRU. */\n\tif (!PageLRU(page))\n\t\treturn ret;\n\n\t/* Compaction should not handle unevictable pages but CMA can do so */\n\tif (PageUnevictable(page) && !(mode & ISOLATE_UNEVICTABLE))\n\t\treturn ret;\n\n\tret = -EBUSY;\n\n\t/*\n\t * To minimise LRU disruption, the caller can indicate that it only\n\t * wants to isolate pages it will be able to operate on without\n\t * blocking - clean pages for the most part.\n\t *\n\t * ISOLATE_ASYNC_MIGRATE is used to indicate that it only wants to pages\n\t * that it is possible to migrate without blocking\n\t */\n\tif (mode & ISOLATE_ASYNC_MIGRATE) {\n\t\t/* All the caller can do on PageWriteback is block */\n\t\tif (PageWriteback(page))\n\t\t\treturn ret;\n\n\t\tif (PageDirty(page)) {\n\t\t\tstruct address_space *mapping;\n\t\t\tbool migrate_dirty;\n\n\t\t\t/*\n\t\t\t * Only pages without mappings or that have a\n\t\t\t * ->migratepage callback are possible to migrate\n\t\t\t * without blocking. However, we can be racing with\n\t\t\t * truncation so it's necessary to lock the page\n\t\t\t * to stabilise the mapping as truncation holds\n\t\t\t * the page lock until after the page is removed\n\t\t\t * from the page cache.\n\t\t\t */\n\t\t\tif (!trylock_page(page))\n\t\t\t\treturn ret;\n\n\t\t\tmapping = page_mapping(page);\n\t\t\tmigrate_dirty = !mapping || mapping->a_ops->migratepage;\n\t\t\tunlock_page(page);\n\t\t\tif (!migrate_dirty)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((mode & ISOLATE_UNMAPPED) && page_mapped(page))\n\t\treturn ret;\n\n\tif (likely(get_page_unless_zero(page))) {\n\t\t/*\n\t\t * Be careful not to clear PageLRU until after we're\n\t\t * sure the page is not being freed elsewhere -- the\n\t\t * page release code relies on it.\n\t\t */\n\t\tClearPageLRU(page);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint __isolate_lru_page(struct page *page, isolate_mode_t mode)\n{\n\tint ret = -EINVAL;\n\n\t/* Only take pages on the LRU. */\n\tif (!PageLRU(page))\n\t\treturn ret;\n\n\t/* Compaction should not handle unevictable pages but CMA can do so */\n\tif (PageUnevictable(page) && !(mode & ISOLATE_UNEVICTABLE))\n\t\treturn ret;\n\n\tret = -EBUSY;\n\n\t/*\n\t * To minimise LRU disruption, the caller can indicate that it only\n\t * wants to isolate pages it will be able to operate on without\n\t * blocking - clean pages for the most part.\n\t *\n\t * ISOLATE_ASYNC_MIGRATE is used to indicate that it only wants to pages\n\t * that it is possible to migrate without blocking\n\t */\n\tif (mode & ISOLATE_ASYNC_MIGRATE) {\n\t\t/* All the caller can do on PageWriteback is block */\n\t\tif (PageWriteback(page))\n\t\t\treturn ret;\n\n\t\tif (PageDirty(page)) {\n\t\t\tstruct address_space *mapping;\n\t\t\tbool migrate_dirty;\n\n\t\t\t/*\n\t\t\t * Only pages without mappings or that have a\n\t\t\t * ->migratepage callback are possible to migrate\n\t\t\t * without blocking. However, we can be racing with\n\t\t\t * truncation so it's necessary to lock the page\n\t\t\t * to stabilise the mapping as truncation holds\n\t\t\t * the page lock until after the page is removed\n\t\t\t * from the page cache.\n\t\t\t */\n\t\t\tif (!trylock_page(page))\n\t\t\t\treturn ret;\n\n\t\t\tmapping = page_mapping(page);\n\t\t\tmigrate_dirty = !mapping || mapping->a_ops->migratepage;\n\t\t\tunlock_page(page);\n\t\t\tif (!migrate_dirty)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((mode & ISOLATE_UNMAPPED) && page_mapped(page))\n\t\treturn ret;\n\n\tif (likely(get_page_unless_zero(page))) {\n\t\t/*\n\t\t * Be careful not to clear PageLRU until after we're\n\t\t * sure the page is not being freed elsewhere -- the\n\t\t * page release code relies on it.\n\t\t */\n\t\tClearPageLRU(page);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_page_lruvec",
          "args": [
            "page",
            "zone->zone_pgdat"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_page_lruvec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1100-1130",
          "snippet": "struct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageCompound(page)"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compact_trylock_irqsave",
          "args": [
            "zone_lru_lock(zone)",
            "&flags",
            "cc"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "compact_trylock_irqsave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "351-364",
          "snippet": "static bool compact_trylock_irqsave(spinlock_t *lock, unsigned long *flags,\n\t\t\t\t\t\tstruct compact_control *cc)\n{\n\tif (cc->mode == MIGRATE_ASYNC) {\n\t\tif (!spin_trylock_irqsave(lock, *flags)) {\n\t\t\tcc->contended = true;\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tspin_lock_irqsave(lock, *flags);\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic bool compact_trylock_irqsave(spinlock_t *lock, unsigned long *flags,\n\t\t\t\t\t\tstruct compact_control *cc)\n{\n\tif (cc->mode == MIGRATE_ASYNC) {\n\t\tif (!spin_trylock_irqsave(lock, *flags)) {\n\t\t\tcc->contended = true;\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tspin_lock_irqsave(lock, *flags);\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_lru_lock",
          "args": [
            "zone"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "page"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isolate_movable_page",
          "args": [
            "page",
            "isolate_mode"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_movable_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "84-143",
          "snippet": "int isolate_movable_page(struct page *page, isolate_mode_t mode)\n{\n\tstruct address_space *mapping;\n\n\t/*\n\t * Avoid burning cycles with pages that are yet under __free_pages(),\n\t * or just got freed under us.\n\t *\n\t * In case we 'win' a race for a movable page being freed under us and\n\t * raise its refcount preventing __free_pages() from doing its job\n\t * the put_page() at the end of this block will take care of\n\t * release this page, thus avoiding a nasty leakage.\n\t */\n\tif (unlikely(!get_page_unless_zero(page)))\n\t\tgoto out;\n\n\t/*\n\t * Check PageMovable before holding a PG_lock because page's owner\n\t * assumes anybody doesn't touch PG_lock of newly allocated page\n\t * so unconditionally grapping the lock ruins page's owner side.\n\t */\n\tif (unlikely(!__PageMovable(page)))\n\t\tgoto out_putpage;\n\t/*\n\t * As movable pages are not isolated from LRU lists, concurrent\n\t * compaction threads can race against page migration functions\n\t * as well as race against the releasing a page.\n\t *\n\t * In order to avoid having an already isolated movable page\n\t * being (wrongly) re-isolated while it is under migration,\n\t * or to avoid attempting to isolate pages being released,\n\t * lets be sure we have the page lock\n\t * before proceeding with the movable page isolation steps.\n\t */\n\tif (unlikely(!trylock_page(page)))\n\t\tgoto out_putpage;\n\n\tif (!PageMovable(page) || PageIsolated(page))\n\t\tgoto out_no_isolated;\n\n\tmapping = page_mapping(page);\n\tVM_BUG_ON_PAGE(!mapping, page);\n\n\tif (!mapping->a_ops->isolate_page(page, mode))\n\t\tgoto out_no_isolated;\n\n\t/* Driver shouldn't use PG_isolated bit of page->flags */\n\tWARN_ON_ONCE(PageIsolated(page));\n\t__SetPageIsolated(page);\n\tunlock_page(page);\n\n\treturn 0;\n\nout_no_isolated:\n\tunlock_page(page);\nout_putpage:\n\tput_page(page);\nout:\n\treturn -EBUSY;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint isolate_movable_page(struct page *page, isolate_mode_t mode)\n{\n\tstruct address_space *mapping;\n\n\t/*\n\t * Avoid burning cycles with pages that are yet under __free_pages(),\n\t * or just got freed under us.\n\t *\n\t * In case we 'win' a race for a movable page being freed under us and\n\t * raise its refcount preventing __free_pages() from doing its job\n\t * the put_page() at the end of this block will take care of\n\t * release this page, thus avoiding a nasty leakage.\n\t */\n\tif (unlikely(!get_page_unless_zero(page)))\n\t\tgoto out;\n\n\t/*\n\t * Check PageMovable before holding a PG_lock because page's owner\n\t * assumes anybody doesn't touch PG_lock of newly allocated page\n\t * so unconditionally grapping the lock ruins page's owner side.\n\t */\n\tif (unlikely(!__PageMovable(page)))\n\t\tgoto out_putpage;\n\t/*\n\t * As movable pages are not isolated from LRU lists, concurrent\n\t * compaction threads can race against page migration functions\n\t * as well as race against the releasing a page.\n\t *\n\t * In order to avoid having an already isolated movable page\n\t * being (wrongly) re-isolated while it is under migration,\n\t * or to avoid attempting to isolate pages being released,\n\t * lets be sure we have the page lock\n\t * before proceeding with the movable page isolation steps.\n\t */\n\tif (unlikely(!trylock_page(page)))\n\t\tgoto out_putpage;\n\n\tif (!PageMovable(page) || PageIsolated(page))\n\t\tgoto out_no_isolated;\n\n\tmapping = page_mapping(page);\n\tVM_BUG_ON_PAGE(!mapping, page);\n\n\tif (!mapping->a_ops->isolate_page(page, mode))\n\t\tgoto out_no_isolated;\n\n\t/* Driver shouldn't use PG_isolated bit of page->flags */\n\tWARN_ON_ONCE(PageIsolated(page));\n\t__SetPageIsolated(page);\n\tunlock_page(page);\n\n\treturn 0;\n\nout_no_isolated:\n\tunlock_page(page);\nout_putpage:\n\tput_page(page);\nout:\n\treturn -EBUSY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "zone_lru_lock(zone)",
            "flags"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_lru_lock",
          "args": [
            "zone"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageIsolated",
          "args": [
            "page"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "__PageMovable(page)"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PageMovable",
          "args": [
            "page"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "order < MAX_ORDER"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_order_unsafe",
          "args": [
            "page"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageBuddy",
          "args": [
            "page"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "low_pfn"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid_within",
          "args": [
            "low_pfn"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compact_unlock_should_abort",
          "args": [
            "zone_lru_lock(zone)",
            "flags",
            "&locked",
            "cc"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "compact_unlock_should_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "381-403",
          "snippet": "static bool compact_unlock_should_abort(spinlock_t *lock,\n\t\tunsigned long flags, bool *locked, struct compact_control *cc)\n{\n\tif (*locked) {\n\t\tspin_unlock_irqrestore(lock, flags);\n\t\t*locked = false;\n\t}\n\n\tif (fatal_signal_pending(current)) {\n\t\tcc->contended = true;\n\t\treturn true;\n\t}\n\n\tif (need_resched()) {\n\t\tif (cc->mode == MIGRATE_ASYNC) {\n\t\t\tcc->contended = true;\n\t\t\treturn true;\n\t\t}\n\t\tcond_resched();\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic bool compact_unlock_should_abort(spinlock_t *lock,\n\t\tunsigned long flags, bool *locked, struct compact_control *cc)\n{\n\tif (*locked) {\n\t\tspin_unlock_irqrestore(lock, flags);\n\t\t*locked = false;\n\t}\n\n\tif (fatal_signal_pending(current)) {\n\t\tcc->contended = true;\n\t\treturn true;\n\t}\n\n\tif (need_resched()) {\n\t\tif (cc->mode == MIGRATE_ASYNC) {\n\t\t\tcc->contended = true;\n\t\t\treturn true;\n\t\t}\n\t\tcond_resched();\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_lru_lock",
          "args": [
            "zone"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_end_pfn",
          "args": [
            "low_pfn",
            "cc->order"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_end_pfn",
          "args": [
            "low_pfn",
            "cc->order"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compact_should_abort",
          "args": [
            "cc"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "compact_should_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "414-427",
          "snippet": "static inline bool compact_should_abort(struct compact_control *cc)\n{\n\t/* async compaction aborts if contended */\n\tif (need_resched()) {\n\t\tif (cc->mode == MIGRATE_ASYNC) {\n\t\t\tcc->contended = true;\n\t\t\treturn true;\n\t\t}\n\n\t\tcond_resched();\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline bool compact_should_abort(struct compact_control *cc)\n{\n\t/* async compaction aborts if contended */\n\tif (need_resched()) {\n\t\tif (cc->mode == MIGRATE_ASYNC) {\n\t\t\tcc->contended = true;\n\t\t\treturn true;\n\t\t}\n\n\t\tcond_resched();\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "congestion_wait",
          "args": [
            "BLK_RW_ASYNC",
            "HZ/10"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "congestion_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/backing-dev.c",
          "lines": "1016-1031",
          "snippet": "long congestion_wait(int sync, long timeout)\n{\n\tlong ret;\n\tunsigned long start = jiffies;\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = &congestion_wqh[sync];\n\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tret = io_schedule_timeout(timeout);\n\tfinish_wait(wqh, &wait);\n\n\ttrace_writeback_congestion_wait(jiffies_to_usecs(timeout),\n\t\t\t\t\tjiffies_to_usecs(jiffies - start));\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <trace/events/writeback.h>",
            "#include <linux/device.h>",
            "#include <linux/writeback.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/wait.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static wait_queue_head_t congestion_wqh[2] = {\n\t\t__WAIT_QUEUE_HEAD_INITIALIZER(congestion_wqh[0]),\n\t\t__WAIT_QUEUE_HEAD_INITIALIZER(congestion_wqh[1])\n\t};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <trace/events/writeback.h>\n#include <linux/device.h>\n#include <linux/writeback.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/wait.h>\n\nstatic wait_queue_head_t congestion_wqh[2] = {\n\t\t__WAIT_QUEUE_HEAD_INITIALIZER(congestion_wqh[0]),\n\t\t__WAIT_QUEUE_HEAD_INITIALIZER(congestion_wqh[1])\n\t};\n\nlong congestion_wait(int sync, long timeout)\n{\n\tlong ret;\n\tunsigned long start = jiffies;\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = &congestion_wqh[sync];\n\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tret = io_schedule_timeout(timeout);\n\tfinish_wait(wqh, &wait);\n\n\ttrace_writeback_congestion_wait(jiffies_to_usecs(timeout),\n\t\t\t\t\tjiffies_to_usecs(jiffies - start));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "too_many_isolated(zone)"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "too_many_isolated",
          "args": [
            "zone"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "too_many_isolated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "660-672",
          "snippet": "static bool too_many_isolated(struct zone *zone)\n{\n\tunsigned long active, inactive, isolated;\n\n\tinactive = node_page_state(zone->zone_pgdat, NR_INACTIVE_FILE) +\n\t\t\tnode_page_state(zone->zone_pgdat, NR_INACTIVE_ANON);\n\tactive = node_page_state(zone->zone_pgdat, NR_ACTIVE_FILE) +\n\t\t\tnode_page_state(zone->zone_pgdat, NR_ACTIVE_ANON);\n\tisolated = node_page_state(zone->zone_pgdat, NR_ISOLATED_FILE) +\n\t\t\tnode_page_state(zone->zone_pgdat, NR_ISOLATED_ANON);\n\n\treturn isolated > (inactive + active) / 2;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic bool too_many_isolated(struct zone *zone)\n{\n\tunsigned long active, inactive, isolated;\n\n\tinactive = node_page_state(zone->zone_pgdat, NR_INACTIVE_FILE) +\n\t\t\tnode_page_state(zone->zone_pgdat, NR_INACTIVE_ANON);\n\tactive = node_page_state(zone->zone_pgdat, NR_ACTIVE_FILE) +\n\t\t\tnode_page_state(zone->zone_pgdat, NR_ACTIVE_ANON);\n\tisolated = node_page_state(zone->zone_pgdat, NR_ISOLATED_FILE) +\n\t\t\tnode_page_state(zone->zone_pgdat, NR_ISOLATED_ANON);\n\n\treturn isolated > (inactive + active) / 2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic unsigned long\nisolate_migratepages_block(struct compact_control *cc, unsigned long low_pfn,\n\t\t\tunsigned long end_pfn, isolate_mode_t isolate_mode)\n{\n\tstruct zone *zone = cc->zone;\n\tunsigned long nr_scanned = 0, nr_isolated = 0;\n\tstruct lruvec *lruvec;\n\tunsigned long flags = 0;\n\tbool locked = false;\n\tstruct page *page = NULL, *valid_page = NULL;\n\tunsigned long start_pfn = low_pfn;\n\tbool skip_on_failure = false;\n\tunsigned long next_skip_pfn = 0;\n\n\t/*\n\t * Ensure that there are not too many pages isolated from the LRU\n\t * list by either parallel reclaimers or compaction. If there are,\n\t * delay for some time until fewer pages are isolated\n\t */\n\twhile (unlikely(too_many_isolated(zone))) {\n\t\t/* async migration should just abort */\n\t\tif (cc->mode == MIGRATE_ASYNC)\n\t\t\treturn 0;\n\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/10);\n\n\t\tif (fatal_signal_pending(current))\n\t\t\treturn 0;\n\t}\n\n\tif (compact_should_abort(cc))\n\t\treturn 0;\n\n\tif (cc->direct_compaction && (cc->mode == MIGRATE_ASYNC)) {\n\t\tskip_on_failure = true;\n\t\tnext_skip_pfn = block_end_pfn(low_pfn, cc->order);\n\t}\n\n\t/* Time to isolate some pages for migration */\n\tfor (; low_pfn < end_pfn; low_pfn++) {\n\n\t\tif (skip_on_failure && low_pfn >= next_skip_pfn) {\n\t\t\t/*\n\t\t\t * We have isolated all migration candidates in the\n\t\t\t * previous order-aligned block, and did not skip it due\n\t\t\t * to failure. We should migrate the pages now and\n\t\t\t * hopefully succeed compaction.\n\t\t\t */\n\t\t\tif (nr_isolated)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * We failed to isolate in the previous order-aligned\n\t\t\t * block. Set the new boundary to the end of the\n\t\t\t * current block. Note we can't simply increase\n\t\t\t * next_skip_pfn by 1 << order, as low_pfn might have\n\t\t\t * been incremented by a higher number due to skipping\n\t\t\t * a compound or a high-order buddy page in the\n\t\t\t * previous loop iteration.\n\t\t\t */\n\t\t\tnext_skip_pfn = block_end_pfn(low_pfn, cc->order);\n\t\t}\n\n\t\t/*\n\t\t * Periodically drop the lock (if held) regardless of its\n\t\t * contention, to give chance to IRQs. Abort async compaction\n\t\t * if contended.\n\t\t */\n\t\tif (!(low_pfn % SWAP_CLUSTER_MAX)\n\t\t    && compact_unlock_should_abort(zone_lru_lock(zone), flags,\n\t\t\t\t\t\t\t\t&locked, cc))\n\t\t\tbreak;\n\n\t\tif (!pfn_valid_within(low_pfn))\n\t\t\tgoto isolate_fail;\n\t\tnr_scanned++;\n\n\t\tpage = pfn_to_page(low_pfn);\n\n\t\tif (!valid_page)\n\t\t\tvalid_page = page;\n\n\t\t/*\n\t\t * Skip if free. We read page order here without zone lock\n\t\t * which is generally unsafe, but the race window is small and\n\t\t * the worst thing that can happen is that we skip some\n\t\t * potential isolation targets.\n\t\t */\n\t\tif (PageBuddy(page)) {\n\t\t\tunsigned long freepage_order = page_order_unsafe(page);\n\n\t\t\t/*\n\t\t\t * Without lock, we cannot be sure that what we got is\n\t\t\t * a valid page order. Consider only values in the\n\t\t\t * valid order range to prevent low_pfn overflow.\n\t\t\t */\n\t\t\tif (freepage_order > 0 && freepage_order < MAX_ORDER)\n\t\t\t\tlow_pfn += (1UL << freepage_order) - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Regardless of being on LRU, compound pages such as THP and\n\t\t * hugetlbfs are not to be compacted. We can potentially save\n\t\t * a lot of iterations if we skip them at once. The check is\n\t\t * racy, but we can consider only valid values and the only\n\t\t * danger is skipping too much.\n\t\t */\n\t\tif (PageCompound(page)) {\n\t\t\tconst unsigned int order = compound_order(page);\n\n\t\t\tif (likely(order < MAX_ORDER))\n\t\t\t\tlow_pfn += (1UL << order) - 1;\n\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\t/*\n\t\t * Check may be lockless but that's ok as we recheck later.\n\t\t * It's possible to migrate LRU and non-lru movable pages.\n\t\t * Skip any other type of page\n\t\t */\n\t\tif (!PageLRU(page)) {\n\t\t\t/*\n\t\t\t * __PageMovable can return false positive so we need\n\t\t\t * to verify it under page_lock.\n\t\t\t */\n\t\t\tif (unlikely(__PageMovable(page)) &&\n\t\t\t\t\t!PageIsolated(page)) {\n\t\t\t\tif (locked) {\n\t\t\t\t\tspin_unlock_irqrestore(zone_lru_lock(zone),\n\t\t\t\t\t\t\t\t\tflags);\n\t\t\t\t\tlocked = false;\n\t\t\t\t}\n\n\t\t\t\tif (!isolate_movable_page(page, isolate_mode))\n\t\t\t\t\tgoto isolate_success;\n\t\t\t}\n\n\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\t/*\n\t\t * Migration will fail if an anonymous page is pinned in memory,\n\t\t * so avoid taking lru_lock and isolating it unnecessarily in an\n\t\t * admittedly racy check.\n\t\t */\n\t\tif (!page_mapping(page) &&\n\t\t    page_count(page) > page_mapcount(page))\n\t\t\tgoto isolate_fail;\n\n\t\t/*\n\t\t * Only allow to migrate anonymous pages in GFP_NOFS context\n\t\t * because those do not depend on fs locks.\n\t\t */\n\t\tif (!(cc->gfp_mask & __GFP_FS) && page_mapping(page))\n\t\t\tgoto isolate_fail;\n\n\t\t/* If we already hold the lock, we can skip some rechecking */\n\t\tif (!locked) {\n\t\t\tlocked = compact_trylock_irqsave(zone_lru_lock(zone),\n\t\t\t\t\t\t\t\t&flags, cc);\n\t\t\tif (!locked)\n\t\t\t\tbreak;\n\n\t\t\t/* Recheck PageLRU and PageCompound under lock */\n\t\t\tif (!PageLRU(page))\n\t\t\t\tgoto isolate_fail;\n\n\t\t\t/*\n\t\t\t * Page become compound since the non-locked check,\n\t\t\t * and it's on LRU. It can only be a THP so the order\n\t\t\t * is safe to read and it's 0 for tail pages.\n\t\t\t */\n\t\t\tif (unlikely(PageCompound(page))) {\n\t\t\t\tlow_pfn += (1UL << compound_order(page)) - 1;\n\t\t\t\tgoto isolate_fail;\n\t\t\t}\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\n\t\t/* Try isolate the page */\n\t\tif (__isolate_lru_page(page, isolate_mode) != 0)\n\t\t\tgoto isolate_fail;\n\n\t\tVM_BUG_ON_PAGE(PageCompound(page), page);\n\n\t\t/* Successfully isolated */\n\t\tdel_page_from_lru_list(page, lruvec, page_lru(page));\n\t\tinc_node_page_state(page,\n\t\t\t\tNR_ISOLATED_ANON + page_is_file_cache(page));\n\nisolate_success:\n\t\tlist_add(&page->lru, &cc->migratepages);\n\t\tcc->nr_migratepages++;\n\t\tnr_isolated++;\n\n\t\t/*\n\t\t * Record where we could have freed pages by migration and not\n\t\t * yet flushed them to buddy allocator.\n\t\t * - this is the lowest page that was isolated and likely be\n\t\t * then freed by migration.\n\t\t */\n\t\tif (!cc->last_migrated_pfn)\n\t\t\tcc->last_migrated_pfn = low_pfn;\n\n\t\t/* Avoid isolating too much */\n\t\tif (cc->nr_migratepages == COMPACT_CLUSTER_MAX) {\n\t\t\t++low_pfn;\n\t\t\tbreak;\n\t\t}\n\n\t\tcontinue;\nisolate_fail:\n\t\tif (!skip_on_failure)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We have isolated some pages, but then failed. Release them\n\t\t * instead of migrating, as we cannot form the cc->order buddy\n\t\t * page anyway.\n\t\t */\n\t\tif (nr_isolated) {\n\t\t\tif (locked) {\n\t\t\t\tspin_unlock_irqrestore(zone_lru_lock(zone), flags);\n\t\t\t\tlocked = false;\n\t\t\t}\n\t\t\tputback_movable_pages(&cc->migratepages);\n\t\t\tcc->nr_migratepages = 0;\n\t\t\tcc->last_migrated_pfn = 0;\n\t\t\tnr_isolated = 0;\n\t\t}\n\n\t\tif (low_pfn < next_skip_pfn) {\n\t\t\tlow_pfn = next_skip_pfn - 1;\n\t\t\t/*\n\t\t\t * The check near the loop beginning would have updated\n\t\t\t * next_skip_pfn too, but this is a bit simpler.\n\t\t\t */\n\t\t\tnext_skip_pfn += 1UL << cc->order;\n\t\t}\n\t}\n\n\t/*\n\t * The PageBuddy() check could have potentially brought us outside\n\t * the range to be scanned.\n\t */\n\tif (unlikely(low_pfn > end_pfn))\n\t\tlow_pfn = end_pfn;\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(zone_lru_lock(zone), flags);\n\n\t/*\n\t * Update the pageblock-skip information and cached scanner pfn,\n\t * if the whole pageblock was scanned without isolating any page.\n\t */\n\tif (low_pfn == end_pfn)\n\t\tupdate_pageblock_skip(cc, valid_page, nr_isolated, true);\n\n\ttrace_mm_compaction_isolate_migratepages(start_pfn, low_pfn,\n\t\t\t\t\t\tnr_scanned, nr_isolated);\n\n\tcc->total_migrate_scanned += nr_scanned;\n\tif (nr_isolated)\n\t\tcount_compact_events(COMPACTISOLATED, nr_isolated);\n\n\treturn low_pfn;\n}"
  },
  {
    "function_name": "too_many_isolated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "660-672",
    "snippet": "static bool too_many_isolated(struct zone *zone)\n{\n\tunsigned long active, inactive, isolated;\n\n\tinactive = node_page_state(zone->zone_pgdat, NR_INACTIVE_FILE) +\n\t\t\tnode_page_state(zone->zone_pgdat, NR_INACTIVE_ANON);\n\tactive = node_page_state(zone->zone_pgdat, NR_ACTIVE_FILE) +\n\t\t\tnode_page_state(zone->zone_pgdat, NR_ACTIVE_ANON);\n\tisolated = node_page_state(zone->zone_pgdat, NR_ISOLATED_FILE) +\n\t\t\tnode_page_state(zone->zone_pgdat, NR_ISOLATED_ANON);\n\n\treturn isolated > (inactive + active) / 2;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_page_state",
          "args": [
            "zone->zone_pgdat",
            "NR_ISOLATED_ANON"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "991-1000",
          "snippet": "unsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nunsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic bool too_many_isolated(struct zone *zone)\n{\n\tunsigned long active, inactive, isolated;\n\n\tinactive = node_page_state(zone->zone_pgdat, NR_INACTIVE_FILE) +\n\t\t\tnode_page_state(zone->zone_pgdat, NR_INACTIVE_ANON);\n\tactive = node_page_state(zone->zone_pgdat, NR_ACTIVE_FILE) +\n\t\t\tnode_page_state(zone->zone_pgdat, NR_ACTIVE_ANON);\n\tisolated = node_page_state(zone->zone_pgdat, NR_ISOLATED_FILE) +\n\t\t\tnode_page_state(zone->zone_pgdat, NR_ISOLATED_ANON);\n\n\treturn isolated > (inactive + active) / 2;\n}"
  },
  {
    "function_name": "isolate_freepages_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "592-657",
    "snippet": "unsigned long\nisolate_freepages_range(struct compact_control *cc,\n\t\t\tunsigned long start_pfn, unsigned long end_pfn)\n{\n\tunsigned long isolated, pfn, block_start_pfn, block_end_pfn;\n\tLIST_HEAD(freelist);\n\n\tpfn = start_pfn;\n\tblock_start_pfn = pageblock_start_pfn(pfn);\n\tif (block_start_pfn < cc->zone->zone_start_pfn)\n\t\tblock_start_pfn = cc->zone->zone_start_pfn;\n\tblock_end_pfn = pageblock_end_pfn(pfn);\n\n\tfor (; pfn < end_pfn; pfn += isolated,\n\t\t\t\tblock_start_pfn = block_end_pfn,\n\t\t\t\tblock_end_pfn += pageblock_nr_pages) {\n\t\t/* Protect pfn from changing by isolate_freepages_block */\n\t\tunsigned long isolate_start_pfn = pfn;\n\n\t\tblock_end_pfn = min(block_end_pfn, end_pfn);\n\n\t\t/*\n\t\t * pfn could pass the block_end_pfn if isolated freepage\n\t\t * is more than pageblock order. In this case, we adjust\n\t\t * scanning range to right one.\n\t\t */\n\t\tif (pfn >= block_end_pfn) {\n\t\t\tblock_start_pfn = pageblock_start_pfn(pfn);\n\t\t\tblock_end_pfn = pageblock_end_pfn(pfn);\n\t\t\tblock_end_pfn = min(block_end_pfn, end_pfn);\n\t\t}\n\n\t\tif (!pageblock_pfn_to_page(block_start_pfn,\n\t\t\t\t\tblock_end_pfn, cc->zone))\n\t\t\tbreak;\n\n\t\tisolated = isolate_freepages_block(cc, &isolate_start_pfn,\n\t\t\t\t\t\tblock_end_pfn, &freelist, true);\n\n\t\t/*\n\t\t * In strict mode, isolate_freepages_block() returns 0 if\n\t\t * there are any holes in the block (ie. invalid PFNs or\n\t\t * non-free pages).\n\t\t */\n\t\tif (!isolated)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If we managed to isolate pages, it is always (1 << n) *\n\t\t * pageblock_nr_pages for some non-negative n.  (Max order\n\t\t * page may span two pageblocks).\n\t\t */\n\t}\n\n\t/* __isolate_free_page() does not map the pages */\n\tmap_pages(&freelist);\n\n\tif (pfn < end_pfn) {\n\t\t/* Loop terminated early, cleanup. */\n\t\trelease_freepages(&freelist);\n\t\treturn 0;\n\t}\n\n\t/* We don't use freelists for anything. */\n\treturn pfn;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_freepages",
          "args": [
            "&freelist"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "release_freepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "53-67",
          "snippet": "static unsigned long release_freepages(struct list_head *freelist)\n{\n\tstruct page *page, *next;\n\tunsigned long high_pfn = 0;\n\n\tlist_for_each_entry_safe(page, next, freelist, lru) {\n\t\tunsigned long pfn = page_to_pfn(page);\n\t\tlist_del(&page->lru);\n\t\t__free_page(page);\n\t\tif (pfn > high_pfn)\n\t\t\thigh_pfn = pfn;\n\t}\n\n\treturn high_pfn;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic unsigned long release_freepages(struct list_head *freelist)\n{\n\tstruct page *page, *next;\n\tunsigned long high_pfn = 0;\n\n\tlist_for_each_entry_safe(page, next, freelist, lru) {\n\t\tunsigned long pfn = page_to_pfn(page);\n\t\tlist_del(&page->lru);\n\t\t__free_page(page);\n\t\tif (pfn > high_pfn)\n\t\t\thigh_pfn = pfn;\n\t}\n\n\treturn high_pfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_pages",
          "args": [
            "&freelist"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "map_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "69-92",
          "snippet": "static void map_pages(struct list_head *list)\n{\n\tunsigned int i, order, nr_pages;\n\tstruct page *page, *next;\n\tLIST_HEAD(tmp_list);\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\n\t\torder = page_private(page);\n\t\tnr_pages = 1 << order;\n\n\t\tpost_alloc_hook(page, order, __GFP_MOVABLE);\n\t\tif (order)\n\t\t\tsplit_page(page, order);\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tlist_add(&page->lru, &tmp_list);\n\t\t\tpage++;\n\t\t}\n\t}\n\n\tlist_splice(&tmp_list, list);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic void map_pages(struct list_head *list)\n{\n\tunsigned int i, order, nr_pages;\n\tstruct page *page, *next;\n\tLIST_HEAD(tmp_list);\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\n\t\torder = page_private(page);\n\t\tnr_pages = 1 << order;\n\n\t\tpost_alloc_hook(page, order, __GFP_MOVABLE);\n\t\tif (order)\n\t\t\tsplit_page(page, order);\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tlist_add(&page->lru, &tmp_list);\n\t\t\tpage++;\n\t\t}\n\t}\n\n\tlist_splice(&tmp_list, list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isolate_freepages_block",
          "args": [
            "cc",
            "&isolate_start_pfn",
            "block_end_pfn",
            "&freelist",
            "true"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_freepages_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "434-576",
          "snippet": "static unsigned long isolate_freepages_block(struct compact_control *cc,\n\t\t\t\tunsigned long *start_pfn,\n\t\t\t\tunsigned long end_pfn,\n\t\t\t\tstruct list_head *freelist,\n\t\t\t\tbool strict)\n{\n\tint nr_scanned = 0, total_isolated = 0;\n\tstruct page *cursor, *valid_page = NULL;\n\tunsigned long flags = 0;\n\tbool locked = false;\n\tunsigned long blockpfn = *start_pfn;\n\tunsigned int order;\n\n\tcursor = pfn_to_page(blockpfn);\n\n\t/* Isolate free pages. */\n\tfor (; blockpfn < end_pfn; blockpfn++, cursor++) {\n\t\tint isolated;\n\t\tstruct page *page = cursor;\n\n\t\t/*\n\t\t * Periodically drop the lock (if held) regardless of its\n\t\t * contention, to give chance to IRQs. Abort if fatal signal\n\t\t * pending or async compaction detects need_resched()\n\t\t */\n\t\tif (!(blockpfn % SWAP_CLUSTER_MAX)\n\t\t    && compact_unlock_should_abort(&cc->zone->lock, flags,\n\t\t\t\t\t\t\t\t&locked, cc))\n\t\t\tbreak;\n\n\t\tnr_scanned++;\n\t\tif (!pfn_valid_within(blockpfn))\n\t\t\tgoto isolate_fail;\n\n\t\tif (!valid_page)\n\t\t\tvalid_page = page;\n\n\t\t/*\n\t\t * For compound pages such as THP and hugetlbfs, we can save\n\t\t * potentially a lot of iterations if we skip them at once.\n\t\t * The check is racy, but we can consider only valid values\n\t\t * and the only danger is skipping too much.\n\t\t */\n\t\tif (PageCompound(page)) {\n\t\t\tconst unsigned int order = compound_order(page);\n\n\t\t\tif (likely(order < MAX_ORDER)) {\n\t\t\t\tblockpfn += (1UL << order) - 1;\n\t\t\t\tcursor += (1UL << order) - 1;\n\t\t\t}\n\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\tif (!PageBuddy(page))\n\t\t\tgoto isolate_fail;\n\n\t\t/*\n\t\t * If we already hold the lock, we can skip some rechecking.\n\t\t * Note that if we hold the lock now, checked_pageblock was\n\t\t * already set in some previous iteration (or strict is true),\n\t\t * so it is correct to skip the suitable migration target\n\t\t * recheck as well.\n\t\t */\n\t\tif (!locked) {\n\t\t\t/*\n\t\t\t * The zone lock must be held to isolate freepages.\n\t\t\t * Unfortunately this is a very coarse lock and can be\n\t\t\t * heavily contended if there are parallel allocations\n\t\t\t * or parallel compactions. For async compaction do not\n\t\t\t * spin on the lock and we acquire the lock as late as\n\t\t\t * possible.\n\t\t\t */\n\t\t\tlocked = compact_trylock_irqsave(&cc->zone->lock,\n\t\t\t\t\t\t\t\t&flags, cc);\n\t\t\tif (!locked)\n\t\t\t\tbreak;\n\n\t\t\t/* Recheck this is a buddy page under lock */\n\t\t\tif (!PageBuddy(page))\n\t\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\t/* Found a free page, will break it into order-0 pages */\n\t\torder = page_order(page);\n\t\tisolated = __isolate_free_page(page, order);\n\t\tif (!isolated)\n\t\t\tbreak;\n\t\tset_page_private(page, order);\n\n\t\ttotal_isolated += isolated;\n\t\tcc->nr_freepages += isolated;\n\t\tlist_add_tail(&page->lru, freelist);\n\n\t\tif (!strict && cc->nr_migratepages <= cc->nr_freepages) {\n\t\t\tblockpfn += isolated;\n\t\t\tbreak;\n\t\t}\n\t\t/* Advance to the end of split page */\n\t\tblockpfn += isolated - 1;\n\t\tcursor += isolated - 1;\n\t\tcontinue;\n\nisolate_fail:\n\t\tif (strict)\n\t\t\tbreak;\n\t\telse\n\t\t\tcontinue;\n\n\t}\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(&cc->zone->lock, flags);\n\n\t/*\n\t * There is a tiny chance that we have read bogus compound_order(),\n\t * so be careful to not go outside of the pageblock.\n\t */\n\tif (unlikely(blockpfn > end_pfn))\n\t\tblockpfn = end_pfn;\n\n\ttrace_mm_compaction_isolate_freepages(*start_pfn, blockpfn,\n\t\t\t\t\tnr_scanned, total_isolated);\n\n\t/* Record how far we have got within the block */\n\t*start_pfn = blockpfn;\n\n\t/*\n\t * If strict isolation is requested by CMA then check that all the\n\t * pages requested were isolated. If there were any failures, 0 is\n\t * returned and CMA will fail.\n\t */\n\tif (strict && blockpfn < end_pfn)\n\t\ttotal_isolated = 0;\n\n\t/* Update the pageblock-skip if the whole pageblock was scanned */\n\tif (blockpfn == end_pfn)\n\t\tupdate_pageblock_skip(cc, valid_page, total_isolated, false);\n\n\tcc->total_free_scanned += nr_scanned;\n\tif (total_isolated)\n\t\tcount_compact_events(COMPACTISOLATED, total_isolated);\n\treturn total_isolated;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic unsigned long isolate_freepages_block(struct compact_control *cc,\n\t\t\t\tunsigned long *start_pfn,\n\t\t\t\tunsigned long end_pfn,\n\t\t\t\tstruct list_head *freelist,\n\t\t\t\tbool strict)\n{\n\tint nr_scanned = 0, total_isolated = 0;\n\tstruct page *cursor, *valid_page = NULL;\n\tunsigned long flags = 0;\n\tbool locked = false;\n\tunsigned long blockpfn = *start_pfn;\n\tunsigned int order;\n\n\tcursor = pfn_to_page(blockpfn);\n\n\t/* Isolate free pages. */\n\tfor (; blockpfn < end_pfn; blockpfn++, cursor++) {\n\t\tint isolated;\n\t\tstruct page *page = cursor;\n\n\t\t/*\n\t\t * Periodically drop the lock (if held) regardless of its\n\t\t * contention, to give chance to IRQs. Abort if fatal signal\n\t\t * pending or async compaction detects need_resched()\n\t\t */\n\t\tif (!(blockpfn % SWAP_CLUSTER_MAX)\n\t\t    && compact_unlock_should_abort(&cc->zone->lock, flags,\n\t\t\t\t\t\t\t\t&locked, cc))\n\t\t\tbreak;\n\n\t\tnr_scanned++;\n\t\tif (!pfn_valid_within(blockpfn))\n\t\t\tgoto isolate_fail;\n\n\t\tif (!valid_page)\n\t\t\tvalid_page = page;\n\n\t\t/*\n\t\t * For compound pages such as THP and hugetlbfs, we can save\n\t\t * potentially a lot of iterations if we skip them at once.\n\t\t * The check is racy, but we can consider only valid values\n\t\t * and the only danger is skipping too much.\n\t\t */\n\t\tif (PageCompound(page)) {\n\t\t\tconst unsigned int order = compound_order(page);\n\n\t\t\tif (likely(order < MAX_ORDER)) {\n\t\t\t\tblockpfn += (1UL << order) - 1;\n\t\t\t\tcursor += (1UL << order) - 1;\n\t\t\t}\n\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\tif (!PageBuddy(page))\n\t\t\tgoto isolate_fail;\n\n\t\t/*\n\t\t * If we already hold the lock, we can skip some rechecking.\n\t\t * Note that if we hold the lock now, checked_pageblock was\n\t\t * already set in some previous iteration (or strict is true),\n\t\t * so it is correct to skip the suitable migration target\n\t\t * recheck as well.\n\t\t */\n\t\tif (!locked) {\n\t\t\t/*\n\t\t\t * The zone lock must be held to isolate freepages.\n\t\t\t * Unfortunately this is a very coarse lock and can be\n\t\t\t * heavily contended if there are parallel allocations\n\t\t\t * or parallel compactions. For async compaction do not\n\t\t\t * spin on the lock and we acquire the lock as late as\n\t\t\t * possible.\n\t\t\t */\n\t\t\tlocked = compact_trylock_irqsave(&cc->zone->lock,\n\t\t\t\t\t\t\t\t&flags, cc);\n\t\t\tif (!locked)\n\t\t\t\tbreak;\n\n\t\t\t/* Recheck this is a buddy page under lock */\n\t\t\tif (!PageBuddy(page))\n\t\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\t/* Found a free page, will break it into order-0 pages */\n\t\torder = page_order(page);\n\t\tisolated = __isolate_free_page(page, order);\n\t\tif (!isolated)\n\t\t\tbreak;\n\t\tset_page_private(page, order);\n\n\t\ttotal_isolated += isolated;\n\t\tcc->nr_freepages += isolated;\n\t\tlist_add_tail(&page->lru, freelist);\n\n\t\tif (!strict && cc->nr_migratepages <= cc->nr_freepages) {\n\t\t\tblockpfn += isolated;\n\t\t\tbreak;\n\t\t}\n\t\t/* Advance to the end of split page */\n\t\tblockpfn += isolated - 1;\n\t\tcursor += isolated - 1;\n\t\tcontinue;\n\nisolate_fail:\n\t\tif (strict)\n\t\t\tbreak;\n\t\telse\n\t\t\tcontinue;\n\n\t}\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(&cc->zone->lock, flags);\n\n\t/*\n\t * There is a tiny chance that we have read bogus compound_order(),\n\t * so be careful to not go outside of the pageblock.\n\t */\n\tif (unlikely(blockpfn > end_pfn))\n\t\tblockpfn = end_pfn;\n\n\ttrace_mm_compaction_isolate_freepages(*start_pfn, blockpfn,\n\t\t\t\t\tnr_scanned, total_isolated);\n\n\t/* Record how far we have got within the block */\n\t*start_pfn = blockpfn;\n\n\t/*\n\t * If strict isolation is requested by CMA then check that all the\n\t * pages requested were isolated. If there were any failures, 0 is\n\t * returned and CMA will fail.\n\t */\n\tif (strict && blockpfn < end_pfn)\n\t\ttotal_isolated = 0;\n\n\t/* Update the pageblock-skip if the whole pageblock was scanned */\n\tif (blockpfn == end_pfn)\n\t\tupdate_pageblock_skip(cc, valid_page, total_isolated, false);\n\n\tcc->total_free_scanned += nr_scanned;\n\tif (total_isolated)\n\t\tcount_compact_events(COMPACTISOLATED, total_isolated);\n\treturn total_isolated;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pageblock_pfn_to_page",
          "args": [
            "block_start_pfn",
            "block_end_pfn",
            "cc->zone"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "__pageblock_pfn_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1366-1392",
          "snippet": "struct page *__pageblock_pfn_to_page(unsigned long start_pfn,\n\t\t\t\t     unsigned long end_pfn, struct zone *zone)\n{\n\tstruct page *start_page;\n\tstruct page *end_page;\n\n\t/* end_pfn is one past the range we are checking */\n\tend_pfn--;\n\n\tif (!pfn_valid(start_pfn) || !pfn_valid(end_pfn))\n\t\treturn NULL;\n\n\tstart_page = pfn_to_online_page(start_pfn);\n\tif (!start_page)\n\t\treturn NULL;\n\n\tif (page_zone(start_page) != zone)\n\t\treturn NULL;\n\n\tend_page = pfn_to_page(end_pfn);\n\n\t/* This gives a shorter code than deriving page_zone(end_page) */\n\tif (page_zone_id(start_page) != page_zone_id(end_page))\n\t\treturn NULL;\n\n\treturn start_page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstruct page *__pageblock_pfn_to_page(unsigned long start_pfn,\n\t\t\t\t     unsigned long end_pfn, struct zone *zone)\n{\n\tstruct page *start_page;\n\tstruct page *end_page;\n\n\t/* end_pfn is one past the range we are checking */\n\tend_pfn--;\n\n\tif (!pfn_valid(start_pfn) || !pfn_valid(end_pfn))\n\t\treturn NULL;\n\n\tstart_page = pfn_to_online_page(start_pfn);\n\tif (!start_page)\n\t\treturn NULL;\n\n\tif (page_zone(start_page) != zone)\n\t\treturn NULL;\n\n\tend_page = pfn_to_page(end_pfn);\n\n\t/* This gives a shorter code than deriving page_zone(end_page) */\n\tif (page_zone_id(start_page) != page_zone_id(end_page))\n\t\treturn NULL;\n\n\treturn start_page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "block_end_pfn",
            "end_pfn"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pageblock_end_pfn",
          "args": [
            "pfn"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pageblock_start_pfn",
          "args": [
            "pfn"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pageblock_end_pfn",
          "args": [
            "pfn"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pageblock_start_pfn",
          "args": [
            "pfn"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "freelist"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nunsigned long\nisolate_freepages_range(struct compact_control *cc,\n\t\t\tunsigned long start_pfn, unsigned long end_pfn)\n{\n\tunsigned long isolated, pfn, block_start_pfn, block_end_pfn;\n\tLIST_HEAD(freelist);\n\n\tpfn = start_pfn;\n\tblock_start_pfn = pageblock_start_pfn(pfn);\n\tif (block_start_pfn < cc->zone->zone_start_pfn)\n\t\tblock_start_pfn = cc->zone->zone_start_pfn;\n\tblock_end_pfn = pageblock_end_pfn(pfn);\n\n\tfor (; pfn < end_pfn; pfn += isolated,\n\t\t\t\tblock_start_pfn = block_end_pfn,\n\t\t\t\tblock_end_pfn += pageblock_nr_pages) {\n\t\t/* Protect pfn from changing by isolate_freepages_block */\n\t\tunsigned long isolate_start_pfn = pfn;\n\n\t\tblock_end_pfn = min(block_end_pfn, end_pfn);\n\n\t\t/*\n\t\t * pfn could pass the block_end_pfn if isolated freepage\n\t\t * is more than pageblock order. In this case, we adjust\n\t\t * scanning range to right one.\n\t\t */\n\t\tif (pfn >= block_end_pfn) {\n\t\t\tblock_start_pfn = pageblock_start_pfn(pfn);\n\t\t\tblock_end_pfn = pageblock_end_pfn(pfn);\n\t\t\tblock_end_pfn = min(block_end_pfn, end_pfn);\n\t\t}\n\n\t\tif (!pageblock_pfn_to_page(block_start_pfn,\n\t\t\t\t\tblock_end_pfn, cc->zone))\n\t\t\tbreak;\n\n\t\tisolated = isolate_freepages_block(cc, &isolate_start_pfn,\n\t\t\t\t\t\tblock_end_pfn, &freelist, true);\n\n\t\t/*\n\t\t * In strict mode, isolate_freepages_block() returns 0 if\n\t\t * there are any holes in the block (ie. invalid PFNs or\n\t\t * non-free pages).\n\t\t */\n\t\tif (!isolated)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If we managed to isolate pages, it is always (1 << n) *\n\t\t * pageblock_nr_pages for some non-negative n.  (Max order\n\t\t * page may span two pageblocks).\n\t\t */\n\t}\n\n\t/* __isolate_free_page() does not map the pages */\n\tmap_pages(&freelist);\n\n\tif (pfn < end_pfn) {\n\t\t/* Loop terminated early, cleanup. */\n\t\trelease_freepages(&freelist);\n\t\treturn 0;\n\t}\n\n\t/* We don't use freelists for anything. */\n\treturn pfn;\n}"
  },
  {
    "function_name": "isolate_freepages_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "434-576",
    "snippet": "static unsigned long isolate_freepages_block(struct compact_control *cc,\n\t\t\t\tunsigned long *start_pfn,\n\t\t\t\tunsigned long end_pfn,\n\t\t\t\tstruct list_head *freelist,\n\t\t\t\tbool strict)\n{\n\tint nr_scanned = 0, total_isolated = 0;\n\tstruct page *cursor, *valid_page = NULL;\n\tunsigned long flags = 0;\n\tbool locked = false;\n\tunsigned long blockpfn = *start_pfn;\n\tunsigned int order;\n\n\tcursor = pfn_to_page(blockpfn);\n\n\t/* Isolate free pages. */\n\tfor (; blockpfn < end_pfn; blockpfn++, cursor++) {\n\t\tint isolated;\n\t\tstruct page *page = cursor;\n\n\t\t/*\n\t\t * Periodically drop the lock (if held) regardless of its\n\t\t * contention, to give chance to IRQs. Abort if fatal signal\n\t\t * pending or async compaction detects need_resched()\n\t\t */\n\t\tif (!(blockpfn % SWAP_CLUSTER_MAX)\n\t\t    && compact_unlock_should_abort(&cc->zone->lock, flags,\n\t\t\t\t\t\t\t\t&locked, cc))\n\t\t\tbreak;\n\n\t\tnr_scanned++;\n\t\tif (!pfn_valid_within(blockpfn))\n\t\t\tgoto isolate_fail;\n\n\t\tif (!valid_page)\n\t\t\tvalid_page = page;\n\n\t\t/*\n\t\t * For compound pages such as THP and hugetlbfs, we can save\n\t\t * potentially a lot of iterations if we skip them at once.\n\t\t * The check is racy, but we can consider only valid values\n\t\t * and the only danger is skipping too much.\n\t\t */\n\t\tif (PageCompound(page)) {\n\t\t\tconst unsigned int order = compound_order(page);\n\n\t\t\tif (likely(order < MAX_ORDER)) {\n\t\t\t\tblockpfn += (1UL << order) - 1;\n\t\t\t\tcursor += (1UL << order) - 1;\n\t\t\t}\n\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\tif (!PageBuddy(page))\n\t\t\tgoto isolate_fail;\n\n\t\t/*\n\t\t * If we already hold the lock, we can skip some rechecking.\n\t\t * Note that if we hold the lock now, checked_pageblock was\n\t\t * already set in some previous iteration (or strict is true),\n\t\t * so it is correct to skip the suitable migration target\n\t\t * recheck as well.\n\t\t */\n\t\tif (!locked) {\n\t\t\t/*\n\t\t\t * The zone lock must be held to isolate freepages.\n\t\t\t * Unfortunately this is a very coarse lock and can be\n\t\t\t * heavily contended if there are parallel allocations\n\t\t\t * or parallel compactions. For async compaction do not\n\t\t\t * spin on the lock and we acquire the lock as late as\n\t\t\t * possible.\n\t\t\t */\n\t\t\tlocked = compact_trylock_irqsave(&cc->zone->lock,\n\t\t\t\t\t\t\t\t&flags, cc);\n\t\t\tif (!locked)\n\t\t\t\tbreak;\n\n\t\t\t/* Recheck this is a buddy page under lock */\n\t\t\tif (!PageBuddy(page))\n\t\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\t/* Found a free page, will break it into order-0 pages */\n\t\torder = page_order(page);\n\t\tisolated = __isolate_free_page(page, order);\n\t\tif (!isolated)\n\t\t\tbreak;\n\t\tset_page_private(page, order);\n\n\t\ttotal_isolated += isolated;\n\t\tcc->nr_freepages += isolated;\n\t\tlist_add_tail(&page->lru, freelist);\n\n\t\tif (!strict && cc->nr_migratepages <= cc->nr_freepages) {\n\t\t\tblockpfn += isolated;\n\t\t\tbreak;\n\t\t}\n\t\t/* Advance to the end of split page */\n\t\tblockpfn += isolated - 1;\n\t\tcursor += isolated - 1;\n\t\tcontinue;\n\nisolate_fail:\n\t\tif (strict)\n\t\t\tbreak;\n\t\telse\n\t\t\tcontinue;\n\n\t}\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(&cc->zone->lock, flags);\n\n\t/*\n\t * There is a tiny chance that we have read bogus compound_order(),\n\t * so be careful to not go outside of the pageblock.\n\t */\n\tif (unlikely(blockpfn > end_pfn))\n\t\tblockpfn = end_pfn;\n\n\ttrace_mm_compaction_isolate_freepages(*start_pfn, blockpfn,\n\t\t\t\t\tnr_scanned, total_isolated);\n\n\t/* Record how far we have got within the block */\n\t*start_pfn = blockpfn;\n\n\t/*\n\t * If strict isolation is requested by CMA then check that all the\n\t * pages requested were isolated. If there were any failures, 0 is\n\t * returned and CMA will fail.\n\t */\n\tif (strict && blockpfn < end_pfn)\n\t\ttotal_isolated = 0;\n\n\t/* Update the pageblock-skip if the whole pageblock was scanned */\n\tif (blockpfn == end_pfn)\n\t\tupdate_pageblock_skip(cc, valid_page, total_isolated, false);\n\n\tcc->total_free_scanned += nr_scanned;\n\tif (total_isolated)\n\t\tcount_compact_events(COMPACTISOLATED, total_isolated);\n\treturn total_isolated;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "count_compact_events",
          "args": [
            "COMPACTISOLATED",
            "total_isolated"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "count_compact_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "34-37",
          "snippet": "static inline void count_compact_events(enum vm_event_item item, long delta)\n{\n\tcount_vm_events(item, delta);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline void count_compact_events(enum vm_event_item item, long delta)\n{\n\tcount_vm_events(item, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_pageblock_skip",
          "args": [
            "cc",
            "valid_page",
            "total_isolated",
            "false"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "update_pageblock_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "336-340",
          "snippet": "static inline void update_pageblock_skip(struct compact_control *cc,\n\t\t\tstruct page *page, unsigned long nr_isolated,\n\t\t\tbool migrate_scanner)\n{\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline void update_pageblock_skip(struct compact_control *cc,\n\t\t\tstruct page *page, unsigned long nr_isolated,\n\t\t\tbool migrate_scanner)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_mm_compaction_isolate_freepages",
          "args": [
            "*start_pfn",
            "blockpfn",
            "nr_scanned",
            "total_isolated"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "blockpfn > end_pfn"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&cc->zone->lock",
            "flags"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&page->lru",
            "freelist"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "order"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__isolate_free_page",
          "args": [
            "page",
            "order"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "__isolate_free_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2859-2906",
          "snippet": "int __isolate_free_page(struct page *page, unsigned int order)\n{\n\tunsigned long watermark;\n\tstruct zone *zone;\n\tint mt;\n\n\tBUG_ON(!PageBuddy(page));\n\n\tzone = page_zone(page);\n\tmt = get_pageblock_migratetype(page);\n\n\tif (!is_migrate_isolate(mt)) {\n\t\t/*\n\t\t * Obey watermarks as if the page was being allocated. We can\n\t\t * emulate a high-order watermark check with a raised order-0\n\t\t * watermark, because we already know our high-order page\n\t\t * exists.\n\t\t */\n\t\twatermark = min_wmark_pages(zone) + (1UL << order);\n\t\tif (!zone_watermark_ok(zone, 0, watermark, 0, ALLOC_CMA))\n\t\t\treturn 0;\n\n\t\t__mod_zone_freepage_state(zone, -(1UL << order), mt);\n\t}\n\n\t/* Remove page from free list */\n\tlist_del(&page->lru);\n\tzone->free_area[order].nr_free--;\n\trmv_page_order(page);\n\n\t/*\n\t * Set the pageblock if the isolated page is at least half of a\n\t * pageblock\n\t */\n\tif (order >= pageblock_order - 1) {\n\t\tstruct page *endpage = page + (1 << order) - 1;\n\t\tfor (; page < endpage; page += pageblock_nr_pages) {\n\t\t\tint mt = get_pageblock_migratetype(page);\n\t\t\tif (!is_migrate_isolate(mt) && !is_migrate_cma(mt)\n\t\t\t    && !is_migrate_highatomic(mt))\n\t\t\t\tset_pageblock_migratetype(page,\n\t\t\t\t\t\t\t  MIGRATE_MOVABLE);\n\t\t}\n\t}\n\n\n\treturn 1UL << order;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nint __isolate_free_page(struct page *page, unsigned int order)\n{\n\tunsigned long watermark;\n\tstruct zone *zone;\n\tint mt;\n\n\tBUG_ON(!PageBuddy(page));\n\n\tzone = page_zone(page);\n\tmt = get_pageblock_migratetype(page);\n\n\tif (!is_migrate_isolate(mt)) {\n\t\t/*\n\t\t * Obey watermarks as if the page was being allocated. We can\n\t\t * emulate a high-order watermark check with a raised order-0\n\t\t * watermark, because we already know our high-order page\n\t\t * exists.\n\t\t */\n\t\twatermark = min_wmark_pages(zone) + (1UL << order);\n\t\tif (!zone_watermark_ok(zone, 0, watermark, 0, ALLOC_CMA))\n\t\t\treturn 0;\n\n\t\t__mod_zone_freepage_state(zone, -(1UL << order), mt);\n\t}\n\n\t/* Remove page from free list */\n\tlist_del(&page->lru);\n\tzone->free_area[order].nr_free--;\n\trmv_page_order(page);\n\n\t/*\n\t * Set the pageblock if the isolated page is at least half of a\n\t * pageblock\n\t */\n\tif (order >= pageblock_order - 1) {\n\t\tstruct page *endpage = page + (1 << order) - 1;\n\t\tfor (; page < endpage; page += pageblock_nr_pages) {\n\t\t\tint mt = get_pageblock_migratetype(page);\n\t\t\tif (!is_migrate_isolate(mt) && !is_migrate_cma(mt)\n\t\t\t    && !is_migrate_highatomic(mt))\n\t\t\t\tset_pageblock_migratetype(page,\n\t\t\t\t\t\t\t  MIGRATE_MOVABLE);\n\t\t}\n\t}\n\n\n\treturn 1UL << order;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_order",
          "args": [
            "page"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "rmv_page_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "707-711",
          "snippet": "static inline void rmv_page_order(struct page *page)\n{\n\t__ClearPageBuddy(page);\n\tset_page_private(page, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void rmv_page_order(struct page *page)\n{\n\t__ClearPageBuddy(page);\n\tset_page_private(page, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageBuddy",
          "args": [
            "page"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compact_trylock_irqsave",
          "args": [
            "&cc->zone->lock",
            "&flags",
            "cc"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "compact_trylock_irqsave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "351-364",
          "snippet": "static bool compact_trylock_irqsave(spinlock_t *lock, unsigned long *flags,\n\t\t\t\t\t\tstruct compact_control *cc)\n{\n\tif (cc->mode == MIGRATE_ASYNC) {\n\t\tif (!spin_trylock_irqsave(lock, *flags)) {\n\t\t\tcc->contended = true;\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tspin_lock_irqsave(lock, *flags);\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic bool compact_trylock_irqsave(spinlock_t *lock, unsigned long *flags,\n\t\t\t\t\t\tstruct compact_control *cc)\n{\n\tif (cc->mode == MIGRATE_ASYNC) {\n\t\tif (!spin_trylock_irqsave(lock, *flags)) {\n\t\t\tcc->contended = true;\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tspin_lock_irqsave(lock, *flags);\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageBuddy",
          "args": [
            "page"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "order < MAX_ORDER"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid_within",
          "args": [
            "blockpfn"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compact_unlock_should_abort",
          "args": [
            "&cc->zone->lock",
            "flags",
            "&locked",
            "cc"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "compact_unlock_should_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "381-403",
          "snippet": "static bool compact_unlock_should_abort(spinlock_t *lock,\n\t\tunsigned long flags, bool *locked, struct compact_control *cc)\n{\n\tif (*locked) {\n\t\tspin_unlock_irqrestore(lock, flags);\n\t\t*locked = false;\n\t}\n\n\tif (fatal_signal_pending(current)) {\n\t\tcc->contended = true;\n\t\treturn true;\n\t}\n\n\tif (need_resched()) {\n\t\tif (cc->mode == MIGRATE_ASYNC) {\n\t\t\tcc->contended = true;\n\t\t\treturn true;\n\t\t}\n\t\tcond_resched();\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic bool compact_unlock_should_abort(spinlock_t *lock,\n\t\tunsigned long flags, bool *locked, struct compact_control *cc)\n{\n\tif (*locked) {\n\t\tspin_unlock_irqrestore(lock, flags);\n\t\t*locked = false;\n\t}\n\n\tif (fatal_signal_pending(current)) {\n\t\tcc->contended = true;\n\t\treturn true;\n\t}\n\n\tif (need_resched()) {\n\t\tif (cc->mode == MIGRATE_ASYNC) {\n\t\t\tcc->contended = true;\n\t\t\treturn true;\n\t\t}\n\t\tcond_resched();\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "blockpfn"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic unsigned long isolate_freepages_block(struct compact_control *cc,\n\t\t\t\tunsigned long *start_pfn,\n\t\t\t\tunsigned long end_pfn,\n\t\t\t\tstruct list_head *freelist,\n\t\t\t\tbool strict)\n{\n\tint nr_scanned = 0, total_isolated = 0;\n\tstruct page *cursor, *valid_page = NULL;\n\tunsigned long flags = 0;\n\tbool locked = false;\n\tunsigned long blockpfn = *start_pfn;\n\tunsigned int order;\n\n\tcursor = pfn_to_page(blockpfn);\n\n\t/* Isolate free pages. */\n\tfor (; blockpfn < end_pfn; blockpfn++, cursor++) {\n\t\tint isolated;\n\t\tstruct page *page = cursor;\n\n\t\t/*\n\t\t * Periodically drop the lock (if held) regardless of its\n\t\t * contention, to give chance to IRQs. Abort if fatal signal\n\t\t * pending or async compaction detects need_resched()\n\t\t */\n\t\tif (!(blockpfn % SWAP_CLUSTER_MAX)\n\t\t    && compact_unlock_should_abort(&cc->zone->lock, flags,\n\t\t\t\t\t\t\t\t&locked, cc))\n\t\t\tbreak;\n\n\t\tnr_scanned++;\n\t\tif (!pfn_valid_within(blockpfn))\n\t\t\tgoto isolate_fail;\n\n\t\tif (!valid_page)\n\t\t\tvalid_page = page;\n\n\t\t/*\n\t\t * For compound pages such as THP and hugetlbfs, we can save\n\t\t * potentially a lot of iterations if we skip them at once.\n\t\t * The check is racy, but we can consider only valid values\n\t\t * and the only danger is skipping too much.\n\t\t */\n\t\tif (PageCompound(page)) {\n\t\t\tconst unsigned int order = compound_order(page);\n\n\t\t\tif (likely(order < MAX_ORDER)) {\n\t\t\t\tblockpfn += (1UL << order) - 1;\n\t\t\t\tcursor += (1UL << order) - 1;\n\t\t\t}\n\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\tif (!PageBuddy(page))\n\t\t\tgoto isolate_fail;\n\n\t\t/*\n\t\t * If we already hold the lock, we can skip some rechecking.\n\t\t * Note that if we hold the lock now, checked_pageblock was\n\t\t * already set in some previous iteration (or strict is true),\n\t\t * so it is correct to skip the suitable migration target\n\t\t * recheck as well.\n\t\t */\n\t\tif (!locked) {\n\t\t\t/*\n\t\t\t * The zone lock must be held to isolate freepages.\n\t\t\t * Unfortunately this is a very coarse lock and can be\n\t\t\t * heavily contended if there are parallel allocations\n\t\t\t * or parallel compactions. For async compaction do not\n\t\t\t * spin on the lock and we acquire the lock as late as\n\t\t\t * possible.\n\t\t\t */\n\t\t\tlocked = compact_trylock_irqsave(&cc->zone->lock,\n\t\t\t\t\t\t\t\t&flags, cc);\n\t\t\tif (!locked)\n\t\t\t\tbreak;\n\n\t\t\t/* Recheck this is a buddy page under lock */\n\t\t\tif (!PageBuddy(page))\n\t\t\t\tgoto isolate_fail;\n\t\t}\n\n\t\t/* Found a free page, will break it into order-0 pages */\n\t\torder = page_order(page);\n\t\tisolated = __isolate_free_page(page, order);\n\t\tif (!isolated)\n\t\t\tbreak;\n\t\tset_page_private(page, order);\n\n\t\ttotal_isolated += isolated;\n\t\tcc->nr_freepages += isolated;\n\t\tlist_add_tail(&page->lru, freelist);\n\n\t\tif (!strict && cc->nr_migratepages <= cc->nr_freepages) {\n\t\t\tblockpfn += isolated;\n\t\t\tbreak;\n\t\t}\n\t\t/* Advance to the end of split page */\n\t\tblockpfn += isolated - 1;\n\t\tcursor += isolated - 1;\n\t\tcontinue;\n\nisolate_fail:\n\t\tif (strict)\n\t\t\tbreak;\n\t\telse\n\t\t\tcontinue;\n\n\t}\n\n\tif (locked)\n\t\tspin_unlock_irqrestore(&cc->zone->lock, flags);\n\n\t/*\n\t * There is a tiny chance that we have read bogus compound_order(),\n\t * so be careful to not go outside of the pageblock.\n\t */\n\tif (unlikely(blockpfn > end_pfn))\n\t\tblockpfn = end_pfn;\n\n\ttrace_mm_compaction_isolate_freepages(*start_pfn, blockpfn,\n\t\t\t\t\tnr_scanned, total_isolated);\n\n\t/* Record how far we have got within the block */\n\t*start_pfn = blockpfn;\n\n\t/*\n\t * If strict isolation is requested by CMA then check that all the\n\t * pages requested were isolated. If there were any failures, 0 is\n\t * returned and CMA will fail.\n\t */\n\tif (strict && blockpfn < end_pfn)\n\t\ttotal_isolated = 0;\n\n\t/* Update the pageblock-skip if the whole pageblock was scanned */\n\tif (blockpfn == end_pfn)\n\t\tupdate_pageblock_skip(cc, valid_page, total_isolated, false);\n\n\tcc->total_free_scanned += nr_scanned;\n\tif (total_isolated)\n\t\tcount_compact_events(COMPACTISOLATED, total_isolated);\n\treturn total_isolated;\n}"
  },
  {
    "function_name": "compact_should_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "414-427",
    "snippet": "static inline bool compact_should_abort(struct compact_control *cc)\n{\n\t/* async compaction aborts if contended */\n\tif (need_resched()) {\n\t\tif (cc->mode == MIGRATE_ASYNC) {\n\t\t\tcc->contended = true;\n\t\t\treturn true;\n\t\t}\n\n\t\tcond_resched();\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline bool compact_should_abort(struct compact_control *cc)\n{\n\t/* async compaction aborts if contended */\n\tif (need_resched()) {\n\t\tif (cc->mode == MIGRATE_ASYNC) {\n\t\t\tcc->contended = true;\n\t\t\treturn true;\n\t\t}\n\n\t\tcond_resched();\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "compact_unlock_should_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "381-403",
    "snippet": "static bool compact_unlock_should_abort(spinlock_t *lock,\n\t\tunsigned long flags, bool *locked, struct compact_control *cc)\n{\n\tif (*locked) {\n\t\tspin_unlock_irqrestore(lock, flags);\n\t\t*locked = false;\n\t}\n\n\tif (fatal_signal_pending(current)) {\n\t\tcc->contended = true;\n\t\treturn true;\n\t}\n\n\tif (need_resched()) {\n\t\tif (cc->mode == MIGRATE_ASYNC) {\n\t\t\tcc->contended = true;\n\t\t\treturn true;\n\t\t}\n\t\tcond_resched();\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "lock",
            "flags"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic bool compact_unlock_should_abort(spinlock_t *lock,\n\t\tunsigned long flags, bool *locked, struct compact_control *cc)\n{\n\tif (*locked) {\n\t\tspin_unlock_irqrestore(lock, flags);\n\t\t*locked = false;\n\t}\n\n\tif (fatal_signal_pending(current)) {\n\t\tcc->contended = true;\n\t\treturn true;\n\t}\n\n\tif (need_resched()) {\n\t\tif (cc->mode == MIGRATE_ASYNC) {\n\t\t\tcc->contended = true;\n\t\t\treturn true;\n\t\t}\n\t\tcond_resched();\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "compact_trylock_irqsave",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "351-364",
    "snippet": "static bool compact_trylock_irqsave(spinlock_t *lock, unsigned long *flags,\n\t\t\t\t\t\tstruct compact_control *cc)\n{\n\tif (cc->mode == MIGRATE_ASYNC) {\n\t\tif (!spin_trylock_irqsave(lock, *flags)) {\n\t\t\tcc->contended = true;\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tspin_lock_irqsave(lock, *flags);\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "lock",
            "*flags"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_trylock_irqsave",
          "args": [
            "lock",
            "*flags"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic bool compact_trylock_irqsave(spinlock_t *lock, unsigned long *flags,\n\t\t\t\t\t\tstruct compact_control *cc)\n{\n\tif (cc->mode == MIGRATE_ASYNC) {\n\t\tif (!spin_trylock_irqsave(lock, *flags)) {\n\t\t\tcc->contended = true;\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tspin_lock_irqsave(lock, *flags);\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "update_pageblock_skip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "336-340",
    "snippet": "static inline void update_pageblock_skip(struct compact_control *cc,\n\t\t\tstruct page *page, unsigned long nr_isolated,\n\t\t\tbool migrate_scanner)\n{\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline void update_pageblock_skip(struct compact_control *cc,\n\t\t\tstruct page *page, unsigned long nr_isolated,\n\t\t\tbool migrate_scanner)\n{\n}"
  },
  {
    "function_name": "pageblock_skip_persistent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "331-334",
    "snippet": "static inline bool pageblock_skip_persistent(struct page *page)\n{\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline bool pageblock_skip_persistent(struct page *page)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "isolation_suitable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "325-329",
    "snippet": "static inline bool isolation_suitable(struct compact_control *cc,\n\t\t\t\t\tstruct page *page)\n{\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline bool isolation_suitable(struct compact_control *cc,\n\t\t\t\t\tstruct page *page)\n{\n\treturn true;\n}"
  },
  {
    "function_name": "update_pageblock_skip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "292-323",
    "snippet": "static void update_pageblock_skip(struct compact_control *cc,\n\t\t\tstruct page *page, unsigned long nr_isolated,\n\t\t\tbool migrate_scanner)\n{\n\tstruct zone *zone = cc->zone;\n\tunsigned long pfn;\n\n\tif (cc->no_set_skip_hint)\n\t\treturn;\n\n\tif (!page)\n\t\treturn;\n\n\tif (nr_isolated)\n\t\treturn;\n\n\tset_pageblock_skip(page);\n\n\tpfn = page_to_pfn(page);\n\n\t/* Update where async and sync compaction should restart */\n\tif (migrate_scanner) {\n\t\tif (pfn > zone->compact_cached_migrate_pfn[0])\n\t\t\tzone->compact_cached_migrate_pfn[0] = pfn;\n\t\tif (cc->mode != MIGRATE_ASYNC &&\n\t\t    pfn > zone->compact_cached_migrate_pfn[1])\n\t\t\tzone->compact_cached_migrate_pfn[1] = pfn;\n\t} else {\n\t\tif (pfn < zone->compact_cached_free_pfn)\n\t\t\tzone->compact_cached_free_pfn = pfn;\n\t}\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pageblock_skip",
          "args": [
            "page"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic void update_pageblock_skip(struct compact_control *cc,\n\t\t\tstruct page *page, unsigned long nr_isolated,\n\t\t\tbool migrate_scanner)\n{\n\tstruct zone *zone = cc->zone;\n\tunsigned long pfn;\n\n\tif (cc->no_set_skip_hint)\n\t\treturn;\n\n\tif (!page)\n\t\treturn;\n\n\tif (nr_isolated)\n\t\treturn;\n\n\tset_pageblock_skip(page);\n\n\tpfn = page_to_pfn(page);\n\n\t/* Update where async and sync compaction should restart */\n\tif (migrate_scanner) {\n\t\tif (pfn > zone->compact_cached_migrate_pfn[0])\n\t\t\tzone->compact_cached_migrate_pfn[0] = pfn;\n\t\tif (cc->mode != MIGRATE_ASYNC &&\n\t\t    pfn > zone->compact_cached_migrate_pfn[1])\n\t\t\tzone->compact_cached_migrate_pfn[1] = pfn;\n\t} else {\n\t\tif (pfn < zone->compact_cached_free_pfn)\n\t\t\tzone->compact_cached_free_pfn = pfn;\n\t}\n}"
  },
  {
    "function_name": "reset_isolation_suitable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "273-286",
    "snippet": "void reset_isolation_suitable(pg_data_t *pgdat)\n{\n\tint zoneid;\n\n\tfor (zoneid = 0; zoneid < MAX_NR_ZONES; zoneid++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zoneid];\n\t\tif (!populated_zone(zone))\n\t\t\tcontinue;\n\n\t\t/* Only flush if a full compaction finished recently */\n\t\tif (zone->compact_blockskip_flush)\n\t\t\t__reset_isolation_suitable(zone);\n\t}\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__reset_isolation_suitable",
          "args": [
            "zone"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "__reset_isolation_suitable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "245-271",
          "snippet": "static void __reset_isolation_suitable(struct zone *zone)\n{\n\tunsigned long start_pfn = zone->zone_start_pfn;\n\tunsigned long end_pfn = zone_end_pfn(zone);\n\tunsigned long pfn;\n\n\tzone->compact_blockskip_flush = false;\n\n\t/* Walk the zone and mark every pageblock as suitable for isolation */\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += pageblock_nr_pages) {\n\t\tstruct page *page;\n\n\t\tcond_resched();\n\n\t\tpage = pfn_to_online_page(pfn);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (zone != page_zone(page))\n\t\t\tcontinue;\n\t\tif (pageblock_skip_persistent(page))\n\t\t\tcontinue;\n\n\t\tclear_pageblock_skip(page);\n\t}\n\n\treset_cached_positions(zone);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic void __reset_isolation_suitable(struct zone *zone)\n{\n\tunsigned long start_pfn = zone->zone_start_pfn;\n\tunsigned long end_pfn = zone_end_pfn(zone);\n\tunsigned long pfn;\n\n\tzone->compact_blockskip_flush = false;\n\n\t/* Walk the zone and mark every pageblock as suitable for isolation */\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += pageblock_nr_pages) {\n\t\tstruct page *page;\n\n\t\tcond_resched();\n\n\t\tpage = pfn_to_online_page(pfn);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (zone != page_zone(page))\n\t\t\tcontinue;\n\t\tif (pageblock_skip_persistent(page))\n\t\t\tcontinue;\n\n\t\tclear_pageblock_skip(page);\n\t}\n\n\treset_cached_positions(zone);\n}"
        }
      },
      {
        "call_info": {
          "callee": "populated_zone",
          "args": [
            "zone"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nvoid reset_isolation_suitable(pg_data_t *pgdat)\n{\n\tint zoneid;\n\n\tfor (zoneid = 0; zoneid < MAX_NR_ZONES; zoneid++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zoneid];\n\t\tif (!populated_zone(zone))\n\t\t\tcontinue;\n\n\t\t/* Only flush if a full compaction finished recently */\n\t\tif (zone->compact_blockskip_flush)\n\t\t\t__reset_isolation_suitable(zone);\n\t}\n}"
  },
  {
    "function_name": "__reset_isolation_suitable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "245-271",
    "snippet": "static void __reset_isolation_suitable(struct zone *zone)\n{\n\tunsigned long start_pfn = zone->zone_start_pfn;\n\tunsigned long end_pfn = zone_end_pfn(zone);\n\tunsigned long pfn;\n\n\tzone->compact_blockskip_flush = false;\n\n\t/* Walk the zone and mark every pageblock as suitable for isolation */\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += pageblock_nr_pages) {\n\t\tstruct page *page;\n\n\t\tcond_resched();\n\n\t\tpage = pfn_to_online_page(pfn);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (zone != page_zone(page))\n\t\t\tcontinue;\n\t\tif (pageblock_skip_persistent(page))\n\t\t\tcontinue;\n\n\t\tclear_pageblock_skip(page);\n\t}\n\n\treset_cached_positions(zone);\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reset_cached_positions",
          "args": [
            "zone"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "reset_cached_positions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "214-220",
          "snippet": "static void reset_cached_positions(struct zone *zone)\n{\n\tzone->compact_cached_migrate_pfn[0] = zone->zone_start_pfn;\n\tzone->compact_cached_migrate_pfn[1] = zone->zone_start_pfn;\n\tzone->compact_cached_free_pfn =\n\t\t\t\tpageblock_start_pfn(zone_end_pfn(zone) - 1);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic void reset_cached_positions(struct zone *zone)\n{\n\tzone->compact_cached_migrate_pfn[0] = zone->zone_start_pfn;\n\tzone->compact_cached_migrate_pfn[1] = zone->zone_start_pfn;\n\tzone->compact_cached_free_pfn =\n\t\t\t\tpageblock_start_pfn(zone_end_pfn(zone) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_pageblock_skip",
          "args": [
            "page"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pageblock_skip_persistent",
          "args": [
            "page"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "pageblock_skip_persistent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "331-334",
          "snippet": "static inline bool pageblock_skip_persistent(struct page *page)\n{\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline bool pageblock_skip_persistent(struct page *page)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_online_page",
          "args": [
            "pfn"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_end_pfn",
          "args": [
            "zone"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic void __reset_isolation_suitable(struct zone *zone)\n{\n\tunsigned long start_pfn = zone->zone_start_pfn;\n\tunsigned long end_pfn = zone_end_pfn(zone);\n\tunsigned long pfn;\n\n\tzone->compact_blockskip_flush = false;\n\n\t/* Walk the zone and mark every pageblock as suitable for isolation */\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += pageblock_nr_pages) {\n\t\tstruct page *page;\n\n\t\tcond_resched();\n\n\t\tpage = pfn_to_online_page(pfn);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (zone != page_zone(page))\n\t\t\tcontinue;\n\t\tif (pageblock_skip_persistent(page))\n\t\t\tcontinue;\n\n\t\tclear_pageblock_skip(page);\n\t}\n\n\treset_cached_positions(zone);\n}"
  },
  {
    "function_name": "pageblock_skip_persistent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "227-238",
    "snippet": "static bool pageblock_skip_persistent(struct page *page)\n{\n\tif (!PageCompound(page))\n\t\treturn false;\n\n\tpage = compound_head(page);\n\n\tif (compound_order(page) >= pageblock_order)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic bool pageblock_skip_persistent(struct page *page)\n{\n\tif (!PageCompound(page))\n\t\treturn false;\n\n\tpage = compound_head(page);\n\n\tif (compound_order(page) >= pageblock_order)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "reset_cached_positions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "214-220",
    "snippet": "static void reset_cached_positions(struct zone *zone)\n{\n\tzone->compact_cached_migrate_pfn[0] = zone->zone_start_pfn;\n\tzone->compact_cached_migrate_pfn[1] = zone->zone_start_pfn;\n\tzone->compact_cached_free_pfn =\n\t\t\t\tpageblock_start_pfn(zone_end_pfn(zone) - 1);\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pageblock_start_pfn",
          "args": [
            "zone_end_pfn(zone) - 1"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_end_pfn",
          "args": [
            "zone"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic void reset_cached_positions(struct zone *zone)\n{\n\tzone->compact_cached_migrate_pfn[0] = zone->zone_start_pfn;\n\tzone->compact_cached_migrate_pfn[1] = zone->zone_start_pfn;\n\tzone->compact_cached_free_pfn =\n\t\t\t\tpageblock_start_pfn(zone_end_pfn(zone) - 1);\n}"
  },
  {
    "function_name": "isolation_suitable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "205-212",
    "snippet": "static inline bool isolation_suitable(struct compact_control *cc,\n\t\t\t\t\tstruct page *page)\n{\n\tif (cc->ignore_skip_hint)\n\t\treturn true;\n\n\treturn !get_pageblock_skip(page);\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_pageblock_skip",
          "args": [
            "page"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline bool isolation_suitable(struct compact_control *cc,\n\t\t\t\t\tstruct page *page)\n{\n\tif (cc->ignore_skip_hint)\n\t\treturn true;\n\n\treturn !get_pageblock_skip(page);\n}"
  },
  {
    "function_name": "compaction_restarting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "195-202",
    "snippet": "bool compaction_restarting(struct zone *zone, int order)\n{\n\tif (order < zone->compact_order_failed)\n\t\treturn false;\n\n\treturn zone->compact_defer_shift == COMPACT_MAX_DEFER_SHIFT &&\n\t\tzone->compact_considered >= 1UL << zone->compact_defer_shift;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define COMPACT_MAX_DEFER_SHIFT 6"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\n#define COMPACT_MAX_DEFER_SHIFT 6\n\nbool compaction_restarting(struct zone *zone, int order)\n{\n\tif (order < zone->compact_order_failed)\n\t\treturn false;\n\n\treturn zone->compact_defer_shift == COMPACT_MAX_DEFER_SHIFT &&\n\t\tzone->compact_considered >= 1UL << zone->compact_defer_shift;\n}"
  },
  {
    "function_name": "compaction_defer_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "181-192",
    "snippet": "void compaction_defer_reset(struct zone *zone, int order,\n\t\tbool alloc_success)\n{\n\tif (alloc_success) {\n\t\tzone->compact_considered = 0;\n\t\tzone->compact_defer_shift = 0;\n\t}\n\tif (order >= zone->compact_order_failed)\n\t\tzone->compact_order_failed = order + 1;\n\n\ttrace_mm_compaction_defer_reset(zone, order);\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_mm_compaction_defer_reset",
          "args": [
            "zone",
            "order"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nvoid compaction_defer_reset(struct zone *zone, int order,\n\t\tbool alloc_success)\n{\n\tif (alloc_success) {\n\t\tzone->compact_considered = 0;\n\t\tzone->compact_defer_shift = 0;\n\t}\n\tif (order >= zone->compact_order_failed)\n\t\tzone->compact_order_failed = order + 1;\n\n\ttrace_mm_compaction_defer_reset(zone, order);\n}"
  },
  {
    "function_name": "compaction_deferred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "157-174",
    "snippet": "bool compaction_deferred(struct zone *zone, int order)\n{\n\tunsigned long defer_limit = 1UL << zone->compact_defer_shift;\n\n\tif (order < zone->compact_order_failed)\n\t\treturn false;\n\n\t/* Avoid possible overflow */\n\tif (++zone->compact_considered > defer_limit)\n\t\tzone->compact_considered = defer_limit;\n\n\tif (zone->compact_considered >= defer_limit)\n\t\treturn false;\n\n\ttrace_mm_compaction_deferred(zone, order);\n\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_mm_compaction_deferred",
          "args": [
            "zone",
            "order"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nbool compaction_deferred(struct zone *zone, int order)\n{\n\tunsigned long defer_limit = 1UL << zone->compact_defer_shift;\n\n\tif (order < zone->compact_order_failed)\n\t\treturn false;\n\n\t/* Avoid possible overflow */\n\tif (++zone->compact_considered > defer_limit)\n\t\tzone->compact_considered = defer_limit;\n\n\tif (zone->compact_considered >= defer_limit)\n\t\treturn false;\n\n\ttrace_mm_compaction_deferred(zone, order);\n\n\treturn true;\n}"
  },
  {
    "function_name": "defer_compaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "142-154",
    "snippet": "void defer_compaction(struct zone *zone, int order)\n{\n\tzone->compact_considered = 0;\n\tzone->compact_defer_shift++;\n\n\tif (order < zone->compact_order_failed)\n\t\tzone->compact_order_failed = order;\n\n\tif (zone->compact_defer_shift > COMPACT_MAX_DEFER_SHIFT)\n\t\tzone->compact_defer_shift = COMPACT_MAX_DEFER_SHIFT;\n\n\ttrace_mm_compaction_defer_compaction(zone, order);\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define COMPACT_MAX_DEFER_SHIFT 6"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_mm_compaction_defer_compaction",
          "args": [
            "zone",
            "order"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\n#define COMPACT_MAX_DEFER_SHIFT 6\n\nvoid defer_compaction(struct zone *zone, int order)\n{\n\tzone->compact_considered = 0;\n\tzone->compact_defer_shift++;\n\n\tif (order < zone->compact_order_failed)\n\t\tzone->compact_order_failed = order;\n\n\tif (zone->compact_defer_shift > COMPACT_MAX_DEFER_SHIFT)\n\t\tzone->compact_defer_shift = COMPACT_MAX_DEFER_SHIFT;\n\n\ttrace_mm_compaction_defer_compaction(zone, order);\n}"
  },
  {
    "function_name": "__ClearPageMovable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "120-131",
    "snippet": "void __ClearPageMovable(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageMovable(page), page);\n\t/*\n\t * Clear registered address_space val with keeping PAGE_MAPPING_MOVABLE\n\t * flag so that VM can catch up released page by driver after isolation.\n\t * With it, VM migration doesn't try to put it back.\n\t */\n\tpage->mapping = (void *)((unsigned long)page->mapping &\n\t\t\t\tPAGE_MAPPING_MOVABLE);\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageMovable(page)",
            "page"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageMovable",
          "args": [
            "page"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "__ClearPageMovable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "120-131",
          "snippet": "void __ClearPageMovable(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageMovable(page), page);\n\t/*\n\t * Clear registered address_space val with keeping PAGE_MAPPING_MOVABLE\n\t * flag so that VM can catch up released page by driver after isolation.\n\t * With it, VM migration doesn't try to put it back.\n\t */\n\tpage->mapping = (void *)((unsigned long)page->mapping &\n\t\t\t\tPAGE_MAPPING_MOVABLE);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nvoid __ClearPageMovable(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageMovable(page), page);\n\t/*\n\t * Clear registered address_space val with keeping PAGE_MAPPING_MOVABLE\n\t * flag so that VM can catch up released page by driver after isolation.\n\t * With it, VM migration doesn't try to put it back.\n\t */\n\tpage->mapping = (void *)((unsigned long)page->mapping &\n\t\t\t\tPAGE_MAPPING_MOVABLE);\n}"
  },
  {
    "function_name": "__SetPageMovable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "112-117",
    "snippet": "void __SetPageMovable(struct page *page, struct address_space *mapping)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE((unsigned long)mapping & PAGE_MAPPING_MOVABLE, page);\n\tpage->mapping = (void *)((unsigned long)mapping | PAGE_MAPPING_MOVABLE);\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "(unsigned long)mapping & PAGE_MAPPING_MOVABLE",
            "page"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nvoid __SetPageMovable(struct page *page, struct address_space *mapping)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE((unsigned long)mapping & PAGE_MAPPING_MOVABLE, page);\n\tpage->mapping = (void *)((unsigned long)mapping | PAGE_MAPPING_MOVABLE);\n}"
  },
  {
    "function_name": "PageMovable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "96-109",
    "snippet": "int PageMovable(struct page *page)\n{\n\tstruct address_space *mapping;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (!__PageMovable(page))\n\t\treturn 0;\n\n\tmapping = page_mapping(page);\n\tif (mapping && mapping->a_ops && mapping->a_ops->isolate_page)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__PageMovable",
          "args": [
            "page"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nint PageMovable(struct page *page)\n{\n\tstruct address_space *mapping;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (!__PageMovable(page))\n\t\treturn 0;\n\n\tmapping = page_mapping(page);\n\tif (mapping && mapping->a_ops && mapping->a_ops->isolate_page)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "map_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "69-92",
    "snippet": "static void map_pages(struct list_head *list)\n{\n\tunsigned int i, order, nr_pages;\n\tstruct page *page, *next;\n\tLIST_HEAD(tmp_list);\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\n\t\torder = page_private(page);\n\t\tnr_pages = 1 << order;\n\n\t\tpost_alloc_hook(page, order, __GFP_MOVABLE);\n\t\tif (order)\n\t\t\tsplit_page(page, order);\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tlist_add(&page->lru, &tmp_list);\n\t\t\tpage++;\n\t\t}\n\t}\n\n\tlist_splice(&tmp_list, list);\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_splice",
          "args": [
            "&tmp_list",
            "list"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->lru",
            "&tmp_list"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split_page",
          "args": [
            "page",
            "order"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "split_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2846-2856",
          "snippet": "void split_page(struct page *page, unsigned int order)\n{\n\tint i;\n\n\tVM_BUG_ON_PAGE(PageCompound(page), page);\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\n\tfor (i = 1; i < (1 << order); i++)\n\t\tset_page_refcounted(page + i);\n\tsplit_page_owner(page, order);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid split_page(struct page *page, unsigned int order)\n{\n\tint i;\n\n\tVM_BUG_ON_PAGE(PageCompound(page), page);\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\n\tfor (i = 1; i < (1 << order); i++)\n\t\tset_page_refcounted(page + i);\n\tsplit_page_owner(page, order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "post_alloc_hook",
          "args": [
            "page",
            "order",
            "__GFP_MOVABLE"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "post_alloc_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1908-1919",
          "snippet": "inline void post_alloc_hook(struct page *page, unsigned int order,\n\t\t\t\tgfp_t gfp_flags)\n{\n\tset_page_private(page, 0);\n\tset_page_refcounted(page);\n\n\tarch_alloc_page(page, order);\n\tkernel_map_pages(page, 1 << order, 1);\n\tkernel_poison_pages(page, 1 << order, 1);\n\tkasan_alloc_pages(page, order);\n\tset_page_owner(page, order, gfp_flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\ninline void post_alloc_hook(struct page *page, unsigned int order,\n\t\t\t\tgfp_t gfp_flags)\n{\n\tset_page_private(page, 0);\n\tset_page_refcounted(page);\n\n\tarch_alloc_page(page, order);\n\tkernel_map_pages(page, 1 << order, 1);\n\tkernel_poison_pages(page, 1 << order, 1);\n\tkasan_alloc_pages(page, order);\n\tset_page_owner(page, order, gfp_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "page",
            "next",
            "list",
            "lru"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "tmp_list"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic void map_pages(struct list_head *list)\n{\n\tunsigned int i, order, nr_pages;\n\tstruct page *page, *next;\n\tLIST_HEAD(tmp_list);\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\n\t\torder = page_private(page);\n\t\tnr_pages = 1 << order;\n\n\t\tpost_alloc_hook(page, order, __GFP_MOVABLE);\n\t\tif (order)\n\t\t\tsplit_page(page, order);\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tlist_add(&page->lru, &tmp_list);\n\t\t\tpage++;\n\t\t}\n\t}\n\n\tlist_splice(&tmp_list, list);\n}"
  },
  {
    "function_name": "release_freepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "53-67",
    "snippet": "static unsigned long release_freepages(struct list_head *freelist)\n{\n\tstruct page *page, *next;\n\tunsigned long high_pfn = 0;\n\n\tlist_for_each_entry_safe(page, next, freelist, lru) {\n\t\tunsigned long pfn = page_to_pfn(page);\n\t\tlist_del(&page->lru);\n\t\t__free_page(page);\n\t\tif (pfn > high_pfn)\n\t\t\thigh_pfn = pfn;\n\t}\n\n\treturn high_pfn;\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "__free_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "280-291",
          "snippet": "static void __free_page_ext(unsigned long pfn)\n{\n\tstruct mem_section *ms;\n\tstruct page_ext *base;\n\n\tms = __pfn_to_section(pfn);\n\tif (!ms || !ms->page_ext)\n\t\treturn;\n\tbase = get_entry(ms->page_ext, pfn);\n\tfree_page_ext(base);\n\tms->page_ext = NULL;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic void __free_page_ext(unsigned long pfn)\n{\n\tstruct mem_section *ms;\n\tstruct page_ext *base;\n\n\tms = __pfn_to_section(pfn);\n\tif (!ms || !ms->page_ext)\n\t\treturn;\n\tbase = get_entry(ms->page_ext, pfn);\n\tfree_page_ext(base);\n\tms->page_ext = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "page",
            "next",
            "freelist",
            "lru"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic unsigned long release_freepages(struct list_head *freelist)\n{\n\tstruct page *page, *next;\n\tunsigned long high_pfn = 0;\n\n\tlist_for_each_entry_safe(page, next, freelist, lru) {\n\t\tunsigned long pfn = page_to_pfn(page);\n\t\tlist_del(&page->lru);\n\t\t__free_page(page);\n\t\tif (pfn > high_pfn)\n\t\t\thigh_pfn = pfn;\n\t}\n\n\treturn high_pfn;\n}"
  },
  {
    "function_name": "count_compact_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "34-37",
    "snippet": "static inline void count_compact_events(enum vm_event_item item, long delta)\n{\n\tcount_vm_events(item, delta);\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "count_vm_events",
          "args": [
            "item",
            "delta"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline void count_compact_events(enum vm_event_item item, long delta)\n{\n\tcount_vm_events(item, delta);\n}"
  },
  {
    "function_name": "count_compact_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
    "lines": "29-32",
    "snippet": "static inline void count_compact_event(enum vm_event_item item)\n{\n\tcount_vm_event(item);\n}",
    "includes": [
      "#include <trace/events/compaction.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kasan.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/compaction.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "item"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic inline void count_compact_event(enum vm_event_item item)\n{\n\tcount_vm_event(item);\n}"
  }
]