[
  {
    "function_name": "mpol_to_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "2812-2860",
    "snippet": "void mpol_to_str(char *buffer, int maxlen, struct mempolicy *pol)\n{\n\tchar *p = buffer;\n\tnodemask_t nodes = NODE_MASK_NONE;\n\tunsigned short mode = MPOL_DEFAULT;\n\tunsigned short flags = 0;\n\n\tif (pol && pol != &default_policy && !(pol->flags & MPOL_F_MORON)) {\n\t\tmode = pol->mode;\n\t\tflags = pol->flags;\n\t}\n\n\tswitch (mode) {\n\tcase MPOL_DEFAULT:\n\t\tbreak;\n\tcase MPOL_PREFERRED:\n\t\tif (flags & MPOL_F_LOCAL)\n\t\t\tmode = MPOL_LOCAL;\n\t\telse\n\t\t\tnode_set(pol->v.preferred_node, nodes);\n\t\tbreak;\n\tcase MPOL_BIND:\n\tcase MPOL_INTERLEAVE:\n\t\tnodes = pol->v.nodes;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tsnprintf(p, maxlen, \"unknown\");\n\t\treturn;\n\t}\n\n\tp += snprintf(p, maxlen, \"%s\", policy_modes[mode]);\n\n\tif (flags & MPOL_MODE_FLAGS) {\n\t\tp += snprintf(p, buffer + maxlen - p, \"=\");\n\n\t\t/*\n\t\t * Currently, the only defined flags are mutually exclusive\n\t\t */\n\t\tif (flags & MPOL_F_STATIC_NODES)\n\t\t\tp += snprintf(p, buffer + maxlen - p, \"static\");\n\t\telse if (flags & MPOL_F_RELATIVE_NODES)\n\t\t\tp += snprintf(p, buffer + maxlen - p, \"relative\");\n\t}\n\n\tif (!nodes_empty(nodes))\n\t\tp += scnprintf(p, buffer + maxlen - p, \":%*pbl\",\n\t\t\t       nodemask_pr_args(&nodes));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct mempolicy default_policy = {\n\t.refcnt = ATOMIC_INIT(1), /* never free it */\n\t.mode = MPOL_PREFERRED,\n\t.flags = MPOL_F_LOCAL,\n};",
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);",
      "static const char * const policy_modes[] =\n{\n\t[MPOL_DEFAULT]    = \"default\",\n\t[MPOL_PREFERRED]  = \"prefer\",\n\t[MPOL_BIND]       = \"bind\",\n\t[MPOL_INTERLEAVE] = \"interleave\",\n\t[MPOL_LOCAL]      = \"local\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "p",
            "buffer + maxlen - p",
            "\":%*pbl\"",
            "nodemask_pr_args(&nodes)"
          ],
          "line": 2858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodemask_pr_args",
          "args": [
            "&nodes"
          ],
          "line": 2859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_empty",
          "args": [
            "nodes"
          ],
          "line": 2857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "p",
            "buffer + maxlen - p",
            "\"relative\""
          ],
          "line": 2854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "p",
            "buffer + maxlen - p",
            "\"static\""
          ],
          "line": 2852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "p",
            "buffer + maxlen - p",
            "\"=\""
          ],
          "line": 2846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "p",
            "maxlen",
            "\"%s\"",
            "policy_modes[mode]"
          ],
          "line": 2843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "p",
            "maxlen",
            "\"unknown\""
          ],
          "line": 2839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 2838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_set",
          "args": [
            "pol->v.preferred_node",
            "nodes"
          ],
          "line": 2831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct mempolicy default_policy = {\n\t.refcnt = ATOMIC_INIT(1), /* never free it */\n\t.mode = MPOL_PREFERRED,\n\t.flags = MPOL_F_LOCAL,\n};\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\nstatic const char * const policy_modes[] =\n{\n\t[MPOL_DEFAULT]    = \"default\",\n\t[MPOL_PREFERRED]  = \"prefer\",\n\t[MPOL_BIND]       = \"bind\",\n\t[MPOL_INTERLEAVE] = \"interleave\",\n\t[MPOL_LOCAL]      = \"local\",\n};\n\nvoid mpol_to_str(char *buffer, int maxlen, struct mempolicy *pol)\n{\n\tchar *p = buffer;\n\tnodemask_t nodes = NODE_MASK_NONE;\n\tunsigned short mode = MPOL_DEFAULT;\n\tunsigned short flags = 0;\n\n\tif (pol && pol != &default_policy && !(pol->flags & MPOL_F_MORON)) {\n\t\tmode = pol->mode;\n\t\tflags = pol->flags;\n\t}\n\n\tswitch (mode) {\n\tcase MPOL_DEFAULT:\n\t\tbreak;\n\tcase MPOL_PREFERRED:\n\t\tif (flags & MPOL_F_LOCAL)\n\t\t\tmode = MPOL_LOCAL;\n\t\telse\n\t\t\tnode_set(pol->v.preferred_node, nodes);\n\t\tbreak;\n\tcase MPOL_BIND:\n\tcase MPOL_INTERLEAVE:\n\t\tnodes = pol->v.nodes;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tsnprintf(p, maxlen, \"unknown\");\n\t\treturn;\n\t}\n\n\tp += snprintf(p, maxlen, \"%s\", policy_modes[mode]);\n\n\tif (flags & MPOL_MODE_FLAGS) {\n\t\tp += snprintf(p, buffer + maxlen - p, \"=\");\n\n\t\t/*\n\t\t * Currently, the only defined flags are mutually exclusive\n\t\t */\n\t\tif (flags & MPOL_F_STATIC_NODES)\n\t\t\tp += snprintf(p, buffer + maxlen - p, \"static\");\n\t\telse if (flags & MPOL_F_RELATIVE_NODES)\n\t\t\tp += snprintf(p, buffer + maxlen - p, \"relative\");\n\t}\n\n\tif (!nodes_empty(nodes))\n\t\tp += scnprintf(p, buffer + maxlen - p, \":%*pbl\",\n\t\t\t       nodemask_pr_args(&nodes));\n}"
  },
  {
    "function_name": "mpol_parse_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "2684-2799",
    "snippet": "int mpol_parse_str(char *str, struct mempolicy **mpol)\n{\n\tstruct mempolicy *new = NULL;\n\tunsigned short mode_flags;\n\tnodemask_t nodes;\n\tchar *nodelist = strchr(str, ':');\n\tchar *flags = strchr(str, '=');\n\tint err = 1, mode;\n\n\tif (nodelist) {\n\t\t/* NUL-terminate mode or flags string */\n\t\t*nodelist++ = '\\0';\n\t\tif (nodelist_parse(nodelist, nodes))\n\t\t\tgoto out;\n\t\tif (!nodes_subset(nodes, node_states[N_MEMORY]))\n\t\t\tgoto out;\n\t} else\n\t\tnodes_clear(nodes);\n\n\tif (flags)\n\t\t*flags++ = '\\0';\t/* terminate mode string */\n\n\tmode = match_string(policy_modes, MPOL_MAX, str);\n\tif (mode < 0)\n\t\tgoto out;\n\n\tswitch (mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * Insist on a nodelist of one node only\n\t\t */\n\t\tif (nodelist) {\n\t\t\tchar *rest = nodelist;\n\t\t\twhile (isdigit(*rest))\n\t\t\t\trest++;\n\t\t\tif (*rest)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase MPOL_INTERLEAVE:\n\t\t/*\n\t\t * Default to online nodes with memory if no nodelist\n\t\t */\n\t\tif (!nodelist)\n\t\t\tnodes = node_states[N_MEMORY];\n\t\tbreak;\n\tcase MPOL_LOCAL:\n\t\t/*\n\t\t * Don't allow a nodelist;  mpol_new() checks flags\n\t\t */\n\t\tif (nodelist)\n\t\t\tgoto out;\n\t\tmode = MPOL_PREFERRED;\n\t\tbreak;\n\tcase MPOL_DEFAULT:\n\t\t/*\n\t\t * Insist on a empty nodelist\n\t\t */\n\t\tif (!nodelist)\n\t\t\terr = 0;\n\t\tgoto out;\n\tcase MPOL_BIND:\n\t\t/*\n\t\t * Insist on a nodelist\n\t\t */\n\t\tif (!nodelist)\n\t\t\tgoto out;\n\t}\n\n\tmode_flags = 0;\n\tif (flags) {\n\t\t/*\n\t\t * Currently, we only support two mutually exclusive\n\t\t * mode flags.\n\t\t */\n\t\tif (!strcmp(flags, \"static\"))\n\t\t\tmode_flags |= MPOL_F_STATIC_NODES;\n\t\telse if (!strcmp(flags, \"relative\"))\n\t\t\tmode_flags |= MPOL_F_RELATIVE_NODES;\n\t\telse\n\t\t\tgoto out;\n\t}\n\n\tnew = mpol_new(mode, mode_flags, &nodes);\n\tif (IS_ERR(new))\n\t\tgoto out;\n\n\t/*\n\t * Save nodes for mpol_to_str() to show the tmpfs mount options\n\t * for /proc/mounts, /proc/pid/mounts and /proc/pid/mountinfo.\n\t */\n\tif (mode != MPOL_PREFERRED)\n\t\tnew->v.nodes = nodes;\n\telse if (nodelist)\n\t\tnew->v.preferred_node = first_node(nodes);\n\telse\n\t\tnew->flags |= MPOL_F_LOCAL;\n\n\t/*\n\t * Save nodes for contextualization: this will be used to \"clone\"\n\t * the mempolicy in a specific context [cpuset] at a later time.\n\t */\n\tnew->w.user_nodemask = nodes;\n\n\terr = 0;\n\nout:\n\t/* Restore string for error message */\n\tif (nodelist)\n\t\t*--nodelist = ':';\n\tif (flags)\n\t\t*--flags = '=';\n\tif (!err)\n\t\t*mpol = new;\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);",
      "static const char * const policy_modes[] =\n{\n\t[MPOL_DEFAULT]    = \"default\",\n\t[MPOL_PREFERRED]  = \"prefer\",\n\t[MPOL_BIND]       = \"bind\",\n\t[MPOL_INTERLEAVE] = \"interleave\",\n\t[MPOL_LOCAL]      = \"local\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "first_node",
          "args": [
            "nodes"
          ],
          "line": 2778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new"
          ],
          "line": 2768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_new",
          "args": [
            "mode",
            "mode_flags",
            "&nodes"
          ],
          "line": 2767
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "242-284",
          "snippet": "static struct mempolicy *mpol_new(unsigned short mode, unsigned short flags,\n\t\t\t\t  nodemask_t *nodes)\n{\n\tstruct mempolicy *policy;\n\n\tpr_debug(\"setting mode %d flags %d nodes[0] %lx\\n\",\n\t\t mode, flags, nodes ? nodes_addr(*nodes)[0] : NUMA_NO_NODE);\n\n\tif (mode == MPOL_DEFAULT) {\n\t\tif (nodes && !nodes_empty(*nodes))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\treturn NULL;\n\t}\n\tVM_BUG_ON(!nodes);\n\n\t/*\n\t * MPOL_PREFERRED cannot be used with MPOL_F_STATIC_NODES or\n\t * MPOL_F_RELATIVE_NODES if the nodemask is empty (local allocation).\n\t * All other modes require a valid pointer to a non-empty nodemask.\n\t */\n\tif (mode == MPOL_PREFERRED) {\n\t\tif (nodes_empty(*nodes)) {\n\t\t\tif (((flags & MPOL_F_STATIC_NODES) ||\n\t\t\t     (flags & MPOL_F_RELATIVE_NODES)))\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t} else if (mode == MPOL_LOCAL) {\n\t\tif (!nodes_empty(*nodes) ||\n\t\t    (flags & MPOL_F_STATIC_NODES) ||\n\t\t    (flags & MPOL_F_RELATIVE_NODES))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tmode = MPOL_PREFERRED;\n\t} else if (nodes_empty(*nodes))\n\t\treturn ERR_PTR(-EINVAL);\n\tpolicy = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\tif (!policy)\n\t\treturn ERR_PTR(-ENOMEM);\n\tatomic_set(&policy->refcnt, 1);\n\tpolicy->mode = mode;\n\tpolicy->flags = flags;\n\n\treturn policy;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *policy_cache;",
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct kmem_cache *policy_cache;\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic struct mempolicy *mpol_new(unsigned short mode, unsigned short flags,\n\t\t\t\t  nodemask_t *nodes)\n{\n\tstruct mempolicy *policy;\n\n\tpr_debug(\"setting mode %d flags %d nodes[0] %lx\\n\",\n\t\t mode, flags, nodes ? nodes_addr(*nodes)[0] : NUMA_NO_NODE);\n\n\tif (mode == MPOL_DEFAULT) {\n\t\tif (nodes && !nodes_empty(*nodes))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\treturn NULL;\n\t}\n\tVM_BUG_ON(!nodes);\n\n\t/*\n\t * MPOL_PREFERRED cannot be used with MPOL_F_STATIC_NODES or\n\t * MPOL_F_RELATIVE_NODES if the nodemask is empty (local allocation).\n\t * All other modes require a valid pointer to a non-empty nodemask.\n\t */\n\tif (mode == MPOL_PREFERRED) {\n\t\tif (nodes_empty(*nodes)) {\n\t\t\tif (((flags & MPOL_F_STATIC_NODES) ||\n\t\t\t     (flags & MPOL_F_RELATIVE_NODES)))\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t} else if (mode == MPOL_LOCAL) {\n\t\tif (!nodes_empty(*nodes) ||\n\t\t    (flags & MPOL_F_STATIC_NODES) ||\n\t\t    (flags & MPOL_F_RELATIVE_NODES))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tmode = MPOL_PREFERRED;\n\t} else if (nodes_empty(*nodes))\n\t\treturn ERR_PTR(-EINVAL);\n\tpolicy = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\tif (!policy)\n\t\treturn ERR_PTR(-ENOMEM);\n\tatomic_set(&policy->refcnt, 1);\n\tpolicy->mode = mode;\n\tpolicy->flags = flags;\n\n\treturn policy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "flags",
            "\"relative\""
          ],
          "line": 2761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "flags",
            "\"static\""
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "*rest"
          ],
          "line": 2717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_string",
          "args": [
            "policy_modes",
            "MPOL_MAX",
            "str"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_clear",
          "args": [
            "nodes"
          ],
          "line": 2701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_subset",
          "args": [
            "nodes",
            "node_states[N_MEMORY]"
          ],
          "line": 2698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodelist_parse",
          "args": [
            "nodelist",
            "nodes"
          ],
          "line": 2696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "str",
            "'='"
          ],
          "line": 2690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "str",
            "':'"
          ],
          "line": 2689
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\nstatic const char * const policy_modes[] =\n{\n\t[MPOL_DEFAULT]    = \"default\",\n\t[MPOL_PREFERRED]  = \"prefer\",\n\t[MPOL_BIND]       = \"bind\",\n\t[MPOL_INTERLEAVE] = \"interleave\",\n\t[MPOL_LOCAL]      = \"local\",\n};\n\nint mpol_parse_str(char *str, struct mempolicy **mpol)\n{\n\tstruct mempolicy *new = NULL;\n\tunsigned short mode_flags;\n\tnodemask_t nodes;\n\tchar *nodelist = strchr(str, ':');\n\tchar *flags = strchr(str, '=');\n\tint err = 1, mode;\n\n\tif (nodelist) {\n\t\t/* NUL-terminate mode or flags string */\n\t\t*nodelist++ = '\\0';\n\t\tif (nodelist_parse(nodelist, nodes))\n\t\t\tgoto out;\n\t\tif (!nodes_subset(nodes, node_states[N_MEMORY]))\n\t\t\tgoto out;\n\t} else\n\t\tnodes_clear(nodes);\n\n\tif (flags)\n\t\t*flags++ = '\\0';\t/* terminate mode string */\n\n\tmode = match_string(policy_modes, MPOL_MAX, str);\n\tif (mode < 0)\n\t\tgoto out;\n\n\tswitch (mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * Insist on a nodelist of one node only\n\t\t */\n\t\tif (nodelist) {\n\t\t\tchar *rest = nodelist;\n\t\t\twhile (isdigit(*rest))\n\t\t\t\trest++;\n\t\t\tif (*rest)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase MPOL_INTERLEAVE:\n\t\t/*\n\t\t * Default to online nodes with memory if no nodelist\n\t\t */\n\t\tif (!nodelist)\n\t\t\tnodes = node_states[N_MEMORY];\n\t\tbreak;\n\tcase MPOL_LOCAL:\n\t\t/*\n\t\t * Don't allow a nodelist;  mpol_new() checks flags\n\t\t */\n\t\tif (nodelist)\n\t\t\tgoto out;\n\t\tmode = MPOL_PREFERRED;\n\t\tbreak;\n\tcase MPOL_DEFAULT:\n\t\t/*\n\t\t * Insist on a empty nodelist\n\t\t */\n\t\tif (!nodelist)\n\t\t\terr = 0;\n\t\tgoto out;\n\tcase MPOL_BIND:\n\t\t/*\n\t\t * Insist on a nodelist\n\t\t */\n\t\tif (!nodelist)\n\t\t\tgoto out;\n\t}\n\n\tmode_flags = 0;\n\tif (flags) {\n\t\t/*\n\t\t * Currently, we only support two mutually exclusive\n\t\t * mode flags.\n\t\t */\n\t\tif (!strcmp(flags, \"static\"))\n\t\t\tmode_flags |= MPOL_F_STATIC_NODES;\n\t\telse if (!strcmp(flags, \"relative\"))\n\t\t\tmode_flags |= MPOL_F_RELATIVE_NODES;\n\t\telse\n\t\t\tgoto out;\n\t}\n\n\tnew = mpol_new(mode, mode_flags, &nodes);\n\tif (IS_ERR(new))\n\t\tgoto out;\n\n\t/*\n\t * Save nodes for mpol_to_str() to show the tmpfs mount options\n\t * for /proc/mounts, /proc/pid/mounts and /proc/pid/mountinfo.\n\t */\n\tif (mode != MPOL_PREFERRED)\n\t\tnew->v.nodes = nodes;\n\telse if (nodelist)\n\t\tnew->v.preferred_node = first_node(nodes);\n\telse\n\t\tnew->flags |= MPOL_F_LOCAL;\n\n\t/*\n\t * Save nodes for contextualization: this will be used to \"clone\"\n\t * the mempolicy in a specific context [cpuset] at a later time.\n\t */\n\tnew->w.user_nodemask = nodes;\n\n\terr = 0;\n\nout:\n\t/* Restore string for error message */\n\tif (nodelist)\n\t\t*--nodelist = ':';\n\tif (flags)\n\t\t*--flags = '=';\n\tif (!err)\n\t\t*mpol = new;\n\treturn err;\n}"
  },
  {
    "function_name": "numa_default_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "2651-2654",
    "snippet": "void numa_default_policy(void)\n{\n\tdo_set_mempolicy(MPOL_DEFAULT, 0, NULL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_set_mempolicy",
          "args": [
            "MPOL_DEFAULT",
            "0",
            "NULL"
          ],
          "line": 2653
        },
        "resolved": true,
        "details": {
          "function_name": "do_set_mempolicy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "738-771",
          "snippet": "static long do_set_mempolicy(unsigned short mode, unsigned short flags,\n\t\t\t     nodemask_t *nodes)\n{\n\tstruct mempolicy *new, *old;\n\tNODEMASK_SCRATCH(scratch);\n\tint ret;\n\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\n\tnew = mpol_new(mode, flags, nodes);\n\tif (IS_ERR(new)) {\n\t\tret = PTR_ERR(new);\n\t\tgoto out;\n\t}\n\n\ttask_lock(current);\n\tret = mpol_set_nodemask(new, nodes, scratch);\n\tif (ret) {\n\t\ttask_unlock(current);\n\t\tmpol_put(new);\n\t\tgoto out;\n\t}\n\told = current->mempolicy;\n\tcurrent->mempolicy = new;\n\tif (new && new->mode == MPOL_INTERLEAVE)\n\t\tcurrent->il_prev = MAX_NUMNODES-1;\n\ttask_unlock(current);\n\tmpol_put(old);\n\tret = 0;\nout:\n\tNODEMASK_SCRATCH_FREE(scratch);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic long do_set_mempolicy(unsigned short mode, unsigned short flags,\n\t\t\t     nodemask_t *nodes)\n{\n\tstruct mempolicy *new, *old;\n\tNODEMASK_SCRATCH(scratch);\n\tint ret;\n\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\n\tnew = mpol_new(mode, flags, nodes);\n\tif (IS_ERR(new)) {\n\t\tret = PTR_ERR(new);\n\t\tgoto out;\n\t}\n\n\ttask_lock(current);\n\tret = mpol_set_nodemask(new, nodes, scratch);\n\tif (ret) {\n\t\ttask_unlock(current);\n\t\tmpol_put(new);\n\t\tgoto out;\n\t}\n\told = current->mempolicy;\n\tcurrent->mempolicy = new;\n\tif (new && new->mode == MPOL_INTERLEAVE)\n\t\tcurrent->il_prev = MAX_NUMNODES-1;\n\ttask_unlock(current);\n\tmpol_put(old);\n\tret = 0;\nout:\n\tNODEMASK_SCRATCH_FREE(scratch);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nvoid numa_default_policy(void)\n{\n\tdo_set_mempolicy(MPOL_DEFAULT, 0, NULL);\n}"
  },
  {
    "function_name": "numa_policy_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "2597-2648",
    "snippet": "void __init numa_policy_init(void)\n{\n\tnodemask_t interleave_nodes;\n\tunsigned long largest = 0;\n\tint nid, prefer = 0;\n\n\tpolicy_cache = kmem_cache_create(\"numa_policy\",\n\t\t\t\t\t sizeof(struct mempolicy),\n\t\t\t\t\t 0, SLAB_PANIC, NULL);\n\n\tsn_cache = kmem_cache_create(\"shared_policy_node\",\n\t\t\t\t     sizeof(struct sp_node),\n\t\t\t\t     0, SLAB_PANIC, NULL);\n\n\tfor_each_node(nid) {\n\t\tpreferred_node_policy[nid] = (struct mempolicy) {\n\t\t\t.refcnt = ATOMIC_INIT(1),\n\t\t\t.mode = MPOL_PREFERRED,\n\t\t\t.flags = MPOL_F_MOF | MPOL_F_MORON,\n\t\t\t.v = { .preferred_node = nid, },\n\t\t};\n\t}\n\n\t/*\n\t * Set interleaving policy for system init. Interleaving is only\n\t * enabled across suitably sized nodes (default is >= 16MB), or\n\t * fall back to the largest node if they're all smaller.\n\t */\n\tnodes_clear(interleave_nodes);\n\tfor_each_node_state(nid, N_MEMORY) {\n\t\tunsigned long total_pages = node_present_pages(nid);\n\n\t\t/* Preserve the largest node */\n\t\tif (largest < total_pages) {\n\t\t\tlargest = total_pages;\n\t\t\tprefer = nid;\n\t\t}\n\n\t\t/* Interleave this node? */\n\t\tif ((total_pages << PAGE_SHIFT) >= (16 << 20))\n\t\t\tnode_set(nid, interleave_nodes);\n\t}\n\n\t/* All too small, use the largest */\n\tif (unlikely(nodes_empty(interleave_nodes)))\n\t\tnode_set(prefer, interleave_nodes);\n\n\tif (do_set_mempolicy(MPOL_INTERLEAVE, 0, &interleave_nodes))\n\t\tpr_err(\"%s: interleaving failed\\n\", __func__);\n\n\tcheck_numabalancing_enable();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *policy_cache;",
      "static struct kmem_cache *sn_cache;",
      "static struct mempolicy preferred_node_policy[MAX_NUMNODES];",
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_numabalancing_enable",
          "args": [],
          "line": 2647
        },
        "resolved": true,
        "details": {
          "function_name": "check_numabalancing_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2591-2593",
          "snippet": "static inline void __init check_numabalancing_enable(void)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic inline void __init check_numabalancing_enable(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: interleaving failed\\n\"",
            "__func__"
          ],
          "line": 2645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_set_mempolicy",
          "args": [
            "MPOL_INTERLEAVE",
            "0",
            "&interleave_nodes"
          ],
          "line": 2644
        },
        "resolved": true,
        "details": {
          "function_name": "do_set_mempolicy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "738-771",
          "snippet": "static long do_set_mempolicy(unsigned short mode, unsigned short flags,\n\t\t\t     nodemask_t *nodes)\n{\n\tstruct mempolicy *new, *old;\n\tNODEMASK_SCRATCH(scratch);\n\tint ret;\n\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\n\tnew = mpol_new(mode, flags, nodes);\n\tif (IS_ERR(new)) {\n\t\tret = PTR_ERR(new);\n\t\tgoto out;\n\t}\n\n\ttask_lock(current);\n\tret = mpol_set_nodemask(new, nodes, scratch);\n\tif (ret) {\n\t\ttask_unlock(current);\n\t\tmpol_put(new);\n\t\tgoto out;\n\t}\n\told = current->mempolicy;\n\tcurrent->mempolicy = new;\n\tif (new && new->mode == MPOL_INTERLEAVE)\n\t\tcurrent->il_prev = MAX_NUMNODES-1;\n\ttask_unlock(current);\n\tmpol_put(old);\n\tret = 0;\nout:\n\tNODEMASK_SCRATCH_FREE(scratch);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic long do_set_mempolicy(unsigned short mode, unsigned short flags,\n\t\t\t     nodemask_t *nodes)\n{\n\tstruct mempolicy *new, *old;\n\tNODEMASK_SCRATCH(scratch);\n\tint ret;\n\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\n\tnew = mpol_new(mode, flags, nodes);\n\tif (IS_ERR(new)) {\n\t\tret = PTR_ERR(new);\n\t\tgoto out;\n\t}\n\n\ttask_lock(current);\n\tret = mpol_set_nodemask(new, nodes, scratch);\n\tif (ret) {\n\t\ttask_unlock(current);\n\t\tmpol_put(new);\n\t\tgoto out;\n\t}\n\told = current->mempolicy;\n\tcurrent->mempolicy = new;\n\tif (new && new->mode == MPOL_INTERLEAVE)\n\t\tcurrent->il_prev = MAX_NUMNODES-1;\n\ttask_unlock(current);\n\tmpol_put(old);\n\tret = 0;\nout:\n\tNODEMASK_SCRATCH_FREE(scratch);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_set",
          "args": [
            "prefer",
            "interleave_nodes"
          ],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nodes_empty(interleave_nodes)"
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_empty",
          "args": [
            "interleave_nodes"
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_set",
          "args": [
            "nid",
            "interleave_nodes"
          ],
          "line": 2637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_present_pages",
          "args": [
            "nid"
          ],
          "line": 2627
        },
        "resolved": true,
        "details": {
          "function_name": "reset_node_present_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "932-940",
          "snippet": "static void reset_node_present_pages(pg_data_t *pgdat)\n{\n\tstruct zone *z;\n\n\tfor (z = pgdat->node_zones; z < pgdat->node_zones + MAX_NR_ZONES; z++)\n\t\tz->present_pages = 0;\n\n\tpgdat->node_present_pages = 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void reset_node_present_pages(pg_data_t *pgdat)\n{\n\tstruct zone *z;\n\n\tfor (z = pgdat->node_zones; z < pgdat->node_zones + MAX_NR_ZONES; z++)\n\t\tz->present_pages = 0;\n\n\tpgdat->node_present_pages = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_node_state",
          "args": [
            "nid",
            "N_MEMORY"
          ],
          "line": 2626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_clear",
          "args": [
            "interleave_nodes"
          ],
          "line": 2625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATOMIC_INIT",
          "args": [
            "1"
          ],
          "line": 2613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"shared_policy_node\"",
            "sizeof(struct sp_node)",
            "0",
            "SLAB_PANIC",
            "NULL"
          ],
          "line": 2607
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "517-523",
          "snippet": "struct kmem_cache *\nkmem_cache_create(const char *name, unsigned int size, unsigned int align,\n\t\tslab_flags_t flags, void (*ctor)(void *))\n{\n\treturn kmem_cache_create_usercopy(name, size, align, flags, 0, 0,\n\t\t\t\t\t  ctor);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstruct kmem_cache *\nkmem_cache_create(const char *name, unsigned int size, unsigned int align,\n\t\tslab_flags_t flags, void (*ctor)(void *))\n{\n\treturn kmem_cache_create_usercopy(name, size, align, flags, 0, 0,\n\t\t\t\t\t  ctor);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct kmem_cache *policy_cache;\nstatic struct kmem_cache *sn_cache;\nstatic struct mempolicy preferred_node_policy[MAX_NUMNODES];\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nvoid __init numa_policy_init(void)\n{\n\tnodemask_t interleave_nodes;\n\tunsigned long largest = 0;\n\tint nid, prefer = 0;\n\n\tpolicy_cache = kmem_cache_create(\"numa_policy\",\n\t\t\t\t\t sizeof(struct mempolicy),\n\t\t\t\t\t 0, SLAB_PANIC, NULL);\n\n\tsn_cache = kmem_cache_create(\"shared_policy_node\",\n\t\t\t\t     sizeof(struct sp_node),\n\t\t\t\t     0, SLAB_PANIC, NULL);\n\n\tfor_each_node(nid) {\n\t\tpreferred_node_policy[nid] = (struct mempolicy) {\n\t\t\t.refcnt = ATOMIC_INIT(1),\n\t\t\t.mode = MPOL_PREFERRED,\n\t\t\t.flags = MPOL_F_MOF | MPOL_F_MORON,\n\t\t\t.v = { .preferred_node = nid, },\n\t\t};\n\t}\n\n\t/*\n\t * Set interleaving policy for system init. Interleaving is only\n\t * enabled across suitably sized nodes (default is >= 16MB), or\n\t * fall back to the largest node if they're all smaller.\n\t */\n\tnodes_clear(interleave_nodes);\n\tfor_each_node_state(nid, N_MEMORY) {\n\t\tunsigned long total_pages = node_present_pages(nid);\n\n\t\t/* Preserve the largest node */\n\t\tif (largest < total_pages) {\n\t\t\tlargest = total_pages;\n\t\t\tprefer = nid;\n\t\t}\n\n\t\t/* Interleave this node? */\n\t\tif ((total_pages << PAGE_SHIFT) >= (16 << 20))\n\t\t\tnode_set(nid, interleave_nodes);\n\t}\n\n\t/* All too small, use the largest */\n\tif (unlikely(nodes_empty(interleave_nodes)))\n\t\tnode_set(prefer, interleave_nodes);\n\n\tif (do_set_mempolicy(MPOL_INTERLEAVE, 0, &interleave_nodes))\n\t\tpr_err(\"%s: interleaving failed\\n\", __func__);\n\n\tcheck_numabalancing_enable();\n}"
  },
  {
    "function_name": "check_numabalancing_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "2591-2593",
    "snippet": "static inline void __init check_numabalancing_enable(void)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic inline void __init check_numabalancing_enable(void)\n{\n}"
  },
  {
    "function_name": "setup_numabalancing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "2570-2588",
    "snippet": "static int __init setup_numabalancing(char *str)\n{\n\tint ret = 0;\n\tif (!str)\n\t\tgoto out;\n\n\tif (!strcmp(str, \"enable\")) {\n\t\tnumabalancing_override = 1;\n\t\tret = 1;\n\t} else if (!strcmp(str, \"disable\")) {\n\t\tnumabalancing_override = -1;\n\t\tret = 1;\n\t}\nout:\n\tif (!ret)\n\t\tpr_warn(\"Unable to parse numa_balancing=\\n\");\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Unable to parse numa_balancing=\\n\""
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"disable\""
          ],
          "line": 2579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"enable\""
          ],
          "line": 2576
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic int __init setup_numabalancing(char *str)\n{\n\tint ret = 0;\n\tif (!str)\n\t\tgoto out;\n\n\tif (!strcmp(str, \"enable\")) {\n\t\tnumabalancing_override = 1;\n\t\tret = 1;\n\t} else if (!strcmp(str, \"disable\")) {\n\t\tnumabalancing_override = -1;\n\t\tret = 1;\n\t}\nout:\n\tif (!ret)\n\t\tpr_warn(\"Unable to parse numa_balancing=\\n\");\n\n\treturn ret;\n}"
  },
  {
    "function_name": "check_numabalancing_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "2552-2568",
    "snippet": "static void __init check_numabalancing_enable(void)\n{\n\tbool numabalancing_default = false;\n\n\tif (IS_ENABLED(CONFIG_NUMA_BALANCING_DEFAULT_ENABLED))\n\t\tnumabalancing_default = true;\n\n\t/* Parsed by setup_numabalancing. override == 1 enables, -1 disables */\n\tif (numabalancing_override)\n\t\tset_numabalancing_state(numabalancing_override == 1);\n\n\tif (num_online_nodes() > 1 && !numabalancing_override) {\n\t\tpr_info(\"%s automatic NUMA balancing. Configure with numa_balancing= or the kernel.numa_balancing sysctl\\n\",\n\t\t\tnumabalancing_default ? \"Enabling\" : \"Disabling\");\n\t\tset_numabalancing_state(numabalancing_default);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_numabalancing_state",
          "args": [
            "numabalancing_default"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s automatic NUMA balancing. Configure with numa_balancing= or the kernel.numa_balancing sysctl\\n\"",
            "numabalancing_default ? \"Enabling\" : \"Disabling\""
          ],
          "line": 2564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_nodes",
          "args": [],
          "line": 2563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_numabalancing_state",
          "args": [
            "numabalancing_override == 1"
          ],
          "line": 2561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_NUMA_BALANCING_DEFAULT_ENABLED"
          ],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void __init check_numabalancing_enable(void)\n{\n\tbool numabalancing_default = false;\n\n\tif (IS_ENABLED(CONFIG_NUMA_BALANCING_DEFAULT_ENABLED))\n\t\tnumabalancing_default = true;\n\n\t/* Parsed by setup_numabalancing. override == 1 enables, -1 disables */\n\tif (numabalancing_override)\n\t\tset_numabalancing_state(numabalancing_override == 1);\n\n\tif (num_online_nodes() > 1 && !numabalancing_override) {\n\t\tpr_info(\"%s automatic NUMA balancing. Configure with numa_balancing= or the kernel.numa_balancing sysctl\\n\",\n\t\t\tnumabalancing_default ? \"Enabling\" : \"Disabling\");\n\t\tset_numabalancing_state(numabalancing_default);\n\t}\n}"
  },
  {
    "function_name": "mpol_free_shared_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "2532-2547",
    "snippet": "void mpol_free_shared_policy(struct shared_policy *p)\n{\n\tstruct sp_node *n;\n\tstruct rb_node *next;\n\n\tif (!p->root.rb_node)\n\t\treturn;\n\twrite_lock(&p->lock);\n\tnext = rb_first(&p->root);\n\twhile (next) {\n\t\tn = rb_entry(next, struct sp_node, nd);\n\t\tnext = rb_next(&n->nd);\n\t\tsp_delete(p, n);\n\t}\n\twrite_unlock(&p->lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&p->lock"
          ],
          "line": 2546
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "1869-1872",
          "snippet": "static void migrate_write_unlock(struct zspage *zspage)\n{\n\twrite_unlock(&zspage->lock);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void migrate_write_unlock(struct zspage *zspage)\n{\n\twrite_unlock(&zspage->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sp_delete",
          "args": [
            "p",
            "n"
          ],
          "line": 2544
        },
        "resolved": true,
        "details": {
          "function_name": "sp_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2356-2361",
          "snippet": "static void sp_delete(struct shared_policy *sp, struct sp_node *n)\n{\n\tpr_debug(\"deleting %lx-l%lx\\n\", n->start, n->end);\n\trb_erase(&n->nd, &sp->root);\n\tsp_free(n);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void sp_delete(struct shared_policy *sp, struct sp_node *n)\n{\n\tpr_debug(\"deleting %lx-l%lx\\n\", n->start, n->end);\n\trb_erase(&n->nd, &sp->root);\n\tsp_free(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&n->nd"
          ],
          "line": 2543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "next",
            "structsp_node",
            "nd"
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&p->root"
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&p->lock"
          ],
          "line": 2539
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "1864-1867",
          "snippet": "static void migrate_write_lock(struct zspage *zspage)\n{\n\twrite_lock(&zspage->lock);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void migrate_write_lock(struct zspage *zspage)\n{\n\twrite_lock(&zspage->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nvoid mpol_free_shared_policy(struct shared_policy *p)\n{\n\tstruct sp_node *n;\n\tstruct rb_node *next;\n\n\tif (!p->root.rb_node)\n\t\treturn;\n\twrite_lock(&p->lock);\n\tnext = rb_first(&p->root);\n\twhile (next) {\n\t\tn = rb_entry(next, struct sp_node, nd);\n\t\tnext = rb_next(&n->nd);\n\t\tsp_delete(p, n);\n\t}\n\twrite_unlock(&p->lock);\n}"
  },
  {
    "function_name": "mpol_set_shared_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "2507-2529",
    "snippet": "int mpol_set_shared_policy(struct shared_policy *info,\n\t\t\tstruct vm_area_struct *vma, struct mempolicy *npol)\n{\n\tint err;\n\tstruct sp_node *new = NULL;\n\tunsigned long sz = vma_pages(vma);\n\n\tpr_debug(\"set_shared_policy %lx sz %lu %d %d %lx\\n\",\n\t\t vma->vm_pgoff,\n\t\t sz, npol ? npol->mode : -1,\n\t\t npol ? npol->flags : -1,\n\t\t npol ? nodes_addr(npol->v.nodes)[0] : NUMA_NO_NODE);\n\n\tif (npol) {\n\t\tnew = sp_alloc(vma->vm_pgoff, vma->vm_pgoff + sz, npol);\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\t}\n\terr = shared_policy_replace(info, vma->vm_pgoff, vma->vm_pgoff+sz, new);\n\tif (err && new)\n\t\tsp_free(new);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sp_free",
          "args": [
            "new"
          ],
          "line": 2527
        },
        "resolved": true,
        "details": {
          "function_name": "sp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2250-2254",
          "snippet": "static void sp_free(struct sp_node *n)\n{\n\tmpol_put(n->policy);\n\tkmem_cache_free(sn_cache, n);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *sn_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct kmem_cache *sn_cache;\n\nstatic void sp_free(struct sp_node *n)\n{\n\tmpol_put(n->policy);\n\tkmem_cache_free(sn_cache, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "shared_policy_replace",
          "args": [
            "info",
            "vma->vm_pgoff",
            "vma->vm_pgoff+sz",
            "new"
          ],
          "line": 2525
        },
        "resolved": true,
        "details": {
          "function_name": "shared_policy_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2393-2456",
          "snippet": "static int shared_policy_replace(struct shared_policy *sp, unsigned long start,\n\t\t\t\t unsigned long end, struct sp_node *new)\n{\n\tstruct sp_node *n;\n\tstruct sp_node *n_new = NULL;\n\tstruct mempolicy *mpol_new = NULL;\n\tint ret = 0;\n\nrestart:\n\twrite_lock(&sp->lock);\n\tn = sp_lookup(sp, start, end);\n\t/* Take care of old policies in the same range. */\n\twhile (n && n->start < end) {\n\t\tstruct rb_node *next = rb_next(&n->nd);\n\t\tif (n->start >= start) {\n\t\t\tif (n->end <= end)\n\t\t\t\tsp_delete(sp, n);\n\t\t\telse\n\t\t\t\tn->start = end;\n\t\t} else {\n\t\t\t/* Old policy spanning whole new range. */\n\t\t\tif (n->end > end) {\n\t\t\t\tif (!n_new)\n\t\t\t\t\tgoto alloc_new;\n\n\t\t\t\t*mpol_new = *n->policy;\n\t\t\t\tatomic_set(&mpol_new->refcnt, 1);\n\t\t\t\tsp_node_init(n_new, end, n->end, mpol_new);\n\t\t\t\tn->end = start;\n\t\t\t\tsp_insert(sp, n_new);\n\t\t\t\tn_new = NULL;\n\t\t\t\tmpol_new = NULL;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tn->end = start;\n\t\t}\n\t\tif (!next)\n\t\t\tbreak;\n\t\tn = rb_entry(next, struct sp_node, nd);\n\t}\n\tif (new)\n\t\tsp_insert(sp, new);\n\twrite_unlock(&sp->lock);\n\tret = 0;\n\nerr_out:\n\tif (mpol_new)\n\t\tmpol_put(mpol_new);\n\tif (n_new)\n\t\tkmem_cache_free(sn_cache, n_new);\n\n\treturn ret;\n\nalloc_new:\n\twrite_unlock(&sp->lock);\n\tret = -ENOMEM;\n\tn_new = kmem_cache_alloc(sn_cache, GFP_KERNEL);\n\tif (!n_new)\n\t\tgoto err_out;\n\tmpol_new = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\tif (!mpol_new)\n\t\tgoto err_out;\n\tgoto restart;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *policy_cache;",
            "static struct kmem_cache *sn_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct kmem_cache *policy_cache;\nstatic struct kmem_cache *sn_cache;\n\nstatic int shared_policy_replace(struct shared_policy *sp, unsigned long start,\n\t\t\t\t unsigned long end, struct sp_node *new)\n{\n\tstruct sp_node *n;\n\tstruct sp_node *n_new = NULL;\n\tstruct mempolicy *mpol_new = NULL;\n\tint ret = 0;\n\nrestart:\n\twrite_lock(&sp->lock);\n\tn = sp_lookup(sp, start, end);\n\t/* Take care of old policies in the same range. */\n\twhile (n && n->start < end) {\n\t\tstruct rb_node *next = rb_next(&n->nd);\n\t\tif (n->start >= start) {\n\t\t\tif (n->end <= end)\n\t\t\t\tsp_delete(sp, n);\n\t\t\telse\n\t\t\t\tn->start = end;\n\t\t} else {\n\t\t\t/* Old policy spanning whole new range. */\n\t\t\tif (n->end > end) {\n\t\t\t\tif (!n_new)\n\t\t\t\t\tgoto alloc_new;\n\n\t\t\t\t*mpol_new = *n->policy;\n\t\t\t\tatomic_set(&mpol_new->refcnt, 1);\n\t\t\t\tsp_node_init(n_new, end, n->end, mpol_new);\n\t\t\t\tn->end = start;\n\t\t\t\tsp_insert(sp, n_new);\n\t\t\t\tn_new = NULL;\n\t\t\t\tmpol_new = NULL;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tn->end = start;\n\t\t}\n\t\tif (!next)\n\t\t\tbreak;\n\t\tn = rb_entry(next, struct sp_node, nd);\n\t}\n\tif (new)\n\t\tsp_insert(sp, new);\n\twrite_unlock(&sp->lock);\n\tret = 0;\n\nerr_out:\n\tif (mpol_new)\n\t\tmpol_put(mpol_new);\n\tif (n_new)\n\t\tkmem_cache_free(sn_cache, n_new);\n\n\treturn ret;\n\nalloc_new:\n\twrite_unlock(&sp->lock);\n\tret = -ENOMEM;\n\tn_new = kmem_cache_alloc(sn_cache, GFP_KERNEL);\n\tif (!n_new)\n\t\tgoto err_out;\n\tmpol_new = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\tif (!mpol_new)\n\t\tgoto err_out;\n\tgoto restart;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sp_alloc",
          "args": [
            "vma->vm_pgoff",
            "vma->vm_pgoff + sz",
            "npol"
          ],
          "line": 2521
        },
        "resolved": true,
        "details": {
          "function_name": "sp_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2371-2390",
          "snippet": "static struct sp_node *sp_alloc(unsigned long start, unsigned long end,\n\t\t\t\tstruct mempolicy *pol)\n{\n\tstruct sp_node *n;\n\tstruct mempolicy *newpol;\n\n\tn = kmem_cache_alloc(sn_cache, GFP_KERNEL);\n\tif (!n)\n\t\treturn NULL;\n\n\tnewpol = mpol_dup(pol);\n\tif (IS_ERR(newpol)) {\n\t\tkmem_cache_free(sn_cache, n);\n\t\treturn NULL;\n\t}\n\tnewpol->flags |= MPOL_F_SHARED;\n\tsp_node_init(n, start, end, newpol);\n\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *sn_cache;",
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct kmem_cache *sn_cache;\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic struct sp_node *sp_alloc(unsigned long start, unsigned long end,\n\t\t\t\tstruct mempolicy *pol)\n{\n\tstruct sp_node *n;\n\tstruct mempolicy *newpol;\n\n\tn = kmem_cache_alloc(sn_cache, GFP_KERNEL);\n\tif (!n)\n\t\treturn NULL;\n\n\tnewpol = mpol_dup(pol);\n\tif (IS_ERR(newpol)) {\n\t\tkmem_cache_free(sn_cache, n);\n\t\treturn NULL;\n\t}\n\tnewpol->flags |= MPOL_F_SHARED;\n\tsp_node_init(n, start, end, newpol);\n\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"set_shared_policy %lx sz %lu %d %d %lx\\n\"",
            "vma->vm_pgoff",
            "sz",
            "npol ? npol->mode : -1",
            "npol ? npol->flags : -1",
            "npol ? nodes_addr(npol->v.nodes)[0] : NUMA_NO_NODE"
          ],
          "line": 2514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_addr",
          "args": [
            "npol->v.nodes"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_pages",
          "args": [
            "vma"
          ],
          "line": 2512
        },
        "resolved": true,
        "details": {
          "function_name": "munlock_vma_pages_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "292-295",
          "snippet": "static inline void munlock_vma_pages_all(struct vm_area_struct *vma)\n{\n\tmunlock_vma_pages_range(vma, vma->vm_start, vma->vm_end);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void munlock_vma_pages_all(struct vm_area_struct *vma)\n{\n\tmunlock_vma_pages_range(vma, vma->vm_start, vma->vm_end);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nint mpol_set_shared_policy(struct shared_policy *info,\n\t\t\tstruct vm_area_struct *vma, struct mempolicy *npol)\n{\n\tint err;\n\tstruct sp_node *new = NULL;\n\tunsigned long sz = vma_pages(vma);\n\n\tpr_debug(\"set_shared_policy %lx sz %lu %d %d %lx\\n\",\n\t\t vma->vm_pgoff,\n\t\t sz, npol ? npol->mode : -1,\n\t\t npol ? npol->flags : -1,\n\t\t npol ? nodes_addr(npol->v.nodes)[0] : NUMA_NO_NODE);\n\n\tif (npol) {\n\t\tnew = sp_alloc(vma->vm_pgoff, vma->vm_pgoff + sz, npol);\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\t}\n\terr = shared_policy_replace(info, vma->vm_pgoff, vma->vm_pgoff+sz, new);\n\tif (err && new)\n\t\tsp_free(new);\n\treturn err;\n}"
  },
  {
    "function_name": "mpol_shared_policy_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "2468-2505",
    "snippet": "void mpol_shared_policy_init(struct shared_policy *sp, struct mempolicy *mpol)\n{\n\tint ret;\n\n\tsp->root = RB_ROOT;\t\t/* empty tree == default mempolicy */\n\trwlock_init(&sp->lock);\n\n\tif (mpol) {\n\t\tstruct vm_area_struct pvma;\n\t\tstruct mempolicy *new;\n\t\tNODEMASK_SCRATCH(scratch);\n\n\t\tif (!scratch)\n\t\t\tgoto put_mpol;\n\t\t/* contextualize the tmpfs mount point mempolicy */\n\t\tnew = mpol_new(mpol->mode, mpol->flags, &mpol->w.user_nodemask);\n\t\tif (IS_ERR(new))\n\t\t\tgoto free_scratch; /* no valid nodemask intersection */\n\n\t\ttask_lock(current);\n\t\tret = mpol_set_nodemask(new, &mpol->w.user_nodemask, scratch);\n\t\ttask_unlock(current);\n\t\tif (ret)\n\t\t\tgoto put_new;\n\n\t\t/* Create pseudo-vma that contains just the policy */\n\t\tvma_init(&pvma, NULL);\n\t\tpvma.vm_end = TASK_SIZE;\t/* policy covers entire file */\n\t\tmpol_set_shared_policy(sp, &pvma, new); /* adds ref */\n\nput_new:\n\t\tmpol_put(new);\t\t\t/* drop initial ref */\nfree_scratch:\n\t\tNODEMASK_SCRATCH_FREE(scratch);\nput_mpol:\n\t\tmpol_put(mpol);\t/* drop our incoming ref on sb mpol */\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpol_put",
          "args": [
            "mpol"
          ],
          "line": 2503
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_put_task_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2345-2354",
          "snippet": "void mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nvoid mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NODEMASK_SCRATCH_FREE",
          "args": [
            "scratch"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_set_shared_policy",
          "args": [
            "sp",
            "&pvma",
            "new"
          ],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_set_shared_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2507-2529",
          "snippet": "int mpol_set_shared_policy(struct shared_policy *info,\n\t\t\tstruct vm_area_struct *vma, struct mempolicy *npol)\n{\n\tint err;\n\tstruct sp_node *new = NULL;\n\tunsigned long sz = vma_pages(vma);\n\n\tpr_debug(\"set_shared_policy %lx sz %lu %d %d %lx\\n\",\n\t\t vma->vm_pgoff,\n\t\t sz, npol ? npol->mode : -1,\n\t\t npol ? npol->flags : -1,\n\t\t npol ? nodes_addr(npol->v.nodes)[0] : NUMA_NO_NODE);\n\n\tif (npol) {\n\t\tnew = sp_alloc(vma->vm_pgoff, vma->vm_pgoff + sz, npol);\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\t}\n\terr = shared_policy_replace(info, vma->vm_pgoff, vma->vm_pgoff+sz, new);\n\tif (err && new)\n\t\tsp_free(new);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nint mpol_set_shared_policy(struct shared_policy *info,\n\t\t\tstruct vm_area_struct *vma, struct mempolicy *npol)\n{\n\tint err;\n\tstruct sp_node *new = NULL;\n\tunsigned long sz = vma_pages(vma);\n\n\tpr_debug(\"set_shared_policy %lx sz %lu %d %d %lx\\n\",\n\t\t vma->vm_pgoff,\n\t\t sz, npol ? npol->mode : -1,\n\t\t npol ? npol->flags : -1,\n\t\t npol ? nodes_addr(npol->v.nodes)[0] : NUMA_NO_NODE);\n\n\tif (npol) {\n\t\tnew = sp_alloc(vma->vm_pgoff, vma->vm_pgoff + sz, npol);\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\t}\n\terr = shared_policy_replace(info, vma->vm_pgoff, vma->vm_pgoff+sz, new);\n\tif (err && new)\n\t\tsp_free(new);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_init",
          "args": [
            "&pvma",
            "NULL"
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "current"
          ],
          "line": 2489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_set_nodemask",
          "args": [
            "new",
            "&mpol->w.user_nodemask",
            "scratch"
          ],
          "line": 2488
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_set_nodemask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "203-236",
          "snippet": "static int mpol_set_nodemask(struct mempolicy *pol,\n\t\t     const nodemask_t *nodes, struct nodemask_scratch *nsc)\n{\n\tint ret;\n\n\t/* if mode is MPOL_DEFAULT, pol is NULL. This is right. */\n\tif (pol == NULL)\n\t\treturn 0;\n\t/* Check N_MEMORY */\n\tnodes_and(nsc->mask1,\n\t\t  cpuset_current_mems_allowed, node_states[N_MEMORY]);\n\n\tVM_BUG_ON(!nodes);\n\tif (pol->mode == MPOL_PREFERRED && nodes_empty(*nodes))\n\t\tnodes = NULL;\t/* explicit local allocation */\n\telse {\n\t\tif (pol->flags & MPOL_F_RELATIVE_NODES)\n\t\t\tmpol_relative_nodemask(&nsc->mask2, nodes, &nsc->mask1);\n\t\telse\n\t\t\tnodes_and(nsc->mask2, *nodes, nsc->mask1);\n\n\t\tif (mpol_store_user_nodemask(pol))\n\t\t\tpol->w.user_nodemask = *nodes;\n\t\telse\n\t\t\tpol->w.cpuset_mems_allowed =\n\t\t\t\t\t\tcpuset_current_mems_allowed;\n\t}\n\n\tif (nodes)\n\t\tret = mpol_ops[pol->mode].create(pol, &nsc->mask2);\n\telse\n\t\tret = mpol_ops[pol->mode].create(pol, NULL);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct mempolicy_operations {\n\tint (*create)(struct mempolicy *pol, const nodemask_t *nodes);\n\tvoid (*rebind)(struct mempolicy *pol, const nodemask_t *nodes);\n} mpol_ops[MPOL_MAX];",
            "static const struct mempolicy_operations mpol_ops[MPOL_MAX] = {\n\t[MPOL_DEFAULT] = {\n\t\t.rebind = mpol_rebind_default,\n\t},\n\t[MPOL_INTERLEAVE] = {\n\t\t.create = mpol_new_interleave,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n\t[MPOL_PREFERRED] = {\n\t\t.create = mpol_new_preferred,\n\t\t.rebind = mpol_rebind_preferred,\n\t},\n\t[MPOL_BIND] = {\n\t\t.create = mpol_new_bind,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n};",
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic const struct mempolicy_operations {\n\tint (*create)(struct mempolicy *pol, const nodemask_t *nodes);\n\tvoid (*rebind)(struct mempolicy *pol, const nodemask_t *nodes);\n} mpol_ops[MPOL_MAX];\nstatic const struct mempolicy_operations mpol_ops[MPOL_MAX] = {\n\t[MPOL_DEFAULT] = {\n\t\t.rebind = mpol_rebind_default,\n\t},\n\t[MPOL_INTERLEAVE] = {\n\t\t.create = mpol_new_interleave,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n\t[MPOL_PREFERRED] = {\n\t\t.create = mpol_new_preferred,\n\t\t.rebind = mpol_rebind_preferred,\n\t},\n\t[MPOL_BIND] = {\n\t\t.create = mpol_new_bind,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n};\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic int mpol_set_nodemask(struct mempolicy *pol,\n\t\t     const nodemask_t *nodes, struct nodemask_scratch *nsc)\n{\n\tint ret;\n\n\t/* if mode is MPOL_DEFAULT, pol is NULL. This is right. */\n\tif (pol == NULL)\n\t\treturn 0;\n\t/* Check N_MEMORY */\n\tnodes_and(nsc->mask1,\n\t\t  cpuset_current_mems_allowed, node_states[N_MEMORY]);\n\n\tVM_BUG_ON(!nodes);\n\tif (pol->mode == MPOL_PREFERRED && nodes_empty(*nodes))\n\t\tnodes = NULL;\t/* explicit local allocation */\n\telse {\n\t\tif (pol->flags & MPOL_F_RELATIVE_NODES)\n\t\t\tmpol_relative_nodemask(&nsc->mask2, nodes, &nsc->mask1);\n\t\telse\n\t\t\tnodes_and(nsc->mask2, *nodes, nsc->mask1);\n\n\t\tif (mpol_store_user_nodemask(pol))\n\t\t\tpol->w.user_nodemask = *nodes;\n\t\telse\n\t\t\tpol->w.cpuset_mems_allowed =\n\t\t\t\t\t\tcpuset_current_mems_allowed;\n\t}\n\n\tif (nodes)\n\t\tret = mpol_ops[pol->mode].create(pol, &nsc->mask2);\n\telse\n\t\tret = mpol_ops[pol->mode].create(pol, NULL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "current"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_new",
          "args": [
            "mpol->mode",
            "mpol->flags",
            "&mpol->w.user_nodemask"
          ],
          "line": 2483
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "242-284",
          "snippet": "static struct mempolicy *mpol_new(unsigned short mode, unsigned short flags,\n\t\t\t\t  nodemask_t *nodes)\n{\n\tstruct mempolicy *policy;\n\n\tpr_debug(\"setting mode %d flags %d nodes[0] %lx\\n\",\n\t\t mode, flags, nodes ? nodes_addr(*nodes)[0] : NUMA_NO_NODE);\n\n\tif (mode == MPOL_DEFAULT) {\n\t\tif (nodes && !nodes_empty(*nodes))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\treturn NULL;\n\t}\n\tVM_BUG_ON(!nodes);\n\n\t/*\n\t * MPOL_PREFERRED cannot be used with MPOL_F_STATIC_NODES or\n\t * MPOL_F_RELATIVE_NODES if the nodemask is empty (local allocation).\n\t * All other modes require a valid pointer to a non-empty nodemask.\n\t */\n\tif (mode == MPOL_PREFERRED) {\n\t\tif (nodes_empty(*nodes)) {\n\t\t\tif (((flags & MPOL_F_STATIC_NODES) ||\n\t\t\t     (flags & MPOL_F_RELATIVE_NODES)))\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t} else if (mode == MPOL_LOCAL) {\n\t\tif (!nodes_empty(*nodes) ||\n\t\t    (flags & MPOL_F_STATIC_NODES) ||\n\t\t    (flags & MPOL_F_RELATIVE_NODES))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tmode = MPOL_PREFERRED;\n\t} else if (nodes_empty(*nodes))\n\t\treturn ERR_PTR(-EINVAL);\n\tpolicy = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\tif (!policy)\n\t\treturn ERR_PTR(-ENOMEM);\n\tatomic_set(&policy->refcnt, 1);\n\tpolicy->mode = mode;\n\tpolicy->flags = flags;\n\n\treturn policy;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *policy_cache;",
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct kmem_cache *policy_cache;\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic struct mempolicy *mpol_new(unsigned short mode, unsigned short flags,\n\t\t\t\t  nodemask_t *nodes)\n{\n\tstruct mempolicy *policy;\n\n\tpr_debug(\"setting mode %d flags %d nodes[0] %lx\\n\",\n\t\t mode, flags, nodes ? nodes_addr(*nodes)[0] : NUMA_NO_NODE);\n\n\tif (mode == MPOL_DEFAULT) {\n\t\tif (nodes && !nodes_empty(*nodes))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\treturn NULL;\n\t}\n\tVM_BUG_ON(!nodes);\n\n\t/*\n\t * MPOL_PREFERRED cannot be used with MPOL_F_STATIC_NODES or\n\t * MPOL_F_RELATIVE_NODES if the nodemask is empty (local allocation).\n\t * All other modes require a valid pointer to a non-empty nodemask.\n\t */\n\tif (mode == MPOL_PREFERRED) {\n\t\tif (nodes_empty(*nodes)) {\n\t\t\tif (((flags & MPOL_F_STATIC_NODES) ||\n\t\t\t     (flags & MPOL_F_RELATIVE_NODES)))\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t} else if (mode == MPOL_LOCAL) {\n\t\tif (!nodes_empty(*nodes) ||\n\t\t    (flags & MPOL_F_STATIC_NODES) ||\n\t\t    (flags & MPOL_F_RELATIVE_NODES))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tmode = MPOL_PREFERRED;\n\t} else if (nodes_empty(*nodes))\n\t\treturn ERR_PTR(-EINVAL);\n\tpolicy = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\tif (!policy)\n\t\treturn ERR_PTR(-ENOMEM);\n\tatomic_set(&policy->refcnt, 1);\n\tpolicy->mode = mode;\n\tpolicy->flags = flags;\n\n\treturn policy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NODEMASK_SCRATCH",
          "args": [
            "scratch"
          ],
          "line": 2478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwlock_init",
          "args": [
            "&sp->lock"
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nvoid mpol_shared_policy_init(struct shared_policy *sp, struct mempolicy *mpol)\n{\n\tint ret;\n\n\tsp->root = RB_ROOT;\t\t/* empty tree == default mempolicy */\n\trwlock_init(&sp->lock);\n\n\tif (mpol) {\n\t\tstruct vm_area_struct pvma;\n\t\tstruct mempolicy *new;\n\t\tNODEMASK_SCRATCH(scratch);\n\n\t\tif (!scratch)\n\t\t\tgoto put_mpol;\n\t\t/* contextualize the tmpfs mount point mempolicy */\n\t\tnew = mpol_new(mpol->mode, mpol->flags, &mpol->w.user_nodemask);\n\t\tif (IS_ERR(new))\n\t\t\tgoto free_scratch; /* no valid nodemask intersection */\n\n\t\ttask_lock(current);\n\t\tret = mpol_set_nodemask(new, &mpol->w.user_nodemask, scratch);\n\t\ttask_unlock(current);\n\t\tif (ret)\n\t\t\tgoto put_new;\n\n\t\t/* Create pseudo-vma that contains just the policy */\n\t\tvma_init(&pvma, NULL);\n\t\tpvma.vm_end = TASK_SIZE;\t/* policy covers entire file */\n\t\tmpol_set_shared_policy(sp, &pvma, new); /* adds ref */\n\nput_new:\n\t\tmpol_put(new);\t\t\t/* drop initial ref */\nfree_scratch:\n\t\tNODEMASK_SCRATCH_FREE(scratch);\nput_mpol:\n\t\tmpol_put(mpol);\t/* drop our incoming ref on sb mpol */\n\t}\n}"
  },
  {
    "function_name": "shared_policy_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "2393-2456",
    "snippet": "static int shared_policy_replace(struct shared_policy *sp, unsigned long start,\n\t\t\t\t unsigned long end, struct sp_node *new)\n{\n\tstruct sp_node *n;\n\tstruct sp_node *n_new = NULL;\n\tstruct mempolicy *mpol_new = NULL;\n\tint ret = 0;\n\nrestart:\n\twrite_lock(&sp->lock);\n\tn = sp_lookup(sp, start, end);\n\t/* Take care of old policies in the same range. */\n\twhile (n && n->start < end) {\n\t\tstruct rb_node *next = rb_next(&n->nd);\n\t\tif (n->start >= start) {\n\t\t\tif (n->end <= end)\n\t\t\t\tsp_delete(sp, n);\n\t\t\telse\n\t\t\t\tn->start = end;\n\t\t} else {\n\t\t\t/* Old policy spanning whole new range. */\n\t\t\tif (n->end > end) {\n\t\t\t\tif (!n_new)\n\t\t\t\t\tgoto alloc_new;\n\n\t\t\t\t*mpol_new = *n->policy;\n\t\t\t\tatomic_set(&mpol_new->refcnt, 1);\n\t\t\t\tsp_node_init(n_new, end, n->end, mpol_new);\n\t\t\t\tn->end = start;\n\t\t\t\tsp_insert(sp, n_new);\n\t\t\t\tn_new = NULL;\n\t\t\t\tmpol_new = NULL;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tn->end = start;\n\t\t}\n\t\tif (!next)\n\t\t\tbreak;\n\t\tn = rb_entry(next, struct sp_node, nd);\n\t}\n\tif (new)\n\t\tsp_insert(sp, new);\n\twrite_unlock(&sp->lock);\n\tret = 0;\n\nerr_out:\n\tif (mpol_new)\n\t\tmpol_put(mpol_new);\n\tif (n_new)\n\t\tkmem_cache_free(sn_cache, n_new);\n\n\treturn ret;\n\nalloc_new:\n\twrite_unlock(&sp->lock);\n\tret = -ENOMEM;\n\tn_new = kmem_cache_alloc(sn_cache, GFP_KERNEL);\n\tif (!n_new)\n\t\tgoto err_out;\n\tmpol_new = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\tif (!mpol_new)\n\t\tgoto err_out;\n\tgoto restart;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *policy_cache;",
      "static struct kmem_cache *sn_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "policy_cache",
            "GFP_KERNEL"
          ],
          "line": 2452
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3550-3559",
          "snippet": "void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *ret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc(_RET_IP_, ret,\n\t\t\t       cachep->object_size, cachep->size, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *ret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc(_RET_IP_, ret,\n\t\t\t       cachep->object_size, cachep->size, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&sp->lock"
          ],
          "line": 2447
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "1869-1872",
          "snippet": "static void migrate_write_unlock(struct zspage *zspage)\n{\n\twrite_unlock(&zspage->lock);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void migrate_write_unlock(struct zspage *zspage)\n{\n\twrite_unlock(&zspage->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "sn_cache",
            "n_new"
          ],
          "line": 2442
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3749-3764",
          "snippet": "void kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mpol_put",
          "args": [
            "mpol_new"
          ],
          "line": 2440
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_put_task_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2345-2354",
          "snippet": "void mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nvoid mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sp_insert",
          "args": [
            "sp",
            "new"
          ],
          "line": 2434
        },
        "resolved": true,
        "details": {
          "function_name": "sp_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2209-2229",
          "snippet": "static void sp_insert(struct shared_policy *sp, struct sp_node *new)\n{\n\tstruct rb_node **p = &sp->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct sp_node *nd;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tnd = rb_entry(parent, struct sp_node, nd);\n\t\tif (new->start < nd->start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new->end > nd->end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\trb_link_node(&new->nd, parent, p);\n\trb_insert_color(&new->nd, &sp->root);\n\tpr_debug(\"inserting %lx-%lx: %d\\n\", new->start, new->end,\n\t\t new->policy ? new->policy->mode : 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void sp_insert(struct shared_policy *sp, struct sp_node *new)\n{\n\tstruct rb_node **p = &sp->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct sp_node *nd;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tnd = rb_entry(parent, struct sp_node, nd);\n\t\tif (new->start < nd->start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new->end > nd->end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\trb_link_node(&new->nd, parent, p);\n\trb_insert_color(&new->nd, &sp->root);\n\tpr_debug(\"inserting %lx-%lx: %d\\n\", new->start, new->end,\n\t\t new->policy ? new->policy->mode : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "next",
            "structsp_node",
            "nd"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sp_node_init",
          "args": [
            "n_new",
            "end",
            "n->end",
            "mpol_new"
          ],
          "line": 2420
        },
        "resolved": true,
        "details": {
          "function_name": "sp_node_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2363-2369",
          "snippet": "static void sp_node_init(struct sp_node *node, unsigned long start,\n\t\t\tunsigned long end, struct mempolicy *pol)\n{\n\tnode->start = start;\n\tnode->end = end;\n\tnode->policy = pol;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void sp_node_init(struct sp_node *node, unsigned long start,\n\t\t\tunsigned long end, struct mempolicy *pol)\n{\n\tnode->start = start;\n\tnode->end = end;\n\tnode->policy = pol;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&mpol_new->refcnt",
            "1"
          ],
          "line": 2419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sp_delete",
          "args": [
            "sp",
            "n"
          ],
          "line": 2409
        },
        "resolved": true,
        "details": {
          "function_name": "sp_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2356-2361",
          "snippet": "static void sp_delete(struct shared_policy *sp, struct sp_node *n)\n{\n\tpr_debug(\"deleting %lx-l%lx\\n\", n->start, n->end);\n\trb_erase(&n->nd, &sp->root);\n\tsp_free(n);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void sp_delete(struct shared_policy *sp, struct sp_node *n)\n{\n\tpr_debug(\"deleting %lx-l%lx\\n\", n->start, n->end);\n\trb_erase(&n->nd, &sp->root);\n\tsp_free(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&n->nd"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sp_lookup",
          "args": [
            "sp",
            "start",
            "end"
          ],
          "line": 2403
        },
        "resolved": true,
        "details": {
          "function_name": "sp_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2175-2203",
          "snippet": "static struct sp_node *\nsp_lookup(struct shared_policy *sp, unsigned long start, unsigned long end)\n{\n\tstruct rb_node *n = sp->root.rb_node;\n\n\twhile (n) {\n\t\tstruct sp_node *p = rb_entry(n, struct sp_node, nd);\n\n\t\tif (start >= p->end)\n\t\t\tn = n->rb_right;\n\t\telse if (end <= p->start)\n\t\t\tn = n->rb_left;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!n)\n\t\treturn NULL;\n\tfor (;;) {\n\t\tstruct sp_node *w = NULL;\n\t\tstruct rb_node *prev = rb_prev(n);\n\t\tif (!prev)\n\t\t\tbreak;\n\t\tw = rb_entry(prev, struct sp_node, nd);\n\t\tif (w->end <= start)\n\t\t\tbreak;\n\t\tn = prev;\n\t}\n\treturn rb_entry(n, struct sp_node, nd);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct sp_node *\nsp_lookup(struct shared_policy *sp, unsigned long start, unsigned long end)\n{\n\tstruct rb_node *n = sp->root.rb_node;\n\n\twhile (n) {\n\t\tstruct sp_node *p = rb_entry(n, struct sp_node, nd);\n\n\t\tif (start >= p->end)\n\t\t\tn = n->rb_right;\n\t\telse if (end <= p->start)\n\t\t\tn = n->rb_left;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!n)\n\t\treturn NULL;\n\tfor (;;) {\n\t\tstruct sp_node *w = NULL;\n\t\tstruct rb_node *prev = rb_prev(n);\n\t\tif (!prev)\n\t\t\tbreak;\n\t\tw = rb_entry(prev, struct sp_node, nd);\n\t\tif (w->end <= start)\n\t\t\tbreak;\n\t\tn = prev;\n\t}\n\treturn rb_entry(n, struct sp_node, nd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&sp->lock"
          ],
          "line": 2402
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "1864-1867",
          "snippet": "static void migrate_write_lock(struct zspage *zspage)\n{\n\twrite_lock(&zspage->lock);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void migrate_write_lock(struct zspage *zspage)\n{\n\twrite_lock(&zspage->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct kmem_cache *policy_cache;\nstatic struct kmem_cache *sn_cache;\n\nstatic int shared_policy_replace(struct shared_policy *sp, unsigned long start,\n\t\t\t\t unsigned long end, struct sp_node *new)\n{\n\tstruct sp_node *n;\n\tstruct sp_node *n_new = NULL;\n\tstruct mempolicy *mpol_new = NULL;\n\tint ret = 0;\n\nrestart:\n\twrite_lock(&sp->lock);\n\tn = sp_lookup(sp, start, end);\n\t/* Take care of old policies in the same range. */\n\twhile (n && n->start < end) {\n\t\tstruct rb_node *next = rb_next(&n->nd);\n\t\tif (n->start >= start) {\n\t\t\tif (n->end <= end)\n\t\t\t\tsp_delete(sp, n);\n\t\t\telse\n\t\t\t\tn->start = end;\n\t\t} else {\n\t\t\t/* Old policy spanning whole new range. */\n\t\t\tif (n->end > end) {\n\t\t\t\tif (!n_new)\n\t\t\t\t\tgoto alloc_new;\n\n\t\t\t\t*mpol_new = *n->policy;\n\t\t\t\tatomic_set(&mpol_new->refcnt, 1);\n\t\t\t\tsp_node_init(n_new, end, n->end, mpol_new);\n\t\t\t\tn->end = start;\n\t\t\t\tsp_insert(sp, n_new);\n\t\t\t\tn_new = NULL;\n\t\t\t\tmpol_new = NULL;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tn->end = start;\n\t\t}\n\t\tif (!next)\n\t\t\tbreak;\n\t\tn = rb_entry(next, struct sp_node, nd);\n\t}\n\tif (new)\n\t\tsp_insert(sp, new);\n\twrite_unlock(&sp->lock);\n\tret = 0;\n\nerr_out:\n\tif (mpol_new)\n\t\tmpol_put(mpol_new);\n\tif (n_new)\n\t\tkmem_cache_free(sn_cache, n_new);\n\n\treturn ret;\n\nalloc_new:\n\twrite_unlock(&sp->lock);\n\tret = -ENOMEM;\n\tn_new = kmem_cache_alloc(sn_cache, GFP_KERNEL);\n\tif (!n_new)\n\t\tgoto err_out;\n\tmpol_new = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\tif (!mpol_new)\n\t\tgoto err_out;\n\tgoto restart;\n}"
  },
  {
    "function_name": "sp_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "2371-2390",
    "snippet": "static struct sp_node *sp_alloc(unsigned long start, unsigned long end,\n\t\t\t\tstruct mempolicy *pol)\n{\n\tstruct sp_node *n;\n\tstruct mempolicy *newpol;\n\n\tn = kmem_cache_alloc(sn_cache, GFP_KERNEL);\n\tif (!n)\n\t\treturn NULL;\n\n\tnewpol = mpol_dup(pol);\n\tif (IS_ERR(newpol)) {\n\t\tkmem_cache_free(sn_cache, n);\n\t\treturn NULL;\n\t}\n\tnewpol->flags |= MPOL_F_SHARED;\n\tsp_node_init(n, start, end, newpol);\n\n\treturn n;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *sn_cache;",
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sp_node_init",
          "args": [
            "n",
            "start",
            "end",
            "newpol"
          ],
          "line": 2387
        },
        "resolved": true,
        "details": {
          "function_name": "sp_node_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2363-2369",
          "snippet": "static void sp_node_init(struct sp_node *node, unsigned long start,\n\t\t\tunsigned long end, struct mempolicy *pol)\n{\n\tnode->start = start;\n\tnode->end = end;\n\tnode->policy = pol;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void sp_node_init(struct sp_node *node, unsigned long start,\n\t\t\tunsigned long end, struct mempolicy *pol)\n{\n\tnode->start = start;\n\tnode->end = end;\n\tnode->policy = pol;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "sn_cache",
            "n"
          ],
          "line": 2383
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3749-3764",
          "snippet": "void kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "newpol"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_dup",
          "args": [
            "pol"
          ],
          "line": 2381
        },
        "resolved": true,
        "details": {
          "function_name": "__mpol_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2110-2131",
          "snippet": "struct mempolicy *__mpol_dup(struct mempolicy *old)\n{\n\tstruct mempolicy *new = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\n\tif (!new)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* task's mempolicy is protected by alloc_lock */\n\tif (old == current->mempolicy) {\n\t\ttask_lock(current);\n\t\t*new = *old;\n\t\ttask_unlock(current);\n\t} else\n\t\t*new = *old;\n\n\tif (current_cpuset_is_being_rebound()) {\n\t\tnodemask_t mems = cpuset_mems_allowed(current);\n\t\tmpol_rebind_policy(new, &mems);\n\t}\n\tatomic_set(&new->refcnt, 1);\n\treturn new;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *policy_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct kmem_cache *policy_cache;\n\nstruct mempolicy *__mpol_dup(struct mempolicy *old)\n{\n\tstruct mempolicy *new = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\n\tif (!new)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* task's mempolicy is protected by alloc_lock */\n\tif (old == current->mempolicy) {\n\t\ttask_lock(current);\n\t\t*new = *old;\n\t\ttask_unlock(current);\n\t} else\n\t\t*new = *old;\n\n\tif (current_cpuset_is_being_rebound()) {\n\t\tnodemask_t mems = cpuset_mems_allowed(current);\n\t\tmpol_rebind_policy(new, &mems);\n\t}\n\tatomic_set(&new->refcnt, 1);\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "sn_cache",
            "GFP_KERNEL"
          ],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3550-3559",
          "snippet": "void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *ret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc(_RET_IP_, ret,\n\t\t\t       cachep->object_size, cachep->size, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *ret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc(_RET_IP_, ret,\n\t\t\t       cachep->object_size, cachep->size, flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct kmem_cache *sn_cache;\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic struct sp_node *sp_alloc(unsigned long start, unsigned long end,\n\t\t\t\tstruct mempolicy *pol)\n{\n\tstruct sp_node *n;\n\tstruct mempolicy *newpol;\n\n\tn = kmem_cache_alloc(sn_cache, GFP_KERNEL);\n\tif (!n)\n\t\treturn NULL;\n\n\tnewpol = mpol_dup(pol);\n\tif (IS_ERR(newpol)) {\n\t\tkmem_cache_free(sn_cache, n);\n\t\treturn NULL;\n\t}\n\tnewpol->flags |= MPOL_F_SHARED;\n\tsp_node_init(n, start, end, newpol);\n\n\treturn n;\n}"
  },
  {
    "function_name": "sp_node_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "2363-2369",
    "snippet": "static void sp_node_init(struct sp_node *node, unsigned long start,\n\t\t\tunsigned long end, struct mempolicy *pol)\n{\n\tnode->start = start;\n\tnode->end = end;\n\tnode->policy = pol;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void sp_node_init(struct sp_node *node, unsigned long start,\n\t\t\tunsigned long end, struct mempolicy *pol)\n{\n\tnode->start = start;\n\tnode->end = end;\n\tnode->policy = pol;\n}"
  },
  {
    "function_name": "sp_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "2356-2361",
    "snippet": "static void sp_delete(struct shared_policy *sp, struct sp_node *n)\n{\n\tpr_debug(\"deleting %lx-l%lx\\n\", n->start, n->end);\n\trb_erase(&n->nd, &sp->root);\n\tsp_free(n);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sp_free",
          "args": [
            "n"
          ],
          "line": 2360
        },
        "resolved": true,
        "details": {
          "function_name": "sp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2250-2254",
          "snippet": "static void sp_free(struct sp_node *n)\n{\n\tmpol_put(n->policy);\n\tkmem_cache_free(sn_cache, n);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *sn_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct kmem_cache *sn_cache;\n\nstatic void sp_free(struct sp_node *n)\n{\n\tmpol_put(n->policy);\n\tkmem_cache_free(sn_cache, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&n->nd",
            "&sp->root"
          ],
          "line": 2359
        },
        "resolved": true,
        "details": {
          "function_name": "vma_rb_erase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "479-489",
          "snippet": "static __always_inline void vma_rb_erase(struct vm_area_struct *vma,\n\t\t\t\t\t struct rb_root *root)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the vma being erased.\n\t */\n\tvalidate_mm_rb(root, vma);\n\n\t__vma_rb_erase(vma, root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic __always_inline void vma_rb_erase(struct vm_area_struct *vma,\n\t\t\t\t\t struct rb_root *root)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the vma being erased.\n\t */\n\tvalidate_mm_rb(root, vma);\n\n\t__vma_rb_erase(vma, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"deleting %lx-l%lx\\n\"",
            "n->start",
            "n->end"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void sp_delete(struct shared_policy *sp, struct sp_node *n)\n{\n\tpr_debug(\"deleting %lx-l%lx\\n\", n->start, n->end);\n\trb_erase(&n->nd, &sp->root);\n\tsp_free(n);\n}"
  },
  {
    "function_name": "mpol_put_task_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "2345-2354",
    "snippet": "void mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpol_put",
          "args": [
            "pol"
          ],
          "line": 2353
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_put_task_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2345-2354",
          "snippet": "void mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "task"
          ],
          "line": 2352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "task"
          ],
          "line": 2349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nvoid mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}"
  },
  {
    "function_name": "mpol_misplaced",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "2273-2337",
    "snippet": "int mpol_misplaced(struct page *page, struct vm_area_struct *vma, unsigned long addr)\n{\n\tstruct mempolicy *pol;\n\tstruct zoneref *z;\n\tint curnid = page_to_nid(page);\n\tunsigned long pgoff;\n\tint thiscpu = raw_smp_processor_id();\n\tint thisnid = cpu_to_node(thiscpu);\n\tint polnid = -1;\n\tint ret = -1;\n\n\tpol = get_vma_policy(vma, addr);\n\tif (!(pol->flags & MPOL_F_MOF))\n\t\tgoto out;\n\n\tswitch (pol->mode) {\n\tcase MPOL_INTERLEAVE:\n\t\tpgoff = vma->vm_pgoff;\n\t\tpgoff += (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\tpolnid = offset_il_node(pol, pgoff);\n\t\tbreak;\n\n\tcase MPOL_PREFERRED:\n\t\tif (pol->flags & MPOL_F_LOCAL)\n\t\t\tpolnid = numa_node_id();\n\t\telse\n\t\t\tpolnid = pol->v.preferred_node;\n\t\tbreak;\n\n\tcase MPOL_BIND:\n\n\t\t/*\n\t\t * allows binding to multiple nodes.\n\t\t * use current page if in policy nodemask,\n\t\t * else select nearest allowed node, if any.\n\t\t * If no allowed nodes, use current [!misplaced].\n\t\t */\n\t\tif (node_isset(curnid, pol->v.nodes))\n\t\t\tgoto out;\n\t\tz = first_zones_zonelist(\n\t\t\t\tnode_zonelist(numa_node_id(), GFP_HIGHUSER),\n\t\t\t\tgfp_zone(GFP_HIGHUSER),\n\t\t\t\t&pol->v.nodes);\n\t\tpolnid = zone_to_nid(z->zone);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/* Migrate the page towards the node whose CPU is referencing it */\n\tif (pol->flags & MPOL_F_MORON) {\n\t\tpolnid = thisnid;\n\n\t\tif (!should_numa_migrate_memory(current, page, curnid, thiscpu))\n\t\t\tgoto out;\n\t}\n\n\tif (curnid != polnid)\n\t\tret = polnid;\nout:\n\tmpol_cond_put(pol);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpol_cond_put",
          "args": [
            "pol"
          ],
          "line": 2334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "should_numa_migrate_memory",
          "args": [
            "current",
            "page",
            "curnid",
            "thiscpu"
          ],
          "line": 2327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_to_nid",
          "args": [
            "z->zone"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "first_zones_zonelist",
          "args": [
            "node_zonelist(numa_node_id(), GFP_HIGHUSER)",
            "gfp_zone(GFP_HIGHUSER)",
            "&pol->v.nodes"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfp_zone",
          "args": [
            "GFP_HIGHUSER"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_zonelist",
          "args": [
            "numa_node_id()",
            "GFP_HIGHUSER"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_node_id",
          "args": [],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_isset",
          "args": [
            "curnid",
            "pol->v.nodes"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_node_id",
          "args": [],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_il_node",
          "args": [
            "pol",
            "pgoff"
          ],
          "line": 2292
        },
        "resolved": true,
        "details": {
          "function_name": "offset_il_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1814-1828",
          "snippet": "static unsigned offset_il_node(struct mempolicy *pol, unsigned long n)\n{\n\tunsigned nnodes = nodes_weight(pol->v.nodes);\n\tunsigned target;\n\tint i;\n\tint nid;\n\n\tif (!nnodes)\n\t\treturn numa_node_id();\n\ttarget = (unsigned int)n % nnodes;\n\tnid = first_node(pol->v.nodes);\n\tfor (i = 0; i < target; i++)\n\t\tnid = next_node(nid, pol->v.nodes);\n\treturn nid;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic unsigned offset_il_node(struct mempolicy *pol, unsigned long n)\n{\n\tunsigned nnodes = nodes_weight(pol->v.nodes);\n\tunsigned target;\n\tint i;\n\tint nid;\n\n\tif (!nnodes)\n\t\treturn numa_node_id();\n\ttarget = (unsigned int)n % nnodes;\n\tnid = first_node(pol->v.nodes);\n\tfor (i = 0; i < target; i++)\n\t\tnid = next_node(nid, pol->v.nodes);\n\treturn nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vma_policy",
          "args": [
            "vma",
            "addr"
          ],
          "line": 2284
        },
        "resolved": true,
        "details": {
          "function_name": "get_vma_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1665-1674",
          "snippet": "struct mempolicy *get_vma_policy(struct vm_area_struct *vma,\n\t\t\t\t\t\tunsigned long addr)\n{\n\tstruct mempolicy *pol = __get_vma_policy(vma, addr);\n\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstruct mempolicy *get_vma_policy(struct vm_area_struct *vma,\n\t\t\t\t\t\tunsigned long addr)\n{\n\tstruct mempolicy *pol = __get_vma_policy(vma, addr);\n\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "thiscpu"
          ],
          "line": 2280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 2279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nint mpol_misplaced(struct page *page, struct vm_area_struct *vma, unsigned long addr)\n{\n\tstruct mempolicy *pol;\n\tstruct zoneref *z;\n\tint curnid = page_to_nid(page);\n\tunsigned long pgoff;\n\tint thiscpu = raw_smp_processor_id();\n\tint thisnid = cpu_to_node(thiscpu);\n\tint polnid = -1;\n\tint ret = -1;\n\n\tpol = get_vma_policy(vma, addr);\n\tif (!(pol->flags & MPOL_F_MOF))\n\t\tgoto out;\n\n\tswitch (pol->mode) {\n\tcase MPOL_INTERLEAVE:\n\t\tpgoff = vma->vm_pgoff;\n\t\tpgoff += (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\tpolnid = offset_il_node(pol, pgoff);\n\t\tbreak;\n\n\tcase MPOL_PREFERRED:\n\t\tif (pol->flags & MPOL_F_LOCAL)\n\t\t\tpolnid = numa_node_id();\n\t\telse\n\t\t\tpolnid = pol->v.preferred_node;\n\t\tbreak;\n\n\tcase MPOL_BIND:\n\n\t\t/*\n\t\t * allows binding to multiple nodes.\n\t\t * use current page if in policy nodemask,\n\t\t * else select nearest allowed node, if any.\n\t\t * If no allowed nodes, use current [!misplaced].\n\t\t */\n\t\tif (node_isset(curnid, pol->v.nodes))\n\t\t\tgoto out;\n\t\tz = first_zones_zonelist(\n\t\t\t\tnode_zonelist(numa_node_id(), GFP_HIGHUSER),\n\t\t\t\tgfp_zone(GFP_HIGHUSER),\n\t\t\t\t&pol->v.nodes);\n\t\tpolnid = zone_to_nid(z->zone);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/* Migrate the page towards the node whose CPU is referencing it */\n\tif (pol->flags & MPOL_F_MORON) {\n\t\tpolnid = thisnid;\n\n\t\tif (!should_numa_migrate_memory(current, page, curnid, thiscpu))\n\t\t\tgoto out;\n\t}\n\n\tif (curnid != polnid)\n\t\tret = polnid;\nout:\n\tmpol_cond_put(pol);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "sp_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "2250-2254",
    "snippet": "static void sp_free(struct sp_node *n)\n{\n\tmpol_put(n->policy);\n\tkmem_cache_free(sn_cache, n);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *sn_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "sn_cache",
            "n"
          ],
          "line": 2253
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3749-3764",
          "snippet": "void kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mpol_put",
          "args": [
            "n->policy"
          ],
          "line": 2252
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_put_task_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2345-2354",
          "snippet": "void mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nvoid mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct kmem_cache *sn_cache;\n\nstatic void sp_free(struct sp_node *n)\n{\n\tmpol_put(n->policy);\n\tkmem_cache_free(sn_cache, n);\n}"
  },
  {
    "function_name": "mpol_shared_policy_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "2232-2248",
    "snippet": "struct mempolicy *\nmpol_shared_policy_lookup(struct shared_policy *sp, unsigned long idx)\n{\n\tstruct mempolicy *pol = NULL;\n\tstruct sp_node *sn;\n\n\tif (!sp->root.rb_node)\n\t\treturn NULL;\n\tread_lock(&sp->lock);\n\tsn = sp_lookup(sp, idx, idx+1);\n\tif (sn) {\n\t\tmpol_get(sn->policy);\n\t\tpol = sn->policy;\n\t}\n\tread_unlock(&sp->lock);\n\treturn pol;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&sp->lock"
          ],
          "line": 2246
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "1859-1862",
          "snippet": "static void migrate_read_unlock(struct zspage *zspage)\n{\n\tread_unlock(&zspage->lock);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void migrate_read_unlock(struct zspage *zspage)\n{\n\tread_unlock(&zspage->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mpol_get",
          "args": [
            "sn->policy"
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sp_lookup",
          "args": [
            "sp",
            "idx",
            "idx+1"
          ],
          "line": 2241
        },
        "resolved": true,
        "details": {
          "function_name": "sp_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2175-2203",
          "snippet": "static struct sp_node *\nsp_lookup(struct shared_policy *sp, unsigned long start, unsigned long end)\n{\n\tstruct rb_node *n = sp->root.rb_node;\n\n\twhile (n) {\n\t\tstruct sp_node *p = rb_entry(n, struct sp_node, nd);\n\n\t\tif (start >= p->end)\n\t\t\tn = n->rb_right;\n\t\telse if (end <= p->start)\n\t\t\tn = n->rb_left;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!n)\n\t\treturn NULL;\n\tfor (;;) {\n\t\tstruct sp_node *w = NULL;\n\t\tstruct rb_node *prev = rb_prev(n);\n\t\tif (!prev)\n\t\t\tbreak;\n\t\tw = rb_entry(prev, struct sp_node, nd);\n\t\tif (w->end <= start)\n\t\t\tbreak;\n\t\tn = prev;\n\t}\n\treturn rb_entry(n, struct sp_node, nd);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct sp_node *\nsp_lookup(struct shared_policy *sp, unsigned long start, unsigned long end)\n{\n\tstruct rb_node *n = sp->root.rb_node;\n\n\twhile (n) {\n\t\tstruct sp_node *p = rb_entry(n, struct sp_node, nd);\n\n\t\tif (start >= p->end)\n\t\t\tn = n->rb_right;\n\t\telse if (end <= p->start)\n\t\t\tn = n->rb_left;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!n)\n\t\treturn NULL;\n\tfor (;;) {\n\t\tstruct sp_node *w = NULL;\n\t\tstruct rb_node *prev = rb_prev(n);\n\t\tif (!prev)\n\t\t\tbreak;\n\t\tw = rb_entry(prev, struct sp_node, nd);\n\t\tif (w->end <= start)\n\t\t\tbreak;\n\t\tn = prev;\n\t}\n\treturn rb_entry(n, struct sp_node, nd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&sp->lock"
          ],
          "line": 2240
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "1854-1857",
          "snippet": "static void migrate_read_lock(struct zspage *zspage)\n{\n\tread_lock(&zspage->lock);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void migrate_read_lock(struct zspage *zspage)\n{\n\tread_lock(&zspage->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstruct mempolicy *\nmpol_shared_policy_lookup(struct shared_policy *sp, unsigned long idx)\n{\n\tstruct mempolicy *pol = NULL;\n\tstruct sp_node *sn;\n\n\tif (!sp->root.rb_node)\n\t\treturn NULL;\n\tread_lock(&sp->lock);\n\tsn = sp_lookup(sp, idx, idx+1);\n\tif (sn) {\n\t\tmpol_get(sn->policy);\n\t\tpol = sn->policy;\n\t}\n\tread_unlock(&sp->lock);\n\treturn pol;\n}"
  },
  {
    "function_name": "sp_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "2209-2229",
    "snippet": "static void sp_insert(struct shared_policy *sp, struct sp_node *new)\n{\n\tstruct rb_node **p = &sp->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct sp_node *nd;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tnd = rb_entry(parent, struct sp_node, nd);\n\t\tif (new->start < nd->start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new->end > nd->end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\trb_link_node(&new->nd, parent, p);\n\trb_insert_color(&new->nd, &sp->root);\n\tpr_debug(\"inserting %lx-%lx: %d\\n\", new->start, new->end,\n\t\t new->policy ? new->policy->mode : 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"inserting %lx-%lx: %d\\n\"",
            "new->start",
            "new->end",
            "new->policy ? new->policy->mode : 0"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&new->nd",
            "&sp->root"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&new->nd",
            "parent",
            "p"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structsp_node",
            "nd"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void sp_insert(struct shared_policy *sp, struct sp_node *new)\n{\n\tstruct rb_node **p = &sp->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct sp_node *nd;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tnd = rb_entry(parent, struct sp_node, nd);\n\t\tif (new->start < nd->start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new->end > nd->end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\trb_link_node(&new->nd, parent, p);\n\trb_insert_color(&new->nd, &sp->root);\n\tpr_debug(\"inserting %lx-%lx: %d\\n\", new->start, new->end,\n\t\t new->policy ? new->policy->mode : 0);\n}"
  },
  {
    "function_name": "sp_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "2175-2203",
    "snippet": "static struct sp_node *\nsp_lookup(struct shared_policy *sp, unsigned long start, unsigned long end)\n{\n\tstruct rb_node *n = sp->root.rb_node;\n\n\twhile (n) {\n\t\tstruct sp_node *p = rb_entry(n, struct sp_node, nd);\n\n\t\tif (start >= p->end)\n\t\t\tn = n->rb_right;\n\t\telse if (end <= p->start)\n\t\t\tn = n->rb_left;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!n)\n\t\treturn NULL;\n\tfor (;;) {\n\t\tstruct sp_node *w = NULL;\n\t\tstruct rb_node *prev = rb_prev(n);\n\t\tif (!prev)\n\t\t\tbreak;\n\t\tw = rb_entry(prev, struct sp_node, nd);\n\t\tif (w->end <= start)\n\t\t\tbreak;\n\t\tn = prev;\n\t}\n\treturn rb_entry(n, struct sp_node, nd);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structsp_node",
            "nd"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "prev",
            "structsp_node",
            "nd"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "n"
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structsp_node",
            "nd"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct sp_node *\nsp_lookup(struct shared_policy *sp, unsigned long start, unsigned long end)\n{\n\tstruct rb_node *n = sp->root.rb_node;\n\n\twhile (n) {\n\t\tstruct sp_node *p = rb_entry(n, struct sp_node, nd);\n\n\t\tif (start >= p->end)\n\t\t\tn = n->rb_right;\n\t\telse if (end <= p->start)\n\t\t\tn = n->rb_left;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!n)\n\t\treturn NULL;\n\tfor (;;) {\n\t\tstruct sp_node *w = NULL;\n\t\tstruct rb_node *prev = rb_prev(n);\n\t\tif (!prev)\n\t\t\tbreak;\n\t\tw = rb_entry(prev, struct sp_node, nd);\n\t\tif (w->end <= start)\n\t\t\tbreak;\n\t\tn = prev;\n\t}\n\treturn rb_entry(n, struct sp_node, nd);\n}"
  },
  {
    "function_name": "__mpol_equal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "2134-2160",
    "snippet": "bool __mpol_equal(struct mempolicy *a, struct mempolicy *b)\n{\n\tif (!a || !b)\n\t\treturn false;\n\tif (a->mode != b->mode)\n\t\treturn false;\n\tif (a->flags != b->flags)\n\t\treturn false;\n\tif (mpol_store_user_nodemask(a))\n\t\tif (!nodes_equal(a->w.user_nodemask, b->w.user_nodemask))\n\t\t\treturn false;\n\n\tswitch (a->mode) {\n\tcase MPOL_BIND:\n\t\t/* Fall through */\n\tcase MPOL_INTERLEAVE:\n\t\treturn !!nodes_equal(a->v.nodes, b->v.nodes);\n\tcase MPOL_PREFERRED:\n\t\t/* a's ->flags is the same as b's */\n\t\tif (a->flags & MPOL_F_LOCAL)\n\t\t\treturn true;\n\t\treturn a->v.preferred_node == b->v.preferred_node;\n\tdefault:\n\t\tBUG();\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_equal",
          "args": [
            "a->v.nodes",
            "b->v.nodes"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_equal",
          "args": [
            "a->w.user_nodemask",
            "b->w.user_nodemask"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_store_user_nodemask",
          "args": [
            "a"
          ],
          "line": 2142
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_store_user_nodemask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "154-157",
          "snippet": "static inline int mpol_store_user_nodemask(const struct mempolicy *pol)\n{\n\treturn pol->flags & MPOL_MODE_FLAGS;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic inline int mpol_store_user_nodemask(const struct mempolicy *pol)\n{\n\treturn pol->flags & MPOL_MODE_FLAGS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nbool __mpol_equal(struct mempolicy *a, struct mempolicy *b)\n{\n\tif (!a || !b)\n\t\treturn false;\n\tif (a->mode != b->mode)\n\t\treturn false;\n\tif (a->flags != b->flags)\n\t\treturn false;\n\tif (mpol_store_user_nodemask(a))\n\t\tif (!nodes_equal(a->w.user_nodemask, b->w.user_nodemask))\n\t\t\treturn false;\n\n\tswitch (a->mode) {\n\tcase MPOL_BIND:\n\t\t/* Fall through */\n\tcase MPOL_INTERLEAVE:\n\t\treturn !!nodes_equal(a->v.nodes, b->v.nodes);\n\tcase MPOL_PREFERRED:\n\t\t/* a's ->flags is the same as b's */\n\t\tif (a->flags & MPOL_F_LOCAL)\n\t\t\treturn true;\n\t\treturn a->v.preferred_node == b->v.preferred_node;\n\tdefault:\n\t\tBUG();\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "__mpol_dup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "2110-2131",
    "snippet": "struct mempolicy *__mpol_dup(struct mempolicy *old)\n{\n\tstruct mempolicy *new = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\n\tif (!new)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* task's mempolicy is protected by alloc_lock */\n\tif (old == current->mempolicy) {\n\t\ttask_lock(current);\n\t\t*new = *old;\n\t\ttask_unlock(current);\n\t} else\n\t\t*new = *old;\n\n\tif (current_cpuset_is_being_rebound()) {\n\t\tnodemask_t mems = cpuset_mems_allowed(current);\n\t\tmpol_rebind_policy(new, &mems);\n\t}\n\tatomic_set(&new->refcnt, 1);\n\treturn new;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *policy_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&new->refcnt",
            "1"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_rebind_policy",
          "args": [
            "new",
            "&mems"
          ],
          "line": 2127
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_rebind_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "349-358",
          "snippet": "static void mpol_rebind_policy(struct mempolicy *pol, const nodemask_t *newmask)\n{\n\tif (!pol)\n\t\treturn;\n\tif (!mpol_store_user_nodemask(pol) &&\n\t    nodes_equal(pol->w.cpuset_mems_allowed, *newmask))\n\t\treturn;\n\n\tmpol_ops[pol->mode].rebind(pol, newmask);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct mempolicy_operations {\n\tint (*create)(struct mempolicy *pol, const nodemask_t *nodes);\n\tvoid (*rebind)(struct mempolicy *pol, const nodemask_t *nodes);\n} mpol_ops[MPOL_MAX];",
            "static const struct mempolicy_operations mpol_ops[MPOL_MAX] = {\n\t[MPOL_DEFAULT] = {\n\t\t.rebind = mpol_rebind_default,\n\t},\n\t[MPOL_INTERLEAVE] = {\n\t\t.create = mpol_new_interleave,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n\t[MPOL_PREFERRED] = {\n\t\t.create = mpol_new_preferred,\n\t\t.rebind = mpol_rebind_preferred,\n\t},\n\t[MPOL_BIND] = {\n\t\t.create = mpol_new_bind,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic const struct mempolicy_operations {\n\tint (*create)(struct mempolicy *pol, const nodemask_t *nodes);\n\tvoid (*rebind)(struct mempolicy *pol, const nodemask_t *nodes);\n} mpol_ops[MPOL_MAX];\nstatic const struct mempolicy_operations mpol_ops[MPOL_MAX] = {\n\t[MPOL_DEFAULT] = {\n\t\t.rebind = mpol_rebind_default,\n\t},\n\t[MPOL_INTERLEAVE] = {\n\t\t.create = mpol_new_interleave,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n\t[MPOL_PREFERRED] = {\n\t\t.create = mpol_new_preferred,\n\t\t.rebind = mpol_rebind_preferred,\n\t},\n\t[MPOL_BIND] = {\n\t\t.create = mpol_new_bind,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n};\n\nstatic void mpol_rebind_policy(struct mempolicy *pol, const nodemask_t *newmask)\n{\n\tif (!pol)\n\t\treturn;\n\tif (!mpol_store_user_nodemask(pol) &&\n\t    nodes_equal(pol->w.cpuset_mems_allowed, *newmask))\n\t\treturn;\n\n\tmpol_ops[pol->mode].rebind(pol, newmask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuset_mems_allowed",
          "args": [
            "current"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cpuset_is_being_rebound",
          "args": [],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "current"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "current"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "policy_cache",
            "GFP_KERNEL"
          ],
          "line": 2112
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3550-3559",
          "snippet": "void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *ret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc(_RET_IP_, ret,\n\t\t\t       cachep->object_size, cachep->size, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *ret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc(_RET_IP_, ret,\n\t\t\t       cachep->object_size, cachep->size, flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct kmem_cache *policy_cache;\n\nstruct mempolicy *__mpol_dup(struct mempolicy *old)\n{\n\tstruct mempolicy *new = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\n\tif (!new)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* task's mempolicy is protected by alloc_lock */\n\tif (old == current->mempolicy) {\n\t\ttask_lock(current);\n\t\t*new = *old;\n\t\ttask_unlock(current);\n\t} else\n\t\t*new = *old;\n\n\tif (current_cpuset_is_being_rebound()) {\n\t\tnodemask_t mems = cpuset_mems_allowed(current);\n\t\tmpol_rebind_policy(new, &mems);\n\t}\n\tatomic_set(&new->refcnt, 1);\n\treturn new;\n}"
  },
  {
    "function_name": "vma_dup_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "2088-2096",
    "snippet": "int vma_dup_policy(struct vm_area_struct *src, struct vm_area_struct *dst)\n{\n\tstruct mempolicy *pol = mpol_dup(vma_policy(src));\n\n\tif (IS_ERR(pol))\n\t\treturn PTR_ERR(pol);\n\tdst->vm_policy = pol;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "pol"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pol"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_dup",
          "args": [
            "vma_policy(src)"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "__mpol_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2110-2131",
          "snippet": "struct mempolicy *__mpol_dup(struct mempolicy *old)\n{\n\tstruct mempolicy *new = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\n\tif (!new)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* task's mempolicy is protected by alloc_lock */\n\tif (old == current->mempolicy) {\n\t\ttask_lock(current);\n\t\t*new = *old;\n\t\ttask_unlock(current);\n\t} else\n\t\t*new = *old;\n\n\tif (current_cpuset_is_being_rebound()) {\n\t\tnodemask_t mems = cpuset_mems_allowed(current);\n\t\tmpol_rebind_policy(new, &mems);\n\t}\n\tatomic_set(&new->refcnt, 1);\n\treturn new;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *policy_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct kmem_cache *policy_cache;\n\nstruct mempolicy *__mpol_dup(struct mempolicy *old)\n{\n\tstruct mempolicy *new = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\n\tif (!new)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* task's mempolicy is protected by alloc_lock */\n\tif (old == current->mempolicy) {\n\t\ttask_lock(current);\n\t\t*new = *old;\n\t\ttask_unlock(current);\n\t} else\n\t\t*new = *old;\n\n\tif (current_cpuset_is_being_rebound()) {\n\t\tnodemask_t mems = cpuset_mems_allowed(current);\n\t\tmpol_rebind_policy(new, &mems);\n\t}\n\tatomic_set(&new->refcnt, 1);\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_policy",
          "args": [
            "src"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "vma_policy_mof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1676-1696",
          "snippet": "bool vma_policy_mof(struct vm_area_struct *vma)\n{\n\tstruct mempolicy *pol;\n\n\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\tbool ret = false;\n\n\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start);\n\t\tif (pol && (pol->flags & MPOL_F_MOF))\n\t\t\tret = true;\n\t\tmpol_cond_put(pol);\n\n\t\treturn ret;\n\t}\n\n\tpol = vma->vm_policy;\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol->flags & MPOL_F_MOF;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nbool vma_policy_mof(struct vm_area_struct *vma)\n{\n\tstruct mempolicy *pol;\n\n\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\tbool ret = false;\n\n\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start);\n\t\tif (pol && (pol->flags & MPOL_F_MOF))\n\t\t\tret = true;\n\t\tmpol_cond_put(pol);\n\n\t\treturn ret;\n\t}\n\n\tpol = vma->vm_policy;\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol->flags & MPOL_F_MOF;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nint vma_dup_policy(struct vm_area_struct *src, struct vm_area_struct *dst)\n{\n\tstruct mempolicy *pol = mpol_dup(vma_policy(src));\n\n\tif (IS_ERR(pol))\n\t\treturn PTR_ERR(pol);\n\tdst->vm_policy = pol;\n\treturn 0;\n}"
  },
  {
    "function_name": "alloc_pages_current",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "2065-2085",
    "snippet": "struct page *alloc_pages_current(gfp_t gfp, unsigned order)\n{\n\tstruct mempolicy *pol = &default_policy;\n\tstruct page *page;\n\n\tif (!in_interrupt() && !(gfp & __GFP_THISNODE))\n\t\tpol = get_task_policy(current);\n\n\t/*\n\t * No reference counting needed for current->mempolicy\n\t * nor system default_policy\n\t */\n\tif (pol->mode == MPOL_INTERLEAVE)\n\t\tpage = alloc_page_interleave(gfp, order, interleave_nodes(pol));\n\telse\n\t\tpage = __alloc_pages_nodemask(gfp, order,\n\t\t\t\tpolicy_node(gfp, pol, numa_node_id()),\n\t\t\t\tpolicy_nodemask(gfp, pol));\n\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct mempolicy default_policy = {\n\t.refcnt = ATOMIC_INIT(1), /* never free it */\n\t.mode = MPOL_PREFERRED,\n\t.flags = MPOL_F_LOCAL,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__alloc_pages_nodemask",
          "args": [
            "gfp",
            "order",
            "policy_node(gfp, pol, numa_node_id())",
            "policy_nodemask(gfp, pol)"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_pages_nodemask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4347-4405",
          "snippet": "struct page *\n__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid,\n\t\t\t\t\t\t\tnodemask_t *nodemask)\n{\n\tstruct page *page;\n\tunsigned int alloc_flags = ALLOC_WMARK_LOW;\n\tgfp_t alloc_mask; /* The gfp_t that was actually used for allocation */\n\tstruct alloc_context ac = { };\n\n\t/*\n\t * There are several places where we assume that the order value is sane\n\t * so bail out early if the request is out of bound.\n\t */\n\tif (unlikely(order >= MAX_ORDER)) {\n\t\tWARN_ON_ONCE(!(gfp_mask & __GFP_NOWARN));\n\t\treturn NULL;\n\t}\n\n\tgfp_mask &= gfp_allowed_mask;\n\talloc_mask = gfp_mask;\n\tif (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &ac, &alloc_mask, &alloc_flags))\n\t\treturn NULL;\n\n\tfinalise_ac(gfp_mask, &ac);\n\n\t/* First allocation attempt */\n\tpage = get_page_from_freelist(alloc_mask, order, alloc_flags, &ac);\n\tif (likely(page))\n\t\tgoto out;\n\n\t/*\n\t * Apply scoped allocation constraints. This is mainly about GFP_NOFS\n\t * resp. GFP_NOIO which has to be inherited for all allocation requests\n\t * from a particular context which has been marked by\n\t * memalloc_no{fs,io}_{save,restore}.\n\t */\n\talloc_mask = current_gfp_context(gfp_mask);\n\tac.spread_dirty_pages = false;\n\n\t/*\n\t * Restore the original nodemask if it was potentially replaced with\n\t * &cpuset_current_mems_allowed to optimize the fast-path attempt.\n\t */\n\tif (unlikely(ac.nodemask != nodemask))\n\t\tac.nodemask = nodemask;\n\n\tpage = __alloc_pages_slowpath(alloc_mask, order, &ac);\n\nout:\n\tif (memcg_kmem_enabled() && (gfp_mask & __GFP_ACCOUNT) && page &&\n\t    unlikely(memcg_kmem_charge(page, gfp_mask, order) != 0)) {\n\t\t__free_pages(page, order);\n\t\tpage = NULL;\n\t}\n\n\ttrace_mm_page_alloc(page, order, alloc_mask, ac.migratetype);\n\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "gfp_t gfp_allowed_mask",
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\ngfp_t gfp_allowed_mask;\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstruct page *\n__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid,\n\t\t\t\t\t\t\tnodemask_t *nodemask)\n{\n\tstruct page *page;\n\tunsigned int alloc_flags = ALLOC_WMARK_LOW;\n\tgfp_t alloc_mask; /* The gfp_t that was actually used for allocation */\n\tstruct alloc_context ac = { };\n\n\t/*\n\t * There are several places where we assume that the order value is sane\n\t * so bail out early if the request is out of bound.\n\t */\n\tif (unlikely(order >= MAX_ORDER)) {\n\t\tWARN_ON_ONCE(!(gfp_mask & __GFP_NOWARN));\n\t\treturn NULL;\n\t}\n\n\tgfp_mask &= gfp_allowed_mask;\n\talloc_mask = gfp_mask;\n\tif (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &ac, &alloc_mask, &alloc_flags))\n\t\treturn NULL;\n\n\tfinalise_ac(gfp_mask, &ac);\n\n\t/* First allocation attempt */\n\tpage = get_page_from_freelist(alloc_mask, order, alloc_flags, &ac);\n\tif (likely(page))\n\t\tgoto out;\n\n\t/*\n\t * Apply scoped allocation constraints. This is mainly about GFP_NOFS\n\t * resp. GFP_NOIO which has to be inherited for all allocation requests\n\t * from a particular context which has been marked by\n\t * memalloc_no{fs,io}_{save,restore}.\n\t */\n\talloc_mask = current_gfp_context(gfp_mask);\n\tac.spread_dirty_pages = false;\n\n\t/*\n\t * Restore the original nodemask if it was potentially replaced with\n\t * &cpuset_current_mems_allowed to optimize the fast-path attempt.\n\t */\n\tif (unlikely(ac.nodemask != nodemask))\n\t\tac.nodemask = nodemask;\n\n\tpage = __alloc_pages_slowpath(alloc_mask, order, &ac);\n\nout:\n\tif (memcg_kmem_enabled() && (gfp_mask & __GFP_ACCOUNT) && page &&\n\t    unlikely(memcg_kmem_charge(page, gfp_mask, order) != 0)) {\n\t\t__free_pages(page, order);\n\t\tpage = NULL;\n\t}\n\n\ttrace_mm_page_alloc(page, order, alloc_mask, ac.migratetype);\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "policy_nodemask",
          "args": [
            "gfp",
            "pol"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "mempolicy_nodemask_intersects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1947-1979",
          "snippet": "bool mempolicy_nodemask_intersects(struct task_struct *tsk,\n\t\t\t\t\tconst nodemask_t *mask)\n{\n\tstruct mempolicy *mempolicy;\n\tbool ret = true;\n\n\tif (!mask)\n\t\treturn ret;\n\ttask_lock(tsk);\n\tmempolicy = tsk->mempolicy;\n\tif (!mempolicy)\n\t\tgoto out;\n\n\tswitch (mempolicy->mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * MPOL_PREFERRED and MPOL_F_LOCAL are only preferred nodes to\n\t\t * allocate from, they may fallback to other nodes when oom.\n\t\t * Thus, it's possible for tsk to have allocated memory from\n\t\t * nodes in mask.\n\t\t */\n\t\tbreak;\n\tcase MPOL_BIND:\n\tcase MPOL_INTERLEAVE:\n\t\tret = nodes_intersects(mempolicy->v.nodes, *mask);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\nout:\n\ttask_unlock(tsk);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nbool mempolicy_nodemask_intersects(struct task_struct *tsk,\n\t\t\t\t\tconst nodemask_t *mask)\n{\n\tstruct mempolicy *mempolicy;\n\tbool ret = true;\n\n\tif (!mask)\n\t\treturn ret;\n\ttask_lock(tsk);\n\tmempolicy = tsk->mempolicy;\n\tif (!mempolicy)\n\t\tgoto out;\n\n\tswitch (mempolicy->mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * MPOL_PREFERRED and MPOL_F_LOCAL are only preferred nodes to\n\t\t * allocate from, they may fallback to other nodes when oom.\n\t\t * Thus, it's possible for tsk to have allocated memory from\n\t\t * nodes in mask.\n\t\t */\n\t\tbreak;\n\tcase MPOL_BIND:\n\tcase MPOL_INTERLEAVE:\n\t\tret = nodes_intersects(mempolicy->v.nodes, *mask);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\nout:\n\ttask_unlock(tsk);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "policy_node",
          "args": [
            "gfp",
            "pol",
            "numa_node_id()"
          ],
          "line": 2081
        },
        "resolved": true,
        "details": {
          "function_name": "policy_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1734-1749",
          "snippet": "static int policy_node(gfp_t gfp, struct mempolicy *policy,\n\t\t\t\t\t\t\t\tint nd)\n{\n\tif (policy->mode == MPOL_PREFERRED && !(policy->flags & MPOL_F_LOCAL))\n\t\tnd = policy->v.preferred_node;\n\telse {\n\t\t/*\n\t\t * __GFP_THISNODE shouldn't even be used with the bind policy\n\t\t * because we might easily break the expectation to stay on the\n\t\t * requested node and not break the policy.\n\t\t */\n\t\tWARN_ON_ONCE(policy->mode == MPOL_BIND && (gfp & __GFP_THISNODE));\n\t}\n\n\treturn nd;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic int policy_node(gfp_t gfp, struct mempolicy *policy,\n\t\t\t\t\t\t\t\tint nd)\n{\n\tif (policy->mode == MPOL_PREFERRED && !(policy->flags & MPOL_F_LOCAL))\n\t\tnd = policy->v.preferred_node;\n\telse {\n\t\t/*\n\t\t * __GFP_THISNODE shouldn't even be used with the bind policy\n\t\t * because we might easily break the expectation to stay on the\n\t\t * requested node and not break the policy.\n\t\t */\n\t\tWARN_ON_ONCE(policy->mode == MPOL_BIND && (gfp & __GFP_THISNODE));\n\t}\n\n\treturn nd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "numa_node_id",
          "args": [],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page_interleave",
          "args": [
            "gfp",
            "order",
            "interleave_nodes(pol)"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_page_interleave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1983-1998",
          "snippet": "static struct page *alloc_page_interleave(gfp_t gfp, unsigned order,\n\t\t\t\t\tunsigned nid)\n{\n\tstruct page *page;\n\n\tpage = __alloc_pages(gfp, order, nid);\n\t/* skip NUMA_INTERLEAVE_HIT counter update if numa stats is disabled */\n\tif (!static_branch_likely(&vm_numa_stat_key))\n\t\treturn page;\n\tif (page && page_to_nid(page) == nid) {\n\t\tpreempt_disable();\n\t\t__inc_numa_state(page_zone(page), NUMA_INTERLEAVE_HIT);\n\t\tpreempt_enable();\n\t}\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct page *alloc_page_interleave(gfp_t gfp, unsigned order,\n\t\t\t\t\tunsigned nid)\n{\n\tstruct page *page;\n\n\tpage = __alloc_pages(gfp, order, nid);\n\t/* skip NUMA_INTERLEAVE_HIT counter update if numa stats is disabled */\n\tif (!static_branch_likely(&vm_numa_stat_key))\n\t\treturn page;\n\tif (page && page_to_nid(page) == nid) {\n\t\tpreempt_disable();\n\t\t__inc_numa_state(page_zone(page), NUMA_INTERLEAVE_HIT);\n\t\tpreempt_enable();\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "interleave_nodes",
          "args": [
            "pol"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "interleave_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1752-1761",
          "snippet": "static unsigned interleave_nodes(struct mempolicy *policy)\n{\n\tunsigned next;\n\tstruct task_struct *me = current;\n\n\tnext = next_node_in(me->il_prev, policy->v.nodes);\n\tif (next < MAX_NUMNODES)\n\t\tme->il_prev = next;\n\treturn next;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic unsigned interleave_nodes(struct mempolicy *policy)\n{\n\tunsigned next;\n\tstruct task_struct *me = current;\n\n\tnext = next_node_in(me->il_prev, policy->v.nodes);\n\tif (next < MAX_NUMNODES)\n\t\tme->il_prev = next;\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_policy",
          "args": [
            "current"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "get_task_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "130-147",
          "snippet": "struct mempolicy *get_task_policy(struct task_struct *p)\n{\n\tstruct mempolicy *pol = p->mempolicy;\n\tint node;\n\n\tif (pol)\n\t\treturn pol;\n\n\tnode = numa_node_id();\n\tif (node != NUMA_NO_NODE) {\n\t\tpol = &preferred_node_policy[node];\n\t\t/* preferred_node_policy is not initialised early in boot */\n\t\tif (pol->mode)\n\t\t\treturn pol;\n\t}\n\n\treturn &default_policy;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct mempolicy default_policy = {\n\t.refcnt = ATOMIC_INIT(1), /* never free it */\n\t.mode = MPOL_PREFERRED,\n\t.flags = MPOL_F_LOCAL,\n};",
            "static struct mempolicy preferred_node_policy[MAX_NUMNODES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct mempolicy default_policy = {\n\t.refcnt = ATOMIC_INIT(1), /* never free it */\n\t.mode = MPOL_PREFERRED,\n\t.flags = MPOL_F_LOCAL,\n};\nstatic struct mempolicy preferred_node_policy[MAX_NUMNODES];\n\nstruct mempolicy *get_task_policy(struct task_struct *p)\n{\n\tstruct mempolicy *pol = p->mempolicy;\n\tint node;\n\n\tif (pol)\n\t\treturn pol;\n\n\tnode = numa_node_id();\n\tif (node != NUMA_NO_NODE) {\n\t\tpol = &preferred_node_policy[node];\n\t\t/* preferred_node_policy is not initialised early in boot */\n\t\tif (pol->mode)\n\t\t\treturn pol;\n\t}\n\n\treturn &default_policy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct mempolicy default_policy = {\n\t.refcnt = ATOMIC_INIT(1), /* never free it */\n\t.mode = MPOL_PREFERRED,\n\t.flags = MPOL_F_LOCAL,\n};\n\nstruct page *alloc_pages_current(gfp_t gfp, unsigned order)\n{\n\tstruct mempolicy *pol = &default_policy;\n\tstruct page *page;\n\n\tif (!in_interrupt() && !(gfp & __GFP_THISNODE))\n\t\tpol = get_task_policy(current);\n\n\t/*\n\t * No reference counting needed for current->mempolicy\n\t * nor system default_policy\n\t */\n\tif (pol->mode == MPOL_INTERLEAVE)\n\t\tpage = alloc_page_interleave(gfp, order, interleave_nodes(pol));\n\telse\n\t\tpage = __alloc_pages_nodemask(gfp, order,\n\t\t\t\tpolicy_node(gfp, pol, numa_node_id()),\n\t\t\t\tpolicy_nodemask(gfp, pol));\n\n\treturn page;\n}"
  },
  {
    "function_name": "alloc_pages_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "2022-2048",
    "snippet": "struct page *\nalloc_pages_vma(gfp_t gfp, int order, struct vm_area_struct *vma,\n\t\tunsigned long addr, int node)\n{\n\tstruct mempolicy *pol;\n\tstruct page *page;\n\tint preferred_nid;\n\tnodemask_t *nmask;\n\n\tpol = get_vma_policy(vma, addr);\n\n\tif (pol->mode == MPOL_INTERLEAVE) {\n\t\tunsigned nid;\n\n\t\tnid = interleave_nid(pol, vma, addr, PAGE_SHIFT + order);\n\t\tmpol_cond_put(pol);\n\t\tpage = alloc_page_interleave(gfp, order, nid);\n\t\tgoto out;\n\t}\n\n\tnmask = policy_nodemask(gfp, pol);\n\tpreferred_nid = policy_node(gfp, pol, node);\n\tpage = __alloc_pages_nodemask(gfp, order, preferred_nid, nmask);\n\tmpol_cond_put(pol);\nout:\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpol_cond_put",
          "args": [
            "pol"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__alloc_pages_nodemask",
          "args": [
            "gfp",
            "order",
            "preferred_nid",
            "nmask"
          ],
          "line": 2044
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_pages_nodemask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4347-4405",
          "snippet": "struct page *\n__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid,\n\t\t\t\t\t\t\tnodemask_t *nodemask)\n{\n\tstruct page *page;\n\tunsigned int alloc_flags = ALLOC_WMARK_LOW;\n\tgfp_t alloc_mask; /* The gfp_t that was actually used for allocation */\n\tstruct alloc_context ac = { };\n\n\t/*\n\t * There are several places where we assume that the order value is sane\n\t * so bail out early if the request is out of bound.\n\t */\n\tif (unlikely(order >= MAX_ORDER)) {\n\t\tWARN_ON_ONCE(!(gfp_mask & __GFP_NOWARN));\n\t\treturn NULL;\n\t}\n\n\tgfp_mask &= gfp_allowed_mask;\n\talloc_mask = gfp_mask;\n\tif (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &ac, &alloc_mask, &alloc_flags))\n\t\treturn NULL;\n\n\tfinalise_ac(gfp_mask, &ac);\n\n\t/* First allocation attempt */\n\tpage = get_page_from_freelist(alloc_mask, order, alloc_flags, &ac);\n\tif (likely(page))\n\t\tgoto out;\n\n\t/*\n\t * Apply scoped allocation constraints. This is mainly about GFP_NOFS\n\t * resp. GFP_NOIO which has to be inherited for all allocation requests\n\t * from a particular context which has been marked by\n\t * memalloc_no{fs,io}_{save,restore}.\n\t */\n\talloc_mask = current_gfp_context(gfp_mask);\n\tac.spread_dirty_pages = false;\n\n\t/*\n\t * Restore the original nodemask if it was potentially replaced with\n\t * &cpuset_current_mems_allowed to optimize the fast-path attempt.\n\t */\n\tif (unlikely(ac.nodemask != nodemask))\n\t\tac.nodemask = nodemask;\n\n\tpage = __alloc_pages_slowpath(alloc_mask, order, &ac);\n\nout:\n\tif (memcg_kmem_enabled() && (gfp_mask & __GFP_ACCOUNT) && page &&\n\t    unlikely(memcg_kmem_charge(page, gfp_mask, order) != 0)) {\n\t\t__free_pages(page, order);\n\t\tpage = NULL;\n\t}\n\n\ttrace_mm_page_alloc(page, order, alloc_mask, ac.migratetype);\n\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "gfp_t gfp_allowed_mask",
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\ngfp_t gfp_allowed_mask;\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstruct page *\n__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid,\n\t\t\t\t\t\t\tnodemask_t *nodemask)\n{\n\tstruct page *page;\n\tunsigned int alloc_flags = ALLOC_WMARK_LOW;\n\tgfp_t alloc_mask; /* The gfp_t that was actually used for allocation */\n\tstruct alloc_context ac = { };\n\n\t/*\n\t * There are several places where we assume that the order value is sane\n\t * so bail out early if the request is out of bound.\n\t */\n\tif (unlikely(order >= MAX_ORDER)) {\n\t\tWARN_ON_ONCE(!(gfp_mask & __GFP_NOWARN));\n\t\treturn NULL;\n\t}\n\n\tgfp_mask &= gfp_allowed_mask;\n\talloc_mask = gfp_mask;\n\tif (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &ac, &alloc_mask, &alloc_flags))\n\t\treturn NULL;\n\n\tfinalise_ac(gfp_mask, &ac);\n\n\t/* First allocation attempt */\n\tpage = get_page_from_freelist(alloc_mask, order, alloc_flags, &ac);\n\tif (likely(page))\n\t\tgoto out;\n\n\t/*\n\t * Apply scoped allocation constraints. This is mainly about GFP_NOFS\n\t * resp. GFP_NOIO which has to be inherited for all allocation requests\n\t * from a particular context which has been marked by\n\t * memalloc_no{fs,io}_{save,restore}.\n\t */\n\talloc_mask = current_gfp_context(gfp_mask);\n\tac.spread_dirty_pages = false;\n\n\t/*\n\t * Restore the original nodemask if it was potentially replaced with\n\t * &cpuset_current_mems_allowed to optimize the fast-path attempt.\n\t */\n\tif (unlikely(ac.nodemask != nodemask))\n\t\tac.nodemask = nodemask;\n\n\tpage = __alloc_pages_slowpath(alloc_mask, order, &ac);\n\nout:\n\tif (memcg_kmem_enabled() && (gfp_mask & __GFP_ACCOUNT) && page &&\n\t    unlikely(memcg_kmem_charge(page, gfp_mask, order) != 0)) {\n\t\t__free_pages(page, order);\n\t\tpage = NULL;\n\t}\n\n\ttrace_mm_page_alloc(page, order, alloc_mask, ac.migratetype);\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "policy_node",
          "args": [
            "gfp",
            "pol",
            "node"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "policy_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1734-1749",
          "snippet": "static int policy_node(gfp_t gfp, struct mempolicy *policy,\n\t\t\t\t\t\t\t\tint nd)\n{\n\tif (policy->mode == MPOL_PREFERRED && !(policy->flags & MPOL_F_LOCAL))\n\t\tnd = policy->v.preferred_node;\n\telse {\n\t\t/*\n\t\t * __GFP_THISNODE shouldn't even be used with the bind policy\n\t\t * because we might easily break the expectation to stay on the\n\t\t * requested node and not break the policy.\n\t\t */\n\t\tWARN_ON_ONCE(policy->mode == MPOL_BIND && (gfp & __GFP_THISNODE));\n\t}\n\n\treturn nd;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic int policy_node(gfp_t gfp, struct mempolicy *policy,\n\t\t\t\t\t\t\t\tint nd)\n{\n\tif (policy->mode == MPOL_PREFERRED && !(policy->flags & MPOL_F_LOCAL))\n\t\tnd = policy->v.preferred_node;\n\telse {\n\t\t/*\n\t\t * __GFP_THISNODE shouldn't even be used with the bind policy\n\t\t * because we might easily break the expectation to stay on the\n\t\t * requested node and not break the policy.\n\t\t */\n\t\tWARN_ON_ONCE(policy->mode == MPOL_BIND && (gfp & __GFP_THISNODE));\n\t}\n\n\treturn nd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "policy_nodemask",
          "args": [
            "gfp",
            "pol"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "mempolicy_nodemask_intersects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1947-1979",
          "snippet": "bool mempolicy_nodemask_intersects(struct task_struct *tsk,\n\t\t\t\t\tconst nodemask_t *mask)\n{\n\tstruct mempolicy *mempolicy;\n\tbool ret = true;\n\n\tif (!mask)\n\t\treturn ret;\n\ttask_lock(tsk);\n\tmempolicy = tsk->mempolicy;\n\tif (!mempolicy)\n\t\tgoto out;\n\n\tswitch (mempolicy->mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * MPOL_PREFERRED and MPOL_F_LOCAL are only preferred nodes to\n\t\t * allocate from, they may fallback to other nodes when oom.\n\t\t * Thus, it's possible for tsk to have allocated memory from\n\t\t * nodes in mask.\n\t\t */\n\t\tbreak;\n\tcase MPOL_BIND:\n\tcase MPOL_INTERLEAVE:\n\t\tret = nodes_intersects(mempolicy->v.nodes, *mask);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\nout:\n\ttask_unlock(tsk);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nbool mempolicy_nodemask_intersects(struct task_struct *tsk,\n\t\t\t\t\tconst nodemask_t *mask)\n{\n\tstruct mempolicy *mempolicy;\n\tbool ret = true;\n\n\tif (!mask)\n\t\treturn ret;\n\ttask_lock(tsk);\n\tmempolicy = tsk->mempolicy;\n\tif (!mempolicy)\n\t\tgoto out;\n\n\tswitch (mempolicy->mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * MPOL_PREFERRED and MPOL_F_LOCAL are only preferred nodes to\n\t\t * allocate from, they may fallback to other nodes when oom.\n\t\t * Thus, it's possible for tsk to have allocated memory from\n\t\t * nodes in mask.\n\t\t */\n\t\tbreak;\n\tcase MPOL_BIND:\n\tcase MPOL_INTERLEAVE:\n\t\tret = nodes_intersects(mempolicy->v.nodes, *mask);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\nout:\n\ttask_unlock(tsk);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page_interleave",
          "args": [
            "gfp",
            "order",
            "nid"
          ],
          "line": 2038
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_page_interleave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1983-1998",
          "snippet": "static struct page *alloc_page_interleave(gfp_t gfp, unsigned order,\n\t\t\t\t\tunsigned nid)\n{\n\tstruct page *page;\n\n\tpage = __alloc_pages(gfp, order, nid);\n\t/* skip NUMA_INTERLEAVE_HIT counter update if numa stats is disabled */\n\tif (!static_branch_likely(&vm_numa_stat_key))\n\t\treturn page;\n\tif (page && page_to_nid(page) == nid) {\n\t\tpreempt_disable();\n\t\t__inc_numa_state(page_zone(page), NUMA_INTERLEAVE_HIT);\n\t\tpreempt_enable();\n\t}\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct page *alloc_page_interleave(gfp_t gfp, unsigned order,\n\t\t\t\t\tunsigned nid)\n{\n\tstruct page *page;\n\n\tpage = __alloc_pages(gfp, order, nid);\n\t/* skip NUMA_INTERLEAVE_HIT counter update if numa stats is disabled */\n\tif (!static_branch_likely(&vm_numa_stat_key))\n\t\treturn page;\n\tif (page && page_to_nid(page) == nid) {\n\t\tpreempt_disable();\n\t\t__inc_numa_state(page_zone(page), NUMA_INTERLEAVE_HIT);\n\t\tpreempt_enable();\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mpol_cond_put",
          "args": [
            "pol"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interleave_nid",
          "args": [
            "pol",
            "vma",
            "addr",
            "PAGE_SHIFT + order"
          ],
          "line": 2036
        },
        "resolved": true,
        "details": {
          "function_name": "interleave_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1831-1850",
          "snippet": "static inline unsigned interleave_nid(struct mempolicy *pol,\n\t\t struct vm_area_struct *vma, unsigned long addr, int shift)\n{\n\tif (vma) {\n\t\tunsigned long off;\n\n\t\t/*\n\t\t * for small pages, there is no difference between\n\t\t * shift and PAGE_SHIFT, so the bit-shift is safe.\n\t\t * for huge pages, since vm_pgoff is in units of small\n\t\t * pages, we need to shift off the always 0 bits to get\n\t\t * a useful offset.\n\t\t */\n\t\tBUG_ON(shift < PAGE_SHIFT);\n\t\toff = vma->vm_pgoff >> (shift - PAGE_SHIFT);\n\t\toff += (addr - vma->vm_start) >> shift;\n\t\treturn offset_il_node(pol, off);\n\t} else\n\t\treturn interleave_nodes(pol);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic inline unsigned interleave_nid(struct mempolicy *pol,\n\t\t struct vm_area_struct *vma, unsigned long addr, int shift)\n{\n\tif (vma) {\n\t\tunsigned long off;\n\n\t\t/*\n\t\t * for small pages, there is no difference between\n\t\t * shift and PAGE_SHIFT, so the bit-shift is safe.\n\t\t * for huge pages, since vm_pgoff is in units of small\n\t\t * pages, we need to shift off the always 0 bits to get\n\t\t * a useful offset.\n\t\t */\n\t\tBUG_ON(shift < PAGE_SHIFT);\n\t\toff = vma->vm_pgoff >> (shift - PAGE_SHIFT);\n\t\toff += (addr - vma->vm_start) >> shift;\n\t\treturn offset_il_node(pol, off);\n\t} else\n\t\treturn interleave_nodes(pol);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vma_policy",
          "args": [
            "vma",
            "addr"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "get_vma_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1665-1674",
          "snippet": "struct mempolicy *get_vma_policy(struct vm_area_struct *vma,\n\t\t\t\t\t\tunsigned long addr)\n{\n\tstruct mempolicy *pol = __get_vma_policy(vma, addr);\n\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstruct mempolicy *get_vma_policy(struct vm_area_struct *vma,\n\t\t\t\t\t\tunsigned long addr)\n{\n\tstruct mempolicy *pol = __get_vma_policy(vma, addr);\n\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstruct page *\nalloc_pages_vma(gfp_t gfp, int order, struct vm_area_struct *vma,\n\t\tunsigned long addr, int node)\n{\n\tstruct mempolicy *pol;\n\tstruct page *page;\n\tint preferred_nid;\n\tnodemask_t *nmask;\n\n\tpol = get_vma_policy(vma, addr);\n\n\tif (pol->mode == MPOL_INTERLEAVE) {\n\t\tunsigned nid;\n\n\t\tnid = interleave_nid(pol, vma, addr, PAGE_SHIFT + order);\n\t\tmpol_cond_put(pol);\n\t\tpage = alloc_page_interleave(gfp, order, nid);\n\t\tgoto out;\n\t}\n\n\tnmask = policy_nodemask(gfp, pol);\n\tpreferred_nid = policy_node(gfp, pol, node);\n\tpage = __alloc_pages_nodemask(gfp, order, preferred_nid, nmask);\n\tmpol_cond_put(pol);\nout:\n\treturn page;\n}"
  },
  {
    "function_name": "alloc_page_interleave",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1983-1998",
    "snippet": "static struct page *alloc_page_interleave(gfp_t gfp, unsigned order,\n\t\t\t\t\tunsigned nid)\n{\n\tstruct page *page;\n\n\tpage = __alloc_pages(gfp, order, nid);\n\t/* skip NUMA_INTERLEAVE_HIT counter update if numa stats is disabled */\n\tif (!static_branch_likely(&vm_numa_stat_key))\n\t\treturn page;\n\tif (page && page_to_nid(page) == nid) {\n\t\tpreempt_disable();\n\t\t__inc_numa_state(page_zone(page), NUMA_INTERLEAVE_HIT);\n\t\tpreempt_enable();\n\t}\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__inc_numa_state",
          "args": [
            "page_zone(page)",
            "NUMA_INTERLEAVE_HIT"
          ],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "__inc_numa_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "938-951",
          "snippet": "void __inc_numa_state(struct zone *zone,\n\t\t\t\t enum numa_stat_item item)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\tu16 __percpu *p = pcp->vm_numa_stat_diff + item;\n\tu16 v;\n\n\tv = __this_cpu_inc_return(*p);\n\n\tif (unlikely(v > NUMA_STATS_THRESHOLD)) {\n\t\tzone_numa_state_add(v, zone, item);\n\t\t__this_cpu_write(*p, 0);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define NUMA_STATS_THRESHOLD (U16_MAX - 2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\n#define NUMA_STATS_THRESHOLD (U16_MAX - 2)\n\nvoid __inc_numa_state(struct zone *zone,\n\t\t\t\t enum numa_stat_item item)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\tu16 __percpu *p = pcp->vm_numa_stat_diff + item;\n\tu16 v;\n\n\tv = __this_cpu_inc_return(*p);\n\n\tif (unlikely(v > NUMA_STATS_THRESHOLD)) {\n\t\tzone_numa_state_add(v, zone, item);\n\t\t__this_cpu_write(*p, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&vm_numa_stat_key"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__alloc_pages",
          "args": [
            "gfp",
            "order",
            "nid"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_pages_slowpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4047-4295",
          "snippet": "static inline struct page *\n__alloc_pages_slowpath(gfp_t gfp_mask, unsigned int order,\n\t\t\t\t\t\tstruct alloc_context *ac)\n{\n\tbool can_direct_reclaim = gfp_mask & __GFP_DIRECT_RECLAIM;\n\tconst bool costly_order = order > PAGE_ALLOC_COSTLY_ORDER;\n\tstruct page *page = NULL;\n\tunsigned int alloc_flags;\n\tunsigned long did_some_progress;\n\tenum compact_priority compact_priority;\n\tenum compact_result compact_result;\n\tint compaction_retries;\n\tint no_progress_loops;\n\tunsigned int cpuset_mems_cookie;\n\tint reserve_flags;\n\n\t/*\n\t * We also sanity check to catch abuse of atomic reserves being used by\n\t * callers that are not in atomic context.\n\t */\n\tif (WARN_ON_ONCE((gfp_mask & (__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)) ==\n\t\t\t\t(__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)))\n\t\tgfp_mask &= ~__GFP_ATOMIC;\n\nretry_cpuset:\n\tcompaction_retries = 0;\n\tno_progress_loops = 0;\n\tcompact_priority = DEF_COMPACT_PRIORITY;\n\tcpuset_mems_cookie = read_mems_allowed_begin();\n\n\t/*\n\t * The fast path uses conservative alloc_flags to succeed only until\n\t * kswapd needs to be woken up, and to avoid the cost of setting up\n\t * alloc_flags precisely. So we do that now.\n\t */\n\talloc_flags = gfp_to_alloc_flags(gfp_mask);\n\n\t/*\n\t * We need to recalculate the starting point for the zonelist iterator\n\t * because we might have used different nodemask in the fast path, or\n\t * there was a cpuset modification and we are retrying - otherwise we\n\t * could end up iterating over non-eligible zones endlessly.\n\t */\n\tac->preferred_zoneref = first_zones_zonelist(ac->zonelist,\n\t\t\t\t\tac->high_zoneidx, ac->nodemask);\n\tif (!ac->preferred_zoneref->zone)\n\t\tgoto nopage;\n\n\tif (gfp_mask & __GFP_KSWAPD_RECLAIM)\n\t\twake_all_kswapds(order, gfp_mask, ac);\n\n\t/*\n\t * The adjusted alloc_flags might result in immediate success, so try\n\t * that first\n\t */\n\tpage = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/*\n\t * For costly allocations, try direct compaction first, as it's likely\n\t * that we have enough base pages and don't need to reclaim. For non-\n\t * movable high-order allocations, do that as well, as compaction will\n\t * try prevent permanent fragmentation by migrating from blocks of the\n\t * same migratetype.\n\t * Don't try this for allocations that are allowed to ignore\n\t * watermarks, as the ALLOC_NO_WATERMARKS attempt didn't yet happen.\n\t */\n\tif (can_direct_reclaim &&\n\t\t\t(costly_order ||\n\t\t\t   (order > 0 && ac->migratetype != MIGRATE_MOVABLE))\n\t\t\t&& !gfp_pfmemalloc_allowed(gfp_mask)) {\n\t\tpage = __alloc_pages_direct_compact(gfp_mask, order,\n\t\t\t\t\t\talloc_flags, ac,\n\t\t\t\t\t\tINIT_COMPACT_PRIORITY,\n\t\t\t\t\t\t&compact_result);\n\t\tif (page)\n\t\t\tgoto got_pg;\n\n\t\t/*\n\t\t * Checks for costly allocations with __GFP_NORETRY, which\n\t\t * includes THP page fault allocations\n\t\t */\n\t\tif (costly_order && (gfp_mask & __GFP_NORETRY)) {\n\t\t\t/*\n\t\t\t * If compaction is deferred for high-order allocations,\n\t\t\t * it is because sync compaction recently failed. If\n\t\t\t * this is the case and the caller requested a THP\n\t\t\t * allocation, we do not want to heavily disrupt the\n\t\t\t * system, so we fail the allocation instead of entering\n\t\t\t * direct reclaim.\n\t\t\t */\n\t\t\tif (compact_result == COMPACT_DEFERRED)\n\t\t\t\tgoto nopage;\n\n\t\t\t/*\n\t\t\t * Looks like reclaim/compaction is worth trying, but\n\t\t\t * sync compaction could be very expensive, so keep\n\t\t\t * using async compaction.\n\t\t\t */\n\t\t\tcompact_priority = INIT_COMPACT_PRIORITY;\n\t\t}\n\t}\n\nretry:\n\t/* Ensure kswapd doesn't accidentally go to sleep as long as we loop */\n\tif (gfp_mask & __GFP_KSWAPD_RECLAIM)\n\t\twake_all_kswapds(order, gfp_mask, ac);\n\n\treserve_flags = __gfp_pfmemalloc_flags(gfp_mask);\n\tif (reserve_flags)\n\t\talloc_flags = reserve_flags;\n\n\t/*\n\t * Reset the nodemask and zonelist iterators if memory policies can be\n\t * ignored. These allocations are high priority and system rather than\n\t * user oriented.\n\t */\n\tif (!(alloc_flags & ALLOC_CPUSET) || reserve_flags) {\n\t\tac->nodemask = NULL;\n\t\tac->preferred_zoneref = first_zones_zonelist(ac->zonelist,\n\t\t\t\t\tac->high_zoneidx, ac->nodemask);\n\t}\n\n\t/* Attempt with potentially adjusted zonelist and alloc_flags */\n\tpage = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/* Caller is not willing to reclaim, we can't balance anything */\n\tif (!can_direct_reclaim)\n\t\tgoto nopage;\n\n\t/* Avoid recursion of direct reclaim */\n\tif (current->flags & PF_MEMALLOC)\n\t\tgoto nopage;\n\n\t/* Try direct reclaim and then allocating */\n\tpage = __alloc_pages_direct_reclaim(gfp_mask, order, alloc_flags, ac,\n\t\t\t\t\t\t\t&did_some_progress);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/* Try direct compaction and then allocating */\n\tpage = __alloc_pages_direct_compact(gfp_mask, order, alloc_flags, ac,\n\t\t\t\t\tcompact_priority, &compact_result);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/* Do not loop if specifically requested */\n\tif (gfp_mask & __GFP_NORETRY)\n\t\tgoto nopage;\n\n\t/*\n\t * Do not retry costly high order allocations unless they are\n\t * __GFP_RETRY_MAYFAIL\n\t */\n\tif (costly_order && !(gfp_mask & __GFP_RETRY_MAYFAIL))\n\t\tgoto nopage;\n\n\tif (should_reclaim_retry(gfp_mask, order, ac, alloc_flags,\n\t\t\t\t did_some_progress > 0, &no_progress_loops))\n\t\tgoto retry;\n\n\t/*\n\t * It doesn't make any sense to retry for the compaction if the order-0\n\t * reclaim is not able to make any progress because the current\n\t * implementation of the compaction depends on the sufficient amount\n\t * of free memory (see __compaction_suitable)\n\t */\n\tif (did_some_progress > 0 &&\n\t\t\tshould_compact_retry(ac, order, alloc_flags,\n\t\t\t\tcompact_result, &compact_priority,\n\t\t\t\t&compaction_retries))\n\t\tgoto retry;\n\n\n\t/* Deal with possible cpuset update races before we start OOM killing */\n\tif (check_retry_cpuset(cpuset_mems_cookie, ac))\n\t\tgoto retry_cpuset;\n\n\t/* Reclaim has failed us, start killing things */\n\tpage = __alloc_pages_may_oom(gfp_mask, order, ac, &did_some_progress);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/* Avoid allocations with no watermarks from looping endlessly */\n\tif (tsk_is_oom_victim(current) &&\n\t    (alloc_flags == ALLOC_OOM ||\n\t     (gfp_mask & __GFP_NOMEMALLOC)))\n\t\tgoto nopage;\n\n\t/* Retry as long as the OOM killer is making progress */\n\tif (did_some_progress) {\n\t\tno_progress_loops = 0;\n\t\tgoto retry;\n\t}\n\nnopage:\n\t/* Deal with possible cpuset update races before we fail */\n\tif (check_retry_cpuset(cpuset_mems_cookie, ac))\n\t\tgoto retry_cpuset;\n\n\t/*\n\t * Make sure that __GFP_NOFAIL request doesn't leak out and make sure\n\t * we always retry\n\t */\n\tif (gfp_mask & __GFP_NOFAIL) {\n\t\t/*\n\t\t * All existing users of the __GFP_NOFAIL are blockable, so warn\n\t\t * of any new users that actually require GFP_NOWAIT\n\t\t */\n\t\tif (WARN_ON_ONCE(!can_direct_reclaim))\n\t\t\tgoto fail;\n\n\t\t/*\n\t\t * PF_MEMALLOC request from this context is rather bizarre\n\t\t * because we cannot reclaim anything and only can loop waiting\n\t\t * for somebody to do a work for us\n\t\t */\n\t\tWARN_ON_ONCE(current->flags & PF_MEMALLOC);\n\n\t\t/*\n\t\t * non failing costly orders are a hard requirement which we\n\t\t * are not prepared for much so let's warn about these users\n\t\t * so that we can identify them and convert them to something\n\t\t * else.\n\t\t */\n\t\tWARN_ON_ONCE(order > PAGE_ALLOC_COSTLY_ORDER);\n\n\t\t/*\n\t\t * Help non-failing allocations by giving them access to memory\n\t\t * reserves but do not use ALLOC_NO_WATERMARKS because this\n\t\t * could deplete whole memory reserves which would just make\n\t\t * the situation worse\n\t\t */\n\t\tpage = __alloc_pages_cpuset_fallback(gfp_mask, order, ALLOC_HARDER, ac);\n\t\tif (page)\n\t\t\tgoto got_pg;\n\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\nfail:\n\twarn_alloc(gfp_mask, ac->nodemask,\n\t\t\t\"page allocation failure: order:%u\", order);\ngot_pg:\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline struct page *\n__alloc_pages_slowpath(gfp_t gfp_mask, unsigned int order,\n\t\t\t\t\t\tstruct alloc_context *ac)\n{\n\tbool can_direct_reclaim = gfp_mask & __GFP_DIRECT_RECLAIM;\n\tconst bool costly_order = order > PAGE_ALLOC_COSTLY_ORDER;\n\tstruct page *page = NULL;\n\tunsigned int alloc_flags;\n\tunsigned long did_some_progress;\n\tenum compact_priority compact_priority;\n\tenum compact_result compact_result;\n\tint compaction_retries;\n\tint no_progress_loops;\n\tunsigned int cpuset_mems_cookie;\n\tint reserve_flags;\n\n\t/*\n\t * We also sanity check to catch abuse of atomic reserves being used by\n\t * callers that are not in atomic context.\n\t */\n\tif (WARN_ON_ONCE((gfp_mask & (__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)) ==\n\t\t\t\t(__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)))\n\t\tgfp_mask &= ~__GFP_ATOMIC;\n\nretry_cpuset:\n\tcompaction_retries = 0;\n\tno_progress_loops = 0;\n\tcompact_priority = DEF_COMPACT_PRIORITY;\n\tcpuset_mems_cookie = read_mems_allowed_begin();\n\n\t/*\n\t * The fast path uses conservative alloc_flags to succeed only until\n\t * kswapd needs to be woken up, and to avoid the cost of setting up\n\t * alloc_flags precisely. So we do that now.\n\t */\n\talloc_flags = gfp_to_alloc_flags(gfp_mask);\n\n\t/*\n\t * We need to recalculate the starting point for the zonelist iterator\n\t * because we might have used different nodemask in the fast path, or\n\t * there was a cpuset modification and we are retrying - otherwise we\n\t * could end up iterating over non-eligible zones endlessly.\n\t */\n\tac->preferred_zoneref = first_zones_zonelist(ac->zonelist,\n\t\t\t\t\tac->high_zoneidx, ac->nodemask);\n\tif (!ac->preferred_zoneref->zone)\n\t\tgoto nopage;\n\n\tif (gfp_mask & __GFP_KSWAPD_RECLAIM)\n\t\twake_all_kswapds(order, gfp_mask, ac);\n\n\t/*\n\t * The adjusted alloc_flags might result in immediate success, so try\n\t * that first\n\t */\n\tpage = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/*\n\t * For costly allocations, try direct compaction first, as it's likely\n\t * that we have enough base pages and don't need to reclaim. For non-\n\t * movable high-order allocations, do that as well, as compaction will\n\t * try prevent permanent fragmentation by migrating from blocks of the\n\t * same migratetype.\n\t * Don't try this for allocations that are allowed to ignore\n\t * watermarks, as the ALLOC_NO_WATERMARKS attempt didn't yet happen.\n\t */\n\tif (can_direct_reclaim &&\n\t\t\t(costly_order ||\n\t\t\t   (order > 0 && ac->migratetype != MIGRATE_MOVABLE))\n\t\t\t&& !gfp_pfmemalloc_allowed(gfp_mask)) {\n\t\tpage = __alloc_pages_direct_compact(gfp_mask, order,\n\t\t\t\t\t\talloc_flags, ac,\n\t\t\t\t\t\tINIT_COMPACT_PRIORITY,\n\t\t\t\t\t\t&compact_result);\n\t\tif (page)\n\t\t\tgoto got_pg;\n\n\t\t/*\n\t\t * Checks for costly allocations with __GFP_NORETRY, which\n\t\t * includes THP page fault allocations\n\t\t */\n\t\tif (costly_order && (gfp_mask & __GFP_NORETRY)) {\n\t\t\t/*\n\t\t\t * If compaction is deferred for high-order allocations,\n\t\t\t * it is because sync compaction recently failed. If\n\t\t\t * this is the case and the caller requested a THP\n\t\t\t * allocation, we do not want to heavily disrupt the\n\t\t\t * system, so we fail the allocation instead of entering\n\t\t\t * direct reclaim.\n\t\t\t */\n\t\t\tif (compact_result == COMPACT_DEFERRED)\n\t\t\t\tgoto nopage;\n\n\t\t\t/*\n\t\t\t * Looks like reclaim/compaction is worth trying, but\n\t\t\t * sync compaction could be very expensive, so keep\n\t\t\t * using async compaction.\n\t\t\t */\n\t\t\tcompact_priority = INIT_COMPACT_PRIORITY;\n\t\t}\n\t}\n\nretry:\n\t/* Ensure kswapd doesn't accidentally go to sleep as long as we loop */\n\tif (gfp_mask & __GFP_KSWAPD_RECLAIM)\n\t\twake_all_kswapds(order, gfp_mask, ac);\n\n\treserve_flags = __gfp_pfmemalloc_flags(gfp_mask);\n\tif (reserve_flags)\n\t\talloc_flags = reserve_flags;\n\n\t/*\n\t * Reset the nodemask and zonelist iterators if memory policies can be\n\t * ignored. These allocations are high priority and system rather than\n\t * user oriented.\n\t */\n\tif (!(alloc_flags & ALLOC_CPUSET) || reserve_flags) {\n\t\tac->nodemask = NULL;\n\t\tac->preferred_zoneref = first_zones_zonelist(ac->zonelist,\n\t\t\t\t\tac->high_zoneidx, ac->nodemask);\n\t}\n\n\t/* Attempt with potentially adjusted zonelist and alloc_flags */\n\tpage = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/* Caller is not willing to reclaim, we can't balance anything */\n\tif (!can_direct_reclaim)\n\t\tgoto nopage;\n\n\t/* Avoid recursion of direct reclaim */\n\tif (current->flags & PF_MEMALLOC)\n\t\tgoto nopage;\n\n\t/* Try direct reclaim and then allocating */\n\tpage = __alloc_pages_direct_reclaim(gfp_mask, order, alloc_flags, ac,\n\t\t\t\t\t\t\t&did_some_progress);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/* Try direct compaction and then allocating */\n\tpage = __alloc_pages_direct_compact(gfp_mask, order, alloc_flags, ac,\n\t\t\t\t\tcompact_priority, &compact_result);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/* Do not loop if specifically requested */\n\tif (gfp_mask & __GFP_NORETRY)\n\t\tgoto nopage;\n\n\t/*\n\t * Do not retry costly high order allocations unless they are\n\t * __GFP_RETRY_MAYFAIL\n\t */\n\tif (costly_order && !(gfp_mask & __GFP_RETRY_MAYFAIL))\n\t\tgoto nopage;\n\n\tif (should_reclaim_retry(gfp_mask, order, ac, alloc_flags,\n\t\t\t\t did_some_progress > 0, &no_progress_loops))\n\t\tgoto retry;\n\n\t/*\n\t * It doesn't make any sense to retry for the compaction if the order-0\n\t * reclaim is not able to make any progress because the current\n\t * implementation of the compaction depends on the sufficient amount\n\t * of free memory (see __compaction_suitable)\n\t */\n\tif (did_some_progress > 0 &&\n\t\t\tshould_compact_retry(ac, order, alloc_flags,\n\t\t\t\tcompact_result, &compact_priority,\n\t\t\t\t&compaction_retries))\n\t\tgoto retry;\n\n\n\t/* Deal with possible cpuset update races before we start OOM killing */\n\tif (check_retry_cpuset(cpuset_mems_cookie, ac))\n\t\tgoto retry_cpuset;\n\n\t/* Reclaim has failed us, start killing things */\n\tpage = __alloc_pages_may_oom(gfp_mask, order, ac, &did_some_progress);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/* Avoid allocations with no watermarks from looping endlessly */\n\tif (tsk_is_oom_victim(current) &&\n\t    (alloc_flags == ALLOC_OOM ||\n\t     (gfp_mask & __GFP_NOMEMALLOC)))\n\t\tgoto nopage;\n\n\t/* Retry as long as the OOM killer is making progress */\n\tif (did_some_progress) {\n\t\tno_progress_loops = 0;\n\t\tgoto retry;\n\t}\n\nnopage:\n\t/* Deal with possible cpuset update races before we fail */\n\tif (check_retry_cpuset(cpuset_mems_cookie, ac))\n\t\tgoto retry_cpuset;\n\n\t/*\n\t * Make sure that __GFP_NOFAIL request doesn't leak out and make sure\n\t * we always retry\n\t */\n\tif (gfp_mask & __GFP_NOFAIL) {\n\t\t/*\n\t\t * All existing users of the __GFP_NOFAIL are blockable, so warn\n\t\t * of any new users that actually require GFP_NOWAIT\n\t\t */\n\t\tif (WARN_ON_ONCE(!can_direct_reclaim))\n\t\t\tgoto fail;\n\n\t\t/*\n\t\t * PF_MEMALLOC request from this context is rather bizarre\n\t\t * because we cannot reclaim anything and only can loop waiting\n\t\t * for somebody to do a work for us\n\t\t */\n\t\tWARN_ON_ONCE(current->flags & PF_MEMALLOC);\n\n\t\t/*\n\t\t * non failing costly orders are a hard requirement which we\n\t\t * are not prepared for much so let's warn about these users\n\t\t * so that we can identify them and convert them to something\n\t\t * else.\n\t\t */\n\t\tWARN_ON_ONCE(order > PAGE_ALLOC_COSTLY_ORDER);\n\n\t\t/*\n\t\t * Help non-failing allocations by giving them access to memory\n\t\t * reserves but do not use ALLOC_NO_WATERMARKS because this\n\t\t * could deplete whole memory reserves which would just make\n\t\t * the situation worse\n\t\t */\n\t\tpage = __alloc_pages_cpuset_fallback(gfp_mask, order, ALLOC_HARDER, ac);\n\t\tif (page)\n\t\t\tgoto got_pg;\n\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\nfail:\n\twarn_alloc(gfp_mask, ac->nodemask,\n\t\t\t\"page allocation failure: order:%u\", order);\ngot_pg:\n\treturn page;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct page *alloc_page_interleave(gfp_t gfp, unsigned order,\n\t\t\t\t\tunsigned nid)\n{\n\tstruct page *page;\n\n\tpage = __alloc_pages(gfp, order, nid);\n\t/* skip NUMA_INTERLEAVE_HIT counter update if numa stats is disabled */\n\tif (!static_branch_likely(&vm_numa_stat_key))\n\t\treturn page;\n\tif (page && page_to_nid(page) == nid) {\n\t\tpreempt_disable();\n\t\t__inc_numa_state(page_zone(page), NUMA_INTERLEAVE_HIT);\n\t\tpreempt_enable();\n\t}\n\treturn page;\n}"
  },
  {
    "function_name": "mempolicy_nodemask_intersects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1947-1979",
    "snippet": "bool mempolicy_nodemask_intersects(struct task_struct *tsk,\n\t\t\t\t\tconst nodemask_t *mask)\n{\n\tstruct mempolicy *mempolicy;\n\tbool ret = true;\n\n\tif (!mask)\n\t\treturn ret;\n\ttask_lock(tsk);\n\tmempolicy = tsk->mempolicy;\n\tif (!mempolicy)\n\t\tgoto out;\n\n\tswitch (mempolicy->mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * MPOL_PREFERRED and MPOL_F_LOCAL are only preferred nodes to\n\t\t * allocate from, they may fallback to other nodes when oom.\n\t\t * Thus, it's possible for tsk to have allocated memory from\n\t\t * nodes in mask.\n\t\t */\n\t\tbreak;\n\tcase MPOL_BIND:\n\tcase MPOL_INTERLEAVE:\n\t\tret = nodes_intersects(mempolicy->v.nodes, *mask);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\nout:\n\ttask_unlock(tsk);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "tsk"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_intersects",
          "args": [
            "mempolicy->v.nodes",
            "*mask"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "tsk"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nbool mempolicy_nodemask_intersects(struct task_struct *tsk,\n\t\t\t\t\tconst nodemask_t *mask)\n{\n\tstruct mempolicy *mempolicy;\n\tbool ret = true;\n\n\tif (!mask)\n\t\treturn ret;\n\ttask_lock(tsk);\n\tmempolicy = tsk->mempolicy;\n\tif (!mempolicy)\n\t\tgoto out;\n\n\tswitch (mempolicy->mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * MPOL_PREFERRED and MPOL_F_LOCAL are only preferred nodes to\n\t\t * allocate from, they may fallback to other nodes when oom.\n\t\t * Thus, it's possible for tsk to have allocated memory from\n\t\t * nodes in mask.\n\t\t */\n\t\tbreak;\n\tcase MPOL_BIND:\n\tcase MPOL_INTERLEAVE:\n\t\tret = nodes_intersects(mempolicy->v.nodes, *mask);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\nout:\n\ttask_unlock(tsk);\n\treturn ret;\n}"
  },
  {
    "function_name": "init_nodemask_of_mempolicy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1903-1934",
    "snippet": "bool init_nodemask_of_mempolicy(nodemask_t *mask)\n{\n\tstruct mempolicy *mempolicy;\n\tint nid;\n\n\tif (!(mask && current->mempolicy))\n\t\treturn false;\n\n\ttask_lock(current);\n\tmempolicy = current->mempolicy;\n\tswitch (mempolicy->mode) {\n\tcase MPOL_PREFERRED:\n\t\tif (mempolicy->flags & MPOL_F_LOCAL)\n\t\t\tnid = numa_node_id();\n\t\telse\n\t\t\tnid = mempolicy->v.preferred_node;\n\t\tinit_nodemask_of_node(mask, nid);\n\t\tbreak;\n\n\tcase MPOL_BIND:\n\t\t/* Fall through */\n\tcase MPOL_INTERLEAVE:\n\t\t*mask =  mempolicy->v.nodes;\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\ttask_unlock(current);\n\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "current"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_nodemask_of_node",
          "args": [
            "mask",
            "nid"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_node_id",
          "args": [],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "current"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nbool init_nodemask_of_mempolicy(nodemask_t *mask)\n{\n\tstruct mempolicy *mempolicy;\n\tint nid;\n\n\tif (!(mask && current->mempolicy))\n\t\treturn false;\n\n\ttask_lock(current);\n\tmempolicy = current->mempolicy;\n\tswitch (mempolicy->mode) {\n\tcase MPOL_PREFERRED:\n\t\tif (mempolicy->flags & MPOL_F_LOCAL)\n\t\t\tnid = numa_node_id();\n\t\telse\n\t\t\tnid = mempolicy->v.preferred_node;\n\t\tinit_nodemask_of_node(mask, nid);\n\t\tbreak;\n\n\tcase MPOL_BIND:\n\t\t/* Fall through */\n\tcase MPOL_INTERLEAVE:\n\t\t*mask =  mempolicy->v.nodes;\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\ttask_unlock(current);\n\n\treturn true;\n}"
  },
  {
    "function_name": "huge_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1868-1885",
    "snippet": "int huge_node(struct vm_area_struct *vma, unsigned long addr, gfp_t gfp_flags,\n\t\t\t\tstruct mempolicy **mpol, nodemask_t **nodemask)\n{\n\tint nid;\n\n\t*mpol = get_vma_policy(vma, addr);\n\t*nodemask = NULL;\t/* assume !MPOL_BIND */\n\n\tif (unlikely((*mpol)->mode == MPOL_INTERLEAVE)) {\n\t\tnid = interleave_nid(*mpol, vma, addr,\n\t\t\t\t\thuge_page_shift(hstate_vma(vma)));\n\t} else {\n\t\tnid = policy_node(gfp_flags, *mpol, numa_node_id());\n\t\tif ((*mpol)->mode == MPOL_BIND)\n\t\t\t*nodemask = &(*mpol)->v.nodes;\n\t}\n\treturn nid;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "policy_node",
          "args": [
            "gfp_flags",
            "*mpol",
            "numa_node_id()"
          ],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "policy_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1734-1749",
          "snippet": "static int policy_node(gfp_t gfp, struct mempolicy *policy,\n\t\t\t\t\t\t\t\tint nd)\n{\n\tif (policy->mode == MPOL_PREFERRED && !(policy->flags & MPOL_F_LOCAL))\n\t\tnd = policy->v.preferred_node;\n\telse {\n\t\t/*\n\t\t * __GFP_THISNODE shouldn't even be used with the bind policy\n\t\t * because we might easily break the expectation to stay on the\n\t\t * requested node and not break the policy.\n\t\t */\n\t\tWARN_ON_ONCE(policy->mode == MPOL_BIND && (gfp & __GFP_THISNODE));\n\t}\n\n\treturn nd;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic int policy_node(gfp_t gfp, struct mempolicy *policy,\n\t\t\t\t\t\t\t\tint nd)\n{\n\tif (policy->mode == MPOL_PREFERRED && !(policy->flags & MPOL_F_LOCAL))\n\t\tnd = policy->v.preferred_node;\n\telse {\n\t\t/*\n\t\t * __GFP_THISNODE shouldn't even be used with the bind policy\n\t\t * because we might easily break the expectation to stay on the\n\t\t * requested node and not break the policy.\n\t\t */\n\t\tWARN_ON_ONCE(policy->mode == MPOL_BIND && (gfp & __GFP_THISNODE));\n\t}\n\n\treturn nd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "numa_node_id",
          "args": [],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interleave_nid",
          "args": [
            "*mpol",
            "vma",
            "addr",
            "huge_page_shift(hstate_vma(vma))"
          ],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "interleave_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1831-1850",
          "snippet": "static inline unsigned interleave_nid(struct mempolicy *pol,\n\t\t struct vm_area_struct *vma, unsigned long addr, int shift)\n{\n\tif (vma) {\n\t\tunsigned long off;\n\n\t\t/*\n\t\t * for small pages, there is no difference between\n\t\t * shift and PAGE_SHIFT, so the bit-shift is safe.\n\t\t * for huge pages, since vm_pgoff is in units of small\n\t\t * pages, we need to shift off the always 0 bits to get\n\t\t * a useful offset.\n\t\t */\n\t\tBUG_ON(shift < PAGE_SHIFT);\n\t\toff = vma->vm_pgoff >> (shift - PAGE_SHIFT);\n\t\toff += (addr - vma->vm_start) >> shift;\n\t\treturn offset_il_node(pol, off);\n\t} else\n\t\treturn interleave_nodes(pol);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic inline unsigned interleave_nid(struct mempolicy *pol,\n\t\t struct vm_area_struct *vma, unsigned long addr, int shift)\n{\n\tif (vma) {\n\t\tunsigned long off;\n\n\t\t/*\n\t\t * for small pages, there is no difference between\n\t\t * shift and PAGE_SHIFT, so the bit-shift is safe.\n\t\t * for huge pages, since vm_pgoff is in units of small\n\t\t * pages, we need to shift off the always 0 bits to get\n\t\t * a useful offset.\n\t\t */\n\t\tBUG_ON(shift < PAGE_SHIFT);\n\t\toff = vma->vm_pgoff >> (shift - PAGE_SHIFT);\n\t\toff += (addr - vma->vm_start) >> shift;\n\t\treturn offset_il_node(pol, off);\n\t} else\n\t\treturn interleave_nodes(pol);\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_page_shift",
          "args": [
            "hstate_vma(vma)"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_vma",
          "args": [
            "vma"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(*mpol)->mode == MPOL_INTERLEAVE"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_vma_policy",
          "args": [
            "vma",
            "addr"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "get_vma_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1665-1674",
          "snippet": "struct mempolicy *get_vma_policy(struct vm_area_struct *vma,\n\t\t\t\t\t\tunsigned long addr)\n{\n\tstruct mempolicy *pol = __get_vma_policy(vma, addr);\n\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstruct mempolicy *get_vma_policy(struct vm_area_struct *vma,\n\t\t\t\t\t\tunsigned long addr)\n{\n\tstruct mempolicy *pol = __get_vma_policy(vma, addr);\n\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nint huge_node(struct vm_area_struct *vma, unsigned long addr, gfp_t gfp_flags,\n\t\t\t\tstruct mempolicy **mpol, nodemask_t **nodemask)\n{\n\tint nid;\n\n\t*mpol = get_vma_policy(vma, addr);\n\t*nodemask = NULL;\t/* assume !MPOL_BIND */\n\n\tif (unlikely((*mpol)->mode == MPOL_INTERLEAVE)) {\n\t\tnid = interleave_nid(*mpol, vma, addr,\n\t\t\t\t\thuge_page_shift(hstate_vma(vma)));\n\t} else {\n\t\tnid = policy_node(gfp_flags, *mpol, numa_node_id());\n\t\tif ((*mpol)->mode == MPOL_BIND)\n\t\t\t*nodemask = &(*mpol)->v.nodes;\n\t}\n\treturn nid;\n}"
  },
  {
    "function_name": "interleave_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1831-1850",
    "snippet": "static inline unsigned interleave_nid(struct mempolicy *pol,\n\t\t struct vm_area_struct *vma, unsigned long addr, int shift)\n{\n\tif (vma) {\n\t\tunsigned long off;\n\n\t\t/*\n\t\t * for small pages, there is no difference between\n\t\t * shift and PAGE_SHIFT, so the bit-shift is safe.\n\t\t * for huge pages, since vm_pgoff is in units of small\n\t\t * pages, we need to shift off the always 0 bits to get\n\t\t * a useful offset.\n\t\t */\n\t\tBUG_ON(shift < PAGE_SHIFT);\n\t\toff = vma->vm_pgoff >> (shift - PAGE_SHIFT);\n\t\toff += (addr - vma->vm_start) >> shift;\n\t\treturn offset_il_node(pol, off);\n\t} else\n\t\treturn interleave_nodes(pol);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "interleave_nodes",
          "args": [
            "pol"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "interleave_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1752-1761",
          "snippet": "static unsigned interleave_nodes(struct mempolicy *policy)\n{\n\tunsigned next;\n\tstruct task_struct *me = current;\n\n\tnext = next_node_in(me->il_prev, policy->v.nodes);\n\tif (next < MAX_NUMNODES)\n\t\tme->il_prev = next;\n\treturn next;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic unsigned interleave_nodes(struct mempolicy *policy)\n{\n\tunsigned next;\n\tstruct task_struct *me = current;\n\n\tnext = next_node_in(me->il_prev, policy->v.nodes);\n\tif (next < MAX_NUMNODES)\n\t\tme->il_prev = next;\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_il_node",
          "args": [
            "pol",
            "off"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "offset_il_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1814-1828",
          "snippet": "static unsigned offset_il_node(struct mempolicy *pol, unsigned long n)\n{\n\tunsigned nnodes = nodes_weight(pol->v.nodes);\n\tunsigned target;\n\tint i;\n\tint nid;\n\n\tif (!nnodes)\n\t\treturn numa_node_id();\n\ttarget = (unsigned int)n % nnodes;\n\tnid = first_node(pol->v.nodes);\n\tfor (i = 0; i < target; i++)\n\t\tnid = next_node(nid, pol->v.nodes);\n\treturn nid;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic unsigned offset_il_node(struct mempolicy *pol, unsigned long n)\n{\n\tunsigned nnodes = nodes_weight(pol->v.nodes);\n\tunsigned target;\n\tint i;\n\tint nid;\n\n\tif (!nnodes)\n\t\treturn numa_node_id();\n\ttarget = (unsigned int)n % nnodes;\n\tnid = first_node(pol->v.nodes);\n\tfor (i = 0; i < target; i++)\n\t\tnid = next_node(nid, pol->v.nodes);\n\treturn nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "shift < PAGE_SHIFT"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic inline unsigned interleave_nid(struct mempolicy *pol,\n\t\t struct vm_area_struct *vma, unsigned long addr, int shift)\n{\n\tif (vma) {\n\t\tunsigned long off;\n\n\t\t/*\n\t\t * for small pages, there is no difference between\n\t\t * shift and PAGE_SHIFT, so the bit-shift is safe.\n\t\t * for huge pages, since vm_pgoff is in units of small\n\t\t * pages, we need to shift off the always 0 bits to get\n\t\t * a useful offset.\n\t\t */\n\t\tBUG_ON(shift < PAGE_SHIFT);\n\t\toff = vma->vm_pgoff >> (shift - PAGE_SHIFT);\n\t\toff += (addr - vma->vm_start) >> shift;\n\t\treturn offset_il_node(pol, off);\n\t} else\n\t\treturn interleave_nodes(pol);\n}"
  },
  {
    "function_name": "offset_il_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1814-1828",
    "snippet": "static unsigned offset_il_node(struct mempolicy *pol, unsigned long n)\n{\n\tunsigned nnodes = nodes_weight(pol->v.nodes);\n\tunsigned target;\n\tint i;\n\tint nid;\n\n\tif (!nnodes)\n\t\treturn numa_node_id();\n\ttarget = (unsigned int)n % nnodes;\n\tnid = first_node(pol->v.nodes);\n\tfor (i = 0; i < target; i++)\n\t\tnid = next_node(nid, pol->v.nodes);\n\treturn nid;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next_node",
          "args": [
            "nid",
            "pol->v.nodes"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "hstate_next_node_to_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1014-1024",
          "snippet": "static int hstate_next_node_to_free(struct hstate *h, nodemask_t *nodes_allowed)\n{\n\tint nid;\n\n\tVM_BUG_ON(!nodes_allowed);\n\n\tnid = get_valid_node_allowed(h->next_nid_to_free, nodes_allowed);\n\th->next_nid_to_free = next_node_allowed(nid, nodes_allowed);\n\n\treturn nid;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic int hstate_next_node_to_free(struct hstate *h, nodemask_t *nodes_allowed)\n{\n\tint nid;\n\n\tVM_BUG_ON(!nodes_allowed);\n\n\tnid = get_valid_node_allowed(h->next_nid_to_free, nodes_allowed);\n\th->next_nid_to_free = next_node_allowed(nid, nodes_allowed);\n\n\treturn nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "first_node",
          "args": [
            "pol->v.nodes"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_node_id",
          "args": [],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_weight",
          "args": [
            "pol->v.nodes"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic unsigned offset_il_node(struct mempolicy *pol, unsigned long n)\n{\n\tunsigned nnodes = nodes_weight(pol->v.nodes);\n\tunsigned target;\n\tint i;\n\tint nid;\n\n\tif (!nnodes)\n\t\treturn numa_node_id();\n\ttarget = (unsigned int)n % nnodes;\n\tnid = first_node(pol->v.nodes);\n\tfor (i = 0; i < target; i++)\n\t\tnid = next_node(nid, pol->v.nodes);\n\treturn nid;\n}"
  },
  {
    "function_name": "mempolicy_slab_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1767-1807",
    "snippet": "unsigned int mempolicy_slab_node(void)\n{\n\tstruct mempolicy *policy;\n\tint node = numa_mem_id();\n\n\tif (in_interrupt())\n\t\treturn node;\n\n\tpolicy = current->mempolicy;\n\tif (!policy || policy->flags & MPOL_F_LOCAL)\n\t\treturn node;\n\n\tswitch (policy->mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * handled MPOL_F_LOCAL above\n\t\t */\n\t\treturn policy->v.preferred_node;\n\n\tcase MPOL_INTERLEAVE:\n\t\treturn interleave_nodes(policy);\n\n\tcase MPOL_BIND: {\n\t\tstruct zoneref *z;\n\n\t\t/*\n\t\t * Follow bind policy behavior and start allocation at the\n\t\t * first node.\n\t\t */\n\t\tstruct zonelist *zonelist;\n\t\tenum zone_type highest_zoneidx = gfp_zone(GFP_KERNEL);\n\t\tzonelist = &NODE_DATA(node)->node_zonelists[ZONELIST_FALLBACK];\n\t\tz = first_zones_zonelist(zonelist, highest_zoneidx,\n\t\t\t\t\t\t\t&policy->v.nodes);\n\t\treturn z->zone ? zone_to_nid(z->zone) : node;\n\t}\n\n\tdefault:\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_to_nid",
          "args": [
            "z->zone"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "first_zones_zonelist",
          "args": [
            "zonelist",
            "highest_zoneidx",
            "&policy->v.nodes"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "node"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfp_zone",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interleave_nodes",
          "args": [
            "policy"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "interleave_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1752-1761",
          "snippet": "static unsigned interleave_nodes(struct mempolicy *policy)\n{\n\tunsigned next;\n\tstruct task_struct *me = current;\n\n\tnext = next_node_in(me->il_prev, policy->v.nodes);\n\tif (next < MAX_NUMNODES)\n\t\tme->il_prev = next;\n\treturn next;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic unsigned interleave_nodes(struct mempolicy *policy)\n{\n\tunsigned next;\n\tstruct task_struct *me = current;\n\n\tnext = next_node_in(me->il_prev, policy->v.nodes);\n\tif (next < MAX_NUMNODES)\n\t\tme->il_prev = next;\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_mem_id",
          "args": [],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nunsigned int mempolicy_slab_node(void)\n{\n\tstruct mempolicy *policy;\n\tint node = numa_mem_id();\n\n\tif (in_interrupt())\n\t\treturn node;\n\n\tpolicy = current->mempolicy;\n\tif (!policy || policy->flags & MPOL_F_LOCAL)\n\t\treturn node;\n\n\tswitch (policy->mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * handled MPOL_F_LOCAL above\n\t\t */\n\t\treturn policy->v.preferred_node;\n\n\tcase MPOL_INTERLEAVE:\n\t\treturn interleave_nodes(policy);\n\n\tcase MPOL_BIND: {\n\t\tstruct zoneref *z;\n\n\t\t/*\n\t\t * Follow bind policy behavior and start allocation at the\n\t\t * first node.\n\t\t */\n\t\tstruct zonelist *zonelist;\n\t\tenum zone_type highest_zoneidx = gfp_zone(GFP_KERNEL);\n\t\tzonelist = &NODE_DATA(node)->node_zonelists[ZONELIST_FALLBACK];\n\t\tz = first_zones_zonelist(zonelist, highest_zoneidx,\n\t\t\t\t\t\t\t&policy->v.nodes);\n\t\treturn z->zone ? zone_to_nid(z->zone) : node;\n\t}\n\n\tdefault:\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "interleave_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1752-1761",
    "snippet": "static unsigned interleave_nodes(struct mempolicy *policy)\n{\n\tunsigned next;\n\tstruct task_struct *me = current;\n\n\tnext = next_node_in(me->il_prev, policy->v.nodes);\n\tif (next < MAX_NUMNODES)\n\t\tme->il_prev = next;\n\treturn next;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next_node_in",
          "args": [
            "me->il_prev",
            "policy->v.nodes"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic unsigned interleave_nodes(struct mempolicy *policy)\n{\n\tunsigned next;\n\tstruct task_struct *me = current;\n\n\tnext = next_node_in(me->il_prev, policy->v.nodes);\n\tif (next < MAX_NUMNODES)\n\t\tme->il_prev = next;\n\treturn next;\n}"
  },
  {
    "function_name": "policy_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1734-1749",
    "snippet": "static int policy_node(gfp_t gfp, struct mempolicy *policy,\n\t\t\t\t\t\t\t\tint nd)\n{\n\tif (policy->mode == MPOL_PREFERRED && !(policy->flags & MPOL_F_LOCAL))\n\t\tnd = policy->v.preferred_node;\n\telse {\n\t\t/*\n\t\t * __GFP_THISNODE shouldn't even be used with the bind policy\n\t\t * because we might easily break the expectation to stay on the\n\t\t * requested node and not break the policy.\n\t\t */\n\t\tWARN_ON_ONCE(policy->mode == MPOL_BIND && (gfp & __GFP_THISNODE));\n\t}\n\n\treturn nd;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "policy->mode == MPOL_BIND && (gfp & __GFP_THISNODE)"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic int policy_node(gfp_t gfp, struct mempolicy *policy,\n\t\t\t\t\t\t\t\tint nd)\n{\n\tif (policy->mode == MPOL_PREFERRED && !(policy->flags & MPOL_F_LOCAL))\n\t\tnd = policy->v.preferred_node;\n\telse {\n\t\t/*\n\t\t * __GFP_THISNODE shouldn't even be used with the bind policy\n\t\t * because we might easily break the expectation to stay on the\n\t\t * requested node and not break the policy.\n\t\t */\n\t\tWARN_ON_ONCE(policy->mode == MPOL_BIND && (gfp & __GFP_THISNODE));\n\t}\n\n\treturn nd;\n}"
  },
  {
    "function_name": "policy_nodemask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1722-1731",
    "snippet": "static nodemask_t *policy_nodemask(gfp_t gfp, struct mempolicy *policy)\n{\n\t/* Lower zones don't get a nodemask applied for MPOL_BIND */\n\tif (unlikely(policy->mode == MPOL_BIND) &&\n\t\t\tapply_policy_zone(policy, gfp_zone(gfp)) &&\n\t\t\tcpuset_nodemask_valid_mems_allowed(&policy->v.nodes))\n\t\treturn &policy->v.nodes;\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuset_nodemask_valid_mems_allowed",
          "args": [
            "&policy->v.nodes"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apply_policy_zone",
          "args": [
            "policy",
            "gfp_zone(gfp)"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "apply_policy_zone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1698-1716",
          "snippet": "static int apply_policy_zone(struct mempolicy *policy, enum zone_type zone)\n{\n\tenum zone_type dynamic_policy_zone = policy_zone;\n\n\tBUG_ON(dynamic_policy_zone == ZONE_MOVABLE);\n\n\t/*\n\t * if policy->v.nodes has movable memory only,\n\t * we apply policy when gfp_zone(gfp) = ZONE_MOVABLE only.\n\t *\n\t * policy->v.nodes is intersect with node_states[N_MEMORY].\n\t * so if the following test faile, it implies\n\t * policy->v.nodes has movable memory only.\n\t */\n\tif (!nodes_intersects(policy->v.nodes, node_states[N_HIGH_MEMORY]))\n\t\tdynamic_policy_zone = ZONE_MOVABLE;\n\n\treturn zone >= dynamic_policy_zone;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum zone_type policy_zone = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nenum zone_type policy_zone = 0;\n\nstatic int apply_policy_zone(struct mempolicy *policy, enum zone_type zone)\n{\n\tenum zone_type dynamic_policy_zone = policy_zone;\n\n\tBUG_ON(dynamic_policy_zone == ZONE_MOVABLE);\n\n\t/*\n\t * if policy->v.nodes has movable memory only,\n\t * we apply policy when gfp_zone(gfp) = ZONE_MOVABLE only.\n\t *\n\t * policy->v.nodes is intersect with node_states[N_MEMORY].\n\t * so if the following test faile, it implies\n\t * policy->v.nodes has movable memory only.\n\t */\n\tif (!nodes_intersects(policy->v.nodes, node_states[N_HIGH_MEMORY]))\n\t\tdynamic_policy_zone = ZONE_MOVABLE;\n\n\treturn zone >= dynamic_policy_zone;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfp_zone",
          "args": [
            "gfp"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "policy->mode == MPOL_BIND"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic nodemask_t *policy_nodemask(gfp_t gfp, struct mempolicy *policy)\n{\n\t/* Lower zones don't get a nodemask applied for MPOL_BIND */\n\tif (unlikely(policy->mode == MPOL_BIND) &&\n\t\t\tapply_policy_zone(policy, gfp_zone(gfp)) &&\n\t\t\tcpuset_nodemask_valid_mems_allowed(&policy->v.nodes))\n\t\treturn &policy->v.nodes;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "apply_policy_zone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1698-1716",
    "snippet": "static int apply_policy_zone(struct mempolicy *policy, enum zone_type zone)\n{\n\tenum zone_type dynamic_policy_zone = policy_zone;\n\n\tBUG_ON(dynamic_policy_zone == ZONE_MOVABLE);\n\n\t/*\n\t * if policy->v.nodes has movable memory only,\n\t * we apply policy when gfp_zone(gfp) = ZONE_MOVABLE only.\n\t *\n\t * policy->v.nodes is intersect with node_states[N_MEMORY].\n\t * so if the following test faile, it implies\n\t * policy->v.nodes has movable memory only.\n\t */\n\tif (!nodes_intersects(policy->v.nodes, node_states[N_HIGH_MEMORY]))\n\t\tdynamic_policy_zone = ZONE_MOVABLE;\n\n\treturn zone >= dynamic_policy_zone;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum zone_type policy_zone = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nodes_intersects",
          "args": [
            "policy->v.nodes",
            "node_states[N_HIGH_MEMORY]"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dynamic_policy_zone == ZONE_MOVABLE"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nenum zone_type policy_zone = 0;\n\nstatic int apply_policy_zone(struct mempolicy *policy, enum zone_type zone)\n{\n\tenum zone_type dynamic_policy_zone = policy_zone;\n\n\tBUG_ON(dynamic_policy_zone == ZONE_MOVABLE);\n\n\t/*\n\t * if policy->v.nodes has movable memory only,\n\t * we apply policy when gfp_zone(gfp) = ZONE_MOVABLE only.\n\t *\n\t * policy->v.nodes is intersect with node_states[N_MEMORY].\n\t * so if the following test faile, it implies\n\t * policy->v.nodes has movable memory only.\n\t */\n\tif (!nodes_intersects(policy->v.nodes, node_states[N_HIGH_MEMORY]))\n\t\tdynamic_policy_zone = ZONE_MOVABLE;\n\n\treturn zone >= dynamic_policy_zone;\n}"
  },
  {
    "function_name": "vma_policy_mof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1676-1696",
    "snippet": "bool vma_policy_mof(struct vm_area_struct *vma)\n{\n\tstruct mempolicy *pol;\n\n\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\tbool ret = false;\n\n\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start);\n\t\tif (pol && (pol->flags & MPOL_F_MOF))\n\t\t\tret = true;\n\t\tmpol_cond_put(pol);\n\n\t\treturn ret;\n\t}\n\n\tpol = vma->vm_policy;\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol->flags & MPOL_F_MOF;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_task_policy",
          "args": [
            "current"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "get_task_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "130-147",
          "snippet": "struct mempolicy *get_task_policy(struct task_struct *p)\n{\n\tstruct mempolicy *pol = p->mempolicy;\n\tint node;\n\n\tif (pol)\n\t\treturn pol;\n\n\tnode = numa_node_id();\n\tif (node != NUMA_NO_NODE) {\n\t\tpol = &preferred_node_policy[node];\n\t\t/* preferred_node_policy is not initialised early in boot */\n\t\tif (pol->mode)\n\t\t\treturn pol;\n\t}\n\n\treturn &default_policy;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct mempolicy default_policy = {\n\t.refcnt = ATOMIC_INIT(1), /* never free it */\n\t.mode = MPOL_PREFERRED,\n\t.flags = MPOL_F_LOCAL,\n};",
            "static struct mempolicy preferred_node_policy[MAX_NUMNODES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct mempolicy default_policy = {\n\t.refcnt = ATOMIC_INIT(1), /* never free it */\n\t.mode = MPOL_PREFERRED,\n\t.flags = MPOL_F_LOCAL,\n};\nstatic struct mempolicy preferred_node_policy[MAX_NUMNODES];\n\nstruct mempolicy *get_task_policy(struct task_struct *p)\n{\n\tstruct mempolicy *pol = p->mempolicy;\n\tint node;\n\n\tif (pol)\n\t\treturn pol;\n\n\tnode = numa_node_id();\n\tif (node != NUMA_NO_NODE) {\n\t\tpol = &preferred_node_policy[node];\n\t\t/* preferred_node_policy is not initialised early in boot */\n\t\tif (pol->mode)\n\t\t\treturn pol;\n\t}\n\n\treturn &default_policy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mpol_cond_put",
          "args": [
            "pol"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma->vm_ops->get_policy",
          "args": [
            "vma",
            "vma->vm_start"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nbool vma_policy_mof(struct vm_area_struct *vma)\n{\n\tstruct mempolicy *pol;\n\n\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\tbool ret = false;\n\n\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start);\n\t\tif (pol && (pol->flags & MPOL_F_MOF))\n\t\t\tret = true;\n\t\tmpol_cond_put(pol);\n\n\t\treturn ret;\n\t}\n\n\tpol = vma->vm_policy;\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol->flags & MPOL_F_MOF;\n}"
  },
  {
    "function_name": "get_vma_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1665-1674",
    "snippet": "struct mempolicy *get_vma_policy(struct vm_area_struct *vma,\n\t\t\t\t\t\tunsigned long addr)\n{\n\tstruct mempolicy *pol = __get_vma_policy(vma, addr);\n\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_task_policy",
          "args": [
            "current"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "get_task_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "130-147",
          "snippet": "struct mempolicy *get_task_policy(struct task_struct *p)\n{\n\tstruct mempolicy *pol = p->mempolicy;\n\tint node;\n\n\tif (pol)\n\t\treturn pol;\n\n\tnode = numa_node_id();\n\tif (node != NUMA_NO_NODE) {\n\t\tpol = &preferred_node_policy[node];\n\t\t/* preferred_node_policy is not initialised early in boot */\n\t\tif (pol->mode)\n\t\t\treturn pol;\n\t}\n\n\treturn &default_policy;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct mempolicy default_policy = {\n\t.refcnt = ATOMIC_INIT(1), /* never free it */\n\t.mode = MPOL_PREFERRED,\n\t.flags = MPOL_F_LOCAL,\n};",
            "static struct mempolicy preferred_node_policy[MAX_NUMNODES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct mempolicy default_policy = {\n\t.refcnt = ATOMIC_INIT(1), /* never free it */\n\t.mode = MPOL_PREFERRED,\n\t.flags = MPOL_F_LOCAL,\n};\nstatic struct mempolicy preferred_node_policy[MAX_NUMNODES];\n\nstruct mempolicy *get_task_policy(struct task_struct *p)\n{\n\tstruct mempolicy *pol = p->mempolicy;\n\tint node;\n\n\tif (pol)\n\t\treturn pol;\n\n\tnode = numa_node_id();\n\tif (node != NUMA_NO_NODE) {\n\t\tpol = &preferred_node_policy[node];\n\t\t/* preferred_node_policy is not initialised early in boot */\n\t\tif (pol->mode)\n\t\t\treturn pol;\n\t}\n\n\treturn &default_policy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_vma_policy",
          "args": [
            "vma",
            "addr"
          ],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "__get_vma_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1628-1651",
          "snippet": "struct mempolicy *__get_vma_policy(struct vm_area_struct *vma,\n\t\t\t\t\t\tunsigned long addr)\n{\n\tstruct mempolicy *pol = NULL;\n\n\tif (vma) {\n\t\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\t\tpol = vma->vm_ops->get_policy(vma, addr);\n\t\t} else if (vma->vm_policy) {\n\t\t\tpol = vma->vm_policy;\n\n\t\t\t/*\n\t\t\t * shmem_alloc_page() passes MPOL_F_SHARED policy with\n\t\t\t * a pseudo vma whose vma->vm_ops=NULL. Take a reference\n\t\t\t * count on these policies which will be dropped by\n\t\t\t * mpol_cond_put() later\n\t\t\t */\n\t\t\tif (mpol_needs_cond_ref(pol))\n\t\t\t\tmpol_get(pol);\n\t\t}\n\t}\n\n\treturn pol;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstruct mempolicy *__get_vma_policy(struct vm_area_struct *vma,\n\t\t\t\t\t\tunsigned long addr)\n{\n\tstruct mempolicy *pol = NULL;\n\n\tif (vma) {\n\t\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\t\tpol = vma->vm_ops->get_policy(vma, addr);\n\t\t} else if (vma->vm_policy) {\n\t\t\tpol = vma->vm_policy;\n\n\t\t\t/*\n\t\t\t * shmem_alloc_page() passes MPOL_F_SHARED policy with\n\t\t\t * a pseudo vma whose vma->vm_ops=NULL. Take a reference\n\t\t\t * count on these policies which will be dropped by\n\t\t\t * mpol_cond_put() later\n\t\t\t */\n\t\t\tif (mpol_needs_cond_ref(pol))\n\t\t\t\tmpol_get(pol);\n\t\t}\n\t}\n\n\treturn pol;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstruct mempolicy *get_vma_policy(struct vm_area_struct *vma,\n\t\t\t\t\t\tunsigned long addr)\n{\n\tstruct mempolicy *pol = __get_vma_policy(vma, addr);\n\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol;\n}"
  },
  {
    "function_name": "__get_vma_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1628-1651",
    "snippet": "struct mempolicy *__get_vma_policy(struct vm_area_struct *vma,\n\t\t\t\t\t\tunsigned long addr)\n{\n\tstruct mempolicy *pol = NULL;\n\n\tif (vma) {\n\t\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\t\tpol = vma->vm_ops->get_policy(vma, addr);\n\t\t} else if (vma->vm_policy) {\n\t\t\tpol = vma->vm_policy;\n\n\t\t\t/*\n\t\t\t * shmem_alloc_page() passes MPOL_F_SHARED policy with\n\t\t\t * a pseudo vma whose vma->vm_ops=NULL. Take a reference\n\t\t\t * count on these policies which will be dropped by\n\t\t\t * mpol_cond_put() later\n\t\t\t */\n\t\t\tif (mpol_needs_cond_ref(pol))\n\t\t\t\tmpol_get(pol);\n\t\t}\n\t}\n\n\treturn pol;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpol_get",
          "args": [
            "pol"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_needs_cond_ref",
          "args": [
            "pol"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma->vm_ops->get_policy",
          "args": [
            "vma",
            "addr"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstruct mempolicy *__get_vma_policy(struct vm_area_struct *vma,\n\t\t\t\t\t\tunsigned long addr)\n{\n\tstruct mempolicy *pol = NULL;\n\n\tif (vma) {\n\t\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\t\tpol = vma->vm_ops->get_policy(vma, addr);\n\t\t} else if (vma->vm_policy) {\n\t\t\tpol = vma->vm_policy;\n\n\t\t\t/*\n\t\t\t * shmem_alloc_page() passes MPOL_F_SHARED policy with\n\t\t\t * a pseudo vma whose vma->vm_ops=NULL. Take a reference\n\t\t\t * count on these policies which will be dropped by\n\t\t\t * mpol_cond_put() later\n\t\t\t */\n\t\t\tif (mpol_needs_cond_ref(pol))\n\t\t\t\tmpol_get(pol);\n\t\t}\n\t}\n\n\treturn pol;\n}"
  },
  {
    "function_name": "kernel_get_mempolicy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1484-1509",
    "snippet": "static int kernel_get_mempolicy(int __user *policy,\n\t\t\t\tunsigned long __user *nmask,\n\t\t\t\tunsigned long maxnode,\n\t\t\t\tunsigned long addr,\n\t\t\t\tunsigned long flags)\n{\n\tint err;\n\tint uninitialized_var(pval);\n\tnodemask_t nodes;\n\n\tif (nmask != NULL && maxnode < MAX_NUMNODES)\n\t\treturn -EINVAL;\n\n\terr = do_get_mempolicy(&pval, &nodes, addr, flags);\n\n\tif (err)\n\t\treturn err;\n\n\tif (policy && put_user(pval, policy))\n\t\treturn -EFAULT;\n\n\tif (nmask)\n\t\terr = copy_nodes_to_user(nmask, maxnode, &nodes);\n\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_nodes_to_user",
          "args": [
            "nmask",
            "maxnode",
            "&nodes"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "copy_nodes_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1313-1327",
          "snippet": "static int copy_nodes_to_user(unsigned long __user *mask, unsigned long maxnode,\n\t\t\t      nodemask_t *nodes)\n{\n\tunsigned long copy = ALIGN(maxnode-1, 64) / 8;\n\tconst int nbytes = BITS_TO_LONGS(MAX_NUMNODES) * sizeof(long);\n\n\tif (copy > nbytes) {\n\t\tif (copy > PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\tif (clear_user((char __user *)mask + nbytes, copy - nbytes))\n\t\t\treturn -EFAULT;\n\t\tcopy = nbytes;\n\t}\n\treturn copy_to_user(mask, nodes_addr(*nodes), copy) ? -EFAULT : 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic int copy_nodes_to_user(unsigned long __user *mask, unsigned long maxnode,\n\t\t\t      nodemask_t *nodes)\n{\n\tunsigned long copy = ALIGN(maxnode-1, 64) / 8;\n\tconst int nbytes = BITS_TO_LONGS(MAX_NUMNODES) * sizeof(long);\n\n\tif (copy > nbytes) {\n\t\tif (copy > PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\tif (clear_user((char __user *)mask + nbytes, copy - nbytes))\n\t\t\treturn -EFAULT;\n\t\tcopy = nbytes;\n\t}\n\treturn copy_to_user(mask, nodes_addr(*nodes), copy) ? -EFAULT : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "pval",
            "policy"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_get_mempolicy",
          "args": [
            "&pval",
            "&nodes",
            "addr",
            "flags"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "do_get_mempolicy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "817-911",
          "snippet": "static long do_get_mempolicy(int *policy, nodemask_t *nmask,\n\t\t\t     unsigned long addr, unsigned long flags)\n{\n\tint err;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = NULL;\n\tstruct mempolicy *pol = current->mempolicy, *pol_refcount = NULL;\n\n\tif (flags &\n\t\t~(unsigned long)(MPOL_F_NODE|MPOL_F_ADDR|MPOL_F_MEMS_ALLOWED))\n\t\treturn -EINVAL;\n\n\tif (flags & MPOL_F_MEMS_ALLOWED) {\n\t\tif (flags & (MPOL_F_NODE|MPOL_F_ADDR))\n\t\t\treturn -EINVAL;\n\t\t*policy = 0;\t/* just so it's initialized */\n\t\ttask_lock(current);\n\t\t*nmask  = cpuset_current_mems_allowed;\n\t\ttask_unlock(current);\n\t\treturn 0;\n\t}\n\n\tif (flags & MPOL_F_ADDR) {\n\t\t/*\n\t\t * Do NOT fall back to task policy if the\n\t\t * vma/shared policy at addr is NULL.  We\n\t\t * want to return MPOL_DEFAULT in this case.\n\t\t */\n\t\tdown_read(&mm->mmap_sem);\n\t\tvma = find_vma_intersection(mm, addr, addr+1);\n\t\tif (!vma) {\n\t\t\tup_read(&mm->mmap_sem);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (vma->vm_ops && vma->vm_ops->get_policy)\n\t\t\tpol = vma->vm_ops->get_policy(vma, addr);\n\t\telse\n\t\t\tpol = vma->vm_policy;\n\t} else if (addr)\n\t\treturn -EINVAL;\n\n\tif (!pol)\n\t\tpol = &default_policy;\t/* indicates default behavior */\n\n\tif (flags & MPOL_F_NODE) {\n\t\tif (flags & MPOL_F_ADDR) {\n\t\t\t/*\n\t\t\t * Take a refcount on the mpol, lookup_node()\n\t\t\t * wil drop the mmap_sem, so after calling\n\t\t\t * lookup_node() only \"pol\" remains valid, \"vma\"\n\t\t\t * is stale.\n\t\t\t */\n\t\t\tpol_refcount = pol;\n\t\t\tvma = NULL;\n\t\t\tmpol_get(pol);\n\t\t\terr = lookup_node(mm, addr);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t\t*policy = err;\n\t\t} else if (pol == current->mempolicy &&\n\t\t\t\tpol->mode == MPOL_INTERLEAVE) {\n\t\t\t*policy = next_node_in(current->il_prev, pol->v.nodes);\n\t\t} else {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t*policy = pol == &default_policy ? MPOL_DEFAULT :\n\t\t\t\t\t\tpol->mode;\n\t\t/*\n\t\t * Internal mempolicy flags must be masked off before exposing\n\t\t * the policy to userspace.\n\t\t */\n\t\t*policy |= (pol->flags & MPOL_MODE_FLAGS);\n\t}\n\n\terr = 0;\n\tif (nmask) {\n\t\tif (mpol_store_user_nodemask(pol)) {\n\t\t\t*nmask = pol->w.user_nodemask;\n\t\t} else {\n\t\t\ttask_lock(current);\n\t\t\tget_policy_nodemask(pol, nmask);\n\t\t\ttask_unlock(current);\n\t\t}\n\t}\n\n out:\n\tmpol_cond_put(pol);\n\tif (vma)\n\t\tup_read(&mm->mmap_sem);\n\tif (pol_refcount)\n\t\tmpol_put(pol_refcount);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct mempolicy default_policy = {\n\t.refcnt = ATOMIC_INIT(1), /* never free it */\n\t.mode = MPOL_PREFERRED,\n\t.flags = MPOL_F_LOCAL,\n};",
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct mempolicy default_policy = {\n\t.refcnt = ATOMIC_INIT(1), /* never free it */\n\t.mode = MPOL_PREFERRED,\n\t.flags = MPOL_F_LOCAL,\n};\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic long do_get_mempolicy(int *policy, nodemask_t *nmask,\n\t\t\t     unsigned long addr, unsigned long flags)\n{\n\tint err;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = NULL;\n\tstruct mempolicy *pol = current->mempolicy, *pol_refcount = NULL;\n\n\tif (flags &\n\t\t~(unsigned long)(MPOL_F_NODE|MPOL_F_ADDR|MPOL_F_MEMS_ALLOWED))\n\t\treturn -EINVAL;\n\n\tif (flags & MPOL_F_MEMS_ALLOWED) {\n\t\tif (flags & (MPOL_F_NODE|MPOL_F_ADDR))\n\t\t\treturn -EINVAL;\n\t\t*policy = 0;\t/* just so it's initialized */\n\t\ttask_lock(current);\n\t\t*nmask  = cpuset_current_mems_allowed;\n\t\ttask_unlock(current);\n\t\treturn 0;\n\t}\n\n\tif (flags & MPOL_F_ADDR) {\n\t\t/*\n\t\t * Do NOT fall back to task policy if the\n\t\t * vma/shared policy at addr is NULL.  We\n\t\t * want to return MPOL_DEFAULT in this case.\n\t\t */\n\t\tdown_read(&mm->mmap_sem);\n\t\tvma = find_vma_intersection(mm, addr, addr+1);\n\t\tif (!vma) {\n\t\t\tup_read(&mm->mmap_sem);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (vma->vm_ops && vma->vm_ops->get_policy)\n\t\t\tpol = vma->vm_ops->get_policy(vma, addr);\n\t\telse\n\t\t\tpol = vma->vm_policy;\n\t} else if (addr)\n\t\treturn -EINVAL;\n\n\tif (!pol)\n\t\tpol = &default_policy;\t/* indicates default behavior */\n\n\tif (flags & MPOL_F_NODE) {\n\t\tif (flags & MPOL_F_ADDR) {\n\t\t\t/*\n\t\t\t * Take a refcount on the mpol, lookup_node()\n\t\t\t * wil drop the mmap_sem, so after calling\n\t\t\t * lookup_node() only \"pol\" remains valid, \"vma\"\n\t\t\t * is stale.\n\t\t\t */\n\t\t\tpol_refcount = pol;\n\t\t\tvma = NULL;\n\t\t\tmpol_get(pol);\n\t\t\terr = lookup_node(mm, addr);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t\t*policy = err;\n\t\t} else if (pol == current->mempolicy &&\n\t\t\t\tpol->mode == MPOL_INTERLEAVE) {\n\t\t\t*policy = next_node_in(current->il_prev, pol->v.nodes);\n\t\t} else {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t*policy = pol == &default_policy ? MPOL_DEFAULT :\n\t\t\t\t\t\tpol->mode;\n\t\t/*\n\t\t * Internal mempolicy flags must be masked off before exposing\n\t\t * the policy to userspace.\n\t\t */\n\t\t*policy |= (pol->flags & MPOL_MODE_FLAGS);\n\t}\n\n\terr = 0;\n\tif (nmask) {\n\t\tif (mpol_store_user_nodemask(pol)) {\n\t\t\t*nmask = pol->w.user_nodemask;\n\t\t} else {\n\t\t\ttask_lock(current);\n\t\t\tget_policy_nodemask(pol, nmask);\n\t\t\ttask_unlock(current);\n\t\t}\n\t}\n\n out:\n\tmpol_cond_put(pol);\n\tif (vma)\n\t\tup_read(&mm->mmap_sem);\n\tif (pol_refcount)\n\t\tmpol_put(pol_refcount);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic int kernel_get_mempolicy(int __user *policy,\n\t\t\t\tunsigned long __user *nmask,\n\t\t\t\tunsigned long maxnode,\n\t\t\t\tunsigned long addr,\n\t\t\t\tunsigned long flags)\n{\n\tint err;\n\tint uninitialized_var(pval);\n\tnodemask_t nodes;\n\n\tif (nmask != NULL && maxnode < MAX_NUMNODES)\n\t\treturn -EINVAL;\n\n\terr = do_get_mempolicy(&pval, &nodes, addr, flags);\n\n\tif (err)\n\t\treturn err;\n\n\tif (policy && put_user(pval, policy))\n\t\treturn -EFAULT;\n\n\tif (nmask)\n\t\terr = copy_nodes_to_user(nmask, maxnode, &nodes);\n\n\treturn err;\n}"
  },
  {
    "function_name": "kernel_migrate_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1383-1473",
    "snippet": "static int kernel_migrate_pages(pid_t pid, unsigned long maxnode,\n\t\t\t\tconst unsigned long __user *old_nodes,\n\t\t\t\tconst unsigned long __user *new_nodes)\n{\n\tstruct mm_struct *mm = NULL;\n\tstruct task_struct *task;\n\tnodemask_t task_nodes;\n\tint err;\n\tnodemask_t *old;\n\tnodemask_t *new;\n\tNODEMASK_SCRATCH(scratch);\n\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\n\told = &scratch->mask1;\n\tnew = &scratch->mask2;\n\n\terr = get_nodes(old, old_nodes, maxnode);\n\tif (err)\n\t\tgoto out;\n\n\terr = get_nodes(new, new_nodes, maxnode);\n\tif (err)\n\t\tgoto out;\n\n\t/* Find the mm_struct */\n\trcu_read_lock();\n\ttask = pid ? find_task_by_vpid(pid) : current;\n\tif (!task) {\n\t\trcu_read_unlock();\n\t\terr = -ESRCH;\n\t\tgoto out;\n\t}\n\tget_task_struct(task);\n\n\terr = -EINVAL;\n\n\t/*\n\t * Check if this process has the right to modify the specified process.\n\t * Use the regular \"ptrace_may_access()\" checks.\n\t */\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) {\n\t\trcu_read_unlock();\n\t\terr = -EPERM;\n\t\tgoto out_put;\n\t}\n\trcu_read_unlock();\n\n\ttask_nodes = cpuset_mems_allowed(task);\n\t/* Is the user allowed to access the target nodes? */\n\tif (!nodes_subset(*new, task_nodes) && !capable(CAP_SYS_NICE)) {\n\t\terr = -EPERM;\n\t\tgoto out_put;\n\t}\n\n\ttask_nodes = cpuset_mems_allowed(current);\n\tnodes_and(*new, *new, task_nodes);\n\tif (nodes_empty(*new))\n\t\tgoto out_put;\n\n\tnodes_and(*new, *new, node_states[N_MEMORY]);\n\tif (nodes_empty(*new))\n\t\tgoto out_put;\n\n\terr = security_task_movememory(task);\n\tif (err)\n\t\tgoto out_put;\n\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\n\tif (!mm) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = do_migrate_pages(mm, old, new,\n\t\tcapable(CAP_SYS_NICE) ? MPOL_MF_MOVE_ALL : MPOL_MF_MOVE);\n\n\tmmput(mm);\nout:\n\tNODEMASK_SCRATCH_FREE(scratch);\n\n\treturn err;\n\nout_put:\n\tput_task_struct(task);\n\tgoto out;\n\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODEMASK_SCRATCH_FREE",
          "args": [
            "scratch"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_migrate_pages",
          "args": [
            "mm",
            "old",
            "new",
            "capable(CAP_SYS_NICE) ? MPOL_MF_MOVE_ALL : MPOL_MF_MOVE"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "do_migrate_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1139-1143",
          "snippet": "int do_migrate_pages(struct mm_struct *mm, const nodemask_t *from,\n\t\t     const nodemask_t *to, int flags)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nint do_migrate_pages(struct mm_struct *mm, const nodemask_t *from,\n\t\t     const nodemask_t *to, int flags)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_NICE"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_mm",
          "args": [
            "task"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_task_movememory",
          "args": [
            "task"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_empty",
          "args": [
            "*new"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_and",
          "args": [
            "*new",
            "*new",
            "node_states[N_MEMORY]"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_empty",
          "args": [
            "*new"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_and",
          "args": [
            "*new",
            "*new",
            "task_nodes"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuset_mems_allowed",
          "args": [
            "current"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_NICE"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_subset",
          "args": [
            "*new",
            "task_nodes"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuset_mems_allowed",
          "args": [
            "task"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_may_access",
          "args": [
            "task",
            "PTRACE_MODE_READ_REALCREDS"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "task"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_task_by_vpid",
          "args": [
            "pid"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nodes",
          "args": [
            "new",
            "new_nodes",
            "maxnode"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "get_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1252-1310",
          "snippet": "static int get_nodes(nodemask_t *nodes, const unsigned long __user *nmask,\n\t\t     unsigned long maxnode)\n{\n\tunsigned long k;\n\tunsigned long t;\n\tunsigned long nlongs;\n\tunsigned long endmask;\n\n\t--maxnode;\n\tnodes_clear(*nodes);\n\tif (maxnode == 0 || !nmask)\n\t\treturn 0;\n\tif (maxnode > PAGE_SIZE*BITS_PER_BYTE)\n\t\treturn -EINVAL;\n\n\tnlongs = BITS_TO_LONGS(maxnode);\n\tif ((maxnode % BITS_PER_LONG) == 0)\n\t\tendmask = ~0UL;\n\telse\n\t\tendmask = (1UL << (maxnode % BITS_PER_LONG)) - 1;\n\n\t/*\n\t * When the user specified more nodes than supported just check\n\t * if the non supported part is all zero.\n\t *\n\t * If maxnode have more longs than MAX_NUMNODES, check\n\t * the bits in that area first. And then go through to\n\t * check the rest bits which equal or bigger than MAX_NUMNODES.\n\t * Otherwise, just check bits [MAX_NUMNODES, maxnode).\n\t */\n\tif (nlongs > BITS_TO_LONGS(MAX_NUMNODES)) {\n\t\tfor (k = BITS_TO_LONGS(MAX_NUMNODES); k < nlongs; k++) {\n\t\t\tif (get_user(t, nmask + k))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (k == nlongs - 1) {\n\t\t\t\tif (t & endmask)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t} else if (t)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tnlongs = BITS_TO_LONGS(MAX_NUMNODES);\n\t\tendmask = ~0UL;\n\t}\n\n\tif (maxnode > MAX_NUMNODES && MAX_NUMNODES % BITS_PER_LONG != 0) {\n\t\tunsigned long valid_mask = endmask;\n\n\t\tvalid_mask &= ~((1UL << (MAX_NUMNODES % BITS_PER_LONG)) - 1);\n\t\tif (get_user(t, nmask + nlongs - 1))\n\t\t\treturn -EFAULT;\n\t\tif (t & valid_mask)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(nodes_addr(*nodes), nmask, nlongs*sizeof(unsigned long)))\n\t\treturn -EFAULT;\n\tnodes_addr(*nodes)[nlongs-1] &= endmask;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic int get_nodes(nodemask_t *nodes, const unsigned long __user *nmask,\n\t\t     unsigned long maxnode)\n{\n\tunsigned long k;\n\tunsigned long t;\n\tunsigned long nlongs;\n\tunsigned long endmask;\n\n\t--maxnode;\n\tnodes_clear(*nodes);\n\tif (maxnode == 0 || !nmask)\n\t\treturn 0;\n\tif (maxnode > PAGE_SIZE*BITS_PER_BYTE)\n\t\treturn -EINVAL;\n\n\tnlongs = BITS_TO_LONGS(maxnode);\n\tif ((maxnode % BITS_PER_LONG) == 0)\n\t\tendmask = ~0UL;\n\telse\n\t\tendmask = (1UL << (maxnode % BITS_PER_LONG)) - 1;\n\n\t/*\n\t * When the user specified more nodes than supported just check\n\t * if the non supported part is all zero.\n\t *\n\t * If maxnode have more longs than MAX_NUMNODES, check\n\t * the bits in that area first. And then go through to\n\t * check the rest bits which equal or bigger than MAX_NUMNODES.\n\t * Otherwise, just check bits [MAX_NUMNODES, maxnode).\n\t */\n\tif (nlongs > BITS_TO_LONGS(MAX_NUMNODES)) {\n\t\tfor (k = BITS_TO_LONGS(MAX_NUMNODES); k < nlongs; k++) {\n\t\t\tif (get_user(t, nmask + k))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (k == nlongs - 1) {\n\t\t\t\tif (t & endmask)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t} else if (t)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tnlongs = BITS_TO_LONGS(MAX_NUMNODES);\n\t\tendmask = ~0UL;\n\t}\n\n\tif (maxnode > MAX_NUMNODES && MAX_NUMNODES % BITS_PER_LONG != 0) {\n\t\tunsigned long valid_mask = endmask;\n\n\t\tvalid_mask &= ~((1UL << (MAX_NUMNODES % BITS_PER_LONG)) - 1);\n\t\tif (get_user(t, nmask + nlongs - 1))\n\t\t\treturn -EFAULT;\n\t\tif (t & valid_mask)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(nodes_addr(*nodes), nmask, nlongs*sizeof(unsigned long)))\n\t\treturn -EFAULT;\n\tnodes_addr(*nodes)[nlongs-1] &= endmask;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NODEMASK_SCRATCH",
          "args": [
            "scratch"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic int kernel_migrate_pages(pid_t pid, unsigned long maxnode,\n\t\t\t\tconst unsigned long __user *old_nodes,\n\t\t\t\tconst unsigned long __user *new_nodes)\n{\n\tstruct mm_struct *mm = NULL;\n\tstruct task_struct *task;\n\tnodemask_t task_nodes;\n\tint err;\n\tnodemask_t *old;\n\tnodemask_t *new;\n\tNODEMASK_SCRATCH(scratch);\n\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\n\told = &scratch->mask1;\n\tnew = &scratch->mask2;\n\n\terr = get_nodes(old, old_nodes, maxnode);\n\tif (err)\n\t\tgoto out;\n\n\terr = get_nodes(new, new_nodes, maxnode);\n\tif (err)\n\t\tgoto out;\n\n\t/* Find the mm_struct */\n\trcu_read_lock();\n\ttask = pid ? find_task_by_vpid(pid) : current;\n\tif (!task) {\n\t\trcu_read_unlock();\n\t\terr = -ESRCH;\n\t\tgoto out;\n\t}\n\tget_task_struct(task);\n\n\terr = -EINVAL;\n\n\t/*\n\t * Check if this process has the right to modify the specified process.\n\t * Use the regular \"ptrace_may_access()\" checks.\n\t */\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) {\n\t\trcu_read_unlock();\n\t\terr = -EPERM;\n\t\tgoto out_put;\n\t}\n\trcu_read_unlock();\n\n\ttask_nodes = cpuset_mems_allowed(task);\n\t/* Is the user allowed to access the target nodes? */\n\tif (!nodes_subset(*new, task_nodes) && !capable(CAP_SYS_NICE)) {\n\t\terr = -EPERM;\n\t\tgoto out_put;\n\t}\n\n\ttask_nodes = cpuset_mems_allowed(current);\n\tnodes_and(*new, *new, task_nodes);\n\tif (nodes_empty(*new))\n\t\tgoto out_put;\n\n\tnodes_and(*new, *new, node_states[N_MEMORY]);\n\tif (nodes_empty(*new))\n\t\tgoto out_put;\n\n\terr = security_task_movememory(task);\n\tif (err)\n\t\tgoto out_put;\n\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\n\tif (!mm) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = do_migrate_pages(mm, old, new,\n\t\tcapable(CAP_SYS_NICE) ? MPOL_MF_MOVE_ALL : MPOL_MF_MOVE);\n\n\tmmput(mm);\nout:\n\tNODEMASK_SCRATCH_FREE(scratch);\n\n\treturn err;\n\nout_put:\n\tput_task_struct(task);\n\tgoto out;\n\n}"
  },
  {
    "function_name": "kernel_set_mempolicy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1358-1375",
    "snippet": "static long kernel_set_mempolicy(int mode, const unsigned long __user *nmask,\n\t\t\t\t unsigned long maxnode)\n{\n\tint err;\n\tnodemask_t nodes;\n\tunsigned short flags;\n\n\tflags = mode & MPOL_MODE_FLAGS;\n\tmode &= ~MPOL_MODE_FLAGS;\n\tif ((unsigned int)mode >= MPOL_MAX)\n\t\treturn -EINVAL;\n\tif ((flags & MPOL_F_STATIC_NODES) && (flags & MPOL_F_RELATIVE_NODES))\n\t\treturn -EINVAL;\n\terr = get_nodes(&nodes, nmask, maxnode);\n\tif (err)\n\t\treturn err;\n\treturn do_set_mempolicy(mode, flags, &nodes);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_set_mempolicy",
          "args": [
            "mode",
            "flags",
            "&nodes"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "do_set_mempolicy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "738-771",
          "snippet": "static long do_set_mempolicy(unsigned short mode, unsigned short flags,\n\t\t\t     nodemask_t *nodes)\n{\n\tstruct mempolicy *new, *old;\n\tNODEMASK_SCRATCH(scratch);\n\tint ret;\n\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\n\tnew = mpol_new(mode, flags, nodes);\n\tif (IS_ERR(new)) {\n\t\tret = PTR_ERR(new);\n\t\tgoto out;\n\t}\n\n\ttask_lock(current);\n\tret = mpol_set_nodemask(new, nodes, scratch);\n\tif (ret) {\n\t\ttask_unlock(current);\n\t\tmpol_put(new);\n\t\tgoto out;\n\t}\n\told = current->mempolicy;\n\tcurrent->mempolicy = new;\n\tif (new && new->mode == MPOL_INTERLEAVE)\n\t\tcurrent->il_prev = MAX_NUMNODES-1;\n\ttask_unlock(current);\n\tmpol_put(old);\n\tret = 0;\nout:\n\tNODEMASK_SCRATCH_FREE(scratch);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic long do_set_mempolicy(unsigned short mode, unsigned short flags,\n\t\t\t     nodemask_t *nodes)\n{\n\tstruct mempolicy *new, *old;\n\tNODEMASK_SCRATCH(scratch);\n\tint ret;\n\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\n\tnew = mpol_new(mode, flags, nodes);\n\tif (IS_ERR(new)) {\n\t\tret = PTR_ERR(new);\n\t\tgoto out;\n\t}\n\n\ttask_lock(current);\n\tret = mpol_set_nodemask(new, nodes, scratch);\n\tif (ret) {\n\t\ttask_unlock(current);\n\t\tmpol_put(new);\n\t\tgoto out;\n\t}\n\told = current->mempolicy;\n\tcurrent->mempolicy = new;\n\tif (new && new->mode == MPOL_INTERLEAVE)\n\t\tcurrent->il_prev = MAX_NUMNODES-1;\n\ttask_unlock(current);\n\tmpol_put(old);\n\tret = 0;\nout:\n\tNODEMASK_SCRATCH_FREE(scratch);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nodes",
          "args": [
            "&nodes",
            "nmask",
            "maxnode"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "get_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1252-1310",
          "snippet": "static int get_nodes(nodemask_t *nodes, const unsigned long __user *nmask,\n\t\t     unsigned long maxnode)\n{\n\tunsigned long k;\n\tunsigned long t;\n\tunsigned long nlongs;\n\tunsigned long endmask;\n\n\t--maxnode;\n\tnodes_clear(*nodes);\n\tif (maxnode == 0 || !nmask)\n\t\treturn 0;\n\tif (maxnode > PAGE_SIZE*BITS_PER_BYTE)\n\t\treturn -EINVAL;\n\n\tnlongs = BITS_TO_LONGS(maxnode);\n\tif ((maxnode % BITS_PER_LONG) == 0)\n\t\tendmask = ~0UL;\n\telse\n\t\tendmask = (1UL << (maxnode % BITS_PER_LONG)) - 1;\n\n\t/*\n\t * When the user specified more nodes than supported just check\n\t * if the non supported part is all zero.\n\t *\n\t * If maxnode have more longs than MAX_NUMNODES, check\n\t * the bits in that area first. And then go through to\n\t * check the rest bits which equal or bigger than MAX_NUMNODES.\n\t * Otherwise, just check bits [MAX_NUMNODES, maxnode).\n\t */\n\tif (nlongs > BITS_TO_LONGS(MAX_NUMNODES)) {\n\t\tfor (k = BITS_TO_LONGS(MAX_NUMNODES); k < nlongs; k++) {\n\t\t\tif (get_user(t, nmask + k))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (k == nlongs - 1) {\n\t\t\t\tif (t & endmask)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t} else if (t)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tnlongs = BITS_TO_LONGS(MAX_NUMNODES);\n\t\tendmask = ~0UL;\n\t}\n\n\tif (maxnode > MAX_NUMNODES && MAX_NUMNODES % BITS_PER_LONG != 0) {\n\t\tunsigned long valid_mask = endmask;\n\n\t\tvalid_mask &= ~((1UL << (MAX_NUMNODES % BITS_PER_LONG)) - 1);\n\t\tif (get_user(t, nmask + nlongs - 1))\n\t\t\treturn -EFAULT;\n\t\tif (t & valid_mask)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(nodes_addr(*nodes), nmask, nlongs*sizeof(unsigned long)))\n\t\treturn -EFAULT;\n\tnodes_addr(*nodes)[nlongs-1] &= endmask;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic int get_nodes(nodemask_t *nodes, const unsigned long __user *nmask,\n\t\t     unsigned long maxnode)\n{\n\tunsigned long k;\n\tunsigned long t;\n\tunsigned long nlongs;\n\tunsigned long endmask;\n\n\t--maxnode;\n\tnodes_clear(*nodes);\n\tif (maxnode == 0 || !nmask)\n\t\treturn 0;\n\tif (maxnode > PAGE_SIZE*BITS_PER_BYTE)\n\t\treturn -EINVAL;\n\n\tnlongs = BITS_TO_LONGS(maxnode);\n\tif ((maxnode % BITS_PER_LONG) == 0)\n\t\tendmask = ~0UL;\n\telse\n\t\tendmask = (1UL << (maxnode % BITS_PER_LONG)) - 1;\n\n\t/*\n\t * When the user specified more nodes than supported just check\n\t * if the non supported part is all zero.\n\t *\n\t * If maxnode have more longs than MAX_NUMNODES, check\n\t * the bits in that area first. And then go through to\n\t * check the rest bits which equal or bigger than MAX_NUMNODES.\n\t * Otherwise, just check bits [MAX_NUMNODES, maxnode).\n\t */\n\tif (nlongs > BITS_TO_LONGS(MAX_NUMNODES)) {\n\t\tfor (k = BITS_TO_LONGS(MAX_NUMNODES); k < nlongs; k++) {\n\t\t\tif (get_user(t, nmask + k))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (k == nlongs - 1) {\n\t\t\t\tif (t & endmask)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t} else if (t)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tnlongs = BITS_TO_LONGS(MAX_NUMNODES);\n\t\tendmask = ~0UL;\n\t}\n\n\tif (maxnode > MAX_NUMNODES && MAX_NUMNODES % BITS_PER_LONG != 0) {\n\t\tunsigned long valid_mask = endmask;\n\n\t\tvalid_mask &= ~((1UL << (MAX_NUMNODES % BITS_PER_LONG)) - 1);\n\t\tif (get_user(t, nmask + nlongs - 1))\n\t\t\treturn -EFAULT;\n\t\tif (t & valid_mask)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(nodes_addr(*nodes), nmask, nlongs*sizeof(unsigned long)))\n\t\treturn -EFAULT;\n\tnodes_addr(*nodes)[nlongs-1] &= endmask;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic long kernel_set_mempolicy(int mode, const unsigned long __user *nmask,\n\t\t\t\t unsigned long maxnode)\n{\n\tint err;\n\tnodemask_t nodes;\n\tunsigned short flags;\n\n\tflags = mode & MPOL_MODE_FLAGS;\n\tmode &= ~MPOL_MODE_FLAGS;\n\tif ((unsigned int)mode >= MPOL_MAX)\n\t\treturn -EINVAL;\n\tif ((flags & MPOL_F_STATIC_NODES) && (flags & MPOL_F_RELATIVE_NODES))\n\t\treturn -EINVAL;\n\terr = get_nodes(&nodes, nmask, maxnode);\n\tif (err)\n\t\treturn err;\n\treturn do_set_mempolicy(mode, flags, &nodes);\n}"
  },
  {
    "function_name": "kernel_mbind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1329-1348",
    "snippet": "static long kernel_mbind(unsigned long start, unsigned long len,\n\t\t\t unsigned long mode, const unsigned long __user *nmask,\n\t\t\t unsigned long maxnode, unsigned int flags)\n{\n\tnodemask_t nodes;\n\tint err;\n\tunsigned short mode_flags;\n\n\tmode_flags = mode & MPOL_MODE_FLAGS;\n\tmode &= ~MPOL_MODE_FLAGS;\n\tif (mode >= MPOL_MAX)\n\t\treturn -EINVAL;\n\tif ((mode_flags & MPOL_F_STATIC_NODES) &&\n\t    (mode_flags & MPOL_F_RELATIVE_NODES))\n\t\treturn -EINVAL;\n\terr = get_nodes(&nodes, nmask, maxnode);\n\tif (err)\n\t\treturn err;\n\treturn do_mbind(start, len, mode, mode_flags, &nodes, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_mbind",
          "args": [
            "start",
            "len",
            "mode",
            "mode_flags",
            "&nodes",
            "flags"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "do_mbind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1151-1245",
          "snippet": "static long do_mbind(unsigned long start, unsigned long len,\n\t\t     unsigned short mode, unsigned short mode_flags,\n\t\t     nodemask_t *nmask, unsigned long flags)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct mempolicy *new;\n\tunsigned long end;\n\tint err;\n\tLIST_HEAD(pagelist);\n\n\tif (flags & ~(unsigned long)MPOL_MF_VALID)\n\t\treturn -EINVAL;\n\tif ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))\n\t\treturn -EPERM;\n\n\tif (start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\n\tif (mode == MPOL_DEFAULT)\n\t\tflags &= ~MPOL_MF_STRICT;\n\n\tlen = (len + PAGE_SIZE - 1) & PAGE_MASK;\n\tend = start + len;\n\n\tif (end < start)\n\t\treturn -EINVAL;\n\tif (end == start)\n\t\treturn 0;\n\n\tnew = mpol_new(mode, mode_flags, nmask);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\tif (flags & MPOL_MF_LAZY)\n\t\tnew->flags |= MPOL_F_MOF;\n\n\t/*\n\t * If we are using the default policy then operation\n\t * on discontinuous address spaces is okay after all\n\t */\n\tif (!new)\n\t\tflags |= MPOL_MF_DISCONTIG_OK;\n\n\tpr_debug(\"mbind %lx-%lx mode:%d flags:%d nodes:%lx\\n\",\n\t\t start, start + len, mode, mode_flags,\n\t\t nmask ? nodes_addr(*nmask)[0] : NUMA_NO_NODE);\n\n\tif (flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL)) {\n\n\t\terr = migrate_prep();\n\t\tif (err)\n\t\t\tgoto mpol_out;\n\t}\n\t{\n\t\tNODEMASK_SCRATCH(scratch);\n\t\tif (scratch) {\n\t\t\tdown_write(&mm->mmap_sem);\n\t\t\ttask_lock(current);\n\t\t\terr = mpol_set_nodemask(new, nmask, scratch);\n\t\t\ttask_unlock(current);\n\t\t\tif (err)\n\t\t\t\tup_write(&mm->mmap_sem);\n\t\t} else\n\t\t\terr = -ENOMEM;\n\t\tNODEMASK_SCRATCH_FREE(scratch);\n\t}\n\tif (err)\n\t\tgoto mpol_out;\n\n\terr = queue_pages_range(mm, start, end, nmask,\n\t\t\t  flags | MPOL_MF_INVERT, &pagelist);\n\tif (!err)\n\t\terr = mbind_range(mm, start, end, new);\n\n\tif (!err) {\n\t\tint nr_failed = 0;\n\n\t\tif (!list_empty(&pagelist)) {\n\t\t\tWARN_ON_ONCE(flags & MPOL_MF_LAZY);\n\t\t\tnr_failed = migrate_pages(&pagelist, new_page, NULL,\n\t\t\t\tstart, MIGRATE_SYNC, MR_MEMPOLICY_MBIND);\n\t\t\tif (nr_failed)\n\t\t\t\tputback_movable_pages(&pagelist);\n\t\t}\n\n\t\tif (nr_failed && (flags & MPOL_MF_STRICT))\n\t\t\terr = -EIO;\n\t} else\n\t\tputback_movable_pages(&pagelist);\n\n\tup_write(&mm->mmap_sem);\n mpol_out:\n\tmpol_put(new);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [
            "#define MPOL_MF_INVERT (MPOL_MF_INTERNAL << 1)\t\t/* Invert check for nodemask */",
            "#define MPOL_MF_DISCONTIG_OK (MPOL_MF_INTERNAL << 0)\t/* Skip checks for continuous vmas */"
          ],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\n#define MPOL_MF_INVERT (MPOL_MF_INTERNAL << 1)\t\t/* Invert check for nodemask */\n#define MPOL_MF_DISCONTIG_OK (MPOL_MF_INTERNAL << 0)\t/* Skip checks for continuous vmas */\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic long do_mbind(unsigned long start, unsigned long len,\n\t\t     unsigned short mode, unsigned short mode_flags,\n\t\t     nodemask_t *nmask, unsigned long flags)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct mempolicy *new;\n\tunsigned long end;\n\tint err;\n\tLIST_HEAD(pagelist);\n\n\tif (flags & ~(unsigned long)MPOL_MF_VALID)\n\t\treturn -EINVAL;\n\tif ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))\n\t\treturn -EPERM;\n\n\tif (start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\n\tif (mode == MPOL_DEFAULT)\n\t\tflags &= ~MPOL_MF_STRICT;\n\n\tlen = (len + PAGE_SIZE - 1) & PAGE_MASK;\n\tend = start + len;\n\n\tif (end < start)\n\t\treturn -EINVAL;\n\tif (end == start)\n\t\treturn 0;\n\n\tnew = mpol_new(mode, mode_flags, nmask);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\tif (flags & MPOL_MF_LAZY)\n\t\tnew->flags |= MPOL_F_MOF;\n\n\t/*\n\t * If we are using the default policy then operation\n\t * on discontinuous address spaces is okay after all\n\t */\n\tif (!new)\n\t\tflags |= MPOL_MF_DISCONTIG_OK;\n\n\tpr_debug(\"mbind %lx-%lx mode:%d flags:%d nodes:%lx\\n\",\n\t\t start, start + len, mode, mode_flags,\n\t\t nmask ? nodes_addr(*nmask)[0] : NUMA_NO_NODE);\n\n\tif (flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL)) {\n\n\t\terr = migrate_prep();\n\t\tif (err)\n\t\t\tgoto mpol_out;\n\t}\n\t{\n\t\tNODEMASK_SCRATCH(scratch);\n\t\tif (scratch) {\n\t\t\tdown_write(&mm->mmap_sem);\n\t\t\ttask_lock(current);\n\t\t\terr = mpol_set_nodemask(new, nmask, scratch);\n\t\t\ttask_unlock(current);\n\t\t\tif (err)\n\t\t\t\tup_write(&mm->mmap_sem);\n\t\t} else\n\t\t\terr = -ENOMEM;\n\t\tNODEMASK_SCRATCH_FREE(scratch);\n\t}\n\tif (err)\n\t\tgoto mpol_out;\n\n\terr = queue_pages_range(mm, start, end, nmask,\n\t\t\t  flags | MPOL_MF_INVERT, &pagelist);\n\tif (!err)\n\t\terr = mbind_range(mm, start, end, new);\n\n\tif (!err) {\n\t\tint nr_failed = 0;\n\n\t\tif (!list_empty(&pagelist)) {\n\t\t\tWARN_ON_ONCE(flags & MPOL_MF_LAZY);\n\t\t\tnr_failed = migrate_pages(&pagelist, new_page, NULL,\n\t\t\t\tstart, MIGRATE_SYNC, MR_MEMPOLICY_MBIND);\n\t\t\tif (nr_failed)\n\t\t\t\tputback_movable_pages(&pagelist);\n\t\t}\n\n\t\tif (nr_failed && (flags & MPOL_MF_STRICT))\n\t\t\terr = -EIO;\n\t} else\n\t\tputback_movable_pages(&pagelist);\n\n\tup_write(&mm->mmap_sem);\n mpol_out:\n\tmpol_put(new);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nodes",
          "args": [
            "&nodes",
            "nmask",
            "maxnode"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "get_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1252-1310",
          "snippet": "static int get_nodes(nodemask_t *nodes, const unsigned long __user *nmask,\n\t\t     unsigned long maxnode)\n{\n\tunsigned long k;\n\tunsigned long t;\n\tunsigned long nlongs;\n\tunsigned long endmask;\n\n\t--maxnode;\n\tnodes_clear(*nodes);\n\tif (maxnode == 0 || !nmask)\n\t\treturn 0;\n\tif (maxnode > PAGE_SIZE*BITS_PER_BYTE)\n\t\treturn -EINVAL;\n\n\tnlongs = BITS_TO_LONGS(maxnode);\n\tif ((maxnode % BITS_PER_LONG) == 0)\n\t\tendmask = ~0UL;\n\telse\n\t\tendmask = (1UL << (maxnode % BITS_PER_LONG)) - 1;\n\n\t/*\n\t * When the user specified more nodes than supported just check\n\t * if the non supported part is all zero.\n\t *\n\t * If maxnode have more longs than MAX_NUMNODES, check\n\t * the bits in that area first. And then go through to\n\t * check the rest bits which equal or bigger than MAX_NUMNODES.\n\t * Otherwise, just check bits [MAX_NUMNODES, maxnode).\n\t */\n\tif (nlongs > BITS_TO_LONGS(MAX_NUMNODES)) {\n\t\tfor (k = BITS_TO_LONGS(MAX_NUMNODES); k < nlongs; k++) {\n\t\t\tif (get_user(t, nmask + k))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (k == nlongs - 1) {\n\t\t\t\tif (t & endmask)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t} else if (t)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tnlongs = BITS_TO_LONGS(MAX_NUMNODES);\n\t\tendmask = ~0UL;\n\t}\n\n\tif (maxnode > MAX_NUMNODES && MAX_NUMNODES % BITS_PER_LONG != 0) {\n\t\tunsigned long valid_mask = endmask;\n\n\t\tvalid_mask &= ~((1UL << (MAX_NUMNODES % BITS_PER_LONG)) - 1);\n\t\tif (get_user(t, nmask + nlongs - 1))\n\t\t\treturn -EFAULT;\n\t\tif (t & valid_mask)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(nodes_addr(*nodes), nmask, nlongs*sizeof(unsigned long)))\n\t\treturn -EFAULT;\n\tnodes_addr(*nodes)[nlongs-1] &= endmask;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic int get_nodes(nodemask_t *nodes, const unsigned long __user *nmask,\n\t\t     unsigned long maxnode)\n{\n\tunsigned long k;\n\tunsigned long t;\n\tunsigned long nlongs;\n\tunsigned long endmask;\n\n\t--maxnode;\n\tnodes_clear(*nodes);\n\tif (maxnode == 0 || !nmask)\n\t\treturn 0;\n\tif (maxnode > PAGE_SIZE*BITS_PER_BYTE)\n\t\treturn -EINVAL;\n\n\tnlongs = BITS_TO_LONGS(maxnode);\n\tif ((maxnode % BITS_PER_LONG) == 0)\n\t\tendmask = ~0UL;\n\telse\n\t\tendmask = (1UL << (maxnode % BITS_PER_LONG)) - 1;\n\n\t/*\n\t * When the user specified more nodes than supported just check\n\t * if the non supported part is all zero.\n\t *\n\t * If maxnode have more longs than MAX_NUMNODES, check\n\t * the bits in that area first. And then go through to\n\t * check the rest bits which equal or bigger than MAX_NUMNODES.\n\t * Otherwise, just check bits [MAX_NUMNODES, maxnode).\n\t */\n\tif (nlongs > BITS_TO_LONGS(MAX_NUMNODES)) {\n\t\tfor (k = BITS_TO_LONGS(MAX_NUMNODES); k < nlongs; k++) {\n\t\t\tif (get_user(t, nmask + k))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (k == nlongs - 1) {\n\t\t\t\tif (t & endmask)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t} else if (t)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tnlongs = BITS_TO_LONGS(MAX_NUMNODES);\n\t\tendmask = ~0UL;\n\t}\n\n\tif (maxnode > MAX_NUMNODES && MAX_NUMNODES % BITS_PER_LONG != 0) {\n\t\tunsigned long valid_mask = endmask;\n\n\t\tvalid_mask &= ~((1UL << (MAX_NUMNODES % BITS_PER_LONG)) - 1);\n\t\tif (get_user(t, nmask + nlongs - 1))\n\t\t\treturn -EFAULT;\n\t\tif (t & valid_mask)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(nodes_addr(*nodes), nmask, nlongs*sizeof(unsigned long)))\n\t\treturn -EFAULT;\n\tnodes_addr(*nodes)[nlongs-1] &= endmask;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic long kernel_mbind(unsigned long start, unsigned long len,\n\t\t\t unsigned long mode, const unsigned long __user *nmask,\n\t\t\t unsigned long maxnode, unsigned int flags)\n{\n\tnodemask_t nodes;\n\tint err;\n\tunsigned short mode_flags;\n\n\tmode_flags = mode & MPOL_MODE_FLAGS;\n\tmode &= ~MPOL_MODE_FLAGS;\n\tif (mode >= MPOL_MAX)\n\t\treturn -EINVAL;\n\tif ((mode_flags & MPOL_F_STATIC_NODES) &&\n\t    (mode_flags & MPOL_F_RELATIVE_NODES))\n\t\treturn -EINVAL;\n\terr = get_nodes(&nodes, nmask, maxnode);\n\tif (err)\n\t\treturn err;\n\treturn do_mbind(start, len, mode, mode_flags, &nodes, flags);\n}"
  },
  {
    "function_name": "copy_nodes_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1313-1327",
    "snippet": "static int copy_nodes_to_user(unsigned long __user *mask, unsigned long maxnode,\n\t\t\t      nodemask_t *nodes)\n{\n\tunsigned long copy = ALIGN(maxnode-1, 64) / 8;\n\tconst int nbytes = BITS_TO_LONGS(MAX_NUMNODES) * sizeof(long);\n\n\tif (copy > nbytes) {\n\t\tif (copy > PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\tif (clear_user((char __user *)mask + nbytes, copy - nbytes))\n\t\t\treturn -EFAULT;\n\t\tcopy = nbytes;\n\t}\n\treturn copy_to_user(mask, nodes_addr(*nodes), copy) ? -EFAULT : 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "mask",
            "nodes_addr(*nodes)",
            "copy"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_addr",
          "args": [
            "*nodes"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_user",
          "args": [
            "(char __user *)mask + nbytes",
            "copy - nbytes"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "MAX_NUMNODES"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "maxnode-1",
            "64"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic int copy_nodes_to_user(unsigned long __user *mask, unsigned long maxnode,\n\t\t\t      nodemask_t *nodes)\n{\n\tunsigned long copy = ALIGN(maxnode-1, 64) / 8;\n\tconst int nbytes = BITS_TO_LONGS(MAX_NUMNODES) * sizeof(long);\n\n\tif (copy > nbytes) {\n\t\tif (copy > PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\tif (clear_user((char __user *)mask + nbytes, copy - nbytes))\n\t\t\treturn -EFAULT;\n\t\tcopy = nbytes;\n\t}\n\treturn copy_to_user(mask, nodes_addr(*nodes), copy) ? -EFAULT : 0;\n}"
  },
  {
    "function_name": "get_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1252-1310",
    "snippet": "static int get_nodes(nodemask_t *nodes, const unsigned long __user *nmask,\n\t\t     unsigned long maxnode)\n{\n\tunsigned long k;\n\tunsigned long t;\n\tunsigned long nlongs;\n\tunsigned long endmask;\n\n\t--maxnode;\n\tnodes_clear(*nodes);\n\tif (maxnode == 0 || !nmask)\n\t\treturn 0;\n\tif (maxnode > PAGE_SIZE*BITS_PER_BYTE)\n\t\treturn -EINVAL;\n\n\tnlongs = BITS_TO_LONGS(maxnode);\n\tif ((maxnode % BITS_PER_LONG) == 0)\n\t\tendmask = ~0UL;\n\telse\n\t\tendmask = (1UL << (maxnode % BITS_PER_LONG)) - 1;\n\n\t/*\n\t * When the user specified more nodes than supported just check\n\t * if the non supported part is all zero.\n\t *\n\t * If maxnode have more longs than MAX_NUMNODES, check\n\t * the bits in that area first. And then go through to\n\t * check the rest bits which equal or bigger than MAX_NUMNODES.\n\t * Otherwise, just check bits [MAX_NUMNODES, maxnode).\n\t */\n\tif (nlongs > BITS_TO_LONGS(MAX_NUMNODES)) {\n\t\tfor (k = BITS_TO_LONGS(MAX_NUMNODES); k < nlongs; k++) {\n\t\t\tif (get_user(t, nmask + k))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (k == nlongs - 1) {\n\t\t\t\tif (t & endmask)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t} else if (t)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tnlongs = BITS_TO_LONGS(MAX_NUMNODES);\n\t\tendmask = ~0UL;\n\t}\n\n\tif (maxnode > MAX_NUMNODES && MAX_NUMNODES % BITS_PER_LONG != 0) {\n\t\tunsigned long valid_mask = endmask;\n\n\t\tvalid_mask &= ~((1UL << (MAX_NUMNODES % BITS_PER_LONG)) - 1);\n\t\tif (get_user(t, nmask + nlongs - 1))\n\t\t\treturn -EFAULT;\n\t\tif (t & valid_mask)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(nodes_addr(*nodes), nmask, nlongs*sizeof(unsigned long)))\n\t\treturn -EFAULT;\n\tnodes_addr(*nodes)[nlongs-1] &= endmask;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nodes_addr",
          "args": [
            "*nodes"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "nodes_addr(*nodes)",
            "nmask",
            "nlongs*sizeof(unsigned long)"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_addr",
          "args": [
            "*nodes"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "t",
            "nmask + nlongs - 1"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "MAX_NUMNODES"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "t",
            "nmask + k"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "MAX_NUMNODES"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "MAX_NUMNODES"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "maxnode"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_clear",
          "args": [
            "*nodes"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic int get_nodes(nodemask_t *nodes, const unsigned long __user *nmask,\n\t\t     unsigned long maxnode)\n{\n\tunsigned long k;\n\tunsigned long t;\n\tunsigned long nlongs;\n\tunsigned long endmask;\n\n\t--maxnode;\n\tnodes_clear(*nodes);\n\tif (maxnode == 0 || !nmask)\n\t\treturn 0;\n\tif (maxnode > PAGE_SIZE*BITS_PER_BYTE)\n\t\treturn -EINVAL;\n\n\tnlongs = BITS_TO_LONGS(maxnode);\n\tif ((maxnode % BITS_PER_LONG) == 0)\n\t\tendmask = ~0UL;\n\telse\n\t\tendmask = (1UL << (maxnode % BITS_PER_LONG)) - 1;\n\n\t/*\n\t * When the user specified more nodes than supported just check\n\t * if the non supported part is all zero.\n\t *\n\t * If maxnode have more longs than MAX_NUMNODES, check\n\t * the bits in that area first. And then go through to\n\t * check the rest bits which equal or bigger than MAX_NUMNODES.\n\t * Otherwise, just check bits [MAX_NUMNODES, maxnode).\n\t */\n\tif (nlongs > BITS_TO_LONGS(MAX_NUMNODES)) {\n\t\tfor (k = BITS_TO_LONGS(MAX_NUMNODES); k < nlongs; k++) {\n\t\t\tif (get_user(t, nmask + k))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (k == nlongs - 1) {\n\t\t\t\tif (t & endmask)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t} else if (t)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tnlongs = BITS_TO_LONGS(MAX_NUMNODES);\n\t\tendmask = ~0UL;\n\t}\n\n\tif (maxnode > MAX_NUMNODES && MAX_NUMNODES % BITS_PER_LONG != 0) {\n\t\tunsigned long valid_mask = endmask;\n\n\t\tvalid_mask &= ~((1UL << (MAX_NUMNODES % BITS_PER_LONG)) - 1);\n\t\tif (get_user(t, nmask + nlongs - 1))\n\t\t\treturn -EFAULT;\n\t\tif (t & valid_mask)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(nodes_addr(*nodes), nmask, nlongs*sizeof(unsigned long)))\n\t\treturn -EFAULT;\n\tnodes_addr(*nodes)[nlongs-1] &= endmask;\n\treturn 0;\n}"
  },
  {
    "function_name": "do_mbind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1151-1245",
    "snippet": "static long do_mbind(unsigned long start, unsigned long len,\n\t\t     unsigned short mode, unsigned short mode_flags,\n\t\t     nodemask_t *nmask, unsigned long flags)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct mempolicy *new;\n\tunsigned long end;\n\tint err;\n\tLIST_HEAD(pagelist);\n\n\tif (flags & ~(unsigned long)MPOL_MF_VALID)\n\t\treturn -EINVAL;\n\tif ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))\n\t\treturn -EPERM;\n\n\tif (start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\n\tif (mode == MPOL_DEFAULT)\n\t\tflags &= ~MPOL_MF_STRICT;\n\n\tlen = (len + PAGE_SIZE - 1) & PAGE_MASK;\n\tend = start + len;\n\n\tif (end < start)\n\t\treturn -EINVAL;\n\tif (end == start)\n\t\treturn 0;\n\n\tnew = mpol_new(mode, mode_flags, nmask);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\tif (flags & MPOL_MF_LAZY)\n\t\tnew->flags |= MPOL_F_MOF;\n\n\t/*\n\t * If we are using the default policy then operation\n\t * on discontinuous address spaces is okay after all\n\t */\n\tif (!new)\n\t\tflags |= MPOL_MF_DISCONTIG_OK;\n\n\tpr_debug(\"mbind %lx-%lx mode:%d flags:%d nodes:%lx\\n\",\n\t\t start, start + len, mode, mode_flags,\n\t\t nmask ? nodes_addr(*nmask)[0] : NUMA_NO_NODE);\n\n\tif (flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL)) {\n\n\t\terr = migrate_prep();\n\t\tif (err)\n\t\t\tgoto mpol_out;\n\t}\n\t{\n\t\tNODEMASK_SCRATCH(scratch);\n\t\tif (scratch) {\n\t\t\tdown_write(&mm->mmap_sem);\n\t\t\ttask_lock(current);\n\t\t\terr = mpol_set_nodemask(new, nmask, scratch);\n\t\t\ttask_unlock(current);\n\t\t\tif (err)\n\t\t\t\tup_write(&mm->mmap_sem);\n\t\t} else\n\t\t\terr = -ENOMEM;\n\t\tNODEMASK_SCRATCH_FREE(scratch);\n\t}\n\tif (err)\n\t\tgoto mpol_out;\n\n\terr = queue_pages_range(mm, start, end, nmask,\n\t\t\t  flags | MPOL_MF_INVERT, &pagelist);\n\tif (!err)\n\t\terr = mbind_range(mm, start, end, new);\n\n\tif (!err) {\n\t\tint nr_failed = 0;\n\n\t\tif (!list_empty(&pagelist)) {\n\t\t\tWARN_ON_ONCE(flags & MPOL_MF_LAZY);\n\t\t\tnr_failed = migrate_pages(&pagelist, new_page, NULL,\n\t\t\t\tstart, MIGRATE_SYNC, MR_MEMPOLICY_MBIND);\n\t\t\tif (nr_failed)\n\t\t\t\tputback_movable_pages(&pagelist);\n\t\t}\n\n\t\tif (nr_failed && (flags & MPOL_MF_STRICT))\n\t\t\terr = -EIO;\n\t} else\n\t\tputback_movable_pages(&pagelist);\n\n\tup_write(&mm->mmap_sem);\n mpol_out:\n\tmpol_put(new);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [
      "#define MPOL_MF_INVERT (MPOL_MF_INTERNAL << 1)\t\t/* Invert check for nodemask */",
      "#define MPOL_MF_DISCONTIG_OK (MPOL_MF_INTERNAL << 0)\t/* Skip checks for continuous vmas */"
    ],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpol_put",
          "args": [
            "new"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_put_task_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2345-2354",
          "snippet": "void mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nvoid mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putback_movable_pages",
          "args": [
            "&pagelist"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "putback_movable_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "167-198",
          "snippet": "void putback_movable_pages(struct list_head *l)\n{\n\tstruct page *page;\n\tstruct page *page2;\n\n\tlist_for_each_entry_safe(page, page2, l, lru) {\n\t\tif (unlikely(PageHuge(page))) {\n\t\t\tputback_active_hugepage(page);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&page->lru);\n\t\t/*\n\t\t * We isolated non-lru movable page so here we can use\n\t\t * __PageMovable because LRU page's mapping cannot have\n\t\t * PAGE_MAPPING_MOVABLE.\n\t\t */\n\t\tif (unlikely(__PageMovable(page))) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\t\tlock_page(page);\n\t\t\tif (PageMovable(page))\n\t\t\t\tputback_movable_page(page);\n\t\t\telse\n\t\t\t\t__ClearPageIsolated(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t} else {\n\t\t\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page), -hpage_nr_pages(page));\n\t\t\tputback_lru_page(page);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid putback_movable_pages(struct list_head *l)\n{\n\tstruct page *page;\n\tstruct page *page2;\n\n\tlist_for_each_entry_safe(page, page2, l, lru) {\n\t\tif (unlikely(PageHuge(page))) {\n\t\t\tputback_active_hugepage(page);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&page->lru);\n\t\t/*\n\t\t * We isolated non-lru movable page so here we can use\n\t\t * __PageMovable because LRU page's mapping cannot have\n\t\t * PAGE_MAPPING_MOVABLE.\n\t\t */\n\t\tif (unlikely(__PageMovable(page))) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\t\tlock_page(page);\n\t\t\tif (PageMovable(page))\n\t\t\t\tputback_movable_page(page);\n\t\t\telse\n\t\t\t\t__ClearPageIsolated(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t} else {\n\t\t\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page), -hpage_nr_pages(page));\n\t\t\tputback_lru_page(page);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "migrate_pages",
          "args": [
            "&pagelist",
            "new_page",
            "NULL",
            "start",
            "MIGRATE_SYNC",
            "MR_MEMPOLICY_MBIND"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "1362-1449",
          "snippet": "int migrate_pages(struct list_head *from, new_page_t get_new_page,\n\t\tfree_page_t put_new_page, unsigned long private,\n\t\tenum migrate_mode mode, int reason)\n{\n\tint retry = 1;\n\tint nr_failed = 0;\n\tint nr_succeeded = 0;\n\tint pass = 0;\n\tstruct page *page;\n\tstruct page *page2;\n\tint swapwrite = current->flags & PF_SWAPWRITE;\n\tint rc;\n\n\tif (!swapwrite)\n\t\tcurrent->flags |= PF_SWAPWRITE;\n\n\tfor(pass = 0; pass < 10 && retry; pass++) {\n\t\tretry = 0;\n\n\t\tlist_for_each_entry_safe(page, page2, from, lru) {\nretry:\n\t\t\tcond_resched();\n\n\t\t\tif (PageHuge(page))\n\t\t\t\trc = unmap_and_move_huge_page(get_new_page,\n\t\t\t\t\t\tput_new_page, private, page,\n\t\t\t\t\t\tpass > 2, mode, reason);\n\t\t\telse\n\t\t\t\trc = unmap_and_move(get_new_page, put_new_page,\n\t\t\t\t\t\tprivate, page, pass > 2, mode,\n\t\t\t\t\t\treason);\n\n\t\t\tswitch(rc) {\n\t\t\tcase -ENOMEM:\n\t\t\t\t/*\n\t\t\t\t * THP migration might be unsupported or the\n\t\t\t\t * allocation could've failed so we should\n\t\t\t\t * retry on the same page with the THP split\n\t\t\t\t * to base pages.\n\t\t\t\t *\n\t\t\t\t * Head page is retried immediately and tail\n\t\t\t\t * pages are added to the tail of the list so\n\t\t\t\t * we encounter them after the rest of the list\n\t\t\t\t * is processed.\n\t\t\t\t */\n\t\t\t\tif (PageTransHuge(page) && !PageHuge(page)) {\n\t\t\t\t\tlock_page(page);\n\t\t\t\t\trc = split_huge_page_to_list(page, from);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tif (!rc) {\n\t\t\t\t\t\tlist_safe_reset_next(page, page2, lru);\n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnr_failed++;\n\t\t\t\tgoto out;\n\t\t\tcase -EAGAIN:\n\t\t\t\tretry++;\n\t\t\t\tbreak;\n\t\t\tcase MIGRATEPAGE_SUCCESS:\n\t\t\t\tnr_succeeded++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Permanent failure (-EBUSY, -ENOSYS, etc.):\n\t\t\t\t * unlike -EAGAIN case, the failed page is\n\t\t\t\t * removed from migration page list and not\n\t\t\t\t * retried in the next outer loop.\n\t\t\t\t */\n\t\t\t\tnr_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tnr_failed += retry;\n\trc = nr_failed;\nout:\n\tif (nr_succeeded)\n\t\tcount_vm_events(PGMIGRATE_SUCCESS, nr_succeeded);\n\tif (nr_failed)\n\t\tcount_vm_events(PGMIGRATE_FAIL, nr_failed);\n\ttrace_mm_migrate_pages(nr_succeeded, nr_failed, mode, reason);\n\n\tif (!swapwrite)\n\t\tcurrent->flags &= ~PF_SWAPWRITE;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint migrate_pages(struct list_head *from, new_page_t get_new_page,\n\t\tfree_page_t put_new_page, unsigned long private,\n\t\tenum migrate_mode mode, int reason)\n{\n\tint retry = 1;\n\tint nr_failed = 0;\n\tint nr_succeeded = 0;\n\tint pass = 0;\n\tstruct page *page;\n\tstruct page *page2;\n\tint swapwrite = current->flags & PF_SWAPWRITE;\n\tint rc;\n\n\tif (!swapwrite)\n\t\tcurrent->flags |= PF_SWAPWRITE;\n\n\tfor(pass = 0; pass < 10 && retry; pass++) {\n\t\tretry = 0;\n\n\t\tlist_for_each_entry_safe(page, page2, from, lru) {\nretry:\n\t\t\tcond_resched();\n\n\t\t\tif (PageHuge(page))\n\t\t\t\trc = unmap_and_move_huge_page(get_new_page,\n\t\t\t\t\t\tput_new_page, private, page,\n\t\t\t\t\t\tpass > 2, mode, reason);\n\t\t\telse\n\t\t\t\trc = unmap_and_move(get_new_page, put_new_page,\n\t\t\t\t\t\tprivate, page, pass > 2, mode,\n\t\t\t\t\t\treason);\n\n\t\t\tswitch(rc) {\n\t\t\tcase -ENOMEM:\n\t\t\t\t/*\n\t\t\t\t * THP migration might be unsupported or the\n\t\t\t\t * allocation could've failed so we should\n\t\t\t\t * retry on the same page with the THP split\n\t\t\t\t * to base pages.\n\t\t\t\t *\n\t\t\t\t * Head page is retried immediately and tail\n\t\t\t\t * pages are added to the tail of the list so\n\t\t\t\t * we encounter them after the rest of the list\n\t\t\t\t * is processed.\n\t\t\t\t */\n\t\t\t\tif (PageTransHuge(page) && !PageHuge(page)) {\n\t\t\t\t\tlock_page(page);\n\t\t\t\t\trc = split_huge_page_to_list(page, from);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tif (!rc) {\n\t\t\t\t\t\tlist_safe_reset_next(page, page2, lru);\n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnr_failed++;\n\t\t\t\tgoto out;\n\t\t\tcase -EAGAIN:\n\t\t\t\tretry++;\n\t\t\t\tbreak;\n\t\t\tcase MIGRATEPAGE_SUCCESS:\n\t\t\t\tnr_succeeded++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Permanent failure (-EBUSY, -ENOSYS, etc.):\n\t\t\t\t * unlike -EAGAIN case, the failed page is\n\t\t\t\t * removed from migration page list and not\n\t\t\t\t * retried in the next outer loop.\n\t\t\t\t */\n\t\t\t\tnr_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tnr_failed += retry;\n\trc = nr_failed;\nout:\n\tif (nr_succeeded)\n\t\tcount_vm_events(PGMIGRATE_SUCCESS, nr_succeeded);\n\tif (nr_failed)\n\t\tcount_vm_events(PGMIGRATE_FAIL, nr_failed);\n\ttrace_mm_migrate_pages(nr_succeeded, nr_failed, mode, reason);\n\n\tif (!swapwrite)\n\t\tcurrent->flags &= ~PF_SWAPWRITE;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "flags & MPOL_MF_LAZY"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pagelist"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mbind_range",
          "args": [
            "mm",
            "start",
            "end",
            "new"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "mbind_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "677-735",
          "snippet": "static int mbind_range(struct mm_struct *mm, unsigned long start,\n\t\t       unsigned long end, struct mempolicy *new_pol)\n{\n\tstruct vm_area_struct *next;\n\tstruct vm_area_struct *prev;\n\tstruct vm_area_struct *vma;\n\tint err = 0;\n\tpgoff_t pgoff;\n\tunsigned long vmstart;\n\tunsigned long vmend;\n\n\tvma = find_vma(mm, start);\n\tif (!vma || vma->vm_start > start)\n\t\treturn -EFAULT;\n\n\tprev = vma->vm_prev;\n\tif (start > vma->vm_start)\n\t\tprev = vma;\n\n\tfor (; vma && vma->vm_start < end; prev = vma, vma = next) {\n\t\tnext = vma->vm_next;\n\t\tvmstart = max(start, vma->vm_start);\n\t\tvmend   = min(end, vma->vm_end);\n\n\t\tif (mpol_equal(vma_policy(vma), new_pol))\n\t\t\tcontinue;\n\n\t\tpgoff = vma->vm_pgoff +\n\t\t\t((vmstart - vma->vm_start) >> PAGE_SHIFT);\n\t\tprev = vma_merge(mm, prev, vmstart, vmend, vma->vm_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, pgoff,\n\t\t\t\t new_pol, vma->vm_userfaultfd_ctx);\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tnext = vma->vm_next;\n\t\t\tif (mpol_equal(vma_policy(vma), new_pol))\n\t\t\t\tcontinue;\n\t\t\t/* vma_merge() joined vma && vma->next, case 8 */\n\t\t\tgoto replace;\n\t\t}\n\t\tif (vma->vm_start != vmstart) {\n\t\t\terr = split_vma(vma->vm_mm, vma, vmstart, 1);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (vma->vm_end != vmend) {\n\t\t\terr = split_vma(vma->vm_mm, vma, vmend, 0);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n replace:\n\t\terr = vma_replace_policy(vma, new_pol);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n out:\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic int mbind_range(struct mm_struct *mm, unsigned long start,\n\t\t       unsigned long end, struct mempolicy *new_pol)\n{\n\tstruct vm_area_struct *next;\n\tstruct vm_area_struct *prev;\n\tstruct vm_area_struct *vma;\n\tint err = 0;\n\tpgoff_t pgoff;\n\tunsigned long vmstart;\n\tunsigned long vmend;\n\n\tvma = find_vma(mm, start);\n\tif (!vma || vma->vm_start > start)\n\t\treturn -EFAULT;\n\n\tprev = vma->vm_prev;\n\tif (start > vma->vm_start)\n\t\tprev = vma;\n\n\tfor (; vma && vma->vm_start < end; prev = vma, vma = next) {\n\t\tnext = vma->vm_next;\n\t\tvmstart = max(start, vma->vm_start);\n\t\tvmend   = min(end, vma->vm_end);\n\n\t\tif (mpol_equal(vma_policy(vma), new_pol))\n\t\t\tcontinue;\n\n\t\tpgoff = vma->vm_pgoff +\n\t\t\t((vmstart - vma->vm_start) >> PAGE_SHIFT);\n\t\tprev = vma_merge(mm, prev, vmstart, vmend, vma->vm_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, pgoff,\n\t\t\t\t new_pol, vma->vm_userfaultfd_ctx);\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tnext = vma->vm_next;\n\t\t\tif (mpol_equal(vma_policy(vma), new_pol))\n\t\t\t\tcontinue;\n\t\t\t/* vma_merge() joined vma && vma->next, case 8 */\n\t\t\tgoto replace;\n\t\t}\n\t\tif (vma->vm_start != vmstart) {\n\t\t\terr = split_vma(vma->vm_mm, vma, vmstart, 1);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (vma->vm_end != vmend) {\n\t\t\terr = split_vma(vma->vm_mm, vma, vmend, 0);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n replace:\n\t\terr = vma_replace_policy(vma, new_pol);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n out:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_pages_range",
          "args": [
            "mm",
            "start",
            "end",
            "nmask",
            "flags | MPOL_MF_INVERT",
            "&pagelist"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "queue_pages_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "618-638",
          "snippet": "static int\nqueue_pages_range(struct mm_struct *mm, unsigned long start, unsigned long end,\n\t\tnodemask_t *nodes, unsigned long flags,\n\t\tstruct list_head *pagelist)\n{\n\tstruct queue_pages qp = {\n\t\t.pagelist = pagelist,\n\t\t.flags = flags,\n\t\t.nmask = nodes,\n\t\t.prev = NULL,\n\t};\n\tstruct mm_walk queue_pages_walk = {\n\t\t.hugetlb_entry = queue_pages_hugetlb,\n\t\t.pmd_entry = queue_pages_pte_range,\n\t\t.test_walk = queue_pages_test_walk,\n\t\t.mm = mm,\n\t\t.private = &qp,\n\t};\n\n\treturn walk_page_range(start, end, &queue_pages_walk);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic int\nqueue_pages_range(struct mm_struct *mm, unsigned long start, unsigned long end,\n\t\tnodemask_t *nodes, unsigned long flags,\n\t\tstruct list_head *pagelist)\n{\n\tstruct queue_pages qp = {\n\t\t.pagelist = pagelist,\n\t\t.flags = flags,\n\t\t.nmask = nodes,\n\t\t.prev = NULL,\n\t};\n\tstruct mm_walk queue_pages_walk = {\n\t\t.hugetlb_entry = queue_pages_hugetlb,\n\t\t.pmd_entry = queue_pages_pte_range,\n\t\t.test_walk = queue_pages_test_walk,\n\t\t.mm = mm,\n\t\t.private = &qp,\n\t};\n\n\treturn walk_page_range(start, end, &queue_pages_walk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NODEMASK_SCRATCH_FREE",
          "args": [
            "scratch"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "current"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_set_nodemask",
          "args": [
            "new",
            "nmask",
            "scratch"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_set_nodemask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "203-236",
          "snippet": "static int mpol_set_nodemask(struct mempolicy *pol,\n\t\t     const nodemask_t *nodes, struct nodemask_scratch *nsc)\n{\n\tint ret;\n\n\t/* if mode is MPOL_DEFAULT, pol is NULL. This is right. */\n\tif (pol == NULL)\n\t\treturn 0;\n\t/* Check N_MEMORY */\n\tnodes_and(nsc->mask1,\n\t\t  cpuset_current_mems_allowed, node_states[N_MEMORY]);\n\n\tVM_BUG_ON(!nodes);\n\tif (pol->mode == MPOL_PREFERRED && nodes_empty(*nodes))\n\t\tnodes = NULL;\t/* explicit local allocation */\n\telse {\n\t\tif (pol->flags & MPOL_F_RELATIVE_NODES)\n\t\t\tmpol_relative_nodemask(&nsc->mask2, nodes, &nsc->mask1);\n\t\telse\n\t\t\tnodes_and(nsc->mask2, *nodes, nsc->mask1);\n\n\t\tif (mpol_store_user_nodemask(pol))\n\t\t\tpol->w.user_nodemask = *nodes;\n\t\telse\n\t\t\tpol->w.cpuset_mems_allowed =\n\t\t\t\t\t\tcpuset_current_mems_allowed;\n\t}\n\n\tif (nodes)\n\t\tret = mpol_ops[pol->mode].create(pol, &nsc->mask2);\n\telse\n\t\tret = mpol_ops[pol->mode].create(pol, NULL);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct mempolicy_operations {\n\tint (*create)(struct mempolicy *pol, const nodemask_t *nodes);\n\tvoid (*rebind)(struct mempolicy *pol, const nodemask_t *nodes);\n} mpol_ops[MPOL_MAX];",
            "static const struct mempolicy_operations mpol_ops[MPOL_MAX] = {\n\t[MPOL_DEFAULT] = {\n\t\t.rebind = mpol_rebind_default,\n\t},\n\t[MPOL_INTERLEAVE] = {\n\t\t.create = mpol_new_interleave,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n\t[MPOL_PREFERRED] = {\n\t\t.create = mpol_new_preferred,\n\t\t.rebind = mpol_rebind_preferred,\n\t},\n\t[MPOL_BIND] = {\n\t\t.create = mpol_new_bind,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n};",
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic const struct mempolicy_operations {\n\tint (*create)(struct mempolicy *pol, const nodemask_t *nodes);\n\tvoid (*rebind)(struct mempolicy *pol, const nodemask_t *nodes);\n} mpol_ops[MPOL_MAX];\nstatic const struct mempolicy_operations mpol_ops[MPOL_MAX] = {\n\t[MPOL_DEFAULT] = {\n\t\t.rebind = mpol_rebind_default,\n\t},\n\t[MPOL_INTERLEAVE] = {\n\t\t.create = mpol_new_interleave,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n\t[MPOL_PREFERRED] = {\n\t\t.create = mpol_new_preferred,\n\t\t.rebind = mpol_rebind_preferred,\n\t},\n\t[MPOL_BIND] = {\n\t\t.create = mpol_new_bind,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n};\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic int mpol_set_nodemask(struct mempolicy *pol,\n\t\t     const nodemask_t *nodes, struct nodemask_scratch *nsc)\n{\n\tint ret;\n\n\t/* if mode is MPOL_DEFAULT, pol is NULL. This is right. */\n\tif (pol == NULL)\n\t\treturn 0;\n\t/* Check N_MEMORY */\n\tnodes_and(nsc->mask1,\n\t\t  cpuset_current_mems_allowed, node_states[N_MEMORY]);\n\n\tVM_BUG_ON(!nodes);\n\tif (pol->mode == MPOL_PREFERRED && nodes_empty(*nodes))\n\t\tnodes = NULL;\t/* explicit local allocation */\n\telse {\n\t\tif (pol->flags & MPOL_F_RELATIVE_NODES)\n\t\t\tmpol_relative_nodemask(&nsc->mask2, nodes, &nsc->mask1);\n\t\telse\n\t\t\tnodes_and(nsc->mask2, *nodes, nsc->mask1);\n\n\t\tif (mpol_store_user_nodemask(pol))\n\t\t\tpol->w.user_nodemask = *nodes;\n\t\telse\n\t\t\tpol->w.cpuset_mems_allowed =\n\t\t\t\t\t\tcpuset_current_mems_allowed;\n\t}\n\n\tif (nodes)\n\t\tret = mpol_ops[pol->mode].create(pol, &nsc->mask2);\n\telse\n\t\tret = mpol_ops[pol->mode].create(pol, NULL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "current"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODEMASK_SCRATCH",
          "args": [
            "scratch"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_prep",
          "args": [],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_prep_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "77-82",
          "snippet": "int migrate_prep_local(void)\n{\n\tlru_add_drain();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint migrate_prep_local(void)\n{\n\tlru_add_drain();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"mbind %lx-%lx mode:%d flags:%d nodes:%lx\\n\"",
            "start",
            "start + len",
            "mode",
            "mode_flags",
            "nmask ? nodes_addr(*nmask)[0] : NUMA_NO_NODE"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_addr",
          "args": [
            "*nmask"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_new",
          "args": [
            "mode",
            "mode_flags",
            "nmask"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "242-284",
          "snippet": "static struct mempolicy *mpol_new(unsigned short mode, unsigned short flags,\n\t\t\t\t  nodemask_t *nodes)\n{\n\tstruct mempolicy *policy;\n\n\tpr_debug(\"setting mode %d flags %d nodes[0] %lx\\n\",\n\t\t mode, flags, nodes ? nodes_addr(*nodes)[0] : NUMA_NO_NODE);\n\n\tif (mode == MPOL_DEFAULT) {\n\t\tif (nodes && !nodes_empty(*nodes))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\treturn NULL;\n\t}\n\tVM_BUG_ON(!nodes);\n\n\t/*\n\t * MPOL_PREFERRED cannot be used with MPOL_F_STATIC_NODES or\n\t * MPOL_F_RELATIVE_NODES if the nodemask is empty (local allocation).\n\t * All other modes require a valid pointer to a non-empty nodemask.\n\t */\n\tif (mode == MPOL_PREFERRED) {\n\t\tif (nodes_empty(*nodes)) {\n\t\t\tif (((flags & MPOL_F_STATIC_NODES) ||\n\t\t\t     (flags & MPOL_F_RELATIVE_NODES)))\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t} else if (mode == MPOL_LOCAL) {\n\t\tif (!nodes_empty(*nodes) ||\n\t\t    (flags & MPOL_F_STATIC_NODES) ||\n\t\t    (flags & MPOL_F_RELATIVE_NODES))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tmode = MPOL_PREFERRED;\n\t} else if (nodes_empty(*nodes))\n\t\treturn ERR_PTR(-EINVAL);\n\tpolicy = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\tif (!policy)\n\t\treturn ERR_PTR(-ENOMEM);\n\tatomic_set(&policy->refcnt, 1);\n\tpolicy->mode = mode;\n\tpolicy->flags = flags;\n\n\treturn policy;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *policy_cache;",
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct kmem_cache *policy_cache;\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic struct mempolicy *mpol_new(unsigned short mode, unsigned short flags,\n\t\t\t\t  nodemask_t *nodes)\n{\n\tstruct mempolicy *policy;\n\n\tpr_debug(\"setting mode %d flags %d nodes[0] %lx\\n\",\n\t\t mode, flags, nodes ? nodes_addr(*nodes)[0] : NUMA_NO_NODE);\n\n\tif (mode == MPOL_DEFAULT) {\n\t\tif (nodes && !nodes_empty(*nodes))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\treturn NULL;\n\t}\n\tVM_BUG_ON(!nodes);\n\n\t/*\n\t * MPOL_PREFERRED cannot be used with MPOL_F_STATIC_NODES or\n\t * MPOL_F_RELATIVE_NODES if the nodemask is empty (local allocation).\n\t * All other modes require a valid pointer to a non-empty nodemask.\n\t */\n\tif (mode == MPOL_PREFERRED) {\n\t\tif (nodes_empty(*nodes)) {\n\t\t\tif (((flags & MPOL_F_STATIC_NODES) ||\n\t\t\t     (flags & MPOL_F_RELATIVE_NODES)))\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t} else if (mode == MPOL_LOCAL) {\n\t\tif (!nodes_empty(*nodes) ||\n\t\t    (flags & MPOL_F_STATIC_NODES) ||\n\t\t    (flags & MPOL_F_RELATIVE_NODES))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tmode = MPOL_PREFERRED;\n\t} else if (nodes_empty(*nodes))\n\t\treturn ERR_PTR(-EINVAL);\n\tpolicy = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\tif (!policy)\n\t\treturn ERR_PTR(-ENOMEM);\n\tatomic_set(&policy->refcnt, 1);\n\tpolicy->mode = mode;\n\tpolicy->flags = flags;\n\n\treturn policy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_NICE"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "pagelist"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\n#define MPOL_MF_INVERT (MPOL_MF_INTERNAL << 1)\t\t/* Invert check for nodemask */\n#define MPOL_MF_DISCONTIG_OK (MPOL_MF_INTERNAL << 0)\t/* Skip checks for continuous vmas */\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic long do_mbind(unsigned long start, unsigned long len,\n\t\t     unsigned short mode, unsigned short mode_flags,\n\t\t     nodemask_t *nmask, unsigned long flags)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct mempolicy *new;\n\tunsigned long end;\n\tint err;\n\tLIST_HEAD(pagelist);\n\n\tif (flags & ~(unsigned long)MPOL_MF_VALID)\n\t\treturn -EINVAL;\n\tif ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))\n\t\treturn -EPERM;\n\n\tif (start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\n\tif (mode == MPOL_DEFAULT)\n\t\tflags &= ~MPOL_MF_STRICT;\n\n\tlen = (len + PAGE_SIZE - 1) & PAGE_MASK;\n\tend = start + len;\n\n\tif (end < start)\n\t\treturn -EINVAL;\n\tif (end == start)\n\t\treturn 0;\n\n\tnew = mpol_new(mode, mode_flags, nmask);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\tif (flags & MPOL_MF_LAZY)\n\t\tnew->flags |= MPOL_F_MOF;\n\n\t/*\n\t * If we are using the default policy then operation\n\t * on discontinuous address spaces is okay after all\n\t */\n\tif (!new)\n\t\tflags |= MPOL_MF_DISCONTIG_OK;\n\n\tpr_debug(\"mbind %lx-%lx mode:%d flags:%d nodes:%lx\\n\",\n\t\t start, start + len, mode, mode_flags,\n\t\t nmask ? nodes_addr(*nmask)[0] : NUMA_NO_NODE);\n\n\tif (flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL)) {\n\n\t\terr = migrate_prep();\n\t\tif (err)\n\t\t\tgoto mpol_out;\n\t}\n\t{\n\t\tNODEMASK_SCRATCH(scratch);\n\t\tif (scratch) {\n\t\t\tdown_write(&mm->mmap_sem);\n\t\t\ttask_lock(current);\n\t\t\terr = mpol_set_nodemask(new, nmask, scratch);\n\t\t\ttask_unlock(current);\n\t\t\tif (err)\n\t\t\t\tup_write(&mm->mmap_sem);\n\t\t} else\n\t\t\terr = -ENOMEM;\n\t\tNODEMASK_SCRATCH_FREE(scratch);\n\t}\n\tif (err)\n\t\tgoto mpol_out;\n\n\terr = queue_pages_range(mm, start, end, nmask,\n\t\t\t  flags | MPOL_MF_INVERT, &pagelist);\n\tif (!err)\n\t\terr = mbind_range(mm, start, end, new);\n\n\tif (!err) {\n\t\tint nr_failed = 0;\n\n\t\tif (!list_empty(&pagelist)) {\n\t\t\tWARN_ON_ONCE(flags & MPOL_MF_LAZY);\n\t\t\tnr_failed = migrate_pages(&pagelist, new_page, NULL,\n\t\t\t\tstart, MIGRATE_SYNC, MR_MEMPOLICY_MBIND);\n\t\t\tif (nr_failed)\n\t\t\t\tputback_movable_pages(&pagelist);\n\t\t}\n\n\t\tif (nr_failed && (flags & MPOL_MF_STRICT))\n\t\t\terr = -EIO;\n\t} else\n\t\tputback_movable_pages(&pagelist);\n\n\tup_write(&mm->mmap_sem);\n mpol_out:\n\tmpol_put(new);\n\treturn err;\n}"
  },
  {
    "function_name": "new_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1145-1148",
    "snippet": "static struct page *new_page(struct page *page, unsigned long start)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct page *new_page(struct page *page, unsigned long start)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "do_migrate_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1139-1143",
    "snippet": "int do_migrate_pages(struct mm_struct *mm, const nodemask_t *from,\n\t\t     const nodemask_t *to, int flags)\n{\n\treturn -ENOSYS;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nint do_migrate_pages(struct mm_struct *mm, const nodemask_t *from,\n\t\t     const nodemask_t *to, int flags)\n{\n\treturn -ENOSYS;\n}"
  },
  {
    "function_name": "migrate_page_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1134-1137",
    "snippet": "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags)\n{\n}"
  },
  {
    "function_name": "new_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1100-1131",
    "snippet": "static struct page *new_page(struct page *page, unsigned long start)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long uninitialized_var(address);\n\n\tvma = find_vma(current->mm, start);\n\twhile (vma) {\n\t\taddress = page_address_in_vma(page, vma);\n\t\tif (address != -EFAULT)\n\t\t\tbreak;\n\t\tvma = vma->vm_next;\n\t}\n\n\tif (PageHuge(page)) {\n\t\treturn alloc_huge_page_vma(page_hstate(compound_head(page)),\n\t\t\t\tvma, address);\n\t} else if (PageTransHuge(page)) {\n\t\tstruct page *thp;\n\n\t\tthp = alloc_pages_vma(GFP_TRANSHUGE, HPAGE_PMD_ORDER, vma,\n\t\t\t\taddress, numa_node_id());\n\t\tif (!thp)\n\t\t\treturn NULL;\n\t\tprep_transhuge_page(thp);\n\t\treturn thp;\n\t}\n\t/*\n\t * if !vma, alloc_page_vma() will use task or system default policy\n\t */\n\treturn alloc_page_vma(GFP_HIGHUSER_MOVABLE | __GFP_RETRY_MAYFAIL,\n\t\t\tvma, address);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_page_vma",
          "args": [
            "GFP_HIGHUSER_MOVABLE | __GFP_RETRY_MAYFAIL",
            "vma",
            "address"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prep_transhuge_page",
          "args": [
            "thp"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "prep_transhuge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "490-499",
          "snippet": "void prep_transhuge_page(struct page *page)\n{\n\t/*\n\t * we use page->mapping and page->indexlru in second tail page\n\t * as list_head: assuming THP order >= 2\n\t */\n\n\tINIT_LIST_HEAD(page_deferred_list(page));\n\tset_compound_page_dtor(page, TRANSHUGE_PAGE_DTOR);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid prep_transhuge_page(struct page *page)\n{\n\t/*\n\t * we use page->mapping and page->indexlru in second tail page\n\t * as list_head: assuming THP order >= 2\n\t */\n\n\tINIT_LIST_HEAD(page_deferred_list(page));\n\tset_compound_page_dtor(page, TRANSHUGE_PAGE_DTOR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_pages_vma",
          "args": [
            "GFP_TRANSHUGE",
            "HPAGE_PMD_ORDER",
            "vma",
            "address",
            "numa_node_id()"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_pages_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2022-2048",
          "snippet": "struct page *\nalloc_pages_vma(gfp_t gfp, int order, struct vm_area_struct *vma,\n\t\tunsigned long addr, int node)\n{\n\tstruct mempolicy *pol;\n\tstruct page *page;\n\tint preferred_nid;\n\tnodemask_t *nmask;\n\n\tpol = get_vma_policy(vma, addr);\n\n\tif (pol->mode == MPOL_INTERLEAVE) {\n\t\tunsigned nid;\n\n\t\tnid = interleave_nid(pol, vma, addr, PAGE_SHIFT + order);\n\t\tmpol_cond_put(pol);\n\t\tpage = alloc_page_interleave(gfp, order, nid);\n\t\tgoto out;\n\t}\n\n\tnmask = policy_nodemask(gfp, pol);\n\tpreferred_nid = policy_node(gfp, pol, node);\n\tpage = __alloc_pages_nodemask(gfp, order, preferred_nid, nmask);\n\tmpol_cond_put(pol);\nout:\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstruct page *\nalloc_pages_vma(gfp_t gfp, int order, struct vm_area_struct *vma,\n\t\tunsigned long addr, int node)\n{\n\tstruct mempolicy *pol;\n\tstruct page *page;\n\tint preferred_nid;\n\tnodemask_t *nmask;\n\n\tpol = get_vma_policy(vma, addr);\n\n\tif (pol->mode == MPOL_INTERLEAVE) {\n\t\tunsigned nid;\n\n\t\tnid = interleave_nid(pol, vma, addr, PAGE_SHIFT + order);\n\t\tmpol_cond_put(pol);\n\t\tpage = alloc_page_interleave(gfp, order, nid);\n\t\tgoto out;\n\t}\n\n\tnmask = policy_nodemask(gfp, pol);\n\tpreferred_nid = policy_node(gfp, pol, node);\n\tpage = __alloc_pages_nodemask(gfp, order, preferred_nid, nmask);\n\tmpol_cond_put(pol);\nout:\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "numa_node_id",
          "args": [],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_huge_page_vma",
          "args": [
            "page_hstate(compound_head(page))",
            "vma",
            "address"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_huge_page_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1671-1686",
          "snippet": "struct page *alloc_huge_page_vma(struct hstate *h, struct vm_area_struct *vma,\n\t\tunsigned long address)\n{\n\tstruct mempolicy *mpol;\n\tnodemask_t *nodemask;\n\tstruct page *page;\n\tgfp_t gfp_mask;\n\tint node;\n\n\tgfp_mask = htlb_alloc_mask(h);\n\tnode = huge_node(vma, address, gfp_mask, &mpol, &nodemask);\n\tpage = alloc_huge_page_nodemask(h, node, nodemask);\n\tmpol_cond_put(mpol);\n\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct page *alloc_huge_page_vma(struct hstate *h, struct vm_area_struct *vma,\n\t\tunsigned long address)\n{\n\tstruct mempolicy *mpol;\n\tnodemask_t *nodemask;\n\tstruct page *page;\n\tgfp_t gfp_mask;\n\tint node;\n\n\tgfp_mask = htlb_alloc_mask(h);\n\tnode = huge_node(vma, address, gfp_mask, &mpol, &nodemask);\n\tpage = alloc_huge_page_nodemask(h, node, nodemask);\n\tmpol_cond_put(mpol);\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_hstate",
          "args": [
            "compound_head(page)"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address_in_vma",
          "args": [
            "page",
            "vma"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "page_address_in_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "687-708",
          "snippet": "unsigned long page_address_in_vma(struct page *page, struct vm_area_struct *vma)\n{\n\tunsigned long address;\n\tif (PageAnon(page)) {\n\t\tstruct anon_vma *page__anon_vma = page_anon_vma(page);\n\t\t/*\n\t\t * Note: swapoff's unuse_vma() is more efficient with this\n\t\t * check, and needs it to match anon_vma when KSM is active.\n\t\t */\n\t\tif (!vma->anon_vma || !page__anon_vma ||\n\t\t    vma->anon_vma->root != page__anon_vma->root)\n\t\t\treturn -EFAULT;\n\t} else if (page->mapping) {\n\t\tif (!vma->vm_file || vma->vm_file->f_mapping != page->mapping)\n\t\t\treturn -EFAULT;\n\t} else\n\t\treturn -EFAULT;\n\taddress = __vma_address(page, vma);\n\tif (unlikely(address < vma->vm_start || address >= vma->vm_end))\n\t\treturn -EFAULT;\n\treturn address;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long page_address_in_vma(struct page *page, struct vm_area_struct *vma)\n{\n\tunsigned long address;\n\tif (PageAnon(page)) {\n\t\tstruct anon_vma *page__anon_vma = page_anon_vma(page);\n\t\t/*\n\t\t * Note: swapoff's unuse_vma() is more efficient with this\n\t\t * check, and needs it to match anon_vma when KSM is active.\n\t\t */\n\t\tif (!vma->anon_vma || !page__anon_vma ||\n\t\t    vma->anon_vma->root != page__anon_vma->root)\n\t\t\treturn -EFAULT;\n\t} else if (page->mapping) {\n\t\tif (!vma->vm_file || vma->vm_file->f_mapping != page->mapping)\n\t\t\treturn -EFAULT;\n\t} else\n\t\treturn -EFAULT;\n\taddress = __vma_address(page, vma);\n\tif (unlikely(address < vma->vm_start || address >= vma->vm_end))\n\t\treturn -EFAULT;\n\treturn address;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "current->mm",
            "start"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "775-796",
          "snippet": "struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct page *new_page(struct page *page, unsigned long start)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long uninitialized_var(address);\n\n\tvma = find_vma(current->mm, start);\n\twhile (vma) {\n\t\taddress = page_address_in_vma(page, vma);\n\t\tif (address != -EFAULT)\n\t\t\tbreak;\n\t\tvma = vma->vm_next;\n\t}\n\n\tif (PageHuge(page)) {\n\t\treturn alloc_huge_page_vma(page_hstate(compound_head(page)),\n\t\t\t\tvma, address);\n\t} else if (PageTransHuge(page)) {\n\t\tstruct page *thp;\n\n\t\tthp = alloc_pages_vma(GFP_TRANSHUGE, HPAGE_PMD_ORDER, vma,\n\t\t\t\taddress, numa_node_id());\n\t\tif (!thp)\n\t\t\treturn NULL;\n\t\tprep_transhuge_page(thp);\n\t\treturn thp;\n\t}\n\t/*\n\t * if !vma, alloc_page_vma() will use task or system default policy\n\t */\n\treturn alloc_page_vma(GFP_HIGHUSER_MOVABLE | __GFP_RETRY_MAYFAIL,\n\t\t\tvma, address);\n}"
  },
  {
    "function_name": "do_migrate_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "994-1091",
    "snippet": "int do_migrate_pages(struct mm_struct *mm, const nodemask_t *from,\n\t\t     const nodemask_t *to, int flags)\n{\n\tint busy = 0;\n\tint err;\n\tnodemask_t tmp;\n\n\terr = migrate_prep();\n\tif (err)\n\t\treturn err;\n\n\tdown_read(&mm->mmap_sem);\n\n\t/*\n\t * Find a 'source' bit set in 'tmp' whose corresponding 'dest'\n\t * bit in 'to' is not also set in 'tmp'.  Clear the found 'source'\n\t * bit in 'tmp', and return that <source, dest> pair for migration.\n\t * The pair of nodemasks 'to' and 'from' define the map.\n\t *\n\t * If no pair of bits is found that way, fallback to picking some\n\t * pair of 'source' and 'dest' bits that are not the same.  If the\n\t * 'source' and 'dest' bits are the same, this represents a node\n\t * that will be migrating to itself, so no pages need move.\n\t *\n\t * If no bits are left in 'tmp', or if all remaining bits left\n\t * in 'tmp' correspond to the same bit in 'to', return false\n\t * (nothing left to migrate).\n\t *\n\t * This lets us pick a pair of nodes to migrate between, such that\n\t * if possible the dest node is not already occupied by some other\n\t * source node, minimizing the risk of overloading the memory on a\n\t * node that would happen if we migrated incoming memory to a node\n\t * before migrating outgoing memory source that same node.\n\t *\n\t * A single scan of tmp is sufficient.  As we go, we remember the\n\t * most recent <s, d> pair that moved (s != d).  If we find a pair\n\t * that not only moved, but what's better, moved to an empty slot\n\t * (d is not set in tmp), then we break out then, with that pair.\n\t * Otherwise when we finish scanning from_tmp, we at least have the\n\t * most recent <s, d> pair that moved.  If we get all the way through\n\t * the scan of tmp without finding any node that moved, much less\n\t * moved to an empty node, then there is nothing left worth migrating.\n\t */\n\n\ttmp = *from;\n\twhile (!nodes_empty(tmp)) {\n\t\tint s,d;\n\t\tint source = NUMA_NO_NODE;\n\t\tint dest = 0;\n\n\t\tfor_each_node_mask(s, tmp) {\n\n\t\t\t/*\n\t\t\t * do_migrate_pages() tries to maintain the relative\n\t\t\t * node relationship of the pages established between\n\t\t\t * threads and memory areas.\n                         *\n\t\t\t * However if the number of source nodes is not equal to\n\t\t\t * the number of destination nodes we can not preserve\n\t\t\t * this node relative relationship.  In that case, skip\n\t\t\t * copying memory from a node that is in the destination\n\t\t\t * mask.\n\t\t\t *\n\t\t\t * Example: [2,3,4] -> [3,4,5] moves everything.\n\t\t\t *          [0-7] - > [3,4,5] moves only 0,1,2,6,7.\n\t\t\t */\n\n\t\t\tif ((nodes_weight(*from) != nodes_weight(*to)) &&\n\t\t\t\t\t\t(node_isset(s, *to)))\n\t\t\t\tcontinue;\n\n\t\t\td = node_remap(s, *from, *to);\n\t\t\tif (s == d)\n\t\t\t\tcontinue;\n\n\t\t\tsource = s;\t/* Node moved. Memorize */\n\t\t\tdest = d;\n\n\t\t\t/* dest not in remaining from nodes? */\n\t\t\tif (!node_isset(dest, tmp))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (source == NUMA_NO_NODE)\n\t\t\tbreak;\n\n\t\tnode_clear(source, tmp);\n\t\terr = migrate_to_node(mm, source, dest, flags);\n\t\tif (err > 0)\n\t\t\tbusy += err;\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\tup_read(&mm->mmap_sem);\n\tif (err < 0)\n\t\treturn err;\n\treturn busy;\n\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_to_node",
          "args": [
            "mm",
            "source",
            "dest",
            "flags"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_to_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "959-986",
          "snippet": "static int migrate_to_node(struct mm_struct *mm, int source, int dest,\n\t\t\t   int flags)\n{\n\tnodemask_t nmask;\n\tLIST_HEAD(pagelist);\n\tint err = 0;\n\n\tnodes_clear(nmask);\n\tnode_set(source, nmask);\n\n\t/*\n\t * This does not \"check\" the range but isolates all pages that\n\t * need migration.  Between passing in the full user address\n\t * space range and MPOL_MF_DISCONTIG_OK, this call can not fail.\n\t */\n\tVM_BUG_ON(!(flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL)));\n\tqueue_pages_range(mm, mm->mmap->vm_start, mm->task_size, &nmask,\n\t\t\tflags | MPOL_MF_DISCONTIG_OK, &pagelist);\n\n\tif (!list_empty(&pagelist)) {\n\t\terr = migrate_pages(&pagelist, alloc_new_node_page, NULL, dest,\n\t\t\t\t\tMIGRATE_SYNC, MR_SYSCALL);\n\t\tif (err)\n\t\t\tputback_movable_pages(&pagelist);\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [
            "#define MPOL_MF_DISCONTIG_OK (MPOL_MF_INTERNAL << 0)\t/* Skip checks for continuous vmas */"
          ],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\n#define MPOL_MF_DISCONTIG_OK (MPOL_MF_INTERNAL << 0)\t/* Skip checks for continuous vmas */\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic int migrate_to_node(struct mm_struct *mm, int source, int dest,\n\t\t\t   int flags)\n{\n\tnodemask_t nmask;\n\tLIST_HEAD(pagelist);\n\tint err = 0;\n\n\tnodes_clear(nmask);\n\tnode_set(source, nmask);\n\n\t/*\n\t * This does not \"check\" the range but isolates all pages that\n\t * need migration.  Between passing in the full user address\n\t * space range and MPOL_MF_DISCONTIG_OK, this call can not fail.\n\t */\n\tVM_BUG_ON(!(flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL)));\n\tqueue_pages_range(mm, mm->mmap->vm_start, mm->task_size, &nmask,\n\t\t\tflags | MPOL_MF_DISCONTIG_OK, &pagelist);\n\n\tif (!list_empty(&pagelist)) {\n\t\terr = migrate_pages(&pagelist, alloc_new_node_page, NULL, dest,\n\t\t\t\t\tMIGRATE_SYNC, MR_SYSCALL);\n\t\tif (err)\n\t\t\tputback_movable_pages(&pagelist);\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_clear",
          "args": [
            "source",
            "tmp"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_isset",
          "args": [
            "dest",
            "tmp"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_remap",
          "args": [
            "s",
            "*from",
            "*to"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_isset",
          "args": [
            "s",
            "*to"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_weight",
          "args": [
            "*to"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_weight",
          "args": [
            "*from"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_node_mask",
          "args": [
            "s",
            "tmp"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_empty",
          "args": [
            "tmp"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_prep",
          "args": [],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_prep_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "77-82",
          "snippet": "int migrate_prep_local(void)\n{\n\tlru_add_drain();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint migrate_prep_local(void)\n{\n\tlru_add_drain();\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nint do_migrate_pages(struct mm_struct *mm, const nodemask_t *from,\n\t\t     const nodemask_t *to, int flags)\n{\n\tint busy = 0;\n\tint err;\n\tnodemask_t tmp;\n\n\terr = migrate_prep();\n\tif (err)\n\t\treturn err;\n\n\tdown_read(&mm->mmap_sem);\n\n\t/*\n\t * Find a 'source' bit set in 'tmp' whose corresponding 'dest'\n\t * bit in 'to' is not also set in 'tmp'.  Clear the found 'source'\n\t * bit in 'tmp', and return that <source, dest> pair for migration.\n\t * The pair of nodemasks 'to' and 'from' define the map.\n\t *\n\t * If no pair of bits is found that way, fallback to picking some\n\t * pair of 'source' and 'dest' bits that are not the same.  If the\n\t * 'source' and 'dest' bits are the same, this represents a node\n\t * that will be migrating to itself, so no pages need move.\n\t *\n\t * If no bits are left in 'tmp', or if all remaining bits left\n\t * in 'tmp' correspond to the same bit in 'to', return false\n\t * (nothing left to migrate).\n\t *\n\t * This lets us pick a pair of nodes to migrate between, such that\n\t * if possible the dest node is not already occupied by some other\n\t * source node, minimizing the risk of overloading the memory on a\n\t * node that would happen if we migrated incoming memory to a node\n\t * before migrating outgoing memory source that same node.\n\t *\n\t * A single scan of tmp is sufficient.  As we go, we remember the\n\t * most recent <s, d> pair that moved (s != d).  If we find a pair\n\t * that not only moved, but what's better, moved to an empty slot\n\t * (d is not set in tmp), then we break out then, with that pair.\n\t * Otherwise when we finish scanning from_tmp, we at least have the\n\t * most recent <s, d> pair that moved.  If we get all the way through\n\t * the scan of tmp without finding any node that moved, much less\n\t * moved to an empty node, then there is nothing left worth migrating.\n\t */\n\n\ttmp = *from;\n\twhile (!nodes_empty(tmp)) {\n\t\tint s,d;\n\t\tint source = NUMA_NO_NODE;\n\t\tint dest = 0;\n\n\t\tfor_each_node_mask(s, tmp) {\n\n\t\t\t/*\n\t\t\t * do_migrate_pages() tries to maintain the relative\n\t\t\t * node relationship of the pages established between\n\t\t\t * threads and memory areas.\n                         *\n\t\t\t * However if the number of source nodes is not equal to\n\t\t\t * the number of destination nodes we can not preserve\n\t\t\t * this node relative relationship.  In that case, skip\n\t\t\t * copying memory from a node that is in the destination\n\t\t\t * mask.\n\t\t\t *\n\t\t\t * Example: [2,3,4] -> [3,4,5] moves everything.\n\t\t\t *          [0-7] - > [3,4,5] moves only 0,1,2,6,7.\n\t\t\t */\n\n\t\t\tif ((nodes_weight(*from) != nodes_weight(*to)) &&\n\t\t\t\t\t\t(node_isset(s, *to)))\n\t\t\t\tcontinue;\n\n\t\t\td = node_remap(s, *from, *to);\n\t\t\tif (s == d)\n\t\t\t\tcontinue;\n\n\t\t\tsource = s;\t/* Node moved. Memorize */\n\t\t\tdest = d;\n\n\t\t\t/* dest not in remaining from nodes? */\n\t\t\tif (!node_isset(dest, tmp))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (source == NUMA_NO_NODE)\n\t\t\tbreak;\n\n\t\tnode_clear(source, tmp);\n\t\terr = migrate_to_node(mm, source, dest, flags);\n\t\tif (err > 0)\n\t\t\tbusy += err;\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\tup_read(&mm->mmap_sem);\n\tif (err < 0)\n\t\treturn err;\n\treturn busy;\n\n}"
  },
  {
    "function_name": "migrate_to_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "959-986",
    "snippet": "static int migrate_to_node(struct mm_struct *mm, int source, int dest,\n\t\t\t   int flags)\n{\n\tnodemask_t nmask;\n\tLIST_HEAD(pagelist);\n\tint err = 0;\n\n\tnodes_clear(nmask);\n\tnode_set(source, nmask);\n\n\t/*\n\t * This does not \"check\" the range but isolates all pages that\n\t * need migration.  Between passing in the full user address\n\t * space range and MPOL_MF_DISCONTIG_OK, this call can not fail.\n\t */\n\tVM_BUG_ON(!(flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL)));\n\tqueue_pages_range(mm, mm->mmap->vm_start, mm->task_size, &nmask,\n\t\t\tflags | MPOL_MF_DISCONTIG_OK, &pagelist);\n\n\tif (!list_empty(&pagelist)) {\n\t\terr = migrate_pages(&pagelist, alloc_new_node_page, NULL, dest,\n\t\t\t\t\tMIGRATE_SYNC, MR_SYSCALL);\n\t\tif (err)\n\t\t\tputback_movable_pages(&pagelist);\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [
      "#define MPOL_MF_DISCONTIG_OK (MPOL_MF_INTERNAL << 0)\t/* Skip checks for continuous vmas */"
    ],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "putback_movable_pages",
          "args": [
            "&pagelist"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "putback_movable_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "167-198",
          "snippet": "void putback_movable_pages(struct list_head *l)\n{\n\tstruct page *page;\n\tstruct page *page2;\n\n\tlist_for_each_entry_safe(page, page2, l, lru) {\n\t\tif (unlikely(PageHuge(page))) {\n\t\t\tputback_active_hugepage(page);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&page->lru);\n\t\t/*\n\t\t * We isolated non-lru movable page so here we can use\n\t\t * __PageMovable because LRU page's mapping cannot have\n\t\t * PAGE_MAPPING_MOVABLE.\n\t\t */\n\t\tif (unlikely(__PageMovable(page))) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\t\tlock_page(page);\n\t\t\tif (PageMovable(page))\n\t\t\t\tputback_movable_page(page);\n\t\t\telse\n\t\t\t\t__ClearPageIsolated(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t} else {\n\t\t\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page), -hpage_nr_pages(page));\n\t\t\tputback_lru_page(page);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid putback_movable_pages(struct list_head *l)\n{\n\tstruct page *page;\n\tstruct page *page2;\n\n\tlist_for_each_entry_safe(page, page2, l, lru) {\n\t\tif (unlikely(PageHuge(page))) {\n\t\t\tputback_active_hugepage(page);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&page->lru);\n\t\t/*\n\t\t * We isolated non-lru movable page so here we can use\n\t\t * __PageMovable because LRU page's mapping cannot have\n\t\t * PAGE_MAPPING_MOVABLE.\n\t\t */\n\t\tif (unlikely(__PageMovable(page))) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\t\tlock_page(page);\n\t\t\tif (PageMovable(page))\n\t\t\t\tputback_movable_page(page);\n\t\t\telse\n\t\t\t\t__ClearPageIsolated(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t} else {\n\t\t\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page), -hpage_nr_pages(page));\n\t\t\tputback_lru_page(page);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "migrate_pages",
          "args": [
            "&pagelist",
            "alloc_new_node_page",
            "NULL",
            "dest",
            "MIGRATE_SYNC",
            "MR_SYSCALL"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "1362-1449",
          "snippet": "int migrate_pages(struct list_head *from, new_page_t get_new_page,\n\t\tfree_page_t put_new_page, unsigned long private,\n\t\tenum migrate_mode mode, int reason)\n{\n\tint retry = 1;\n\tint nr_failed = 0;\n\tint nr_succeeded = 0;\n\tint pass = 0;\n\tstruct page *page;\n\tstruct page *page2;\n\tint swapwrite = current->flags & PF_SWAPWRITE;\n\tint rc;\n\n\tif (!swapwrite)\n\t\tcurrent->flags |= PF_SWAPWRITE;\n\n\tfor(pass = 0; pass < 10 && retry; pass++) {\n\t\tretry = 0;\n\n\t\tlist_for_each_entry_safe(page, page2, from, lru) {\nretry:\n\t\t\tcond_resched();\n\n\t\t\tif (PageHuge(page))\n\t\t\t\trc = unmap_and_move_huge_page(get_new_page,\n\t\t\t\t\t\tput_new_page, private, page,\n\t\t\t\t\t\tpass > 2, mode, reason);\n\t\t\telse\n\t\t\t\trc = unmap_and_move(get_new_page, put_new_page,\n\t\t\t\t\t\tprivate, page, pass > 2, mode,\n\t\t\t\t\t\treason);\n\n\t\t\tswitch(rc) {\n\t\t\tcase -ENOMEM:\n\t\t\t\t/*\n\t\t\t\t * THP migration might be unsupported or the\n\t\t\t\t * allocation could've failed so we should\n\t\t\t\t * retry on the same page with the THP split\n\t\t\t\t * to base pages.\n\t\t\t\t *\n\t\t\t\t * Head page is retried immediately and tail\n\t\t\t\t * pages are added to the tail of the list so\n\t\t\t\t * we encounter them after the rest of the list\n\t\t\t\t * is processed.\n\t\t\t\t */\n\t\t\t\tif (PageTransHuge(page) && !PageHuge(page)) {\n\t\t\t\t\tlock_page(page);\n\t\t\t\t\trc = split_huge_page_to_list(page, from);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tif (!rc) {\n\t\t\t\t\t\tlist_safe_reset_next(page, page2, lru);\n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnr_failed++;\n\t\t\t\tgoto out;\n\t\t\tcase -EAGAIN:\n\t\t\t\tretry++;\n\t\t\t\tbreak;\n\t\t\tcase MIGRATEPAGE_SUCCESS:\n\t\t\t\tnr_succeeded++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Permanent failure (-EBUSY, -ENOSYS, etc.):\n\t\t\t\t * unlike -EAGAIN case, the failed page is\n\t\t\t\t * removed from migration page list and not\n\t\t\t\t * retried in the next outer loop.\n\t\t\t\t */\n\t\t\t\tnr_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tnr_failed += retry;\n\trc = nr_failed;\nout:\n\tif (nr_succeeded)\n\t\tcount_vm_events(PGMIGRATE_SUCCESS, nr_succeeded);\n\tif (nr_failed)\n\t\tcount_vm_events(PGMIGRATE_FAIL, nr_failed);\n\ttrace_mm_migrate_pages(nr_succeeded, nr_failed, mode, reason);\n\n\tif (!swapwrite)\n\t\tcurrent->flags &= ~PF_SWAPWRITE;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint migrate_pages(struct list_head *from, new_page_t get_new_page,\n\t\tfree_page_t put_new_page, unsigned long private,\n\t\tenum migrate_mode mode, int reason)\n{\n\tint retry = 1;\n\tint nr_failed = 0;\n\tint nr_succeeded = 0;\n\tint pass = 0;\n\tstruct page *page;\n\tstruct page *page2;\n\tint swapwrite = current->flags & PF_SWAPWRITE;\n\tint rc;\n\n\tif (!swapwrite)\n\t\tcurrent->flags |= PF_SWAPWRITE;\n\n\tfor(pass = 0; pass < 10 && retry; pass++) {\n\t\tretry = 0;\n\n\t\tlist_for_each_entry_safe(page, page2, from, lru) {\nretry:\n\t\t\tcond_resched();\n\n\t\t\tif (PageHuge(page))\n\t\t\t\trc = unmap_and_move_huge_page(get_new_page,\n\t\t\t\t\t\tput_new_page, private, page,\n\t\t\t\t\t\tpass > 2, mode, reason);\n\t\t\telse\n\t\t\t\trc = unmap_and_move(get_new_page, put_new_page,\n\t\t\t\t\t\tprivate, page, pass > 2, mode,\n\t\t\t\t\t\treason);\n\n\t\t\tswitch(rc) {\n\t\t\tcase -ENOMEM:\n\t\t\t\t/*\n\t\t\t\t * THP migration might be unsupported or the\n\t\t\t\t * allocation could've failed so we should\n\t\t\t\t * retry on the same page with the THP split\n\t\t\t\t * to base pages.\n\t\t\t\t *\n\t\t\t\t * Head page is retried immediately and tail\n\t\t\t\t * pages are added to the tail of the list so\n\t\t\t\t * we encounter them after the rest of the list\n\t\t\t\t * is processed.\n\t\t\t\t */\n\t\t\t\tif (PageTransHuge(page) && !PageHuge(page)) {\n\t\t\t\t\tlock_page(page);\n\t\t\t\t\trc = split_huge_page_to_list(page, from);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tif (!rc) {\n\t\t\t\t\t\tlist_safe_reset_next(page, page2, lru);\n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnr_failed++;\n\t\t\t\tgoto out;\n\t\t\tcase -EAGAIN:\n\t\t\t\tretry++;\n\t\t\t\tbreak;\n\t\t\tcase MIGRATEPAGE_SUCCESS:\n\t\t\t\tnr_succeeded++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Permanent failure (-EBUSY, -ENOSYS, etc.):\n\t\t\t\t * unlike -EAGAIN case, the failed page is\n\t\t\t\t * removed from migration page list and not\n\t\t\t\t * retried in the next outer loop.\n\t\t\t\t */\n\t\t\t\tnr_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tnr_failed += retry;\n\trc = nr_failed;\nout:\n\tif (nr_succeeded)\n\t\tcount_vm_events(PGMIGRATE_SUCCESS, nr_succeeded);\n\tif (nr_failed)\n\t\tcount_vm_events(PGMIGRATE_FAIL, nr_failed);\n\ttrace_mm_migrate_pages(nr_succeeded, nr_failed, mode, reason);\n\n\tif (!swapwrite)\n\t\tcurrent->flags &= ~PF_SWAPWRITE;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pagelist"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_pages_range",
          "args": [
            "mm",
            "mm->mmap->vm_start",
            "mm->task_size",
            "&nmask",
            "flags | MPOL_MF_DISCONTIG_OK",
            "&pagelist"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "queue_pages_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "618-638",
          "snippet": "static int\nqueue_pages_range(struct mm_struct *mm, unsigned long start, unsigned long end,\n\t\tnodemask_t *nodes, unsigned long flags,\n\t\tstruct list_head *pagelist)\n{\n\tstruct queue_pages qp = {\n\t\t.pagelist = pagelist,\n\t\t.flags = flags,\n\t\t.nmask = nodes,\n\t\t.prev = NULL,\n\t};\n\tstruct mm_walk queue_pages_walk = {\n\t\t.hugetlb_entry = queue_pages_hugetlb,\n\t\t.pmd_entry = queue_pages_pte_range,\n\t\t.test_walk = queue_pages_test_walk,\n\t\t.mm = mm,\n\t\t.private = &qp,\n\t};\n\n\treturn walk_page_range(start, end, &queue_pages_walk);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic int\nqueue_pages_range(struct mm_struct *mm, unsigned long start, unsigned long end,\n\t\tnodemask_t *nodes, unsigned long flags,\n\t\tstruct list_head *pagelist)\n{\n\tstruct queue_pages qp = {\n\t\t.pagelist = pagelist,\n\t\t.flags = flags,\n\t\t.nmask = nodes,\n\t\t.prev = NULL,\n\t};\n\tstruct mm_walk queue_pages_walk = {\n\t\t.hugetlb_entry = queue_pages_hugetlb,\n\t\t.pmd_entry = queue_pages_pte_range,\n\t\t.test_walk = queue_pages_test_walk,\n\t\t.mm = mm,\n\t\t.private = &qp,\n\t};\n\n\treturn walk_page_range(start, end, &queue_pages_walk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!(flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL))"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_set",
          "args": [
            "source",
            "nmask"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_clear",
          "args": [
            "nmask"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "pagelist"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\n#define MPOL_MF_DISCONTIG_OK (MPOL_MF_INTERNAL << 0)\t/* Skip checks for continuous vmas */\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic int migrate_to_node(struct mm_struct *mm, int source, int dest,\n\t\t\t   int flags)\n{\n\tnodemask_t nmask;\n\tLIST_HEAD(pagelist);\n\tint err = 0;\n\n\tnodes_clear(nmask);\n\tnode_set(source, nmask);\n\n\t/*\n\t * This does not \"check\" the range but isolates all pages that\n\t * need migration.  Between passing in the full user address\n\t * space range and MPOL_MF_DISCONTIG_OK, this call can not fail.\n\t */\n\tVM_BUG_ON(!(flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL)));\n\tqueue_pages_range(mm, mm->mmap->vm_start, mm->task_size, &nmask,\n\t\t\tflags | MPOL_MF_DISCONTIG_OK, &pagelist);\n\n\tif (!list_empty(&pagelist)) {\n\t\terr = migrate_pages(&pagelist, alloc_new_node_page, NULL, dest,\n\t\t\t\t\tMIGRATE_SYNC, MR_SYSCALL);\n\t\tif (err)\n\t\t\tputback_movable_pages(&pagelist);\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "alloc_new_node_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "935-953",
    "snippet": "struct page *alloc_new_node_page(struct page *page, unsigned long node)\n{\n\tif (PageHuge(page))\n\t\treturn alloc_huge_page_node(page_hstate(compound_head(page)),\n\t\t\t\t\tnode);\n\telse if (PageTransHuge(page)) {\n\t\tstruct page *thp;\n\n\t\tthp = alloc_pages_node(node,\n\t\t\t(GFP_TRANSHUGE | __GFP_THISNODE),\n\t\t\tHPAGE_PMD_ORDER);\n\t\tif (!thp)\n\t\t\treturn NULL;\n\t\tprep_transhuge_page(thp);\n\t\treturn thp;\n\t} else\n\t\treturn __alloc_pages_node(node, GFP_HIGHUSER_MOVABLE |\n\t\t\t\t\t\t    __GFP_THISNODE, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__alloc_pages_node",
          "args": [
            "node",
            "GFP_HIGHUSER_MOVABLE |\n\t\t\t\t\t\t    __GFP_THISNODE",
            "0"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prep_transhuge_page",
          "args": [
            "thp"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "prep_transhuge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "490-499",
          "snippet": "void prep_transhuge_page(struct page *page)\n{\n\t/*\n\t * we use page->mapping and page->indexlru in second tail page\n\t * as list_head: assuming THP order >= 2\n\t */\n\n\tINIT_LIST_HEAD(page_deferred_list(page));\n\tset_compound_page_dtor(page, TRANSHUGE_PAGE_DTOR);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid prep_transhuge_page(struct page *page)\n{\n\t/*\n\t * we use page->mapping and page->indexlru in second tail page\n\t * as list_head: assuming THP order >= 2\n\t */\n\n\tINIT_LIST_HEAD(page_deferred_list(page));\n\tset_compound_page_dtor(page, TRANSHUGE_PAGE_DTOR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_pages_node",
          "args": [
            "node",
            "(GFP_TRANSHUGE | __GFP_THISNODE)",
            "HPAGE_PMD_ORDER"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_huge_page_node",
          "args": [
            "page_hstate(compound_head(page))",
            "node"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_huge_page_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1630-1647",
          "snippet": "struct page *alloc_huge_page_node(struct hstate *h, int nid)\n{\n\tgfp_t gfp_mask = htlb_alloc_mask(h);\n\tstruct page *page = NULL;\n\n\tif (nid != NUMA_NO_NODE)\n\t\tgfp_mask |= __GFP_THISNODE;\n\n\tspin_lock(&hugetlb_lock);\n\tif (h->free_huge_pages - h->resv_huge_pages > 0)\n\t\tpage = dequeue_huge_page_nodemask(h, gfp_mask, nid, NULL);\n\tspin_unlock(&hugetlb_lock);\n\n\tif (!page)\n\t\tpage = alloc_migrate_huge_page(h, gfp_mask, nid, NULL);\n\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct page *alloc_huge_page_node(struct hstate *h, int nid)\n{\n\tgfp_t gfp_mask = htlb_alloc_mask(h);\n\tstruct page *page = NULL;\n\n\tif (nid != NUMA_NO_NODE)\n\t\tgfp_mask |= __GFP_THISNODE;\n\n\tspin_lock(&hugetlb_lock);\n\tif (h->free_huge_pages - h->resv_huge_pages > 0)\n\t\tpage = dequeue_huge_page_nodemask(h, gfp_mask, nid, NULL);\n\tspin_unlock(&hugetlb_lock);\n\n\tif (!page)\n\t\tpage = alloc_migrate_huge_page(h, gfp_mask, nid, NULL);\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_hstate",
          "args": [
            "compound_head(page)"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstruct page *alloc_new_node_page(struct page *page, unsigned long node)\n{\n\tif (PageHuge(page))\n\t\treturn alloc_huge_page_node(page_hstate(compound_head(page)),\n\t\t\t\t\tnode);\n\telse if (PageTransHuge(page)) {\n\t\tstruct page *thp;\n\n\t\tthp = alloc_pages_node(node,\n\t\t\t(GFP_TRANSHUGE | __GFP_THISNODE),\n\t\t\tHPAGE_PMD_ORDER);\n\t\tif (!thp)\n\t\t\treturn NULL;\n\t\tprep_transhuge_page(thp);\n\t\treturn thp;\n\t} else\n\t\treturn __alloc_pages_node(node, GFP_HIGHUSER_MOVABLE |\n\t\t\t\t\t\t    __GFP_THISNODE, 0);\n}"
  },
  {
    "function_name": "migrate_page_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "917-932",
    "snippet": "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags)\n{\n\tstruct page *head = compound_head(page);\n\t/*\n\t * Avoid migrating a page that is shared with others.\n\t */\n\tif ((flags & MPOL_MF_MOVE_ALL) || page_mapcount(head) == 1) {\n\t\tif (!isolate_lru_page(head)) {\n\t\t\tlist_add_tail(&head->lru, pagelist);\n\t\t\tmod_node_page_state(page_pgdat(head),\n\t\t\t\tNR_ISOLATED_ANON + page_is_file_cache(head),\n\t\t\t\thpage_nr_pages(head));\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_node_page_state",
          "args": [
            "page_pgdat(head)",
            "NR_ISOLATED_ANON + page_is_file_cache(head)",
            "hpage_nr_pages(head)"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "mod_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "644-652",
          "snippet": "void mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\t\tlong delta)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__mod_node_page_state(pgdat, item, delta);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\t\tlong delta)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__mod_node_page_state(pgdat, item, delta);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "head"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_file_cache",
          "args": [
            "head"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_pgdat",
          "args": [
            "head"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&head->lru",
            "pagelist"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isolate_lru_page",
          "args": [
            "head"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1772-1795",
          "snippet": "int isolate_lru_page(struct page *page)\n{\n\tint ret = -EBUSY;\n\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tWARN_RATELIMIT(PageTail(page), \"trying to isolate tail page\");\n\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\n\t\tspin_lock_irq(zone_lru_lock(zone));\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tif (PageLRU(page)) {\n\t\t\tint lru = page_lru(page);\n\t\t\tget_page(page);\n\t\t\tClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint isolate_lru_page(struct page *page)\n{\n\tint ret = -EBUSY;\n\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tWARN_RATELIMIT(PageTail(page), \"trying to isolate tail page\");\n\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\n\t\tspin_lock_irq(zone_lru_lock(zone));\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tif (PageLRU(page)) {\n\t\t\tint lru = page_lru(page);\n\t\t\tget_page(page);\n\t\t\tClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "head"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags)\n{\n\tstruct page *head = compound_head(page);\n\t/*\n\t * Avoid migrating a page that is shared with others.\n\t */\n\tif ((flags & MPOL_MF_MOVE_ALL) || page_mapcount(head) == 1) {\n\t\tif (!isolate_lru_page(head)) {\n\t\t\tlist_add_tail(&head->lru, pagelist);\n\t\t\tmod_node_page_state(page_pgdat(head),\n\t\t\t\tNR_ISOLATED_ANON + page_is_file_cache(head),\n\t\t\t\thpage_nr_pages(head));\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "do_get_mempolicy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "817-911",
    "snippet": "static long do_get_mempolicy(int *policy, nodemask_t *nmask,\n\t\t\t     unsigned long addr, unsigned long flags)\n{\n\tint err;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = NULL;\n\tstruct mempolicy *pol = current->mempolicy, *pol_refcount = NULL;\n\n\tif (flags &\n\t\t~(unsigned long)(MPOL_F_NODE|MPOL_F_ADDR|MPOL_F_MEMS_ALLOWED))\n\t\treturn -EINVAL;\n\n\tif (flags & MPOL_F_MEMS_ALLOWED) {\n\t\tif (flags & (MPOL_F_NODE|MPOL_F_ADDR))\n\t\t\treturn -EINVAL;\n\t\t*policy = 0;\t/* just so it's initialized */\n\t\ttask_lock(current);\n\t\t*nmask  = cpuset_current_mems_allowed;\n\t\ttask_unlock(current);\n\t\treturn 0;\n\t}\n\n\tif (flags & MPOL_F_ADDR) {\n\t\t/*\n\t\t * Do NOT fall back to task policy if the\n\t\t * vma/shared policy at addr is NULL.  We\n\t\t * want to return MPOL_DEFAULT in this case.\n\t\t */\n\t\tdown_read(&mm->mmap_sem);\n\t\tvma = find_vma_intersection(mm, addr, addr+1);\n\t\tif (!vma) {\n\t\t\tup_read(&mm->mmap_sem);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (vma->vm_ops && vma->vm_ops->get_policy)\n\t\t\tpol = vma->vm_ops->get_policy(vma, addr);\n\t\telse\n\t\t\tpol = vma->vm_policy;\n\t} else if (addr)\n\t\treturn -EINVAL;\n\n\tif (!pol)\n\t\tpol = &default_policy;\t/* indicates default behavior */\n\n\tif (flags & MPOL_F_NODE) {\n\t\tif (flags & MPOL_F_ADDR) {\n\t\t\t/*\n\t\t\t * Take a refcount on the mpol, lookup_node()\n\t\t\t * wil drop the mmap_sem, so after calling\n\t\t\t * lookup_node() only \"pol\" remains valid, \"vma\"\n\t\t\t * is stale.\n\t\t\t */\n\t\t\tpol_refcount = pol;\n\t\t\tvma = NULL;\n\t\t\tmpol_get(pol);\n\t\t\terr = lookup_node(mm, addr);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t\t*policy = err;\n\t\t} else if (pol == current->mempolicy &&\n\t\t\t\tpol->mode == MPOL_INTERLEAVE) {\n\t\t\t*policy = next_node_in(current->il_prev, pol->v.nodes);\n\t\t} else {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t*policy = pol == &default_policy ? MPOL_DEFAULT :\n\t\t\t\t\t\tpol->mode;\n\t\t/*\n\t\t * Internal mempolicy flags must be masked off before exposing\n\t\t * the policy to userspace.\n\t\t */\n\t\t*policy |= (pol->flags & MPOL_MODE_FLAGS);\n\t}\n\n\terr = 0;\n\tif (nmask) {\n\t\tif (mpol_store_user_nodemask(pol)) {\n\t\t\t*nmask = pol->w.user_nodemask;\n\t\t} else {\n\t\t\ttask_lock(current);\n\t\t\tget_policy_nodemask(pol, nmask);\n\t\t\ttask_unlock(current);\n\t\t}\n\t}\n\n out:\n\tmpol_cond_put(pol);\n\tif (vma)\n\t\tup_read(&mm->mmap_sem);\n\tif (pol_refcount)\n\t\tmpol_put(pol_refcount);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct mempolicy default_policy = {\n\t.refcnt = ATOMIC_INIT(1), /* never free it */\n\t.mode = MPOL_PREFERRED,\n\t.flags = MPOL_F_LOCAL,\n};",
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpol_put",
          "args": [
            "pol_refcount"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_put_task_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2345-2354",
          "snippet": "void mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nvoid mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_cond_put",
          "args": [
            "pol"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "current"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_policy_nodemask",
          "args": [
            "pol",
            "nmask"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "get_policy_nodemask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "778-798",
          "snippet": "static void get_policy_nodemask(struct mempolicy *p, nodemask_t *nodes)\n{\n\tnodes_clear(*nodes);\n\tif (p == &default_policy)\n\t\treturn;\n\n\tswitch (p->mode) {\n\tcase MPOL_BIND:\n\t\t/* Fall through */\n\tcase MPOL_INTERLEAVE:\n\t\t*nodes = p->v.nodes;\n\t\tbreak;\n\tcase MPOL_PREFERRED:\n\t\tif (!(p->flags & MPOL_F_LOCAL))\n\t\t\tnode_set(p->v.preferred_node, *nodes);\n\t\t/* else return empty node mask for local allocation */\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct mempolicy default_policy = {\n\t.refcnt = ATOMIC_INIT(1), /* never free it */\n\t.mode = MPOL_PREFERRED,\n\t.flags = MPOL_F_LOCAL,\n};",
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct mempolicy default_policy = {\n\t.refcnt = ATOMIC_INIT(1), /* never free it */\n\t.mode = MPOL_PREFERRED,\n\t.flags = MPOL_F_LOCAL,\n};\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic void get_policy_nodemask(struct mempolicy *p, nodemask_t *nodes)\n{\n\tnodes_clear(*nodes);\n\tif (p == &default_policy)\n\t\treturn;\n\n\tswitch (p->mode) {\n\tcase MPOL_BIND:\n\t\t/* Fall through */\n\tcase MPOL_INTERLEAVE:\n\t\t*nodes = p->v.nodes;\n\t\tbreak;\n\tcase MPOL_PREFERRED:\n\t\tif (!(p->flags & MPOL_F_LOCAL))\n\t\t\tnode_set(p->v.preferred_node, *nodes);\n\t\t/* else return empty node mask for local allocation */\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "current"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_store_user_nodemask",
          "args": [
            "pol"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_store_user_nodemask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "154-157",
          "snippet": "static inline int mpol_store_user_nodemask(const struct mempolicy *pol)\n{\n\treturn pol->flags & MPOL_MODE_FLAGS;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic inline int mpol_store_user_nodemask(const struct mempolicy *pol)\n{\n\treturn pol->flags & MPOL_MODE_FLAGS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_node_in",
          "args": [
            "current->il_prev",
            "pol->v.nodes"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_node",
          "args": [
            "mm",
            "addr"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "800-814",
          "snippet": "static int lookup_node(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct page *p;\n\tint err;\n\n\tint locked = 1;\n\terr = get_user_pages_locked(addr & PAGE_MASK, 1, 0, &p, &locked);\n\tif (err >= 0) {\n\t\terr = page_to_nid(p);\n\t\tput_page(p);\n\t}\n\tif (locked)\n\t\tup_read(&mm->mmap_sem);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic int lookup_node(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct page *p;\n\tint err;\n\n\tint locked = 1;\n\terr = get_user_pages_locked(addr & PAGE_MASK, 1, 0, &p, &locked);\n\tif (err >= 0) {\n\t\terr = page_to_nid(p);\n\t\tput_page(p);\n\t}\n\tif (locked)\n\t\tup_read(&mm->mmap_sem);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mpol_get",
          "args": [
            "pol"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma->vm_ops->get_policy",
          "args": [
            "vma",
            "addr"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_vma_intersection",
          "args": [
            "mm",
            "addr",
            "addr+1"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "current"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "current"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct mempolicy default_policy = {\n\t.refcnt = ATOMIC_INIT(1), /* never free it */\n\t.mode = MPOL_PREFERRED,\n\t.flags = MPOL_F_LOCAL,\n};\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic long do_get_mempolicy(int *policy, nodemask_t *nmask,\n\t\t\t     unsigned long addr, unsigned long flags)\n{\n\tint err;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = NULL;\n\tstruct mempolicy *pol = current->mempolicy, *pol_refcount = NULL;\n\n\tif (flags &\n\t\t~(unsigned long)(MPOL_F_NODE|MPOL_F_ADDR|MPOL_F_MEMS_ALLOWED))\n\t\treturn -EINVAL;\n\n\tif (flags & MPOL_F_MEMS_ALLOWED) {\n\t\tif (flags & (MPOL_F_NODE|MPOL_F_ADDR))\n\t\t\treturn -EINVAL;\n\t\t*policy = 0;\t/* just so it's initialized */\n\t\ttask_lock(current);\n\t\t*nmask  = cpuset_current_mems_allowed;\n\t\ttask_unlock(current);\n\t\treturn 0;\n\t}\n\n\tif (flags & MPOL_F_ADDR) {\n\t\t/*\n\t\t * Do NOT fall back to task policy if the\n\t\t * vma/shared policy at addr is NULL.  We\n\t\t * want to return MPOL_DEFAULT in this case.\n\t\t */\n\t\tdown_read(&mm->mmap_sem);\n\t\tvma = find_vma_intersection(mm, addr, addr+1);\n\t\tif (!vma) {\n\t\t\tup_read(&mm->mmap_sem);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (vma->vm_ops && vma->vm_ops->get_policy)\n\t\t\tpol = vma->vm_ops->get_policy(vma, addr);\n\t\telse\n\t\t\tpol = vma->vm_policy;\n\t} else if (addr)\n\t\treturn -EINVAL;\n\n\tif (!pol)\n\t\tpol = &default_policy;\t/* indicates default behavior */\n\n\tif (flags & MPOL_F_NODE) {\n\t\tif (flags & MPOL_F_ADDR) {\n\t\t\t/*\n\t\t\t * Take a refcount on the mpol, lookup_node()\n\t\t\t * wil drop the mmap_sem, so after calling\n\t\t\t * lookup_node() only \"pol\" remains valid, \"vma\"\n\t\t\t * is stale.\n\t\t\t */\n\t\t\tpol_refcount = pol;\n\t\t\tvma = NULL;\n\t\t\tmpol_get(pol);\n\t\t\terr = lookup_node(mm, addr);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t\t*policy = err;\n\t\t} else if (pol == current->mempolicy &&\n\t\t\t\tpol->mode == MPOL_INTERLEAVE) {\n\t\t\t*policy = next_node_in(current->il_prev, pol->v.nodes);\n\t\t} else {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t*policy = pol == &default_policy ? MPOL_DEFAULT :\n\t\t\t\t\t\tpol->mode;\n\t\t/*\n\t\t * Internal mempolicy flags must be masked off before exposing\n\t\t * the policy to userspace.\n\t\t */\n\t\t*policy |= (pol->flags & MPOL_MODE_FLAGS);\n\t}\n\n\terr = 0;\n\tif (nmask) {\n\t\tif (mpol_store_user_nodemask(pol)) {\n\t\t\t*nmask = pol->w.user_nodemask;\n\t\t} else {\n\t\t\ttask_lock(current);\n\t\t\tget_policy_nodemask(pol, nmask);\n\t\t\ttask_unlock(current);\n\t\t}\n\t}\n\n out:\n\tmpol_cond_put(pol);\n\tif (vma)\n\t\tup_read(&mm->mmap_sem);\n\tif (pol_refcount)\n\t\tmpol_put(pol_refcount);\n\treturn err;\n}"
  },
  {
    "function_name": "lookup_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "800-814",
    "snippet": "static int lookup_node(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct page *p;\n\tint err;\n\n\tint locked = 1;\n\terr = get_user_pages_locked(addr & PAGE_MASK, 1, 0, &p, &locked);\n\tif (err >= 0) {\n\t\terr = page_to_nid(p);\n\t\tput_page(p);\n\t}\n\tif (locked)\n\t\tup_read(&mm->mmap_sem);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "p"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "p"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user_pages_locked",
          "args": [
            "addr & PAGE_MASK",
            "1",
            "0",
            "&p",
            "&locked"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_pages_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "172-177",
          "snippet": "long get_user_pages_locked(unsigned long start, unsigned long nr_pages,\n\t\t\t    unsigned int gup_flags, struct page **pages,\n\t\t\t    int *locked)\n{\n\treturn get_user_pages(start, nr_pages, gup_flags, pages, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nlong get_user_pages_locked(unsigned long start, unsigned long nr_pages,\n\t\t\t    unsigned int gup_flags, struct page **pages,\n\t\t\t    int *locked)\n{\n\treturn get_user_pages(start, nr_pages, gup_flags, pages, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic int lookup_node(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct page *p;\n\tint err;\n\n\tint locked = 1;\n\terr = get_user_pages_locked(addr & PAGE_MASK, 1, 0, &p, &locked);\n\tif (err >= 0) {\n\t\terr = page_to_nid(p);\n\t\tput_page(p);\n\t}\n\tif (locked)\n\t\tup_read(&mm->mmap_sem);\n\treturn err;\n}"
  },
  {
    "function_name": "get_policy_nodemask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "778-798",
    "snippet": "static void get_policy_nodemask(struct mempolicy *p, nodemask_t *nodes)\n{\n\tnodes_clear(*nodes);\n\tif (p == &default_policy)\n\t\treturn;\n\n\tswitch (p->mode) {\n\tcase MPOL_BIND:\n\t\t/* Fall through */\n\tcase MPOL_INTERLEAVE:\n\t\t*nodes = p->v.nodes;\n\t\tbreak;\n\tcase MPOL_PREFERRED:\n\t\tif (!(p->flags & MPOL_F_LOCAL))\n\t\t\tnode_set(p->v.preferred_node, *nodes);\n\t\t/* else return empty node mask for local allocation */\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct mempolicy default_policy = {\n\t.refcnt = ATOMIC_INIT(1), /* never free it */\n\t.mode = MPOL_PREFERRED,\n\t.flags = MPOL_F_LOCAL,\n};",
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_set",
          "args": [
            "p->v.preferred_node",
            "*nodes"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_clear",
          "args": [
            "*nodes"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct mempolicy default_policy = {\n\t.refcnt = ATOMIC_INIT(1), /* never free it */\n\t.mode = MPOL_PREFERRED,\n\t.flags = MPOL_F_LOCAL,\n};\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic void get_policy_nodemask(struct mempolicy *p, nodemask_t *nodes)\n{\n\tnodes_clear(*nodes);\n\tif (p == &default_policy)\n\t\treturn;\n\n\tswitch (p->mode) {\n\tcase MPOL_BIND:\n\t\t/* Fall through */\n\tcase MPOL_INTERLEAVE:\n\t\t*nodes = p->v.nodes;\n\t\tbreak;\n\tcase MPOL_PREFERRED:\n\t\tif (!(p->flags & MPOL_F_LOCAL))\n\t\t\tnode_set(p->v.preferred_node, *nodes);\n\t\t/* else return empty node mask for local allocation */\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "do_set_mempolicy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "738-771",
    "snippet": "static long do_set_mempolicy(unsigned short mode, unsigned short flags,\n\t\t\t     nodemask_t *nodes)\n{\n\tstruct mempolicy *new, *old;\n\tNODEMASK_SCRATCH(scratch);\n\tint ret;\n\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\n\tnew = mpol_new(mode, flags, nodes);\n\tif (IS_ERR(new)) {\n\t\tret = PTR_ERR(new);\n\t\tgoto out;\n\t}\n\n\ttask_lock(current);\n\tret = mpol_set_nodemask(new, nodes, scratch);\n\tif (ret) {\n\t\ttask_unlock(current);\n\t\tmpol_put(new);\n\t\tgoto out;\n\t}\n\told = current->mempolicy;\n\tcurrent->mempolicy = new;\n\tif (new && new->mode == MPOL_INTERLEAVE)\n\t\tcurrent->il_prev = MAX_NUMNODES-1;\n\ttask_unlock(current);\n\tmpol_put(old);\n\tret = 0;\nout:\n\tNODEMASK_SCRATCH_FREE(scratch);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NODEMASK_SCRATCH_FREE",
          "args": [
            "scratch"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_put",
          "args": [
            "old"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_put_task_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2345-2354",
          "snippet": "void mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nvoid mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "current"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "current"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_set_nodemask",
          "args": [
            "new",
            "nodes",
            "scratch"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_set_nodemask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "203-236",
          "snippet": "static int mpol_set_nodemask(struct mempolicy *pol,\n\t\t     const nodemask_t *nodes, struct nodemask_scratch *nsc)\n{\n\tint ret;\n\n\t/* if mode is MPOL_DEFAULT, pol is NULL. This is right. */\n\tif (pol == NULL)\n\t\treturn 0;\n\t/* Check N_MEMORY */\n\tnodes_and(nsc->mask1,\n\t\t  cpuset_current_mems_allowed, node_states[N_MEMORY]);\n\n\tVM_BUG_ON(!nodes);\n\tif (pol->mode == MPOL_PREFERRED && nodes_empty(*nodes))\n\t\tnodes = NULL;\t/* explicit local allocation */\n\telse {\n\t\tif (pol->flags & MPOL_F_RELATIVE_NODES)\n\t\t\tmpol_relative_nodemask(&nsc->mask2, nodes, &nsc->mask1);\n\t\telse\n\t\t\tnodes_and(nsc->mask2, *nodes, nsc->mask1);\n\n\t\tif (mpol_store_user_nodemask(pol))\n\t\t\tpol->w.user_nodemask = *nodes;\n\t\telse\n\t\t\tpol->w.cpuset_mems_allowed =\n\t\t\t\t\t\tcpuset_current_mems_allowed;\n\t}\n\n\tif (nodes)\n\t\tret = mpol_ops[pol->mode].create(pol, &nsc->mask2);\n\telse\n\t\tret = mpol_ops[pol->mode].create(pol, NULL);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct mempolicy_operations {\n\tint (*create)(struct mempolicy *pol, const nodemask_t *nodes);\n\tvoid (*rebind)(struct mempolicy *pol, const nodemask_t *nodes);\n} mpol_ops[MPOL_MAX];",
            "static const struct mempolicy_operations mpol_ops[MPOL_MAX] = {\n\t[MPOL_DEFAULT] = {\n\t\t.rebind = mpol_rebind_default,\n\t},\n\t[MPOL_INTERLEAVE] = {\n\t\t.create = mpol_new_interleave,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n\t[MPOL_PREFERRED] = {\n\t\t.create = mpol_new_preferred,\n\t\t.rebind = mpol_rebind_preferred,\n\t},\n\t[MPOL_BIND] = {\n\t\t.create = mpol_new_bind,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n};",
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic const struct mempolicy_operations {\n\tint (*create)(struct mempolicy *pol, const nodemask_t *nodes);\n\tvoid (*rebind)(struct mempolicy *pol, const nodemask_t *nodes);\n} mpol_ops[MPOL_MAX];\nstatic const struct mempolicy_operations mpol_ops[MPOL_MAX] = {\n\t[MPOL_DEFAULT] = {\n\t\t.rebind = mpol_rebind_default,\n\t},\n\t[MPOL_INTERLEAVE] = {\n\t\t.create = mpol_new_interleave,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n\t[MPOL_PREFERRED] = {\n\t\t.create = mpol_new_preferred,\n\t\t.rebind = mpol_rebind_preferred,\n\t},\n\t[MPOL_BIND] = {\n\t\t.create = mpol_new_bind,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n};\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic int mpol_set_nodemask(struct mempolicy *pol,\n\t\t     const nodemask_t *nodes, struct nodemask_scratch *nsc)\n{\n\tint ret;\n\n\t/* if mode is MPOL_DEFAULT, pol is NULL. This is right. */\n\tif (pol == NULL)\n\t\treturn 0;\n\t/* Check N_MEMORY */\n\tnodes_and(nsc->mask1,\n\t\t  cpuset_current_mems_allowed, node_states[N_MEMORY]);\n\n\tVM_BUG_ON(!nodes);\n\tif (pol->mode == MPOL_PREFERRED && nodes_empty(*nodes))\n\t\tnodes = NULL;\t/* explicit local allocation */\n\telse {\n\t\tif (pol->flags & MPOL_F_RELATIVE_NODES)\n\t\t\tmpol_relative_nodemask(&nsc->mask2, nodes, &nsc->mask1);\n\t\telse\n\t\t\tnodes_and(nsc->mask2, *nodes, nsc->mask1);\n\n\t\tif (mpol_store_user_nodemask(pol))\n\t\t\tpol->w.user_nodemask = *nodes;\n\t\telse\n\t\t\tpol->w.cpuset_mems_allowed =\n\t\t\t\t\t\tcpuset_current_mems_allowed;\n\t}\n\n\tif (nodes)\n\t\tret = mpol_ops[pol->mode].create(pol, &nsc->mask2);\n\telse\n\t\tret = mpol_ops[pol->mode].create(pol, NULL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "current"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_new",
          "args": [
            "mode",
            "flags",
            "nodes"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "242-284",
          "snippet": "static struct mempolicy *mpol_new(unsigned short mode, unsigned short flags,\n\t\t\t\t  nodemask_t *nodes)\n{\n\tstruct mempolicy *policy;\n\n\tpr_debug(\"setting mode %d flags %d nodes[0] %lx\\n\",\n\t\t mode, flags, nodes ? nodes_addr(*nodes)[0] : NUMA_NO_NODE);\n\n\tif (mode == MPOL_DEFAULT) {\n\t\tif (nodes && !nodes_empty(*nodes))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\treturn NULL;\n\t}\n\tVM_BUG_ON(!nodes);\n\n\t/*\n\t * MPOL_PREFERRED cannot be used with MPOL_F_STATIC_NODES or\n\t * MPOL_F_RELATIVE_NODES if the nodemask is empty (local allocation).\n\t * All other modes require a valid pointer to a non-empty nodemask.\n\t */\n\tif (mode == MPOL_PREFERRED) {\n\t\tif (nodes_empty(*nodes)) {\n\t\t\tif (((flags & MPOL_F_STATIC_NODES) ||\n\t\t\t     (flags & MPOL_F_RELATIVE_NODES)))\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t} else if (mode == MPOL_LOCAL) {\n\t\tif (!nodes_empty(*nodes) ||\n\t\t    (flags & MPOL_F_STATIC_NODES) ||\n\t\t    (flags & MPOL_F_RELATIVE_NODES))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tmode = MPOL_PREFERRED;\n\t} else if (nodes_empty(*nodes))\n\t\treturn ERR_PTR(-EINVAL);\n\tpolicy = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\tif (!policy)\n\t\treturn ERR_PTR(-ENOMEM);\n\tatomic_set(&policy->refcnt, 1);\n\tpolicy->mode = mode;\n\tpolicy->flags = flags;\n\n\treturn policy;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *policy_cache;",
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct kmem_cache *policy_cache;\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic struct mempolicy *mpol_new(unsigned short mode, unsigned short flags,\n\t\t\t\t  nodemask_t *nodes)\n{\n\tstruct mempolicy *policy;\n\n\tpr_debug(\"setting mode %d flags %d nodes[0] %lx\\n\",\n\t\t mode, flags, nodes ? nodes_addr(*nodes)[0] : NUMA_NO_NODE);\n\n\tif (mode == MPOL_DEFAULT) {\n\t\tif (nodes && !nodes_empty(*nodes))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\treturn NULL;\n\t}\n\tVM_BUG_ON(!nodes);\n\n\t/*\n\t * MPOL_PREFERRED cannot be used with MPOL_F_STATIC_NODES or\n\t * MPOL_F_RELATIVE_NODES if the nodemask is empty (local allocation).\n\t * All other modes require a valid pointer to a non-empty nodemask.\n\t */\n\tif (mode == MPOL_PREFERRED) {\n\t\tif (nodes_empty(*nodes)) {\n\t\t\tif (((flags & MPOL_F_STATIC_NODES) ||\n\t\t\t     (flags & MPOL_F_RELATIVE_NODES)))\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t} else if (mode == MPOL_LOCAL) {\n\t\tif (!nodes_empty(*nodes) ||\n\t\t    (flags & MPOL_F_STATIC_NODES) ||\n\t\t    (flags & MPOL_F_RELATIVE_NODES))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tmode = MPOL_PREFERRED;\n\t} else if (nodes_empty(*nodes))\n\t\treturn ERR_PTR(-EINVAL);\n\tpolicy = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\tif (!policy)\n\t\treturn ERR_PTR(-ENOMEM);\n\tatomic_set(&policy->refcnt, 1);\n\tpolicy->mode = mode;\n\tpolicy->flags = flags;\n\n\treturn policy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NODEMASK_SCRATCH",
          "args": [
            "scratch"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic long do_set_mempolicy(unsigned short mode, unsigned short flags,\n\t\t\t     nodemask_t *nodes)\n{\n\tstruct mempolicy *new, *old;\n\tNODEMASK_SCRATCH(scratch);\n\tint ret;\n\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\n\tnew = mpol_new(mode, flags, nodes);\n\tif (IS_ERR(new)) {\n\t\tret = PTR_ERR(new);\n\t\tgoto out;\n\t}\n\n\ttask_lock(current);\n\tret = mpol_set_nodemask(new, nodes, scratch);\n\tif (ret) {\n\t\ttask_unlock(current);\n\t\tmpol_put(new);\n\t\tgoto out;\n\t}\n\told = current->mempolicy;\n\tcurrent->mempolicy = new;\n\tif (new && new->mode == MPOL_INTERLEAVE)\n\t\tcurrent->il_prev = MAX_NUMNODES-1;\n\ttask_unlock(current);\n\tmpol_put(old);\n\tret = 0;\nout:\n\tNODEMASK_SCRATCH_FREE(scratch);\n\treturn ret;\n}"
  },
  {
    "function_name": "mbind_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "677-735",
    "snippet": "static int mbind_range(struct mm_struct *mm, unsigned long start,\n\t\t       unsigned long end, struct mempolicy *new_pol)\n{\n\tstruct vm_area_struct *next;\n\tstruct vm_area_struct *prev;\n\tstruct vm_area_struct *vma;\n\tint err = 0;\n\tpgoff_t pgoff;\n\tunsigned long vmstart;\n\tunsigned long vmend;\n\n\tvma = find_vma(mm, start);\n\tif (!vma || vma->vm_start > start)\n\t\treturn -EFAULT;\n\n\tprev = vma->vm_prev;\n\tif (start > vma->vm_start)\n\t\tprev = vma;\n\n\tfor (; vma && vma->vm_start < end; prev = vma, vma = next) {\n\t\tnext = vma->vm_next;\n\t\tvmstart = max(start, vma->vm_start);\n\t\tvmend   = min(end, vma->vm_end);\n\n\t\tif (mpol_equal(vma_policy(vma), new_pol))\n\t\t\tcontinue;\n\n\t\tpgoff = vma->vm_pgoff +\n\t\t\t((vmstart - vma->vm_start) >> PAGE_SHIFT);\n\t\tprev = vma_merge(mm, prev, vmstart, vmend, vma->vm_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, pgoff,\n\t\t\t\t new_pol, vma->vm_userfaultfd_ctx);\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tnext = vma->vm_next;\n\t\t\tif (mpol_equal(vma_policy(vma), new_pol))\n\t\t\t\tcontinue;\n\t\t\t/* vma_merge() joined vma && vma->next, case 8 */\n\t\t\tgoto replace;\n\t\t}\n\t\tif (vma->vm_start != vmstart) {\n\t\t\terr = split_vma(vma->vm_mm, vma, vmstart, 1);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (vma->vm_end != vmend) {\n\t\t\terr = split_vma(vma->vm_mm, vma, vmend, 0);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n replace:\n\t\terr = vma_replace_policy(vma, new_pol);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n out:\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vma_replace_policy",
          "args": [
            "vma",
            "new_pol"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "vma_replace_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "644-674",
          "snippet": "static int vma_replace_policy(struct vm_area_struct *vma,\n\t\t\t\t\t\tstruct mempolicy *pol)\n{\n\tint err;\n\tstruct mempolicy *old;\n\tstruct mempolicy *new;\n\n\tpr_debug(\"vma %lx-%lx/%lx vm_ops %p vm_file %p set_policy %p\\n\",\n\t\t vma->vm_start, vma->vm_end, vma->vm_pgoff,\n\t\t vma->vm_ops, vma->vm_file,\n\t\t vma->vm_ops ? vma->vm_ops->set_policy : NULL);\n\n\tnew = mpol_dup(pol);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\tif (vma->vm_ops && vma->vm_ops->set_policy) {\n\t\terr = vma->vm_ops->set_policy(vma, new);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\n\told = vma->vm_policy;\n\tvma->vm_policy = new; /* protected by mmap_sem */\n\tmpol_put(old);\n\n\treturn 0;\n err_out:\n\tmpol_put(new);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic int vma_replace_policy(struct vm_area_struct *vma,\n\t\t\t\t\t\tstruct mempolicy *pol)\n{\n\tint err;\n\tstruct mempolicy *old;\n\tstruct mempolicy *new;\n\n\tpr_debug(\"vma %lx-%lx/%lx vm_ops %p vm_file %p set_policy %p\\n\",\n\t\t vma->vm_start, vma->vm_end, vma->vm_pgoff,\n\t\t vma->vm_ops, vma->vm_file,\n\t\t vma->vm_ops ? vma->vm_ops->set_policy : NULL);\n\n\tnew = mpol_dup(pol);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\tif (vma->vm_ops && vma->vm_ops->set_policy) {\n\t\terr = vma->vm_ops->set_policy(vma, new);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\n\told = vma->vm_policy;\n\tvma->vm_policy = new; /* protected by mmap_sem */\n\tmpol_put(old);\n\n\treturn 0;\n err_out:\n\tmpol_put(new);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "split_vma",
          "args": [
            "vma->vm_mm",
            "vma",
            "vmend",
            "0"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "split_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "1450-1507",
          "snippet": "int split_vma(struct mm_struct *mm, struct vm_area_struct *vma,\n\t      unsigned long addr, int new_below)\n{\n\tstruct vm_area_struct *new;\n\tstruct vm_region *region;\n\tunsigned long npages;\n\n\t/* we're only permitted to split anonymous regions (these should have\n\t * only a single usage on the region) */\n\tif (vma->vm_file)\n\t\treturn -ENOMEM;\n\n\tif (mm->map_count >= sysctl_max_map_count)\n\t\treturn -ENOMEM;\n\n\tregion = kmem_cache_alloc(vm_region_jar, GFP_KERNEL);\n\tif (!region)\n\t\treturn -ENOMEM;\n\n\tnew = vm_area_dup(vma);\n\tif (!new) {\n\t\tkmem_cache_free(vm_region_jar, region);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* most fields are the same, copy all, and then fixup */\n\t*region = *vma->vm_region;\n\tnew->vm_region = region;\n\n\tnpages = (addr - vma->vm_start) >> PAGE_SHIFT;\n\n\tif (new_below) {\n\t\tregion->vm_top = region->vm_end = new->vm_end = addr;\n\t} else {\n\t\tregion->vm_start = new->vm_start = addr;\n\t\tregion->vm_pgoff = new->vm_pgoff += npages;\n\t}\n\n\tif (new->vm_ops && new->vm_ops->open)\n\t\tnew->vm_ops->open(new);\n\n\tdelete_vma_from_mm(vma);\n\tdown_write(&nommu_region_sem);\n\tdelete_nommu_region(vma->vm_region);\n\tif (new_below) {\n\t\tvma->vm_region->vm_start = vma->vm_start = addr;\n\t\tvma->vm_region->vm_pgoff = vma->vm_pgoff += npages;\n\t} else {\n\t\tvma->vm_region->vm_end = vma->vm_end = addr;\n\t\tvma->vm_region->vm_top = addr;\n\t}\n\tadd_nommu_region(vma->vm_region);\n\tadd_nommu_region(new->vm_region);\n\tup_write(&nommu_region_sem);\n\tadd_vma_to_mm(mm, vma);\n\tadd_vma_to_mm(mm, new);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *vm_region_jar;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *vm_region_jar;\n\nint split_vma(struct mm_struct *mm, struct vm_area_struct *vma,\n\t      unsigned long addr, int new_below)\n{\n\tstruct vm_area_struct *new;\n\tstruct vm_region *region;\n\tunsigned long npages;\n\n\t/* we're only permitted to split anonymous regions (these should have\n\t * only a single usage on the region) */\n\tif (vma->vm_file)\n\t\treturn -ENOMEM;\n\n\tif (mm->map_count >= sysctl_max_map_count)\n\t\treturn -ENOMEM;\n\n\tregion = kmem_cache_alloc(vm_region_jar, GFP_KERNEL);\n\tif (!region)\n\t\treturn -ENOMEM;\n\n\tnew = vm_area_dup(vma);\n\tif (!new) {\n\t\tkmem_cache_free(vm_region_jar, region);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* most fields are the same, copy all, and then fixup */\n\t*region = *vma->vm_region;\n\tnew->vm_region = region;\n\n\tnpages = (addr - vma->vm_start) >> PAGE_SHIFT;\n\n\tif (new_below) {\n\t\tregion->vm_top = region->vm_end = new->vm_end = addr;\n\t} else {\n\t\tregion->vm_start = new->vm_start = addr;\n\t\tregion->vm_pgoff = new->vm_pgoff += npages;\n\t}\n\n\tif (new->vm_ops && new->vm_ops->open)\n\t\tnew->vm_ops->open(new);\n\n\tdelete_vma_from_mm(vma);\n\tdown_write(&nommu_region_sem);\n\tdelete_nommu_region(vma->vm_region);\n\tif (new_below) {\n\t\tvma->vm_region->vm_start = vma->vm_start = addr;\n\t\tvma->vm_region->vm_pgoff = vma->vm_pgoff += npages;\n\t} else {\n\t\tvma->vm_region->vm_end = vma->vm_end = addr;\n\t\tvma->vm_region->vm_top = addr;\n\t}\n\tadd_nommu_region(vma->vm_region);\n\tadd_nommu_region(new->vm_region);\n\tup_write(&nommu_region_sem);\n\tadd_vma_to_mm(mm, vma);\n\tadd_vma_to_mm(mm, new);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mpol_equal",
          "args": [
            "vma_policy(vma)",
            "new_pol"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "__mpol_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2134-2160",
          "snippet": "bool __mpol_equal(struct mempolicy *a, struct mempolicy *b)\n{\n\tif (!a || !b)\n\t\treturn false;\n\tif (a->mode != b->mode)\n\t\treturn false;\n\tif (a->flags != b->flags)\n\t\treturn false;\n\tif (mpol_store_user_nodemask(a))\n\t\tif (!nodes_equal(a->w.user_nodemask, b->w.user_nodemask))\n\t\t\treturn false;\n\n\tswitch (a->mode) {\n\tcase MPOL_BIND:\n\t\t/* Fall through */\n\tcase MPOL_INTERLEAVE:\n\t\treturn !!nodes_equal(a->v.nodes, b->v.nodes);\n\tcase MPOL_PREFERRED:\n\t\t/* a's ->flags is the same as b's */\n\t\tif (a->flags & MPOL_F_LOCAL)\n\t\t\treturn true;\n\t\treturn a->v.preferred_node == b->v.preferred_node;\n\tdefault:\n\t\tBUG();\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nbool __mpol_equal(struct mempolicy *a, struct mempolicy *b)\n{\n\tif (!a || !b)\n\t\treturn false;\n\tif (a->mode != b->mode)\n\t\treturn false;\n\tif (a->flags != b->flags)\n\t\treturn false;\n\tif (mpol_store_user_nodemask(a))\n\t\tif (!nodes_equal(a->w.user_nodemask, b->w.user_nodemask))\n\t\t\treturn false;\n\n\tswitch (a->mode) {\n\tcase MPOL_BIND:\n\t\t/* Fall through */\n\tcase MPOL_INTERLEAVE:\n\t\treturn !!nodes_equal(a->v.nodes, b->v.nodes);\n\tcase MPOL_PREFERRED:\n\t\t/* a's ->flags is the same as b's */\n\t\tif (a->flags & MPOL_F_LOCAL)\n\t\t\treturn true;\n\t\treturn a->v.preferred_node == b->v.preferred_node;\n\tdefault:\n\t\tBUG();\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_policy",
          "args": [
            "vma"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "vma_policy_mof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1676-1696",
          "snippet": "bool vma_policy_mof(struct vm_area_struct *vma)\n{\n\tstruct mempolicy *pol;\n\n\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\tbool ret = false;\n\n\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start);\n\t\tif (pol && (pol->flags & MPOL_F_MOF))\n\t\t\tret = true;\n\t\tmpol_cond_put(pol);\n\n\t\treturn ret;\n\t}\n\n\tpol = vma->vm_policy;\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol->flags & MPOL_F_MOF;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nbool vma_policy_mof(struct vm_area_struct *vma)\n{\n\tstruct mempolicy *pol;\n\n\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\tbool ret = false;\n\n\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start);\n\t\tif (pol && (pol->flags & MPOL_F_MOF))\n\t\t\tret = true;\n\t\tmpol_cond_put(pol);\n\n\t\treturn ret;\n\t}\n\n\tpol = vma->vm_policy;\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol->flags & MPOL_F_MOF;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_merge",
          "args": [
            "mm",
            "prev",
            "vmstart",
            "vmend",
            "vma->vm_flags",
            "vma->anon_vma",
            "vma->vm_file",
            "pgoff",
            "new_pol",
            "vma->vm_userfaultfd_ctx"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "vma_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1132-1223",
          "snippet": "struct vm_area_struct *vma_merge(struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *prev, unsigned long addr,\n\t\t\tunsigned long end, unsigned long vm_flags,\n\t\t\tstruct anon_vma *anon_vma, struct file *file,\n\t\t\tpgoff_t pgoff, struct mempolicy *policy,\n\t\t\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tpgoff_t pglen = (end - addr) >> PAGE_SHIFT;\n\tstruct vm_area_struct *area, *next;\n\tint err;\n\n\t/*\n\t * We later require that vma->vm_flags == vm_flags,\n\t * so this tests vma->vm_flags & VM_SPECIAL, too.\n\t */\n\tif (vm_flags & VM_SPECIAL)\n\t\treturn NULL;\n\n\tif (prev)\n\t\tnext = prev->vm_next;\n\telse\n\t\tnext = mm->mmap;\n\tarea = next;\n\tif (area && area->vm_end == end)\t\t/* cases 6, 7, 8 */\n\t\tnext = next->vm_next;\n\n\t/* verify some invariant that must be enforced by the caller */\n\tVM_WARN_ON(prev && addr <= prev->vm_start);\n\tVM_WARN_ON(area && end > area->vm_end);\n\tVM_WARN_ON(addr >= end);\n\n\t/*\n\t * Can it merge with the predecessor?\n\t */\n\tif (prev && prev->vm_end == addr &&\n\t\t\tmpol_equal(vma_policy(prev), policy) &&\n\t\t\tcan_vma_merge_after(prev, vm_flags,\n\t\t\t\t\t    anon_vma, file, pgoff,\n\t\t\t\t\t    vm_userfaultfd_ctx)) {\n\t\t/*\n\t\t * OK, it can.  Can we now merge in the successor as well?\n\t\t */\n\t\tif (next && end == next->vm_start &&\n\t\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t\t     anon_vma, file,\n\t\t\t\t\t\t     pgoff+pglen,\n\t\t\t\t\t\t     vm_userfaultfd_ctx) &&\n\t\t\t\tis_mergeable_anon_vma(prev->anon_vma,\n\t\t\t\t\t\t      next->anon_vma, NULL)) {\n\t\t\t\t\t\t\t/* cases 1, 6 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t next->vm_end, prev->vm_pgoff, NULL,\n\t\t\t\t\t prev);\n\t\t} else\t\t\t\t\t/* cases 2, 5, 7 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t end, prev->vm_pgoff, NULL, prev);\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(prev, vm_flags);\n\t\treturn prev;\n\t}\n\n\t/*\n\t * Can this new request be merged in front of next?\n\t */\n\tif (next && end == next->vm_start &&\n\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t     anon_vma, file, pgoff+pglen,\n\t\t\t\t\t     vm_userfaultfd_ctx)) {\n\t\tif (prev && addr < prev->vm_end)\t/* case 4 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t addr, prev->vm_pgoff, NULL, next);\n\t\telse {\t\t\t\t\t/* cases 3, 8 */\n\t\t\terr = __vma_adjust(area, addr, next->vm_end,\n\t\t\t\t\t next->vm_pgoff - pglen, NULL, next);\n\t\t\t/*\n\t\t\t * In case 3 area is already equal to next and\n\t\t\t * this is a noop, but in case 8 \"area\" has\n\t\t\t * been removed and next was expanded over it.\n\t\t\t */\n\t\t\tarea = next;\n\t\t}\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(area, vm_flags);\n\t\treturn area;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\n\nstruct vm_area_struct *vma_merge(struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *prev, unsigned long addr,\n\t\t\tunsigned long end, unsigned long vm_flags,\n\t\t\tstruct anon_vma *anon_vma, struct file *file,\n\t\t\tpgoff_t pgoff, struct mempolicy *policy,\n\t\t\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tpgoff_t pglen = (end - addr) >> PAGE_SHIFT;\n\tstruct vm_area_struct *area, *next;\n\tint err;\n\n\t/*\n\t * We later require that vma->vm_flags == vm_flags,\n\t * so this tests vma->vm_flags & VM_SPECIAL, too.\n\t */\n\tif (vm_flags & VM_SPECIAL)\n\t\treturn NULL;\n\n\tif (prev)\n\t\tnext = prev->vm_next;\n\telse\n\t\tnext = mm->mmap;\n\tarea = next;\n\tif (area && area->vm_end == end)\t\t/* cases 6, 7, 8 */\n\t\tnext = next->vm_next;\n\n\t/* verify some invariant that must be enforced by the caller */\n\tVM_WARN_ON(prev && addr <= prev->vm_start);\n\tVM_WARN_ON(area && end > area->vm_end);\n\tVM_WARN_ON(addr >= end);\n\n\t/*\n\t * Can it merge with the predecessor?\n\t */\n\tif (prev && prev->vm_end == addr &&\n\t\t\tmpol_equal(vma_policy(prev), policy) &&\n\t\t\tcan_vma_merge_after(prev, vm_flags,\n\t\t\t\t\t    anon_vma, file, pgoff,\n\t\t\t\t\t    vm_userfaultfd_ctx)) {\n\t\t/*\n\t\t * OK, it can.  Can we now merge in the successor as well?\n\t\t */\n\t\tif (next && end == next->vm_start &&\n\t\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t\t     anon_vma, file,\n\t\t\t\t\t\t     pgoff+pglen,\n\t\t\t\t\t\t     vm_userfaultfd_ctx) &&\n\t\t\t\tis_mergeable_anon_vma(prev->anon_vma,\n\t\t\t\t\t\t      next->anon_vma, NULL)) {\n\t\t\t\t\t\t\t/* cases 1, 6 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t next->vm_end, prev->vm_pgoff, NULL,\n\t\t\t\t\t prev);\n\t\t} else\t\t\t\t\t/* cases 2, 5, 7 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t end, prev->vm_pgoff, NULL, prev);\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(prev, vm_flags);\n\t\treturn prev;\n\t}\n\n\t/*\n\t * Can this new request be merged in front of next?\n\t */\n\tif (next && end == next->vm_start &&\n\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t     anon_vma, file, pgoff+pglen,\n\t\t\t\t\t     vm_userfaultfd_ctx)) {\n\t\tif (prev && addr < prev->vm_end)\t/* case 4 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t addr, prev->vm_pgoff, NULL, next);\n\t\telse {\t\t\t\t\t/* cases 3, 8 */\n\t\t\terr = __vma_adjust(area, addr, next->vm_end,\n\t\t\t\t\t next->vm_pgoff - pglen, NULL, next);\n\t\t\t/*\n\t\t\t * In case 3 area is already equal to next and\n\t\t\t * this is a noop, but in case 8 \"area\" has\n\t\t\t * been removed and next was expanded over it.\n\t\t\t */\n\t\t\tarea = next;\n\t\t}\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(area, vm_flags);\n\t\treturn area;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "end",
            "vma->vm_end"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "start",
            "vma->vm_start"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "mm",
            "start"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "775-796",
          "snippet": "struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic int mbind_range(struct mm_struct *mm, unsigned long start,\n\t\t       unsigned long end, struct mempolicy *new_pol)\n{\n\tstruct vm_area_struct *next;\n\tstruct vm_area_struct *prev;\n\tstruct vm_area_struct *vma;\n\tint err = 0;\n\tpgoff_t pgoff;\n\tunsigned long vmstart;\n\tunsigned long vmend;\n\n\tvma = find_vma(mm, start);\n\tif (!vma || vma->vm_start > start)\n\t\treturn -EFAULT;\n\n\tprev = vma->vm_prev;\n\tif (start > vma->vm_start)\n\t\tprev = vma;\n\n\tfor (; vma && vma->vm_start < end; prev = vma, vma = next) {\n\t\tnext = vma->vm_next;\n\t\tvmstart = max(start, vma->vm_start);\n\t\tvmend   = min(end, vma->vm_end);\n\n\t\tif (mpol_equal(vma_policy(vma), new_pol))\n\t\t\tcontinue;\n\n\t\tpgoff = vma->vm_pgoff +\n\t\t\t((vmstart - vma->vm_start) >> PAGE_SHIFT);\n\t\tprev = vma_merge(mm, prev, vmstart, vmend, vma->vm_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, pgoff,\n\t\t\t\t new_pol, vma->vm_userfaultfd_ctx);\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tnext = vma->vm_next;\n\t\t\tif (mpol_equal(vma_policy(vma), new_pol))\n\t\t\t\tcontinue;\n\t\t\t/* vma_merge() joined vma && vma->next, case 8 */\n\t\t\tgoto replace;\n\t\t}\n\t\tif (vma->vm_start != vmstart) {\n\t\t\terr = split_vma(vma->vm_mm, vma, vmstart, 1);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (vma->vm_end != vmend) {\n\t\t\terr = split_vma(vma->vm_mm, vma, vmend, 0);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n replace:\n\t\terr = vma_replace_policy(vma, new_pol);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n out:\n\treturn err;\n}"
  },
  {
    "function_name": "vma_replace_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "644-674",
    "snippet": "static int vma_replace_policy(struct vm_area_struct *vma,\n\t\t\t\t\t\tstruct mempolicy *pol)\n{\n\tint err;\n\tstruct mempolicy *old;\n\tstruct mempolicy *new;\n\n\tpr_debug(\"vma %lx-%lx/%lx vm_ops %p vm_file %p set_policy %p\\n\",\n\t\t vma->vm_start, vma->vm_end, vma->vm_pgoff,\n\t\t vma->vm_ops, vma->vm_file,\n\t\t vma->vm_ops ? vma->vm_ops->set_policy : NULL);\n\n\tnew = mpol_dup(pol);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\tif (vma->vm_ops && vma->vm_ops->set_policy) {\n\t\terr = vma->vm_ops->set_policy(vma, new);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\n\told = vma->vm_policy;\n\tvma->vm_policy = new; /* protected by mmap_sem */\n\tmpol_put(old);\n\n\treturn 0;\n err_out:\n\tmpol_put(new);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpol_put",
          "args": [
            "new"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_put_task_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2345-2354",
          "snippet": "void mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nvoid mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma->vm_ops->set_policy",
          "args": [
            "vma",
            "new"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_dup",
          "args": [
            "pol"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "__mpol_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2110-2131",
          "snippet": "struct mempolicy *__mpol_dup(struct mempolicy *old)\n{\n\tstruct mempolicy *new = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\n\tif (!new)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* task's mempolicy is protected by alloc_lock */\n\tif (old == current->mempolicy) {\n\t\ttask_lock(current);\n\t\t*new = *old;\n\t\ttask_unlock(current);\n\t} else\n\t\t*new = *old;\n\n\tif (current_cpuset_is_being_rebound()) {\n\t\tnodemask_t mems = cpuset_mems_allowed(current);\n\t\tmpol_rebind_policy(new, &mems);\n\t}\n\tatomic_set(&new->refcnt, 1);\n\treturn new;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *policy_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct kmem_cache *policy_cache;\n\nstruct mempolicy *__mpol_dup(struct mempolicy *old)\n{\n\tstruct mempolicy *new = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\n\tif (!new)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* task's mempolicy is protected by alloc_lock */\n\tif (old == current->mempolicy) {\n\t\ttask_lock(current);\n\t\t*new = *old;\n\t\ttask_unlock(current);\n\t} else\n\t\t*new = *old;\n\n\tif (current_cpuset_is_being_rebound()) {\n\t\tnodemask_t mems = cpuset_mems_allowed(current);\n\t\tmpol_rebind_policy(new, &mems);\n\t}\n\tatomic_set(&new->refcnt, 1);\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"vma %lx-%lx/%lx vm_ops %p vm_file %p set_policy %p\\n\"",
            "vma->vm_start",
            "vma->vm_end",
            "vma->vm_pgoff",
            "vma->vm_ops",
            "vma->vm_file",
            "vma->vm_ops ? vma->vm_ops->set_policy : NULL"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic int vma_replace_policy(struct vm_area_struct *vma,\n\t\t\t\t\t\tstruct mempolicy *pol)\n{\n\tint err;\n\tstruct mempolicy *old;\n\tstruct mempolicy *new;\n\n\tpr_debug(\"vma %lx-%lx/%lx vm_ops %p vm_file %p set_policy %p\\n\",\n\t\t vma->vm_start, vma->vm_end, vma->vm_pgoff,\n\t\t vma->vm_ops, vma->vm_file,\n\t\t vma->vm_ops ? vma->vm_ops->set_policy : NULL);\n\n\tnew = mpol_dup(pol);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\tif (vma->vm_ops && vma->vm_ops->set_policy) {\n\t\terr = vma->vm_ops->set_policy(vma, new);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\n\told = vma->vm_policy;\n\tvma->vm_policy = new; /* protected by mmap_sem */\n\tmpol_put(old);\n\n\treturn 0;\n err_out:\n\tmpol_put(new);\n\treturn err;\n}"
  },
  {
    "function_name": "queue_pages_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "618-638",
    "snippet": "static int\nqueue_pages_range(struct mm_struct *mm, unsigned long start, unsigned long end,\n\t\tnodemask_t *nodes, unsigned long flags,\n\t\tstruct list_head *pagelist)\n{\n\tstruct queue_pages qp = {\n\t\t.pagelist = pagelist,\n\t\t.flags = flags,\n\t\t.nmask = nodes,\n\t\t.prev = NULL,\n\t};\n\tstruct mm_walk queue_pages_walk = {\n\t\t.hugetlb_entry = queue_pages_hugetlb,\n\t\t.pmd_entry = queue_pages_pte_range,\n\t\t.test_walk = queue_pages_test_walk,\n\t\t.mm = mm,\n\t\t.private = &qp,\n\t};\n\n\treturn walk_page_range(start, end, &queue_pages_walk);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_page_range",
          "args": [
            "start",
            "end",
            "&queue_pages_walk"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "walk_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
          "lines": "293-340",
          "snippet": "int walk_page_range(unsigned long start, unsigned long end,\n\t\t    struct mm_walk *walk)\n{\n\tint err = 0;\n\tunsigned long next;\n\tstruct vm_area_struct *vma;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tif (!walk->mm)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON_MM(!rwsem_is_locked(&walk->mm->mmap_sem), walk->mm);\n\n\tvma = find_vma(walk->mm, start);\n\tdo {\n\t\tif (!vma) { /* after the last vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = end;\n\t\t} else if (start < vma->vm_start) { /* outside vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = min(end, vma->vm_start);\n\t\t} else { /* inside vma */\n\t\t\twalk->vma = vma;\n\t\t\tnext = min(end, vma->vm_end);\n\t\t\tvma = vma->vm_next;\n\n\t\t\terr = walk_page_test(start, next, walk);\n\t\t\tif (err > 0) {\n\t\t\t\t/*\n\t\t\t\t * positive return values are purely for\n\t\t\t\t * controlling the pagewalk, so should never\n\t\t\t\t * be passed to the callers.\n\t\t\t\t */\n\t\t\t\terr = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (walk->vma || walk->pte_hole)\n\t\t\terr = __walk_page_range(start, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (start = next, start < end);\n\treturn err;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nint walk_page_range(unsigned long start, unsigned long end,\n\t\t    struct mm_walk *walk)\n{\n\tint err = 0;\n\tunsigned long next;\n\tstruct vm_area_struct *vma;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tif (!walk->mm)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON_MM(!rwsem_is_locked(&walk->mm->mmap_sem), walk->mm);\n\n\tvma = find_vma(walk->mm, start);\n\tdo {\n\t\tif (!vma) { /* after the last vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = end;\n\t\t} else if (start < vma->vm_start) { /* outside vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = min(end, vma->vm_start);\n\t\t} else { /* inside vma */\n\t\t\twalk->vma = vma;\n\t\t\tnext = min(end, vma->vm_end);\n\t\t\tvma = vma->vm_next;\n\n\t\t\terr = walk_page_test(start, next, walk);\n\t\t\tif (err > 0) {\n\t\t\t\t/*\n\t\t\t\t * positive return values are purely for\n\t\t\t\t * controlling the pagewalk, so should never\n\t\t\t\t * be passed to the callers.\n\t\t\t\t */\n\t\t\t\terr = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (walk->vma || walk->pte_hole)\n\t\t\terr = __walk_page_range(start, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (start = next, start < end);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic int\nqueue_pages_range(struct mm_struct *mm, unsigned long start, unsigned long end,\n\t\tnodemask_t *nodes, unsigned long flags,\n\t\tstruct list_head *pagelist)\n{\n\tstruct queue_pages qp = {\n\t\t.pagelist = pagelist,\n\t\t.flags = flags,\n\t\t.nmask = nodes,\n\t\t.prev = NULL,\n\t};\n\tstruct mm_walk queue_pages_walk = {\n\t\t.hugetlb_entry = queue_pages_hugetlb,\n\t\t.pmd_entry = queue_pages_pte_range,\n\t\t.test_walk = queue_pages_test_walk,\n\t\t.mm = mm,\n\t\t.private = &qp,\n\t};\n\n\treturn walk_page_range(start, end, &queue_pages_walk);\n}"
  },
  {
    "function_name": "queue_pages_test_walk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "571-609",
    "snippet": "static int queue_pages_test_walk(unsigned long start, unsigned long end,\n\t\t\t\tstruct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct queue_pages *qp = walk->private;\n\tunsigned long endvma = vma->vm_end;\n\tunsigned long flags = qp->flags;\n\n\tif (!vma_migratable(vma))\n\t\treturn 1;\n\n\tif (endvma > end)\n\t\tendvma = end;\n\tif (vma->vm_start > start)\n\t\tstart = vma->vm_start;\n\n\tif (!(flags & MPOL_MF_DISCONTIG_OK)) {\n\t\tif (!vma->vm_next && vma->vm_end < end)\n\t\t\treturn -EFAULT;\n\t\tif (qp->prev && qp->prev->vm_end < vma->vm_start)\n\t\t\treturn -EFAULT;\n\t}\n\n\tqp->prev = vma;\n\n\tif (flags & MPOL_MF_LAZY) {\n\t\t/* Similar to task_numa_work, skip inaccessible VMAs */\n\t\tif (!is_vm_hugetlb_page(vma) &&\n\t\t\t(vma->vm_flags & (VM_READ | VM_EXEC | VM_WRITE)) &&\n\t\t\t!(vma->vm_flags & VM_MIXEDMAP))\n\t\t\tchange_prot_numa(vma, start, endvma);\n\t\treturn 1;\n\t}\n\n\t/* queue pages from current vma */\n\tif (flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [
      "#define MPOL_MF_DISCONTIG_OK (MPOL_MF_INTERNAL << 0)\t/* Skip checks for continuous vmas */"
    ],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "change_prot_numa",
          "args": [
            "vma",
            "start",
            "endvma"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "change_prot_numa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "564-568",
          "snippet": "static unsigned long change_prot_numa(struct vm_area_struct *vma,\n\t\t\tunsigned long addr, unsigned long end)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic unsigned long change_prot_numa(struct vm_area_struct *vma,\n\t\t\tunsigned long addr, unsigned long end)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_migratable",
          "args": [
            "vma"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\n#define MPOL_MF_DISCONTIG_OK (MPOL_MF_INTERNAL << 0)\t/* Skip checks for continuous vmas */\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic int queue_pages_test_walk(unsigned long start, unsigned long end,\n\t\t\t\tstruct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct queue_pages *qp = walk->private;\n\tunsigned long endvma = vma->vm_end;\n\tunsigned long flags = qp->flags;\n\n\tif (!vma_migratable(vma))\n\t\treturn 1;\n\n\tif (endvma > end)\n\t\tendvma = end;\n\tif (vma->vm_start > start)\n\t\tstart = vma->vm_start;\n\n\tif (!(flags & MPOL_MF_DISCONTIG_OK)) {\n\t\tif (!vma->vm_next && vma->vm_end < end)\n\t\t\treturn -EFAULT;\n\t\tif (qp->prev && qp->prev->vm_end < vma->vm_start)\n\t\t\treturn -EFAULT;\n\t}\n\n\tqp->prev = vma;\n\n\tif (flags & MPOL_MF_LAZY) {\n\t\t/* Similar to task_numa_work, skip inaccessible VMAs */\n\t\tif (!is_vm_hugetlb_page(vma) &&\n\t\t\t(vma->vm_flags & (VM_READ | VM_EXEC | VM_WRITE)) &&\n\t\t\t!(vma->vm_flags & VM_MIXEDMAP))\n\t\t\tchange_prot_numa(vma, start, endvma);\n\t\treturn 1;\n\t}\n\n\t/* queue pages from current vma */\n\tif (flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "change_prot_numa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "564-568",
    "snippet": "static unsigned long change_prot_numa(struct vm_area_struct *vma,\n\t\t\tunsigned long addr, unsigned long end)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic unsigned long change_prot_numa(struct vm_area_struct *vma,\n\t\t\tunsigned long addr, unsigned long end)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "change_prot_numa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "552-562",
    "snippet": "unsigned long change_prot_numa(struct vm_area_struct *vma,\n\t\t\tunsigned long addr, unsigned long end)\n{\n\tint nr_updated;\n\n\tnr_updated = change_protection(vma, addr, end, PAGE_NONE, 0, 1);\n\tif (nr_updated)\n\t\tcount_vm_numa_events(NUMA_PTE_UPDATES, nr_updated);\n\n\treturn nr_updated;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "count_vm_numa_events",
          "args": [
            "NUMA_PTE_UPDATES",
            "nr_updated"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "change_protection",
          "args": [
            "vma",
            "addr",
            "end",
            "PAGE_NONE",
            "0",
            "1"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "change_protection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mprotect.c",
          "lines": "295-307",
          "snippet": "unsigned long change_protection(struct vm_area_struct *vma, unsigned long start,\n\t\t       unsigned long end, pgprot_t newprot,\n\t\t       int dirty_accountable, int prot_numa)\n{\n\tunsigned long pages;\n\n\tif (is_vm_hugetlb_page(vma))\n\t\tpages = hugetlb_change_protection(vma, start, end, newprot);\n\telse\n\t\tpages = change_protection_range(vma, start, end, newprot, dirty_accountable, prot_numa);\n\n\treturn pages;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/personality.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/security.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/pgtable.h>\n#include <linux/mm_inline.h>\n#include <linux/uaccess.h>\n#include <linux/ksm.h>\n#include <linux/pkeys.h>\n#include <linux/perf_event.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nunsigned long change_protection(struct vm_area_struct *vma, unsigned long start,\n\t\t       unsigned long end, pgprot_t newprot,\n\t\t       int dirty_accountable, int prot_numa)\n{\n\tunsigned long pages;\n\n\tif (is_vm_hugetlb_page(vma))\n\t\tpages = hugetlb_change_protection(vma, start, end, newprot);\n\telse\n\t\tpages = change_protection_range(vma, start, end, newprot, dirty_accountable, prot_numa);\n\n\treturn pages;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nunsigned long change_prot_numa(struct vm_area_struct *vma,\n\t\t\tunsigned long addr, unsigned long end)\n{\n\tint nr_updated;\n\n\tnr_updated = change_protection(vma, addr, end, PAGE_NONE, 0, 1);\n\tif (nr_updated)\n\t\tcount_vm_numa_events(NUMA_PTE_UPDATES, nr_updated);\n\n\treturn nr_updated;\n}"
  },
  {
    "function_name": "queue_pages_hugetlb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "512-540",
    "snippet": "static int queue_pages_hugetlb(pte_t *pte, unsigned long hmask,\n\t\t\t       unsigned long addr, unsigned long end,\n\t\t\t       struct mm_walk *walk)\n{\n#ifdef CONFIG_HUGETLB_PAGE\n\tstruct queue_pages *qp = walk->private;\n\tunsigned long flags = qp->flags;\n\tstruct page *page;\n\tspinlock_t *ptl;\n\tpte_t entry;\n\n\tptl = huge_pte_lock(hstate_vma(walk->vma), walk->mm, pte);\n\tentry = huge_ptep_get(pte);\n\tif (!pte_present(entry))\n\t\tgoto unlock;\n\tpage = pte_page(entry);\n\tif (!queue_pages_required(page, qp))\n\t\tgoto unlock;\n\t/* With MPOL_MF_MOVE, we migrate only unshared hugepage. */\n\tif (flags & (MPOL_MF_MOVE_ALL) ||\n\t    (flags & MPOL_MF_MOVE && page_mapcount(page) == 1))\n\t\tisolate_huge_page(page, qp->pagelist);\nunlock:\n\tspin_unlock(ptl);\n#else\n\tBUG();\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isolate_huge_page",
          "args": [
            "page",
            "qp->pagelist"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4891-4906",
          "snippet": "bool isolate_huge_page(struct page *page, struct list_head *list)\n{\n\tbool ret = true;\n\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\tspin_lock(&hugetlb_lock);\n\tif (!page_huge_active(page) || !get_page_unless_zero(page)) {\n\t\tret = false;\n\t\tgoto unlock;\n\t}\n\tclear_page_huge_active(page);\n\tlist_move_tail(&page->lru, list);\nunlock:\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nbool isolate_huge_page(struct page *page, struct list_head *list)\n{\n\tbool ret = true;\n\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\tspin_lock(&hugetlb_lock);\n\tif (!page_huge_active(page) || !get_page_unless_zero(page)) {\n\t\tret = false;\n\t\tgoto unlock;\n\t}\n\tclear_page_huge_active(page);\n\tlist_move_tail(&page->lru, list);\nunlock:\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "page"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_pages_required",
          "args": [
            "page",
            "qp"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "queue_pages_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "422-429",
          "snippet": "static inline bool queue_pages_required(struct page *page,\n\t\t\t\t\tstruct queue_pages *qp)\n{\n\tint nid = page_to_nid(page);\n\tunsigned long flags = qp->flags;\n\n\treturn node_isset(nid, *qp->nmask) == !(flags & MPOL_MF_INVERT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [
            "#define MPOL_MF_INVERT (MPOL_MF_INTERNAL << 1)\t\t/* Invert check for nodemask */"
          ],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\n#define MPOL_MF_INVERT (MPOL_MF_INTERNAL << 1)\t\t/* Invert check for nodemask */\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic inline bool queue_pages_required(struct page *page,\n\t\t\t\t\tstruct queue_pages *qp)\n{\n\tint nid = page_to_nid(page);\n\tunsigned long flags = qp->flags;\n\n\treturn node_isset(nid, *qp->nmask) == !(flags & MPOL_MF_INVERT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_page",
          "args": [
            "entry"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "release_pte_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "504-509",
          "snippet": "static void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "entry"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_ptep_get",
          "args": [
            "pte"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_lock",
          "args": [
            "hstate_vma(walk->vma)",
            "walk->mm",
            "pte"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_vma",
          "args": [
            "walk->vma"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic int queue_pages_hugetlb(pte_t *pte, unsigned long hmask,\n\t\t\t       unsigned long addr, unsigned long end,\n\t\t\t       struct mm_walk *walk)\n{\n#ifdef CONFIG_HUGETLB_PAGE\n\tstruct queue_pages *qp = walk->private;\n\tunsigned long flags = qp->flags;\n\tstruct page *page;\n\tspinlock_t *ptl;\n\tpte_t entry;\n\n\tptl = huge_pte_lock(hstate_vma(walk->vma), walk->mm, pte);\n\tentry = huge_ptep_get(pte);\n\tif (!pte_present(entry))\n\t\tgoto unlock;\n\tpage = pte_page(entry);\n\tif (!queue_pages_required(page, qp))\n\t\tgoto unlock;\n\t/* With MPOL_MF_MOVE, we migrate only unshared hugepage. */\n\tif (flags & (MPOL_MF_MOVE_ALL) ||\n\t    (flags & MPOL_MF_MOVE && page_mapcount(page) == 1))\n\t\tisolate_huge_page(page, qp->pagelist);\nunlock:\n\tspin_unlock(ptl);\n#else\n\tBUG();\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "queue_pages_pte_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "469-510",
    "snippet": "static int queue_pages_pte_range(pmd_t *pmd, unsigned long addr,\n\t\t\tunsigned long end, struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct page *page;\n\tstruct queue_pages *qp = walk->private;\n\tunsigned long flags = qp->flags;\n\tint ret;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (ptl) {\n\t\tret = queue_pages_pmd(pmd, ptl, addr, end, walk);\n\t\tif (ret)\n\t\t\treturn 0;\n\t}\n\n\tif (pmd_trans_unstable(pmd))\n\t\treturn 0;\n\n\tpte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tfor (; addr != end; pte++, addr += PAGE_SIZE) {\n\t\tif (!pte_present(*pte))\n\t\t\tcontinue;\n\t\tpage = vm_normal_page(vma, addr, *pte);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\t/*\n\t\t * vm_normal_page() filters out zero pages, but there might\n\t\t * still be PageReserved pages to skip, perhaps in a VDSO.\n\t\t */\n\t\tif (PageReserved(page))\n\t\t\tcontinue;\n\t\tif (!queue_pages_required(page, qp))\n\t\t\tcontinue;\n\t\tmigrate_page_add(page, qp->pagelist, flags);\n\t}\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "pte - 1",
            "ptl"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_page_add",
          "args": [
            "page",
            "qp->pagelist",
            "flags"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_page_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1134-1137",
          "snippet": "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_pages_required",
          "args": [
            "page",
            "qp"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "queue_pages_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "422-429",
          "snippet": "static inline bool queue_pages_required(struct page *page,\n\t\t\t\t\tstruct queue_pages *qp)\n{\n\tint nid = page_to_nid(page);\n\tunsigned long flags = qp->flags;\n\n\treturn node_isset(nid, *qp->nmask) == !(flags & MPOL_MF_INVERT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [
            "#define MPOL_MF_INVERT (MPOL_MF_INTERNAL << 1)\t\t/* Invert check for nodemask */"
          ],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\n#define MPOL_MF_INVERT (MPOL_MF_INTERNAL << 1)\t\t/* Invert check for nodemask */\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic inline bool queue_pages_required(struct page *page,\n\t\t\t\t\tstruct queue_pages *qp)\n{\n\tint nid = page_to_nid(page);\n\tunsigned long flags = qp->flags;\n\n\treturn node_isset(nid, *qp->nmask) == !(flags & MPOL_MF_INVERT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageReserved",
          "args": [
            "page"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_normal_page",
          "args": [
            "vma",
            "addr",
            "*pte"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "vm_normal_page_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "651-689",
          "snippet": "struct page *vm_normal_page_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tpmd_t pmd)\n{\n\tunsigned long pfn = pmd_pfn(pmd);\n\n\t/*\n\t * There is no pmd_special() but there may be special pmds, e.g.\n\t * in a direct-access (dax) mapping, so let's just replicate the\n\t * !CONFIG_ARCH_HAS_PTE_SPECIAL case from vm_normal_page() here.\n\t */\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (pmd_devmap(pmd))\n\t\treturn NULL;\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\tif (unlikely(pfn > highest_memmap_pfn))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstruct page *vm_normal_page_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tpmd_t pmd)\n{\n\tunsigned long pfn = pmd_pfn(pmd);\n\n\t/*\n\t * There is no pmd_special() but there may be special pmds, e.g.\n\t * in a direct-access (dax) mapping, so let's just replicate the\n\t * !CONFIG_ARCH_HAS_PTE_SPECIAL case from vm_normal_page() here.\n\t */\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (pmd_devmap(pmd))\n\t\treturn NULL;\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\tif (unlikely(pfn > highest_memmap_pfn))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "*pte"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "walk->mm",
            "pmd",
            "addr",
            "&ptl"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_unstable",
          "args": [
            "pmd"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_pages_pmd",
          "args": [
            "pmd",
            "ptl",
            "addr",
            "end",
            "walk"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "queue_pages_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "431-463",
          "snippet": "static int queue_pages_pmd(pmd_t *pmd, spinlock_t *ptl, unsigned long addr,\n\t\t\t\tunsigned long end, struct mm_walk *walk)\n{\n\tint ret = 0;\n\tstruct page *page;\n\tstruct queue_pages *qp = walk->private;\n\tunsigned long flags;\n\n\tif (unlikely(is_pmd_migration_entry(*pmd))) {\n\t\tret = 1;\n\t\tgoto unlock;\n\t}\n\tpage = pmd_page(*pmd);\n\tif (is_huge_zero_page(page)) {\n\t\tspin_unlock(ptl);\n\t\t__split_huge_pmd(walk->vma, pmd, addr, false, NULL);\n\t\tgoto out;\n\t}\n\tif (!queue_pages_required(page, qp)) {\n\t\tret = 1;\n\t\tgoto unlock;\n\t}\n\n\tret = 1;\n\tflags = qp->flags;\n\t/* go to thp migration */\n\tif (flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL))\n\t\tmigrate_page_add(page, qp->pagelist, flags);\nunlock:\n\tspin_unlock(ptl);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic int queue_pages_pmd(pmd_t *pmd, spinlock_t *ptl, unsigned long addr,\n\t\t\t\tunsigned long end, struct mm_walk *walk)\n{\n\tint ret = 0;\n\tstruct page *page;\n\tstruct queue_pages *qp = walk->private;\n\tunsigned long flags;\n\n\tif (unlikely(is_pmd_migration_entry(*pmd))) {\n\t\tret = 1;\n\t\tgoto unlock;\n\t}\n\tpage = pmd_page(*pmd);\n\tif (is_huge_zero_page(page)) {\n\t\tspin_unlock(ptl);\n\t\t__split_huge_pmd(walk->vma, pmd, addr, false, NULL);\n\t\tgoto out;\n\t}\n\tif (!queue_pages_required(page, qp)) {\n\t\tret = 1;\n\t\tgoto unlock;\n\t}\n\n\tret = 1;\n\tflags = qp->flags;\n\t/* go to thp migration */\n\tif (flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL))\n\t\tmigrate_page_add(page, qp->pagelist, flags);\nunlock:\n\tspin_unlock(ptl);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge_lock",
          "args": [
            "pmd",
            "vma"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "__pmd_trans_huge_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1957-1966",
          "snippet": "spinlock_t *__pmd_trans_huge_lock(pmd_t *pmd, struct vm_area_struct *vma)\n{\n\tspinlock_t *ptl;\n\tptl = pmd_lock(vma->vm_mm, pmd);\n\tif (likely(is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) ||\n\t\t\tpmd_devmap(*pmd)))\n\t\treturn ptl;\n\tspin_unlock(ptl);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nspinlock_t *__pmd_trans_huge_lock(pmd_t *pmd, struct vm_area_struct *vma)\n{\n\tspinlock_t *ptl;\n\tptl = pmd_lock(vma->vm_mm, pmd);\n\tif (likely(is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) ||\n\t\t\tpmd_devmap(*pmd)))\n\t\treturn ptl;\n\tspin_unlock(ptl);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic int queue_pages_pte_range(pmd_t *pmd, unsigned long addr,\n\t\t\tunsigned long end, struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct page *page;\n\tstruct queue_pages *qp = walk->private;\n\tunsigned long flags = qp->flags;\n\tint ret;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (ptl) {\n\t\tret = queue_pages_pmd(pmd, ptl, addr, end, walk);\n\t\tif (ret)\n\t\t\treturn 0;\n\t}\n\n\tif (pmd_trans_unstable(pmd))\n\t\treturn 0;\n\n\tpte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tfor (; addr != end; pte++, addr += PAGE_SIZE) {\n\t\tif (!pte_present(*pte))\n\t\t\tcontinue;\n\t\tpage = vm_normal_page(vma, addr, *pte);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\t/*\n\t\t * vm_normal_page() filters out zero pages, but there might\n\t\t * still be PageReserved pages to skip, perhaps in a VDSO.\n\t\t */\n\t\tif (PageReserved(page))\n\t\t\tcontinue;\n\t\tif (!queue_pages_required(page, qp))\n\t\t\tcontinue;\n\t\tmigrate_page_add(page, qp->pagelist, flags);\n\t}\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\treturn 0;\n}"
  },
  {
    "function_name": "queue_pages_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "431-463",
    "snippet": "static int queue_pages_pmd(pmd_t *pmd, spinlock_t *ptl, unsigned long addr,\n\t\t\t\tunsigned long end, struct mm_walk *walk)\n{\n\tint ret = 0;\n\tstruct page *page;\n\tstruct queue_pages *qp = walk->private;\n\tunsigned long flags;\n\n\tif (unlikely(is_pmd_migration_entry(*pmd))) {\n\t\tret = 1;\n\t\tgoto unlock;\n\t}\n\tpage = pmd_page(*pmd);\n\tif (is_huge_zero_page(page)) {\n\t\tspin_unlock(ptl);\n\t\t__split_huge_pmd(walk->vma, pmd, addr, false, NULL);\n\t\tgoto out;\n\t}\n\tif (!queue_pages_required(page, qp)) {\n\t\tret = 1;\n\t\tgoto unlock;\n\t}\n\n\tret = 1;\n\tflags = qp->flags;\n\t/* go to thp migration */\n\tif (flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL))\n\t\tmigrate_page_add(page, qp->pagelist, flags);\nunlock:\n\tspin_unlock(ptl);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_page_add",
          "args": [
            "page",
            "qp->pagelist",
            "flags"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_page_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1134-1137",
          "snippet": "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_pages_required",
          "args": [
            "page",
            "qp"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "queue_pages_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "422-429",
          "snippet": "static inline bool queue_pages_required(struct page *page,\n\t\t\t\t\tstruct queue_pages *qp)\n{\n\tint nid = page_to_nid(page);\n\tunsigned long flags = qp->flags;\n\n\treturn node_isset(nid, *qp->nmask) == !(flags & MPOL_MF_INVERT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [
            "#define MPOL_MF_INVERT (MPOL_MF_INTERNAL << 1)\t\t/* Invert check for nodemask */"
          ],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\n#define MPOL_MF_INVERT (MPOL_MF_INTERNAL << 1)\t\t/* Invert check for nodemask */\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic inline bool queue_pages_required(struct page *page,\n\t\t\t\t\tstruct queue_pages *qp)\n{\n\tint nid = page_to_nid(page);\n\tunsigned long flags = qp->flags;\n\n\treturn node_isset(nid, *qp->nmask) == !(flags & MPOL_MF_INVERT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__split_huge_pmd",
          "args": [
            "walk->vma",
            "pmd",
            "addr",
            "false",
            "NULL"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "__split_huge_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2243-2285",
          "snippet": "void __split_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long address, bool freeze, struct page *page)\n{\n\tspinlock_t *ptl;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long haddr = address & HPAGE_PMD_MASK;\n\n\tmmu_notifier_invalidate_range_start(mm, haddr, haddr + HPAGE_PMD_SIZE);\n\tptl = pmd_lock(mm, pmd);\n\n\t/*\n\t * If caller asks to setup a migration entries, we need a page to check\n\t * pmd against. Otherwise we can end up replacing wrong page.\n\t */\n\tVM_BUG_ON(freeze && !page);\n\tif (page && page != pmd_page(*pmd))\n\t        goto out;\n\n\tif (pmd_trans_huge(*pmd)) {\n\t\tpage = pmd_page(*pmd);\n\t\tif (PageMlocked(page))\n\t\t\tclear_page_mlock(page);\n\t} else if (!(pmd_devmap(*pmd) || is_pmd_migration_entry(*pmd)))\n\t\tgoto out;\n\t__split_huge_pmd_locked(vma, pmd, haddr, freeze);\nout:\n\tspin_unlock(ptl);\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback.\n\t * They are 3 cases to consider inside __split_huge_pmd_locked():\n\t *  1) pmdp_huge_clear_flush_notify() call invalidate_range() obvious\n\t *  2) __split_huge_zero_page_pmd() read only zero page and any write\n\t *    fault will trigger a flush_notify before pointing to a new page\n\t *    (it is fine if the secondary mmu keeps pointing to the old zero\n\t *    page in the meantime)\n\t *  3) Split a huge pmd into pte pointing to the same page. No need\n\t *     to invalidate secondary tlb entry they are all still valid.\n\t *     any further changes to individual pte will notify. So no need\n\t *     to call mmu_notifier->invalidate_range()\n\t */\n\tmmu_notifier_invalidate_range_only_end(mm, haddr, haddr +\n\t\t\t\t\t       HPAGE_PMD_SIZE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid __split_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long address, bool freeze, struct page *page)\n{\n\tspinlock_t *ptl;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long haddr = address & HPAGE_PMD_MASK;\n\n\tmmu_notifier_invalidate_range_start(mm, haddr, haddr + HPAGE_PMD_SIZE);\n\tptl = pmd_lock(mm, pmd);\n\n\t/*\n\t * If caller asks to setup a migration entries, we need a page to check\n\t * pmd against. Otherwise we can end up replacing wrong page.\n\t */\n\tVM_BUG_ON(freeze && !page);\n\tif (page && page != pmd_page(*pmd))\n\t        goto out;\n\n\tif (pmd_trans_huge(*pmd)) {\n\t\tpage = pmd_page(*pmd);\n\t\tif (PageMlocked(page))\n\t\t\tclear_page_mlock(page);\n\t} else if (!(pmd_devmap(*pmd) || is_pmd_migration_entry(*pmd)))\n\t\tgoto out;\n\t__split_huge_pmd_locked(vma, pmd, haddr, freeze);\nout:\n\tspin_unlock(ptl);\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback.\n\t * They are 3 cases to consider inside __split_huge_pmd_locked():\n\t *  1) pmdp_huge_clear_flush_notify() call invalidate_range() obvious\n\t *  2) __split_huge_zero_page_pmd() read only zero page and any write\n\t *    fault will trigger a flush_notify before pointing to a new page\n\t *    (it is fine if the secondary mmu keeps pointing to the old zero\n\t *    page in the meantime)\n\t *  3) Split a huge pmd into pte pointing to the same page. No need\n\t *     to invalidate secondary tlb entry they are all still valid.\n\t *     any further changes to individual pte will notify. So no need\n\t *     to call mmu_notifier->invalidate_range()\n\t */\n\tmmu_notifier_invalidate_range_only_end(mm, haddr, haddr +\n\t\t\t\t\t       HPAGE_PMD_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_huge_zero_page",
          "args": [
            "page"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_page",
          "args": [
            "*pmd"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_pmd_migration_entry(*pmd)"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_pmd_migration_entry",
          "args": [
            "*pmd"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic int queue_pages_pmd(pmd_t *pmd, spinlock_t *ptl, unsigned long addr,\n\t\t\t\tunsigned long end, struct mm_walk *walk)\n{\n\tint ret = 0;\n\tstruct page *page;\n\tstruct queue_pages *qp = walk->private;\n\tunsigned long flags;\n\n\tif (unlikely(is_pmd_migration_entry(*pmd))) {\n\t\tret = 1;\n\t\tgoto unlock;\n\t}\n\tpage = pmd_page(*pmd);\n\tif (is_huge_zero_page(page)) {\n\t\tspin_unlock(ptl);\n\t\t__split_huge_pmd(walk->vma, pmd, addr, false, NULL);\n\t\tgoto out;\n\t}\n\tif (!queue_pages_required(page, qp)) {\n\t\tret = 1;\n\t\tgoto unlock;\n\t}\n\n\tret = 1;\n\tflags = qp->flags;\n\t/* go to thp migration */\n\tif (flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL))\n\t\tmigrate_page_add(page, qp->pagelist, flags);\nunlock:\n\tspin_unlock(ptl);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "queue_pages_required",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "422-429",
    "snippet": "static inline bool queue_pages_required(struct page *page,\n\t\t\t\t\tstruct queue_pages *qp)\n{\n\tint nid = page_to_nid(page);\n\tunsigned long flags = qp->flags;\n\n\treturn node_isset(nid, *qp->nmask) == !(flags & MPOL_MF_INVERT);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [
      "#define MPOL_MF_INVERT (MPOL_MF_INTERNAL << 1)\t\t/* Invert check for nodemask */"
    ],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_isset",
          "args": [
            "nid",
            "*qp->nmask"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\n#define MPOL_MF_INVERT (MPOL_MF_INTERNAL << 1)\t\t/* Invert check for nodemask */\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic inline bool queue_pages_required(struct page *page,\n\t\t\t\t\tstruct queue_pages *qp)\n{\n\tint nid = page_to_nid(page);\n\tunsigned long flags = qp->flags;\n\n\treturn node_isset(nid, *qp->nmask) == !(flags & MPOL_MF_INVERT);\n}"
  },
  {
    "function_name": "mpol_rebind_mm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "378-386",
    "snippet": "void mpol_rebind_mm(struct mm_struct *mm, nodemask_t *new)\n{\n\tstruct vm_area_struct *vma;\n\n\tdown_write(&mm->mmap_sem);\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\tmpol_rebind_policy(vma->vm_policy, new);\n\tup_write(&mm->mmap_sem);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_rebind_policy",
          "args": [
            "vma->vm_policy",
            "new"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_rebind_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "349-358",
          "snippet": "static void mpol_rebind_policy(struct mempolicy *pol, const nodemask_t *newmask)\n{\n\tif (!pol)\n\t\treturn;\n\tif (!mpol_store_user_nodemask(pol) &&\n\t    nodes_equal(pol->w.cpuset_mems_allowed, *newmask))\n\t\treturn;\n\n\tmpol_ops[pol->mode].rebind(pol, newmask);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct mempolicy_operations {\n\tint (*create)(struct mempolicy *pol, const nodemask_t *nodes);\n\tvoid (*rebind)(struct mempolicy *pol, const nodemask_t *nodes);\n} mpol_ops[MPOL_MAX];",
            "static const struct mempolicy_operations mpol_ops[MPOL_MAX] = {\n\t[MPOL_DEFAULT] = {\n\t\t.rebind = mpol_rebind_default,\n\t},\n\t[MPOL_INTERLEAVE] = {\n\t\t.create = mpol_new_interleave,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n\t[MPOL_PREFERRED] = {\n\t\t.create = mpol_new_preferred,\n\t\t.rebind = mpol_rebind_preferred,\n\t},\n\t[MPOL_BIND] = {\n\t\t.create = mpol_new_bind,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic const struct mempolicy_operations {\n\tint (*create)(struct mempolicy *pol, const nodemask_t *nodes);\n\tvoid (*rebind)(struct mempolicy *pol, const nodemask_t *nodes);\n} mpol_ops[MPOL_MAX];\nstatic const struct mempolicy_operations mpol_ops[MPOL_MAX] = {\n\t[MPOL_DEFAULT] = {\n\t\t.rebind = mpol_rebind_default,\n\t},\n\t[MPOL_INTERLEAVE] = {\n\t\t.create = mpol_new_interleave,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n\t[MPOL_PREFERRED] = {\n\t\t.create = mpol_new_preferred,\n\t\t.rebind = mpol_rebind_preferred,\n\t},\n\t[MPOL_BIND] = {\n\t\t.create = mpol_new_bind,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n};\n\nstatic void mpol_rebind_policy(struct mempolicy *pol, const nodemask_t *newmask)\n{\n\tif (!pol)\n\t\treturn;\n\tif (!mpol_store_user_nodemask(pol) &&\n\t    nodes_equal(pol->w.cpuset_mems_allowed, *newmask))\n\t\treturn;\n\n\tmpol_ops[pol->mode].rebind(pol, newmask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nvoid mpol_rebind_mm(struct mm_struct *mm, nodemask_t *new)\n{\n\tstruct vm_area_struct *vma;\n\n\tdown_write(&mm->mmap_sem);\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\tmpol_rebind_policy(vma->vm_policy, new);\n\tup_write(&mm->mmap_sem);\n}"
  },
  {
    "function_name": "mpol_rebind_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "367-370",
    "snippet": "void mpol_rebind_task(struct task_struct *tsk, const nodemask_t *new)\n{\n\tmpol_rebind_policy(tsk->mempolicy, new);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpol_rebind_policy",
          "args": [
            "tsk->mempolicy",
            "new"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_rebind_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "349-358",
          "snippet": "static void mpol_rebind_policy(struct mempolicy *pol, const nodemask_t *newmask)\n{\n\tif (!pol)\n\t\treturn;\n\tif (!mpol_store_user_nodemask(pol) &&\n\t    nodes_equal(pol->w.cpuset_mems_allowed, *newmask))\n\t\treturn;\n\n\tmpol_ops[pol->mode].rebind(pol, newmask);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct mempolicy_operations {\n\tint (*create)(struct mempolicy *pol, const nodemask_t *nodes);\n\tvoid (*rebind)(struct mempolicy *pol, const nodemask_t *nodes);\n} mpol_ops[MPOL_MAX];",
            "static const struct mempolicy_operations mpol_ops[MPOL_MAX] = {\n\t[MPOL_DEFAULT] = {\n\t\t.rebind = mpol_rebind_default,\n\t},\n\t[MPOL_INTERLEAVE] = {\n\t\t.create = mpol_new_interleave,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n\t[MPOL_PREFERRED] = {\n\t\t.create = mpol_new_preferred,\n\t\t.rebind = mpol_rebind_preferred,\n\t},\n\t[MPOL_BIND] = {\n\t\t.create = mpol_new_bind,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic const struct mempolicy_operations {\n\tint (*create)(struct mempolicy *pol, const nodemask_t *nodes);\n\tvoid (*rebind)(struct mempolicy *pol, const nodemask_t *nodes);\n} mpol_ops[MPOL_MAX];\nstatic const struct mempolicy_operations mpol_ops[MPOL_MAX] = {\n\t[MPOL_DEFAULT] = {\n\t\t.rebind = mpol_rebind_default,\n\t},\n\t[MPOL_INTERLEAVE] = {\n\t\t.create = mpol_new_interleave,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n\t[MPOL_PREFERRED] = {\n\t\t.create = mpol_new_preferred,\n\t\t.rebind = mpol_rebind_preferred,\n\t},\n\t[MPOL_BIND] = {\n\t\t.create = mpol_new_bind,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n};\n\nstatic void mpol_rebind_policy(struct mempolicy *pol, const nodemask_t *newmask)\n{\n\tif (!pol)\n\t\treturn;\n\tif (!mpol_store_user_nodemask(pol) &&\n\t    nodes_equal(pol->w.cpuset_mems_allowed, *newmask))\n\t\treturn;\n\n\tmpol_ops[pol->mode].rebind(pol, newmask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nvoid mpol_rebind_task(struct task_struct *tsk, const nodemask_t *new)\n{\n\tmpol_rebind_policy(tsk->mempolicy, new);\n}"
  },
  {
    "function_name": "mpol_rebind_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "349-358",
    "snippet": "static void mpol_rebind_policy(struct mempolicy *pol, const nodemask_t *newmask)\n{\n\tif (!pol)\n\t\treturn;\n\tif (!mpol_store_user_nodemask(pol) &&\n\t    nodes_equal(pol->w.cpuset_mems_allowed, *newmask))\n\t\treturn;\n\n\tmpol_ops[pol->mode].rebind(pol, newmask);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct mempolicy_operations {\n\tint (*create)(struct mempolicy *pol, const nodemask_t *nodes);\n\tvoid (*rebind)(struct mempolicy *pol, const nodemask_t *nodes);\n} mpol_ops[MPOL_MAX];",
      "static const struct mempolicy_operations mpol_ops[MPOL_MAX] = {\n\t[MPOL_DEFAULT] = {\n\t\t.rebind = mpol_rebind_default,\n\t},\n\t[MPOL_INTERLEAVE] = {\n\t\t.create = mpol_new_interleave,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n\t[MPOL_PREFERRED] = {\n\t\t.create = mpol_new_preferred,\n\t\t.rebind = mpol_rebind_preferred,\n\t},\n\t[MPOL_BIND] = {\n\t\t.create = mpol_new_bind,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpol_ops[pol->mode].rebind",
          "args": [
            "pol",
            "newmask"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_equal",
          "args": [
            "pol->w.cpuset_mems_allowed",
            "*newmask"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_store_user_nodemask",
          "args": [
            "pol"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_store_user_nodemask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "154-157",
          "snippet": "static inline int mpol_store_user_nodemask(const struct mempolicy *pol)\n{\n\treturn pol->flags & MPOL_MODE_FLAGS;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic inline int mpol_store_user_nodemask(const struct mempolicy *pol)\n{\n\treturn pol->flags & MPOL_MODE_FLAGS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic const struct mempolicy_operations {\n\tint (*create)(struct mempolicy *pol, const nodemask_t *nodes);\n\tvoid (*rebind)(struct mempolicy *pol, const nodemask_t *nodes);\n} mpol_ops[MPOL_MAX];\nstatic const struct mempolicy_operations mpol_ops[MPOL_MAX] = {\n\t[MPOL_DEFAULT] = {\n\t\t.rebind = mpol_rebind_default,\n\t},\n\t[MPOL_INTERLEAVE] = {\n\t\t.create = mpol_new_interleave,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n\t[MPOL_PREFERRED] = {\n\t\t.create = mpol_new_preferred,\n\t\t.rebind = mpol_rebind_preferred,\n\t},\n\t[MPOL_BIND] = {\n\t\t.create = mpol_new_bind,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n};\n\nstatic void mpol_rebind_policy(struct mempolicy *pol, const nodemask_t *newmask)\n{\n\tif (!pol)\n\t\treturn;\n\tif (!mpol_store_user_nodemask(pol) &&\n\t    nodes_equal(pol->w.cpuset_mems_allowed, *newmask))\n\t\treturn;\n\n\tmpol_ops[pol->mode].rebind(pol, newmask);\n}"
  },
  {
    "function_name": "mpol_rebind_preferred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "318-340",
    "snippet": "static void mpol_rebind_preferred(struct mempolicy *pol,\n\t\t\t\t\t\tconst nodemask_t *nodes)\n{\n\tnodemask_t tmp;\n\n\tif (pol->flags & MPOL_F_STATIC_NODES) {\n\t\tint node = first_node(pol->w.user_nodemask);\n\n\t\tif (node_isset(node, *nodes)) {\n\t\t\tpol->v.preferred_node = node;\n\t\t\tpol->flags &= ~MPOL_F_LOCAL;\n\t\t} else\n\t\t\tpol->flags |= MPOL_F_LOCAL;\n\t} else if (pol->flags & MPOL_F_RELATIVE_NODES) {\n\t\tmpol_relative_nodemask(&tmp, &pol->w.user_nodemask, nodes);\n\t\tpol->v.preferred_node = first_node(tmp);\n\t} else if (!(pol->flags & MPOL_F_LOCAL)) {\n\t\tpol->v.preferred_node = node_remap(pol->v.preferred_node,\n\t\t\t\t\t\t   pol->w.cpuset_mems_allowed,\n\t\t\t\t\t\t   *nodes);\n\t\tpol->w.cpuset_mems_allowed = *nodes;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_remap",
          "args": [
            "pol->v.preferred_node",
            "pol->w.cpuset_mems_allowed",
            "*nodes"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "first_node",
          "args": [
            "tmp"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_relative_nodemask",
          "args": [
            "&tmp",
            "&pol->w.user_nodemask",
            "nodes"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_relative_nodemask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "159-165",
          "snippet": "static void mpol_relative_nodemask(nodemask_t *ret, const nodemask_t *orig,\n\t\t\t\t   const nodemask_t *rel)\n{\n\tnodemask_t tmp;\n\tnodes_fold(tmp, *orig, nodes_weight(*rel));\n\tnodes_onto(*ret, tmp, *rel);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void mpol_relative_nodemask(nodemask_t *ret, const nodemask_t *orig,\n\t\t\t\t   const nodemask_t *rel)\n{\n\tnodemask_t tmp;\n\tnodes_fold(tmp, *orig, nodes_weight(*rel));\n\tnodes_onto(*ret, tmp, *rel);\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_isset",
          "args": [
            "node",
            "*nodes"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "first_node",
          "args": [
            "pol->w.user_nodemask"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic void mpol_rebind_preferred(struct mempolicy *pol,\n\t\t\t\t\t\tconst nodemask_t *nodes)\n{\n\tnodemask_t tmp;\n\n\tif (pol->flags & MPOL_F_STATIC_NODES) {\n\t\tint node = first_node(pol->w.user_nodemask);\n\n\t\tif (node_isset(node, *nodes)) {\n\t\t\tpol->v.preferred_node = node;\n\t\t\tpol->flags &= ~MPOL_F_LOCAL;\n\t\t} else\n\t\t\tpol->flags |= MPOL_F_LOCAL;\n\t} else if (pol->flags & MPOL_F_RELATIVE_NODES) {\n\t\tmpol_relative_nodemask(&tmp, &pol->w.user_nodemask, nodes);\n\t\tpol->v.preferred_node = first_node(tmp);\n\t} else if (!(pol->flags & MPOL_F_LOCAL)) {\n\t\tpol->v.preferred_node = node_remap(pol->v.preferred_node,\n\t\t\t\t\t\t   pol->w.cpuset_mems_allowed,\n\t\t\t\t\t\t   *nodes);\n\t\tpol->w.cpuset_mems_allowed = *nodes;\n\t}\n}"
  },
  {
    "function_name": "mpol_rebind_nodemask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "298-316",
    "snippet": "static void mpol_rebind_nodemask(struct mempolicy *pol, const nodemask_t *nodes)\n{\n\tnodemask_t tmp;\n\n\tif (pol->flags & MPOL_F_STATIC_NODES)\n\t\tnodes_and(tmp, pol->w.user_nodemask, *nodes);\n\telse if (pol->flags & MPOL_F_RELATIVE_NODES)\n\t\tmpol_relative_nodemask(&tmp, &pol->w.user_nodemask, nodes);\n\telse {\n\t\tnodes_remap(tmp, pol->v.nodes,pol->w.cpuset_mems_allowed,\n\t\t\t\t\t\t\t\t*nodes);\n\t\tpol->w.cpuset_mems_allowed = tmp;\n\t}\n\n\tif (nodes_empty(tmp))\n\t\ttmp = *nodes;\n\n\tpol->v.nodes = tmp;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nodes_empty",
          "args": [
            "tmp"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_remap",
          "args": [
            "tmp",
            "pol->v.nodes",
            "pol->w.cpuset_mems_allowed",
            "*nodes"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_relative_nodemask",
          "args": [
            "&tmp",
            "&pol->w.user_nodemask",
            "nodes"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_relative_nodemask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "159-165",
          "snippet": "static void mpol_relative_nodemask(nodemask_t *ret, const nodemask_t *orig,\n\t\t\t\t   const nodemask_t *rel)\n{\n\tnodemask_t tmp;\n\tnodes_fold(tmp, *orig, nodes_weight(*rel));\n\tnodes_onto(*ret, tmp, *rel);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void mpol_relative_nodemask(nodemask_t *ret, const nodemask_t *orig,\n\t\t\t\t   const nodemask_t *rel)\n{\n\tnodemask_t tmp;\n\tnodes_fold(tmp, *orig, nodes_weight(*rel));\n\tnodes_onto(*ret, tmp, *rel);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodes_and",
          "args": [
            "tmp",
            "pol->w.user_nodemask",
            "*nodes"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic void mpol_rebind_nodemask(struct mempolicy *pol, const nodemask_t *nodes)\n{\n\tnodemask_t tmp;\n\n\tif (pol->flags & MPOL_F_STATIC_NODES)\n\t\tnodes_and(tmp, pol->w.user_nodemask, *nodes);\n\telse if (pol->flags & MPOL_F_RELATIVE_NODES)\n\t\tmpol_relative_nodemask(&tmp, &pol->w.user_nodemask, nodes);\n\telse {\n\t\tnodes_remap(tmp, pol->v.nodes,pol->w.cpuset_mems_allowed,\n\t\t\t\t\t\t\t\t*nodes);\n\t\tpol->w.cpuset_mems_allowed = tmp;\n\t}\n\n\tif (nodes_empty(tmp))\n\t\ttmp = *nodes;\n\n\tpol->v.nodes = tmp;\n}"
  },
  {
    "function_name": "mpol_rebind_default",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "294-296",
    "snippet": "static void mpol_rebind_default(struct mempolicy *pol, const nodemask_t *nodes)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void mpol_rebind_default(struct mempolicy *pol, const nodemask_t *nodes)\n{\n}"
  },
  {
    "function_name": "__mpol_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "287-292",
    "snippet": "void __mpol_put(struct mempolicy *p)\n{\n\tif (!atomic_dec_and_test(&p->refcnt))\n\t\treturn;\n\tkmem_cache_free(policy_cache, p);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *policy_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "policy_cache",
            "p"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3749-3764",
          "snippet": "void kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&p->refcnt"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct kmem_cache *policy_cache;\n\nvoid __mpol_put(struct mempolicy *p)\n{\n\tif (!atomic_dec_and_test(&p->refcnt))\n\t\treturn;\n\tkmem_cache_free(policy_cache, p);\n}"
  },
  {
    "function_name": "mpol_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "242-284",
    "snippet": "static struct mempolicy *mpol_new(unsigned short mode, unsigned short flags,\n\t\t\t\t  nodemask_t *nodes)\n{\n\tstruct mempolicy *policy;\n\n\tpr_debug(\"setting mode %d flags %d nodes[0] %lx\\n\",\n\t\t mode, flags, nodes ? nodes_addr(*nodes)[0] : NUMA_NO_NODE);\n\n\tif (mode == MPOL_DEFAULT) {\n\t\tif (nodes && !nodes_empty(*nodes))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\treturn NULL;\n\t}\n\tVM_BUG_ON(!nodes);\n\n\t/*\n\t * MPOL_PREFERRED cannot be used with MPOL_F_STATIC_NODES or\n\t * MPOL_F_RELATIVE_NODES if the nodemask is empty (local allocation).\n\t * All other modes require a valid pointer to a non-empty nodemask.\n\t */\n\tif (mode == MPOL_PREFERRED) {\n\t\tif (nodes_empty(*nodes)) {\n\t\t\tif (((flags & MPOL_F_STATIC_NODES) ||\n\t\t\t     (flags & MPOL_F_RELATIVE_NODES)))\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t} else if (mode == MPOL_LOCAL) {\n\t\tif (!nodes_empty(*nodes) ||\n\t\t    (flags & MPOL_F_STATIC_NODES) ||\n\t\t    (flags & MPOL_F_RELATIVE_NODES))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tmode = MPOL_PREFERRED;\n\t} else if (nodes_empty(*nodes))\n\t\treturn ERR_PTR(-EINVAL);\n\tpolicy = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\tif (!policy)\n\t\treturn ERR_PTR(-ENOMEM);\n\tatomic_set(&policy->refcnt, 1);\n\tpolicy->mode = mode;\n\tpolicy->flags = flags;\n\n\treturn policy;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *policy_cache;",
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&policy->refcnt",
            "1"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "policy_cache",
            "GFP_KERNEL"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3550-3559",
          "snippet": "void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *ret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc(_RET_IP_, ret,\n\t\t\t       cachep->object_size, cachep->size, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *ret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc(_RET_IP_, ret,\n\t\t\t       cachep->object_size, cachep->size, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_empty",
          "args": [
            "*nodes"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_empty",
          "args": [
            "*nodes"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_empty",
          "args": [
            "*nodes"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!nodes"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_empty",
          "args": [
            "*nodes"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"setting mode %d flags %d nodes[0] %lx\\n\"",
            "mode",
            "flags",
            "nodes ? nodes_addr(*nodes)[0] : NUMA_NO_NODE"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_addr",
          "args": [
            "*nodes"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct kmem_cache *policy_cache;\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic struct mempolicy *mpol_new(unsigned short mode, unsigned short flags,\n\t\t\t\t  nodemask_t *nodes)\n{\n\tstruct mempolicy *policy;\n\n\tpr_debug(\"setting mode %d flags %d nodes[0] %lx\\n\",\n\t\t mode, flags, nodes ? nodes_addr(*nodes)[0] : NUMA_NO_NODE);\n\n\tif (mode == MPOL_DEFAULT) {\n\t\tif (nodes && !nodes_empty(*nodes))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\treturn NULL;\n\t}\n\tVM_BUG_ON(!nodes);\n\n\t/*\n\t * MPOL_PREFERRED cannot be used with MPOL_F_STATIC_NODES or\n\t * MPOL_F_RELATIVE_NODES if the nodemask is empty (local allocation).\n\t * All other modes require a valid pointer to a non-empty nodemask.\n\t */\n\tif (mode == MPOL_PREFERRED) {\n\t\tif (nodes_empty(*nodes)) {\n\t\t\tif (((flags & MPOL_F_STATIC_NODES) ||\n\t\t\t     (flags & MPOL_F_RELATIVE_NODES)))\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t} else if (mode == MPOL_LOCAL) {\n\t\tif (!nodes_empty(*nodes) ||\n\t\t    (flags & MPOL_F_STATIC_NODES) ||\n\t\t    (flags & MPOL_F_RELATIVE_NODES))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tmode = MPOL_PREFERRED;\n\t} else if (nodes_empty(*nodes))\n\t\treturn ERR_PTR(-EINVAL);\n\tpolicy = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\tif (!policy)\n\t\treturn ERR_PTR(-ENOMEM);\n\tatomic_set(&policy->refcnt, 1);\n\tpolicy->mode = mode;\n\tpolicy->flags = flags;\n\n\treturn policy;\n}"
  },
  {
    "function_name": "mpol_set_nodemask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "203-236",
    "snippet": "static int mpol_set_nodemask(struct mempolicy *pol,\n\t\t     const nodemask_t *nodes, struct nodemask_scratch *nsc)\n{\n\tint ret;\n\n\t/* if mode is MPOL_DEFAULT, pol is NULL. This is right. */\n\tif (pol == NULL)\n\t\treturn 0;\n\t/* Check N_MEMORY */\n\tnodes_and(nsc->mask1,\n\t\t  cpuset_current_mems_allowed, node_states[N_MEMORY]);\n\n\tVM_BUG_ON(!nodes);\n\tif (pol->mode == MPOL_PREFERRED && nodes_empty(*nodes))\n\t\tnodes = NULL;\t/* explicit local allocation */\n\telse {\n\t\tif (pol->flags & MPOL_F_RELATIVE_NODES)\n\t\t\tmpol_relative_nodemask(&nsc->mask2, nodes, &nsc->mask1);\n\t\telse\n\t\t\tnodes_and(nsc->mask2, *nodes, nsc->mask1);\n\n\t\tif (mpol_store_user_nodemask(pol))\n\t\t\tpol->w.user_nodemask = *nodes;\n\t\telse\n\t\t\tpol->w.cpuset_mems_allowed =\n\t\t\t\t\t\tcpuset_current_mems_allowed;\n\t}\n\n\tif (nodes)\n\t\tret = mpol_ops[pol->mode].create(pol, &nsc->mask2);\n\telse\n\t\tret = mpol_ops[pol->mode].create(pol, NULL);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct mempolicy_operations {\n\tint (*create)(struct mempolicy *pol, const nodemask_t *nodes);\n\tvoid (*rebind)(struct mempolicy *pol, const nodemask_t *nodes);\n} mpol_ops[MPOL_MAX];",
      "static const struct mempolicy_operations mpol_ops[MPOL_MAX] = {\n\t[MPOL_DEFAULT] = {\n\t\t.rebind = mpol_rebind_default,\n\t},\n\t[MPOL_INTERLEAVE] = {\n\t\t.create = mpol_new_interleave,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n\t[MPOL_PREFERRED] = {\n\t\t.create = mpol_new_preferred,\n\t\t.rebind = mpol_rebind_preferred,\n\t},\n\t[MPOL_BIND] = {\n\t\t.create = mpol_new_bind,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n};",
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpol_ops[pol->mode].create",
          "args": [
            "pol",
            "NULL"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_ops[pol->mode].create",
          "args": [
            "pol",
            "&nsc->mask2"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_store_user_nodemask",
          "args": [
            "pol"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_store_user_nodemask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "154-157",
          "snippet": "static inline int mpol_store_user_nodemask(const struct mempolicy *pol)\n{\n\treturn pol->flags & MPOL_MODE_FLAGS;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic inline int mpol_store_user_nodemask(const struct mempolicy *pol)\n{\n\treturn pol->flags & MPOL_MODE_FLAGS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodes_and",
          "args": [
            "nsc->mask2",
            "*nodes",
            "nsc->mask1"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_relative_nodemask",
          "args": [
            "&nsc->mask2",
            "nodes",
            "&nsc->mask1"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_relative_nodemask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "159-165",
          "snippet": "static void mpol_relative_nodemask(nodemask_t *ret, const nodemask_t *orig,\n\t\t\t\t   const nodemask_t *rel)\n{\n\tnodemask_t tmp;\n\tnodes_fold(tmp, *orig, nodes_weight(*rel));\n\tnodes_onto(*ret, tmp, *rel);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void mpol_relative_nodemask(nodemask_t *ret, const nodemask_t *orig,\n\t\t\t\t   const nodemask_t *rel)\n{\n\tnodemask_t tmp;\n\tnodes_fold(tmp, *orig, nodes_weight(*rel));\n\tnodes_onto(*ret, tmp, *rel);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodes_empty",
          "args": [
            "*nodes"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!nodes"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_and",
          "args": [
            "nsc->mask1",
            "cpuset_current_mems_allowed",
            "node_states[N_MEMORY]"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic const struct mempolicy_operations {\n\tint (*create)(struct mempolicy *pol, const nodemask_t *nodes);\n\tvoid (*rebind)(struct mempolicy *pol, const nodemask_t *nodes);\n} mpol_ops[MPOL_MAX];\nstatic const struct mempolicy_operations mpol_ops[MPOL_MAX] = {\n\t[MPOL_DEFAULT] = {\n\t\t.rebind = mpol_rebind_default,\n\t},\n\t[MPOL_INTERLEAVE] = {\n\t\t.create = mpol_new_interleave,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n\t[MPOL_PREFERRED] = {\n\t\t.create = mpol_new_preferred,\n\t\t.rebind = mpol_rebind_preferred,\n\t},\n\t[MPOL_BIND] = {\n\t\t.create = mpol_new_bind,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n};\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic int mpol_set_nodemask(struct mempolicy *pol,\n\t\t     const nodemask_t *nodes, struct nodemask_scratch *nsc)\n{\n\tint ret;\n\n\t/* if mode is MPOL_DEFAULT, pol is NULL. This is right. */\n\tif (pol == NULL)\n\t\treturn 0;\n\t/* Check N_MEMORY */\n\tnodes_and(nsc->mask1,\n\t\t  cpuset_current_mems_allowed, node_states[N_MEMORY]);\n\n\tVM_BUG_ON(!nodes);\n\tif (pol->mode == MPOL_PREFERRED && nodes_empty(*nodes))\n\t\tnodes = NULL;\t/* explicit local allocation */\n\telse {\n\t\tif (pol->flags & MPOL_F_RELATIVE_NODES)\n\t\t\tmpol_relative_nodemask(&nsc->mask2, nodes, &nsc->mask1);\n\t\telse\n\t\t\tnodes_and(nsc->mask2, *nodes, nsc->mask1);\n\n\t\tif (mpol_store_user_nodemask(pol))\n\t\t\tpol->w.user_nodemask = *nodes;\n\t\telse\n\t\t\tpol->w.cpuset_mems_allowed =\n\t\t\t\t\t\tcpuset_current_mems_allowed;\n\t}\n\n\tif (nodes)\n\t\tret = mpol_ops[pol->mode].create(pol, &nsc->mask2);\n\telse\n\t\tret = mpol_ops[pol->mode].create(pol, NULL);\n\treturn ret;\n}"
  },
  {
    "function_name": "mpol_new_bind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "186-192",
    "snippet": "static int mpol_new_bind(struct mempolicy *pol, const nodemask_t *nodes)\n{\n\tif (nodes_empty(*nodes))\n\t\treturn -EINVAL;\n\tpol->v.nodes = *nodes;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nodes_empty",
          "args": [
            "*nodes"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic int mpol_new_bind(struct mempolicy *pol, const nodemask_t *nodes)\n{\n\tif (nodes_empty(*nodes))\n\t\treturn -EINVAL;\n\tpol->v.nodes = *nodes;\n\treturn 0;\n}"
  },
  {
    "function_name": "mpol_new_preferred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "175-184",
    "snippet": "static int mpol_new_preferred(struct mempolicy *pol, const nodemask_t *nodes)\n{\n\tif (!nodes)\n\t\tpol->flags |= MPOL_F_LOCAL;\t/* local allocation */\n\telse if (nodes_empty(*nodes))\n\t\treturn -EINVAL;\t\t\t/*  no allowed nodes */\n\telse\n\t\tpol->v.preferred_node = first_node(*nodes);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "first_node",
          "args": [
            "*nodes"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_empty",
          "args": [
            "*nodes"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic int mpol_new_preferred(struct mempolicy *pol, const nodemask_t *nodes)\n{\n\tif (!nodes)\n\t\tpol->flags |= MPOL_F_LOCAL;\t/* local allocation */\n\telse if (nodes_empty(*nodes))\n\t\treturn -EINVAL;\t\t\t/*  no allowed nodes */\n\telse\n\t\tpol->v.preferred_node = first_node(*nodes);\n\treturn 0;\n}"
  },
  {
    "function_name": "mpol_new_interleave",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "167-173",
    "snippet": "static int mpol_new_interleave(struct mempolicy *pol, const nodemask_t *nodes)\n{\n\tif (nodes_empty(*nodes))\n\t\treturn -EINVAL;\n\tpol->v.nodes = *nodes;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nodes_empty",
          "args": [
            "*nodes"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic int mpol_new_interleave(struct mempolicy *pol, const nodemask_t *nodes)\n{\n\tif (nodes_empty(*nodes))\n\t\treturn -EINVAL;\n\tpol->v.nodes = *nodes;\n\treturn 0;\n}"
  },
  {
    "function_name": "mpol_relative_nodemask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "159-165",
    "snippet": "static void mpol_relative_nodemask(nodemask_t *ret, const nodemask_t *orig,\n\t\t\t\t   const nodemask_t *rel)\n{\n\tnodemask_t tmp;\n\tnodes_fold(tmp, *orig, nodes_weight(*rel));\n\tnodes_onto(*ret, tmp, *rel);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nodes_onto",
          "args": [
            "*ret",
            "tmp",
            "*rel"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_fold",
          "args": [
            "tmp",
            "*orig",
            "nodes_weight(*rel)"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_weight",
          "args": [
            "*rel"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void mpol_relative_nodemask(nodemask_t *ret, const nodemask_t *orig,\n\t\t\t\t   const nodemask_t *rel)\n{\n\tnodemask_t tmp;\n\tnodes_fold(tmp, *orig, nodes_weight(*rel));\n\tnodes_onto(*ret, tmp, *rel);\n}"
  },
  {
    "function_name": "mpol_store_user_nodemask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "154-157",
    "snippet": "static inline int mpol_store_user_nodemask(const struct mempolicy *pol)\n{\n\treturn pol->flags & MPOL_MODE_FLAGS;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstatic inline int mpol_store_user_nodemask(const struct mempolicy *pol)\n{\n\treturn pol->flags & MPOL_MODE_FLAGS;\n}"
  },
  {
    "function_name": "get_task_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "130-147",
    "snippet": "struct mempolicy *get_task_policy(struct task_struct *p)\n{\n\tstruct mempolicy *pol = p->mempolicy;\n\tint node;\n\n\tif (pol)\n\t\treturn pol;\n\n\tnode = numa_node_id();\n\tif (node != NUMA_NO_NODE) {\n\t\tpol = &preferred_node_policy[node];\n\t\t/* preferred_node_policy is not initialised early in boot */\n\t\tif (pol->mode)\n\t\t\treturn pol;\n\t}\n\n\treturn &default_policy;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct mempolicy default_policy = {\n\t.refcnt = ATOMIC_INIT(1), /* never free it */\n\t.mode = MPOL_PREFERRED,\n\t.flags = MPOL_F_LOCAL,\n};",
      "static struct mempolicy preferred_node_policy[MAX_NUMNODES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "numa_node_id",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic struct mempolicy default_policy = {\n\t.refcnt = ATOMIC_INIT(1), /* never free it */\n\t.mode = MPOL_PREFERRED,\n\t.flags = MPOL_F_LOCAL,\n};\nstatic struct mempolicy preferred_node_policy[MAX_NUMNODES];\n\nstruct mempolicy *get_task_policy(struct task_struct *p)\n{\n\tstruct mempolicy *pol = p->mempolicy;\n\tint node;\n\n\tif (pol)\n\t\treturn pol;\n\n\tnode = numa_node_id();\n\tif (node != NUMA_NO_NODE) {\n\t\tpol = &preferred_node_policy[node];\n\t\t/* preferred_node_policy is not initialised early in boot */\n\t\tif (pol->mode)\n\t\t\treturn pol;\n\t}\n\n\treturn &default_policy;\n}"
  },
  {
    "function_name": "mbind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1350-1355",
    "snippet": "SYSCALL_DEFINE6(mbind, unsigned long, start, unsigned long, len,\n\t\tunsigned long, mode, const unsigned long __user *, nmask,\n\t\tunsigned long, maxnode, unsigned int, flags)\n{\n\treturn kernel_mbind(start, len, mode, nmask, maxnode, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nSYSCALL_DEFINE6(mbind, unsigned long, start, unsigned long, len,\n\t\tunsigned long, mode, const unsigned long __user *, nmask,\n\t\tunsigned long, maxnode, unsigned int, flags)\n{\n\treturn kernel_mbind(start, len, mode, nmask, maxnode, flags);\n}"
  },
  {
    "function_name": "set_mempolicy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1377-1381",
    "snippet": "SYSCALL_DEFINE3(set_mempolicy, int, mode, const unsigned long __user *, nmask,\n\t\tunsigned long, maxnode)\n{\n\treturn kernel_set_mempolicy(mode, nmask, maxnode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nSYSCALL_DEFINE3(set_mempolicy, int, mode, const unsigned long __user *, nmask,\n\t\tunsigned long, maxnode)\n{\n\treturn kernel_set_mempolicy(mode, nmask, maxnode);\n}"
  },
  {
    "function_name": "migrate_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1475-1480",
    "snippet": "SYSCALL_DEFINE4(migrate_pages, pid_t, pid, unsigned long, maxnode,\n\t\tconst unsigned long __user *, old_nodes,\n\t\tconst unsigned long __user *, new_nodes)\n{\n\treturn kernel_migrate_pages(pid, maxnode, old_nodes, new_nodes);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nSYSCALL_DEFINE4(migrate_pages, pid_t, pid, unsigned long, maxnode,\n\t\tconst unsigned long __user *, old_nodes,\n\t\tconst unsigned long __user *, new_nodes)\n{\n\treturn kernel_migrate_pages(pid, maxnode, old_nodes, new_nodes);\n}"
  },
  {
    "function_name": "get_mempolicy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1511-1516",
    "snippet": "SYSCALL_DEFINE5(get_mempolicy, int __user *, policy,\n\t\tunsigned long __user *, nmask, unsigned long, maxnode,\n\t\tunsigned long, addr, unsigned long, flags)\n{\n\treturn kernel_get_mempolicy(policy, nmask, maxnode, addr, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nSYSCALL_DEFINE5(get_mempolicy, int __user *, policy,\n\t\tunsigned long __user *, nmask, unsigned long, maxnode,\n\t\tunsigned long, addr, unsigned long, flags)\n{\n\treturn kernel_get_mempolicy(policy, nmask, maxnode, addr, flags);\n}"
  },
  {
    "function_name": "get_mempolicy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1520-1548",
    "snippet": "SYSCALL_DEFINE5(get_mempolicy, int __user *, policy,\n\t\t       compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode,\n\t\t       compat_ulong_t, addr, compat_ulong_t, flags)\n{\n\tlong err;\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tDECLARE_BITMAP(bm, MAX_NUMNODES);\n\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\n\tif (nmask)\n\t\tnm = compat_alloc_user_space(alloc_size);\n\n\terr = kernel_get_mempolicy(policy, nm, nr_bits+1, addr, flags);\n\n\tif (!err && nmask) {\n\t\tunsigned long copy_size;\n\t\tcopy_size = min_t(unsigned long, sizeof(bm), alloc_size);\n\t\terr = copy_from_user(bm, nm, copy_size);\n\t\t/* ensure entire bitmap is zeroed */\n\t\terr |= clear_user(nmask, ALIGN(maxnode-1, 8) / 8);\n\t\terr |= compat_put_bitmap(nmask, bm, nr_bits);\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nSYSCALL_DEFINE5(get_mempolicy, int __user *, policy,\n\t\t       compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode,\n\t\t       compat_ulong_t, addr, compat_ulong_t, flags)\n{\n\tlong err;\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tDECLARE_BITMAP(bm, MAX_NUMNODES);\n\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\n\tif (nmask)\n\t\tnm = compat_alloc_user_space(alloc_size);\n\n\terr = kernel_get_mempolicy(policy, nm, nr_bits+1, addr, flags);\n\n\tif (!err && nmask) {\n\t\tunsigned long copy_size;\n\t\tcopy_size = min_t(unsigned long, sizeof(bm), alloc_size);\n\t\terr = copy_from_user(bm, nm, copy_size);\n\t\t/* ensure entire bitmap is zeroed */\n\t\terr |= clear_user(nmask, ALIGN(maxnode-1, 8) / 8);\n\t\terr |= compat_put_bitmap(nmask, bm, nr_bits);\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "set_mempolicy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1550-1569",
    "snippet": "SYSCALL_DEFINE3(set_mempolicy, int, mode, compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode)\n{\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tDECLARE_BITMAP(bm, MAX_NUMNODES);\n\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\n\tif (nmask) {\n\t\tif (compat_get_bitmap(bm, nmask, nr_bits))\n\t\t\treturn -EFAULT;\n\t\tnm = compat_alloc_user_space(alloc_size);\n\t\tif (copy_to_user(nm, bm, alloc_size))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn kernel_set_mempolicy(mode, nm, nr_bits+1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nSYSCALL_DEFINE3(set_mempolicy, int, mode, compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode)\n{\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tDECLARE_BITMAP(bm, MAX_NUMNODES);\n\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\n\tif (nmask) {\n\t\tif (compat_get_bitmap(bm, nmask, nr_bits))\n\t\t\treturn -EFAULT;\n\t\tnm = compat_alloc_user_space(alloc_size);\n\t\tif (copy_to_user(nm, bm, alloc_size))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn kernel_set_mempolicy(mode, nm, nr_bits+1);\n}"
  },
  {
    "function_name": "mbind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1571-1591",
    "snippet": "SYSCALL_DEFINE6(mbind, compat_ulong_t, start, compat_ulong_t, len,\n\t\t       compat_ulong_t, mode, compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode, compat_ulong_t, flags)\n{\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tnodemask_t bm;\n\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\n\tif (nmask) {\n\t\tif (compat_get_bitmap(nodes_addr(bm), nmask, nr_bits))\n\t\t\treturn -EFAULT;\n\t\tnm = compat_alloc_user_space(alloc_size);\n\t\tif (copy_to_user(nm, nodes_addr(bm), alloc_size))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn kernel_mbind(start, len, mode, nm, nr_bits+1, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nSYSCALL_DEFINE6(mbind, compat_ulong_t, start, compat_ulong_t, len,\n\t\t       compat_ulong_t, mode, compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode, compat_ulong_t, flags)\n{\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tnodemask_t bm;\n\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\n\tif (nmask) {\n\t\tif (compat_get_bitmap(nodes_addr(bm), nmask, nr_bits))\n\t\t\treturn -EFAULT;\n\t\tnm = compat_alloc_user_space(alloc_size);\n\t\tif (copy_to_user(nm, nodes_addr(bm), alloc_size))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn kernel_mbind(start, len, mode, nm, nr_bits+1, flags);\n}"
  },
  {
    "function_name": "migrate_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
    "lines": "1593-1624",
    "snippet": "SYSCALL_DEFINE4(migrate_pages, compat_pid_t, pid,\n\t\t       compat_ulong_t, maxnode,\n\t\t       const compat_ulong_t __user *, old_nodes,\n\t\t       const compat_ulong_t __user *, new_nodes)\n{\n\tunsigned long __user *old = NULL;\n\tunsigned long __user *new = NULL;\n\tnodemask_t tmp_mask;\n\tunsigned long nr_bits;\n\tunsigned long size;\n\n\tnr_bits = min_t(unsigned long, maxnode - 1, MAX_NUMNODES);\n\tsize = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\tif (old_nodes) {\n\t\tif (compat_get_bitmap(nodes_addr(tmp_mask), old_nodes, nr_bits))\n\t\t\treturn -EFAULT;\n\t\told = compat_alloc_user_space(new_nodes ? size * 2 : size);\n\t\tif (new_nodes)\n\t\t\tnew = old + size / sizeof(unsigned long);\n\t\tif (copy_to_user(old, nodes_addr(tmp_mask), size))\n\t\t\treturn -EFAULT;\n\t}\n\tif (new_nodes) {\n\t\tif (compat_get_bitmap(nodes_addr(tmp_mask), new_nodes, nr_bits))\n\t\t\treturn -EFAULT;\n\t\tif (new == NULL)\n\t\t\tnew = compat_alloc_user_space(size);\n\t\tif (copy_to_user(new, nodes_addr(tmp_mask), size))\n\t\t\treturn -EFAULT;\n\t}\n\treturn kernel_migrate_pages(pid, nr_bits + 1, old, new);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/swapops.h>",
      "#include <linux/printk.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/ctype.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/swap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/compat.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nSYSCALL_DEFINE4(migrate_pages, compat_pid_t, pid,\n\t\t       compat_ulong_t, maxnode,\n\t\t       const compat_ulong_t __user *, old_nodes,\n\t\t       const compat_ulong_t __user *, new_nodes)\n{\n\tunsigned long __user *old = NULL;\n\tunsigned long __user *new = NULL;\n\tnodemask_t tmp_mask;\n\tunsigned long nr_bits;\n\tunsigned long size;\n\n\tnr_bits = min_t(unsigned long, maxnode - 1, MAX_NUMNODES);\n\tsize = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\tif (old_nodes) {\n\t\tif (compat_get_bitmap(nodes_addr(tmp_mask), old_nodes, nr_bits))\n\t\t\treturn -EFAULT;\n\t\told = compat_alloc_user_space(new_nodes ? size * 2 : size);\n\t\tif (new_nodes)\n\t\t\tnew = old + size / sizeof(unsigned long);\n\t\tif (copy_to_user(old, nodes_addr(tmp_mask), size))\n\t\t\treturn -EFAULT;\n\t}\n\tif (new_nodes) {\n\t\tif (compat_get_bitmap(nodes_addr(tmp_mask), new_nodes, nr_bits))\n\t\t\treturn -EFAULT;\n\t\tif (new == NULL)\n\t\t\tnew = compat_alloc_user_space(size);\n\t\tif (copy_to_user(new, nodes_addr(tmp_mask), size))\n\t\t\treturn -EFAULT;\n\t}\n\treturn kernel_migrate_pages(pid, nr_bits + 1, old, new);\n}"
  }
]