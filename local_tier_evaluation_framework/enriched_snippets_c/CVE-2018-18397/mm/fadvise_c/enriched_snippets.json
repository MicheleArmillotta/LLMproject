[
  {
    "function_name": "ksys_fadvise64_64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/fadvise.c",
    "lines": "193-205",
    "snippet": "int ksys_fadvise64_64(int fd, loff_t offset, loff_t len, int advice)\n{\n\tstruct fd f = fdget(fd);\n\tint ret;\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tret = vfs_fadvise(f.file, offset, len, advice);\n\n\tfdput(f);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fadvise.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_fadvise",
          "args": [
            "f.file",
            "offset",
            "len",
            "advice"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_fadvise",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/fadvise.c",
          "lines": "182-188",
          "snippet": "int vfs_fadvise(struct file *file, loff_t offset, loff_t len, int advice)\n{\n\tif (file->f_op->fadvise)\n\t\treturn file->f_op->fadvise(file, offset, len, advice);\n\n\treturn generic_fadvise(file, offset, len, advice);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/swap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/fadvise.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/fadvise.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint vfs_fadvise(struct file *file, loff_t offset, loff_t len, int advice)\n{\n\tif (file->f_op->fadvise)\n\t\treturn file->f_op->fadvise(file, offset, len, advice);\n\n\treturn generic_fadvise(file, offset, len, advice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/fadvise.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint ksys_fadvise64_64(int fd, loff_t offset, loff_t len, int advice)\n{\n\tstruct fd f = fdget(fd);\n\tint ret;\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tret = vfs_fadvise(f.file, offset, len, advice);\n\n\tfdput(f);\n\treturn ret;\n}"
  },
  {
    "function_name": "vfs_fadvise",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/fadvise.c",
    "lines": "182-188",
    "snippet": "int vfs_fadvise(struct file *file, loff_t offset, loff_t len, int advice)\n{\n\tif (file->f_op->fadvise)\n\t\treturn file->f_op->fadvise(file, offset, len, advice);\n\n\treturn generic_fadvise(file, offset, len, advice);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fadvise.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fadvise",
          "args": [
            "file",
            "offset",
            "len",
            "advice"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fadvise",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/fadvise.c",
          "lines": "30-180",
          "snippet": "static int generic_fadvise(struct file *file, loff_t offset, loff_t len,\n\t\t\t   int advice)\n{\n\tstruct inode *inode;\n\tstruct address_space *mapping;\n\tstruct backing_dev_info *bdi;\n\tloff_t endbyte;\t\t\t/* inclusive */\n\tpgoff_t start_index;\n\tpgoff_t end_index;\n\tunsigned long nrpages;\n\n\tinode = file_inode(file);\n\tif (S_ISFIFO(inode->i_mode))\n\t\treturn -ESPIPE;\n\n\tmapping = file->f_mapping;\n\tif (!mapping || len < 0)\n\t\treturn -EINVAL;\n\n\tbdi = inode_to_bdi(mapping->host);\n\n\tif (IS_DAX(inode) || (bdi == &noop_backing_dev_info)) {\n\t\tswitch (advice) {\n\t\tcase POSIX_FADV_NORMAL:\n\t\tcase POSIX_FADV_RANDOM:\n\t\tcase POSIX_FADV_SEQUENTIAL:\n\t\tcase POSIX_FADV_WILLNEED:\n\t\tcase POSIX_FADV_NOREUSE:\n\t\tcase POSIX_FADV_DONTNEED:\n\t\t\t/* no bad return value, but ignore advice */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Careful about overflows. Len == 0 means \"as much as possible\".  Use\n\t * unsigned math because signed overflows are undefined and UBSan\n\t * complains.\n\t */\n\tendbyte = (u64)offset + (u64)len;\n\tif (!len || endbyte < len)\n\t\tendbyte = -1;\n\telse\n\t\tendbyte--;\t\t/* inclusive */\n\n\tswitch (advice) {\n\tcase POSIX_FADV_NORMAL:\n\t\tfile->f_ra.ra_pages = bdi->ra_pages;\n\t\tspin_lock(&file->f_lock);\n\t\tfile->f_mode &= ~FMODE_RANDOM;\n\t\tspin_unlock(&file->f_lock);\n\t\tbreak;\n\tcase POSIX_FADV_RANDOM:\n\t\tspin_lock(&file->f_lock);\n\t\tfile->f_mode |= FMODE_RANDOM;\n\t\tspin_unlock(&file->f_lock);\n\t\tbreak;\n\tcase POSIX_FADV_SEQUENTIAL:\n\t\tfile->f_ra.ra_pages = bdi->ra_pages * 2;\n\t\tspin_lock(&file->f_lock);\n\t\tfile->f_mode &= ~FMODE_RANDOM;\n\t\tspin_unlock(&file->f_lock);\n\t\tbreak;\n\tcase POSIX_FADV_WILLNEED:\n\t\t/* First and last PARTIAL page! */\n\t\tstart_index = offset >> PAGE_SHIFT;\n\t\tend_index = endbyte >> PAGE_SHIFT;\n\n\t\t/* Careful about overflow on the \"+1\" */\n\t\tnrpages = end_index - start_index + 1;\n\t\tif (!nrpages)\n\t\t\tnrpages = ~0UL;\n\n\t\t/*\n\t\t * Ignore return value because fadvise() shall return\n\t\t * success even if filesystem can't retrieve a hint,\n\t\t */\n\t\tforce_page_cache_readahead(mapping, file, start_index, nrpages);\n\t\tbreak;\n\tcase POSIX_FADV_NOREUSE:\n\t\tbreak;\n\tcase POSIX_FADV_DONTNEED:\n\t\tif (!inode_write_congested(mapping->host))\n\t\t\t__filemap_fdatawrite_range(mapping, offset, endbyte,\n\t\t\t\t\t\t   WB_SYNC_NONE);\n\n\t\t/*\n\t\t * First and last FULL page! Partial pages are deliberately\n\t\t * preserved on the expectation that it is better to preserve\n\t\t * needed memory than to discard unneeded memory.\n\t\t */\n\t\tstart_index = (offset+(PAGE_SIZE-1)) >> PAGE_SHIFT;\n\t\tend_index = (endbyte >> PAGE_SHIFT);\n\t\t/*\n\t\t * The page at end_index will be inclusively discarded according\n\t\t * by invalidate_mapping_pages(), so subtracting 1 from\n\t\t * end_index means we will skip the last page.  But if endbyte\n\t\t * is page aligned or is at the end of file, we should not skip\n\t\t * that page - discarding the last page is safe enough.\n\t\t */\n\t\tif ((endbyte & ~PAGE_MASK) != ~PAGE_MASK &&\n\t\t\t\tendbyte != inode->i_size - 1) {\n\t\t\t/* First page is tricky as 0 - 1 = -1, but pgoff_t\n\t\t\t * is unsigned, so the end_index >= start_index\n\t\t\t * check below would be true and we'll discard the whole\n\t\t\t * file cache which is not what was asked.\n\t\t\t */\n\t\t\tif (end_index == 0)\n\t\t\t\tbreak;\n\n\t\t\tend_index--;\n\t\t}\n\n\t\tif (end_index >= start_index) {\n\t\t\tunsigned long count;\n\n\t\t\t/*\n\t\t\t * It's common to FADV_DONTNEED right after\n\t\t\t * the read or write that instantiates the\n\t\t\t * pages, in which case there will be some\n\t\t\t * sitting on the local LRU cache. Try to\n\t\t\t * avoid the expensive remote drain and the\n\t\t\t * second cache tree walk below by flushing\n\t\t\t * them out right away.\n\t\t\t */\n\t\t\tlru_add_drain();\n\n\t\t\tcount = invalidate_mapping_pages(mapping,\n\t\t\t\t\t\tstart_index, end_index);\n\n\t\t\t/*\n\t\t\t * If fewer pages were invalidated than expected then\n\t\t\t * it is possible that some of the pages were on\n\t\t\t * a per-cpu pagevec for a remote CPU. Drain all\n\t\t\t * pagevecs and try again.\n\t\t\t */\n\t\t\tif (count < (end_index - start_index + 1)) {\n\t\t\t\tlru_add_drain_all();\n\t\t\t\tinvalidate_mapping_pages(mapping, start_index,\n\t\t\t\t\t\tend_index);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/swap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/fadvise.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/fadvise.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nstatic int generic_fadvise(struct file *file, loff_t offset, loff_t len,\n\t\t\t   int advice)\n{\n\tstruct inode *inode;\n\tstruct address_space *mapping;\n\tstruct backing_dev_info *bdi;\n\tloff_t endbyte;\t\t\t/* inclusive */\n\tpgoff_t start_index;\n\tpgoff_t end_index;\n\tunsigned long nrpages;\n\n\tinode = file_inode(file);\n\tif (S_ISFIFO(inode->i_mode))\n\t\treturn -ESPIPE;\n\n\tmapping = file->f_mapping;\n\tif (!mapping || len < 0)\n\t\treturn -EINVAL;\n\n\tbdi = inode_to_bdi(mapping->host);\n\n\tif (IS_DAX(inode) || (bdi == &noop_backing_dev_info)) {\n\t\tswitch (advice) {\n\t\tcase POSIX_FADV_NORMAL:\n\t\tcase POSIX_FADV_RANDOM:\n\t\tcase POSIX_FADV_SEQUENTIAL:\n\t\tcase POSIX_FADV_WILLNEED:\n\t\tcase POSIX_FADV_NOREUSE:\n\t\tcase POSIX_FADV_DONTNEED:\n\t\t\t/* no bad return value, but ignore advice */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Careful about overflows. Len == 0 means \"as much as possible\".  Use\n\t * unsigned math because signed overflows are undefined and UBSan\n\t * complains.\n\t */\n\tendbyte = (u64)offset + (u64)len;\n\tif (!len || endbyte < len)\n\t\tendbyte = -1;\n\telse\n\t\tendbyte--;\t\t/* inclusive */\n\n\tswitch (advice) {\n\tcase POSIX_FADV_NORMAL:\n\t\tfile->f_ra.ra_pages = bdi->ra_pages;\n\t\tspin_lock(&file->f_lock);\n\t\tfile->f_mode &= ~FMODE_RANDOM;\n\t\tspin_unlock(&file->f_lock);\n\t\tbreak;\n\tcase POSIX_FADV_RANDOM:\n\t\tspin_lock(&file->f_lock);\n\t\tfile->f_mode |= FMODE_RANDOM;\n\t\tspin_unlock(&file->f_lock);\n\t\tbreak;\n\tcase POSIX_FADV_SEQUENTIAL:\n\t\tfile->f_ra.ra_pages = bdi->ra_pages * 2;\n\t\tspin_lock(&file->f_lock);\n\t\tfile->f_mode &= ~FMODE_RANDOM;\n\t\tspin_unlock(&file->f_lock);\n\t\tbreak;\n\tcase POSIX_FADV_WILLNEED:\n\t\t/* First and last PARTIAL page! */\n\t\tstart_index = offset >> PAGE_SHIFT;\n\t\tend_index = endbyte >> PAGE_SHIFT;\n\n\t\t/* Careful about overflow on the \"+1\" */\n\t\tnrpages = end_index - start_index + 1;\n\t\tif (!nrpages)\n\t\t\tnrpages = ~0UL;\n\n\t\t/*\n\t\t * Ignore return value because fadvise() shall return\n\t\t * success even if filesystem can't retrieve a hint,\n\t\t */\n\t\tforce_page_cache_readahead(mapping, file, start_index, nrpages);\n\t\tbreak;\n\tcase POSIX_FADV_NOREUSE:\n\t\tbreak;\n\tcase POSIX_FADV_DONTNEED:\n\t\tif (!inode_write_congested(mapping->host))\n\t\t\t__filemap_fdatawrite_range(mapping, offset, endbyte,\n\t\t\t\t\t\t   WB_SYNC_NONE);\n\n\t\t/*\n\t\t * First and last FULL page! Partial pages are deliberately\n\t\t * preserved on the expectation that it is better to preserve\n\t\t * needed memory than to discard unneeded memory.\n\t\t */\n\t\tstart_index = (offset+(PAGE_SIZE-1)) >> PAGE_SHIFT;\n\t\tend_index = (endbyte >> PAGE_SHIFT);\n\t\t/*\n\t\t * The page at end_index will be inclusively discarded according\n\t\t * by invalidate_mapping_pages(), so subtracting 1 from\n\t\t * end_index means we will skip the last page.  But if endbyte\n\t\t * is page aligned or is at the end of file, we should not skip\n\t\t * that page - discarding the last page is safe enough.\n\t\t */\n\t\tif ((endbyte & ~PAGE_MASK) != ~PAGE_MASK &&\n\t\t\t\tendbyte != inode->i_size - 1) {\n\t\t\t/* First page is tricky as 0 - 1 = -1, but pgoff_t\n\t\t\t * is unsigned, so the end_index >= start_index\n\t\t\t * check below would be true and we'll discard the whole\n\t\t\t * file cache which is not what was asked.\n\t\t\t */\n\t\t\tif (end_index == 0)\n\t\t\t\tbreak;\n\n\t\t\tend_index--;\n\t\t}\n\n\t\tif (end_index >= start_index) {\n\t\t\tunsigned long count;\n\n\t\t\t/*\n\t\t\t * It's common to FADV_DONTNEED right after\n\t\t\t * the read or write that instantiates the\n\t\t\t * pages, in which case there will be some\n\t\t\t * sitting on the local LRU cache. Try to\n\t\t\t * avoid the expensive remote drain and the\n\t\t\t * second cache tree walk below by flushing\n\t\t\t * them out right away.\n\t\t\t */\n\t\t\tlru_add_drain();\n\n\t\t\tcount = invalidate_mapping_pages(mapping,\n\t\t\t\t\t\tstart_index, end_index);\n\n\t\t\t/*\n\t\t\t * If fewer pages were invalidated than expected then\n\t\t\t * it is possible that some of the pages were on\n\t\t\t * a per-cpu pagevec for a remote CPU. Drain all\n\t\t\t * pagevecs and try again.\n\t\t\t */\n\t\t\tif (count < (end_index - start_index + 1)) {\n\t\t\t\tlru_add_drain_all();\n\t\t\t\tinvalidate_mapping_pages(mapping, start_index,\n\t\t\t\t\t\tend_index);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file->f_op->fadvise",
          "args": [
            "file",
            "offset",
            "len",
            "advice"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/fadvise.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint vfs_fadvise(struct file *file, loff_t offset, loff_t len, int advice)\n{\n\tif (file->f_op->fadvise)\n\t\treturn file->f_op->fadvise(file, offset, len, advice);\n\n\treturn generic_fadvise(file, offset, len, advice);\n}"
  },
  {
    "function_name": "generic_fadvise",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/fadvise.c",
    "lines": "30-180",
    "snippet": "static int generic_fadvise(struct file *file, loff_t offset, loff_t len,\n\t\t\t   int advice)\n{\n\tstruct inode *inode;\n\tstruct address_space *mapping;\n\tstruct backing_dev_info *bdi;\n\tloff_t endbyte;\t\t\t/* inclusive */\n\tpgoff_t start_index;\n\tpgoff_t end_index;\n\tunsigned long nrpages;\n\n\tinode = file_inode(file);\n\tif (S_ISFIFO(inode->i_mode))\n\t\treturn -ESPIPE;\n\n\tmapping = file->f_mapping;\n\tif (!mapping || len < 0)\n\t\treturn -EINVAL;\n\n\tbdi = inode_to_bdi(mapping->host);\n\n\tif (IS_DAX(inode) || (bdi == &noop_backing_dev_info)) {\n\t\tswitch (advice) {\n\t\tcase POSIX_FADV_NORMAL:\n\t\tcase POSIX_FADV_RANDOM:\n\t\tcase POSIX_FADV_SEQUENTIAL:\n\t\tcase POSIX_FADV_WILLNEED:\n\t\tcase POSIX_FADV_NOREUSE:\n\t\tcase POSIX_FADV_DONTNEED:\n\t\t\t/* no bad return value, but ignore advice */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Careful about overflows. Len == 0 means \"as much as possible\".  Use\n\t * unsigned math because signed overflows are undefined and UBSan\n\t * complains.\n\t */\n\tendbyte = (u64)offset + (u64)len;\n\tif (!len || endbyte < len)\n\t\tendbyte = -1;\n\telse\n\t\tendbyte--;\t\t/* inclusive */\n\n\tswitch (advice) {\n\tcase POSIX_FADV_NORMAL:\n\t\tfile->f_ra.ra_pages = bdi->ra_pages;\n\t\tspin_lock(&file->f_lock);\n\t\tfile->f_mode &= ~FMODE_RANDOM;\n\t\tspin_unlock(&file->f_lock);\n\t\tbreak;\n\tcase POSIX_FADV_RANDOM:\n\t\tspin_lock(&file->f_lock);\n\t\tfile->f_mode |= FMODE_RANDOM;\n\t\tspin_unlock(&file->f_lock);\n\t\tbreak;\n\tcase POSIX_FADV_SEQUENTIAL:\n\t\tfile->f_ra.ra_pages = bdi->ra_pages * 2;\n\t\tspin_lock(&file->f_lock);\n\t\tfile->f_mode &= ~FMODE_RANDOM;\n\t\tspin_unlock(&file->f_lock);\n\t\tbreak;\n\tcase POSIX_FADV_WILLNEED:\n\t\t/* First and last PARTIAL page! */\n\t\tstart_index = offset >> PAGE_SHIFT;\n\t\tend_index = endbyte >> PAGE_SHIFT;\n\n\t\t/* Careful about overflow on the \"+1\" */\n\t\tnrpages = end_index - start_index + 1;\n\t\tif (!nrpages)\n\t\t\tnrpages = ~0UL;\n\n\t\t/*\n\t\t * Ignore return value because fadvise() shall return\n\t\t * success even if filesystem can't retrieve a hint,\n\t\t */\n\t\tforce_page_cache_readahead(mapping, file, start_index, nrpages);\n\t\tbreak;\n\tcase POSIX_FADV_NOREUSE:\n\t\tbreak;\n\tcase POSIX_FADV_DONTNEED:\n\t\tif (!inode_write_congested(mapping->host))\n\t\t\t__filemap_fdatawrite_range(mapping, offset, endbyte,\n\t\t\t\t\t\t   WB_SYNC_NONE);\n\n\t\t/*\n\t\t * First and last FULL page! Partial pages are deliberately\n\t\t * preserved on the expectation that it is better to preserve\n\t\t * needed memory than to discard unneeded memory.\n\t\t */\n\t\tstart_index = (offset+(PAGE_SIZE-1)) >> PAGE_SHIFT;\n\t\tend_index = (endbyte >> PAGE_SHIFT);\n\t\t/*\n\t\t * The page at end_index will be inclusively discarded according\n\t\t * by invalidate_mapping_pages(), so subtracting 1 from\n\t\t * end_index means we will skip the last page.  But if endbyte\n\t\t * is page aligned or is at the end of file, we should not skip\n\t\t * that page - discarding the last page is safe enough.\n\t\t */\n\t\tif ((endbyte & ~PAGE_MASK) != ~PAGE_MASK &&\n\t\t\t\tendbyte != inode->i_size - 1) {\n\t\t\t/* First page is tricky as 0 - 1 = -1, but pgoff_t\n\t\t\t * is unsigned, so the end_index >= start_index\n\t\t\t * check below would be true and we'll discard the whole\n\t\t\t * file cache which is not what was asked.\n\t\t\t */\n\t\t\tif (end_index == 0)\n\t\t\t\tbreak;\n\n\t\t\tend_index--;\n\t\t}\n\n\t\tif (end_index >= start_index) {\n\t\t\tunsigned long count;\n\n\t\t\t/*\n\t\t\t * It's common to FADV_DONTNEED right after\n\t\t\t * the read or write that instantiates the\n\t\t\t * pages, in which case there will be some\n\t\t\t * sitting on the local LRU cache. Try to\n\t\t\t * avoid the expensive remote drain and the\n\t\t\t * second cache tree walk below by flushing\n\t\t\t * them out right away.\n\t\t\t */\n\t\t\tlru_add_drain();\n\n\t\t\tcount = invalidate_mapping_pages(mapping,\n\t\t\t\t\t\tstart_index, end_index);\n\n\t\t\t/*\n\t\t\t * If fewer pages were invalidated than expected then\n\t\t\t * it is possible that some of the pages were on\n\t\t\t * a per-cpu pagevec for a remote CPU. Drain all\n\t\t\t * pagevecs and try again.\n\t\t\t */\n\t\t\tif (count < (end_index - start_index + 1)) {\n\t\t\t\tlru_add_drain_all();\n\t\t\t\tinvalidate_mapping_pages(mapping, start_index,\n\t\t\t\t\t\tend_index);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fadvise.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "invalidate_mapping_pages",
          "args": [
            "mapping",
            "start_index",
            "end_index"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_mapping_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "543-610",
          "snippet": "unsigned long invalidate_mapping_pages(struct address_space *mapping,\n\t\tpgoff_t start, pgoff_t end)\n{\n\tpgoff_t indices[PAGEVEC_SIZE];\n\tstruct pagevec pvec;\n\tpgoff_t index = start;\n\tunsigned long ret;\n\tunsigned long count = 0;\n\tint i;\n\n\tpagevec_init(&pvec);\n\twhile (index <= end && pagevec_lookup_entries(&pvec, mapping, index,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE - 1) + 1,\n\t\t\tindices)) {\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* We rely upon deletion not changing page->index */\n\t\t\tindex = indices[i];\n\t\t\tif (index > end)\n\t\t\t\tbreak;\n\n\t\t\tif (xa_is_value(page)) {\n\t\t\t\tinvalidate_exceptional_entry(mapping, index,\n\t\t\t\t\t\t\t     page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!trylock_page(page))\n\t\t\t\tcontinue;\n\n\t\t\tWARN_ON(page_to_index(page) != index);\n\n\t\t\t/* Middle of THP: skip */\n\t\t\tif (PageTransTail(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t} else if (PageTransHuge(page)) {\n\t\t\t\tindex += HPAGE_PMD_NR - 1;\n\t\t\t\ti += HPAGE_PMD_NR - 1;\n\t\t\t\t/*\n\t\t\t\t * 'end' is in the middle of THP. Don't\n\t\t\t\t * invalidate the page as the part outside of\n\t\t\t\t * 'end' could be still useful.\n\t\t\t\t */\n\t\t\t\tif (index > end) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = invalidate_inode_page(page);\n\t\t\tunlock_page(page);\n\t\t\t/*\n\t\t\t * Invalidation is a hint that the page is no longer\n\t\t\t * of interest and try to speed up its reclaim.\n\t\t\t */\n\t\t\tif (!ret)\n\t\t\t\tdeactivate_file_page(page);\n\t\t\tcount += ret;\n\t\t}\n\t\tpagevec_remove_exceptionals(&pvec);\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t\tindex++;\n\t}\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nunsigned long invalidate_mapping_pages(struct address_space *mapping,\n\t\tpgoff_t start, pgoff_t end)\n{\n\tpgoff_t indices[PAGEVEC_SIZE];\n\tstruct pagevec pvec;\n\tpgoff_t index = start;\n\tunsigned long ret;\n\tunsigned long count = 0;\n\tint i;\n\n\tpagevec_init(&pvec);\n\twhile (index <= end && pagevec_lookup_entries(&pvec, mapping, index,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE - 1) + 1,\n\t\t\tindices)) {\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* We rely upon deletion not changing page->index */\n\t\t\tindex = indices[i];\n\t\t\tif (index > end)\n\t\t\t\tbreak;\n\n\t\t\tif (xa_is_value(page)) {\n\t\t\t\tinvalidate_exceptional_entry(mapping, index,\n\t\t\t\t\t\t\t     page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!trylock_page(page))\n\t\t\t\tcontinue;\n\n\t\t\tWARN_ON(page_to_index(page) != index);\n\n\t\t\t/* Middle of THP: skip */\n\t\t\tif (PageTransTail(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t} else if (PageTransHuge(page)) {\n\t\t\t\tindex += HPAGE_PMD_NR - 1;\n\t\t\t\ti += HPAGE_PMD_NR - 1;\n\t\t\t\t/*\n\t\t\t\t * 'end' is in the middle of THP. Don't\n\t\t\t\t * invalidate the page as the part outside of\n\t\t\t\t * 'end' could be still useful.\n\t\t\t\t */\n\t\t\t\tif (index > end) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = invalidate_inode_page(page);\n\t\t\tunlock_page(page);\n\t\t\t/*\n\t\t\t * Invalidation is a hint that the page is no longer\n\t\t\t * of interest and try to speed up its reclaim.\n\t\t\t */\n\t\t\tif (!ret)\n\t\t\t\tdeactivate_file_page(page);\n\t\t\tcount += ret;\n\t\t}\n\t\tpagevec_remove_exceptionals(&pvec);\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t\tindex++;\n\t}\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_add_drain_all",
          "args": [],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__filemap_fdatawrite_range",
          "args": [
            "mapping",
            "offset",
            "endbyte",
            "WB_SYNC_NONE"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "__filemap_fdatawrite_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "396-414",
          "snippet": "int __filemap_fdatawrite_range(struct address_space *mapping, loff_t start,\n\t\t\t\tloff_t end, int sync_mode)\n{\n\tint ret;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = sync_mode,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.range_start = start,\n\t\t.range_end = end,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(mapping))\n\t\treturn 0;\n\n\twbc_attach_fdatawrite_inode(&wbc, mapping->host);\n\tret = do_writepages(mapping, &wbc);\n\twbc_detach_inode(&wbc);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint __filemap_fdatawrite_range(struct address_space *mapping, loff_t start,\n\t\t\t\tloff_t end, int sync_mode)\n{\n\tint ret;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = sync_mode,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.range_start = start,\n\t\t.range_end = end,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(mapping))\n\t\treturn 0;\n\n\twbc_attach_fdatawrite_inode(&wbc, mapping->host);\n\tret = do_writepages(mapping, &wbc);\n\twbc_detach_inode(&wbc);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_write_congested",
          "args": [
            "mapping->host"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "force_page_cache_readahead",
          "args": [
            "mapping",
            "file",
            "start_index",
            "nrpages"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "force_page_cache_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
          "lines": "219-246",
          "snippet": "int force_page_cache_readahead(struct address_space *mapping, struct file *filp,\n\t\t\t       pgoff_t offset, unsigned long nr_to_read)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(mapping->host);\n\tstruct file_ra_state *ra = &filp->f_ra;\n\tunsigned long max_pages;\n\n\tif (unlikely(!mapping->a_ops->readpage && !mapping->a_ops->readpages))\n\t\treturn -EINVAL;\n\n\t/*\n\t * If the request exceeds the readahead window, allow the read to\n\t * be up to the optimal hardware IO size\n\t */\n\tmax_pages = max_t(unsigned long, bdi->io_pages, ra->ra_pages);\n\tnr_to_read = min(nr_to_read, max_pages);\n\twhile (nr_to_read) {\n\t\tunsigned long this_chunk = (2 * 1024 * 1024) / PAGE_SIZE;\n\n\t\tif (this_chunk > nr_to_read)\n\t\t\tthis_chunk = nr_to_read;\n\t\t__do_page_cache_readahead(mapping, filp, offset, this_chunk, 0);\n\n\t\toffset += this_chunk;\n\t\tnr_to_read -= this_chunk;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fadvise.h>",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/export.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nint force_page_cache_readahead(struct address_space *mapping, struct file *filp,\n\t\t\t       pgoff_t offset, unsigned long nr_to_read)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(mapping->host);\n\tstruct file_ra_state *ra = &filp->f_ra;\n\tunsigned long max_pages;\n\n\tif (unlikely(!mapping->a_ops->readpage && !mapping->a_ops->readpages))\n\t\treturn -EINVAL;\n\n\t/*\n\t * If the request exceeds the readahead window, allow the read to\n\t * be up to the optimal hardware IO size\n\t */\n\tmax_pages = max_t(unsigned long, bdi->io_pages, ra->ra_pages);\n\tnr_to_read = min(nr_to_read, max_pages);\n\twhile (nr_to_read) {\n\t\tunsigned long this_chunk = (2 * 1024 * 1024) / PAGE_SIZE;\n\n\t\tif (this_chunk > nr_to_read)\n\t\t\tthis_chunk = nr_to_read;\n\t\t__do_page_cache_readahead(mapping, filp, offset, this_chunk, 0);\n\n\t\toffset += this_chunk;\n\t\tnr_to_read -= this_chunk;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&file->f_lock"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&file->f_lock"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&file->f_lock"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&file->f_lock"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&file->f_lock"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&file->f_lock"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DAX",
          "args": [
            "inode"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "mapping->host"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISFIFO",
          "args": [
            "inode->i_mode"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/fadvise.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nstatic int generic_fadvise(struct file *file, loff_t offset, loff_t len,\n\t\t\t   int advice)\n{\n\tstruct inode *inode;\n\tstruct address_space *mapping;\n\tstruct backing_dev_info *bdi;\n\tloff_t endbyte;\t\t\t/* inclusive */\n\tpgoff_t start_index;\n\tpgoff_t end_index;\n\tunsigned long nrpages;\n\n\tinode = file_inode(file);\n\tif (S_ISFIFO(inode->i_mode))\n\t\treturn -ESPIPE;\n\n\tmapping = file->f_mapping;\n\tif (!mapping || len < 0)\n\t\treturn -EINVAL;\n\n\tbdi = inode_to_bdi(mapping->host);\n\n\tif (IS_DAX(inode) || (bdi == &noop_backing_dev_info)) {\n\t\tswitch (advice) {\n\t\tcase POSIX_FADV_NORMAL:\n\t\tcase POSIX_FADV_RANDOM:\n\t\tcase POSIX_FADV_SEQUENTIAL:\n\t\tcase POSIX_FADV_WILLNEED:\n\t\tcase POSIX_FADV_NOREUSE:\n\t\tcase POSIX_FADV_DONTNEED:\n\t\t\t/* no bad return value, but ignore advice */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Careful about overflows. Len == 0 means \"as much as possible\".  Use\n\t * unsigned math because signed overflows are undefined and UBSan\n\t * complains.\n\t */\n\tendbyte = (u64)offset + (u64)len;\n\tif (!len || endbyte < len)\n\t\tendbyte = -1;\n\telse\n\t\tendbyte--;\t\t/* inclusive */\n\n\tswitch (advice) {\n\tcase POSIX_FADV_NORMAL:\n\t\tfile->f_ra.ra_pages = bdi->ra_pages;\n\t\tspin_lock(&file->f_lock);\n\t\tfile->f_mode &= ~FMODE_RANDOM;\n\t\tspin_unlock(&file->f_lock);\n\t\tbreak;\n\tcase POSIX_FADV_RANDOM:\n\t\tspin_lock(&file->f_lock);\n\t\tfile->f_mode |= FMODE_RANDOM;\n\t\tspin_unlock(&file->f_lock);\n\t\tbreak;\n\tcase POSIX_FADV_SEQUENTIAL:\n\t\tfile->f_ra.ra_pages = bdi->ra_pages * 2;\n\t\tspin_lock(&file->f_lock);\n\t\tfile->f_mode &= ~FMODE_RANDOM;\n\t\tspin_unlock(&file->f_lock);\n\t\tbreak;\n\tcase POSIX_FADV_WILLNEED:\n\t\t/* First and last PARTIAL page! */\n\t\tstart_index = offset >> PAGE_SHIFT;\n\t\tend_index = endbyte >> PAGE_SHIFT;\n\n\t\t/* Careful about overflow on the \"+1\" */\n\t\tnrpages = end_index - start_index + 1;\n\t\tif (!nrpages)\n\t\t\tnrpages = ~0UL;\n\n\t\t/*\n\t\t * Ignore return value because fadvise() shall return\n\t\t * success even if filesystem can't retrieve a hint,\n\t\t */\n\t\tforce_page_cache_readahead(mapping, file, start_index, nrpages);\n\t\tbreak;\n\tcase POSIX_FADV_NOREUSE:\n\t\tbreak;\n\tcase POSIX_FADV_DONTNEED:\n\t\tif (!inode_write_congested(mapping->host))\n\t\t\t__filemap_fdatawrite_range(mapping, offset, endbyte,\n\t\t\t\t\t\t   WB_SYNC_NONE);\n\n\t\t/*\n\t\t * First and last FULL page! Partial pages are deliberately\n\t\t * preserved on the expectation that it is better to preserve\n\t\t * needed memory than to discard unneeded memory.\n\t\t */\n\t\tstart_index = (offset+(PAGE_SIZE-1)) >> PAGE_SHIFT;\n\t\tend_index = (endbyte >> PAGE_SHIFT);\n\t\t/*\n\t\t * The page at end_index will be inclusively discarded according\n\t\t * by invalidate_mapping_pages(), so subtracting 1 from\n\t\t * end_index means we will skip the last page.  But if endbyte\n\t\t * is page aligned or is at the end of file, we should not skip\n\t\t * that page - discarding the last page is safe enough.\n\t\t */\n\t\tif ((endbyte & ~PAGE_MASK) != ~PAGE_MASK &&\n\t\t\t\tendbyte != inode->i_size - 1) {\n\t\t\t/* First page is tricky as 0 - 1 = -1, but pgoff_t\n\t\t\t * is unsigned, so the end_index >= start_index\n\t\t\t * check below would be true and we'll discard the whole\n\t\t\t * file cache which is not what was asked.\n\t\t\t */\n\t\t\tif (end_index == 0)\n\t\t\t\tbreak;\n\n\t\t\tend_index--;\n\t\t}\n\n\t\tif (end_index >= start_index) {\n\t\t\tunsigned long count;\n\n\t\t\t/*\n\t\t\t * It's common to FADV_DONTNEED right after\n\t\t\t * the read or write that instantiates the\n\t\t\t * pages, in which case there will be some\n\t\t\t * sitting on the local LRU cache. Try to\n\t\t\t * avoid the expensive remote drain and the\n\t\t\t * second cache tree walk below by flushing\n\t\t\t * them out right away.\n\t\t\t */\n\t\t\tlru_add_drain();\n\n\t\t\tcount = invalidate_mapping_pages(mapping,\n\t\t\t\t\t\tstart_index, end_index);\n\n\t\t\t/*\n\t\t\t * If fewer pages were invalidated than expected then\n\t\t\t * it is possible that some of the pages were on\n\t\t\t * a per-cpu pagevec for a remote CPU. Drain all\n\t\t\t * pagevecs and try again.\n\t\t\t */\n\t\t\tif (count < (end_index - start_index + 1)) {\n\t\t\t\tlru_add_drain_all();\n\t\t\t\tinvalidate_mapping_pages(mapping, start_index,\n\t\t\t\t\t\tend_index);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "fadvise64_64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/fadvise.c",
    "lines": "207-210",
    "snippet": "SYSCALL_DEFINE4(fadvise64_64, int, fd, loff_t, offset, loff_t, len, int, advice)\n{\n\treturn ksys_fadvise64_64(fd, offset, len, advice);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fadvise.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/fadvise.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE4(fadvise64_64, int, fd, loff_t, offset, loff_t, len, int, advice)\n{\n\treturn ksys_fadvise64_64(fd, offset, len, advice);\n}"
  },
  {
    "function_name": "fadvise64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/fadvise.c",
    "lines": "214-217",
    "snippet": "SYSCALL_DEFINE4(fadvise64, int, fd, loff_t, offset, size_t, len, int, advice)\n{\n\treturn ksys_fadvise64_64(fd, offset, len, advice);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fadvise.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/fadvise.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE4(fadvise64, int, fd, loff_t, offset, size_t, len, int, advice)\n{\n\treturn ksys_fadvise64_64(fd, offset, len, advice);\n}"
  }
]