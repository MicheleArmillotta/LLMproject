[
  {
    "function_name": "page_init_poison",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/debug.c",
    "lines": "218-222",
    "snippet": "void page_init_poison(struct page *page, size_t size)\n{\n\tif (page_init_poisoning)\n\t\tmemset(page, PAGE_POISON_PATTERN, size);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/migrate.h>",
      "#include <trace/events/mmflags.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "page",
            "PAGE_POISON_PATTERN",
            "size"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/ctype.h>\n#include <linux/page_owner.h>\n#include <linux/migrate.h>\n#include <trace/events/mmflags.h>\n#include <linux/memcontrol.h>\n#include <linux/trace_events.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid page_init_poison(struct page *page, size_t size)\n{\n\tif (page_init_poisoning)\n\t\tmemset(page, PAGE_POISON_PATTERN, size);\n}"
  },
  {
    "function_name": "setup_vm_debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/debug.c",
    "lines": "181-215",
    "snippet": "static int __init setup_vm_debug(char *str)\n{\n\tbool __page_init_poisoning = true;\n\n\t/*\n\t * Calling vm_debug with no arguments is equivalent to requesting\n\t * to enable all debugging options we can control.\n\t */\n\tif (*str++ != '=' || !*str)\n\t\tgoto out;\n\n\t__page_init_poisoning = false;\n\tif (*str == '-')\n\t\tgoto out;\n\n\twhile (*str) {\n\t\tswitch (tolower(*str)) {\n\t\tcase'p':\n\t\t\t__page_init_poisoning = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"vm_debug option '%c' unknown. skipped\\n\",\n\t\t\t       *str);\n\t\t}\n\n\t\tstr++;\n\t}\nout:\n\tif (page_init_poisoning && !__page_init_poisoning)\n\t\tpr_warn(\"Page struct poisoning disabled by kernel command line option 'vm_debug'\\n\");\n\n\tpage_init_poisoning = __page_init_poisoning;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/migrate.h>",
      "#include <trace/events/mmflags.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Page struct poisoning disabled by kernel command line option 'vm_debug'\\n\""
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"vm_debug option '%c' unknown. skipped\\n\"",
            "*str"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "*str"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/ctype.h>\n#include <linux/page_owner.h>\n#include <linux/migrate.h>\n#include <trace/events/mmflags.h>\n#include <linux/memcontrol.h>\n#include <linux/trace_events.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int __init setup_vm_debug(char *str)\n{\n\tbool __page_init_poisoning = true;\n\n\t/*\n\t * Calling vm_debug with no arguments is equivalent to requesting\n\t * to enable all debugging options we can control.\n\t */\n\tif (*str++ != '=' || !*str)\n\t\tgoto out;\n\n\t__page_init_poisoning = false;\n\tif (*str == '-')\n\t\tgoto out;\n\n\twhile (*str) {\n\t\tswitch (tolower(*str)) {\n\t\tcase'p':\n\t\t\t__page_init_poisoning = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"vm_debug option '%c' unknown. skipped\\n\",\n\t\t\t       *str);\n\t\t}\n\n\t\tstr++;\n\t}\nout:\n\tif (page_init_poisoning && !__page_init_poisoning)\n\t\tpr_warn(\"Page struct poisoning disabled by kernel command line option 'vm_debug'\\n\");\n\n\tpage_init_poisoning = __page_init_poisoning;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "dump_mm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/debug.c",
    "lines": "116-177",
    "snippet": "void dump_mm(const struct mm_struct *mm)\n{\n\tpr_emerg(\"mm %px mmap %px seqnum %llu task_size %lu\\n\"\n#ifdef CONFIG_MMU\n\t\t\"get_unmapped_area %px\\n\"\n#endif\n\t\t\"mmap_base %lu mmap_legacy_base %lu highest_vm_end %lu\\n\"\n\t\t\"pgd %px mm_users %d mm_count %d pgtables_bytes %lu map_count %d\\n\"\n\t\t\"hiwater_rss %lx hiwater_vm %lx total_vm %lx locked_vm %lx\\n\"\n\t\t\"pinned_vm %lx data_vm %lx exec_vm %lx stack_vm %lx\\n\"\n\t\t\"start_code %lx end_code %lx start_data %lx end_data %lx\\n\"\n\t\t\"start_brk %lx brk %lx start_stack %lx\\n\"\n\t\t\"arg_start %lx arg_end %lx env_start %lx env_end %lx\\n\"\n\t\t\"binfmt %px flags %lx core_state %px\\n\"\n#ifdef CONFIG_AIO\n\t\t\"ioctx_table %px\\n\"\n#endif\n#ifdef CONFIG_MEMCG\n\t\t\"owner %px \"\n#endif\n\t\t\"exe_file %px\\n\"\n#ifdef CONFIG_MMU_NOTIFIER\n\t\t\"mmu_notifier_mm %px\\n\"\n#endif\n#ifdef CONFIG_NUMA_BALANCING\n\t\t\"numa_next_scan %lu numa_scan_offset %lu numa_scan_seq %d\\n\"\n#endif\n\t\t\"tlb_flush_pending %d\\n\"\n\t\t\"def_flags: %#lx(%pGv)\\n\",\n\n\t\tmm, mm->mmap, (long long) mm->vmacache_seqnum, mm->task_size,\n#ifdef CONFIG_MMU\n\t\tmm->get_unmapped_area,\n#endif\n\t\tmm->mmap_base, mm->mmap_legacy_base, mm->highest_vm_end,\n\t\tmm->pgd, atomic_read(&mm->mm_users),\n\t\tatomic_read(&mm->mm_count),\n\t\tmm_pgtables_bytes(mm),\n\t\tmm->map_count,\n\t\tmm->hiwater_rss, mm->hiwater_vm, mm->total_vm, mm->locked_vm,\n\t\tmm->pinned_vm, mm->data_vm, mm->exec_vm, mm->stack_vm,\n\t\tmm->start_code, mm->end_code, mm->start_data, mm->end_data,\n\t\tmm->start_brk, mm->brk, mm->start_stack,\n\t\tmm->arg_start, mm->arg_end, mm->env_start, mm->env_end,\n\t\tmm->binfmt, mm->flags, mm->core_state,\n#ifdef CONFIG_AIO\n\t\tmm->ioctx_table,\n#endif\n#ifdef CONFIG_MEMCG\n\t\tmm->owner,\n#endif\n\t\tmm->exe_file,\n#ifdef CONFIG_MMU_NOTIFIER\n\t\tmm->mmu_notifier_mm,\n#endif\n#ifdef CONFIG_NUMA_BALANCING\n\t\tmm->numa_next_scan, mm->numa_scan_offset, mm->numa_scan_seq,\n#endif\n\t\tatomic_read(&mm->tlb_flush_pending),\n\t\tmm->def_flags, &mm->def_flags\n\t);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/migrate.h>",
      "#include <trace/events/mmflags.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"mm %px mmap %px seqnum %llu task_size %lu\\n\"\n#ifdef CONFIG_MMU\n\t\t\"get_unmapped_area %px\\n\"\n#endif\n\t\t\"mmap_base %lu mmap_legacy_base %lu highest_vm_end %lu\\n\"\n\t\t\"pgd %px mm_users %d mm_count %d pgtables_bytes %lu map_count %d\\n\"\n\t\t\"hiwater_rss %lx hiwater_vm %lx total_vm %lx locked_vm %lx\\n\"\n\t\t\"pinned_vm %lx data_vm %lx exec_vm %lx stack_vm %lx\\n\"\n\t\t\"start_code %lx end_code %lx start_data %lx end_data %lx\\n\"\n\t\t\"start_brk %lx brk %lx start_stack %lx\\n\"\n\t\t\"arg_start %lx arg_end %lx env_start %lx env_end %lx\\n\"\n\t\t\"binfmt %px flags %lx core_state %px\\n\"\n#ifdef CONFIG_AIO\n\t\t\"ioctx_table %px\\n\"\n#endif\n#ifdef CONFIG_MEMCG\n\t\t\"owner %px \"\n#endif\n\t\t\"exe_file %px\\n\"\n#ifdef CONFIG_MMU_NOTIFIER\n\t\t\"mmu_notifier_mm %px\\n\"\n#endif\n#ifdef CONFIG_NUMA_BALANCING\n\t\t\"numa_next_scan %lu numa_scan_offset %lu numa_scan_seq %d\\n\"\n#endif\"tlb_flush_pending %d\\n\"\n\t\t\"def_flags: %#lx(%pGv)\\n\"",
            "mm",
            "mm->mmap",
            "(long long) mm->vmacache_seqnum",
            "mm->task_size",
            "#ifdef CONFIG_MMUmm->get_unmapped_area",
            "#endifmm->mmap_base",
            "mm->mmap_legacy_base",
            "mm->highest_vm_end",
            "mm->pgd",
            "atomic_read(&mm->mm_users)",
            "atomic_read(&mm->mm_count)",
            "mm_pgtables_bytes(mm)",
            "mm->map_count",
            "mm->hiwater_rss",
            "mm->hiwater_vm",
            "mm->total_vm",
            "mm->locked_vm",
            "mm->pinned_vm",
            "mm->data_vm",
            "mm->exec_vm",
            "mm->stack_vm",
            "mm->start_code",
            "mm->end_code",
            "mm->start_data",
            "mm->end_data",
            "mm->start_brk",
            "mm->brk",
            "mm->start_stack",
            "mm->arg_start",
            "mm->arg_end",
            "mm->env_start",
            "mm->env_end",
            "mm->binfmt",
            "mm->flags",
            "mm->core_state",
            "#ifdef CONFIG_AIOmm->ioctx_table",
            "#endif\n#ifdef CONFIG_MEMCGmm->owner",
            "#endifmm->exe_file",
            "#ifdef CONFIG_MMU_NOTIFIERmm->mmu_notifier_mm",
            "#endif\n#ifdef CONFIG_NUMA_BALANCINGmm->numa_next_scan",
            "mm->numa_scan_offset",
            "mm->numa_scan_seq",
            "#endifatomic_read(&mm->tlb_flush_pending)",
            "mm->def_flags",
            "&mm->def_flags"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&mm->tlb_flush_pending"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_pgtables_bytes",
          "args": [
            "mm"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&mm->mm_count"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&mm->mm_users"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/ctype.h>\n#include <linux/page_owner.h>\n#include <linux/migrate.h>\n#include <trace/events/mmflags.h>\n#include <linux/memcontrol.h>\n#include <linux/trace_events.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid dump_mm(const struct mm_struct *mm)\n{\n\tpr_emerg(\"mm %px mmap %px seqnum %llu task_size %lu\\n\"\n#ifdef CONFIG_MMU\n\t\t\"get_unmapped_area %px\\n\"\n#endif\n\t\t\"mmap_base %lu mmap_legacy_base %lu highest_vm_end %lu\\n\"\n\t\t\"pgd %px mm_users %d mm_count %d pgtables_bytes %lu map_count %d\\n\"\n\t\t\"hiwater_rss %lx hiwater_vm %lx total_vm %lx locked_vm %lx\\n\"\n\t\t\"pinned_vm %lx data_vm %lx exec_vm %lx stack_vm %lx\\n\"\n\t\t\"start_code %lx end_code %lx start_data %lx end_data %lx\\n\"\n\t\t\"start_brk %lx brk %lx start_stack %lx\\n\"\n\t\t\"arg_start %lx arg_end %lx env_start %lx env_end %lx\\n\"\n\t\t\"binfmt %px flags %lx core_state %px\\n\"\n#ifdef CONFIG_AIO\n\t\t\"ioctx_table %px\\n\"\n#endif\n#ifdef CONFIG_MEMCG\n\t\t\"owner %px \"\n#endif\n\t\t\"exe_file %px\\n\"\n#ifdef CONFIG_MMU_NOTIFIER\n\t\t\"mmu_notifier_mm %px\\n\"\n#endif\n#ifdef CONFIG_NUMA_BALANCING\n\t\t\"numa_next_scan %lu numa_scan_offset %lu numa_scan_seq %d\\n\"\n#endif\n\t\t\"tlb_flush_pending %d\\n\"\n\t\t\"def_flags: %#lx(%pGv)\\n\",\n\n\t\tmm, mm->mmap, (long long) mm->vmacache_seqnum, mm->task_size,\n#ifdef CONFIG_MMU\n\t\tmm->get_unmapped_area,\n#endif\n\t\tmm->mmap_base, mm->mmap_legacy_base, mm->highest_vm_end,\n\t\tmm->pgd, atomic_read(&mm->mm_users),\n\t\tatomic_read(&mm->mm_count),\n\t\tmm_pgtables_bytes(mm),\n\t\tmm->map_count,\n\t\tmm->hiwater_rss, mm->hiwater_vm, mm->total_vm, mm->locked_vm,\n\t\tmm->pinned_vm, mm->data_vm, mm->exec_vm, mm->stack_vm,\n\t\tmm->start_code, mm->end_code, mm->start_data, mm->end_data,\n\t\tmm->start_brk, mm->brk, mm->start_stack,\n\t\tmm->arg_start, mm->arg_end, mm->env_start, mm->env_end,\n\t\tmm->binfmt, mm->flags, mm->core_state,\n#ifdef CONFIG_AIO\n\t\tmm->ioctx_table,\n#endif\n#ifdef CONFIG_MEMCG\n\t\tmm->owner,\n#endif\n\t\tmm->exe_file,\n#ifdef CONFIG_MMU_NOTIFIER\n\t\tmm->mmu_notifier_mm,\n#endif\n#ifdef CONFIG_NUMA_BALANCING\n\t\tmm->numa_next_scan, mm->numa_scan_offset, mm->numa_scan_seq,\n#endif\n\t\tatomic_read(&mm->tlb_flush_pending),\n\t\tmm->def_flags, &mm->def_flags\n\t);\n}"
  },
  {
    "function_name": "dump_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/debug.c",
    "lines": "100-113",
    "snippet": "void dump_vma(const struct vm_area_struct *vma)\n{\n\tpr_emerg(\"vma %px start %px end %px\\n\"\n\t\t\"next %px prev %px mm %px\\n\"\n\t\t\"prot %lx anon_vma %px vm_ops %px\\n\"\n\t\t\"pgoff %lx file %px private_data %px\\n\"\n\t\t\"flags: %#lx(%pGv)\\n\",\n\t\tvma, (void *)vma->vm_start, (void *)vma->vm_end, vma->vm_next,\n\t\tvma->vm_prev, vma->vm_mm,\n\t\t(unsigned long)pgprot_val(vma->vm_page_prot),\n\t\tvma->anon_vma, vma->vm_ops, vma->vm_pgoff,\n\t\tvma->vm_file, vma->vm_private_data,\n\t\tvma->vm_flags, &vma->vm_flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/migrate.h>",
      "#include <trace/events/mmflags.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"vma %px start %px end %px\\n\"\n\t\t\"next %px prev %px mm %px\\n\"\n\t\t\"prot %lx anon_vma %px vm_ops %px\\n\"\n\t\t\"pgoff %lx file %px private_data %px\\n\"\n\t\t\"flags: %#lx(%pGv)\\n\"",
            "vma",
            "(void *)vma->vm_start",
            "(void *)vma->vm_end",
            "vma->vm_next",
            "vma->vm_prev",
            "vma->vm_mm",
            "(unsigned long)pgprot_val(vma->vm_page_prot)",
            "vma->anon_vma",
            "vma->vm_ops",
            "vma->vm_pgoff",
            "vma->vm_file",
            "vma->vm_private_data",
            "vma->vm_flags",
            "&vma->vm_flags"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprot_val",
          "args": [
            "vma->vm_page_prot"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/ctype.h>\n#include <linux/page_owner.h>\n#include <linux/migrate.h>\n#include <trace/events/mmflags.h>\n#include <linux/memcontrol.h>\n#include <linux/trace_events.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid dump_vma(const struct vm_area_struct *vma)\n{\n\tpr_emerg(\"vma %px start %px end %px\\n\"\n\t\t\"next %px prev %px mm %px\\n\"\n\t\t\"prot %lx anon_vma %px vm_ops %px\\n\"\n\t\t\"pgoff %lx file %px private_data %px\\n\"\n\t\t\"flags: %#lx(%pGv)\\n\",\n\t\tvma, (void *)vma->vm_start, (void *)vma->vm_end, vma->vm_next,\n\t\tvma->vm_prev, vma->vm_mm,\n\t\t(unsigned long)pgprot_val(vma->vm_page_prot),\n\t\tvma->anon_vma, vma->vm_ops, vma->vm_pgoff,\n\t\tvma->vm_file, vma->vm_private_data,\n\t\tvma->vm_flags, &vma->vm_flags);\n}"
  },
  {
    "function_name": "dump_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/debug.c",
    "lines": "91-95",
    "snippet": "void dump_page(struct page *page, const char *reason)\n{\n\t__dump_page(page, reason);\n\tdump_page_owner(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/migrate.h>",
      "#include <trace/events/mmflags.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_page_owner",
          "args": [
            "page"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "__dump_page_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
          "lines": "408-451",
          "snippet": "void __dump_page_owner(struct page *page)\n{\n\tstruct page_ext *page_ext = lookup_page_ext(page);\n\tstruct page_owner *page_owner;\n\tunsigned long entries[PAGE_OWNER_STACK_DEPTH];\n\tstruct stack_trace trace = {\n\t\t.nr_entries = 0,\n\t\t.entries = entries,\n\t\t.max_entries = PAGE_OWNER_STACK_DEPTH,\n\t\t.skip = 0\n\t};\n\tdepot_stack_handle_t handle;\n\tgfp_t gfp_mask;\n\tint mt;\n\n\tif (unlikely(!page_ext)) {\n\t\tpr_alert(\"There is not page extension available.\\n\");\n\t\treturn;\n\t}\n\n\tpage_owner = get_page_owner(page_ext);\n\tgfp_mask = page_owner->gfp_mask;\n\tmt = gfpflags_to_migratetype(gfp_mask);\n\n\tif (!test_bit(PAGE_EXT_OWNER, &page_ext->flags)) {\n\t\tpr_alert(\"page_owner info is not active (free page?)\\n\");\n\t\treturn;\n\t}\n\n\thandle = READ_ONCE(page_owner->handle);\n\tif (!handle) {\n\t\tpr_alert(\"page_owner info is not active (free page?)\\n\");\n\t\treturn;\n\t}\n\n\tdepot_fetch_stack(handle, &trace);\n\tpr_alert(\"page allocated via order %u, migratetype %s, gfp_mask %#x(%pGg)\\n\",\n\t\t page_owner->order, migratetype_names[mt], gfp_mask, &gfp_mask);\n\tprint_stack_trace(&trace, 0);\n\n\tif (page_owner->last_migrate_reason != -1)\n\t\tpr_alert(\"page has been migrated, last migrate reason: %s\\n\",\n\t\t\tmigrate_reason_names[page_owner->last_migrate_reason]);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/migrate.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [
            "#define PAGE_OWNER_STACK_DEPTH (16)"
          ],
          "globals_used": [
            "static __always_inline depot_stack_handle_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\n#define PAGE_OWNER_STACK_DEPTH (16)\n\nstatic __always_inline depot_stack_handle_t;\n\nvoid __dump_page_owner(struct page *page)\n{\n\tstruct page_ext *page_ext = lookup_page_ext(page);\n\tstruct page_owner *page_owner;\n\tunsigned long entries[PAGE_OWNER_STACK_DEPTH];\n\tstruct stack_trace trace = {\n\t\t.nr_entries = 0,\n\t\t.entries = entries,\n\t\t.max_entries = PAGE_OWNER_STACK_DEPTH,\n\t\t.skip = 0\n\t};\n\tdepot_stack_handle_t handle;\n\tgfp_t gfp_mask;\n\tint mt;\n\n\tif (unlikely(!page_ext)) {\n\t\tpr_alert(\"There is not page extension available.\\n\");\n\t\treturn;\n\t}\n\n\tpage_owner = get_page_owner(page_ext);\n\tgfp_mask = page_owner->gfp_mask;\n\tmt = gfpflags_to_migratetype(gfp_mask);\n\n\tif (!test_bit(PAGE_EXT_OWNER, &page_ext->flags)) {\n\t\tpr_alert(\"page_owner info is not active (free page?)\\n\");\n\t\treturn;\n\t}\n\n\thandle = READ_ONCE(page_owner->handle);\n\tif (!handle) {\n\t\tpr_alert(\"page_owner info is not active (free page?)\\n\");\n\t\treturn;\n\t}\n\n\tdepot_fetch_stack(handle, &trace);\n\tpr_alert(\"page allocated via order %u, migratetype %s, gfp_mask %#x(%pGg)\\n\",\n\t\t page_owner->order, migratetype_names[mt], gfp_mask, &gfp_mask);\n\tprint_stack_trace(&trace, 0);\n\n\tif (page_owner->last_migrate_reason != -1)\n\t\tpr_alert(\"page has been migrated, last migrate reason: %s\\n\",\n\t\t\tmigrate_reason_names[page_owner->last_migrate_reason]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dump_page",
          "args": [
            "page",
            "reason"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "__dump_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/debug.c",
          "lines": "45-89",
          "snippet": "void __dump_page(struct page *page, const char *reason)\n{\n\tbool page_poisoned = PagePoisoned(page);\n\tint mapcount;\n\n\t/*\n\t * If struct page is poisoned don't access Page*() functions as that\n\t * leads to recursive loop. Page*() check for poisoned pages, and calls\n\t * dump_page() when detected.\n\t */\n\tif (page_poisoned) {\n\t\tpr_emerg(\"page:%px is uninitialized and poisoned\", page);\n\t\tgoto hex_only;\n\t}\n\n\t/*\n\t * Avoid VM_BUG_ON() in page_mapcount().\n\t * page->_mapcount space in struct page is used by sl[aou]b pages to\n\t * encode own info.\n\t */\n\tmapcount = PageSlab(page) ? 0 : page_mapcount(page);\n\n\tpr_emerg(\"page:%px count:%d mapcount:%d mapping:%px index:%#lx\",\n\t\t  page, page_ref_count(page), mapcount,\n\t\t  page->mapping, page_to_pgoff(page));\n\tif (PageCompound(page))\n\t\tpr_cont(\" compound_mapcount: %d\", compound_mapcount(page));\n\tpr_cont(\"\\n\");\n\tBUILD_BUG_ON(ARRAY_SIZE(pageflag_names) != __NR_PAGEFLAGS + 1);\n\n\tpr_emerg(\"flags: %#lx(%pGp)\\n\", page->flags, &page->flags);\n\nhex_only:\n\tprint_hex_dump(KERN_ALERT, \"raw: \", DUMP_PREFIX_NONE, 32,\n\t\t\tsizeof(unsigned long), page,\n\t\t\tsizeof(struct page), false);\n\n\tif (reason)\n\t\tpr_alert(\"page dumped because: %s\\n\", reason);\n\n#ifdef CONFIG_MEMCG\n\tif (!page_poisoned && page->mem_cgroup)\n\t\tpr_alert(\"page->mem_cgroup:%px\\n\", page->mem_cgroup);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/migrate.h>",
            "#include <trace/events/mmflags.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct trace_print_flags pageflag_names[] = {\n\t__def_pageflag_names,\n\t{0, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/ctype.h>\n#include <linux/page_owner.h>\n#include <linux/migrate.h>\n#include <trace/events/mmflags.h>\n#include <linux/memcontrol.h>\n#include <linux/trace_events.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nconst struct trace_print_flags pageflag_names[] = {\n\t__def_pageflag_names,\n\t{0, NULL}\n};\n\nvoid __dump_page(struct page *page, const char *reason)\n{\n\tbool page_poisoned = PagePoisoned(page);\n\tint mapcount;\n\n\t/*\n\t * If struct page is poisoned don't access Page*() functions as that\n\t * leads to recursive loop. Page*() check for poisoned pages, and calls\n\t * dump_page() when detected.\n\t */\n\tif (page_poisoned) {\n\t\tpr_emerg(\"page:%px is uninitialized and poisoned\", page);\n\t\tgoto hex_only;\n\t}\n\n\t/*\n\t * Avoid VM_BUG_ON() in page_mapcount().\n\t * page->_mapcount space in struct page is used by sl[aou]b pages to\n\t * encode own info.\n\t */\n\tmapcount = PageSlab(page) ? 0 : page_mapcount(page);\n\n\tpr_emerg(\"page:%px count:%d mapcount:%d mapping:%px index:%#lx\",\n\t\t  page, page_ref_count(page), mapcount,\n\t\t  page->mapping, page_to_pgoff(page));\n\tif (PageCompound(page))\n\t\tpr_cont(\" compound_mapcount: %d\", compound_mapcount(page));\n\tpr_cont(\"\\n\");\n\tBUILD_BUG_ON(ARRAY_SIZE(pageflag_names) != __NR_PAGEFLAGS + 1);\n\n\tpr_emerg(\"flags: %#lx(%pGp)\\n\", page->flags, &page->flags);\n\nhex_only:\n\tprint_hex_dump(KERN_ALERT, \"raw: \", DUMP_PREFIX_NONE, 32,\n\t\t\tsizeof(unsigned long), page,\n\t\t\tsizeof(struct page), false);\n\n\tif (reason)\n\t\tpr_alert(\"page dumped because: %s\\n\", reason);\n\n#ifdef CONFIG_MEMCG\n\tif (!page_poisoned && page->mem_cgroup)\n\t\tpr_alert(\"page->mem_cgroup:%px\\n\", page->mem_cgroup);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/ctype.h>\n#include <linux/page_owner.h>\n#include <linux/migrate.h>\n#include <trace/events/mmflags.h>\n#include <linux/memcontrol.h>\n#include <linux/trace_events.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid dump_page(struct page *page, const char *reason)\n{\n\t__dump_page(page, reason);\n\tdump_page_owner(page);\n}"
  },
  {
    "function_name": "__dump_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/debug.c",
    "lines": "45-89",
    "snippet": "void __dump_page(struct page *page, const char *reason)\n{\n\tbool page_poisoned = PagePoisoned(page);\n\tint mapcount;\n\n\t/*\n\t * If struct page is poisoned don't access Page*() functions as that\n\t * leads to recursive loop. Page*() check for poisoned pages, and calls\n\t * dump_page() when detected.\n\t */\n\tif (page_poisoned) {\n\t\tpr_emerg(\"page:%px is uninitialized and poisoned\", page);\n\t\tgoto hex_only;\n\t}\n\n\t/*\n\t * Avoid VM_BUG_ON() in page_mapcount().\n\t * page->_mapcount space in struct page is used by sl[aou]b pages to\n\t * encode own info.\n\t */\n\tmapcount = PageSlab(page) ? 0 : page_mapcount(page);\n\n\tpr_emerg(\"page:%px count:%d mapcount:%d mapping:%px index:%#lx\",\n\t\t  page, page_ref_count(page), mapcount,\n\t\t  page->mapping, page_to_pgoff(page));\n\tif (PageCompound(page))\n\t\tpr_cont(\" compound_mapcount: %d\", compound_mapcount(page));\n\tpr_cont(\"\\n\");\n\tBUILD_BUG_ON(ARRAY_SIZE(pageflag_names) != __NR_PAGEFLAGS + 1);\n\n\tpr_emerg(\"flags: %#lx(%pGp)\\n\", page->flags, &page->flags);\n\nhex_only:\n\tprint_hex_dump(KERN_ALERT, \"raw: \", DUMP_PREFIX_NONE, 32,\n\t\t\tsizeof(unsigned long), page,\n\t\t\tsizeof(struct page), false);\n\n\tif (reason)\n\t\tpr_alert(\"page dumped because: %s\\n\", reason);\n\n#ifdef CONFIG_MEMCG\n\tif (!page_poisoned && page->mem_cgroup)\n\t\tpr_alert(\"page->mem_cgroup:%px\\n\", page->mem_cgroup);\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/migrate.h>",
      "#include <trace/events/mmflags.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct trace_print_flags pageflag_names[] = {\n\t__def_pageflag_names,\n\t{0, NULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"page->mem_cgroup:%px\\n\"",
            "page->mem_cgroup"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"page dumped because: %s\\n\"",
            "reason"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_hex_dump",
          "args": [
            "KERN_ALERT",
            "\"raw: \"",
            "DUMP_PREFIX_NONE",
            "32",
            "sizeof(unsigned long)",
            "page",
            "sizeof(struct page)",
            "false"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"flags: %#lx(%pGp)\\n\"",
            "page->flags",
            "&page->flags"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "ARRAY_SIZE(pageflag_names) != __NR_PAGEFLAGS + 1"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "pageflag_names"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" compound_mapcount: %d\"",
            "compound_mapcount(page)"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_mapcount",
          "args": [
            "page"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"page:%px count:%d mapcount:%d mapping:%px index:%#lx\"",
            "page",
            "page_ref_count(page)",
            "mapcount",
            "page->mapping",
            "page_to_pgoff(page)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pgoff",
          "args": [
            "page"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_count",
          "args": [
            "page"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "page"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageSlab",
          "args": [
            "page"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"page:%px is uninitialized and poisoned\"",
            "page"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePoisoned",
          "args": [
            "page"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/ctype.h>\n#include <linux/page_owner.h>\n#include <linux/migrate.h>\n#include <trace/events/mmflags.h>\n#include <linux/memcontrol.h>\n#include <linux/trace_events.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nconst struct trace_print_flags pageflag_names[] = {\n\t__def_pageflag_names,\n\t{0, NULL}\n};\n\nvoid __dump_page(struct page *page, const char *reason)\n{\n\tbool page_poisoned = PagePoisoned(page);\n\tint mapcount;\n\n\t/*\n\t * If struct page is poisoned don't access Page*() functions as that\n\t * leads to recursive loop. Page*() check for poisoned pages, and calls\n\t * dump_page() when detected.\n\t */\n\tif (page_poisoned) {\n\t\tpr_emerg(\"page:%px is uninitialized and poisoned\", page);\n\t\tgoto hex_only;\n\t}\n\n\t/*\n\t * Avoid VM_BUG_ON() in page_mapcount().\n\t * page->_mapcount space in struct page is used by sl[aou]b pages to\n\t * encode own info.\n\t */\n\tmapcount = PageSlab(page) ? 0 : page_mapcount(page);\n\n\tpr_emerg(\"page:%px count:%d mapcount:%d mapping:%px index:%#lx\",\n\t\t  page, page_ref_count(page), mapcount,\n\t\t  page->mapping, page_to_pgoff(page));\n\tif (PageCompound(page))\n\t\tpr_cont(\" compound_mapcount: %d\", compound_mapcount(page));\n\tpr_cont(\"\\n\");\n\tBUILD_BUG_ON(ARRAY_SIZE(pageflag_names) != __NR_PAGEFLAGS + 1);\n\n\tpr_emerg(\"flags: %#lx(%pGp)\\n\", page->flags, &page->flags);\n\nhex_only:\n\tprint_hex_dump(KERN_ALERT, \"raw: \", DUMP_PREFIX_NONE, 32,\n\t\t\tsizeof(unsigned long), page,\n\t\t\tsizeof(struct page), false);\n\n\tif (reason)\n\t\tpr_alert(\"page dumped because: %s\\n\", reason);\n\n#ifdef CONFIG_MEMCG\n\tif (!page_poisoned && page->mem_cgroup)\n\t\tpr_alert(\"page->mem_cgroup:%px\\n\", page->mem_cgroup);\n#endif\n}"
  }
]