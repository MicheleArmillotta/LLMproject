[
  {
    "function_name": "wait_for_stable_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "2804-2808",
    "snippet": "void wait_for_stable_page(struct page *page)\n{\n\tif (bdi_cap_stable_pages_required(inode_to_bdi(page->mapping->host)))\n\t\twait_on_page_writeback(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 2807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_cap_stable_pages_required",
          "args": [
            "inode_to_bdi(page->mapping->host)"
          ],
          "line": 2806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "page->mapping->host"
          ],
          "line": 2806
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid wait_for_stable_page(struct page *page)\n{\n\tif (bdi_cap_stable_pages_required(inode_to_bdi(page->mapping->host)))\n\t\twait_on_page_writeback(page);\n}"
  },
  {
    "function_name": "__test_set_page_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "2745-2793",
    "snippet": "int __test_set_page_writeback(struct page *page, bool keep_write)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tint ret;\n\n\tlock_page_memcg(page);\n\tif (mapping && mapping_use_writeback_tags(mapping)) {\n\t\tXA_STATE(xas, &mapping->i_pages, page_index(page));\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\t\tunsigned long flags;\n\n\t\txas_lock_irqsave(&xas, flags);\n\t\txas_load(&xas);\n\t\tret = TestSetPageWriteback(page);\n\t\tif (!ret) {\n\t\t\tbool on_wblist;\n\n\t\t\ton_wblist = mapping_tagged(mapping,\n\t\t\t\t\t\t   PAGECACHE_TAG_WRITEBACK);\n\n\t\t\txas_set_mark(&xas, PAGECACHE_TAG_WRITEBACK);\n\t\t\tif (bdi_cap_account_writeback(bdi))\n\t\t\t\tinc_wb_stat(inode_to_wb(inode), WB_WRITEBACK);\n\n\t\t\t/*\n\t\t\t * We can come through here when swapping anonymous\n\t\t\t * pages, so we don't necessarily have an inode to track\n\t\t\t * for sync.\n\t\t\t */\n\t\t\tif (mapping->host && !on_wblist)\n\t\t\t\tsb_mark_inode_writeback(mapping->host);\n\t\t}\n\t\tif (!PageDirty(page))\n\t\t\txas_clear_mark(&xas, PAGECACHE_TAG_DIRTY);\n\t\tif (!keep_write)\n\t\t\txas_clear_mark(&xas, PAGECACHE_TAG_TOWRITE);\n\t\txas_unlock_irqrestore(&xas, flags);\n\t} else {\n\t\tret = TestSetPageWriteback(page);\n\t}\n\tif (!ret) {\n\t\tinc_lruvec_page_state(page, NR_WRITEBACK);\n\t\tinc_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t}\n\tunlock_page_memcg(page);\n\treturn ret;\n\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page_memcg",
          "args": [
            "page"
          ],
          "line": 2790
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_zone_page_state",
          "args": [
            "page",
            "NR_ZONE_WRITE_PENDING"
          ],
          "line": 2788
        },
        "resolved": true,
        "details": {
          "function_name": "inc_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "612-621",
          "snippet": "void inc_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\tstruct zone *zone;\n\n\tzone = page_zone(page);\n\tlocal_irq_save(flags);\n\t__inc_zone_state(zone, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid inc_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\tstruct zone *zone;\n\n\tzone = page_zone(page);\n\tlocal_irq_save(flags);\n\t__inc_zone_state(zone, item);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_lruvec_page_state",
          "args": [
            "page",
            "NR_WRITEBACK"
          ],
          "line": 2787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestSetPageWriteback",
          "args": [
            "page"
          ],
          "line": 2784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_unlock_irqrestore",
          "args": [
            "&xas",
            "flags"
          ],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_clear_mark",
          "args": [
            "&xas",
            "PAGECACHE_TAG_TOWRITE"
          ],
          "line": 2781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_clear_mark",
          "args": [
            "&xas",
            "PAGECACHE_TAG_DIRTY"
          ],
          "line": 2779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 2778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_mark_inode_writeback",
          "args": [
            "mapping->host"
          ],
          "line": 2776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_wb_stat",
          "args": [
            "inode_to_wb(inode)",
            "WB_WRITEBACK"
          ],
          "line": 2768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_wb",
          "args": [
            "inode"
          ],
          "line": 2768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_cap_account_writeback",
          "args": [
            "bdi"
          ],
          "line": 2767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_set_mark",
          "args": [
            "&xas",
            "PAGECACHE_TAG_WRITEBACK"
          ],
          "line": 2766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_tagged",
          "args": [
            "mapping",
            "PAGECACHE_TAG_WRITEBACK"
          ],
          "line": 2763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestSetPageWriteback",
          "args": [
            "page"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_load",
          "args": [
            "&xas"
          ],
          "line": 2758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_lock_irqsave",
          "args": [
            "&xas",
            "flags"
          ],
          "line": 2757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "inode"
          ],
          "line": 2754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "page_index(page)"
          ],
          "line": 2752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_index",
          "args": [
            "page"
          ],
          "line": 2752
        },
        "resolved": true,
        "details": {
          "function_name": "__basepage_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1358-1373",
          "snippet": "pgoff_t __basepage_index(struct page *page)\n{\n\tstruct page *page_head = compound_head(page);\n\tpgoff_t index = page_index(page_head);\n\tunsigned long compound_idx;\n\n\tif (!PageHuge(page_head))\n\t\treturn page_index(page);\n\n\tif (compound_order(page_head) >= MAX_ORDER)\n\t\tcompound_idx = page_to_pfn(page) - page_to_pfn(page_head);\n\telse\n\t\tcompound_idx = page - page_head;\n\n\treturn (index << compound_order(page_head)) + compound_idx;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\npgoff_t __basepage_index(struct page *page)\n{\n\tstruct page *page_head = compound_head(page);\n\tpgoff_t index = page_index(page_head);\n\tunsigned long compound_idx;\n\n\tif (!PageHuge(page_head))\n\t\treturn page_index(page);\n\n\tif (compound_order(page_head) >= MAX_ORDER)\n\t\tcompound_idx = page_to_pfn(page) - page_to_pfn(page_head);\n\telse\n\t\tcompound_idx = page - page_head;\n\n\treturn (index << compound_order(page_head)) + compound_idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_use_writeback_tags",
          "args": [
            "mapping"
          ],
          "line": 2751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 2747
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint __test_set_page_writeback(struct page *page, bool keep_write)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tint ret;\n\n\tlock_page_memcg(page);\n\tif (mapping && mapping_use_writeback_tags(mapping)) {\n\t\tXA_STATE(xas, &mapping->i_pages, page_index(page));\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\t\tunsigned long flags;\n\n\t\txas_lock_irqsave(&xas, flags);\n\t\txas_load(&xas);\n\t\tret = TestSetPageWriteback(page);\n\t\tif (!ret) {\n\t\t\tbool on_wblist;\n\n\t\t\ton_wblist = mapping_tagged(mapping,\n\t\t\t\t\t\t   PAGECACHE_TAG_WRITEBACK);\n\n\t\t\txas_set_mark(&xas, PAGECACHE_TAG_WRITEBACK);\n\t\t\tif (bdi_cap_account_writeback(bdi))\n\t\t\t\tinc_wb_stat(inode_to_wb(inode), WB_WRITEBACK);\n\n\t\t\t/*\n\t\t\t * We can come through here when swapping anonymous\n\t\t\t * pages, so we don't necessarily have an inode to track\n\t\t\t * for sync.\n\t\t\t */\n\t\t\tif (mapping->host && !on_wblist)\n\t\t\t\tsb_mark_inode_writeback(mapping->host);\n\t\t}\n\t\tif (!PageDirty(page))\n\t\t\txas_clear_mark(&xas, PAGECACHE_TAG_DIRTY);\n\t\tif (!keep_write)\n\t\t\txas_clear_mark(&xas, PAGECACHE_TAG_TOWRITE);\n\t\txas_unlock_irqrestore(&xas, flags);\n\t} else {\n\t\tret = TestSetPageWriteback(page);\n\t}\n\tif (!ret) {\n\t\tinc_lruvec_page_state(page, NR_WRITEBACK);\n\t\tinc_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t}\n\tunlock_page_memcg(page);\n\treturn ret;\n\n}"
  },
  {
    "function_name": "test_clear_page_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "2695-2743",
    "snippet": "int test_clear_page_writeback(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\tint ret;\n\n\tmemcg = lock_page_memcg(page);\n\tlruvec = mem_cgroup_page_lruvec(page, page_pgdat(page));\n\tif (mapping && mapping_use_writeback_tags(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\t\tunsigned long flags;\n\n\t\txa_lock_irqsave(&mapping->i_pages, flags);\n\t\tret = TestClearPageWriteback(page);\n\t\tif (ret) {\n\t\t\t__xa_clear_mark(&mapping->i_pages, page_index(page),\n\t\t\t\t\t\tPAGECACHE_TAG_WRITEBACK);\n\t\t\tif (bdi_cap_account_writeback(bdi)) {\n\t\t\t\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\t\t\t\tdec_wb_stat(wb, WB_WRITEBACK);\n\t\t\t\t__wb_writeout_inc(wb);\n\t\t\t}\n\t\t}\n\n\t\tif (mapping->host && !mapping_tagged(mapping,\n\t\t\t\t\t\t     PAGECACHE_TAG_WRITEBACK))\n\t\t\tsb_clear_inode_writeback(mapping->host);\n\n\t\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\t} else {\n\t\tret = TestClearPageWriteback(page);\n\t}\n\t/*\n\t * NOTE: Page might be free now! Writeback doesn't hold a page\n\t * reference on its own, it relies on truncation to wait for\n\t * the clearing of PG_writeback. The below can only access\n\t * page state that is static across allocation cycles.\n\t */\n\tif (ret) {\n\t\tdec_lruvec_state(lruvec, NR_WRITEBACK);\n\t\tdec_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t\tinc_node_page_state(page, NR_WRITTEN);\n\t}\n\t__unlock_page_memcg(memcg);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__unlock_page_memcg",
          "args": [
            "memcg"
          ],
          "line": 2741
        },
        "resolved": true,
        "details": {
          "function_name": "__unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1898-1910",
          "snippet": "void __unlock_page_memcg(struct mem_cgroup *memcg)\n{\n\tif (memcg && memcg->move_lock_task == current) {\n\t\tunsigned long flags = memcg->move_lock_flags;\n\n\t\tmemcg->move_lock_task = NULL;\n\t\tmemcg->move_lock_flags = 0;\n\n\t\tspin_unlock_irqrestore(&memcg->move_lock, flags);\n\t}\n\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid __unlock_page_memcg(struct mem_cgroup *memcg)\n{\n\tif (memcg && memcg->move_lock_task == current) {\n\t\tunsigned long flags = memcg->move_lock_flags;\n\n\t\tmemcg->move_lock_task = NULL;\n\t\tmemcg->move_lock_flags = 0;\n\n\t\tspin_unlock_irqrestore(&memcg->move_lock, flags);\n\t}\n\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_node_page_state",
          "args": [
            "page",
            "NR_WRITTEN"
          ],
          "line": 2739
        },
        "resolved": true,
        "details": {
          "function_name": "inc_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "655-664",
          "snippet": "void inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tunsigned long flags;\n\tstruct pglist_data *pgdat;\n\n\tpgdat = page_pgdat(page);\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tunsigned long flags;\n\tstruct pglist_data *pgdat;\n\n\tpgdat = page_pgdat(page);\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dec_zone_page_state",
          "args": [
            "page",
            "NR_ZONE_WRITE_PENDING"
          ],
          "line": 2738
        },
        "resolved": true,
        "details": {
          "function_name": "dec_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "624-631",
          "snippet": "void dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dec_lruvec_state",
          "args": [
            "lruvec",
            "NR_WRITEBACK"
          ],
          "line": 2737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestClearPageWriteback",
          "args": [
            "page"
          ],
          "line": 2728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_unlock_irqrestore",
          "args": [
            "&mapping->i_pages",
            "flags"
          ],
          "line": 2726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_clear_inode_writeback",
          "args": [
            "mapping->host"
          ],
          "line": 2724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_tagged",
          "args": [
            "mapping",
            "PAGECACHE_TAG_WRITEBACK"
          ],
          "line": 2722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wb_writeout_inc",
          "args": [
            "wb"
          ],
          "line": 2718
        },
        "resolved": true,
        "details": {
          "function_name": "__wb_writeout_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "599-611",
          "snippet": "static inline void __wb_writeout_inc(struct bdi_writeback *wb)\n{\n\tstruct wb_domain *cgdom;\n\n\tinc_wb_stat(wb, WB_WRITTEN);\n\twb_domain_writeout_inc(&global_wb_domain, &wb->completions,\n\t\t\t       wb->bdi->max_prop_frac);\n\n\tcgdom = mem_cgroup_wb_domain(wb);\n\tif (cgdom)\n\t\twb_domain_writeout_inc(cgdom, wb_memcg_completions(wb),\n\t\t\t\t       wb->bdi->max_prop_frac);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct wb_domain global_wb_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct wb_domain global_wb_domain;\n\nstatic inline void __wb_writeout_inc(struct bdi_writeback *wb)\n{\n\tstruct wb_domain *cgdom;\n\n\tinc_wb_stat(wb, WB_WRITTEN);\n\twb_domain_writeout_inc(&global_wb_domain, &wb->completions,\n\t\t\t       wb->bdi->max_prop_frac);\n\n\tcgdom = mem_cgroup_wb_domain(wb);\n\tif (cgdom)\n\t\twb_domain_writeout_inc(cgdom, wb_memcg_completions(wb),\n\t\t\t\t       wb->bdi->max_prop_frac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dec_wb_stat",
          "args": [
            "wb",
            "WB_WRITEBACK"
          ],
          "line": 2717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_wb",
          "args": [
            "inode"
          ],
          "line": 2715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_cap_account_writeback",
          "args": [
            "bdi"
          ],
          "line": 2714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__xa_clear_mark",
          "args": [
            "&mapping->i_pages",
            "page_index(page)",
            "PAGECACHE_TAG_WRITEBACK"
          ],
          "line": 2712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_index",
          "args": [
            "page"
          ],
          "line": 2712
        },
        "resolved": true,
        "details": {
          "function_name": "__basepage_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1358-1373",
          "snippet": "pgoff_t __basepage_index(struct page *page)\n{\n\tstruct page *page_head = compound_head(page);\n\tpgoff_t index = page_index(page_head);\n\tunsigned long compound_idx;\n\n\tif (!PageHuge(page_head))\n\t\treturn page_index(page);\n\n\tif (compound_order(page_head) >= MAX_ORDER)\n\t\tcompound_idx = page_to_pfn(page) - page_to_pfn(page_head);\n\telse\n\t\tcompound_idx = page - page_head;\n\n\treturn (index << compound_order(page_head)) + compound_idx;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\npgoff_t __basepage_index(struct page *page)\n{\n\tstruct page *page_head = compound_head(page);\n\tpgoff_t index = page_index(page_head);\n\tunsigned long compound_idx;\n\n\tif (!PageHuge(page_head))\n\t\treturn page_index(page);\n\n\tif (compound_order(page_head) >= MAX_ORDER)\n\t\tcompound_idx = page_to_pfn(page) - page_to_pfn(page_head);\n\telse\n\t\tcompound_idx = page - page_head;\n\n\treturn (index << compound_order(page_head)) + compound_idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TestClearPageWriteback",
          "args": [
            "page"
          ],
          "line": 2710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_lock_irqsave",
          "args": [
            "&mapping->i_pages",
            "flags"
          ],
          "line": 2709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "inode"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_use_writeback_tags",
          "args": [
            "mapping"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_page_lruvec",
          "args": [
            "page",
            "page_pgdat(page)"
          ],
          "line": 2703
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_page_lruvec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1100-1130",
          "snippet": "struct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_pgdat",
          "args": [
            "page"
          ],
          "line": 2703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_page_memcg",
          "args": [
            "page"
          ],
          "line": 2702
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 2697
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint test_clear_page_writeback(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\tint ret;\n\n\tmemcg = lock_page_memcg(page);\n\tlruvec = mem_cgroup_page_lruvec(page, page_pgdat(page));\n\tif (mapping && mapping_use_writeback_tags(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\t\tunsigned long flags;\n\n\t\txa_lock_irqsave(&mapping->i_pages, flags);\n\t\tret = TestClearPageWriteback(page);\n\t\tif (ret) {\n\t\t\t__xa_clear_mark(&mapping->i_pages, page_index(page),\n\t\t\t\t\t\tPAGECACHE_TAG_WRITEBACK);\n\t\t\tif (bdi_cap_account_writeback(bdi)) {\n\t\t\t\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\t\t\t\tdec_wb_stat(wb, WB_WRITEBACK);\n\t\t\t\t__wb_writeout_inc(wb);\n\t\t\t}\n\t\t}\n\n\t\tif (mapping->host && !mapping_tagged(mapping,\n\t\t\t\t\t\t     PAGECACHE_TAG_WRITEBACK))\n\t\t\tsb_clear_inode_writeback(mapping->host);\n\n\t\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\t} else {\n\t\tret = TestClearPageWriteback(page);\n\t}\n\t/*\n\t * NOTE: Page might be free now! Writeback doesn't hold a page\n\t * reference on its own, it relies on truncation to wait for\n\t * the clearing of PG_writeback. The below can only access\n\t * page state that is static across allocation cycles.\n\t */\n\tif (ret) {\n\t\tdec_lruvec_state(lruvec, NR_WRITEBACK);\n\t\tdec_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t\tinc_node_page_state(page, NR_WRITTEN);\n\t}\n\t__unlock_page_memcg(memcg);\n\treturn ret;\n}"
  },
  {
    "function_name": "clear_page_dirty_for_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "2634-2692",
    "snippet": "int clear_page_dirty_for_io(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (mapping && mapping_cap_account_dirty(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct bdi_writeback *wb;\n\t\tstruct wb_lock_cookie cookie = {};\n\n\t\t/*\n\t\t * Yes, Virginia, this is indeed insane.\n\t\t *\n\t\t * We use this sequence to make sure that\n\t\t *  (a) we account for dirty stats properly\n\t\t *  (b) we tell the low-level filesystem to\n\t\t *      mark the whole page dirty if it was\n\t\t *      dirty in a pagetable. Only to then\n\t\t *  (c) clean the page again and return 1 to\n\t\t *      cause the writeback.\n\t\t *\n\t\t * This way we avoid all nasty races with the\n\t\t * dirty bit in multiple places and clearing\n\t\t * them concurrently from different threads.\n\t\t *\n\t\t * Note! Normally the \"set_page_dirty(page)\"\n\t\t * has no effect on the actual dirty bit - since\n\t\t * that will already usually be set. But we\n\t\t * need the side effects, and it can help us\n\t\t * avoid races.\n\t\t *\n\t\t * We basically use the page \"master dirty bit\"\n\t\t * as a serialization point for all the different\n\t\t * threads doing their things.\n\t\t */\n\t\tif (page_mkclean(page))\n\t\t\tset_page_dirty(page);\n\t\t/*\n\t\t * We carefully synchronise fault handlers against\n\t\t * installing a dirty pte and marking the page dirty\n\t\t * at this point.  We do this by having them hold the\n\t\t * page lock while dirtying the page, and pages are\n\t\t * always locked coming in here, so we get the desired\n\t\t * exclusion.\n\t\t */\n\t\twb = unlocked_inode_to_wb_begin(inode, &cookie);\n\t\tif (TestClearPageDirty(page)) {\n\t\t\tdec_lruvec_page_state(page, NR_FILE_DIRTY);\n\t\t\tdec_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t\t\tdec_wb_stat(wb, WB_RECLAIMABLE);\n\t\t\tret = 1;\n\t\t}\n\t\tunlocked_inode_to_wb_end(inode, &cookie);\n\t\treturn ret;\n\t}\n\treturn TestClearPageDirty(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TestClearPageDirty",
          "args": [
            "page"
          ],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlocked_inode_to_wb_end",
          "args": [
            "inode",
            "&cookie"
          ],
          "line": 2688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_wb_stat",
          "args": [
            "wb",
            "WB_RECLAIMABLE"
          ],
          "line": 2685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_zone_page_state",
          "args": [
            "page",
            "NR_ZONE_WRITE_PENDING"
          ],
          "line": 2684
        },
        "resolved": true,
        "details": {
          "function_name": "dec_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "624-631",
          "snippet": "void dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dec_lruvec_page_state",
          "args": [
            "page",
            "NR_FILE_DIRTY"
          ],
          "line": 2683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestClearPageDirty",
          "args": [
            "page"
          ],
          "line": 2682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlocked_inode_to_wb_begin",
          "args": [
            "inode",
            "&cookie"
          ],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 2672
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_dirty_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2573-2581",
          "snippet": "int set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mkclean",
          "args": [
            "page"
          ],
          "line": 2671
        },
        "resolved": true,
        "details": {
          "function_name": "page_mkclean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "965-987",
          "snippet": "int page_mkclean(struct page *page)\n{\n\tint cleaned = 0;\n\tstruct address_space *mapping;\n\tstruct rmap_walk_control rwc = {\n\t\t.arg = (void *)&cleaned,\n\t\t.rmap_one = page_mkclean_one,\n\t\t.invalid_vma = invalid_mkclean_vma,\n\t};\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_mapped(page))\n\t\treturn 0;\n\n\tmapping = page_mapping(page);\n\tif (!mapping)\n\t\treturn 0;\n\n\trmap_walk(page, &rwc);\n\n\treturn cleaned;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint page_mkclean(struct page *page)\n{\n\tint cleaned = 0;\n\tstruct address_space *mapping;\n\tstruct rmap_walk_control rwc = {\n\t\t.arg = (void *)&cleaned,\n\t\t.rmap_one = page_mkclean_one,\n\t\t.invalid_vma = invalid_mkclean_vma,\n\t};\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_mapped(page))\n\t\treturn 0;\n\n\tmapping = page_mapping(page);\n\tif (!mapping)\n\t\treturn 0;\n\n\trmap_walk(page, &rwc);\n\n\treturn cleaned;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_cap_account_dirty",
          "args": [
            "mapping"
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 2639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 2639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 2636
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint clear_page_dirty_for_io(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (mapping && mapping_cap_account_dirty(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct bdi_writeback *wb;\n\t\tstruct wb_lock_cookie cookie = {};\n\n\t\t/*\n\t\t * Yes, Virginia, this is indeed insane.\n\t\t *\n\t\t * We use this sequence to make sure that\n\t\t *  (a) we account for dirty stats properly\n\t\t *  (b) we tell the low-level filesystem to\n\t\t *      mark the whole page dirty if it was\n\t\t *      dirty in a pagetable. Only to then\n\t\t *  (c) clean the page again and return 1 to\n\t\t *      cause the writeback.\n\t\t *\n\t\t * This way we avoid all nasty races with the\n\t\t * dirty bit in multiple places and clearing\n\t\t * them concurrently from different threads.\n\t\t *\n\t\t * Note! Normally the \"set_page_dirty(page)\"\n\t\t * has no effect on the actual dirty bit - since\n\t\t * that will already usually be set. But we\n\t\t * need the side effects, and it can help us\n\t\t * avoid races.\n\t\t *\n\t\t * We basically use the page \"master dirty bit\"\n\t\t * as a serialization point for all the different\n\t\t * threads doing their things.\n\t\t */\n\t\tif (page_mkclean(page))\n\t\t\tset_page_dirty(page);\n\t\t/*\n\t\t * We carefully synchronise fault handlers against\n\t\t * installing a dirty pte and marking the page dirty\n\t\t * at this point.  We do this by having them hold the\n\t\t * page lock while dirtying the page, and pages are\n\t\t * always locked coming in here, so we get the desired\n\t\t * exclusion.\n\t\t */\n\t\twb = unlocked_inode_to_wb_begin(inode, &cookie);\n\t\tif (TestClearPageDirty(page)) {\n\t\t\tdec_lruvec_page_state(page, NR_FILE_DIRTY);\n\t\t\tdec_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t\t\tdec_wb_stat(wb, WB_RECLAIMABLE);\n\t\t\tret = 1;\n\t\t}\n\t\tunlocked_inode_to_wb_end(inode, &cookie);\n\t\treturn ret;\n\t}\n\treturn TestClearPageDirty(page);\n}"
  },
  {
    "function_name": "__cancel_dirty_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "2597-2617",
    "snippet": "void __cancel_dirty_page(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\n\tif (mapping_cap_account_dirty(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct bdi_writeback *wb;\n\t\tstruct wb_lock_cookie cookie = {};\n\n\t\tlock_page_memcg(page);\n\t\twb = unlocked_inode_to_wb_begin(inode, &cookie);\n\n\t\tif (TestClearPageDirty(page))\n\t\t\taccount_page_cleaned(page, mapping, wb);\n\n\t\tunlocked_inode_to_wb_end(inode, &cookie);\n\t\tunlock_page_memcg(page);\n\t} else {\n\t\tClearPageDirty(page);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ClearPageDirty",
          "args": [
            "page"
          ],
          "line": 2615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page_memcg",
          "args": [
            "page"
          ],
          "line": 2613
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlocked_inode_to_wb_end",
          "args": [
            "inode",
            "&cookie"
          ],
          "line": 2612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "account_page_cleaned",
          "args": [
            "page",
            "mapping",
            "wb"
          ],
          "line": 2610
        },
        "resolved": true,
        "details": {
          "function_name": "account_page_cleaned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2423-2432",
          "snippet": "void account_page_cleaned(struct page *page, struct address_space *mapping,\n\t\t\t  struct bdi_writeback *wb)\n{\n\tif (mapping_cap_account_dirty(mapping)) {\n\t\tdec_lruvec_page_state(page, NR_FILE_DIRTY);\n\t\tdec_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t\tdec_wb_stat(wb, WB_RECLAIMABLE);\n\t\ttask_io_account_cancelled_write(PAGE_SIZE);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid account_page_cleaned(struct page *page, struct address_space *mapping,\n\t\t\t  struct bdi_writeback *wb)\n{\n\tif (mapping_cap_account_dirty(mapping)) {\n\t\tdec_lruvec_page_state(page, NR_FILE_DIRTY);\n\t\tdec_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t\tdec_wb_stat(wb, WB_RECLAIMABLE);\n\t\ttask_io_account_cancelled_write(PAGE_SIZE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TestClearPageDirty",
          "args": [
            "page"
          ],
          "line": 2609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlocked_inode_to_wb_begin",
          "args": [
            "inode",
            "&cookie"
          ],
          "line": 2607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_cap_account_dirty",
          "args": [
            "mapping"
          ],
          "line": 2601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 2599
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid __cancel_dirty_page(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\n\tif (mapping_cap_account_dirty(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct bdi_writeback *wb;\n\t\tstruct wb_lock_cookie cookie = {};\n\n\t\tlock_page_memcg(page);\n\t\twb = unlocked_inode_to_wb_begin(inode, &cookie);\n\n\t\tif (TestClearPageDirty(page))\n\t\t\taccount_page_cleaned(page, mapping, wb);\n\n\t\tunlocked_inode_to_wb_end(inode, &cookie);\n\t\tunlock_page_memcg(page);\n\t} else {\n\t\tClearPageDirty(page);\n\t}\n}"
  },
  {
    "function_name": "set_page_dirty_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "2573-2581",
    "snippet": "int set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2579
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_dirty_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2573-2581",
          "snippet": "int set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}"
  },
  {
    "function_name": "set_page_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "2530-2560",
    "snippet": "int set_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\n\tpage = compound_head(page);\n\tif (likely(mapping)) {\n\t\tint (*spd)(struct page *) = mapping->a_ops->set_page_dirty;\n\t\t/*\n\t\t * readahead/lru_deactivate_page could remain\n\t\t * PG_readahead/PG_reclaim due to race with end_page_writeback\n\t\t * About readahead, if the page is written, the flags would be\n\t\t * reset. So no problem.\n\t\t * About lru_deactivate_page, if the page is redirty, the flag\n\t\t * will be reset. So no problem. but if the page is used by readahead\n\t\t * it will confuse readahead and make it restart the size rampup\n\t\t * process. But it's a trivial problem.\n\t\t */\n\t\tif (PageReclaim(page))\n\t\t\tClearPageReclaim(page);\n#ifdef CONFIG_BLOCK\n\t\tif (!spd)\n\t\t\tspd = __set_page_dirty_buffers;\n#endif\n\t\treturn (*spd)(page);\n\t}\n\tif (!PageDirty(page)) {\n\t\tif (!TestSetPageDirty(page))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TestSetPageDirty",
          "args": [
            "page"
          ],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "page"
          ],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageReclaim",
          "args": [
            "page"
          ],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageReclaim",
          "args": [
            "page"
          ],
          "line": 2547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "mapping"
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 2532
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint set_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\n\tpage = compound_head(page);\n\tif (likely(mapping)) {\n\t\tint (*spd)(struct page *) = mapping->a_ops->set_page_dirty;\n\t\t/*\n\t\t * readahead/lru_deactivate_page could remain\n\t\t * PG_readahead/PG_reclaim due to race with end_page_writeback\n\t\t * About readahead, if the page is written, the flags would be\n\t\t * reset. So no problem.\n\t\t * About lru_deactivate_page, if the page is redirty, the flag\n\t\t * will be reset. So no problem. but if the page is used by readahead\n\t\t * it will confuse readahead and make it restart the size rampup\n\t\t * process. But it's a trivial problem.\n\t\t */\n\t\tif (PageReclaim(page))\n\t\t\tClearPageReclaim(page);\n#ifdef CONFIG_BLOCK\n\t\tif (!spd)\n\t\t\tspd = __set_page_dirty_buffers;\n#endif\n\t\treturn (*spd)(page);\n\t}\n\tif (!PageDirty(page)) {\n\t\tif (!TestSetPageDirty(page))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "redirty_page_for_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "2508-2516",
    "snippet": "int redirty_page_for_writepage(struct writeback_control *wbc, struct page *page)\n{\n\tint ret;\n\n\twbc->pages_skipped++;\n\tret = __set_page_dirty_nobuffers(page);\n\taccount_page_redirty(page);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "account_page_redirty",
          "args": [
            "page"
          ],
          "line": 2514
        },
        "resolved": true,
        "details": {
          "function_name": "account_page_redirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2485-2500",
          "snippet": "void account_page_redirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\tif (mapping && mapping_cap_account_dirty(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct bdi_writeback *wb;\n\t\tstruct wb_lock_cookie cookie = {};\n\n\t\twb = unlocked_inode_to_wb_begin(inode, &cookie);\n\t\tcurrent->nr_dirtied--;\n\t\tdec_node_page_state(page, NR_DIRTIED);\n\t\tdec_wb_stat(wb, WB_DIRTIED);\n\t\tunlocked_inode_to_wb_end(inode, &cookie);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid account_page_redirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\tif (mapping && mapping_cap_account_dirty(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct bdi_writeback *wb;\n\t\tstruct wb_lock_cookie cookie = {};\n\n\t\twb = unlocked_inode_to_wb_begin(inode, &cookie);\n\t\tcurrent->nr_dirtied--;\n\t\tdec_node_page_state(page, NR_DIRTIED);\n\t\tdec_wb_stat(wb, WB_DIRTIED);\n\t\tunlocked_inode_to_wb_end(inode, &cookie);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_page_dirty_nobuffers",
          "args": [
            "page"
          ],
          "line": 2513
        },
        "resolved": true,
        "details": {
          "function_name": "__set_page_dirty_nobuffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2446-2475",
          "snippet": "int __set_page_dirty_nobuffers(struct page *page)\n{\n\tlock_page_memcg(page);\n\tif (!TestSetPageDirty(page)) {\n\t\tstruct address_space *mapping = page_mapping(page);\n\t\tunsigned long flags;\n\n\t\tif (!mapping) {\n\t\t\tunlock_page_memcg(page);\n\t\t\treturn 1;\n\t\t}\n\n\t\txa_lock_irqsave(&mapping->i_pages, flags);\n\t\tBUG_ON(page_mapping(page) != mapping);\n\t\tWARN_ON_ONCE(!PagePrivate(page) && !PageUptodate(page));\n\t\taccount_page_dirtied(page, mapping);\n\t\t__xa_set_mark(&mapping->i_pages, page_index(page),\n\t\t\t\t   PAGECACHE_TAG_DIRTY);\n\t\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\t\tunlock_page_memcg(page);\n\n\t\tif (mapping->host) {\n\t\t\t/* !PageAnon && !swapper_space */\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t\t}\n\t\treturn 1;\n\t}\n\tunlock_page_memcg(page);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint __set_page_dirty_nobuffers(struct page *page)\n{\n\tlock_page_memcg(page);\n\tif (!TestSetPageDirty(page)) {\n\t\tstruct address_space *mapping = page_mapping(page);\n\t\tunsigned long flags;\n\n\t\tif (!mapping) {\n\t\t\tunlock_page_memcg(page);\n\t\t\treturn 1;\n\t\t}\n\n\t\txa_lock_irqsave(&mapping->i_pages, flags);\n\t\tBUG_ON(page_mapping(page) != mapping);\n\t\tWARN_ON_ONCE(!PagePrivate(page) && !PageUptodate(page));\n\t\taccount_page_dirtied(page, mapping);\n\t\t__xa_set_mark(&mapping->i_pages, page_index(page),\n\t\t\t\t   PAGECACHE_TAG_DIRTY);\n\t\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\t\tunlock_page_memcg(page);\n\n\t\tif (mapping->host) {\n\t\t\t/* !PageAnon && !swapper_space */\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t\t}\n\t\treturn 1;\n\t}\n\tunlock_page_memcg(page);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint redirty_page_for_writepage(struct writeback_control *wbc, struct page *page)\n{\n\tint ret;\n\n\twbc->pages_skipped++;\n\tret = __set_page_dirty_nobuffers(page);\n\taccount_page_redirty(page);\n\treturn ret;\n}"
  },
  {
    "function_name": "account_page_redirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "2485-2500",
    "snippet": "void account_page_redirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\tif (mapping && mapping_cap_account_dirty(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct bdi_writeback *wb;\n\t\tstruct wb_lock_cookie cookie = {};\n\n\t\twb = unlocked_inode_to_wb_begin(inode, &cookie);\n\t\tcurrent->nr_dirtied--;\n\t\tdec_node_page_state(page, NR_DIRTIED);\n\t\tdec_wb_stat(wb, WB_DIRTIED);\n\t\tunlocked_inode_to_wb_end(inode, &cookie);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlocked_inode_to_wb_end",
          "args": [
            "inode",
            "&cookie"
          ],
          "line": 2498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_wb_stat",
          "args": [
            "wb",
            "WB_DIRTIED"
          ],
          "line": 2497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_node_page_state",
          "args": [
            "page",
            "NR_DIRTIED"
          ],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "dec_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "667-674",
          "snippet": "void dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_node_page_state(page, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_node_page_state(page, item);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlocked_inode_to_wb_begin",
          "args": [
            "inode",
            "&cookie"
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_cap_account_dirty",
          "args": [
            "mapping"
          ],
          "line": 2489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid account_page_redirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\tif (mapping && mapping_cap_account_dirty(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct bdi_writeback *wb;\n\t\tstruct wb_lock_cookie cookie = {};\n\n\t\twb = unlocked_inode_to_wb_begin(inode, &cookie);\n\t\tcurrent->nr_dirtied--;\n\t\tdec_node_page_state(page, NR_DIRTIED);\n\t\tdec_wb_stat(wb, WB_DIRTIED);\n\t\tunlocked_inode_to_wb_end(inode, &cookie);\n\t}\n}"
  },
  {
    "function_name": "__set_page_dirty_nobuffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "2446-2475",
    "snippet": "int __set_page_dirty_nobuffers(struct page *page)\n{\n\tlock_page_memcg(page);\n\tif (!TestSetPageDirty(page)) {\n\t\tstruct address_space *mapping = page_mapping(page);\n\t\tunsigned long flags;\n\n\t\tif (!mapping) {\n\t\t\tunlock_page_memcg(page);\n\t\t\treturn 1;\n\t\t}\n\n\t\txa_lock_irqsave(&mapping->i_pages, flags);\n\t\tBUG_ON(page_mapping(page) != mapping);\n\t\tWARN_ON_ONCE(!PagePrivate(page) && !PageUptodate(page));\n\t\taccount_page_dirtied(page, mapping);\n\t\t__xa_set_mark(&mapping->i_pages, page_index(page),\n\t\t\t\t   PAGECACHE_TAG_DIRTY);\n\t\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\t\tunlock_page_memcg(page);\n\n\t\tif (mapping->host) {\n\t\t\t/* !PageAnon && !swapper_space */\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t\t}\n\t\treturn 1;\n\t}\n\tunlock_page_memcg(page);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page_memcg",
          "args": [
            "page"
          ],
          "line": 2473
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mark_inode_dirty",
          "args": [
            "mapping->host",
            "I_DIRTY_PAGES"
          ],
          "line": 2469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_unlock_irqrestore",
          "args": [
            "&mapping->i_pages",
            "flags"
          ],
          "line": 2464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__xa_set_mark",
          "args": [
            "&mapping->i_pages",
            "page_index(page)",
            "PAGECACHE_TAG_DIRTY"
          ],
          "line": 2462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_index",
          "args": [
            "page"
          ],
          "line": 2462
        },
        "resolved": true,
        "details": {
          "function_name": "__basepage_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1358-1373",
          "snippet": "pgoff_t __basepage_index(struct page *page)\n{\n\tstruct page *page_head = compound_head(page);\n\tpgoff_t index = page_index(page_head);\n\tunsigned long compound_idx;\n\n\tif (!PageHuge(page_head))\n\t\treturn page_index(page);\n\n\tif (compound_order(page_head) >= MAX_ORDER)\n\t\tcompound_idx = page_to_pfn(page) - page_to_pfn(page_head);\n\telse\n\t\tcompound_idx = page - page_head;\n\n\treturn (index << compound_order(page_head)) + compound_idx;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\npgoff_t __basepage_index(struct page *page)\n{\n\tstruct page *page_head = compound_head(page);\n\tpgoff_t index = page_index(page_head);\n\tunsigned long compound_idx;\n\n\tif (!PageHuge(page_head))\n\t\treturn page_index(page);\n\n\tif (compound_order(page_head) >= MAX_ORDER)\n\t\tcompound_idx = page_to_pfn(page) - page_to_pfn(page_head);\n\telse\n\t\tcompound_idx = page - page_head;\n\n\treturn (index << compound_order(page_head)) + compound_idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "account_page_dirtied",
          "args": [
            "page",
            "mapping"
          ],
          "line": 2461
        },
        "resolved": true,
        "details": {
          "function_name": "account_page_dirtied",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2394-2415",
          "snippet": "void account_page_dirtied(struct page *page, struct address_space *mapping)\n{\n\tstruct inode *inode = mapping->host;\n\n\ttrace_writeback_dirty_page(page, mapping);\n\n\tif (mapping_cap_account_dirty(mapping)) {\n\t\tstruct bdi_writeback *wb;\n\n\t\tinode_attach_wb(inode, page);\n\t\twb = inode_to_wb(inode);\n\n\t\t__inc_lruvec_page_state(page, NR_FILE_DIRTY);\n\t\t__inc_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t\t__inc_node_page_state(page, NR_DIRTIED);\n\t\tinc_wb_stat(wb, WB_RECLAIMABLE);\n\t\tinc_wb_stat(wb, WB_DIRTIED);\n\t\ttask_io_account_write(PAGE_SIZE);\n\t\tcurrent->nr_dirtied++;\n\t\tthis_cpu_inc(bdp_ratelimits);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(int, bdp_ratelimits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_PER_CPU(int, bdp_ratelimits);\n\nvoid account_page_dirtied(struct page *page, struct address_space *mapping)\n{\n\tstruct inode *inode = mapping->host;\n\n\ttrace_writeback_dirty_page(page, mapping);\n\n\tif (mapping_cap_account_dirty(mapping)) {\n\t\tstruct bdi_writeback *wb;\n\n\t\tinode_attach_wb(inode, page);\n\t\twb = inode_to_wb(inode);\n\n\t\t__inc_lruvec_page_state(page, NR_FILE_DIRTY);\n\t\t__inc_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t\t__inc_node_page_state(page, NR_DIRTIED);\n\t\tinc_wb_stat(wb, WB_RECLAIMABLE);\n\t\tinc_wb_stat(wb, WB_DIRTIED);\n\t\ttask_io_account_write(PAGE_SIZE);\n\t\tcurrent->nr_dirtied++;\n\t\tthis_cpu_inc(bdp_ratelimits);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!PagePrivate(page) && !PageUptodate(page)"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page_mapping(page) != mapping"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 2459
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xa_lock_irqsave",
          "args": [
            "&mapping->i_pages",
            "flags"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestSetPageDirty",
          "args": [
            "page"
          ],
          "line": 2449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint __set_page_dirty_nobuffers(struct page *page)\n{\n\tlock_page_memcg(page);\n\tif (!TestSetPageDirty(page)) {\n\t\tstruct address_space *mapping = page_mapping(page);\n\t\tunsigned long flags;\n\n\t\tif (!mapping) {\n\t\t\tunlock_page_memcg(page);\n\t\t\treturn 1;\n\t\t}\n\n\t\txa_lock_irqsave(&mapping->i_pages, flags);\n\t\tBUG_ON(page_mapping(page) != mapping);\n\t\tWARN_ON_ONCE(!PagePrivate(page) && !PageUptodate(page));\n\t\taccount_page_dirtied(page, mapping);\n\t\t__xa_set_mark(&mapping->i_pages, page_index(page),\n\t\t\t\t   PAGECACHE_TAG_DIRTY);\n\t\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\t\tunlock_page_memcg(page);\n\n\t\tif (mapping->host) {\n\t\t\t/* !PageAnon && !swapper_space */\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t\t}\n\t\treturn 1;\n\t}\n\tunlock_page_memcg(page);\n\treturn 0;\n}"
  },
  {
    "function_name": "account_page_cleaned",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "2423-2432",
    "snippet": "void account_page_cleaned(struct page *page, struct address_space *mapping,\n\t\t\t  struct bdi_writeback *wb)\n{\n\tif (mapping_cap_account_dirty(mapping)) {\n\t\tdec_lruvec_page_state(page, NR_FILE_DIRTY);\n\t\tdec_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t\tdec_wb_stat(wb, WB_RECLAIMABLE);\n\t\ttask_io_account_cancelled_write(PAGE_SIZE);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_io_account_cancelled_write",
          "args": [
            "PAGE_SIZE"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_wb_stat",
          "args": [
            "wb",
            "WB_RECLAIMABLE"
          ],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_zone_page_state",
          "args": [
            "page",
            "NR_ZONE_WRITE_PENDING"
          ],
          "line": 2428
        },
        "resolved": true,
        "details": {
          "function_name": "dec_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "624-631",
          "snippet": "void dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dec_lruvec_page_state",
          "args": [
            "page",
            "NR_FILE_DIRTY"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_cap_account_dirty",
          "args": [
            "mapping"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid account_page_cleaned(struct page *page, struct address_space *mapping,\n\t\t\t  struct bdi_writeback *wb)\n{\n\tif (mapping_cap_account_dirty(mapping)) {\n\t\tdec_lruvec_page_state(page, NR_FILE_DIRTY);\n\t\tdec_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t\tdec_wb_stat(wb, WB_RECLAIMABLE);\n\t\ttask_io_account_cancelled_write(PAGE_SIZE);\n\t}\n}"
  },
  {
    "function_name": "account_page_dirtied",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "2394-2415",
    "snippet": "void account_page_dirtied(struct page *page, struct address_space *mapping)\n{\n\tstruct inode *inode = mapping->host;\n\n\ttrace_writeback_dirty_page(page, mapping);\n\n\tif (mapping_cap_account_dirty(mapping)) {\n\t\tstruct bdi_writeback *wb;\n\n\t\tinode_attach_wb(inode, page);\n\t\twb = inode_to_wb(inode);\n\n\t\t__inc_lruvec_page_state(page, NR_FILE_DIRTY);\n\t\t__inc_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t\t__inc_node_page_state(page, NR_DIRTIED);\n\t\tinc_wb_stat(wb, WB_RECLAIMABLE);\n\t\tinc_wb_stat(wb, WB_DIRTIED);\n\t\ttask_io_account_write(PAGE_SIZE);\n\t\tcurrent->nr_dirtied++;\n\t\tthis_cpu_inc(bdp_ratelimits);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(int, bdp_ratelimits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_inc",
          "args": [
            "bdp_ratelimits"
          ],
          "line": 2413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_io_account_write",
          "args": [
            "PAGE_SIZE"
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_wb_stat",
          "args": [
            "wb",
            "WB_DIRTIED"
          ],
          "line": 2410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_wb_stat",
          "args": [
            "wb",
            "WB_RECLAIMABLE"
          ],
          "line": 2409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__inc_node_page_state",
          "args": [
            "page",
            "NR_DIRTIED"
          ],
          "line": 2408
        },
        "resolved": true,
        "details": {
          "function_name": "__inc_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "416-419",
          "snippet": "void __inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__inc_node_state(page_pgdat(page), item);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__inc_node_state(page_pgdat(page), item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__inc_zone_page_state",
          "args": [
            "page",
            "NR_ZONE_WRITE_PENDING"
          ],
          "line": 2407
        },
        "resolved": true,
        "details": {
          "function_name": "__inc_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "410-413",
          "snippet": "void __inc_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\t__inc_zone_state(page_zone(page), item);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __inc_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\t__inc_zone_state(page_zone(page), item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__inc_lruvec_page_state",
          "args": [
            "page",
            "NR_FILE_DIRTY"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_wb",
          "args": [
            "inode"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_attach_wb",
          "args": [
            "inode",
            "page"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_cap_account_dirty",
          "args": [
            "mapping"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_writeback_dirty_page",
          "args": [
            "page",
            "mapping"
          ],
          "line": 2398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_PER_CPU(int, bdp_ratelimits);\n\nvoid account_page_dirtied(struct page *page, struct address_space *mapping)\n{\n\tstruct inode *inode = mapping->host;\n\n\ttrace_writeback_dirty_page(page, mapping);\n\n\tif (mapping_cap_account_dirty(mapping)) {\n\t\tstruct bdi_writeback *wb;\n\n\t\tinode_attach_wb(inode, page);\n\t\twb = inode_to_wb(inode);\n\n\t\t__inc_lruvec_page_state(page, NR_FILE_DIRTY);\n\t\t__inc_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t\t__inc_node_page_state(page, NR_DIRTIED);\n\t\tinc_wb_stat(wb, WB_RECLAIMABLE);\n\t\tinc_wb_stat(wb, WB_DIRTIED);\n\t\ttask_io_account_write(PAGE_SIZE);\n\t\tcurrent->nr_dirtied++;\n\t\tthis_cpu_inc(bdp_ratelimits);\n\t}\n}"
  },
  {
    "function_name": "__set_page_dirty_no_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "2380-2385",
    "snippet": "int __set_page_dirty_no_writeback(struct page *page)\n{\n\tif (!PageDirty(page))\n\t\treturn !TestSetPageDirty(page);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TestSetPageDirty",
          "args": [
            "page"
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint __set_page_dirty_no_writeback(struct page *page)\n{\n\tif (!PageDirty(page))\n\t\treturn !TestSetPageDirty(page);\n\treturn 0;\n}"
  },
  {
    "function_name": "write_one_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "2348-2374",
    "snippet": "int write_one_page(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tint ret = 0;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = 1,\n\t};\n\n\tBUG_ON(!PageLocked(page));\n\n\twait_on_page_writeback(page);\n\n\tif (clear_page_dirty_for_io(page)) {\n\t\tget_page(page);\n\t\tret = mapping->a_ops->writepage(page, &wbc);\n\t\tif (ret == 0)\n\t\t\twait_on_page_writeback(page);\n\t\tput_page(page);\n\t} else {\n\t\tunlock_page(page);\n\t}\n\n\tif (!ret)\n\t\tret = filemap_check_errors(mapping);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filemap_check_errors",
          "args": [
            "mapping"
          ],
          "line": 2372
        },
        "resolved": true,
        "details": {
          "function_name": "filemap_check_errors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "357-368",
          "snippet": "int filemap_check_errors(struct address_space *mapping)\n{\n\tint ret = 0;\n\t/* Check for outstanding write errors */\n\tif (test_bit(AS_ENOSPC, &mapping->flags) &&\n\t    test_and_clear_bit(AS_ENOSPC, &mapping->flags))\n\t\tret = -ENOSPC;\n\tif (test_bit(AS_EIO, &mapping->flags) &&\n\t    test_and_clear_bit(AS_EIO, &mapping->flags))\n\t\tret = -EIO;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint filemap_check_errors(struct address_space *mapping)\n{\n\tint ret = 0;\n\t/* Check for outstanding write errors */\n\tif (test_bit(AS_ENOSPC, &mapping->flags) &&\n\t    test_and_clear_bit(AS_ENOSPC, &mapping->flags))\n\t\tret = -ENOSPC;\n\tif (test_bit(AS_EIO, &mapping->flags) &&\n\t    test_and_clear_bit(AS_EIO, &mapping->flags))\n\t\tret = -EIO;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2368
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 2366
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->writepage",
          "args": [
            "page",
            "&wbc"
          ],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 2362
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "page"
          ],
          "line": 2361
        },
        "resolved": true,
        "details": {
          "function_name": "clear_page_dirty_for_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2634-2692",
          "snippet": "int clear_page_dirty_for_io(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (mapping && mapping_cap_account_dirty(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct bdi_writeback *wb;\n\t\tstruct wb_lock_cookie cookie = {};\n\n\t\t/*\n\t\t * Yes, Virginia, this is indeed insane.\n\t\t *\n\t\t * We use this sequence to make sure that\n\t\t *  (a) we account for dirty stats properly\n\t\t *  (b) we tell the low-level filesystem to\n\t\t *      mark the whole page dirty if it was\n\t\t *      dirty in a pagetable. Only to then\n\t\t *  (c) clean the page again and return 1 to\n\t\t *      cause the writeback.\n\t\t *\n\t\t * This way we avoid all nasty races with the\n\t\t * dirty bit in multiple places and clearing\n\t\t * them concurrently from different threads.\n\t\t *\n\t\t * Note! Normally the \"set_page_dirty(page)\"\n\t\t * has no effect on the actual dirty bit - since\n\t\t * that will already usually be set. But we\n\t\t * need the side effects, and it can help us\n\t\t * avoid races.\n\t\t *\n\t\t * We basically use the page \"master dirty bit\"\n\t\t * as a serialization point for all the different\n\t\t * threads doing their things.\n\t\t */\n\t\tif (page_mkclean(page))\n\t\t\tset_page_dirty(page);\n\t\t/*\n\t\t * We carefully synchronise fault handlers against\n\t\t * installing a dirty pte and marking the page dirty\n\t\t * at this point.  We do this by having them hold the\n\t\t * page lock while dirtying the page, and pages are\n\t\t * always locked coming in here, so we get the desired\n\t\t * exclusion.\n\t\t */\n\t\twb = unlocked_inode_to_wb_begin(inode, &cookie);\n\t\tif (TestClearPageDirty(page)) {\n\t\t\tdec_lruvec_page_state(page, NR_FILE_DIRTY);\n\t\t\tdec_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t\t\tdec_wb_stat(wb, WB_RECLAIMABLE);\n\t\t\tret = 1;\n\t\t}\n\t\tunlocked_inode_to_wb_end(inode, &cookie);\n\t\treturn ret;\n\t}\n\treturn TestClearPageDirty(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint clear_page_dirty_for_io(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (mapping && mapping_cap_account_dirty(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct bdi_writeback *wb;\n\t\tstruct wb_lock_cookie cookie = {};\n\n\t\t/*\n\t\t * Yes, Virginia, this is indeed insane.\n\t\t *\n\t\t * We use this sequence to make sure that\n\t\t *  (a) we account for dirty stats properly\n\t\t *  (b) we tell the low-level filesystem to\n\t\t *      mark the whole page dirty if it was\n\t\t *      dirty in a pagetable. Only to then\n\t\t *  (c) clean the page again and return 1 to\n\t\t *      cause the writeback.\n\t\t *\n\t\t * This way we avoid all nasty races with the\n\t\t * dirty bit in multiple places and clearing\n\t\t * them concurrently from different threads.\n\t\t *\n\t\t * Note! Normally the \"set_page_dirty(page)\"\n\t\t * has no effect on the actual dirty bit - since\n\t\t * that will already usually be set. But we\n\t\t * need the side effects, and it can help us\n\t\t * avoid races.\n\t\t *\n\t\t * We basically use the page \"master dirty bit\"\n\t\t * as a serialization point for all the different\n\t\t * threads doing their things.\n\t\t */\n\t\tif (page_mkclean(page))\n\t\t\tset_page_dirty(page);\n\t\t/*\n\t\t * We carefully synchronise fault handlers against\n\t\t * installing a dirty pte and marking the page dirty\n\t\t * at this point.  We do this by having them hold the\n\t\t * page lock while dirtying the page, and pages are\n\t\t * always locked coming in here, so we get the desired\n\t\t * exclusion.\n\t\t */\n\t\twb = unlocked_inode_to_wb_begin(inode, &cookie);\n\t\tif (TestClearPageDirty(page)) {\n\t\t\tdec_lruvec_page_state(page, NR_FILE_DIRTY);\n\t\t\tdec_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t\t\tdec_wb_stat(wb, WB_RECLAIMABLE);\n\t\t\tret = 1;\n\t\t}\n\t\tunlocked_inode_to_wb_end(inode, &cookie);\n\t\treturn ret;\n\t}\n\treturn TestClearPageDirty(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint write_one_page(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tint ret = 0;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = 1,\n\t};\n\n\tBUG_ON(!PageLocked(page));\n\n\twait_on_page_writeback(page);\n\n\tif (clear_page_dirty_for_io(page)) {\n\t\tget_page(page);\n\t\tret = mapping->a_ops->writepage(page, &wbc);\n\t\tif (ret == 0)\n\t\t\twait_on_page_writeback(page);\n\t\tput_page(page);\n\t} else {\n\t\tunlock_page(page);\n\t}\n\n\tif (!ret)\n\t\tret = filemap_check_errors(mapping);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_writepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "2320-2337",
    "snippet": "int do_writepages(struct address_space *mapping, struct writeback_control *wbc)\n{\n\tint ret;\n\n\tif (wbc->nr_to_write <= 0)\n\t\treturn 0;\n\twhile (1) {\n\t\tif (mapping->a_ops->writepages)\n\t\t\tret = mapping->a_ops->writepages(mapping, wbc);\n\t\telse\n\t\t\tret = generic_writepages(mapping, wbc);\n\t\tif ((ret != -ENOMEM) || (wbc->sync_mode != WB_SYNC_ALL))\n\t\t\tbreak;\n\t\tcond_resched();\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "congestion_wait",
          "args": [
            "BLK_RW_ASYNC",
            "HZ/50"
          ],
          "line": 2334
        },
        "resolved": true,
        "details": {
          "function_name": "congestion_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/backing-dev.c",
          "lines": "1016-1031",
          "snippet": "long congestion_wait(int sync, long timeout)\n{\n\tlong ret;\n\tunsigned long start = jiffies;\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = &congestion_wqh[sync];\n\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tret = io_schedule_timeout(timeout);\n\tfinish_wait(wqh, &wait);\n\n\ttrace_writeback_congestion_wait(jiffies_to_usecs(timeout),\n\t\t\t\t\tjiffies_to_usecs(jiffies - start));\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <trace/events/writeback.h>",
            "#include <linux/device.h>",
            "#include <linux/writeback.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/wait.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static wait_queue_head_t congestion_wqh[2] = {\n\t\t__WAIT_QUEUE_HEAD_INITIALIZER(congestion_wqh[0]),\n\t\t__WAIT_QUEUE_HEAD_INITIALIZER(congestion_wqh[1])\n\t};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <trace/events/writeback.h>\n#include <linux/device.h>\n#include <linux/writeback.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/wait.h>\n\nstatic wait_queue_head_t congestion_wqh[2] = {\n\t\t__WAIT_QUEUE_HEAD_INITIALIZER(congestion_wqh[0]),\n\t\t__WAIT_QUEUE_HEAD_INITIALIZER(congestion_wqh[1])\n\t};\n\nlong congestion_wait(int sync, long timeout)\n{\n\tlong ret;\n\tunsigned long start = jiffies;\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = &congestion_wqh[sync];\n\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tret = io_schedule_timeout(timeout);\n\tfinish_wait(wqh, &wait);\n\n\ttrace_writeback_congestion_wait(jiffies_to_usecs(timeout),\n\t\t\t\t\tjiffies_to_usecs(jiffies - start));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_writepages",
          "args": [
            "mapping",
            "wbc"
          ],
          "line": 2330
        },
        "resolved": true,
        "details": {
          "function_name": "generic_writepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2302-2316",
          "snippet": "int generic_writepages(struct address_space *mapping,\n\t\t       struct writeback_control *wbc)\n{\n\tstruct blk_plug plug;\n\tint ret;\n\n\t/* deal with chardevs and other special file */\n\tif (!mapping->a_ops->writepage)\n\t\treturn 0;\n\n\tblk_start_plug(&plug);\n\tret = write_cache_pages(mapping, wbc, __writepage, mapping);\n\tblk_finish_plug(&plug);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint generic_writepages(struct address_space *mapping,\n\t\t       struct writeback_control *wbc)\n{\n\tstruct blk_plug plug;\n\tint ret;\n\n\t/* deal with chardevs and other special file */\n\tif (!mapping->a_ops->writepage)\n\t\treturn 0;\n\n\tblk_start_plug(&plug);\n\tret = write_cache_pages(mapping, wbc, __writepage, mapping);\n\tblk_finish_plug(&plug);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->writepages",
          "args": [
            "mapping",
            "wbc"
          ],
          "line": 2328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint do_writepages(struct address_space *mapping, struct writeback_control *wbc)\n{\n\tint ret;\n\n\tif (wbc->nr_to_write <= 0)\n\t\treturn 0;\n\twhile (1) {\n\t\tif (mapping->a_ops->writepages)\n\t\t\tret = mapping->a_ops->writepages(mapping, wbc);\n\t\telse\n\t\t\tret = generic_writepages(mapping, wbc);\n\t\tif ((ret != -ENOMEM) || (wbc->sync_mode != WB_SYNC_ALL))\n\t\t\tbreak;\n\t\tcond_resched();\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "generic_writepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "2302-2316",
    "snippet": "int generic_writepages(struct address_space *mapping,\n\t\t       struct writeback_control *wbc)\n{\n\tstruct blk_plug plug;\n\tint ret;\n\n\t/* deal with chardevs and other special file */\n\tif (!mapping->a_ops->writepage)\n\t\treturn 0;\n\n\tblk_start_plug(&plug);\n\tret = write_cache_pages(mapping, wbc, __writepage, mapping);\n\tblk_finish_plug(&plug);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_cache_pages",
          "args": [
            "mapping",
            "wbc",
            "__writepage",
            "mapping"
          ],
          "line": 2313
        },
        "resolved": true,
        "details": {
          "function_name": "write_cache_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2151-2278",
          "snippet": "int write_cache_pages(struct address_space *mapping,\n\t\t      struct writeback_control *wbc, writepage_t writepage,\n\t\t      void *data)\n{\n\tint ret = 0;\n\tint done = 0;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\tpgoff_t uninitialized_var(writeback_index);\n\tpgoff_t index;\n\tpgoff_t end;\t\t/* Inclusive */\n\tpgoff_t done_index;\n\tint range_whole = 0;\n\txa_mark_t tag;\n\n\tpagevec_init(&pvec);\n\tif (wbc->range_cyclic) {\n\t\twriteback_index = mapping->writeback_index; /* prev offset */\n\t\tindex = writeback_index;\n\t\tend = -1;\n\t} else {\n\t\tindex = wbc->range_start >> PAGE_SHIFT;\n\t\tend = wbc->range_end >> PAGE_SHIFT;\n\t\tif (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)\n\t\t\trange_whole = 1;\n\t}\n\tif (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages)\n\t\ttag = PAGECACHE_TAG_TOWRITE;\n\telse\n\t\ttag = PAGECACHE_TAG_DIRTY;\n\tif (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages)\n\t\ttag_pages_for_writeback(mapping, index, end);\n\tdone_index = index;\n\twhile (!done && (index <= end)) {\n\t\tint i;\n\n\t\tnr_pages = pagevec_lookup_range_tag(&pvec, mapping, &index, end,\n\t\t\t\ttag);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tdone_index = page->index;\n\n\t\t\tlock_page(page);\n\n\t\t\t/*\n\t\t\t * Page truncated or invalidated. We can freely skip it\n\t\t\t * then, even for data integrity operations: the page\n\t\t\t * has disappeared concurrently, so there could be no\n\t\t\t * real expectation of this data interity operation\n\t\t\t * even if there is now a new, dirty page at the same\n\t\t\t * pagecache address.\n\t\t\t */\n\t\t\tif (unlikely(page->mapping != mapping)) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tif (PageWriteback(page)) {\n\t\t\t\tif (wbc->sync_mode != WB_SYNC_NONE)\n\t\t\t\t\twait_on_page_writeback(page);\n\t\t\t\telse\n\t\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tBUG_ON(PageWriteback(page));\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\ttrace_wbc_writepage(wbc, inode_to_bdi(mapping->host));\n\t\t\tret = (*writepage)(page, wbc, data);\n\t\t\tif (unlikely(ret)) {\n\t\t\t\tif (ret == AOP_WRITEPAGE_ACTIVATE) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tret = 0;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * done_index is set past this page,\n\t\t\t\t\t * so media errors will not choke\n\t\t\t\t\t * background writeout for the entire\n\t\t\t\t\t * file. This has consequences for\n\t\t\t\t\t * range_cyclic semantics (ie. it may\n\t\t\t\t\t * not be suitable for data integrity\n\t\t\t\t\t * writeout).\n\t\t\t\t\t */\n\t\t\t\t\tdone_index = page->index + 1;\n\t\t\t\t\tdone = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We stop writing back only if we are not doing\n\t\t\t * integrity sync. In case of integrity sync we have to\n\t\t\t * keep going until we have written all the pages\n\t\t\t * we tagged for writeback prior to entering this loop.\n\t\t\t */\n\t\t\tif (--wbc->nr_to_write <= 0 &&\n\t\t\t    wbc->sync_mode == WB_SYNC_NONE) {\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * If we hit the last page and there is more work to be done: wrap\n\t * back the index back to the start of the file for the next\n\t * time we are called.\n\t */\n\tif (wbc->range_cyclic && !done)\n\t\tdone_index = 0;\n\tif (wbc->range_cyclic || (range_whole && wbc->nr_to_write > 0))\n\t\tmapping->writeback_index = done_index;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint write_cache_pages(struct address_space *mapping,\n\t\t      struct writeback_control *wbc, writepage_t writepage,\n\t\t      void *data)\n{\n\tint ret = 0;\n\tint done = 0;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\tpgoff_t uninitialized_var(writeback_index);\n\tpgoff_t index;\n\tpgoff_t end;\t\t/* Inclusive */\n\tpgoff_t done_index;\n\tint range_whole = 0;\n\txa_mark_t tag;\n\n\tpagevec_init(&pvec);\n\tif (wbc->range_cyclic) {\n\t\twriteback_index = mapping->writeback_index; /* prev offset */\n\t\tindex = writeback_index;\n\t\tend = -1;\n\t} else {\n\t\tindex = wbc->range_start >> PAGE_SHIFT;\n\t\tend = wbc->range_end >> PAGE_SHIFT;\n\t\tif (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)\n\t\t\trange_whole = 1;\n\t}\n\tif (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages)\n\t\ttag = PAGECACHE_TAG_TOWRITE;\n\telse\n\t\ttag = PAGECACHE_TAG_DIRTY;\n\tif (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages)\n\t\ttag_pages_for_writeback(mapping, index, end);\n\tdone_index = index;\n\twhile (!done && (index <= end)) {\n\t\tint i;\n\n\t\tnr_pages = pagevec_lookup_range_tag(&pvec, mapping, &index, end,\n\t\t\t\ttag);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tdone_index = page->index;\n\n\t\t\tlock_page(page);\n\n\t\t\t/*\n\t\t\t * Page truncated or invalidated. We can freely skip it\n\t\t\t * then, even for data integrity operations: the page\n\t\t\t * has disappeared concurrently, so there could be no\n\t\t\t * real expectation of this data interity operation\n\t\t\t * even if there is now a new, dirty page at the same\n\t\t\t * pagecache address.\n\t\t\t */\n\t\t\tif (unlikely(page->mapping != mapping)) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tif (PageWriteback(page)) {\n\t\t\t\tif (wbc->sync_mode != WB_SYNC_NONE)\n\t\t\t\t\twait_on_page_writeback(page);\n\t\t\t\telse\n\t\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tBUG_ON(PageWriteback(page));\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\ttrace_wbc_writepage(wbc, inode_to_bdi(mapping->host));\n\t\t\tret = (*writepage)(page, wbc, data);\n\t\t\tif (unlikely(ret)) {\n\t\t\t\tif (ret == AOP_WRITEPAGE_ACTIVATE) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tret = 0;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * done_index is set past this page,\n\t\t\t\t\t * so media errors will not choke\n\t\t\t\t\t * background writeout for the entire\n\t\t\t\t\t * file. This has consequences for\n\t\t\t\t\t * range_cyclic semantics (ie. it may\n\t\t\t\t\t * not be suitable for data integrity\n\t\t\t\t\t * writeout).\n\t\t\t\t\t */\n\t\t\t\t\tdone_index = page->index + 1;\n\t\t\t\t\tdone = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We stop writing back only if we are not doing\n\t\t\t * integrity sync. In case of integrity sync we have to\n\t\t\t * keep going until we have written all the pages\n\t\t\t * we tagged for writeback prior to entering this loop.\n\t\t\t */\n\t\t\tif (--wbc->nr_to_write <= 0 &&\n\t\t\t    wbc->sync_mode == WB_SYNC_NONE) {\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * If we hit the last page and there is more work to be done: wrap\n\t * back the index back to the start of the file for the next\n\t * time we are called.\n\t */\n\tif (wbc->range_cyclic && !done)\n\t\tdone_index = 0;\n\tif (wbc->range_cyclic || (range_whole && wbc->nr_to_write > 0))\n\t\tmapping->writeback_index = done_index;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint generic_writepages(struct address_space *mapping,\n\t\t       struct writeback_control *wbc)\n{\n\tstruct blk_plug plug;\n\tint ret;\n\n\t/* deal with chardevs and other special file */\n\tif (!mapping->a_ops->writepage)\n\t\treturn 0;\n\n\tblk_start_plug(&plug);\n\tret = write_cache_pages(mapping, wbc, __writepage, mapping);\n\tblk_finish_plug(&plug);\n\treturn ret;\n}"
  },
  {
    "function_name": "__writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "2285-2292",
    "snippet": "static int __writepage(struct page *page, struct writeback_control *wbc,\n\t\t       void *data)\n{\n\tstruct address_space *mapping = data;\n\tint ret = mapping->a_ops->writepage(page, wbc);\n\tmapping_set_error(mapping, ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "mapping",
            "ret"
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->writepage",
          "args": [
            "page",
            "wbc"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic int __writepage(struct page *page, struct writeback_control *wbc,\n\t\t       void *data)\n{\n\tstruct address_space *mapping = data;\n\tint ret = mapping->a_ops->writepage(page, wbc);\n\tmapping_set_error(mapping, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "write_cache_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "2151-2278",
    "snippet": "int write_cache_pages(struct address_space *mapping,\n\t\t      struct writeback_control *wbc, writepage_t writepage,\n\t\t      void *data)\n{\n\tint ret = 0;\n\tint done = 0;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\tpgoff_t uninitialized_var(writeback_index);\n\tpgoff_t index;\n\tpgoff_t end;\t\t/* Inclusive */\n\tpgoff_t done_index;\n\tint range_whole = 0;\n\txa_mark_t tag;\n\n\tpagevec_init(&pvec);\n\tif (wbc->range_cyclic) {\n\t\twriteback_index = mapping->writeback_index; /* prev offset */\n\t\tindex = writeback_index;\n\t\tend = -1;\n\t} else {\n\t\tindex = wbc->range_start >> PAGE_SHIFT;\n\t\tend = wbc->range_end >> PAGE_SHIFT;\n\t\tif (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)\n\t\t\trange_whole = 1;\n\t}\n\tif (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages)\n\t\ttag = PAGECACHE_TAG_TOWRITE;\n\telse\n\t\ttag = PAGECACHE_TAG_DIRTY;\n\tif (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages)\n\t\ttag_pages_for_writeback(mapping, index, end);\n\tdone_index = index;\n\twhile (!done && (index <= end)) {\n\t\tint i;\n\n\t\tnr_pages = pagevec_lookup_range_tag(&pvec, mapping, &index, end,\n\t\t\t\ttag);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tdone_index = page->index;\n\n\t\t\tlock_page(page);\n\n\t\t\t/*\n\t\t\t * Page truncated or invalidated. We can freely skip it\n\t\t\t * then, even for data integrity operations: the page\n\t\t\t * has disappeared concurrently, so there could be no\n\t\t\t * real expectation of this data interity operation\n\t\t\t * even if there is now a new, dirty page at the same\n\t\t\t * pagecache address.\n\t\t\t */\n\t\t\tif (unlikely(page->mapping != mapping)) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tif (PageWriteback(page)) {\n\t\t\t\tif (wbc->sync_mode != WB_SYNC_NONE)\n\t\t\t\t\twait_on_page_writeback(page);\n\t\t\t\telse\n\t\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tBUG_ON(PageWriteback(page));\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\ttrace_wbc_writepage(wbc, inode_to_bdi(mapping->host));\n\t\t\tret = (*writepage)(page, wbc, data);\n\t\t\tif (unlikely(ret)) {\n\t\t\t\tif (ret == AOP_WRITEPAGE_ACTIVATE) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tret = 0;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * done_index is set past this page,\n\t\t\t\t\t * so media errors will not choke\n\t\t\t\t\t * background writeout for the entire\n\t\t\t\t\t * file. This has consequences for\n\t\t\t\t\t * range_cyclic semantics (ie. it may\n\t\t\t\t\t * not be suitable for data integrity\n\t\t\t\t\t * writeout).\n\t\t\t\t\t */\n\t\t\t\t\tdone_index = page->index + 1;\n\t\t\t\t\tdone = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We stop writing back only if we are not doing\n\t\t\t * integrity sync. In case of integrity sync we have to\n\t\t\t * keep going until we have written all the pages\n\t\t\t * we tagged for writeback prior to entering this loop.\n\t\t\t */\n\t\t\tif (--wbc->nr_to_write <= 0 &&\n\t\t\t    wbc->sync_mode == WB_SYNC_NONE) {\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * If we hit the last page and there is more work to be done: wrap\n\t * back the index back to the start of the file for the next\n\t * time we are called.\n\t */\n\tif (wbc->range_cyclic && !done)\n\t\tdone_index = 0;\n\tif (wbc->range_cyclic || (range_whole && wbc->nr_to_write > 0))\n\t\tmapping->writeback_index = done_index;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 2263
        },
        "resolved": true,
        "details": {
          "function_name": "__pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "805-813",
          "snippet": "void __pagevec_release(struct pagevec *pvec)\n{\n\tif (!pvec->percpu_pvec_drained) {\n\t\tlru_add_drain();\n\t\tpvec->percpu_pvec_drained = true;\n\t}\n\trelease_pages(pvec->pages, pagevec_count(pvec));\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid __pagevec_release(struct pagevec *pvec)\n{\n\tif (!pvec->percpu_pvec_drained) {\n\t\tlru_add_drain();\n\t\tpvec->percpu_pvec_drained = true;\n\t}\n\trelease_pages(pvec->pages, pagevec_count(pvec));\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "page",
            "wbc",
            "data"
          ],
          "line": 2230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_wbc_writepage",
          "args": [
            "wbc",
            "inode_to_bdi(mapping->host)"
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "mapping->host"
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "page"
          ],
          "line": 2226
        },
        "resolved": true,
        "details": {
          "function_name": "clear_page_dirty_for_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2634-2692",
          "snippet": "int clear_page_dirty_for_io(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (mapping && mapping_cap_account_dirty(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct bdi_writeback *wb;\n\t\tstruct wb_lock_cookie cookie = {};\n\n\t\t/*\n\t\t * Yes, Virginia, this is indeed insane.\n\t\t *\n\t\t * We use this sequence to make sure that\n\t\t *  (a) we account for dirty stats properly\n\t\t *  (b) we tell the low-level filesystem to\n\t\t *      mark the whole page dirty if it was\n\t\t *      dirty in a pagetable. Only to then\n\t\t *  (c) clean the page again and return 1 to\n\t\t *      cause the writeback.\n\t\t *\n\t\t * This way we avoid all nasty races with the\n\t\t * dirty bit in multiple places and clearing\n\t\t * them concurrently from different threads.\n\t\t *\n\t\t * Note! Normally the \"set_page_dirty(page)\"\n\t\t * has no effect on the actual dirty bit - since\n\t\t * that will already usually be set. But we\n\t\t * need the side effects, and it can help us\n\t\t * avoid races.\n\t\t *\n\t\t * We basically use the page \"master dirty bit\"\n\t\t * as a serialization point for all the different\n\t\t * threads doing their things.\n\t\t */\n\t\tif (page_mkclean(page))\n\t\t\tset_page_dirty(page);\n\t\t/*\n\t\t * We carefully synchronise fault handlers against\n\t\t * installing a dirty pte and marking the page dirty\n\t\t * at this point.  We do this by having them hold the\n\t\t * page lock while dirtying the page, and pages are\n\t\t * always locked coming in here, so we get the desired\n\t\t * exclusion.\n\t\t */\n\t\twb = unlocked_inode_to_wb_begin(inode, &cookie);\n\t\tif (TestClearPageDirty(page)) {\n\t\t\tdec_lruvec_page_state(page, NR_FILE_DIRTY);\n\t\t\tdec_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t\t\tdec_wb_stat(wb, WB_RECLAIMABLE);\n\t\t\tret = 1;\n\t\t}\n\t\tunlocked_inode_to_wb_end(inode, &cookie);\n\t\treturn ret;\n\t}\n\treturn TestClearPageDirty(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint clear_page_dirty_for_io(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (mapping && mapping_cap_account_dirty(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct bdi_writeback *wb;\n\t\tstruct wb_lock_cookie cookie = {};\n\n\t\t/*\n\t\t * Yes, Virginia, this is indeed insane.\n\t\t *\n\t\t * We use this sequence to make sure that\n\t\t *  (a) we account for dirty stats properly\n\t\t *  (b) we tell the low-level filesystem to\n\t\t *      mark the whole page dirty if it was\n\t\t *      dirty in a pagetable. Only to then\n\t\t *  (c) clean the page again and return 1 to\n\t\t *      cause the writeback.\n\t\t *\n\t\t * This way we avoid all nasty races with the\n\t\t * dirty bit in multiple places and clearing\n\t\t * them concurrently from different threads.\n\t\t *\n\t\t * Note! Normally the \"set_page_dirty(page)\"\n\t\t * has no effect on the actual dirty bit - since\n\t\t * that will already usually be set. But we\n\t\t * need the side effects, and it can help us\n\t\t * avoid races.\n\t\t *\n\t\t * We basically use the page \"master dirty bit\"\n\t\t * as a serialization point for all the different\n\t\t * threads doing their things.\n\t\t */\n\t\tif (page_mkclean(page))\n\t\t\tset_page_dirty(page);\n\t\t/*\n\t\t * We carefully synchronise fault handlers against\n\t\t * installing a dirty pte and marking the page dirty\n\t\t * at this point.  We do this by having them hold the\n\t\t * page lock while dirtying the page, and pages are\n\t\t * always locked coming in here, so we get the desired\n\t\t * exclusion.\n\t\t */\n\t\twb = unlocked_inode_to_wb_begin(inode, &cookie);\n\t\tif (TestClearPageDirty(page)) {\n\t\t\tdec_lruvec_page_state(page, NR_FILE_DIRTY);\n\t\t\tdec_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t\t\tdec_wb_stat(wb, WB_RECLAIMABLE);\n\t\t\tret = 1;\n\t\t}\n\t\tunlocked_inode_to_wb_end(inode, &cookie);\n\t\treturn ret;\n\t}\n\treturn TestClearPageDirty(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageWriteback(page)"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->mapping != mapping"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lookup_range_tag",
          "args": [
            "&pvec",
            "mapping",
            "&index",
            "end",
            "tag"
          ],
          "line": 2187
        },
        "resolved": true,
        "details": {
          "function_name": "pagevec_lookup_range_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "1002-1009",
          "snippet": "unsigned pagevec_lookup_range_tag(struct pagevec *pvec,\n\t\tstruct address_space *mapping, pgoff_t *index, pgoff_t end,\n\t\txa_mark_t tag)\n{\n\tpvec->nr = find_get_pages_range_tag(mapping, index, end, tag,\n\t\t\t\t\tPAGEVEC_SIZE, pvec->pages);\n\treturn pagevec_count(pvec);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nunsigned pagevec_lookup_range_tag(struct pagevec *pvec,\n\t\tstruct address_space *mapping, pgoff_t *index, pgoff_t end,\n\t\txa_mark_t tag)\n{\n\tpvec->nr = find_get_pages_range_tag(mapping, index, end, tag,\n\t\t\t\t\tPAGEVEC_SIZE, pvec->pages);\n\treturn pagevec_count(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tag_pages_for_writeback",
          "args": [
            "mapping",
            "index",
            "end"
          ],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "tag_pages_for_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2100-2119",
          "snippet": "void tag_pages_for_writeback(struct address_space *mapping,\n\t\t\t     pgoff_t start, pgoff_t end)\n{\n\tXA_STATE(xas, &mapping->i_pages, start);\n\tunsigned int tagged = 0;\n\tvoid *page;\n\n\txas_lock_irq(&xas);\n\txas_for_each_marked(&xas, page, end, PAGECACHE_TAG_DIRTY) {\n\t\txas_set_mark(&xas, PAGECACHE_TAG_TOWRITE);\n\t\tif (++tagged % XA_CHECK_SCHED)\n\t\t\tcontinue;\n\n\t\txas_pause(&xas);\n\t\txas_unlock_irq(&xas);\n\t\tcond_resched();\n\t\txas_lock_irq(&xas);\n\t}\n\txas_unlock_irq(&xas);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid tag_pages_for_writeback(struct address_space *mapping,\n\t\t\t     pgoff_t start, pgoff_t end)\n{\n\tXA_STATE(xas, &mapping->i_pages, start);\n\tunsigned int tagged = 0;\n\tvoid *page;\n\n\txas_lock_irq(&xas);\n\txas_for_each_marked(&xas, page, end, PAGECACHE_TAG_DIRTY) {\n\t\txas_set_mark(&xas, PAGECACHE_TAG_TOWRITE);\n\t\tif (++tagged % XA_CHECK_SCHED)\n\t\t\tcontinue;\n\n\t\txas_pause(&xas);\n\t\txas_unlock_irq(&xas);\n\t\tcond_resched();\n\t\txas_lock_irq(&xas);\n\t}\n\txas_unlock_irq(&xas);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint write_cache_pages(struct address_space *mapping,\n\t\t      struct writeback_control *wbc, writepage_t writepage,\n\t\t      void *data)\n{\n\tint ret = 0;\n\tint done = 0;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\tpgoff_t uninitialized_var(writeback_index);\n\tpgoff_t index;\n\tpgoff_t end;\t\t/* Inclusive */\n\tpgoff_t done_index;\n\tint range_whole = 0;\n\txa_mark_t tag;\n\n\tpagevec_init(&pvec);\n\tif (wbc->range_cyclic) {\n\t\twriteback_index = mapping->writeback_index; /* prev offset */\n\t\tindex = writeback_index;\n\t\tend = -1;\n\t} else {\n\t\tindex = wbc->range_start >> PAGE_SHIFT;\n\t\tend = wbc->range_end >> PAGE_SHIFT;\n\t\tif (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)\n\t\t\trange_whole = 1;\n\t}\n\tif (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages)\n\t\ttag = PAGECACHE_TAG_TOWRITE;\n\telse\n\t\ttag = PAGECACHE_TAG_DIRTY;\n\tif (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages)\n\t\ttag_pages_for_writeback(mapping, index, end);\n\tdone_index = index;\n\twhile (!done && (index <= end)) {\n\t\tint i;\n\n\t\tnr_pages = pagevec_lookup_range_tag(&pvec, mapping, &index, end,\n\t\t\t\ttag);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tdone_index = page->index;\n\n\t\t\tlock_page(page);\n\n\t\t\t/*\n\t\t\t * Page truncated or invalidated. We can freely skip it\n\t\t\t * then, even for data integrity operations: the page\n\t\t\t * has disappeared concurrently, so there could be no\n\t\t\t * real expectation of this data interity operation\n\t\t\t * even if there is now a new, dirty page at the same\n\t\t\t * pagecache address.\n\t\t\t */\n\t\t\tif (unlikely(page->mapping != mapping)) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tif (PageWriteback(page)) {\n\t\t\t\tif (wbc->sync_mode != WB_SYNC_NONE)\n\t\t\t\t\twait_on_page_writeback(page);\n\t\t\t\telse\n\t\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tBUG_ON(PageWriteback(page));\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\ttrace_wbc_writepage(wbc, inode_to_bdi(mapping->host));\n\t\t\tret = (*writepage)(page, wbc, data);\n\t\t\tif (unlikely(ret)) {\n\t\t\t\tif (ret == AOP_WRITEPAGE_ACTIVATE) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tret = 0;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * done_index is set past this page,\n\t\t\t\t\t * so media errors will not choke\n\t\t\t\t\t * background writeout for the entire\n\t\t\t\t\t * file. This has consequences for\n\t\t\t\t\t * range_cyclic semantics (ie. it may\n\t\t\t\t\t * not be suitable for data integrity\n\t\t\t\t\t * writeout).\n\t\t\t\t\t */\n\t\t\t\t\tdone_index = page->index + 1;\n\t\t\t\t\tdone = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We stop writing back only if we are not doing\n\t\t\t * integrity sync. In case of integrity sync we have to\n\t\t\t * keep going until we have written all the pages\n\t\t\t * we tagged for writeback prior to entering this loop.\n\t\t\t */\n\t\t\tif (--wbc->nr_to_write <= 0 &&\n\t\t\t    wbc->sync_mode == WB_SYNC_NONE) {\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * If we hit the last page and there is more work to be done: wrap\n\t * back the index back to the start of the file for the next\n\t * time we are called.\n\t */\n\tif (wbc->range_cyclic && !done)\n\t\tdone_index = 0;\n\tif (wbc->range_cyclic || (range_whole && wbc->nr_to_write > 0))\n\t\tmapping->writeback_index = done_index;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "tag_pages_for_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "2100-2119",
    "snippet": "void tag_pages_for_writeback(struct address_space *mapping,\n\t\t\t     pgoff_t start, pgoff_t end)\n{\n\tXA_STATE(xas, &mapping->i_pages, start);\n\tunsigned int tagged = 0;\n\tvoid *page;\n\n\txas_lock_irq(&xas);\n\txas_for_each_marked(&xas, page, end, PAGECACHE_TAG_DIRTY) {\n\t\txas_set_mark(&xas, PAGECACHE_TAG_TOWRITE);\n\t\tif (++tagged % XA_CHECK_SCHED)\n\t\t\tcontinue;\n\n\t\txas_pause(&xas);\n\t\txas_unlock_irq(&xas);\n\t\tcond_resched();\n\t\txas_lock_irq(&xas);\n\t}\n\txas_unlock_irq(&xas);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "&xas"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_pause",
          "args": [
            "&xas"
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_set_mark",
          "args": [
            "&xas",
            "PAGECACHE_TAG_TOWRITE"
          ],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_for_each_marked",
          "args": [
            "&xas",
            "page",
            "end",
            "PAGECACHE_TAG_DIRTY"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "&xas"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "start"
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid tag_pages_for_writeback(struct address_space *mapping,\n\t\t\t     pgoff_t start, pgoff_t end)\n{\n\tXA_STATE(xas, &mapping->i_pages, start);\n\tunsigned int tagged = 0;\n\tvoid *page;\n\n\txas_lock_irq(&xas);\n\txas_for_each_marked(&xas, page, end, PAGECACHE_TAG_DIRTY) {\n\t\txas_set_mark(&xas, PAGECACHE_TAG_TOWRITE);\n\t\tif (++tagged % XA_CHECK_SCHED)\n\t\t\tcontinue;\n\n\t\txas_pause(&xas);\n\t\txas_unlock_irq(&xas);\n\t\tcond_resched();\n\t\txas_lock_irq(&xas);\n\t}\n\txas_unlock_irq(&xas);\n}"
  },
  {
    "function_name": "page_writeback_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "2076-2084",
    "snippet": "void __init page_writeback_init(void)\n{\n\tBUG_ON(wb_domain_init(&global_wb_domain, GFP_KERNEL));\n\n\tcpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"mm/writeback:online\",\n\t\t\t  page_writeback_cpu_online, NULL);\n\tcpuhp_setup_state(CPUHP_MM_WRITEBACK_DEAD, \"mm/writeback:dead\", NULL,\n\t\t\t  page_writeback_cpu_online);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct wb_domain global_wb_domain;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuhp_setup_state",
          "args": [
            "CPUHP_MM_WRITEBACK_DEAD",
            "\"mm/writeback:dead\"",
            "NULL",
            "page_writeback_cpu_online"
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_setup_state",
          "args": [
            "CPUHP_AP_ONLINE_DYN",
            "\"mm/writeback:online\"",
            "page_writeback_cpu_online",
            "NULL"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "wb_domain_init(&global_wb_domain, GFP_KERNEL)"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_domain_init",
          "args": [
            "&global_wb_domain",
            "GFP_KERNEL"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "wb_domain_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "646-657",
          "snippet": "int wb_domain_init(struct wb_domain *dom, gfp_t gfp)\n{\n\tmemset(dom, 0, sizeof(*dom));\n\n\tspin_lock_init(&dom->lock);\n\n\ttimer_setup(&dom->period_timer, writeout_period, TIMER_DEFERRABLE);\n\n\tdom->dirty_limit_tstamp = jiffies;\n\n\treturn fprop_global_init(&dom->completions, gfp);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint wb_domain_init(struct wb_domain *dom, gfp_t gfp)\n{\n\tmemset(dom, 0, sizeof(*dom));\n\n\tspin_lock_init(&dom->lock);\n\n\ttimer_setup(&dom->period_timer, writeout_period, TIMER_DEFERRABLE);\n\n\tdom->dirty_limit_tstamp = jiffies;\n\n\treturn fprop_global_init(&dom->completions, gfp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct wb_domain global_wb_domain;\n\nvoid __init page_writeback_init(void)\n{\n\tBUG_ON(wb_domain_init(&global_wb_domain, GFP_KERNEL));\n\n\tcpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"mm/writeback:online\",\n\t\t\t  page_writeback_cpu_online, NULL);\n\tcpuhp_setup_state(CPUHP_MM_WRITEBACK_DEAD, \"mm/writeback:dead\", NULL,\n\t\t\t  page_writeback_cpu_online);\n}"
  },
  {
    "function_name": "page_writeback_cpu_online",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "2052-2056",
    "snippet": "static int page_writeback_cpu_online(unsigned int cpu)\n{\n\twriteback_set_ratelimit();\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeback_set_ratelimit",
          "args": [],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "writeback_set_ratelimit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2039-2050",
          "snippet": "void writeback_set_ratelimit(void)\n{\n\tstruct wb_domain *dom = &global_wb_domain;\n\tunsigned long background_thresh;\n\tunsigned long dirty_thresh;\n\n\tglobal_dirty_limits(&background_thresh, &dirty_thresh);\n\tdom->dirty_limit = dirty_thresh;\n\tratelimit_pages = dirty_thresh / (num_online_cpus() * 32);\n\tif (ratelimit_pages < 16)\n\t\tratelimit_pages = 16;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long ratelimit_pages = 32;",
            "struct wb_domain global_wb_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long ratelimit_pages = 32;\nstruct wb_domain global_wb_domain;\n\nvoid writeback_set_ratelimit(void)\n{\n\tstruct wb_domain *dom = &global_wb_domain;\n\tunsigned long background_thresh;\n\tunsigned long dirty_thresh;\n\n\tglobal_dirty_limits(&background_thresh, &dirty_thresh);\n\tdom->dirty_limit = dirty_thresh;\n\tratelimit_pages = dirty_thresh / (num_online_cpus() * 32);\n\tif (ratelimit_pages < 16)\n\t\tratelimit_pages = 16;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic int page_writeback_cpu_online(unsigned int cpu)\n{\n\twriteback_set_ratelimit();\n\treturn 0;\n}"
  },
  {
    "function_name": "writeback_set_ratelimit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "2039-2050",
    "snippet": "void writeback_set_ratelimit(void)\n{\n\tstruct wb_domain *dom = &global_wb_domain;\n\tunsigned long background_thresh;\n\tunsigned long dirty_thresh;\n\n\tglobal_dirty_limits(&background_thresh, &dirty_thresh);\n\tdom->dirty_limit = dirty_thresh;\n\tratelimit_pages = dirty_thresh / (num_online_cpus() * 32);\n\tif (ratelimit_pages < 16)\n\t\tratelimit_pages = 16;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long ratelimit_pages = 32;",
      "struct wb_domain global_wb_domain;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_dirty_limits",
          "args": [
            "&background_thresh",
            "&dirty_thresh"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "global_dirty_limits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "458-467",
          "snippet": "void global_dirty_limits(unsigned long *pbackground, unsigned long *pdirty)\n{\n\tstruct dirty_throttle_control gdtc = { GDTC_INIT_NO_WB };\n\n\tgdtc.avail = global_dirtyable_memory();\n\tdomain_dirty_limits(&gdtc);\n\n\t*pbackground = gdtc.bg_thresh;\n\t*pdirty = gdtc.thresh;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define GDTC_INIT_NO_WB",
            "#define GDTC_INIT_NO_WB\t\t.dom = &global_wb_domain"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define GDTC_INIT_NO_WB\n#define GDTC_INIT_NO_WB\t\t.dom = &global_wb_domain\n\nvoid global_dirty_limits(unsigned long *pbackground, unsigned long *pdirty)\n{\n\tstruct dirty_throttle_control gdtc = { GDTC_INIT_NO_WB };\n\n\tgdtc.avail = global_dirtyable_memory();\n\tdomain_dirty_limits(&gdtc);\n\n\t*pbackground = gdtc.bg_thresh;\n\t*pdirty = gdtc.thresh;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long ratelimit_pages = 32;\nstruct wb_domain global_wb_domain;\n\nvoid writeback_set_ratelimit(void)\n{\n\tstruct wb_domain *dom = &global_wb_domain;\n\tunsigned long background_thresh;\n\tunsigned long dirty_thresh;\n\n\tglobal_dirty_limits(&background_thresh, &dirty_thresh);\n\tdom->dirty_limit = dirty_thresh;\n\tratelimit_pages = dirty_thresh / (num_online_cpus() * 32);\n\tif (ratelimit_pages < 16)\n\t\tratelimit_pages = 16;\n}"
  },
  {
    "function_name": "laptop_sync_completion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "2015-2025",
    "snippet": "void laptop_sync_completion(void)\n{\n\tstruct backing_dev_info *bdi;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(bdi, &bdi_list, bdi_list)\n\t\tdel_timer(&bdi->laptop_mode_wb_timer);\n\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_timer",
          "args": [
            "&bdi->laptop_mode_wb_timer"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "bdi",
            "&bdi_list",
            "bdi_list"
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid laptop_sync_completion(void)\n{\n\tstruct backing_dev_info *bdi;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(bdi, &bdi_list, bdi_list)\n\t\tdel_timer(&bdi->laptop_mode_wb_timer);\n\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "laptop_io_completion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "2005-2008",
    "snippet": "void laptop_io_completion(struct backing_dev_info *info)\n{\n\tmod_timer(&info->laptop_mode_wb_timer, jiffies + laptop_mode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int laptop_mode;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&info->laptop_mode_wb_timer",
            "jiffies + laptop_mode"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint laptop_mode;\n\nvoid laptop_io_completion(struct backing_dev_info *info)\n{\n\tmod_timer(&info->laptop_mode_wb_timer, jiffies + laptop_mode);\n}"
  },
  {
    "function_name": "laptop_mode_timer_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "1992-1998",
    "snippet": "void laptop_mode_timer_fn(struct timer_list *t)\n{\n\tstruct backing_dev_info *backing_dev_info =\n\t\tfrom_timer(backing_dev_info, t, laptop_mode_wb_timer);\n\n\twakeup_flusher_threads_bdi(backing_dev_info, WB_REASON_LAPTOP_TIMER);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup_flusher_threads_bdi",
          "args": [
            "backing_dev_info",
            "WB_REASON_LAPTOP_TIMER"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_timer",
          "args": [
            "backing_dev_info",
            "t",
            "laptop_mode_wb_timer"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid laptop_mode_timer_fn(struct timer_list *t)\n{\n\tstruct backing_dev_info *backing_dev_info =\n\t\tfrom_timer(backing_dev_info, t, laptop_mode_wb_timer);\n\n\twakeup_flusher_threads_bdi(backing_dev_info, WB_REASON_LAPTOP_TIMER);\n}"
  },
  {
    "function_name": "dirty_writeback_centisecs_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "1969-1989",
    "snippet": "int dirty_writeback_centisecs_handler(struct ctl_table *table, int write,\n\tvoid __user *buffer, size_t *length, loff_t *ppos)\n{\n\tunsigned int old_interval = dirty_writeback_interval;\n\tint ret;\n\n\tret = proc_dointvec(table, write, buffer, length, ppos);\n\n\t/*\n\t * Writing 0 to dirty_writeback_interval will disable periodic writeback\n\t * and a different non-zero value will wakeup the writeback threads.\n\t * wb_wakeup_delayed() would be more appropriate, but it's a pain to\n\t * iterate over all bdis and wbs.\n\t * The reason we do this is to make the change take effect immediately.\n\t */\n\tif (!ret && write && dirty_writeback_interval &&\n\t\tdirty_writeback_interval != old_interval)\n\t\twakeup_flusher_threads(WB_REASON_PERIODIC);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int dirty_writeback_interval = 5 * 100;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup_flusher_threads",
          "args": [
            "WB_REASON_PERIODIC"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_dointvec",
          "args": [
            "table",
            "write",
            "buffer",
            "length",
            "ppos"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nunsigned int dirty_writeback_interval = 5 * 100;\n\nint dirty_writeback_centisecs_handler(struct ctl_table *table, int write,\n\tvoid __user *buffer, size_t *length, loff_t *ppos)\n{\n\tunsigned int old_interval = dirty_writeback_interval;\n\tint ret;\n\n\tret = proc_dointvec(table, write, buffer, length, ppos);\n\n\t/*\n\t * Writing 0 to dirty_writeback_interval will disable periodic writeback\n\t * and a different non-zero value will wakeup the writeback threads.\n\t * wb_wakeup_delayed() would be more appropriate, but it's a pain to\n\t * iterate over all bdis and wbs.\n\t * The reason we do this is to make the change take effect immediately.\n\t */\n\tif (!ret && write && dirty_writeback_interval &&\n\t\tdirty_writeback_interval != old_interval)\n\t\twakeup_flusher_threads(WB_REASON_PERIODIC);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "wb_over_bg_thresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "1923-1964",
    "snippet": "bool wb_over_bg_thresh(struct bdi_writeback *wb)\n{\n\tstruct dirty_throttle_control gdtc_stor = { GDTC_INIT(wb) };\n\tstruct dirty_throttle_control mdtc_stor = { MDTC_INIT(wb, &gdtc_stor) };\n\tstruct dirty_throttle_control * const gdtc = &gdtc_stor;\n\tstruct dirty_throttle_control * const mdtc = mdtc_valid(&mdtc_stor) ?\n\t\t\t\t\t\t     &mdtc_stor : NULL;\n\n\t/*\n\t * Similar to balance_dirty_pages() but ignores pages being written\n\t * as we're trying to decide whether to put more under writeback.\n\t */\n\tgdtc->avail = global_dirtyable_memory();\n\tgdtc->dirty = global_node_page_state(NR_FILE_DIRTY) +\n\t\t      global_node_page_state(NR_UNSTABLE_NFS);\n\tdomain_dirty_limits(gdtc);\n\n\tif (gdtc->dirty > gdtc->bg_thresh)\n\t\treturn true;\n\n\tif (wb_stat(wb, WB_RECLAIMABLE) >\n\t    wb_calc_thresh(gdtc->wb, gdtc->bg_thresh))\n\t\treturn true;\n\n\tif (mdtc) {\n\t\tunsigned long filepages, headroom, writeback;\n\n\t\tmem_cgroup_wb_stats(wb, &filepages, &headroom, &mdtc->dirty,\n\t\t\t\t    &writeback);\n\t\tmdtc_calc_avail(mdtc, filepages, headroom);\n\t\tdomain_dirty_limits(mdtc);\t/* ditto, ignore writeback */\n\n\t\tif (mdtc->dirty > mdtc->bg_thresh)\n\t\t\treturn true;\n\n\t\tif (wb_stat(wb, WB_RECLAIMABLE) >\n\t\t    wb_calc_thresh(mdtc->wb, mdtc->bg_thresh))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wb_calc_thresh",
          "args": [
            "mdtc->wb",
            "mdtc->bg_thresh"
          ],
          "line": 1959
        },
        "resolved": true,
        "details": {
          "function_name": "wb_calc_thresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "790-795",
          "snippet": "unsigned long wb_calc_thresh(struct bdi_writeback *wb, unsigned long thresh)\n{\n\tstruct dirty_throttle_control gdtc = { GDTC_INIT(wb),\n\t\t\t\t\t       .thresh = thresh };\n\treturn __wb_calc_thresh(&gdtc);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nunsigned long wb_calc_thresh(struct bdi_writeback *wb, unsigned long thresh)\n{\n\tstruct dirty_throttle_control gdtc = { GDTC_INIT(wb),\n\t\t\t\t\t       .thresh = thresh };\n\treturn __wb_calc_thresh(&gdtc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_stat",
          "args": [
            "wb",
            "WB_RECLAIMABLE"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain_dirty_limits",
          "args": [
            "mdtc"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "domain_dirty_limits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "392-448",
          "snippet": "static void domain_dirty_limits(struct dirty_throttle_control *dtc)\n{\n\tconst unsigned long available_memory = dtc->avail;\n\tstruct dirty_throttle_control *gdtc = mdtc_gdtc(dtc);\n\tunsigned long bytes = vm_dirty_bytes;\n\tunsigned long bg_bytes = dirty_background_bytes;\n\t/* convert ratios to per-PAGE_SIZE for higher precision */\n\tunsigned long ratio = (vm_dirty_ratio * PAGE_SIZE) / 100;\n\tunsigned long bg_ratio = (dirty_background_ratio * PAGE_SIZE) / 100;\n\tunsigned long thresh;\n\tunsigned long bg_thresh;\n\tstruct task_struct *tsk;\n\n\t/* gdtc is !NULL iff @dtc is for memcg domain */\n\tif (gdtc) {\n\t\tunsigned long global_avail = gdtc->avail;\n\n\t\t/*\n\t\t * The byte settings can't be applied directly to memcg\n\t\t * domains.  Convert them to ratios by scaling against\n\t\t * globally available memory.  As the ratios are in\n\t\t * per-PAGE_SIZE, they can be obtained by dividing bytes by\n\t\t * number of pages.\n\t\t */\n\t\tif (bytes)\n\t\t\tratio = min(DIV_ROUND_UP(bytes, global_avail),\n\t\t\t\t    PAGE_SIZE);\n\t\tif (bg_bytes)\n\t\t\tbg_ratio = min(DIV_ROUND_UP(bg_bytes, global_avail),\n\t\t\t\t       PAGE_SIZE);\n\t\tbytes = bg_bytes = 0;\n\t}\n\n\tif (bytes)\n\t\tthresh = DIV_ROUND_UP(bytes, PAGE_SIZE);\n\telse\n\t\tthresh = (ratio * available_memory) / PAGE_SIZE;\n\n\tif (bg_bytes)\n\t\tbg_thresh = DIV_ROUND_UP(bg_bytes, PAGE_SIZE);\n\telse\n\t\tbg_thresh = (bg_ratio * available_memory) / PAGE_SIZE;\n\n\tif (bg_thresh >= thresh)\n\t\tbg_thresh = thresh / 2;\n\ttsk = current;\n\tif (tsk->flags & PF_LESS_THROTTLE || rt_task(tsk)) {\n\t\tbg_thresh += bg_thresh / 4 + global_wb_domain.dirty_limit / 32;\n\t\tthresh += thresh / 4 + global_wb_domain.dirty_limit / 32;\n\t}\n\tdtc->thresh = thresh;\n\tdtc->bg_thresh = bg_thresh;\n\n\t/* we should eventually report the domain in the TP */\n\tif (!gdtc)\n\t\ttrace_global_dirty_state(bg_thresh, thresh);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int dirty_background_ratio = 10;",
            "unsigned long dirty_background_bytes;",
            "int vm_dirty_ratio = 20;",
            "unsigned long vm_dirty_bytes;",
            "struct wb_domain global_wb_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint dirty_background_ratio = 10;\nunsigned long dirty_background_bytes;\nint vm_dirty_ratio = 20;\nunsigned long vm_dirty_bytes;\nstruct wb_domain global_wb_domain;\n\nstatic void domain_dirty_limits(struct dirty_throttle_control *dtc)\n{\n\tconst unsigned long available_memory = dtc->avail;\n\tstruct dirty_throttle_control *gdtc = mdtc_gdtc(dtc);\n\tunsigned long bytes = vm_dirty_bytes;\n\tunsigned long bg_bytes = dirty_background_bytes;\n\t/* convert ratios to per-PAGE_SIZE for higher precision */\n\tunsigned long ratio = (vm_dirty_ratio * PAGE_SIZE) / 100;\n\tunsigned long bg_ratio = (dirty_background_ratio * PAGE_SIZE) / 100;\n\tunsigned long thresh;\n\tunsigned long bg_thresh;\n\tstruct task_struct *tsk;\n\n\t/* gdtc is !NULL iff @dtc is for memcg domain */\n\tif (gdtc) {\n\t\tunsigned long global_avail = gdtc->avail;\n\n\t\t/*\n\t\t * The byte settings can't be applied directly to memcg\n\t\t * domains.  Convert them to ratios by scaling against\n\t\t * globally available memory.  As the ratios are in\n\t\t * per-PAGE_SIZE, they can be obtained by dividing bytes by\n\t\t * number of pages.\n\t\t */\n\t\tif (bytes)\n\t\t\tratio = min(DIV_ROUND_UP(bytes, global_avail),\n\t\t\t\t    PAGE_SIZE);\n\t\tif (bg_bytes)\n\t\t\tbg_ratio = min(DIV_ROUND_UP(bg_bytes, global_avail),\n\t\t\t\t       PAGE_SIZE);\n\t\tbytes = bg_bytes = 0;\n\t}\n\n\tif (bytes)\n\t\tthresh = DIV_ROUND_UP(bytes, PAGE_SIZE);\n\telse\n\t\tthresh = (ratio * available_memory) / PAGE_SIZE;\n\n\tif (bg_bytes)\n\t\tbg_thresh = DIV_ROUND_UP(bg_bytes, PAGE_SIZE);\n\telse\n\t\tbg_thresh = (bg_ratio * available_memory) / PAGE_SIZE;\n\n\tif (bg_thresh >= thresh)\n\t\tbg_thresh = thresh / 2;\n\ttsk = current;\n\tif (tsk->flags & PF_LESS_THROTTLE || rt_task(tsk)) {\n\t\tbg_thresh += bg_thresh / 4 + global_wb_domain.dirty_limit / 32;\n\t\tthresh += thresh / 4 + global_wb_domain.dirty_limit / 32;\n\t}\n\tdtc->thresh = thresh;\n\tdtc->bg_thresh = bg_thresh;\n\n\t/* we should eventually report the domain in the TP */\n\tif (!gdtc)\n\t\ttrace_global_dirty_state(bg_thresh, thresh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mdtc_calc_avail",
          "args": [
            "mdtc",
            "filepages",
            "headroom"
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "mdtc_calc_avail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "731-740",
          "snippet": "static void mdtc_calc_avail(struct dirty_throttle_control *mdtc,\n\t\t\t    unsigned long filepages, unsigned long headroom)\n{\n\tstruct dirty_throttle_control *gdtc = mdtc_gdtc(mdtc);\n\tunsigned long clean = filepages - min(filepages, mdtc->dirty);\n\tunsigned long global_clean = gdtc->avail - min(gdtc->avail, gdtc->dirty);\n\tunsigned long other_clean = global_clean - min(global_clean, clean);\n\n\tmdtc->avail = filepages + min(headroom, other_clean);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void mdtc_calc_avail(struct dirty_throttle_control *mdtc,\n\t\t\t    unsigned long filepages, unsigned long headroom)\n{\n\tstruct dirty_throttle_control *gdtc = mdtc_gdtc(mdtc);\n\tunsigned long clean = filepages - min(filepages, mdtc->dirty);\n\tunsigned long global_clean = gdtc->avail - min(gdtc->avail, gdtc->dirty);\n\tunsigned long other_clean = global_clean - min(global_clean, clean);\n\n\tmdtc->avail = filepages + min(headroom, other_clean);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_wb_stats",
          "args": [
            "wb",
            "&filepages",
            "&headroom",
            "&mdtc->dirty",
            "&writeback"
          ],
          "line": 1950
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_wb_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3871-3893",
          "snippet": "void mem_cgroup_wb_stats(struct bdi_writeback *wb, unsigned long *pfilepages,\n\t\t\t unsigned long *pheadroom, unsigned long *pdirty,\n\t\t\t unsigned long *pwriteback)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(wb->memcg_css);\n\tstruct mem_cgroup *parent;\n\n\t*pdirty = memcg_page_state(memcg, NR_FILE_DIRTY);\n\n\t/* this should eventually include NR_UNSTABLE_NFS */\n\t*pwriteback = memcg_page_state(memcg, NR_WRITEBACK);\n\t*pfilepages = mem_cgroup_nr_lru_pages(memcg, (1 << LRU_INACTIVE_FILE) |\n\t\t\t\t\t\t     (1 << LRU_ACTIVE_FILE));\n\t*pheadroom = PAGE_COUNTER_MAX;\n\n\twhile ((parent = parent_mem_cgroup(memcg))) {\n\t\tunsigned long ceiling = min(memcg->memory.max, memcg->high);\n\t\tunsigned long used = page_counter_read(&memcg->memory);\n\n\t\t*pheadroom = min(*pheadroom, ceiling - min(ceiling, used));\n\t\tmemcg = parent;\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_wb_stats(struct bdi_writeback *wb, unsigned long *pfilepages,\n\t\t\t unsigned long *pheadroom, unsigned long *pdirty,\n\t\t\t unsigned long *pwriteback)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(wb->memcg_css);\n\tstruct mem_cgroup *parent;\n\n\t*pdirty = memcg_page_state(memcg, NR_FILE_DIRTY);\n\n\t/* this should eventually include NR_UNSTABLE_NFS */\n\t*pwriteback = memcg_page_state(memcg, NR_WRITEBACK);\n\t*pfilepages = mem_cgroup_nr_lru_pages(memcg, (1 << LRU_INACTIVE_FILE) |\n\t\t\t\t\t\t     (1 << LRU_ACTIVE_FILE));\n\t*pheadroom = PAGE_COUNTER_MAX;\n\n\twhile ((parent = parent_mem_cgroup(memcg))) {\n\t\tunsigned long ceiling = min(memcg->memory.max, memcg->high);\n\t\tunsigned long used = page_counter_read(&memcg->memory);\n\n\t\t*pheadroom = min(*pheadroom, ceiling - min(ceiling, used));\n\t\tmemcg = parent;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_stat",
          "args": [
            "wb",
            "WB_RECLAIMABLE"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_UNSTABLE_NFS"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_FILE_DIRTY"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_dirtyable_memory",
          "args": [],
          "line": 1935
        },
        "resolved": true,
        "details": {
          "function_name": "global_dirtyable_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "361-380",
          "snippet": "static unsigned long global_dirtyable_memory(void)\n{\n\tunsigned long x;\n\n\tx = global_zone_page_state(NR_FREE_PAGES);\n\t/*\n\t * Pages reserved for the kernel should not be considered\n\t * dirtyable, to prevent a situation where reclaim has to\n\t * clean pages in order to balance the zones.\n\t */\n\tx -= min(x, totalreserve_pages);\n\n\tx += global_node_page_state(NR_INACTIVE_FILE);\n\tx += global_node_page_state(NR_ACTIVE_FILE);\n\n\tif (!vm_highmem_is_dirtyable)\n\t\tx -= highmem_dirtyable_memory(x);\n\n\treturn x + 1;\t/* Ensure that we never return 0 */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int vm_highmem_is_dirtyable;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint vm_highmem_is_dirtyable;\n\nstatic unsigned long global_dirtyable_memory(void)\n{\n\tunsigned long x;\n\n\tx = global_zone_page_state(NR_FREE_PAGES);\n\t/*\n\t * Pages reserved for the kernel should not be considered\n\t * dirtyable, to prevent a situation where reclaim has to\n\t * clean pages in order to balance the zones.\n\t */\n\tx -= min(x, totalreserve_pages);\n\n\tx += global_node_page_state(NR_INACTIVE_FILE);\n\tx += global_node_page_state(NR_ACTIVE_FILE);\n\n\tif (!vm_highmem_is_dirtyable)\n\t\tx -= highmem_dirtyable_memory(x);\n\n\treturn x + 1;\t/* Ensure that we never return 0 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mdtc_valid",
          "args": [
            "&mdtc_stor"
          ],
          "line": 1928
        },
        "resolved": true,
        "details": {
          "function_name": "mdtc_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "222-225",
          "snippet": "static bool mdtc_valid(struct dirty_throttle_control *dtc)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic bool mdtc_valid(struct dirty_throttle_control *dtc)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MDTC_INIT",
          "args": [
            "wb",
            "&gdtc_stor"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDTC_INIT",
          "args": [
            "wb"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nbool wb_over_bg_thresh(struct bdi_writeback *wb)\n{\n\tstruct dirty_throttle_control gdtc_stor = { GDTC_INIT(wb) };\n\tstruct dirty_throttle_control mdtc_stor = { MDTC_INIT(wb, &gdtc_stor) };\n\tstruct dirty_throttle_control * const gdtc = &gdtc_stor;\n\tstruct dirty_throttle_control * const mdtc = mdtc_valid(&mdtc_stor) ?\n\t\t\t\t\t\t     &mdtc_stor : NULL;\n\n\t/*\n\t * Similar to balance_dirty_pages() but ignores pages being written\n\t * as we're trying to decide whether to put more under writeback.\n\t */\n\tgdtc->avail = global_dirtyable_memory();\n\tgdtc->dirty = global_node_page_state(NR_FILE_DIRTY) +\n\t\t      global_node_page_state(NR_UNSTABLE_NFS);\n\tdomain_dirty_limits(gdtc);\n\n\tif (gdtc->dirty > gdtc->bg_thresh)\n\t\treturn true;\n\n\tif (wb_stat(wb, WB_RECLAIMABLE) >\n\t    wb_calc_thresh(gdtc->wb, gdtc->bg_thresh))\n\t\treturn true;\n\n\tif (mdtc) {\n\t\tunsigned long filepages, headroom, writeback;\n\n\t\tmem_cgroup_wb_stats(wb, &filepages, &headroom, &mdtc->dirty,\n\t\t\t\t    &writeback);\n\t\tmdtc_calc_avail(mdtc, filepages, headroom);\n\t\tdomain_dirty_limits(mdtc);\t/* ditto, ignore writeback */\n\n\t\tif (mdtc->dirty > mdtc->bg_thresh)\n\t\t\treturn true;\n\n\t\tif (wb_stat(wb, WB_RECLAIMABLE) >\n\t\t    wb_calc_thresh(mdtc->wb, mdtc->bg_thresh))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "balance_dirty_pages_ratelimited",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "1861-1913",
    "snippet": "void balance_dirty_pages_ratelimited(struct address_space *mapping)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\tstruct bdi_writeback *wb = NULL;\n\tint ratelimit;\n\tint *p;\n\n\tif (!bdi_cap_account_dirty(bdi))\n\t\treturn;\n\n\tif (inode_cgwb_enabled(inode))\n\t\twb = wb_get_create_current(bdi, GFP_KERNEL);\n\tif (!wb)\n\t\twb = &bdi->wb;\n\n\tratelimit = current->nr_dirtied_pause;\n\tif (wb->dirty_exceeded)\n\t\tratelimit = min(ratelimit, 32 >> (PAGE_SHIFT - 10));\n\n\tpreempt_disable();\n\t/*\n\t * This prevents one CPU to accumulate too many dirtied pages without\n\t * calling into balance_dirty_pages(), which can happen when there are\n\t * 1000+ tasks, all of them start dirtying pages at exactly the same\n\t * time, hence all honoured too large initial task->nr_dirtied_pause.\n\t */\n\tp =  this_cpu_ptr(&bdp_ratelimits);\n\tif (unlikely(current->nr_dirtied >= ratelimit))\n\t\t*p = 0;\n\telse if (unlikely(*p >= ratelimit_pages)) {\n\t\t*p = 0;\n\t\tratelimit = 0;\n\t}\n\t/*\n\t * Pick up the dirtied pages by the exited tasks. This avoids lots of\n\t * short-lived tasks (eg. gcc invocations in a kernel build) escaping\n\t * the dirty throttling and livelock other long-run dirtiers.\n\t */\n\tp = this_cpu_ptr(&dirty_throttle_leaks);\n\tif (*p > 0 && current->nr_dirtied < ratelimit) {\n\t\tunsigned long nr_pages_dirtied;\n\t\tnr_pages_dirtied = min(*p, ratelimit - current->nr_dirtied);\n\t\t*p -= nr_pages_dirtied;\n\t\tcurrent->nr_dirtied += nr_pages_dirtied;\n\t}\n\tpreempt_enable();\n\n\tif (unlikely(current->nr_dirtied >= ratelimit))\n\t\tbalance_dirty_pages(wb, current->nr_dirtied);\n\n\twb_put(wb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long ratelimit_pages = 32;",
      "static DEFINE_PER_CPU(int, bdp_ratelimits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wb_put",
          "args": [
            "wb"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balance_dirty_pages",
          "args": [
            "wb",
            "current->nr_dirtied"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "balance_dirty_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1560-1828",
          "snippet": "static void balance_dirty_pages(struct bdi_writeback *wb,\n\t\t\t\tunsigned long pages_dirtied)\n{\n\tstruct dirty_throttle_control gdtc_stor = { GDTC_INIT(wb) };\n\tstruct dirty_throttle_control mdtc_stor = { MDTC_INIT(wb, &gdtc_stor) };\n\tstruct dirty_throttle_control * const gdtc = &gdtc_stor;\n\tstruct dirty_throttle_control * const mdtc = mdtc_valid(&mdtc_stor) ?\n\t\t\t\t\t\t     &mdtc_stor : NULL;\n\tstruct dirty_throttle_control *sdtc;\n\tunsigned long nr_reclaimable;\t/* = file_dirty + unstable_nfs */\n\tlong period;\n\tlong pause;\n\tlong max_pause;\n\tlong min_pause;\n\tint nr_dirtied_pause;\n\tbool dirty_exceeded = false;\n\tunsigned long task_ratelimit;\n\tunsigned long dirty_ratelimit;\n\tstruct backing_dev_info *bdi = wb->bdi;\n\tbool strictlimit = bdi->capabilities & BDI_CAP_STRICTLIMIT;\n\tunsigned long start_time = jiffies;\n\n\tfor (;;) {\n\t\tunsigned long now = jiffies;\n\t\tunsigned long dirty, thresh, bg_thresh;\n\t\tunsigned long m_dirty = 0;\t/* stop bogus uninit warnings */\n\t\tunsigned long m_thresh = 0;\n\t\tunsigned long m_bg_thresh = 0;\n\n\t\t/*\n\t\t * Unstable writes are a feature of certain networked\n\t\t * filesystems (i.e. NFS) in which data may have been\n\t\t * written to the server's write cache, but has not yet\n\t\t * been flushed to permanent storage.\n\t\t */\n\t\tnr_reclaimable = global_node_page_state(NR_FILE_DIRTY) +\n\t\t\t\t\tglobal_node_page_state(NR_UNSTABLE_NFS);\n\t\tgdtc->avail = global_dirtyable_memory();\n\t\tgdtc->dirty = nr_reclaimable + global_node_page_state(NR_WRITEBACK);\n\n\t\tdomain_dirty_limits(gdtc);\n\n\t\tif (unlikely(strictlimit)) {\n\t\t\twb_dirty_limits(gdtc);\n\n\t\t\tdirty = gdtc->wb_dirty;\n\t\t\tthresh = gdtc->wb_thresh;\n\t\t\tbg_thresh = gdtc->wb_bg_thresh;\n\t\t} else {\n\t\t\tdirty = gdtc->dirty;\n\t\t\tthresh = gdtc->thresh;\n\t\t\tbg_thresh = gdtc->bg_thresh;\n\t\t}\n\n\t\tif (mdtc) {\n\t\t\tunsigned long filepages, headroom, writeback;\n\n\t\t\t/*\n\t\t\t * If @wb belongs to !root memcg, repeat the same\n\t\t\t * basic calculations for the memcg domain.\n\t\t\t */\n\t\t\tmem_cgroup_wb_stats(wb, &filepages, &headroom,\n\t\t\t\t\t    &mdtc->dirty, &writeback);\n\t\t\tmdtc->dirty += writeback;\n\t\t\tmdtc_calc_avail(mdtc, filepages, headroom);\n\n\t\t\tdomain_dirty_limits(mdtc);\n\n\t\t\tif (unlikely(strictlimit)) {\n\t\t\t\twb_dirty_limits(mdtc);\n\t\t\t\tm_dirty = mdtc->wb_dirty;\n\t\t\t\tm_thresh = mdtc->wb_thresh;\n\t\t\t\tm_bg_thresh = mdtc->wb_bg_thresh;\n\t\t\t} else {\n\t\t\t\tm_dirty = mdtc->dirty;\n\t\t\t\tm_thresh = mdtc->thresh;\n\t\t\t\tm_bg_thresh = mdtc->bg_thresh;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Throttle it only when the background writeback cannot\n\t\t * catch-up. This avoids (excessively) small writeouts\n\t\t * when the wb limits are ramping up in case of !strictlimit.\n\t\t *\n\t\t * In strictlimit case make decision based on the wb counters\n\t\t * and limits. Small writeouts when the wb limits are ramping\n\t\t * up are the price we consciously pay for strictlimit-ing.\n\t\t *\n\t\t * If memcg domain is in effect, @dirty should be under\n\t\t * both global and memcg freerun ceilings.\n\t\t */\n\t\tif (dirty <= dirty_freerun_ceiling(thresh, bg_thresh) &&\n\t\t    (!mdtc ||\n\t\t     m_dirty <= dirty_freerun_ceiling(m_thresh, m_bg_thresh))) {\n\t\t\tunsigned long intv = dirty_poll_interval(dirty, thresh);\n\t\t\tunsigned long m_intv = ULONG_MAX;\n\n\t\t\tcurrent->dirty_paused_when = now;\n\t\t\tcurrent->nr_dirtied = 0;\n\t\t\tif (mdtc)\n\t\t\t\tm_intv = dirty_poll_interval(m_dirty, m_thresh);\n\t\t\tcurrent->nr_dirtied_pause = min(intv, m_intv);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(!writeback_in_progress(wb)))\n\t\t\twb_start_background_writeback(wb);\n\n\t\t/*\n\t\t * Calculate global domain's pos_ratio and select the\n\t\t * global dtc by default.\n\t\t */\n\t\tif (!strictlimit)\n\t\t\twb_dirty_limits(gdtc);\n\n\t\tdirty_exceeded = (gdtc->wb_dirty > gdtc->wb_thresh) &&\n\t\t\t((gdtc->dirty > gdtc->thresh) || strictlimit);\n\n\t\twb_position_ratio(gdtc);\n\t\tsdtc = gdtc;\n\n\t\tif (mdtc) {\n\t\t\t/*\n\t\t\t * If memcg domain is in effect, calculate its\n\t\t\t * pos_ratio.  @wb should satisfy constraints from\n\t\t\t * both global and memcg domains.  Choose the one\n\t\t\t * w/ lower pos_ratio.\n\t\t\t */\n\t\t\tif (!strictlimit)\n\t\t\t\twb_dirty_limits(mdtc);\n\n\t\t\tdirty_exceeded |= (mdtc->wb_dirty > mdtc->wb_thresh) &&\n\t\t\t\t((mdtc->dirty > mdtc->thresh) || strictlimit);\n\n\t\t\twb_position_ratio(mdtc);\n\t\t\tif (mdtc->pos_ratio < gdtc->pos_ratio)\n\t\t\t\tsdtc = mdtc;\n\t\t}\n\n\t\tif (dirty_exceeded && !wb->dirty_exceeded)\n\t\t\twb->dirty_exceeded = 1;\n\n\t\tif (time_is_before_jiffies(wb->bw_time_stamp +\n\t\t\t\t\t   BANDWIDTH_INTERVAL)) {\n\t\t\tspin_lock(&wb->list_lock);\n\t\t\t__wb_update_bandwidth(gdtc, mdtc, start_time, true);\n\t\t\tspin_unlock(&wb->list_lock);\n\t\t}\n\n\t\t/* throttle according to the chosen dtc */\n\t\tdirty_ratelimit = wb->dirty_ratelimit;\n\t\ttask_ratelimit = ((u64)dirty_ratelimit * sdtc->pos_ratio) >>\n\t\t\t\t\t\t\tRATELIMIT_CALC_SHIFT;\n\t\tmax_pause = wb_max_pause(wb, sdtc->wb_dirty);\n\t\tmin_pause = wb_min_pause(wb, max_pause,\n\t\t\t\t\t task_ratelimit, dirty_ratelimit,\n\t\t\t\t\t &nr_dirtied_pause);\n\n\t\tif (unlikely(task_ratelimit == 0)) {\n\t\t\tperiod = max_pause;\n\t\t\tpause = max_pause;\n\t\t\tgoto pause;\n\t\t}\n\t\tperiod = HZ * pages_dirtied / task_ratelimit;\n\t\tpause = period;\n\t\tif (current->dirty_paused_when)\n\t\t\tpause -= now - current->dirty_paused_when;\n\t\t/*\n\t\t * For less than 1s think time (ext3/4 may block the dirtier\n\t\t * for up to 800ms from time to time on 1-HDD; so does xfs,\n\t\t * however at much less frequency), try to compensate it in\n\t\t * future periods by updating the virtual time; otherwise just\n\t\t * do a reset, as it may be a light dirtier.\n\t\t */\n\t\tif (pause < min_pause) {\n\t\t\ttrace_balance_dirty_pages(wb,\n\t\t\t\t\t\t  sdtc->thresh,\n\t\t\t\t\t\t  sdtc->bg_thresh,\n\t\t\t\t\t\t  sdtc->dirty,\n\t\t\t\t\t\t  sdtc->wb_thresh,\n\t\t\t\t\t\t  sdtc->wb_dirty,\n\t\t\t\t\t\t  dirty_ratelimit,\n\t\t\t\t\t\t  task_ratelimit,\n\t\t\t\t\t\t  pages_dirtied,\n\t\t\t\t\t\t  period,\n\t\t\t\t\t\t  min(pause, 0L),\n\t\t\t\t\t\t  start_time);\n\t\t\tif (pause < -HZ) {\n\t\t\t\tcurrent->dirty_paused_when = now;\n\t\t\t\tcurrent->nr_dirtied = 0;\n\t\t\t} else if (period) {\n\t\t\t\tcurrent->dirty_paused_when += period;\n\t\t\t\tcurrent->nr_dirtied = 0;\n\t\t\t} else if (current->nr_dirtied_pause <= pages_dirtied)\n\t\t\t\tcurrent->nr_dirtied_pause += pages_dirtied;\n\t\t\tbreak;\n\t\t}\n\t\tif (unlikely(pause > max_pause)) {\n\t\t\t/* for occasional dropped task_ratelimit */\n\t\t\tnow += min(pause - max_pause, max_pause);\n\t\t\tpause = max_pause;\n\t\t}\n\npause:\n\t\ttrace_balance_dirty_pages(wb,\n\t\t\t\t\t  sdtc->thresh,\n\t\t\t\t\t  sdtc->bg_thresh,\n\t\t\t\t\t  sdtc->dirty,\n\t\t\t\t\t  sdtc->wb_thresh,\n\t\t\t\t\t  sdtc->wb_dirty,\n\t\t\t\t\t  dirty_ratelimit,\n\t\t\t\t\t  task_ratelimit,\n\t\t\t\t\t  pages_dirtied,\n\t\t\t\t\t  period,\n\t\t\t\t\t  pause,\n\t\t\t\t\t  start_time);\n\t\t__set_current_state(TASK_KILLABLE);\n\t\twb->dirty_sleep = now;\n\t\tio_schedule_timeout(pause);\n\n\t\tcurrent->dirty_paused_when = now + pause;\n\t\tcurrent->nr_dirtied = 0;\n\t\tcurrent->nr_dirtied_pause = nr_dirtied_pause;\n\n\t\t/*\n\t\t * This is typically equal to (dirty < thresh) and can also\n\t\t * keep \"1000+ dd on a slow USB stick\" under control.\n\t\t */\n\t\tif (task_ratelimit)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * In the case of an unresponding NFS server and the NFS dirty\n\t\t * pages exceeds dirty_thresh, give the other good wb's a pipe\n\t\t * to go through, so that tasks on them still remain responsive.\n\t\t *\n\t\t * In theory 1 page is enough to keep the consumer-producer\n\t\t * pipe going: the flusher cleans 1 page => the task dirties 1\n\t\t * more page. However wb_dirty has accounting errors.  So use\n\t\t * the larger and more IO friendly wb_stat_error.\n\t\t */\n\t\tif (sdtc->wb_dirty <= wb_stat_error())\n\t\t\tbreak;\n\n\t\tif (fatal_signal_pending(current))\n\t\t\tbreak;\n\t}\n\n\tif (!dirty_exceeded && wb->dirty_exceeded)\n\t\twb->dirty_exceeded = 0;\n\n\tif (writeback_in_progress(wb))\n\t\treturn;\n\n\t/*\n\t * In laptop mode, we wait until hitting the higher threshold before\n\t * starting background writeout, and then write out all the way down\n\t * to the lower threshold.  So slow writers cause minimal disk activity.\n\t *\n\t * In normal mode, we start background writeout at the lower\n\t * background_thresh, to keep the amount of dirty memory low.\n\t */\n\tif (laptop_mode)\n\t\treturn;\n\n\tif (nr_reclaimable > gdtc->bg_thresh)\n\t\twb_start_background_writeback(wb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define RATELIMIT_CALC_SHIFT\t10",
            "#define BANDWIDTH_INTERVAL\tmax(HZ/5, 1)"
          ],
          "globals_used": [
            "int laptop_mode;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define RATELIMIT_CALC_SHIFT\t10\n#define BANDWIDTH_INTERVAL\tmax(HZ/5, 1)\n\nint laptop_mode;\n\nstatic void balance_dirty_pages(struct bdi_writeback *wb,\n\t\t\t\tunsigned long pages_dirtied)\n{\n\tstruct dirty_throttle_control gdtc_stor = { GDTC_INIT(wb) };\n\tstruct dirty_throttle_control mdtc_stor = { MDTC_INIT(wb, &gdtc_stor) };\n\tstruct dirty_throttle_control * const gdtc = &gdtc_stor;\n\tstruct dirty_throttle_control * const mdtc = mdtc_valid(&mdtc_stor) ?\n\t\t\t\t\t\t     &mdtc_stor : NULL;\n\tstruct dirty_throttle_control *sdtc;\n\tunsigned long nr_reclaimable;\t/* = file_dirty + unstable_nfs */\n\tlong period;\n\tlong pause;\n\tlong max_pause;\n\tlong min_pause;\n\tint nr_dirtied_pause;\n\tbool dirty_exceeded = false;\n\tunsigned long task_ratelimit;\n\tunsigned long dirty_ratelimit;\n\tstruct backing_dev_info *bdi = wb->bdi;\n\tbool strictlimit = bdi->capabilities & BDI_CAP_STRICTLIMIT;\n\tunsigned long start_time = jiffies;\n\n\tfor (;;) {\n\t\tunsigned long now = jiffies;\n\t\tunsigned long dirty, thresh, bg_thresh;\n\t\tunsigned long m_dirty = 0;\t/* stop bogus uninit warnings */\n\t\tunsigned long m_thresh = 0;\n\t\tunsigned long m_bg_thresh = 0;\n\n\t\t/*\n\t\t * Unstable writes are a feature of certain networked\n\t\t * filesystems (i.e. NFS) in which data may have been\n\t\t * written to the server's write cache, but has not yet\n\t\t * been flushed to permanent storage.\n\t\t */\n\t\tnr_reclaimable = global_node_page_state(NR_FILE_DIRTY) +\n\t\t\t\t\tglobal_node_page_state(NR_UNSTABLE_NFS);\n\t\tgdtc->avail = global_dirtyable_memory();\n\t\tgdtc->dirty = nr_reclaimable + global_node_page_state(NR_WRITEBACK);\n\n\t\tdomain_dirty_limits(gdtc);\n\n\t\tif (unlikely(strictlimit)) {\n\t\t\twb_dirty_limits(gdtc);\n\n\t\t\tdirty = gdtc->wb_dirty;\n\t\t\tthresh = gdtc->wb_thresh;\n\t\t\tbg_thresh = gdtc->wb_bg_thresh;\n\t\t} else {\n\t\t\tdirty = gdtc->dirty;\n\t\t\tthresh = gdtc->thresh;\n\t\t\tbg_thresh = gdtc->bg_thresh;\n\t\t}\n\n\t\tif (mdtc) {\n\t\t\tunsigned long filepages, headroom, writeback;\n\n\t\t\t/*\n\t\t\t * If @wb belongs to !root memcg, repeat the same\n\t\t\t * basic calculations for the memcg domain.\n\t\t\t */\n\t\t\tmem_cgroup_wb_stats(wb, &filepages, &headroom,\n\t\t\t\t\t    &mdtc->dirty, &writeback);\n\t\t\tmdtc->dirty += writeback;\n\t\t\tmdtc_calc_avail(mdtc, filepages, headroom);\n\n\t\t\tdomain_dirty_limits(mdtc);\n\n\t\t\tif (unlikely(strictlimit)) {\n\t\t\t\twb_dirty_limits(mdtc);\n\t\t\t\tm_dirty = mdtc->wb_dirty;\n\t\t\t\tm_thresh = mdtc->wb_thresh;\n\t\t\t\tm_bg_thresh = mdtc->wb_bg_thresh;\n\t\t\t} else {\n\t\t\t\tm_dirty = mdtc->dirty;\n\t\t\t\tm_thresh = mdtc->thresh;\n\t\t\t\tm_bg_thresh = mdtc->bg_thresh;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Throttle it only when the background writeback cannot\n\t\t * catch-up. This avoids (excessively) small writeouts\n\t\t * when the wb limits are ramping up in case of !strictlimit.\n\t\t *\n\t\t * In strictlimit case make decision based on the wb counters\n\t\t * and limits. Small writeouts when the wb limits are ramping\n\t\t * up are the price we consciously pay for strictlimit-ing.\n\t\t *\n\t\t * If memcg domain is in effect, @dirty should be under\n\t\t * both global and memcg freerun ceilings.\n\t\t */\n\t\tif (dirty <= dirty_freerun_ceiling(thresh, bg_thresh) &&\n\t\t    (!mdtc ||\n\t\t     m_dirty <= dirty_freerun_ceiling(m_thresh, m_bg_thresh))) {\n\t\t\tunsigned long intv = dirty_poll_interval(dirty, thresh);\n\t\t\tunsigned long m_intv = ULONG_MAX;\n\n\t\t\tcurrent->dirty_paused_when = now;\n\t\t\tcurrent->nr_dirtied = 0;\n\t\t\tif (mdtc)\n\t\t\t\tm_intv = dirty_poll_interval(m_dirty, m_thresh);\n\t\t\tcurrent->nr_dirtied_pause = min(intv, m_intv);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(!writeback_in_progress(wb)))\n\t\t\twb_start_background_writeback(wb);\n\n\t\t/*\n\t\t * Calculate global domain's pos_ratio and select the\n\t\t * global dtc by default.\n\t\t */\n\t\tif (!strictlimit)\n\t\t\twb_dirty_limits(gdtc);\n\n\t\tdirty_exceeded = (gdtc->wb_dirty > gdtc->wb_thresh) &&\n\t\t\t((gdtc->dirty > gdtc->thresh) || strictlimit);\n\n\t\twb_position_ratio(gdtc);\n\t\tsdtc = gdtc;\n\n\t\tif (mdtc) {\n\t\t\t/*\n\t\t\t * If memcg domain is in effect, calculate its\n\t\t\t * pos_ratio.  @wb should satisfy constraints from\n\t\t\t * both global and memcg domains.  Choose the one\n\t\t\t * w/ lower pos_ratio.\n\t\t\t */\n\t\t\tif (!strictlimit)\n\t\t\t\twb_dirty_limits(mdtc);\n\n\t\t\tdirty_exceeded |= (mdtc->wb_dirty > mdtc->wb_thresh) &&\n\t\t\t\t((mdtc->dirty > mdtc->thresh) || strictlimit);\n\n\t\t\twb_position_ratio(mdtc);\n\t\t\tif (mdtc->pos_ratio < gdtc->pos_ratio)\n\t\t\t\tsdtc = mdtc;\n\t\t}\n\n\t\tif (dirty_exceeded && !wb->dirty_exceeded)\n\t\t\twb->dirty_exceeded = 1;\n\n\t\tif (time_is_before_jiffies(wb->bw_time_stamp +\n\t\t\t\t\t   BANDWIDTH_INTERVAL)) {\n\t\t\tspin_lock(&wb->list_lock);\n\t\t\t__wb_update_bandwidth(gdtc, mdtc, start_time, true);\n\t\t\tspin_unlock(&wb->list_lock);\n\t\t}\n\n\t\t/* throttle according to the chosen dtc */\n\t\tdirty_ratelimit = wb->dirty_ratelimit;\n\t\ttask_ratelimit = ((u64)dirty_ratelimit * sdtc->pos_ratio) >>\n\t\t\t\t\t\t\tRATELIMIT_CALC_SHIFT;\n\t\tmax_pause = wb_max_pause(wb, sdtc->wb_dirty);\n\t\tmin_pause = wb_min_pause(wb, max_pause,\n\t\t\t\t\t task_ratelimit, dirty_ratelimit,\n\t\t\t\t\t &nr_dirtied_pause);\n\n\t\tif (unlikely(task_ratelimit == 0)) {\n\t\t\tperiod = max_pause;\n\t\t\tpause = max_pause;\n\t\t\tgoto pause;\n\t\t}\n\t\tperiod = HZ * pages_dirtied / task_ratelimit;\n\t\tpause = period;\n\t\tif (current->dirty_paused_when)\n\t\t\tpause -= now - current->dirty_paused_when;\n\t\t/*\n\t\t * For less than 1s think time (ext3/4 may block the dirtier\n\t\t * for up to 800ms from time to time on 1-HDD; so does xfs,\n\t\t * however at much less frequency), try to compensate it in\n\t\t * future periods by updating the virtual time; otherwise just\n\t\t * do a reset, as it may be a light dirtier.\n\t\t */\n\t\tif (pause < min_pause) {\n\t\t\ttrace_balance_dirty_pages(wb,\n\t\t\t\t\t\t  sdtc->thresh,\n\t\t\t\t\t\t  sdtc->bg_thresh,\n\t\t\t\t\t\t  sdtc->dirty,\n\t\t\t\t\t\t  sdtc->wb_thresh,\n\t\t\t\t\t\t  sdtc->wb_dirty,\n\t\t\t\t\t\t  dirty_ratelimit,\n\t\t\t\t\t\t  task_ratelimit,\n\t\t\t\t\t\t  pages_dirtied,\n\t\t\t\t\t\t  period,\n\t\t\t\t\t\t  min(pause, 0L),\n\t\t\t\t\t\t  start_time);\n\t\t\tif (pause < -HZ) {\n\t\t\t\tcurrent->dirty_paused_when = now;\n\t\t\t\tcurrent->nr_dirtied = 0;\n\t\t\t} else if (period) {\n\t\t\t\tcurrent->dirty_paused_when += period;\n\t\t\t\tcurrent->nr_dirtied = 0;\n\t\t\t} else if (current->nr_dirtied_pause <= pages_dirtied)\n\t\t\t\tcurrent->nr_dirtied_pause += pages_dirtied;\n\t\t\tbreak;\n\t\t}\n\t\tif (unlikely(pause > max_pause)) {\n\t\t\t/* for occasional dropped task_ratelimit */\n\t\t\tnow += min(pause - max_pause, max_pause);\n\t\t\tpause = max_pause;\n\t\t}\n\npause:\n\t\ttrace_balance_dirty_pages(wb,\n\t\t\t\t\t  sdtc->thresh,\n\t\t\t\t\t  sdtc->bg_thresh,\n\t\t\t\t\t  sdtc->dirty,\n\t\t\t\t\t  sdtc->wb_thresh,\n\t\t\t\t\t  sdtc->wb_dirty,\n\t\t\t\t\t  dirty_ratelimit,\n\t\t\t\t\t  task_ratelimit,\n\t\t\t\t\t  pages_dirtied,\n\t\t\t\t\t  period,\n\t\t\t\t\t  pause,\n\t\t\t\t\t  start_time);\n\t\t__set_current_state(TASK_KILLABLE);\n\t\twb->dirty_sleep = now;\n\t\tio_schedule_timeout(pause);\n\n\t\tcurrent->dirty_paused_when = now + pause;\n\t\tcurrent->nr_dirtied = 0;\n\t\tcurrent->nr_dirtied_pause = nr_dirtied_pause;\n\n\t\t/*\n\t\t * This is typically equal to (dirty < thresh) and can also\n\t\t * keep \"1000+ dd on a slow USB stick\" under control.\n\t\t */\n\t\tif (task_ratelimit)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * In the case of an unresponding NFS server and the NFS dirty\n\t\t * pages exceeds dirty_thresh, give the other good wb's a pipe\n\t\t * to go through, so that tasks on them still remain responsive.\n\t\t *\n\t\t * In theory 1 page is enough to keep the consumer-producer\n\t\t * pipe going: the flusher cleans 1 page => the task dirties 1\n\t\t * more page. However wb_dirty has accounting errors.  So use\n\t\t * the larger and more IO friendly wb_stat_error.\n\t\t */\n\t\tif (sdtc->wb_dirty <= wb_stat_error())\n\t\t\tbreak;\n\n\t\tif (fatal_signal_pending(current))\n\t\t\tbreak;\n\t}\n\n\tif (!dirty_exceeded && wb->dirty_exceeded)\n\t\twb->dirty_exceeded = 0;\n\n\tif (writeback_in_progress(wb))\n\t\treturn;\n\n\t/*\n\t * In laptop mode, we wait until hitting the higher threshold before\n\t * starting background writeout, and then write out all the way down\n\t * to the lower threshold.  So slow writers cause minimal disk activity.\n\t *\n\t * In normal mode, we start background writeout at the lower\n\t * background_thresh, to keep the amount of dirty memory low.\n\t */\n\tif (laptop_mode)\n\t\treturn;\n\n\tif (nr_reclaimable > gdtc->bg_thresh)\n\t\twb_start_background_writeback(wb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->nr_dirtied >= ratelimit"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "*p",
            "ratelimit - current->nr_dirtied"
          ],
          "line": 1903
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_set_min_ratio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "674-693",
          "snippet": "int bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)\n{\n\tint ret = 0;\n\n\tspin_lock_bh(&bdi_lock);\n\tif (min_ratio > bdi->max_ratio) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tmin_ratio -= bdi->min_ratio;\n\t\tif (bdi_min_ratio + min_ratio < 100) {\n\t\t\tbdi_min_ratio += min_ratio;\n\t\t\tbdi->min_ratio += min_ratio;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tspin_unlock_bh(&bdi_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int bdi_min_ratio;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned int bdi_min_ratio;\n\nint bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)\n{\n\tint ret = 0;\n\n\tspin_lock_bh(&bdi_lock);\n\tif (min_ratio > bdi->max_ratio) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tmin_ratio -= bdi->min_ratio;\n\t\tif (bdi_min_ratio + min_ratio < 100) {\n\t\t\tbdi_min_ratio += min_ratio;\n\t\t\tbdi->min_ratio += min_ratio;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tspin_unlock_bh(&bdi_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&dirty_throttle_leaks"
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "*p >= ratelimit_pages"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->nr_dirtied >= ratelimit"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&bdp_ratelimits"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_get_create_current",
          "args": [
            "bdi",
            "GFP_KERNEL"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_cgwb_enabled",
          "args": [
            "inode"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_cap_account_dirty",
          "args": [
            "bdi"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "inode"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long ratelimit_pages = 32;\nstatic DEFINE_PER_CPU(int, bdp_ratelimits);\n\nvoid balance_dirty_pages_ratelimited(struct address_space *mapping)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\tstruct bdi_writeback *wb = NULL;\n\tint ratelimit;\n\tint *p;\n\n\tif (!bdi_cap_account_dirty(bdi))\n\t\treturn;\n\n\tif (inode_cgwb_enabled(inode))\n\t\twb = wb_get_create_current(bdi, GFP_KERNEL);\n\tif (!wb)\n\t\twb = &bdi->wb;\n\n\tratelimit = current->nr_dirtied_pause;\n\tif (wb->dirty_exceeded)\n\t\tratelimit = min(ratelimit, 32 >> (PAGE_SHIFT - 10));\n\n\tpreempt_disable();\n\t/*\n\t * This prevents one CPU to accumulate too many dirtied pages without\n\t * calling into balance_dirty_pages(), which can happen when there are\n\t * 1000+ tasks, all of them start dirtying pages at exactly the same\n\t * time, hence all honoured too large initial task->nr_dirtied_pause.\n\t */\n\tp =  this_cpu_ptr(&bdp_ratelimits);\n\tif (unlikely(current->nr_dirtied >= ratelimit))\n\t\t*p = 0;\n\telse if (unlikely(*p >= ratelimit_pages)) {\n\t\t*p = 0;\n\t\tratelimit = 0;\n\t}\n\t/*\n\t * Pick up the dirtied pages by the exited tasks. This avoids lots of\n\t * short-lived tasks (eg. gcc invocations in a kernel build) escaping\n\t * the dirty throttling and livelock other long-run dirtiers.\n\t */\n\tp = this_cpu_ptr(&dirty_throttle_leaks);\n\tif (*p > 0 && current->nr_dirtied < ratelimit) {\n\t\tunsigned long nr_pages_dirtied;\n\t\tnr_pages_dirtied = min(*p, ratelimit - current->nr_dirtied);\n\t\t*p -= nr_pages_dirtied;\n\t\tcurrent->nr_dirtied += nr_pages_dirtied;\n\t}\n\tpreempt_enable();\n\n\tif (unlikely(current->nr_dirtied >= ratelimit))\n\t\tbalance_dirty_pages(wb, current->nr_dirtied);\n\n\twb_put(wb);\n}"
  },
  {
    "function_name": "balance_dirty_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "1560-1828",
    "snippet": "static void balance_dirty_pages(struct bdi_writeback *wb,\n\t\t\t\tunsigned long pages_dirtied)\n{\n\tstruct dirty_throttle_control gdtc_stor = { GDTC_INIT(wb) };\n\tstruct dirty_throttle_control mdtc_stor = { MDTC_INIT(wb, &gdtc_stor) };\n\tstruct dirty_throttle_control * const gdtc = &gdtc_stor;\n\tstruct dirty_throttle_control * const mdtc = mdtc_valid(&mdtc_stor) ?\n\t\t\t\t\t\t     &mdtc_stor : NULL;\n\tstruct dirty_throttle_control *sdtc;\n\tunsigned long nr_reclaimable;\t/* = file_dirty + unstable_nfs */\n\tlong period;\n\tlong pause;\n\tlong max_pause;\n\tlong min_pause;\n\tint nr_dirtied_pause;\n\tbool dirty_exceeded = false;\n\tunsigned long task_ratelimit;\n\tunsigned long dirty_ratelimit;\n\tstruct backing_dev_info *bdi = wb->bdi;\n\tbool strictlimit = bdi->capabilities & BDI_CAP_STRICTLIMIT;\n\tunsigned long start_time = jiffies;\n\n\tfor (;;) {\n\t\tunsigned long now = jiffies;\n\t\tunsigned long dirty, thresh, bg_thresh;\n\t\tunsigned long m_dirty = 0;\t/* stop bogus uninit warnings */\n\t\tunsigned long m_thresh = 0;\n\t\tunsigned long m_bg_thresh = 0;\n\n\t\t/*\n\t\t * Unstable writes are a feature of certain networked\n\t\t * filesystems (i.e. NFS) in which data may have been\n\t\t * written to the server's write cache, but has not yet\n\t\t * been flushed to permanent storage.\n\t\t */\n\t\tnr_reclaimable = global_node_page_state(NR_FILE_DIRTY) +\n\t\t\t\t\tglobal_node_page_state(NR_UNSTABLE_NFS);\n\t\tgdtc->avail = global_dirtyable_memory();\n\t\tgdtc->dirty = nr_reclaimable + global_node_page_state(NR_WRITEBACK);\n\n\t\tdomain_dirty_limits(gdtc);\n\n\t\tif (unlikely(strictlimit)) {\n\t\t\twb_dirty_limits(gdtc);\n\n\t\t\tdirty = gdtc->wb_dirty;\n\t\t\tthresh = gdtc->wb_thresh;\n\t\t\tbg_thresh = gdtc->wb_bg_thresh;\n\t\t} else {\n\t\t\tdirty = gdtc->dirty;\n\t\t\tthresh = gdtc->thresh;\n\t\t\tbg_thresh = gdtc->bg_thresh;\n\t\t}\n\n\t\tif (mdtc) {\n\t\t\tunsigned long filepages, headroom, writeback;\n\n\t\t\t/*\n\t\t\t * If @wb belongs to !root memcg, repeat the same\n\t\t\t * basic calculations for the memcg domain.\n\t\t\t */\n\t\t\tmem_cgroup_wb_stats(wb, &filepages, &headroom,\n\t\t\t\t\t    &mdtc->dirty, &writeback);\n\t\t\tmdtc->dirty += writeback;\n\t\t\tmdtc_calc_avail(mdtc, filepages, headroom);\n\n\t\t\tdomain_dirty_limits(mdtc);\n\n\t\t\tif (unlikely(strictlimit)) {\n\t\t\t\twb_dirty_limits(mdtc);\n\t\t\t\tm_dirty = mdtc->wb_dirty;\n\t\t\t\tm_thresh = mdtc->wb_thresh;\n\t\t\t\tm_bg_thresh = mdtc->wb_bg_thresh;\n\t\t\t} else {\n\t\t\t\tm_dirty = mdtc->dirty;\n\t\t\t\tm_thresh = mdtc->thresh;\n\t\t\t\tm_bg_thresh = mdtc->bg_thresh;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Throttle it only when the background writeback cannot\n\t\t * catch-up. This avoids (excessively) small writeouts\n\t\t * when the wb limits are ramping up in case of !strictlimit.\n\t\t *\n\t\t * In strictlimit case make decision based on the wb counters\n\t\t * and limits. Small writeouts when the wb limits are ramping\n\t\t * up are the price we consciously pay for strictlimit-ing.\n\t\t *\n\t\t * If memcg domain is in effect, @dirty should be under\n\t\t * both global and memcg freerun ceilings.\n\t\t */\n\t\tif (dirty <= dirty_freerun_ceiling(thresh, bg_thresh) &&\n\t\t    (!mdtc ||\n\t\t     m_dirty <= dirty_freerun_ceiling(m_thresh, m_bg_thresh))) {\n\t\t\tunsigned long intv = dirty_poll_interval(dirty, thresh);\n\t\t\tunsigned long m_intv = ULONG_MAX;\n\n\t\t\tcurrent->dirty_paused_when = now;\n\t\t\tcurrent->nr_dirtied = 0;\n\t\t\tif (mdtc)\n\t\t\t\tm_intv = dirty_poll_interval(m_dirty, m_thresh);\n\t\t\tcurrent->nr_dirtied_pause = min(intv, m_intv);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(!writeback_in_progress(wb)))\n\t\t\twb_start_background_writeback(wb);\n\n\t\t/*\n\t\t * Calculate global domain's pos_ratio and select the\n\t\t * global dtc by default.\n\t\t */\n\t\tif (!strictlimit)\n\t\t\twb_dirty_limits(gdtc);\n\n\t\tdirty_exceeded = (gdtc->wb_dirty > gdtc->wb_thresh) &&\n\t\t\t((gdtc->dirty > gdtc->thresh) || strictlimit);\n\n\t\twb_position_ratio(gdtc);\n\t\tsdtc = gdtc;\n\n\t\tif (mdtc) {\n\t\t\t/*\n\t\t\t * If memcg domain is in effect, calculate its\n\t\t\t * pos_ratio.  @wb should satisfy constraints from\n\t\t\t * both global and memcg domains.  Choose the one\n\t\t\t * w/ lower pos_ratio.\n\t\t\t */\n\t\t\tif (!strictlimit)\n\t\t\t\twb_dirty_limits(mdtc);\n\n\t\t\tdirty_exceeded |= (mdtc->wb_dirty > mdtc->wb_thresh) &&\n\t\t\t\t((mdtc->dirty > mdtc->thresh) || strictlimit);\n\n\t\t\twb_position_ratio(mdtc);\n\t\t\tif (mdtc->pos_ratio < gdtc->pos_ratio)\n\t\t\t\tsdtc = mdtc;\n\t\t}\n\n\t\tif (dirty_exceeded && !wb->dirty_exceeded)\n\t\t\twb->dirty_exceeded = 1;\n\n\t\tif (time_is_before_jiffies(wb->bw_time_stamp +\n\t\t\t\t\t   BANDWIDTH_INTERVAL)) {\n\t\t\tspin_lock(&wb->list_lock);\n\t\t\t__wb_update_bandwidth(gdtc, mdtc, start_time, true);\n\t\t\tspin_unlock(&wb->list_lock);\n\t\t}\n\n\t\t/* throttle according to the chosen dtc */\n\t\tdirty_ratelimit = wb->dirty_ratelimit;\n\t\ttask_ratelimit = ((u64)dirty_ratelimit * sdtc->pos_ratio) >>\n\t\t\t\t\t\t\tRATELIMIT_CALC_SHIFT;\n\t\tmax_pause = wb_max_pause(wb, sdtc->wb_dirty);\n\t\tmin_pause = wb_min_pause(wb, max_pause,\n\t\t\t\t\t task_ratelimit, dirty_ratelimit,\n\t\t\t\t\t &nr_dirtied_pause);\n\n\t\tif (unlikely(task_ratelimit == 0)) {\n\t\t\tperiod = max_pause;\n\t\t\tpause = max_pause;\n\t\t\tgoto pause;\n\t\t}\n\t\tperiod = HZ * pages_dirtied / task_ratelimit;\n\t\tpause = period;\n\t\tif (current->dirty_paused_when)\n\t\t\tpause -= now - current->dirty_paused_when;\n\t\t/*\n\t\t * For less than 1s think time (ext3/4 may block the dirtier\n\t\t * for up to 800ms from time to time on 1-HDD; so does xfs,\n\t\t * however at much less frequency), try to compensate it in\n\t\t * future periods by updating the virtual time; otherwise just\n\t\t * do a reset, as it may be a light dirtier.\n\t\t */\n\t\tif (pause < min_pause) {\n\t\t\ttrace_balance_dirty_pages(wb,\n\t\t\t\t\t\t  sdtc->thresh,\n\t\t\t\t\t\t  sdtc->bg_thresh,\n\t\t\t\t\t\t  sdtc->dirty,\n\t\t\t\t\t\t  sdtc->wb_thresh,\n\t\t\t\t\t\t  sdtc->wb_dirty,\n\t\t\t\t\t\t  dirty_ratelimit,\n\t\t\t\t\t\t  task_ratelimit,\n\t\t\t\t\t\t  pages_dirtied,\n\t\t\t\t\t\t  period,\n\t\t\t\t\t\t  min(pause, 0L),\n\t\t\t\t\t\t  start_time);\n\t\t\tif (pause < -HZ) {\n\t\t\t\tcurrent->dirty_paused_when = now;\n\t\t\t\tcurrent->nr_dirtied = 0;\n\t\t\t} else if (period) {\n\t\t\t\tcurrent->dirty_paused_when += period;\n\t\t\t\tcurrent->nr_dirtied = 0;\n\t\t\t} else if (current->nr_dirtied_pause <= pages_dirtied)\n\t\t\t\tcurrent->nr_dirtied_pause += pages_dirtied;\n\t\t\tbreak;\n\t\t}\n\t\tif (unlikely(pause > max_pause)) {\n\t\t\t/* for occasional dropped task_ratelimit */\n\t\t\tnow += min(pause - max_pause, max_pause);\n\t\t\tpause = max_pause;\n\t\t}\n\npause:\n\t\ttrace_balance_dirty_pages(wb,\n\t\t\t\t\t  sdtc->thresh,\n\t\t\t\t\t  sdtc->bg_thresh,\n\t\t\t\t\t  sdtc->dirty,\n\t\t\t\t\t  sdtc->wb_thresh,\n\t\t\t\t\t  sdtc->wb_dirty,\n\t\t\t\t\t  dirty_ratelimit,\n\t\t\t\t\t  task_ratelimit,\n\t\t\t\t\t  pages_dirtied,\n\t\t\t\t\t  period,\n\t\t\t\t\t  pause,\n\t\t\t\t\t  start_time);\n\t\t__set_current_state(TASK_KILLABLE);\n\t\twb->dirty_sleep = now;\n\t\tio_schedule_timeout(pause);\n\n\t\tcurrent->dirty_paused_when = now + pause;\n\t\tcurrent->nr_dirtied = 0;\n\t\tcurrent->nr_dirtied_pause = nr_dirtied_pause;\n\n\t\t/*\n\t\t * This is typically equal to (dirty < thresh) and can also\n\t\t * keep \"1000+ dd on a slow USB stick\" under control.\n\t\t */\n\t\tif (task_ratelimit)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * In the case of an unresponding NFS server and the NFS dirty\n\t\t * pages exceeds dirty_thresh, give the other good wb's a pipe\n\t\t * to go through, so that tasks on them still remain responsive.\n\t\t *\n\t\t * In theory 1 page is enough to keep the consumer-producer\n\t\t * pipe going: the flusher cleans 1 page => the task dirties 1\n\t\t * more page. However wb_dirty has accounting errors.  So use\n\t\t * the larger and more IO friendly wb_stat_error.\n\t\t */\n\t\tif (sdtc->wb_dirty <= wb_stat_error())\n\t\t\tbreak;\n\n\t\tif (fatal_signal_pending(current))\n\t\t\tbreak;\n\t}\n\n\tif (!dirty_exceeded && wb->dirty_exceeded)\n\t\twb->dirty_exceeded = 0;\n\n\tif (writeback_in_progress(wb))\n\t\treturn;\n\n\t/*\n\t * In laptop mode, we wait until hitting the higher threshold before\n\t * starting background writeout, and then write out all the way down\n\t * to the lower threshold.  So slow writers cause minimal disk activity.\n\t *\n\t * In normal mode, we start background writeout at the lower\n\t * background_thresh, to keep the amount of dirty memory low.\n\t */\n\tif (laptop_mode)\n\t\treturn;\n\n\tif (nr_reclaimable > gdtc->bg_thresh)\n\t\twb_start_background_writeback(wb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define RATELIMIT_CALC_SHIFT\t10",
      "#define BANDWIDTH_INTERVAL\tmax(HZ/5, 1)"
    ],
    "globals_used": [
      "int laptop_mode;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wb_start_background_writeback",
          "args": [
            "wb"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeback_in_progress",
          "args": [
            "wb"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_stat_error",
          "args": [],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_schedule_timeout",
          "args": [
            "pause"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_KILLABLE"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_balance_dirty_pages",
          "args": [
            "wb",
            "sdtc->thresh",
            "sdtc->bg_thresh",
            "sdtc->dirty",
            "sdtc->wb_thresh",
            "sdtc->wb_dirty",
            "dirty_ratelimit",
            "task_ratelimit",
            "pages_dirtied",
            "period",
            "pause",
            "start_time"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "pause - max_pause",
            "max_pause"
          ],
          "line": 1760
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_set_min_ratio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "674-693",
          "snippet": "int bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)\n{\n\tint ret = 0;\n\n\tspin_lock_bh(&bdi_lock);\n\tif (min_ratio > bdi->max_ratio) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tmin_ratio -= bdi->min_ratio;\n\t\tif (bdi_min_ratio + min_ratio < 100) {\n\t\t\tbdi_min_ratio += min_ratio;\n\t\t\tbdi->min_ratio += min_ratio;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tspin_unlock_bh(&bdi_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int bdi_min_ratio;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned int bdi_min_ratio;\n\nint bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)\n{\n\tint ret = 0;\n\n\tspin_lock_bh(&bdi_lock);\n\tif (min_ratio > bdi->max_ratio) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tmin_ratio -= bdi->min_ratio;\n\t\tif (bdi_min_ratio + min_ratio < 100) {\n\t\t\tbdi_min_ratio += min_ratio;\n\t\t\tbdi->min_ratio += min_ratio;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tspin_unlock_bh(&bdi_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pause > max_pause"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_balance_dirty_pages",
          "args": [
            "wb",
            "sdtc->thresh",
            "sdtc->bg_thresh",
            "sdtc->dirty",
            "sdtc->wb_thresh",
            "sdtc->wb_dirty",
            "dirty_ratelimit",
            "task_ratelimit",
            "pages_dirtied",
            "period",
            "min(pause, 0L)",
            "start_time"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "task_ratelimit == 0"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_min_pause",
          "args": [
            "wb",
            "max_pause",
            "task_ratelimit",
            "dirty_ratelimit",
            "&nr_dirtied_pause"
          ],
          "line": 1715
        },
        "resolved": true,
        "details": {
          "function_name": "wb_min_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1437-1510",
          "snippet": "static long wb_min_pause(struct bdi_writeback *wb,\n\t\t\t long max_pause,\n\t\t\t unsigned long task_ratelimit,\n\t\t\t unsigned long dirty_ratelimit,\n\t\t\t int *nr_dirtied_pause)\n{\n\tlong hi = ilog2(wb->avg_write_bandwidth);\n\tlong lo = ilog2(wb->dirty_ratelimit);\n\tlong t;\t\t/* target pause */\n\tlong pause;\t/* estimated next pause */\n\tint pages;\t/* target nr_dirtied_pause */\n\n\t/* target for 10ms pause on 1-dd case */\n\tt = max(1, HZ / 100);\n\n\t/*\n\t * Scale up pause time for concurrent dirtiers in order to reduce CPU\n\t * overheads.\n\t *\n\t * (N * 10ms) on 2^N concurrent tasks.\n\t */\n\tif (hi > lo)\n\t\tt += (hi - lo) * (10 * HZ) / 1024;\n\n\t/*\n\t * This is a bit convoluted. We try to base the next nr_dirtied_pause\n\t * on the much more stable dirty_ratelimit. However the next pause time\n\t * will be computed based on task_ratelimit and the two rate limits may\n\t * depart considerably at some time. Especially if task_ratelimit goes\n\t * below dirty_ratelimit/2 and the target pause is max_pause, the next\n\t * pause time will be max_pause*2 _trimmed down_ to max_pause.  As a\n\t * result task_ratelimit won't be executed faithfully, which could\n\t * eventually bring down dirty_ratelimit.\n\t *\n\t * We apply two rules to fix it up:\n\t * 1) try to estimate the next pause time and if necessary, use a lower\n\t *    nr_dirtied_pause so as not to exceed max_pause. When this happens,\n\t *    nr_dirtied_pause will be \"dancing\" with task_ratelimit.\n\t * 2) limit the target pause time to max_pause/2, so that the normal\n\t *    small fluctuations of task_ratelimit won't trigger rule (1) and\n\t *    nr_dirtied_pause will remain as stable as dirty_ratelimit.\n\t */\n\tt = min(t, 1 + max_pause / 2);\n\tpages = dirty_ratelimit * t / roundup_pow_of_two(HZ);\n\n\t/*\n\t * Tiny nr_dirtied_pause is found to hurt I/O performance in the test\n\t * case fio-mmap-randwrite-64k, which does 16*{sync read, async write}.\n\t * When the 16 consecutive reads are often interrupted by some dirty\n\t * throttling pause during the async writes, cfq will go into idles\n\t * (deadline is fine). So push nr_dirtied_pause as high as possible\n\t * until reaches DIRTY_POLL_THRESH=32 pages.\n\t */\n\tif (pages < DIRTY_POLL_THRESH) {\n\t\tt = max_pause;\n\t\tpages = dirty_ratelimit * t / roundup_pow_of_two(HZ);\n\t\tif (pages > DIRTY_POLL_THRESH) {\n\t\t\tpages = DIRTY_POLL_THRESH;\n\t\t\tt = HZ * DIRTY_POLL_THRESH / dirty_ratelimit;\n\t\t}\n\t}\n\n\tpause = HZ * pages / (task_ratelimit + 1);\n\tif (pause > max_pause) {\n\t\tt = max_pause;\n\t\tpages = task_ratelimit * t / roundup_pow_of_two(HZ);\n\t}\n\n\t*nr_dirtied_pause = pages;\n\t/*\n\t * The minimal pause time will normally be half the target pause time.\n\t */\n\treturn pages >= DIRTY_POLL_THRESH ? 1 + t / 2 : t;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define DIRTY_POLL_THRESH\t(128 >> (PAGE_SHIFT - 10))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define DIRTY_POLL_THRESH\t(128 >> (PAGE_SHIFT - 10))\n\nstatic long wb_min_pause(struct bdi_writeback *wb,\n\t\t\t long max_pause,\n\t\t\t unsigned long task_ratelimit,\n\t\t\t unsigned long dirty_ratelimit,\n\t\t\t int *nr_dirtied_pause)\n{\n\tlong hi = ilog2(wb->avg_write_bandwidth);\n\tlong lo = ilog2(wb->dirty_ratelimit);\n\tlong t;\t\t/* target pause */\n\tlong pause;\t/* estimated next pause */\n\tint pages;\t/* target nr_dirtied_pause */\n\n\t/* target for 10ms pause on 1-dd case */\n\tt = max(1, HZ / 100);\n\n\t/*\n\t * Scale up pause time for concurrent dirtiers in order to reduce CPU\n\t * overheads.\n\t *\n\t * (N * 10ms) on 2^N concurrent tasks.\n\t */\n\tif (hi > lo)\n\t\tt += (hi - lo) * (10 * HZ) / 1024;\n\n\t/*\n\t * This is a bit convoluted. We try to base the next nr_dirtied_pause\n\t * on the much more stable dirty_ratelimit. However the next pause time\n\t * will be computed based on task_ratelimit and the two rate limits may\n\t * depart considerably at some time. Especially if task_ratelimit goes\n\t * below dirty_ratelimit/2 and the target pause is max_pause, the next\n\t * pause time will be max_pause*2 _trimmed down_ to max_pause.  As a\n\t * result task_ratelimit won't be executed faithfully, which could\n\t * eventually bring down dirty_ratelimit.\n\t *\n\t * We apply two rules to fix it up:\n\t * 1) try to estimate the next pause time and if necessary, use a lower\n\t *    nr_dirtied_pause so as not to exceed max_pause. When this happens,\n\t *    nr_dirtied_pause will be \"dancing\" with task_ratelimit.\n\t * 2) limit the target pause time to max_pause/2, so that the normal\n\t *    small fluctuations of task_ratelimit won't trigger rule (1) and\n\t *    nr_dirtied_pause will remain as stable as dirty_ratelimit.\n\t */\n\tt = min(t, 1 + max_pause / 2);\n\tpages = dirty_ratelimit * t / roundup_pow_of_two(HZ);\n\n\t/*\n\t * Tiny nr_dirtied_pause is found to hurt I/O performance in the test\n\t * case fio-mmap-randwrite-64k, which does 16*{sync read, async write}.\n\t * When the 16 consecutive reads are often interrupted by some dirty\n\t * throttling pause during the async writes, cfq will go into idles\n\t * (deadline is fine). So push nr_dirtied_pause as high as possible\n\t * until reaches DIRTY_POLL_THRESH=32 pages.\n\t */\n\tif (pages < DIRTY_POLL_THRESH) {\n\t\tt = max_pause;\n\t\tpages = dirty_ratelimit * t / roundup_pow_of_two(HZ);\n\t\tif (pages > DIRTY_POLL_THRESH) {\n\t\t\tpages = DIRTY_POLL_THRESH;\n\t\t\tt = HZ * DIRTY_POLL_THRESH / dirty_ratelimit;\n\t\t}\n\t}\n\n\tpause = HZ * pages / (task_ratelimit + 1);\n\tif (pause > max_pause) {\n\t\tt = max_pause;\n\t\tpages = task_ratelimit * t / roundup_pow_of_two(HZ);\n\t}\n\n\t*nr_dirtied_pause = pages;\n\t/*\n\t * The minimal pause time will normally be half the target pause time.\n\t */\n\treturn pages >= DIRTY_POLL_THRESH ? 1 + t / 2 : t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_max_pause",
          "args": [
            "wb",
            "sdtc->wb_dirty"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&wb->list_lock"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wb_update_bandwidth",
          "args": [
            "gdtc",
            "mdtc",
            "start_time",
            "true"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "__wb_update_bandwidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1344-1392",
          "snippet": "static void __wb_update_bandwidth(struct dirty_throttle_control *gdtc,\n\t\t\t\t  struct dirty_throttle_control *mdtc,\n\t\t\t\t  unsigned long start_time,\n\t\t\t\t  bool update_ratelimit)\n{\n\tstruct bdi_writeback *wb = gdtc->wb;\n\tunsigned long now = jiffies;\n\tunsigned long elapsed = now - wb->bw_time_stamp;\n\tunsigned long dirtied;\n\tunsigned long written;\n\n\tlockdep_assert_held(&wb->list_lock);\n\n\t/*\n\t * rate-limit, only update once every 200ms.\n\t */\n\tif (elapsed < BANDWIDTH_INTERVAL)\n\t\treturn;\n\n\tdirtied = percpu_counter_read(&wb->stat[WB_DIRTIED]);\n\twritten = percpu_counter_read(&wb->stat[WB_WRITTEN]);\n\n\t/*\n\t * Skip quiet periods when disk bandwidth is under-utilized.\n\t * (at least 1s idle time between two flusher runs)\n\t */\n\tif (elapsed > HZ && time_before(wb->bw_time_stamp, start_time))\n\t\tgoto snapshot;\n\n\tif (update_ratelimit) {\n\t\tdomain_update_bandwidth(gdtc, now);\n\t\twb_update_dirty_ratelimit(gdtc, dirtied, elapsed);\n\n\t\t/*\n\t\t * @mdtc is always NULL if !CGROUP_WRITEBACK but the\n\t\t * compiler has no way to figure that out.  Help it.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_CGROUP_WRITEBACK) && mdtc) {\n\t\t\tdomain_update_bandwidth(mdtc, now);\n\t\t\twb_update_dirty_ratelimit(mdtc, dirtied, elapsed);\n\t\t}\n\t}\n\twb_update_write_bandwidth(wb, elapsed, written);\n\nsnapshot:\n\twb->dirtied_stamp = dirtied;\n\twb->written_stamp = written;\n\twb->bw_time_stamp = now;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BANDWIDTH_INTERVAL\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define BANDWIDTH_INTERVAL\tmax(HZ/5, 1)\n\nstatic void __wb_update_bandwidth(struct dirty_throttle_control *gdtc,\n\t\t\t\t  struct dirty_throttle_control *mdtc,\n\t\t\t\t  unsigned long start_time,\n\t\t\t\t  bool update_ratelimit)\n{\n\tstruct bdi_writeback *wb = gdtc->wb;\n\tunsigned long now = jiffies;\n\tunsigned long elapsed = now - wb->bw_time_stamp;\n\tunsigned long dirtied;\n\tunsigned long written;\n\n\tlockdep_assert_held(&wb->list_lock);\n\n\t/*\n\t * rate-limit, only update once every 200ms.\n\t */\n\tif (elapsed < BANDWIDTH_INTERVAL)\n\t\treturn;\n\n\tdirtied = percpu_counter_read(&wb->stat[WB_DIRTIED]);\n\twritten = percpu_counter_read(&wb->stat[WB_WRITTEN]);\n\n\t/*\n\t * Skip quiet periods when disk bandwidth is under-utilized.\n\t * (at least 1s idle time between two flusher runs)\n\t */\n\tif (elapsed > HZ && time_before(wb->bw_time_stamp, start_time))\n\t\tgoto snapshot;\n\n\tif (update_ratelimit) {\n\t\tdomain_update_bandwidth(gdtc, now);\n\t\twb_update_dirty_ratelimit(gdtc, dirtied, elapsed);\n\n\t\t/*\n\t\t * @mdtc is always NULL if !CGROUP_WRITEBACK but the\n\t\t * compiler has no way to figure that out.  Help it.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_CGROUP_WRITEBACK) && mdtc) {\n\t\t\tdomain_update_bandwidth(mdtc, now);\n\t\t\twb_update_dirty_ratelimit(mdtc, dirtied, elapsed);\n\t\t}\n\t}\n\twb_update_write_bandwidth(wb, elapsed, written);\n\nsnapshot:\n\twb->dirtied_stamp = dirtied;\n\twb->written_stamp = written;\n\twb->bw_time_stamp = now;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&wb->list_lock"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_is_before_jiffies",
          "args": [
            "wb->bw_time_stamp +\n\t\t\t\t\t   BANDWIDTH_INTERVAL"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_position_ratio",
          "args": [
            "mdtc"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "wb_position_ratio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "903-1080",
          "snippet": "static void wb_position_ratio(struct dirty_throttle_control *dtc)\n{\n\tstruct bdi_writeback *wb = dtc->wb;\n\tunsigned long write_bw = wb->avg_write_bandwidth;\n\tunsigned long freerun = dirty_freerun_ceiling(dtc->thresh, dtc->bg_thresh);\n\tunsigned long limit = hard_dirty_limit(dtc_dom(dtc), dtc->thresh);\n\tunsigned long wb_thresh = dtc->wb_thresh;\n\tunsigned long x_intercept;\n\tunsigned long setpoint;\t\t/* dirty pages' target balance point */\n\tunsigned long wb_setpoint;\n\tunsigned long span;\n\tlong long pos_ratio;\t\t/* for scaling up/down the rate limit */\n\tlong x;\n\n\tdtc->pos_ratio = 0;\n\n\tif (unlikely(dtc->dirty >= limit))\n\t\treturn;\n\n\t/*\n\t * global setpoint\n\t *\n\t * See comment for pos_ratio_polynom().\n\t */\n\tsetpoint = (freerun + limit) / 2;\n\tpos_ratio = pos_ratio_polynom(setpoint, dtc->dirty, limit);\n\n\t/*\n\t * The strictlimit feature is a tool preventing mistrusted filesystems\n\t * from growing a large number of dirty pages before throttling. For\n\t * such filesystems balance_dirty_pages always checks wb counters\n\t * against wb limits. Even if global \"nr_dirty\" is under \"freerun\".\n\t * This is especially important for fuse which sets bdi->max_ratio to\n\t * 1% by default. Without strictlimit feature, fuse writeback may\n\t * consume arbitrary amount of RAM because it is accounted in\n\t * NR_WRITEBACK_TEMP which is not involved in calculating \"nr_dirty\".\n\t *\n\t * Here, in wb_position_ratio(), we calculate pos_ratio based on\n\t * two values: wb_dirty and wb_thresh. Let's consider an example:\n\t * total amount of RAM is 16GB, bdi->max_ratio is equal to 1%, global\n\t * limits are set by default to 10% and 20% (background and throttle).\n\t * Then wb_thresh is 1% of 20% of 16GB. This amounts to ~8K pages.\n\t * wb_calc_thresh(wb, bg_thresh) is about ~4K pages. wb_setpoint is\n\t * about ~6K pages (as the average of background and throttle wb\n\t * limits). The 3rd order polynomial will provide positive feedback if\n\t * wb_dirty is under wb_setpoint and vice versa.\n\t *\n\t * Note, that we cannot use global counters in these calculations\n\t * because we want to throttle process writing to a strictlimit wb\n\t * much earlier than global \"freerun\" is reached (~23MB vs. ~2.3GB\n\t * in the example above).\n\t */\n\tif (unlikely(wb->bdi->capabilities & BDI_CAP_STRICTLIMIT)) {\n\t\tlong long wb_pos_ratio;\n\n\t\tif (dtc->wb_dirty < 8) {\n\t\t\tdtc->pos_ratio = min_t(long long, pos_ratio * 2,\n\t\t\t\t\t   2 << RATELIMIT_CALC_SHIFT);\n\t\t\treturn;\n\t\t}\n\n\t\tif (dtc->wb_dirty >= wb_thresh)\n\t\t\treturn;\n\n\t\twb_setpoint = dirty_freerun_ceiling(wb_thresh,\n\t\t\t\t\t\t    dtc->wb_bg_thresh);\n\n\t\tif (wb_setpoint == 0 || wb_setpoint == wb_thresh)\n\t\t\treturn;\n\n\t\twb_pos_ratio = pos_ratio_polynom(wb_setpoint, dtc->wb_dirty,\n\t\t\t\t\t\t wb_thresh);\n\n\t\t/*\n\t\t * Typically, for strictlimit case, wb_setpoint << setpoint\n\t\t * and pos_ratio >> wb_pos_ratio. In the other words global\n\t\t * state (\"dirty\") is not limiting factor and we have to\n\t\t * make decision based on wb counters. But there is an\n\t\t * important case when global pos_ratio should get precedence:\n\t\t * global limits are exceeded (e.g. due to activities on other\n\t\t * wb's) while given strictlimit wb is below limit.\n\t\t *\n\t\t * \"pos_ratio * wb_pos_ratio\" would work for the case above,\n\t\t * but it would look too non-natural for the case of all\n\t\t * activity in the system coming from a single strictlimit wb\n\t\t * with bdi->max_ratio == 100%.\n\t\t *\n\t\t * Note that min() below somewhat changes the dynamics of the\n\t\t * control system. Normally, pos_ratio value can be well over 3\n\t\t * (when globally we are at freerun and wb is well below wb\n\t\t * setpoint). Now the maximum pos_ratio in the same situation\n\t\t * is 2. We might want to tweak this if we observe the control\n\t\t * system is too slow to adapt.\n\t\t */\n\t\tdtc->pos_ratio = min(pos_ratio, wb_pos_ratio);\n\t\treturn;\n\t}\n\n\t/*\n\t * We have computed basic pos_ratio above based on global situation. If\n\t * the wb is over/under its share of dirty pages, we want to scale\n\t * pos_ratio further down/up. That is done by the following mechanism.\n\t */\n\n\t/*\n\t * wb setpoint\n\t *\n\t *        f(wb_dirty) := 1.0 + k * (wb_dirty - wb_setpoint)\n\t *\n\t *                        x_intercept - wb_dirty\n\t *                     := --------------------------\n\t *                        x_intercept - wb_setpoint\n\t *\n\t * The main wb control line is a linear function that subjects to\n\t *\n\t * (1) f(wb_setpoint) = 1.0\n\t * (2) k = - 1 / (8 * write_bw)  (in single wb case)\n\t *     or equally: x_intercept = wb_setpoint + 8 * write_bw\n\t *\n\t * For single wb case, the dirty pages are observed to fluctuate\n\t * regularly within range\n\t *        [wb_setpoint - write_bw/2, wb_setpoint + write_bw/2]\n\t * for various filesystems, where (2) can yield in a reasonable 12.5%\n\t * fluctuation range for pos_ratio.\n\t *\n\t * For JBOD case, wb_thresh (not wb_dirty!) could fluctuate up to its\n\t * own size, so move the slope over accordingly and choose a slope that\n\t * yields 100% pos_ratio fluctuation on suddenly doubled wb_thresh.\n\t */\n\tif (unlikely(wb_thresh > dtc->thresh))\n\t\twb_thresh = dtc->thresh;\n\t/*\n\t * It's very possible that wb_thresh is close to 0 not because the\n\t * device is slow, but that it has remained inactive for long time.\n\t * Honour such devices a reasonable good (hopefully IO efficient)\n\t * threshold, so that the occasional writes won't be blocked and active\n\t * writes can rampup the threshold quickly.\n\t */\n\twb_thresh = max(wb_thresh, (limit - dtc->dirty) / 8);\n\t/*\n\t * scale global setpoint to wb's:\n\t *\twb_setpoint = setpoint * wb_thresh / thresh\n\t */\n\tx = div_u64((u64)wb_thresh << 16, dtc->thresh | 1);\n\twb_setpoint = setpoint * (u64)x >> 16;\n\t/*\n\t * Use span=(8*write_bw) in single wb case as indicated by\n\t * (thresh - wb_thresh ~= 0) and transit to wb_thresh in JBOD case.\n\t *\n\t *        wb_thresh                    thresh - wb_thresh\n\t * span = --------- * (8 * write_bw) + ------------------ * wb_thresh\n\t *         thresh                           thresh\n\t */\n\tspan = (dtc->thresh - wb_thresh + 8 * write_bw) * (u64)x >> 16;\n\tx_intercept = wb_setpoint + span;\n\n\tif (dtc->wb_dirty < x_intercept - span / 4) {\n\t\tpos_ratio = div64_u64(pos_ratio * (x_intercept - dtc->wb_dirty),\n\t\t\t\t      (x_intercept - wb_setpoint) | 1);\n\t} else\n\t\tpos_ratio /= 4;\n\n\t/*\n\t * wb reserve area, safeguard against dirty pool underrun and disk idle\n\t * It may push the desired control point of global dirty pages higher\n\t * than setpoint.\n\t */\n\tx_intercept = wb_thresh / 2;\n\tif (dtc->wb_dirty < x_intercept) {\n\t\tif (dtc->wb_dirty > x_intercept / 8)\n\t\t\tpos_ratio = div_u64(pos_ratio * x_intercept,\n\t\t\t\t\t    dtc->wb_dirty);\n\t\telse\n\t\t\tpos_ratio *= 8;\n\t}\n\n\tdtc->pos_ratio = pos_ratio;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define RATELIMIT_CALC_SHIFT\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define RATELIMIT_CALC_SHIFT\t10\n\nstatic void wb_position_ratio(struct dirty_throttle_control *dtc)\n{\n\tstruct bdi_writeback *wb = dtc->wb;\n\tunsigned long write_bw = wb->avg_write_bandwidth;\n\tunsigned long freerun = dirty_freerun_ceiling(dtc->thresh, dtc->bg_thresh);\n\tunsigned long limit = hard_dirty_limit(dtc_dom(dtc), dtc->thresh);\n\tunsigned long wb_thresh = dtc->wb_thresh;\n\tunsigned long x_intercept;\n\tunsigned long setpoint;\t\t/* dirty pages' target balance point */\n\tunsigned long wb_setpoint;\n\tunsigned long span;\n\tlong long pos_ratio;\t\t/* for scaling up/down the rate limit */\n\tlong x;\n\n\tdtc->pos_ratio = 0;\n\n\tif (unlikely(dtc->dirty >= limit))\n\t\treturn;\n\n\t/*\n\t * global setpoint\n\t *\n\t * See comment for pos_ratio_polynom().\n\t */\n\tsetpoint = (freerun + limit) / 2;\n\tpos_ratio = pos_ratio_polynom(setpoint, dtc->dirty, limit);\n\n\t/*\n\t * The strictlimit feature is a tool preventing mistrusted filesystems\n\t * from growing a large number of dirty pages before throttling. For\n\t * such filesystems balance_dirty_pages always checks wb counters\n\t * against wb limits. Even if global \"nr_dirty\" is under \"freerun\".\n\t * This is especially important for fuse which sets bdi->max_ratio to\n\t * 1% by default. Without strictlimit feature, fuse writeback may\n\t * consume arbitrary amount of RAM because it is accounted in\n\t * NR_WRITEBACK_TEMP which is not involved in calculating \"nr_dirty\".\n\t *\n\t * Here, in wb_position_ratio(), we calculate pos_ratio based on\n\t * two values: wb_dirty and wb_thresh. Let's consider an example:\n\t * total amount of RAM is 16GB, bdi->max_ratio is equal to 1%, global\n\t * limits are set by default to 10% and 20% (background and throttle).\n\t * Then wb_thresh is 1% of 20% of 16GB. This amounts to ~8K pages.\n\t * wb_calc_thresh(wb, bg_thresh) is about ~4K pages. wb_setpoint is\n\t * about ~6K pages (as the average of background and throttle wb\n\t * limits). The 3rd order polynomial will provide positive feedback if\n\t * wb_dirty is under wb_setpoint and vice versa.\n\t *\n\t * Note, that we cannot use global counters in these calculations\n\t * because we want to throttle process writing to a strictlimit wb\n\t * much earlier than global \"freerun\" is reached (~23MB vs. ~2.3GB\n\t * in the example above).\n\t */\n\tif (unlikely(wb->bdi->capabilities & BDI_CAP_STRICTLIMIT)) {\n\t\tlong long wb_pos_ratio;\n\n\t\tif (dtc->wb_dirty < 8) {\n\t\t\tdtc->pos_ratio = min_t(long long, pos_ratio * 2,\n\t\t\t\t\t   2 << RATELIMIT_CALC_SHIFT);\n\t\t\treturn;\n\t\t}\n\n\t\tif (dtc->wb_dirty >= wb_thresh)\n\t\t\treturn;\n\n\t\twb_setpoint = dirty_freerun_ceiling(wb_thresh,\n\t\t\t\t\t\t    dtc->wb_bg_thresh);\n\n\t\tif (wb_setpoint == 0 || wb_setpoint == wb_thresh)\n\t\t\treturn;\n\n\t\twb_pos_ratio = pos_ratio_polynom(wb_setpoint, dtc->wb_dirty,\n\t\t\t\t\t\t wb_thresh);\n\n\t\t/*\n\t\t * Typically, for strictlimit case, wb_setpoint << setpoint\n\t\t * and pos_ratio >> wb_pos_ratio. In the other words global\n\t\t * state (\"dirty\") is not limiting factor and we have to\n\t\t * make decision based on wb counters. But there is an\n\t\t * important case when global pos_ratio should get precedence:\n\t\t * global limits are exceeded (e.g. due to activities on other\n\t\t * wb's) while given strictlimit wb is below limit.\n\t\t *\n\t\t * \"pos_ratio * wb_pos_ratio\" would work for the case above,\n\t\t * but it would look too non-natural for the case of all\n\t\t * activity in the system coming from a single strictlimit wb\n\t\t * with bdi->max_ratio == 100%.\n\t\t *\n\t\t * Note that min() below somewhat changes the dynamics of the\n\t\t * control system. Normally, pos_ratio value can be well over 3\n\t\t * (when globally we are at freerun and wb is well below wb\n\t\t * setpoint). Now the maximum pos_ratio in the same situation\n\t\t * is 2. We might want to tweak this if we observe the control\n\t\t * system is too slow to adapt.\n\t\t */\n\t\tdtc->pos_ratio = min(pos_ratio, wb_pos_ratio);\n\t\treturn;\n\t}\n\n\t/*\n\t * We have computed basic pos_ratio above based on global situation. If\n\t * the wb is over/under its share of dirty pages, we want to scale\n\t * pos_ratio further down/up. That is done by the following mechanism.\n\t */\n\n\t/*\n\t * wb setpoint\n\t *\n\t *        f(wb_dirty) := 1.0 + k * (wb_dirty - wb_setpoint)\n\t *\n\t *                        x_intercept - wb_dirty\n\t *                     := --------------------------\n\t *                        x_intercept - wb_setpoint\n\t *\n\t * The main wb control line is a linear function that subjects to\n\t *\n\t * (1) f(wb_setpoint) = 1.0\n\t * (2) k = - 1 / (8 * write_bw)  (in single wb case)\n\t *     or equally: x_intercept = wb_setpoint + 8 * write_bw\n\t *\n\t * For single wb case, the dirty pages are observed to fluctuate\n\t * regularly within range\n\t *        [wb_setpoint - write_bw/2, wb_setpoint + write_bw/2]\n\t * for various filesystems, where (2) can yield in a reasonable 12.5%\n\t * fluctuation range for pos_ratio.\n\t *\n\t * For JBOD case, wb_thresh (not wb_dirty!) could fluctuate up to its\n\t * own size, so move the slope over accordingly and choose a slope that\n\t * yields 100% pos_ratio fluctuation on suddenly doubled wb_thresh.\n\t */\n\tif (unlikely(wb_thresh > dtc->thresh))\n\t\twb_thresh = dtc->thresh;\n\t/*\n\t * It's very possible that wb_thresh is close to 0 not because the\n\t * device is slow, but that it has remained inactive for long time.\n\t * Honour such devices a reasonable good (hopefully IO efficient)\n\t * threshold, so that the occasional writes won't be blocked and active\n\t * writes can rampup the threshold quickly.\n\t */\n\twb_thresh = max(wb_thresh, (limit - dtc->dirty) / 8);\n\t/*\n\t * scale global setpoint to wb's:\n\t *\twb_setpoint = setpoint * wb_thresh / thresh\n\t */\n\tx = div_u64((u64)wb_thresh << 16, dtc->thresh | 1);\n\twb_setpoint = setpoint * (u64)x >> 16;\n\t/*\n\t * Use span=(8*write_bw) in single wb case as indicated by\n\t * (thresh - wb_thresh ~= 0) and transit to wb_thresh in JBOD case.\n\t *\n\t *        wb_thresh                    thresh - wb_thresh\n\t * span = --------- * (8 * write_bw) + ------------------ * wb_thresh\n\t *         thresh                           thresh\n\t */\n\tspan = (dtc->thresh - wb_thresh + 8 * write_bw) * (u64)x >> 16;\n\tx_intercept = wb_setpoint + span;\n\n\tif (dtc->wb_dirty < x_intercept - span / 4) {\n\t\tpos_ratio = div64_u64(pos_ratio * (x_intercept - dtc->wb_dirty),\n\t\t\t\t      (x_intercept - wb_setpoint) | 1);\n\t} else\n\t\tpos_ratio /= 4;\n\n\t/*\n\t * wb reserve area, safeguard against dirty pool underrun and disk idle\n\t * It may push the desired control point of global dirty pages higher\n\t * than setpoint.\n\t */\n\tx_intercept = wb_thresh / 2;\n\tif (dtc->wb_dirty < x_intercept) {\n\t\tif (dtc->wb_dirty > x_intercept / 8)\n\t\t\tpos_ratio = div_u64(pos_ratio * x_intercept,\n\t\t\t\t\t    dtc->wb_dirty);\n\t\telse\n\t\t\tpos_ratio *= 8;\n\t}\n\n\tdtc->pos_ratio = pos_ratio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_dirty_limits",
          "args": [
            "mdtc"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "wb_dirty_limits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1512-1551",
          "snippet": "static inline void wb_dirty_limits(struct dirty_throttle_control *dtc)\n{\n\tstruct bdi_writeback *wb = dtc->wb;\n\tunsigned long wb_reclaimable;\n\n\t/*\n\t * wb_thresh is not treated as some limiting factor as\n\t * dirty_thresh, due to reasons\n\t * - in JBOD setup, wb_thresh can fluctuate a lot\n\t * - in a system with HDD and USB key, the USB key may somehow\n\t *   go into state (wb_dirty >> wb_thresh) either because\n\t *   wb_dirty starts high, or because wb_thresh drops low.\n\t *   In this case we don't want to hard throttle the USB key\n\t *   dirtiers for 100 seconds until wb_dirty drops under\n\t *   wb_thresh. Instead the auxiliary wb control line in\n\t *   wb_position_ratio() will let the dirtier task progress\n\t *   at some rate <= (write_bw / 2) for bringing down wb_dirty.\n\t */\n\tdtc->wb_thresh = __wb_calc_thresh(dtc);\n\tdtc->wb_bg_thresh = dtc->thresh ?\n\t\tdiv_u64((u64)dtc->wb_thresh * dtc->bg_thresh, dtc->thresh) : 0;\n\n\t/*\n\t * In order to avoid the stacked BDI deadlock we need\n\t * to ensure we accurately count the 'dirty' pages when\n\t * the threshold is low.\n\t *\n\t * Otherwise it would be possible to get thresh+n pages\n\t * reported dirty, even though there are thresh-m pages\n\t * actually dirty; with m+n sitting in the percpu\n\t * deltas.\n\t */\n\tif (dtc->wb_thresh < 2 * wb_stat_error()) {\n\t\twb_reclaimable = wb_stat_sum(wb, WB_RECLAIMABLE);\n\t\tdtc->wb_dirty = wb_reclaimable + wb_stat_sum(wb, WB_WRITEBACK);\n\t} else {\n\t\twb_reclaimable = wb_stat(wb, WB_RECLAIMABLE);\n\t\tdtc->wb_dirty = wb_reclaimable + wb_stat(wb, WB_WRITEBACK);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic inline void wb_dirty_limits(struct dirty_throttle_control *dtc)\n{\n\tstruct bdi_writeback *wb = dtc->wb;\n\tunsigned long wb_reclaimable;\n\n\t/*\n\t * wb_thresh is not treated as some limiting factor as\n\t * dirty_thresh, due to reasons\n\t * - in JBOD setup, wb_thresh can fluctuate a lot\n\t * - in a system with HDD and USB key, the USB key may somehow\n\t *   go into state (wb_dirty >> wb_thresh) either because\n\t *   wb_dirty starts high, or because wb_thresh drops low.\n\t *   In this case we don't want to hard throttle the USB key\n\t *   dirtiers for 100 seconds until wb_dirty drops under\n\t *   wb_thresh. Instead the auxiliary wb control line in\n\t *   wb_position_ratio() will let the dirtier task progress\n\t *   at some rate <= (write_bw / 2) for bringing down wb_dirty.\n\t */\n\tdtc->wb_thresh = __wb_calc_thresh(dtc);\n\tdtc->wb_bg_thresh = dtc->thresh ?\n\t\tdiv_u64((u64)dtc->wb_thresh * dtc->bg_thresh, dtc->thresh) : 0;\n\n\t/*\n\t * In order to avoid the stacked BDI deadlock we need\n\t * to ensure we accurately count the 'dirty' pages when\n\t * the threshold is low.\n\t *\n\t * Otherwise it would be possible to get thresh+n pages\n\t * reported dirty, even though there are thresh-m pages\n\t * actually dirty; with m+n sitting in the percpu\n\t * deltas.\n\t */\n\tif (dtc->wb_thresh < 2 * wb_stat_error()) {\n\t\twb_reclaimable = wb_stat_sum(wb, WB_RECLAIMABLE);\n\t\tdtc->wb_dirty = wb_reclaimable + wb_stat_sum(wb, WB_WRITEBACK);\n\t} else {\n\t\twb_reclaimable = wb_stat(wb, WB_RECLAIMABLE);\n\t\tdtc->wb_dirty = wb_reclaimable + wb_stat(wb, WB_WRITEBACK);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_start_background_writeback",
          "args": [
            "wb"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!writeback_in_progress(wb)"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeback_in_progress",
          "args": [
            "wb"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dirty_poll_interval",
          "args": [
            "m_dirty",
            "m_thresh"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "dirty_poll_interval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1409-1416",
          "snippet": "static unsigned long dirty_poll_interval(unsigned long dirty,\n\t\t\t\t\t unsigned long thresh)\n{\n\tif (thresh > dirty)\n\t\treturn 1UL << (ilog2(thresh - dirty) >> 1);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned long dirty_poll_interval(unsigned long dirty,\n\t\t\t\t\t unsigned long thresh)\n{\n\tif (thresh > dirty)\n\t\treturn 1UL << (ilog2(thresh - dirty) >> 1);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dirty_freerun_ceiling",
          "args": [
            "m_thresh",
            "m_bg_thresh"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "dirty_freerun_ceiling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "715-719",
          "snippet": "static unsigned long dirty_freerun_ceiling(unsigned long thresh,\n\t\t\t\t\t   unsigned long bg_thresh)\n{\n\treturn (thresh + bg_thresh) / 2;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned long dirty_freerun_ceiling(unsigned long thresh,\n\t\t\t\t\t   unsigned long bg_thresh)\n{\n\treturn (thresh + bg_thresh) / 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "strictlimit"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain_dirty_limits",
          "args": [
            "mdtc"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "domain_dirty_limits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "392-448",
          "snippet": "static void domain_dirty_limits(struct dirty_throttle_control *dtc)\n{\n\tconst unsigned long available_memory = dtc->avail;\n\tstruct dirty_throttle_control *gdtc = mdtc_gdtc(dtc);\n\tunsigned long bytes = vm_dirty_bytes;\n\tunsigned long bg_bytes = dirty_background_bytes;\n\t/* convert ratios to per-PAGE_SIZE for higher precision */\n\tunsigned long ratio = (vm_dirty_ratio * PAGE_SIZE) / 100;\n\tunsigned long bg_ratio = (dirty_background_ratio * PAGE_SIZE) / 100;\n\tunsigned long thresh;\n\tunsigned long bg_thresh;\n\tstruct task_struct *tsk;\n\n\t/* gdtc is !NULL iff @dtc is for memcg domain */\n\tif (gdtc) {\n\t\tunsigned long global_avail = gdtc->avail;\n\n\t\t/*\n\t\t * The byte settings can't be applied directly to memcg\n\t\t * domains.  Convert them to ratios by scaling against\n\t\t * globally available memory.  As the ratios are in\n\t\t * per-PAGE_SIZE, they can be obtained by dividing bytes by\n\t\t * number of pages.\n\t\t */\n\t\tif (bytes)\n\t\t\tratio = min(DIV_ROUND_UP(bytes, global_avail),\n\t\t\t\t    PAGE_SIZE);\n\t\tif (bg_bytes)\n\t\t\tbg_ratio = min(DIV_ROUND_UP(bg_bytes, global_avail),\n\t\t\t\t       PAGE_SIZE);\n\t\tbytes = bg_bytes = 0;\n\t}\n\n\tif (bytes)\n\t\tthresh = DIV_ROUND_UP(bytes, PAGE_SIZE);\n\telse\n\t\tthresh = (ratio * available_memory) / PAGE_SIZE;\n\n\tif (bg_bytes)\n\t\tbg_thresh = DIV_ROUND_UP(bg_bytes, PAGE_SIZE);\n\telse\n\t\tbg_thresh = (bg_ratio * available_memory) / PAGE_SIZE;\n\n\tif (bg_thresh >= thresh)\n\t\tbg_thresh = thresh / 2;\n\ttsk = current;\n\tif (tsk->flags & PF_LESS_THROTTLE || rt_task(tsk)) {\n\t\tbg_thresh += bg_thresh / 4 + global_wb_domain.dirty_limit / 32;\n\t\tthresh += thresh / 4 + global_wb_domain.dirty_limit / 32;\n\t}\n\tdtc->thresh = thresh;\n\tdtc->bg_thresh = bg_thresh;\n\n\t/* we should eventually report the domain in the TP */\n\tif (!gdtc)\n\t\ttrace_global_dirty_state(bg_thresh, thresh);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int dirty_background_ratio = 10;",
            "unsigned long dirty_background_bytes;",
            "int vm_dirty_ratio = 20;",
            "unsigned long vm_dirty_bytes;",
            "struct wb_domain global_wb_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint dirty_background_ratio = 10;\nunsigned long dirty_background_bytes;\nint vm_dirty_ratio = 20;\nunsigned long vm_dirty_bytes;\nstruct wb_domain global_wb_domain;\n\nstatic void domain_dirty_limits(struct dirty_throttle_control *dtc)\n{\n\tconst unsigned long available_memory = dtc->avail;\n\tstruct dirty_throttle_control *gdtc = mdtc_gdtc(dtc);\n\tunsigned long bytes = vm_dirty_bytes;\n\tunsigned long bg_bytes = dirty_background_bytes;\n\t/* convert ratios to per-PAGE_SIZE for higher precision */\n\tunsigned long ratio = (vm_dirty_ratio * PAGE_SIZE) / 100;\n\tunsigned long bg_ratio = (dirty_background_ratio * PAGE_SIZE) / 100;\n\tunsigned long thresh;\n\tunsigned long bg_thresh;\n\tstruct task_struct *tsk;\n\n\t/* gdtc is !NULL iff @dtc is for memcg domain */\n\tif (gdtc) {\n\t\tunsigned long global_avail = gdtc->avail;\n\n\t\t/*\n\t\t * The byte settings can't be applied directly to memcg\n\t\t * domains.  Convert them to ratios by scaling against\n\t\t * globally available memory.  As the ratios are in\n\t\t * per-PAGE_SIZE, they can be obtained by dividing bytes by\n\t\t * number of pages.\n\t\t */\n\t\tif (bytes)\n\t\t\tratio = min(DIV_ROUND_UP(bytes, global_avail),\n\t\t\t\t    PAGE_SIZE);\n\t\tif (bg_bytes)\n\t\t\tbg_ratio = min(DIV_ROUND_UP(bg_bytes, global_avail),\n\t\t\t\t       PAGE_SIZE);\n\t\tbytes = bg_bytes = 0;\n\t}\n\n\tif (bytes)\n\t\tthresh = DIV_ROUND_UP(bytes, PAGE_SIZE);\n\telse\n\t\tthresh = (ratio * available_memory) / PAGE_SIZE;\n\n\tif (bg_bytes)\n\t\tbg_thresh = DIV_ROUND_UP(bg_bytes, PAGE_SIZE);\n\telse\n\t\tbg_thresh = (bg_ratio * available_memory) / PAGE_SIZE;\n\n\tif (bg_thresh >= thresh)\n\t\tbg_thresh = thresh / 2;\n\ttsk = current;\n\tif (tsk->flags & PF_LESS_THROTTLE || rt_task(tsk)) {\n\t\tbg_thresh += bg_thresh / 4 + global_wb_domain.dirty_limit / 32;\n\t\tthresh += thresh / 4 + global_wb_domain.dirty_limit / 32;\n\t}\n\tdtc->thresh = thresh;\n\tdtc->bg_thresh = bg_thresh;\n\n\t/* we should eventually report the domain in the TP */\n\tif (!gdtc)\n\t\ttrace_global_dirty_state(bg_thresh, thresh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mdtc_calc_avail",
          "args": [
            "mdtc",
            "filepages",
            "headroom"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "mdtc_calc_avail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "731-740",
          "snippet": "static void mdtc_calc_avail(struct dirty_throttle_control *mdtc,\n\t\t\t    unsigned long filepages, unsigned long headroom)\n{\n\tstruct dirty_throttle_control *gdtc = mdtc_gdtc(mdtc);\n\tunsigned long clean = filepages - min(filepages, mdtc->dirty);\n\tunsigned long global_clean = gdtc->avail - min(gdtc->avail, gdtc->dirty);\n\tunsigned long other_clean = global_clean - min(global_clean, clean);\n\n\tmdtc->avail = filepages + min(headroom, other_clean);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void mdtc_calc_avail(struct dirty_throttle_control *mdtc,\n\t\t\t    unsigned long filepages, unsigned long headroom)\n{\n\tstruct dirty_throttle_control *gdtc = mdtc_gdtc(mdtc);\n\tunsigned long clean = filepages - min(filepages, mdtc->dirty);\n\tunsigned long global_clean = gdtc->avail - min(gdtc->avail, gdtc->dirty);\n\tunsigned long other_clean = global_clean - min(global_clean, clean);\n\n\tmdtc->avail = filepages + min(headroom, other_clean);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_wb_stats",
          "args": [
            "wb",
            "&filepages",
            "&headroom",
            "&mdtc->dirty",
            "&writeback"
          ],
          "line": 1621
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_wb_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3871-3893",
          "snippet": "void mem_cgroup_wb_stats(struct bdi_writeback *wb, unsigned long *pfilepages,\n\t\t\t unsigned long *pheadroom, unsigned long *pdirty,\n\t\t\t unsigned long *pwriteback)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(wb->memcg_css);\n\tstruct mem_cgroup *parent;\n\n\t*pdirty = memcg_page_state(memcg, NR_FILE_DIRTY);\n\n\t/* this should eventually include NR_UNSTABLE_NFS */\n\t*pwriteback = memcg_page_state(memcg, NR_WRITEBACK);\n\t*pfilepages = mem_cgroup_nr_lru_pages(memcg, (1 << LRU_INACTIVE_FILE) |\n\t\t\t\t\t\t     (1 << LRU_ACTIVE_FILE));\n\t*pheadroom = PAGE_COUNTER_MAX;\n\n\twhile ((parent = parent_mem_cgroup(memcg))) {\n\t\tunsigned long ceiling = min(memcg->memory.max, memcg->high);\n\t\tunsigned long used = page_counter_read(&memcg->memory);\n\n\t\t*pheadroom = min(*pheadroom, ceiling - min(ceiling, used));\n\t\tmemcg = parent;\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_wb_stats(struct bdi_writeback *wb, unsigned long *pfilepages,\n\t\t\t unsigned long *pheadroom, unsigned long *pdirty,\n\t\t\t unsigned long *pwriteback)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(wb->memcg_css);\n\tstruct mem_cgroup *parent;\n\n\t*pdirty = memcg_page_state(memcg, NR_FILE_DIRTY);\n\n\t/* this should eventually include NR_UNSTABLE_NFS */\n\t*pwriteback = memcg_page_state(memcg, NR_WRITEBACK);\n\t*pfilepages = mem_cgroup_nr_lru_pages(memcg, (1 << LRU_INACTIVE_FILE) |\n\t\t\t\t\t\t     (1 << LRU_ACTIVE_FILE));\n\t*pheadroom = PAGE_COUNTER_MAX;\n\n\twhile ((parent = parent_mem_cgroup(memcg))) {\n\t\tunsigned long ceiling = min(memcg->memory.max, memcg->high);\n\t\tunsigned long used = page_counter_read(&memcg->memory);\n\n\t\t*pheadroom = min(*pheadroom, ceiling - min(ceiling, used));\n\t\tmemcg = parent;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "strictlimit"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_WRITEBACK"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_dirtyable_memory",
          "args": [],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "global_dirtyable_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "361-380",
          "snippet": "static unsigned long global_dirtyable_memory(void)\n{\n\tunsigned long x;\n\n\tx = global_zone_page_state(NR_FREE_PAGES);\n\t/*\n\t * Pages reserved for the kernel should not be considered\n\t * dirtyable, to prevent a situation where reclaim has to\n\t * clean pages in order to balance the zones.\n\t */\n\tx -= min(x, totalreserve_pages);\n\n\tx += global_node_page_state(NR_INACTIVE_FILE);\n\tx += global_node_page_state(NR_ACTIVE_FILE);\n\n\tif (!vm_highmem_is_dirtyable)\n\t\tx -= highmem_dirtyable_memory(x);\n\n\treturn x + 1;\t/* Ensure that we never return 0 */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int vm_highmem_is_dirtyable;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint vm_highmem_is_dirtyable;\n\nstatic unsigned long global_dirtyable_memory(void)\n{\n\tunsigned long x;\n\n\tx = global_zone_page_state(NR_FREE_PAGES);\n\t/*\n\t * Pages reserved for the kernel should not be considered\n\t * dirtyable, to prevent a situation where reclaim has to\n\t * clean pages in order to balance the zones.\n\t */\n\tx -= min(x, totalreserve_pages);\n\n\tx += global_node_page_state(NR_INACTIVE_FILE);\n\tx += global_node_page_state(NR_ACTIVE_FILE);\n\n\tif (!vm_highmem_is_dirtyable)\n\t\tx -= highmem_dirtyable_memory(x);\n\n\treturn x + 1;\t/* Ensure that we never return 0 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_UNSTABLE_NFS"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_FILE_DIRTY"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdtc_valid",
          "args": [
            "&mdtc_stor"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "mdtc_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "222-225",
          "snippet": "static bool mdtc_valid(struct dirty_throttle_control *dtc)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic bool mdtc_valid(struct dirty_throttle_control *dtc)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MDTC_INIT",
          "args": [
            "wb",
            "&gdtc_stor"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDTC_INIT",
          "args": [
            "wb"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define RATELIMIT_CALC_SHIFT\t10\n#define BANDWIDTH_INTERVAL\tmax(HZ/5, 1)\n\nint laptop_mode;\n\nstatic void balance_dirty_pages(struct bdi_writeback *wb,\n\t\t\t\tunsigned long pages_dirtied)\n{\n\tstruct dirty_throttle_control gdtc_stor = { GDTC_INIT(wb) };\n\tstruct dirty_throttle_control mdtc_stor = { MDTC_INIT(wb, &gdtc_stor) };\n\tstruct dirty_throttle_control * const gdtc = &gdtc_stor;\n\tstruct dirty_throttle_control * const mdtc = mdtc_valid(&mdtc_stor) ?\n\t\t\t\t\t\t     &mdtc_stor : NULL;\n\tstruct dirty_throttle_control *sdtc;\n\tunsigned long nr_reclaimable;\t/* = file_dirty + unstable_nfs */\n\tlong period;\n\tlong pause;\n\tlong max_pause;\n\tlong min_pause;\n\tint nr_dirtied_pause;\n\tbool dirty_exceeded = false;\n\tunsigned long task_ratelimit;\n\tunsigned long dirty_ratelimit;\n\tstruct backing_dev_info *bdi = wb->bdi;\n\tbool strictlimit = bdi->capabilities & BDI_CAP_STRICTLIMIT;\n\tunsigned long start_time = jiffies;\n\n\tfor (;;) {\n\t\tunsigned long now = jiffies;\n\t\tunsigned long dirty, thresh, bg_thresh;\n\t\tunsigned long m_dirty = 0;\t/* stop bogus uninit warnings */\n\t\tunsigned long m_thresh = 0;\n\t\tunsigned long m_bg_thresh = 0;\n\n\t\t/*\n\t\t * Unstable writes are a feature of certain networked\n\t\t * filesystems (i.e. NFS) in which data may have been\n\t\t * written to the server's write cache, but has not yet\n\t\t * been flushed to permanent storage.\n\t\t */\n\t\tnr_reclaimable = global_node_page_state(NR_FILE_DIRTY) +\n\t\t\t\t\tglobal_node_page_state(NR_UNSTABLE_NFS);\n\t\tgdtc->avail = global_dirtyable_memory();\n\t\tgdtc->dirty = nr_reclaimable + global_node_page_state(NR_WRITEBACK);\n\n\t\tdomain_dirty_limits(gdtc);\n\n\t\tif (unlikely(strictlimit)) {\n\t\t\twb_dirty_limits(gdtc);\n\n\t\t\tdirty = gdtc->wb_dirty;\n\t\t\tthresh = gdtc->wb_thresh;\n\t\t\tbg_thresh = gdtc->wb_bg_thresh;\n\t\t} else {\n\t\t\tdirty = gdtc->dirty;\n\t\t\tthresh = gdtc->thresh;\n\t\t\tbg_thresh = gdtc->bg_thresh;\n\t\t}\n\n\t\tif (mdtc) {\n\t\t\tunsigned long filepages, headroom, writeback;\n\n\t\t\t/*\n\t\t\t * If @wb belongs to !root memcg, repeat the same\n\t\t\t * basic calculations for the memcg domain.\n\t\t\t */\n\t\t\tmem_cgroup_wb_stats(wb, &filepages, &headroom,\n\t\t\t\t\t    &mdtc->dirty, &writeback);\n\t\t\tmdtc->dirty += writeback;\n\t\t\tmdtc_calc_avail(mdtc, filepages, headroom);\n\n\t\t\tdomain_dirty_limits(mdtc);\n\n\t\t\tif (unlikely(strictlimit)) {\n\t\t\t\twb_dirty_limits(mdtc);\n\t\t\t\tm_dirty = mdtc->wb_dirty;\n\t\t\t\tm_thresh = mdtc->wb_thresh;\n\t\t\t\tm_bg_thresh = mdtc->wb_bg_thresh;\n\t\t\t} else {\n\t\t\t\tm_dirty = mdtc->dirty;\n\t\t\t\tm_thresh = mdtc->thresh;\n\t\t\t\tm_bg_thresh = mdtc->bg_thresh;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Throttle it only when the background writeback cannot\n\t\t * catch-up. This avoids (excessively) small writeouts\n\t\t * when the wb limits are ramping up in case of !strictlimit.\n\t\t *\n\t\t * In strictlimit case make decision based on the wb counters\n\t\t * and limits. Small writeouts when the wb limits are ramping\n\t\t * up are the price we consciously pay for strictlimit-ing.\n\t\t *\n\t\t * If memcg domain is in effect, @dirty should be under\n\t\t * both global and memcg freerun ceilings.\n\t\t */\n\t\tif (dirty <= dirty_freerun_ceiling(thresh, bg_thresh) &&\n\t\t    (!mdtc ||\n\t\t     m_dirty <= dirty_freerun_ceiling(m_thresh, m_bg_thresh))) {\n\t\t\tunsigned long intv = dirty_poll_interval(dirty, thresh);\n\t\t\tunsigned long m_intv = ULONG_MAX;\n\n\t\t\tcurrent->dirty_paused_when = now;\n\t\t\tcurrent->nr_dirtied = 0;\n\t\t\tif (mdtc)\n\t\t\t\tm_intv = dirty_poll_interval(m_dirty, m_thresh);\n\t\t\tcurrent->nr_dirtied_pause = min(intv, m_intv);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(!writeback_in_progress(wb)))\n\t\t\twb_start_background_writeback(wb);\n\n\t\t/*\n\t\t * Calculate global domain's pos_ratio and select the\n\t\t * global dtc by default.\n\t\t */\n\t\tif (!strictlimit)\n\t\t\twb_dirty_limits(gdtc);\n\n\t\tdirty_exceeded = (gdtc->wb_dirty > gdtc->wb_thresh) &&\n\t\t\t((gdtc->dirty > gdtc->thresh) || strictlimit);\n\n\t\twb_position_ratio(gdtc);\n\t\tsdtc = gdtc;\n\n\t\tif (mdtc) {\n\t\t\t/*\n\t\t\t * If memcg domain is in effect, calculate its\n\t\t\t * pos_ratio.  @wb should satisfy constraints from\n\t\t\t * both global and memcg domains.  Choose the one\n\t\t\t * w/ lower pos_ratio.\n\t\t\t */\n\t\t\tif (!strictlimit)\n\t\t\t\twb_dirty_limits(mdtc);\n\n\t\t\tdirty_exceeded |= (mdtc->wb_dirty > mdtc->wb_thresh) &&\n\t\t\t\t((mdtc->dirty > mdtc->thresh) || strictlimit);\n\n\t\t\twb_position_ratio(mdtc);\n\t\t\tif (mdtc->pos_ratio < gdtc->pos_ratio)\n\t\t\t\tsdtc = mdtc;\n\t\t}\n\n\t\tif (dirty_exceeded && !wb->dirty_exceeded)\n\t\t\twb->dirty_exceeded = 1;\n\n\t\tif (time_is_before_jiffies(wb->bw_time_stamp +\n\t\t\t\t\t   BANDWIDTH_INTERVAL)) {\n\t\t\tspin_lock(&wb->list_lock);\n\t\t\t__wb_update_bandwidth(gdtc, mdtc, start_time, true);\n\t\t\tspin_unlock(&wb->list_lock);\n\t\t}\n\n\t\t/* throttle according to the chosen dtc */\n\t\tdirty_ratelimit = wb->dirty_ratelimit;\n\t\ttask_ratelimit = ((u64)dirty_ratelimit * sdtc->pos_ratio) >>\n\t\t\t\t\t\t\tRATELIMIT_CALC_SHIFT;\n\t\tmax_pause = wb_max_pause(wb, sdtc->wb_dirty);\n\t\tmin_pause = wb_min_pause(wb, max_pause,\n\t\t\t\t\t task_ratelimit, dirty_ratelimit,\n\t\t\t\t\t &nr_dirtied_pause);\n\n\t\tif (unlikely(task_ratelimit == 0)) {\n\t\t\tperiod = max_pause;\n\t\t\tpause = max_pause;\n\t\t\tgoto pause;\n\t\t}\n\t\tperiod = HZ * pages_dirtied / task_ratelimit;\n\t\tpause = period;\n\t\tif (current->dirty_paused_when)\n\t\t\tpause -= now - current->dirty_paused_when;\n\t\t/*\n\t\t * For less than 1s think time (ext3/4 may block the dirtier\n\t\t * for up to 800ms from time to time on 1-HDD; so does xfs,\n\t\t * however at much less frequency), try to compensate it in\n\t\t * future periods by updating the virtual time; otherwise just\n\t\t * do a reset, as it may be a light dirtier.\n\t\t */\n\t\tif (pause < min_pause) {\n\t\t\ttrace_balance_dirty_pages(wb,\n\t\t\t\t\t\t  sdtc->thresh,\n\t\t\t\t\t\t  sdtc->bg_thresh,\n\t\t\t\t\t\t  sdtc->dirty,\n\t\t\t\t\t\t  sdtc->wb_thresh,\n\t\t\t\t\t\t  sdtc->wb_dirty,\n\t\t\t\t\t\t  dirty_ratelimit,\n\t\t\t\t\t\t  task_ratelimit,\n\t\t\t\t\t\t  pages_dirtied,\n\t\t\t\t\t\t  period,\n\t\t\t\t\t\t  min(pause, 0L),\n\t\t\t\t\t\t  start_time);\n\t\t\tif (pause < -HZ) {\n\t\t\t\tcurrent->dirty_paused_when = now;\n\t\t\t\tcurrent->nr_dirtied = 0;\n\t\t\t} else if (period) {\n\t\t\t\tcurrent->dirty_paused_when += period;\n\t\t\t\tcurrent->nr_dirtied = 0;\n\t\t\t} else if (current->nr_dirtied_pause <= pages_dirtied)\n\t\t\t\tcurrent->nr_dirtied_pause += pages_dirtied;\n\t\t\tbreak;\n\t\t}\n\t\tif (unlikely(pause > max_pause)) {\n\t\t\t/* for occasional dropped task_ratelimit */\n\t\t\tnow += min(pause - max_pause, max_pause);\n\t\t\tpause = max_pause;\n\t\t}\n\npause:\n\t\ttrace_balance_dirty_pages(wb,\n\t\t\t\t\t  sdtc->thresh,\n\t\t\t\t\t  sdtc->bg_thresh,\n\t\t\t\t\t  sdtc->dirty,\n\t\t\t\t\t  sdtc->wb_thresh,\n\t\t\t\t\t  sdtc->wb_dirty,\n\t\t\t\t\t  dirty_ratelimit,\n\t\t\t\t\t  task_ratelimit,\n\t\t\t\t\t  pages_dirtied,\n\t\t\t\t\t  period,\n\t\t\t\t\t  pause,\n\t\t\t\t\t  start_time);\n\t\t__set_current_state(TASK_KILLABLE);\n\t\twb->dirty_sleep = now;\n\t\tio_schedule_timeout(pause);\n\n\t\tcurrent->dirty_paused_when = now + pause;\n\t\tcurrent->nr_dirtied = 0;\n\t\tcurrent->nr_dirtied_pause = nr_dirtied_pause;\n\n\t\t/*\n\t\t * This is typically equal to (dirty < thresh) and can also\n\t\t * keep \"1000+ dd on a slow USB stick\" under control.\n\t\t */\n\t\tif (task_ratelimit)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * In the case of an unresponding NFS server and the NFS dirty\n\t\t * pages exceeds dirty_thresh, give the other good wb's a pipe\n\t\t * to go through, so that tasks on them still remain responsive.\n\t\t *\n\t\t * In theory 1 page is enough to keep the consumer-producer\n\t\t * pipe going: the flusher cleans 1 page => the task dirties 1\n\t\t * more page. However wb_dirty has accounting errors.  So use\n\t\t * the larger and more IO friendly wb_stat_error.\n\t\t */\n\t\tif (sdtc->wb_dirty <= wb_stat_error())\n\t\t\tbreak;\n\n\t\tif (fatal_signal_pending(current))\n\t\t\tbreak;\n\t}\n\n\tif (!dirty_exceeded && wb->dirty_exceeded)\n\t\twb->dirty_exceeded = 0;\n\n\tif (writeback_in_progress(wb))\n\t\treturn;\n\n\t/*\n\t * In laptop mode, we wait until hitting the higher threshold before\n\t * starting background writeout, and then write out all the way down\n\t * to the lower threshold.  So slow writers cause minimal disk activity.\n\t *\n\t * In normal mode, we start background writeout at the lower\n\t * background_thresh, to keep the amount of dirty memory low.\n\t */\n\tif (laptop_mode)\n\t\treturn;\n\n\tif (nr_reclaimable > gdtc->bg_thresh)\n\t\twb_start_background_writeback(wb);\n}"
  },
  {
    "function_name": "wb_dirty_limits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "1512-1551",
    "snippet": "static inline void wb_dirty_limits(struct dirty_throttle_control *dtc)\n{\n\tstruct bdi_writeback *wb = dtc->wb;\n\tunsigned long wb_reclaimable;\n\n\t/*\n\t * wb_thresh is not treated as some limiting factor as\n\t * dirty_thresh, due to reasons\n\t * - in JBOD setup, wb_thresh can fluctuate a lot\n\t * - in a system with HDD and USB key, the USB key may somehow\n\t *   go into state (wb_dirty >> wb_thresh) either because\n\t *   wb_dirty starts high, or because wb_thresh drops low.\n\t *   In this case we don't want to hard throttle the USB key\n\t *   dirtiers for 100 seconds until wb_dirty drops under\n\t *   wb_thresh. Instead the auxiliary wb control line in\n\t *   wb_position_ratio() will let the dirtier task progress\n\t *   at some rate <= (write_bw / 2) for bringing down wb_dirty.\n\t */\n\tdtc->wb_thresh = __wb_calc_thresh(dtc);\n\tdtc->wb_bg_thresh = dtc->thresh ?\n\t\tdiv_u64((u64)dtc->wb_thresh * dtc->bg_thresh, dtc->thresh) : 0;\n\n\t/*\n\t * In order to avoid the stacked BDI deadlock we need\n\t * to ensure we accurately count the 'dirty' pages when\n\t * the threshold is low.\n\t *\n\t * Otherwise it would be possible to get thresh+n pages\n\t * reported dirty, even though there are thresh-m pages\n\t * actually dirty; with m+n sitting in the percpu\n\t * deltas.\n\t */\n\tif (dtc->wb_thresh < 2 * wb_stat_error()) {\n\t\twb_reclaimable = wb_stat_sum(wb, WB_RECLAIMABLE);\n\t\tdtc->wb_dirty = wb_reclaimable + wb_stat_sum(wb, WB_WRITEBACK);\n\t} else {\n\t\twb_reclaimable = wb_stat(wb, WB_RECLAIMABLE);\n\t\tdtc->wb_dirty = wb_reclaimable + wb_stat(wb, WB_WRITEBACK);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wb_stat",
          "args": [
            "wb",
            "WB_WRITEBACK"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_stat",
          "args": [
            "wb",
            "WB_RECLAIMABLE"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_stat_sum",
          "args": [
            "wb",
            "WB_WRITEBACK"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_stat_sum",
          "args": [
            "wb",
            "WB_RECLAIMABLE"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_stat_error",
          "args": [],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "(u64)dtc->wb_thresh * dtc->bg_thresh",
            "dtc->thresh"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wb_calc_thresh",
          "args": [
            "dtc"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "__wb_calc_thresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "763-788",
          "snippet": "static unsigned long __wb_calc_thresh(struct dirty_throttle_control *dtc)\n{\n\tstruct wb_domain *dom = dtc_dom(dtc);\n\tunsigned long thresh = dtc->thresh;\n\tu64 wb_thresh;\n\tlong numerator, denominator;\n\tunsigned long wb_min_ratio, wb_max_ratio;\n\n\t/*\n\t * Calculate this BDI's share of the thresh ratio.\n\t */\n\tfprop_fraction_percpu(&dom->completions, dtc->wb_completions,\n\t\t\t      &numerator, &denominator);\n\n\twb_thresh = (thresh * (100 - bdi_min_ratio)) / 100;\n\twb_thresh *= numerator;\n\tdo_div(wb_thresh, denominator);\n\n\twb_min_max_ratio(dtc->wb, &wb_min_ratio, &wb_max_ratio);\n\n\twb_thresh += (thresh * wb_min_ratio) / 100;\n\tif (wb_thresh > (thresh * wb_max_ratio) / 100)\n\t\twb_thresh = thresh * wb_max_ratio / 100;\n\n\treturn wb_thresh;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int bdi_min_ratio;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned int bdi_min_ratio;\n\nstatic unsigned long __wb_calc_thresh(struct dirty_throttle_control *dtc)\n{\n\tstruct wb_domain *dom = dtc_dom(dtc);\n\tunsigned long thresh = dtc->thresh;\n\tu64 wb_thresh;\n\tlong numerator, denominator;\n\tunsigned long wb_min_ratio, wb_max_ratio;\n\n\t/*\n\t * Calculate this BDI's share of the thresh ratio.\n\t */\n\tfprop_fraction_percpu(&dom->completions, dtc->wb_completions,\n\t\t\t      &numerator, &denominator);\n\n\twb_thresh = (thresh * (100 - bdi_min_ratio)) / 100;\n\twb_thresh *= numerator;\n\tdo_div(wb_thresh, denominator);\n\n\twb_min_max_ratio(dtc->wb, &wb_min_ratio, &wb_max_ratio);\n\n\twb_thresh += (thresh * wb_min_ratio) / 100;\n\tif (wb_thresh > (thresh * wb_max_ratio) / 100)\n\t\twb_thresh = thresh * wb_max_ratio / 100;\n\n\treturn wb_thresh;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic inline void wb_dirty_limits(struct dirty_throttle_control *dtc)\n{\n\tstruct bdi_writeback *wb = dtc->wb;\n\tunsigned long wb_reclaimable;\n\n\t/*\n\t * wb_thresh is not treated as some limiting factor as\n\t * dirty_thresh, due to reasons\n\t * - in JBOD setup, wb_thresh can fluctuate a lot\n\t * - in a system with HDD and USB key, the USB key may somehow\n\t *   go into state (wb_dirty >> wb_thresh) either because\n\t *   wb_dirty starts high, or because wb_thresh drops low.\n\t *   In this case we don't want to hard throttle the USB key\n\t *   dirtiers for 100 seconds until wb_dirty drops under\n\t *   wb_thresh. Instead the auxiliary wb control line in\n\t *   wb_position_ratio() will let the dirtier task progress\n\t *   at some rate <= (write_bw / 2) for bringing down wb_dirty.\n\t */\n\tdtc->wb_thresh = __wb_calc_thresh(dtc);\n\tdtc->wb_bg_thresh = dtc->thresh ?\n\t\tdiv_u64((u64)dtc->wb_thresh * dtc->bg_thresh, dtc->thresh) : 0;\n\n\t/*\n\t * In order to avoid the stacked BDI deadlock we need\n\t * to ensure we accurately count the 'dirty' pages when\n\t * the threshold is low.\n\t *\n\t * Otherwise it would be possible to get thresh+n pages\n\t * reported dirty, even though there are thresh-m pages\n\t * actually dirty; with m+n sitting in the percpu\n\t * deltas.\n\t */\n\tif (dtc->wb_thresh < 2 * wb_stat_error()) {\n\t\twb_reclaimable = wb_stat_sum(wb, WB_RECLAIMABLE);\n\t\tdtc->wb_dirty = wb_reclaimable + wb_stat_sum(wb, WB_WRITEBACK);\n\t} else {\n\t\twb_reclaimable = wb_stat(wb, WB_RECLAIMABLE);\n\t\tdtc->wb_dirty = wb_reclaimable + wb_stat(wb, WB_WRITEBACK);\n\t}\n}"
  },
  {
    "function_name": "wb_min_pause",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "1437-1510",
    "snippet": "static long wb_min_pause(struct bdi_writeback *wb,\n\t\t\t long max_pause,\n\t\t\t unsigned long task_ratelimit,\n\t\t\t unsigned long dirty_ratelimit,\n\t\t\t int *nr_dirtied_pause)\n{\n\tlong hi = ilog2(wb->avg_write_bandwidth);\n\tlong lo = ilog2(wb->dirty_ratelimit);\n\tlong t;\t\t/* target pause */\n\tlong pause;\t/* estimated next pause */\n\tint pages;\t/* target nr_dirtied_pause */\n\n\t/* target for 10ms pause on 1-dd case */\n\tt = max(1, HZ / 100);\n\n\t/*\n\t * Scale up pause time for concurrent dirtiers in order to reduce CPU\n\t * overheads.\n\t *\n\t * (N * 10ms) on 2^N concurrent tasks.\n\t */\n\tif (hi > lo)\n\t\tt += (hi - lo) * (10 * HZ) / 1024;\n\n\t/*\n\t * This is a bit convoluted. We try to base the next nr_dirtied_pause\n\t * on the much more stable dirty_ratelimit. However the next pause time\n\t * will be computed based on task_ratelimit and the two rate limits may\n\t * depart considerably at some time. Especially if task_ratelimit goes\n\t * below dirty_ratelimit/2 and the target pause is max_pause, the next\n\t * pause time will be max_pause*2 _trimmed down_ to max_pause.  As a\n\t * result task_ratelimit won't be executed faithfully, which could\n\t * eventually bring down dirty_ratelimit.\n\t *\n\t * We apply two rules to fix it up:\n\t * 1) try to estimate the next pause time and if necessary, use a lower\n\t *    nr_dirtied_pause so as not to exceed max_pause. When this happens,\n\t *    nr_dirtied_pause will be \"dancing\" with task_ratelimit.\n\t * 2) limit the target pause time to max_pause/2, so that the normal\n\t *    small fluctuations of task_ratelimit won't trigger rule (1) and\n\t *    nr_dirtied_pause will remain as stable as dirty_ratelimit.\n\t */\n\tt = min(t, 1 + max_pause / 2);\n\tpages = dirty_ratelimit * t / roundup_pow_of_two(HZ);\n\n\t/*\n\t * Tiny nr_dirtied_pause is found to hurt I/O performance in the test\n\t * case fio-mmap-randwrite-64k, which does 16*{sync read, async write}.\n\t * When the 16 consecutive reads are often interrupted by some dirty\n\t * throttling pause during the async writes, cfq will go into idles\n\t * (deadline is fine). So push nr_dirtied_pause as high as possible\n\t * until reaches DIRTY_POLL_THRESH=32 pages.\n\t */\n\tif (pages < DIRTY_POLL_THRESH) {\n\t\tt = max_pause;\n\t\tpages = dirty_ratelimit * t / roundup_pow_of_two(HZ);\n\t\tif (pages > DIRTY_POLL_THRESH) {\n\t\t\tpages = DIRTY_POLL_THRESH;\n\t\t\tt = HZ * DIRTY_POLL_THRESH / dirty_ratelimit;\n\t\t}\n\t}\n\n\tpause = HZ * pages / (task_ratelimit + 1);\n\tif (pause > max_pause) {\n\t\tt = max_pause;\n\t\tpages = task_ratelimit * t / roundup_pow_of_two(HZ);\n\t}\n\n\t*nr_dirtied_pause = pages;\n\t/*\n\t * The minimal pause time will normally be half the target pause time.\n\t */\n\treturn pages >= DIRTY_POLL_THRESH ? 1 + t / 2 : t;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define DIRTY_POLL_THRESH\t(128 >> (PAGE_SHIFT - 10))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "HZ"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "HZ"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "HZ"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "t",
            "1 + max_pause / 2"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_set_min_ratio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "674-693",
          "snippet": "int bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)\n{\n\tint ret = 0;\n\n\tspin_lock_bh(&bdi_lock);\n\tif (min_ratio > bdi->max_ratio) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tmin_ratio -= bdi->min_ratio;\n\t\tif (bdi_min_ratio + min_ratio < 100) {\n\t\t\tbdi_min_ratio += min_ratio;\n\t\t\tbdi->min_ratio += min_ratio;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tspin_unlock_bh(&bdi_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int bdi_min_ratio;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned int bdi_min_ratio;\n\nint bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)\n{\n\tint ret = 0;\n\n\tspin_lock_bh(&bdi_lock);\n\tif (min_ratio > bdi->max_ratio) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tmin_ratio -= bdi->min_ratio;\n\t\tif (bdi_min_ratio + min_ratio < 100) {\n\t\t\tbdi_min_ratio += min_ratio;\n\t\t\tbdi->min_ratio += min_ratio;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tspin_unlock_bh(&bdi_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "1",
            "HZ / 100"
          ],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "wb->dirty_ratelimit"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "wb->avg_write_bandwidth"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define DIRTY_POLL_THRESH\t(128 >> (PAGE_SHIFT - 10))\n\nstatic long wb_min_pause(struct bdi_writeback *wb,\n\t\t\t long max_pause,\n\t\t\t unsigned long task_ratelimit,\n\t\t\t unsigned long dirty_ratelimit,\n\t\t\t int *nr_dirtied_pause)\n{\n\tlong hi = ilog2(wb->avg_write_bandwidth);\n\tlong lo = ilog2(wb->dirty_ratelimit);\n\tlong t;\t\t/* target pause */\n\tlong pause;\t/* estimated next pause */\n\tint pages;\t/* target nr_dirtied_pause */\n\n\t/* target for 10ms pause on 1-dd case */\n\tt = max(1, HZ / 100);\n\n\t/*\n\t * Scale up pause time for concurrent dirtiers in order to reduce CPU\n\t * overheads.\n\t *\n\t * (N * 10ms) on 2^N concurrent tasks.\n\t */\n\tif (hi > lo)\n\t\tt += (hi - lo) * (10 * HZ) / 1024;\n\n\t/*\n\t * This is a bit convoluted. We try to base the next nr_dirtied_pause\n\t * on the much more stable dirty_ratelimit. However the next pause time\n\t * will be computed based on task_ratelimit and the two rate limits may\n\t * depart considerably at some time. Especially if task_ratelimit goes\n\t * below dirty_ratelimit/2 and the target pause is max_pause, the next\n\t * pause time will be max_pause*2 _trimmed down_ to max_pause.  As a\n\t * result task_ratelimit won't be executed faithfully, which could\n\t * eventually bring down dirty_ratelimit.\n\t *\n\t * We apply two rules to fix it up:\n\t * 1) try to estimate the next pause time and if necessary, use a lower\n\t *    nr_dirtied_pause so as not to exceed max_pause. When this happens,\n\t *    nr_dirtied_pause will be \"dancing\" with task_ratelimit.\n\t * 2) limit the target pause time to max_pause/2, so that the normal\n\t *    small fluctuations of task_ratelimit won't trigger rule (1) and\n\t *    nr_dirtied_pause will remain as stable as dirty_ratelimit.\n\t */\n\tt = min(t, 1 + max_pause / 2);\n\tpages = dirty_ratelimit * t / roundup_pow_of_two(HZ);\n\n\t/*\n\t * Tiny nr_dirtied_pause is found to hurt I/O performance in the test\n\t * case fio-mmap-randwrite-64k, which does 16*{sync read, async write}.\n\t * When the 16 consecutive reads are often interrupted by some dirty\n\t * throttling pause during the async writes, cfq will go into idles\n\t * (deadline is fine). So push nr_dirtied_pause as high as possible\n\t * until reaches DIRTY_POLL_THRESH=32 pages.\n\t */\n\tif (pages < DIRTY_POLL_THRESH) {\n\t\tt = max_pause;\n\t\tpages = dirty_ratelimit * t / roundup_pow_of_two(HZ);\n\t\tif (pages > DIRTY_POLL_THRESH) {\n\t\t\tpages = DIRTY_POLL_THRESH;\n\t\t\tt = HZ * DIRTY_POLL_THRESH / dirty_ratelimit;\n\t\t}\n\t}\n\n\tpause = HZ * pages / (task_ratelimit + 1);\n\tif (pause > max_pause) {\n\t\tt = max_pause;\n\t\tpages = task_ratelimit * t / roundup_pow_of_two(HZ);\n\t}\n\n\t*nr_dirtied_pause = pages;\n\t/*\n\t * The minimal pause time will normally be half the target pause time.\n\t */\n\treturn pages >= DIRTY_POLL_THRESH ? 1 + t / 2 : t;\n}"
  },
  {
    "function_name": "wb_max_pause",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "1418-1435",
    "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "t",
            "MAX_PAUSE"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "1 + HZ / 8"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
  },
  {
    "function_name": "dirty_poll_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "1409-1416",
    "snippet": "static unsigned long dirty_poll_interval(unsigned long dirty,\n\t\t\t\t\t unsigned long thresh)\n{\n\tif (thresh > dirty)\n\t\treturn 1UL << (ilog2(thresh - dirty) >> 1);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "thresh - dirty"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned long dirty_poll_interval(unsigned long dirty,\n\t\t\t\t\t unsigned long thresh)\n{\n\tif (thresh > dirty)\n\t\treturn 1UL << (ilog2(thresh - dirty) >> 1);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "wb_update_bandwidth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "1394-1399",
    "snippet": "void wb_update_bandwidth(struct bdi_writeback *wb, unsigned long start_time)\n{\n\tstruct dirty_throttle_control gdtc = { GDTC_INIT(wb) };\n\n\t__wb_update_bandwidth(&gdtc, NULL, start_time, false);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wb_update_bandwidth",
          "args": [
            "&gdtc",
            "NULL",
            "start_time",
            "false"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "__wb_update_bandwidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1344-1392",
          "snippet": "static void __wb_update_bandwidth(struct dirty_throttle_control *gdtc,\n\t\t\t\t  struct dirty_throttle_control *mdtc,\n\t\t\t\t  unsigned long start_time,\n\t\t\t\t  bool update_ratelimit)\n{\n\tstruct bdi_writeback *wb = gdtc->wb;\n\tunsigned long now = jiffies;\n\tunsigned long elapsed = now - wb->bw_time_stamp;\n\tunsigned long dirtied;\n\tunsigned long written;\n\n\tlockdep_assert_held(&wb->list_lock);\n\n\t/*\n\t * rate-limit, only update once every 200ms.\n\t */\n\tif (elapsed < BANDWIDTH_INTERVAL)\n\t\treturn;\n\n\tdirtied = percpu_counter_read(&wb->stat[WB_DIRTIED]);\n\twritten = percpu_counter_read(&wb->stat[WB_WRITTEN]);\n\n\t/*\n\t * Skip quiet periods when disk bandwidth is under-utilized.\n\t * (at least 1s idle time between two flusher runs)\n\t */\n\tif (elapsed > HZ && time_before(wb->bw_time_stamp, start_time))\n\t\tgoto snapshot;\n\n\tif (update_ratelimit) {\n\t\tdomain_update_bandwidth(gdtc, now);\n\t\twb_update_dirty_ratelimit(gdtc, dirtied, elapsed);\n\n\t\t/*\n\t\t * @mdtc is always NULL if !CGROUP_WRITEBACK but the\n\t\t * compiler has no way to figure that out.  Help it.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_CGROUP_WRITEBACK) && mdtc) {\n\t\t\tdomain_update_bandwidth(mdtc, now);\n\t\t\twb_update_dirty_ratelimit(mdtc, dirtied, elapsed);\n\t\t}\n\t}\n\twb_update_write_bandwidth(wb, elapsed, written);\n\nsnapshot:\n\twb->dirtied_stamp = dirtied;\n\twb->written_stamp = written;\n\twb->bw_time_stamp = now;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BANDWIDTH_INTERVAL\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define BANDWIDTH_INTERVAL\tmax(HZ/5, 1)\n\nstatic void __wb_update_bandwidth(struct dirty_throttle_control *gdtc,\n\t\t\t\t  struct dirty_throttle_control *mdtc,\n\t\t\t\t  unsigned long start_time,\n\t\t\t\t  bool update_ratelimit)\n{\n\tstruct bdi_writeback *wb = gdtc->wb;\n\tunsigned long now = jiffies;\n\tunsigned long elapsed = now - wb->bw_time_stamp;\n\tunsigned long dirtied;\n\tunsigned long written;\n\n\tlockdep_assert_held(&wb->list_lock);\n\n\t/*\n\t * rate-limit, only update once every 200ms.\n\t */\n\tif (elapsed < BANDWIDTH_INTERVAL)\n\t\treturn;\n\n\tdirtied = percpu_counter_read(&wb->stat[WB_DIRTIED]);\n\twritten = percpu_counter_read(&wb->stat[WB_WRITTEN]);\n\n\t/*\n\t * Skip quiet periods when disk bandwidth is under-utilized.\n\t * (at least 1s idle time between two flusher runs)\n\t */\n\tif (elapsed > HZ && time_before(wb->bw_time_stamp, start_time))\n\t\tgoto snapshot;\n\n\tif (update_ratelimit) {\n\t\tdomain_update_bandwidth(gdtc, now);\n\t\twb_update_dirty_ratelimit(gdtc, dirtied, elapsed);\n\n\t\t/*\n\t\t * @mdtc is always NULL if !CGROUP_WRITEBACK but the\n\t\t * compiler has no way to figure that out.  Help it.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_CGROUP_WRITEBACK) && mdtc) {\n\t\t\tdomain_update_bandwidth(mdtc, now);\n\t\t\twb_update_dirty_ratelimit(mdtc, dirtied, elapsed);\n\t\t}\n\t}\n\twb_update_write_bandwidth(wb, elapsed, written);\n\nsnapshot:\n\twb->dirtied_stamp = dirtied;\n\twb->written_stamp = written;\n\twb->bw_time_stamp = now;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GDTC_INIT",
          "args": [
            "wb"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid wb_update_bandwidth(struct bdi_writeback *wb, unsigned long start_time)\n{\n\tstruct dirty_throttle_control gdtc = { GDTC_INIT(wb) };\n\n\t__wb_update_bandwidth(&gdtc, NULL, start_time, false);\n}"
  },
  {
    "function_name": "__wb_update_bandwidth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "1344-1392",
    "snippet": "static void __wb_update_bandwidth(struct dirty_throttle_control *gdtc,\n\t\t\t\t  struct dirty_throttle_control *mdtc,\n\t\t\t\t  unsigned long start_time,\n\t\t\t\t  bool update_ratelimit)\n{\n\tstruct bdi_writeback *wb = gdtc->wb;\n\tunsigned long now = jiffies;\n\tunsigned long elapsed = now - wb->bw_time_stamp;\n\tunsigned long dirtied;\n\tunsigned long written;\n\n\tlockdep_assert_held(&wb->list_lock);\n\n\t/*\n\t * rate-limit, only update once every 200ms.\n\t */\n\tif (elapsed < BANDWIDTH_INTERVAL)\n\t\treturn;\n\n\tdirtied = percpu_counter_read(&wb->stat[WB_DIRTIED]);\n\twritten = percpu_counter_read(&wb->stat[WB_WRITTEN]);\n\n\t/*\n\t * Skip quiet periods when disk bandwidth is under-utilized.\n\t * (at least 1s idle time between two flusher runs)\n\t */\n\tif (elapsed > HZ && time_before(wb->bw_time_stamp, start_time))\n\t\tgoto snapshot;\n\n\tif (update_ratelimit) {\n\t\tdomain_update_bandwidth(gdtc, now);\n\t\twb_update_dirty_ratelimit(gdtc, dirtied, elapsed);\n\n\t\t/*\n\t\t * @mdtc is always NULL if !CGROUP_WRITEBACK but the\n\t\t * compiler has no way to figure that out.  Help it.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_CGROUP_WRITEBACK) && mdtc) {\n\t\t\tdomain_update_bandwidth(mdtc, now);\n\t\t\twb_update_dirty_ratelimit(mdtc, dirtied, elapsed);\n\t\t}\n\t}\n\twb_update_write_bandwidth(wb, elapsed, written);\n\nsnapshot:\n\twb->dirtied_stamp = dirtied;\n\twb->written_stamp = written;\n\twb->bw_time_stamp = now;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define BANDWIDTH_INTERVAL\tmax(HZ/5, 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wb_update_write_bandwidth",
          "args": [
            "wb",
            "elapsed",
            "written"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "wb_update_write_bandwidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1082-1130",
          "snippet": "static void wb_update_write_bandwidth(struct bdi_writeback *wb,\n\t\t\t\t      unsigned long elapsed,\n\t\t\t\t      unsigned long written)\n{\n\tconst unsigned long period = roundup_pow_of_two(3 * HZ);\n\tunsigned long avg = wb->avg_write_bandwidth;\n\tunsigned long old = wb->write_bandwidth;\n\tu64 bw;\n\n\t/*\n\t * bw = written * HZ / elapsed\n\t *\n\t *                   bw * elapsed + write_bandwidth * (period - elapsed)\n\t * write_bandwidth = ---------------------------------------------------\n\t *                                          period\n\t *\n\t * @written may have decreased due to account_page_redirty().\n\t * Avoid underflowing @bw calculation.\n\t */\n\tbw = written - min(written, wb->written_stamp);\n\tbw *= HZ;\n\tif (unlikely(elapsed > period)) {\n\t\tdo_div(bw, elapsed);\n\t\tavg = bw;\n\t\tgoto out;\n\t}\n\tbw += (u64)wb->write_bandwidth * (period - elapsed);\n\tbw >>= ilog2(period);\n\n\t/*\n\t * one more level of smoothing, for filtering out sudden spikes\n\t */\n\tif (avg > old && old >= (unsigned long)bw)\n\t\tavg -= (avg - old) >> 3;\n\n\tif (avg < old && old <= (unsigned long)bw)\n\t\tavg += (old - avg) >> 3;\n\nout:\n\t/* keep avg > 0 to guarantee that tot > 0 if there are dirty wbs */\n\tavg = max(avg, 1LU);\n\tif (wb_has_dirty_io(wb)) {\n\t\tlong delta = avg - wb->avg_write_bandwidth;\n\t\tWARN_ON_ONCE(atomic_long_add_return(delta,\n\t\t\t\t\t&wb->bdi->tot_write_bandwidth) <= 0);\n\t}\n\twb->write_bandwidth = bw;\n\twb->avg_write_bandwidth = avg;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_update_write_bandwidth(struct bdi_writeback *wb,\n\t\t\t\t      unsigned long elapsed,\n\t\t\t\t      unsigned long written)\n{\n\tconst unsigned long period = roundup_pow_of_two(3 * HZ);\n\tunsigned long avg = wb->avg_write_bandwidth;\n\tunsigned long old = wb->write_bandwidth;\n\tu64 bw;\n\n\t/*\n\t * bw = written * HZ / elapsed\n\t *\n\t *                   bw * elapsed + write_bandwidth * (period - elapsed)\n\t * write_bandwidth = ---------------------------------------------------\n\t *                                          period\n\t *\n\t * @written may have decreased due to account_page_redirty().\n\t * Avoid underflowing @bw calculation.\n\t */\n\tbw = written - min(written, wb->written_stamp);\n\tbw *= HZ;\n\tif (unlikely(elapsed > period)) {\n\t\tdo_div(bw, elapsed);\n\t\tavg = bw;\n\t\tgoto out;\n\t}\n\tbw += (u64)wb->write_bandwidth * (period - elapsed);\n\tbw >>= ilog2(period);\n\n\t/*\n\t * one more level of smoothing, for filtering out sudden spikes\n\t */\n\tif (avg > old && old >= (unsigned long)bw)\n\t\tavg -= (avg - old) >> 3;\n\n\tif (avg < old && old <= (unsigned long)bw)\n\t\tavg += (old - avg) >> 3;\n\nout:\n\t/* keep avg > 0 to guarantee that tot > 0 if there are dirty wbs */\n\tavg = max(avg, 1LU);\n\tif (wb_has_dirty_io(wb)) {\n\t\tlong delta = avg - wb->avg_write_bandwidth;\n\t\tWARN_ON_ONCE(atomic_long_add_return(delta,\n\t\t\t\t\t&wb->bdi->tot_write_bandwidth) <= 0);\n\t}\n\twb->write_bandwidth = bw;\n\twb->avg_write_bandwidth = avg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_update_dirty_ratelimit",
          "args": [
            "mdtc",
            "dirtied",
            "elapsed"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "wb_update_dirty_ratelimit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1186-1342",
          "snippet": "static void wb_update_dirty_ratelimit(struct dirty_throttle_control *dtc,\n\t\t\t\t      unsigned long dirtied,\n\t\t\t\t      unsigned long elapsed)\n{\n\tstruct bdi_writeback *wb = dtc->wb;\n\tunsigned long dirty = dtc->dirty;\n\tunsigned long freerun = dirty_freerun_ceiling(dtc->thresh, dtc->bg_thresh);\n\tunsigned long limit = hard_dirty_limit(dtc_dom(dtc), dtc->thresh);\n\tunsigned long setpoint = (freerun + limit) / 2;\n\tunsigned long write_bw = wb->avg_write_bandwidth;\n\tunsigned long dirty_ratelimit = wb->dirty_ratelimit;\n\tunsigned long dirty_rate;\n\tunsigned long task_ratelimit;\n\tunsigned long balanced_dirty_ratelimit;\n\tunsigned long step;\n\tunsigned long x;\n\tunsigned long shift;\n\n\t/*\n\t * The dirty rate will match the writeout rate in long term, except\n\t * when dirty pages are truncated by userspace or re-dirtied by FS.\n\t */\n\tdirty_rate = (dirtied - wb->dirtied_stamp) * HZ / elapsed;\n\n\t/*\n\t * task_ratelimit reflects each dd's dirty rate for the past 200ms.\n\t */\n\ttask_ratelimit = (u64)dirty_ratelimit *\n\t\t\t\t\tdtc->pos_ratio >> RATELIMIT_CALC_SHIFT;\n\ttask_ratelimit++; /* it helps rampup dirty_ratelimit from tiny values */\n\n\t/*\n\t * A linear estimation of the \"balanced\" throttle rate. The theory is,\n\t * if there are N dd tasks, each throttled at task_ratelimit, the wb's\n\t * dirty_rate will be measured to be (N * task_ratelimit). So the below\n\t * formula will yield the balanced rate limit (write_bw / N).\n\t *\n\t * Note that the expanded form is not a pure rate feedback:\n\t *\trate_(i+1) = rate_(i) * (write_bw / dirty_rate)\t\t     (1)\n\t * but also takes pos_ratio into account:\n\t *\trate_(i+1) = rate_(i) * (write_bw / dirty_rate) * pos_ratio  (2)\n\t *\n\t * (1) is not realistic because pos_ratio also takes part in balancing\n\t * the dirty rate.  Consider the state\n\t *\tpos_ratio = 0.5\t\t\t\t\t\t     (3)\n\t *\trate = 2 * (write_bw / N)\t\t\t\t     (4)\n\t * If (1) is used, it will stuck in that state! Because each dd will\n\t * be throttled at\n\t *\ttask_ratelimit = pos_ratio * rate = (write_bw / N)\t     (5)\n\t * yielding\n\t *\tdirty_rate = N * task_ratelimit = write_bw\t\t     (6)\n\t * put (6) into (1) we get\n\t *\trate_(i+1) = rate_(i)\t\t\t\t\t     (7)\n\t *\n\t * So we end up using (2) to always keep\n\t *\trate_(i+1) ~= (write_bw / N)\t\t\t\t     (8)\n\t * regardless of the value of pos_ratio. As long as (8) is satisfied,\n\t * pos_ratio is able to drive itself to 1.0, which is not only where\n\t * the dirty count meet the setpoint, but also where the slope of\n\t * pos_ratio is most flat and hence task_ratelimit is least fluctuated.\n\t */\n\tbalanced_dirty_ratelimit = div_u64((u64)task_ratelimit * write_bw,\n\t\t\t\t\t   dirty_rate | 1);\n\t/*\n\t * balanced_dirty_ratelimit ~= (write_bw / N) <= write_bw\n\t */\n\tif (unlikely(balanced_dirty_ratelimit > write_bw))\n\t\tbalanced_dirty_ratelimit = write_bw;\n\n\t/*\n\t * We could safely do this and return immediately:\n\t *\n\t *\twb->dirty_ratelimit = balanced_dirty_ratelimit;\n\t *\n\t * However to get a more stable dirty_ratelimit, the below elaborated\n\t * code makes use of task_ratelimit to filter out singular points and\n\t * limit the step size.\n\t *\n\t * The below code essentially only uses the relative value of\n\t *\n\t *\ttask_ratelimit - dirty_ratelimit\n\t *\t= (pos_ratio - 1) * dirty_ratelimit\n\t *\n\t * which reflects the direction and size of dirty position error.\n\t */\n\n\t/*\n\t * dirty_ratelimit will follow balanced_dirty_ratelimit iff\n\t * task_ratelimit is on the same side of dirty_ratelimit, too.\n\t * For example, when\n\t * - dirty_ratelimit > balanced_dirty_ratelimit\n\t * - dirty_ratelimit > task_ratelimit (dirty pages are above setpoint)\n\t * lowering dirty_ratelimit will help meet both the position and rate\n\t * control targets. Otherwise, don't update dirty_ratelimit if it will\n\t * only help meet the rate target. After all, what the users ultimately\n\t * feel and care are stable dirty rate and small position error.\n\t *\n\t * |task_ratelimit - dirty_ratelimit| is used to limit the step size\n\t * and filter out the singular points of balanced_dirty_ratelimit. Which\n\t * keeps jumping around randomly and can even leap far away at times\n\t * due to the small 200ms estimation period of dirty_rate (we want to\n\t * keep that period small to reduce time lags).\n\t */\n\tstep = 0;\n\n\t/*\n\t * For strictlimit case, calculations above were based on wb counters\n\t * and limits (starting from pos_ratio = wb_position_ratio() and up to\n\t * balanced_dirty_ratelimit = task_ratelimit * write_bw / dirty_rate).\n\t * Hence, to calculate \"step\" properly, we have to use wb_dirty as\n\t * \"dirty\" and wb_setpoint as \"setpoint\".\n\t *\n\t * We rampup dirty_ratelimit forcibly if wb_dirty is low because\n\t * it's possible that wb_thresh is close to zero due to inactivity\n\t * of backing device.\n\t */\n\tif (unlikely(wb->bdi->capabilities & BDI_CAP_STRICTLIMIT)) {\n\t\tdirty = dtc->wb_dirty;\n\t\tif (dtc->wb_dirty < 8)\n\t\t\tsetpoint = dtc->wb_dirty + 1;\n\t\telse\n\t\t\tsetpoint = (dtc->wb_thresh + dtc->wb_bg_thresh) / 2;\n\t}\n\n\tif (dirty < setpoint) {\n\t\tx = min3(wb->balanced_dirty_ratelimit,\n\t\t\t balanced_dirty_ratelimit, task_ratelimit);\n\t\tif (dirty_ratelimit < x)\n\t\t\tstep = x - dirty_ratelimit;\n\t} else {\n\t\tx = max3(wb->balanced_dirty_ratelimit,\n\t\t\t balanced_dirty_ratelimit, task_ratelimit);\n\t\tif (dirty_ratelimit > x)\n\t\t\tstep = dirty_ratelimit - x;\n\t}\n\n\t/*\n\t * Don't pursue 100% rate matching. It's impossible since the balanced\n\t * rate itself is constantly fluctuating. So decrease the track speed\n\t * when it gets close to the target. Helps eliminate pointless tremors.\n\t */\n\tshift = dirty_ratelimit / (2 * step + 1);\n\tif (shift < BITS_PER_LONG)\n\t\tstep = DIV_ROUND_UP(step >> shift, 8);\n\telse\n\t\tstep = 0;\n\n\tif (dirty_ratelimit < balanced_dirty_ratelimit)\n\t\tdirty_ratelimit += step;\n\telse\n\t\tdirty_ratelimit -= step;\n\n\twb->dirty_ratelimit = max(dirty_ratelimit, 1UL);\n\twb->balanced_dirty_ratelimit = balanced_dirty_ratelimit;\n\n\ttrace_bdi_dirty_ratelimit(wb, dirty_rate, task_ratelimit);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define RATELIMIT_CALC_SHIFT\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define RATELIMIT_CALC_SHIFT\t10\n\nstatic void wb_update_dirty_ratelimit(struct dirty_throttle_control *dtc,\n\t\t\t\t      unsigned long dirtied,\n\t\t\t\t      unsigned long elapsed)\n{\n\tstruct bdi_writeback *wb = dtc->wb;\n\tunsigned long dirty = dtc->dirty;\n\tunsigned long freerun = dirty_freerun_ceiling(dtc->thresh, dtc->bg_thresh);\n\tunsigned long limit = hard_dirty_limit(dtc_dom(dtc), dtc->thresh);\n\tunsigned long setpoint = (freerun + limit) / 2;\n\tunsigned long write_bw = wb->avg_write_bandwidth;\n\tunsigned long dirty_ratelimit = wb->dirty_ratelimit;\n\tunsigned long dirty_rate;\n\tunsigned long task_ratelimit;\n\tunsigned long balanced_dirty_ratelimit;\n\tunsigned long step;\n\tunsigned long x;\n\tunsigned long shift;\n\n\t/*\n\t * The dirty rate will match the writeout rate in long term, except\n\t * when dirty pages are truncated by userspace or re-dirtied by FS.\n\t */\n\tdirty_rate = (dirtied - wb->dirtied_stamp) * HZ / elapsed;\n\n\t/*\n\t * task_ratelimit reflects each dd's dirty rate for the past 200ms.\n\t */\n\ttask_ratelimit = (u64)dirty_ratelimit *\n\t\t\t\t\tdtc->pos_ratio >> RATELIMIT_CALC_SHIFT;\n\ttask_ratelimit++; /* it helps rampup dirty_ratelimit from tiny values */\n\n\t/*\n\t * A linear estimation of the \"balanced\" throttle rate. The theory is,\n\t * if there are N dd tasks, each throttled at task_ratelimit, the wb's\n\t * dirty_rate will be measured to be (N * task_ratelimit). So the below\n\t * formula will yield the balanced rate limit (write_bw / N).\n\t *\n\t * Note that the expanded form is not a pure rate feedback:\n\t *\trate_(i+1) = rate_(i) * (write_bw / dirty_rate)\t\t     (1)\n\t * but also takes pos_ratio into account:\n\t *\trate_(i+1) = rate_(i) * (write_bw / dirty_rate) * pos_ratio  (2)\n\t *\n\t * (1) is not realistic because pos_ratio also takes part in balancing\n\t * the dirty rate.  Consider the state\n\t *\tpos_ratio = 0.5\t\t\t\t\t\t     (3)\n\t *\trate = 2 * (write_bw / N)\t\t\t\t     (4)\n\t * If (1) is used, it will stuck in that state! Because each dd will\n\t * be throttled at\n\t *\ttask_ratelimit = pos_ratio * rate = (write_bw / N)\t     (5)\n\t * yielding\n\t *\tdirty_rate = N * task_ratelimit = write_bw\t\t     (6)\n\t * put (6) into (1) we get\n\t *\trate_(i+1) = rate_(i)\t\t\t\t\t     (7)\n\t *\n\t * So we end up using (2) to always keep\n\t *\trate_(i+1) ~= (write_bw / N)\t\t\t\t     (8)\n\t * regardless of the value of pos_ratio. As long as (8) is satisfied,\n\t * pos_ratio is able to drive itself to 1.0, which is not only where\n\t * the dirty count meet the setpoint, but also where the slope of\n\t * pos_ratio is most flat and hence task_ratelimit is least fluctuated.\n\t */\n\tbalanced_dirty_ratelimit = div_u64((u64)task_ratelimit * write_bw,\n\t\t\t\t\t   dirty_rate | 1);\n\t/*\n\t * balanced_dirty_ratelimit ~= (write_bw / N) <= write_bw\n\t */\n\tif (unlikely(balanced_dirty_ratelimit > write_bw))\n\t\tbalanced_dirty_ratelimit = write_bw;\n\n\t/*\n\t * We could safely do this and return immediately:\n\t *\n\t *\twb->dirty_ratelimit = balanced_dirty_ratelimit;\n\t *\n\t * However to get a more stable dirty_ratelimit, the below elaborated\n\t * code makes use of task_ratelimit to filter out singular points and\n\t * limit the step size.\n\t *\n\t * The below code essentially only uses the relative value of\n\t *\n\t *\ttask_ratelimit - dirty_ratelimit\n\t *\t= (pos_ratio - 1) * dirty_ratelimit\n\t *\n\t * which reflects the direction and size of dirty position error.\n\t */\n\n\t/*\n\t * dirty_ratelimit will follow balanced_dirty_ratelimit iff\n\t * task_ratelimit is on the same side of dirty_ratelimit, too.\n\t * For example, when\n\t * - dirty_ratelimit > balanced_dirty_ratelimit\n\t * - dirty_ratelimit > task_ratelimit (dirty pages are above setpoint)\n\t * lowering dirty_ratelimit will help meet both the position and rate\n\t * control targets. Otherwise, don't update dirty_ratelimit if it will\n\t * only help meet the rate target. After all, what the users ultimately\n\t * feel and care are stable dirty rate and small position error.\n\t *\n\t * |task_ratelimit - dirty_ratelimit| is used to limit the step size\n\t * and filter out the singular points of balanced_dirty_ratelimit. Which\n\t * keeps jumping around randomly and can even leap far away at times\n\t * due to the small 200ms estimation period of dirty_rate (we want to\n\t * keep that period small to reduce time lags).\n\t */\n\tstep = 0;\n\n\t/*\n\t * For strictlimit case, calculations above were based on wb counters\n\t * and limits (starting from pos_ratio = wb_position_ratio() and up to\n\t * balanced_dirty_ratelimit = task_ratelimit * write_bw / dirty_rate).\n\t * Hence, to calculate \"step\" properly, we have to use wb_dirty as\n\t * \"dirty\" and wb_setpoint as \"setpoint\".\n\t *\n\t * We rampup dirty_ratelimit forcibly if wb_dirty is low because\n\t * it's possible that wb_thresh is close to zero due to inactivity\n\t * of backing device.\n\t */\n\tif (unlikely(wb->bdi->capabilities & BDI_CAP_STRICTLIMIT)) {\n\t\tdirty = dtc->wb_dirty;\n\t\tif (dtc->wb_dirty < 8)\n\t\t\tsetpoint = dtc->wb_dirty + 1;\n\t\telse\n\t\t\tsetpoint = (dtc->wb_thresh + dtc->wb_bg_thresh) / 2;\n\t}\n\n\tif (dirty < setpoint) {\n\t\tx = min3(wb->balanced_dirty_ratelimit,\n\t\t\t balanced_dirty_ratelimit, task_ratelimit);\n\t\tif (dirty_ratelimit < x)\n\t\t\tstep = x - dirty_ratelimit;\n\t} else {\n\t\tx = max3(wb->balanced_dirty_ratelimit,\n\t\t\t balanced_dirty_ratelimit, task_ratelimit);\n\t\tif (dirty_ratelimit > x)\n\t\t\tstep = dirty_ratelimit - x;\n\t}\n\n\t/*\n\t * Don't pursue 100% rate matching. It's impossible since the balanced\n\t * rate itself is constantly fluctuating. So decrease the track speed\n\t * when it gets close to the target. Helps eliminate pointless tremors.\n\t */\n\tshift = dirty_ratelimit / (2 * step + 1);\n\tif (shift < BITS_PER_LONG)\n\t\tstep = DIV_ROUND_UP(step >> shift, 8);\n\telse\n\t\tstep = 0;\n\n\tif (dirty_ratelimit < balanced_dirty_ratelimit)\n\t\tdirty_ratelimit += step;\n\telse\n\t\tdirty_ratelimit -= step;\n\n\twb->dirty_ratelimit = max(dirty_ratelimit, 1UL);\n\twb->balanced_dirty_ratelimit = balanced_dirty_ratelimit;\n\n\ttrace_bdi_dirty_ratelimit(wb, dirty_rate, task_ratelimit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "domain_update_bandwidth",
          "args": [
            "mdtc",
            "now"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "domain_update_bandwidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1161-1178",
          "snippet": "static void domain_update_bandwidth(struct dirty_throttle_control *dtc,\n\t\t\t\t    unsigned long now)\n{\n\tstruct wb_domain *dom = dtc_dom(dtc);\n\n\t/*\n\t * check locklessly first to optimize away locking for the most time\n\t */\n\tif (time_before(now, dom->dirty_limit_tstamp + BANDWIDTH_INTERVAL))\n\t\treturn;\n\n\tspin_lock(&dom->lock);\n\tif (time_after_eq(now, dom->dirty_limit_tstamp + BANDWIDTH_INTERVAL)) {\n\t\tupdate_dirty_limit(dtc);\n\t\tdom->dirty_limit_tstamp = now;\n\t}\n\tspin_unlock(&dom->lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BANDWIDTH_INTERVAL\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define BANDWIDTH_INTERVAL\tmax(HZ/5, 1)\n\nstatic void domain_update_bandwidth(struct dirty_throttle_control *dtc,\n\t\t\t\t    unsigned long now)\n{\n\tstruct wb_domain *dom = dtc_dom(dtc);\n\n\t/*\n\t * check locklessly first to optimize away locking for the most time\n\t */\n\tif (time_before(now, dom->dirty_limit_tstamp + BANDWIDTH_INTERVAL))\n\t\treturn;\n\n\tspin_lock(&dom->lock);\n\tif (time_after_eq(now, dom->dirty_limit_tstamp + BANDWIDTH_INTERVAL)) {\n\t\tupdate_dirty_limit(dtc);\n\t\tdom->dirty_limit_tstamp = now;\n\t}\n\tspin_unlock(&dom->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_CGROUP_WRITEBACK"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "wb->bw_time_stamp",
            "start_time"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_read",
          "args": [
            "&wb->stat[WB_WRITTEN]"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_read",
          "args": [
            "&wb->stat[WB_DIRTIED]"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wb->list_lock"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define BANDWIDTH_INTERVAL\tmax(HZ/5, 1)\n\nstatic void __wb_update_bandwidth(struct dirty_throttle_control *gdtc,\n\t\t\t\t  struct dirty_throttle_control *mdtc,\n\t\t\t\t  unsigned long start_time,\n\t\t\t\t  bool update_ratelimit)\n{\n\tstruct bdi_writeback *wb = gdtc->wb;\n\tunsigned long now = jiffies;\n\tunsigned long elapsed = now - wb->bw_time_stamp;\n\tunsigned long dirtied;\n\tunsigned long written;\n\n\tlockdep_assert_held(&wb->list_lock);\n\n\t/*\n\t * rate-limit, only update once every 200ms.\n\t */\n\tif (elapsed < BANDWIDTH_INTERVAL)\n\t\treturn;\n\n\tdirtied = percpu_counter_read(&wb->stat[WB_DIRTIED]);\n\twritten = percpu_counter_read(&wb->stat[WB_WRITTEN]);\n\n\t/*\n\t * Skip quiet periods when disk bandwidth is under-utilized.\n\t * (at least 1s idle time between two flusher runs)\n\t */\n\tif (elapsed > HZ && time_before(wb->bw_time_stamp, start_time))\n\t\tgoto snapshot;\n\n\tif (update_ratelimit) {\n\t\tdomain_update_bandwidth(gdtc, now);\n\t\twb_update_dirty_ratelimit(gdtc, dirtied, elapsed);\n\n\t\t/*\n\t\t * @mdtc is always NULL if !CGROUP_WRITEBACK but the\n\t\t * compiler has no way to figure that out.  Help it.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_CGROUP_WRITEBACK) && mdtc) {\n\t\t\tdomain_update_bandwidth(mdtc, now);\n\t\t\twb_update_dirty_ratelimit(mdtc, dirtied, elapsed);\n\t\t}\n\t}\n\twb_update_write_bandwidth(wb, elapsed, written);\n\nsnapshot:\n\twb->dirtied_stamp = dirtied;\n\twb->written_stamp = written;\n\twb->bw_time_stamp = now;\n}"
  },
  {
    "function_name": "wb_update_dirty_ratelimit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "1186-1342",
    "snippet": "static void wb_update_dirty_ratelimit(struct dirty_throttle_control *dtc,\n\t\t\t\t      unsigned long dirtied,\n\t\t\t\t      unsigned long elapsed)\n{\n\tstruct bdi_writeback *wb = dtc->wb;\n\tunsigned long dirty = dtc->dirty;\n\tunsigned long freerun = dirty_freerun_ceiling(dtc->thresh, dtc->bg_thresh);\n\tunsigned long limit = hard_dirty_limit(dtc_dom(dtc), dtc->thresh);\n\tunsigned long setpoint = (freerun + limit) / 2;\n\tunsigned long write_bw = wb->avg_write_bandwidth;\n\tunsigned long dirty_ratelimit = wb->dirty_ratelimit;\n\tunsigned long dirty_rate;\n\tunsigned long task_ratelimit;\n\tunsigned long balanced_dirty_ratelimit;\n\tunsigned long step;\n\tunsigned long x;\n\tunsigned long shift;\n\n\t/*\n\t * The dirty rate will match the writeout rate in long term, except\n\t * when dirty pages are truncated by userspace or re-dirtied by FS.\n\t */\n\tdirty_rate = (dirtied - wb->dirtied_stamp) * HZ / elapsed;\n\n\t/*\n\t * task_ratelimit reflects each dd's dirty rate for the past 200ms.\n\t */\n\ttask_ratelimit = (u64)dirty_ratelimit *\n\t\t\t\t\tdtc->pos_ratio >> RATELIMIT_CALC_SHIFT;\n\ttask_ratelimit++; /* it helps rampup dirty_ratelimit from tiny values */\n\n\t/*\n\t * A linear estimation of the \"balanced\" throttle rate. The theory is,\n\t * if there are N dd tasks, each throttled at task_ratelimit, the wb's\n\t * dirty_rate will be measured to be (N * task_ratelimit). So the below\n\t * formula will yield the balanced rate limit (write_bw / N).\n\t *\n\t * Note that the expanded form is not a pure rate feedback:\n\t *\trate_(i+1) = rate_(i) * (write_bw / dirty_rate)\t\t     (1)\n\t * but also takes pos_ratio into account:\n\t *\trate_(i+1) = rate_(i) * (write_bw / dirty_rate) * pos_ratio  (2)\n\t *\n\t * (1) is not realistic because pos_ratio also takes part in balancing\n\t * the dirty rate.  Consider the state\n\t *\tpos_ratio = 0.5\t\t\t\t\t\t     (3)\n\t *\trate = 2 * (write_bw / N)\t\t\t\t     (4)\n\t * If (1) is used, it will stuck in that state! Because each dd will\n\t * be throttled at\n\t *\ttask_ratelimit = pos_ratio * rate = (write_bw / N)\t     (5)\n\t * yielding\n\t *\tdirty_rate = N * task_ratelimit = write_bw\t\t     (6)\n\t * put (6) into (1) we get\n\t *\trate_(i+1) = rate_(i)\t\t\t\t\t     (7)\n\t *\n\t * So we end up using (2) to always keep\n\t *\trate_(i+1) ~= (write_bw / N)\t\t\t\t     (8)\n\t * regardless of the value of pos_ratio. As long as (8) is satisfied,\n\t * pos_ratio is able to drive itself to 1.0, which is not only where\n\t * the dirty count meet the setpoint, but also where the slope of\n\t * pos_ratio is most flat and hence task_ratelimit is least fluctuated.\n\t */\n\tbalanced_dirty_ratelimit = div_u64((u64)task_ratelimit * write_bw,\n\t\t\t\t\t   dirty_rate | 1);\n\t/*\n\t * balanced_dirty_ratelimit ~= (write_bw / N) <= write_bw\n\t */\n\tif (unlikely(balanced_dirty_ratelimit > write_bw))\n\t\tbalanced_dirty_ratelimit = write_bw;\n\n\t/*\n\t * We could safely do this and return immediately:\n\t *\n\t *\twb->dirty_ratelimit = balanced_dirty_ratelimit;\n\t *\n\t * However to get a more stable dirty_ratelimit, the below elaborated\n\t * code makes use of task_ratelimit to filter out singular points and\n\t * limit the step size.\n\t *\n\t * The below code essentially only uses the relative value of\n\t *\n\t *\ttask_ratelimit - dirty_ratelimit\n\t *\t= (pos_ratio - 1) * dirty_ratelimit\n\t *\n\t * which reflects the direction and size of dirty position error.\n\t */\n\n\t/*\n\t * dirty_ratelimit will follow balanced_dirty_ratelimit iff\n\t * task_ratelimit is on the same side of dirty_ratelimit, too.\n\t * For example, when\n\t * - dirty_ratelimit > balanced_dirty_ratelimit\n\t * - dirty_ratelimit > task_ratelimit (dirty pages are above setpoint)\n\t * lowering dirty_ratelimit will help meet both the position and rate\n\t * control targets. Otherwise, don't update dirty_ratelimit if it will\n\t * only help meet the rate target. After all, what the users ultimately\n\t * feel and care are stable dirty rate and small position error.\n\t *\n\t * |task_ratelimit - dirty_ratelimit| is used to limit the step size\n\t * and filter out the singular points of balanced_dirty_ratelimit. Which\n\t * keeps jumping around randomly and can even leap far away at times\n\t * due to the small 200ms estimation period of dirty_rate (we want to\n\t * keep that period small to reduce time lags).\n\t */\n\tstep = 0;\n\n\t/*\n\t * For strictlimit case, calculations above were based on wb counters\n\t * and limits (starting from pos_ratio = wb_position_ratio() and up to\n\t * balanced_dirty_ratelimit = task_ratelimit * write_bw / dirty_rate).\n\t * Hence, to calculate \"step\" properly, we have to use wb_dirty as\n\t * \"dirty\" and wb_setpoint as \"setpoint\".\n\t *\n\t * We rampup dirty_ratelimit forcibly if wb_dirty is low because\n\t * it's possible that wb_thresh is close to zero due to inactivity\n\t * of backing device.\n\t */\n\tif (unlikely(wb->bdi->capabilities & BDI_CAP_STRICTLIMIT)) {\n\t\tdirty = dtc->wb_dirty;\n\t\tif (dtc->wb_dirty < 8)\n\t\t\tsetpoint = dtc->wb_dirty + 1;\n\t\telse\n\t\t\tsetpoint = (dtc->wb_thresh + dtc->wb_bg_thresh) / 2;\n\t}\n\n\tif (dirty < setpoint) {\n\t\tx = min3(wb->balanced_dirty_ratelimit,\n\t\t\t balanced_dirty_ratelimit, task_ratelimit);\n\t\tif (dirty_ratelimit < x)\n\t\t\tstep = x - dirty_ratelimit;\n\t} else {\n\t\tx = max3(wb->balanced_dirty_ratelimit,\n\t\t\t balanced_dirty_ratelimit, task_ratelimit);\n\t\tif (dirty_ratelimit > x)\n\t\t\tstep = dirty_ratelimit - x;\n\t}\n\n\t/*\n\t * Don't pursue 100% rate matching. It's impossible since the balanced\n\t * rate itself is constantly fluctuating. So decrease the track speed\n\t * when it gets close to the target. Helps eliminate pointless tremors.\n\t */\n\tshift = dirty_ratelimit / (2 * step + 1);\n\tif (shift < BITS_PER_LONG)\n\t\tstep = DIV_ROUND_UP(step >> shift, 8);\n\telse\n\t\tstep = 0;\n\n\tif (dirty_ratelimit < balanced_dirty_ratelimit)\n\t\tdirty_ratelimit += step;\n\telse\n\t\tdirty_ratelimit -= step;\n\n\twb->dirty_ratelimit = max(dirty_ratelimit, 1UL);\n\twb->balanced_dirty_ratelimit = balanced_dirty_ratelimit;\n\n\ttrace_bdi_dirty_ratelimit(wb, dirty_rate, task_ratelimit);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define RATELIMIT_CALC_SHIFT\t10"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_bdi_dirty_ratelimit",
          "args": [
            "wb",
            "dirty_rate",
            "task_ratelimit"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "dirty_ratelimit",
            "1UL"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "step >> shift",
            "8"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max3",
          "args": [
            "wb->balanced_dirty_ratelimit",
            "balanced_dirty_ratelimit",
            "task_ratelimit"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min3",
          "args": [
            "wb->balanced_dirty_ratelimit",
            "balanced_dirty_ratelimit",
            "task_ratelimit"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "wb->bdi->capabilities & BDI_CAP_STRICTLIMIT"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "balanced_dirty_ratelimit > write_bw"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "(u64)task_ratelimit * write_bw",
            "dirty_rate | 1"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hard_dirty_limit",
          "args": [
            "dtc_dom(dtc)",
            "dtc->thresh"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "hard_dirty_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "721-725",
          "snippet": "static unsigned long hard_dirty_limit(struct wb_domain *dom,\n\t\t\t\t      unsigned long thresh)\n{\n\treturn max(thresh, dom->dirty_limit);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned long hard_dirty_limit(struct wb_domain *dom,\n\t\t\t\t      unsigned long thresh)\n{\n\treturn max(thresh, dom->dirty_limit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtc_dom",
          "args": [
            "dtc"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "dtc_dom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "227-230",
          "snippet": "static struct wb_domain *dtc_dom(struct dirty_throttle_control *dtc)\n{\n\treturn &global_wb_domain;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct wb_domain global_wb_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct wb_domain global_wb_domain;\n\nstatic struct wb_domain *dtc_dom(struct dirty_throttle_control *dtc)\n{\n\treturn &global_wb_domain;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dirty_freerun_ceiling",
          "args": [
            "dtc->thresh",
            "dtc->bg_thresh"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "dirty_freerun_ceiling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "715-719",
          "snippet": "static unsigned long dirty_freerun_ceiling(unsigned long thresh,\n\t\t\t\t\t   unsigned long bg_thresh)\n{\n\treturn (thresh + bg_thresh) / 2;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned long dirty_freerun_ceiling(unsigned long thresh,\n\t\t\t\t\t   unsigned long bg_thresh)\n{\n\treturn (thresh + bg_thresh) / 2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define RATELIMIT_CALC_SHIFT\t10\n\nstatic void wb_update_dirty_ratelimit(struct dirty_throttle_control *dtc,\n\t\t\t\t      unsigned long dirtied,\n\t\t\t\t      unsigned long elapsed)\n{\n\tstruct bdi_writeback *wb = dtc->wb;\n\tunsigned long dirty = dtc->dirty;\n\tunsigned long freerun = dirty_freerun_ceiling(dtc->thresh, dtc->bg_thresh);\n\tunsigned long limit = hard_dirty_limit(dtc_dom(dtc), dtc->thresh);\n\tunsigned long setpoint = (freerun + limit) / 2;\n\tunsigned long write_bw = wb->avg_write_bandwidth;\n\tunsigned long dirty_ratelimit = wb->dirty_ratelimit;\n\tunsigned long dirty_rate;\n\tunsigned long task_ratelimit;\n\tunsigned long balanced_dirty_ratelimit;\n\tunsigned long step;\n\tunsigned long x;\n\tunsigned long shift;\n\n\t/*\n\t * The dirty rate will match the writeout rate in long term, except\n\t * when dirty pages are truncated by userspace or re-dirtied by FS.\n\t */\n\tdirty_rate = (dirtied - wb->dirtied_stamp) * HZ / elapsed;\n\n\t/*\n\t * task_ratelimit reflects each dd's dirty rate for the past 200ms.\n\t */\n\ttask_ratelimit = (u64)dirty_ratelimit *\n\t\t\t\t\tdtc->pos_ratio >> RATELIMIT_CALC_SHIFT;\n\ttask_ratelimit++; /* it helps rampup dirty_ratelimit from tiny values */\n\n\t/*\n\t * A linear estimation of the \"balanced\" throttle rate. The theory is,\n\t * if there are N dd tasks, each throttled at task_ratelimit, the wb's\n\t * dirty_rate will be measured to be (N * task_ratelimit). So the below\n\t * formula will yield the balanced rate limit (write_bw / N).\n\t *\n\t * Note that the expanded form is not a pure rate feedback:\n\t *\trate_(i+1) = rate_(i) * (write_bw / dirty_rate)\t\t     (1)\n\t * but also takes pos_ratio into account:\n\t *\trate_(i+1) = rate_(i) * (write_bw / dirty_rate) * pos_ratio  (2)\n\t *\n\t * (1) is not realistic because pos_ratio also takes part in balancing\n\t * the dirty rate.  Consider the state\n\t *\tpos_ratio = 0.5\t\t\t\t\t\t     (3)\n\t *\trate = 2 * (write_bw / N)\t\t\t\t     (4)\n\t * If (1) is used, it will stuck in that state! Because each dd will\n\t * be throttled at\n\t *\ttask_ratelimit = pos_ratio * rate = (write_bw / N)\t     (5)\n\t * yielding\n\t *\tdirty_rate = N * task_ratelimit = write_bw\t\t     (6)\n\t * put (6) into (1) we get\n\t *\trate_(i+1) = rate_(i)\t\t\t\t\t     (7)\n\t *\n\t * So we end up using (2) to always keep\n\t *\trate_(i+1) ~= (write_bw / N)\t\t\t\t     (8)\n\t * regardless of the value of pos_ratio. As long as (8) is satisfied,\n\t * pos_ratio is able to drive itself to 1.0, which is not only where\n\t * the dirty count meet the setpoint, but also where the slope of\n\t * pos_ratio is most flat and hence task_ratelimit is least fluctuated.\n\t */\n\tbalanced_dirty_ratelimit = div_u64((u64)task_ratelimit * write_bw,\n\t\t\t\t\t   dirty_rate | 1);\n\t/*\n\t * balanced_dirty_ratelimit ~= (write_bw / N) <= write_bw\n\t */\n\tif (unlikely(balanced_dirty_ratelimit > write_bw))\n\t\tbalanced_dirty_ratelimit = write_bw;\n\n\t/*\n\t * We could safely do this and return immediately:\n\t *\n\t *\twb->dirty_ratelimit = balanced_dirty_ratelimit;\n\t *\n\t * However to get a more stable dirty_ratelimit, the below elaborated\n\t * code makes use of task_ratelimit to filter out singular points and\n\t * limit the step size.\n\t *\n\t * The below code essentially only uses the relative value of\n\t *\n\t *\ttask_ratelimit - dirty_ratelimit\n\t *\t= (pos_ratio - 1) * dirty_ratelimit\n\t *\n\t * which reflects the direction and size of dirty position error.\n\t */\n\n\t/*\n\t * dirty_ratelimit will follow balanced_dirty_ratelimit iff\n\t * task_ratelimit is on the same side of dirty_ratelimit, too.\n\t * For example, when\n\t * - dirty_ratelimit > balanced_dirty_ratelimit\n\t * - dirty_ratelimit > task_ratelimit (dirty pages are above setpoint)\n\t * lowering dirty_ratelimit will help meet both the position and rate\n\t * control targets. Otherwise, don't update dirty_ratelimit if it will\n\t * only help meet the rate target. After all, what the users ultimately\n\t * feel and care are stable dirty rate and small position error.\n\t *\n\t * |task_ratelimit - dirty_ratelimit| is used to limit the step size\n\t * and filter out the singular points of balanced_dirty_ratelimit. Which\n\t * keeps jumping around randomly and can even leap far away at times\n\t * due to the small 200ms estimation period of dirty_rate (we want to\n\t * keep that period small to reduce time lags).\n\t */\n\tstep = 0;\n\n\t/*\n\t * For strictlimit case, calculations above were based on wb counters\n\t * and limits (starting from pos_ratio = wb_position_ratio() and up to\n\t * balanced_dirty_ratelimit = task_ratelimit * write_bw / dirty_rate).\n\t * Hence, to calculate \"step\" properly, we have to use wb_dirty as\n\t * \"dirty\" and wb_setpoint as \"setpoint\".\n\t *\n\t * We rampup dirty_ratelimit forcibly if wb_dirty is low because\n\t * it's possible that wb_thresh is close to zero due to inactivity\n\t * of backing device.\n\t */\n\tif (unlikely(wb->bdi->capabilities & BDI_CAP_STRICTLIMIT)) {\n\t\tdirty = dtc->wb_dirty;\n\t\tif (dtc->wb_dirty < 8)\n\t\t\tsetpoint = dtc->wb_dirty + 1;\n\t\telse\n\t\t\tsetpoint = (dtc->wb_thresh + dtc->wb_bg_thresh) / 2;\n\t}\n\n\tif (dirty < setpoint) {\n\t\tx = min3(wb->balanced_dirty_ratelimit,\n\t\t\t balanced_dirty_ratelimit, task_ratelimit);\n\t\tif (dirty_ratelimit < x)\n\t\t\tstep = x - dirty_ratelimit;\n\t} else {\n\t\tx = max3(wb->balanced_dirty_ratelimit,\n\t\t\t balanced_dirty_ratelimit, task_ratelimit);\n\t\tif (dirty_ratelimit > x)\n\t\t\tstep = dirty_ratelimit - x;\n\t}\n\n\t/*\n\t * Don't pursue 100% rate matching. It's impossible since the balanced\n\t * rate itself is constantly fluctuating. So decrease the track speed\n\t * when it gets close to the target. Helps eliminate pointless tremors.\n\t */\n\tshift = dirty_ratelimit / (2 * step + 1);\n\tif (shift < BITS_PER_LONG)\n\t\tstep = DIV_ROUND_UP(step >> shift, 8);\n\telse\n\t\tstep = 0;\n\n\tif (dirty_ratelimit < balanced_dirty_ratelimit)\n\t\tdirty_ratelimit += step;\n\telse\n\t\tdirty_ratelimit -= step;\n\n\twb->dirty_ratelimit = max(dirty_ratelimit, 1UL);\n\twb->balanced_dirty_ratelimit = balanced_dirty_ratelimit;\n\n\ttrace_bdi_dirty_ratelimit(wb, dirty_rate, task_ratelimit);\n}"
  },
  {
    "function_name": "domain_update_bandwidth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "1161-1178",
    "snippet": "static void domain_update_bandwidth(struct dirty_throttle_control *dtc,\n\t\t\t\t    unsigned long now)\n{\n\tstruct wb_domain *dom = dtc_dom(dtc);\n\n\t/*\n\t * check locklessly first to optimize away locking for the most time\n\t */\n\tif (time_before(now, dom->dirty_limit_tstamp + BANDWIDTH_INTERVAL))\n\t\treturn;\n\n\tspin_lock(&dom->lock);\n\tif (time_after_eq(now, dom->dirty_limit_tstamp + BANDWIDTH_INTERVAL)) {\n\t\tupdate_dirty_limit(dtc);\n\t\tdom->dirty_limit_tstamp = now;\n\t}\n\tspin_unlock(&dom->lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define BANDWIDTH_INTERVAL\tmax(HZ/5, 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dom->lock"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_dirty_limit",
          "args": [
            "dtc"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "update_dirty_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1132-1159",
          "snippet": "static void update_dirty_limit(struct dirty_throttle_control *dtc)\n{\n\tstruct wb_domain *dom = dtc_dom(dtc);\n\tunsigned long thresh = dtc->thresh;\n\tunsigned long limit = dom->dirty_limit;\n\n\t/*\n\t * Follow up in one step.\n\t */\n\tif (limit < thresh) {\n\t\tlimit = thresh;\n\t\tgoto update;\n\t}\n\n\t/*\n\t * Follow down slowly. Use the higher one as the target, because thresh\n\t * may drop below dirty. This is exactly the reason to introduce\n\t * dom->dirty_limit which is guaranteed to lie above the dirty pages.\n\t */\n\tthresh = max(thresh, dtc->dirty);\n\tif (limit > thresh) {\n\t\tlimit -= (limit - thresh) >> 5;\n\t\tgoto update;\n\t}\n\treturn;\nupdate:\n\tdom->dirty_limit = limit;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void update_dirty_limit(struct dirty_throttle_control *dtc)\n{\n\tstruct wb_domain *dom = dtc_dom(dtc);\n\tunsigned long thresh = dtc->thresh;\n\tunsigned long limit = dom->dirty_limit;\n\n\t/*\n\t * Follow up in one step.\n\t */\n\tif (limit < thresh) {\n\t\tlimit = thresh;\n\t\tgoto update;\n\t}\n\n\t/*\n\t * Follow down slowly. Use the higher one as the target, because thresh\n\t * may drop below dirty. This is exactly the reason to introduce\n\t * dom->dirty_limit which is guaranteed to lie above the dirty pages.\n\t */\n\tthresh = max(thresh, dtc->dirty);\n\tif (limit > thresh) {\n\t\tlimit -= (limit - thresh) >> 5;\n\t\tgoto update;\n\t}\n\treturn;\nupdate:\n\tdom->dirty_limit = limit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "now",
            "dom->dirty_limit_tstamp + BANDWIDTH_INTERVAL"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dom->lock"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "now",
            "dom->dirty_limit_tstamp + BANDWIDTH_INTERVAL"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtc_dom",
          "args": [
            "dtc"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "dtc_dom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "227-230",
          "snippet": "static struct wb_domain *dtc_dom(struct dirty_throttle_control *dtc)\n{\n\treturn &global_wb_domain;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct wb_domain global_wb_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct wb_domain global_wb_domain;\n\nstatic struct wb_domain *dtc_dom(struct dirty_throttle_control *dtc)\n{\n\treturn &global_wb_domain;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define BANDWIDTH_INTERVAL\tmax(HZ/5, 1)\n\nstatic void domain_update_bandwidth(struct dirty_throttle_control *dtc,\n\t\t\t\t    unsigned long now)\n{\n\tstruct wb_domain *dom = dtc_dom(dtc);\n\n\t/*\n\t * check locklessly first to optimize away locking for the most time\n\t */\n\tif (time_before(now, dom->dirty_limit_tstamp + BANDWIDTH_INTERVAL))\n\t\treturn;\n\n\tspin_lock(&dom->lock);\n\tif (time_after_eq(now, dom->dirty_limit_tstamp + BANDWIDTH_INTERVAL)) {\n\t\tupdate_dirty_limit(dtc);\n\t\tdom->dirty_limit_tstamp = now;\n\t}\n\tspin_unlock(&dom->lock);\n}"
  },
  {
    "function_name": "update_dirty_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "1132-1159",
    "snippet": "static void update_dirty_limit(struct dirty_throttle_control *dtc)\n{\n\tstruct wb_domain *dom = dtc_dom(dtc);\n\tunsigned long thresh = dtc->thresh;\n\tunsigned long limit = dom->dirty_limit;\n\n\t/*\n\t * Follow up in one step.\n\t */\n\tif (limit < thresh) {\n\t\tlimit = thresh;\n\t\tgoto update;\n\t}\n\n\t/*\n\t * Follow down slowly. Use the higher one as the target, because thresh\n\t * may drop below dirty. This is exactly the reason to introduce\n\t * dom->dirty_limit which is guaranteed to lie above the dirty pages.\n\t */\n\tthresh = max(thresh, dtc->dirty);\n\tif (limit > thresh) {\n\t\tlimit -= (limit - thresh) >> 5;\n\t\tgoto update;\n\t}\n\treturn;\nupdate:\n\tdom->dirty_limit = limit;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "thresh",
            "dtc->dirty"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtc_dom",
          "args": [
            "dtc"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "dtc_dom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "227-230",
          "snippet": "static struct wb_domain *dtc_dom(struct dirty_throttle_control *dtc)\n{\n\treturn &global_wb_domain;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct wb_domain global_wb_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct wb_domain global_wb_domain;\n\nstatic struct wb_domain *dtc_dom(struct dirty_throttle_control *dtc)\n{\n\treturn &global_wb_domain;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void update_dirty_limit(struct dirty_throttle_control *dtc)\n{\n\tstruct wb_domain *dom = dtc_dom(dtc);\n\tunsigned long thresh = dtc->thresh;\n\tunsigned long limit = dom->dirty_limit;\n\n\t/*\n\t * Follow up in one step.\n\t */\n\tif (limit < thresh) {\n\t\tlimit = thresh;\n\t\tgoto update;\n\t}\n\n\t/*\n\t * Follow down slowly. Use the higher one as the target, because thresh\n\t * may drop below dirty. This is exactly the reason to introduce\n\t * dom->dirty_limit which is guaranteed to lie above the dirty pages.\n\t */\n\tthresh = max(thresh, dtc->dirty);\n\tif (limit > thresh) {\n\t\tlimit -= (limit - thresh) >> 5;\n\t\tgoto update;\n\t}\n\treturn;\nupdate:\n\tdom->dirty_limit = limit;\n}"
  },
  {
    "function_name": "wb_update_write_bandwidth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "1082-1130",
    "snippet": "static void wb_update_write_bandwidth(struct bdi_writeback *wb,\n\t\t\t\t      unsigned long elapsed,\n\t\t\t\t      unsigned long written)\n{\n\tconst unsigned long period = roundup_pow_of_two(3 * HZ);\n\tunsigned long avg = wb->avg_write_bandwidth;\n\tunsigned long old = wb->write_bandwidth;\n\tu64 bw;\n\n\t/*\n\t * bw = written * HZ / elapsed\n\t *\n\t *                   bw * elapsed + write_bandwidth * (period - elapsed)\n\t * write_bandwidth = ---------------------------------------------------\n\t *                                          period\n\t *\n\t * @written may have decreased due to account_page_redirty().\n\t * Avoid underflowing @bw calculation.\n\t */\n\tbw = written - min(written, wb->written_stamp);\n\tbw *= HZ;\n\tif (unlikely(elapsed > period)) {\n\t\tdo_div(bw, elapsed);\n\t\tavg = bw;\n\t\tgoto out;\n\t}\n\tbw += (u64)wb->write_bandwidth * (period - elapsed);\n\tbw >>= ilog2(period);\n\n\t/*\n\t * one more level of smoothing, for filtering out sudden spikes\n\t */\n\tif (avg > old && old >= (unsigned long)bw)\n\t\tavg -= (avg - old) >> 3;\n\n\tif (avg < old && old <= (unsigned long)bw)\n\t\tavg += (old - avg) >> 3;\n\nout:\n\t/* keep avg > 0 to guarantee that tot > 0 if there are dirty wbs */\n\tavg = max(avg, 1LU);\n\tif (wb_has_dirty_io(wb)) {\n\t\tlong delta = avg - wb->avg_write_bandwidth;\n\t\tWARN_ON_ONCE(atomic_long_add_return(delta,\n\t\t\t\t\t&wb->bdi->tot_write_bandwidth) <= 0);\n\t}\n\twb->write_bandwidth = bw;\n\twb->avg_write_bandwidth = avg;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "atomic_long_add_return(delta,\n\t\t\t\t\t&wb->bdi->tot_write_bandwidth) <= 0"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_add_return",
          "args": [
            "delta",
            "&wb->bdi->tot_write_bandwidth"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_has_dirty_io",
          "args": [
            "wb"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "avg",
            "1LU"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "period"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "bw",
            "elapsed"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "elapsed > period"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "written",
            "wb->written_stamp"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_set_min_ratio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "674-693",
          "snippet": "int bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)\n{\n\tint ret = 0;\n\n\tspin_lock_bh(&bdi_lock);\n\tif (min_ratio > bdi->max_ratio) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tmin_ratio -= bdi->min_ratio;\n\t\tif (bdi_min_ratio + min_ratio < 100) {\n\t\t\tbdi_min_ratio += min_ratio;\n\t\t\tbdi->min_ratio += min_ratio;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tspin_unlock_bh(&bdi_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int bdi_min_ratio;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned int bdi_min_ratio;\n\nint bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)\n{\n\tint ret = 0;\n\n\tspin_lock_bh(&bdi_lock);\n\tif (min_ratio > bdi->max_ratio) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tmin_ratio -= bdi->min_ratio;\n\t\tif (bdi_min_ratio + min_ratio < 100) {\n\t\t\tbdi_min_ratio += min_ratio;\n\t\t\tbdi->min_ratio += min_ratio;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tspin_unlock_bh(&bdi_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "3 * HZ"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_update_write_bandwidth(struct bdi_writeback *wb,\n\t\t\t\t      unsigned long elapsed,\n\t\t\t\t      unsigned long written)\n{\n\tconst unsigned long period = roundup_pow_of_two(3 * HZ);\n\tunsigned long avg = wb->avg_write_bandwidth;\n\tunsigned long old = wb->write_bandwidth;\n\tu64 bw;\n\n\t/*\n\t * bw = written * HZ / elapsed\n\t *\n\t *                   bw * elapsed + write_bandwidth * (period - elapsed)\n\t * write_bandwidth = ---------------------------------------------------\n\t *                                          period\n\t *\n\t * @written may have decreased due to account_page_redirty().\n\t * Avoid underflowing @bw calculation.\n\t */\n\tbw = written - min(written, wb->written_stamp);\n\tbw *= HZ;\n\tif (unlikely(elapsed > period)) {\n\t\tdo_div(bw, elapsed);\n\t\tavg = bw;\n\t\tgoto out;\n\t}\n\tbw += (u64)wb->write_bandwidth * (period - elapsed);\n\tbw >>= ilog2(period);\n\n\t/*\n\t * one more level of smoothing, for filtering out sudden spikes\n\t */\n\tif (avg > old && old >= (unsigned long)bw)\n\t\tavg -= (avg - old) >> 3;\n\n\tif (avg < old && old <= (unsigned long)bw)\n\t\tavg += (old - avg) >> 3;\n\nout:\n\t/* keep avg > 0 to guarantee that tot > 0 if there are dirty wbs */\n\tavg = max(avg, 1LU);\n\tif (wb_has_dirty_io(wb)) {\n\t\tlong delta = avg - wb->avg_write_bandwidth;\n\t\tWARN_ON_ONCE(atomic_long_add_return(delta,\n\t\t\t\t\t&wb->bdi->tot_write_bandwidth) <= 0);\n\t}\n\twb->write_bandwidth = bw;\n\twb->avg_write_bandwidth = avg;\n}"
  },
  {
    "function_name": "wb_position_ratio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "903-1080",
    "snippet": "static void wb_position_ratio(struct dirty_throttle_control *dtc)\n{\n\tstruct bdi_writeback *wb = dtc->wb;\n\tunsigned long write_bw = wb->avg_write_bandwidth;\n\tunsigned long freerun = dirty_freerun_ceiling(dtc->thresh, dtc->bg_thresh);\n\tunsigned long limit = hard_dirty_limit(dtc_dom(dtc), dtc->thresh);\n\tunsigned long wb_thresh = dtc->wb_thresh;\n\tunsigned long x_intercept;\n\tunsigned long setpoint;\t\t/* dirty pages' target balance point */\n\tunsigned long wb_setpoint;\n\tunsigned long span;\n\tlong long pos_ratio;\t\t/* for scaling up/down the rate limit */\n\tlong x;\n\n\tdtc->pos_ratio = 0;\n\n\tif (unlikely(dtc->dirty >= limit))\n\t\treturn;\n\n\t/*\n\t * global setpoint\n\t *\n\t * See comment for pos_ratio_polynom().\n\t */\n\tsetpoint = (freerun + limit) / 2;\n\tpos_ratio = pos_ratio_polynom(setpoint, dtc->dirty, limit);\n\n\t/*\n\t * The strictlimit feature is a tool preventing mistrusted filesystems\n\t * from growing a large number of dirty pages before throttling. For\n\t * such filesystems balance_dirty_pages always checks wb counters\n\t * against wb limits. Even if global \"nr_dirty\" is under \"freerun\".\n\t * This is especially important for fuse which sets bdi->max_ratio to\n\t * 1% by default. Without strictlimit feature, fuse writeback may\n\t * consume arbitrary amount of RAM because it is accounted in\n\t * NR_WRITEBACK_TEMP which is not involved in calculating \"nr_dirty\".\n\t *\n\t * Here, in wb_position_ratio(), we calculate pos_ratio based on\n\t * two values: wb_dirty and wb_thresh. Let's consider an example:\n\t * total amount of RAM is 16GB, bdi->max_ratio is equal to 1%, global\n\t * limits are set by default to 10% and 20% (background and throttle).\n\t * Then wb_thresh is 1% of 20% of 16GB. This amounts to ~8K pages.\n\t * wb_calc_thresh(wb, bg_thresh) is about ~4K pages. wb_setpoint is\n\t * about ~6K pages (as the average of background and throttle wb\n\t * limits). The 3rd order polynomial will provide positive feedback if\n\t * wb_dirty is under wb_setpoint and vice versa.\n\t *\n\t * Note, that we cannot use global counters in these calculations\n\t * because we want to throttle process writing to a strictlimit wb\n\t * much earlier than global \"freerun\" is reached (~23MB vs. ~2.3GB\n\t * in the example above).\n\t */\n\tif (unlikely(wb->bdi->capabilities & BDI_CAP_STRICTLIMIT)) {\n\t\tlong long wb_pos_ratio;\n\n\t\tif (dtc->wb_dirty < 8) {\n\t\t\tdtc->pos_ratio = min_t(long long, pos_ratio * 2,\n\t\t\t\t\t   2 << RATELIMIT_CALC_SHIFT);\n\t\t\treturn;\n\t\t}\n\n\t\tif (dtc->wb_dirty >= wb_thresh)\n\t\t\treturn;\n\n\t\twb_setpoint = dirty_freerun_ceiling(wb_thresh,\n\t\t\t\t\t\t    dtc->wb_bg_thresh);\n\n\t\tif (wb_setpoint == 0 || wb_setpoint == wb_thresh)\n\t\t\treturn;\n\n\t\twb_pos_ratio = pos_ratio_polynom(wb_setpoint, dtc->wb_dirty,\n\t\t\t\t\t\t wb_thresh);\n\n\t\t/*\n\t\t * Typically, for strictlimit case, wb_setpoint << setpoint\n\t\t * and pos_ratio >> wb_pos_ratio. In the other words global\n\t\t * state (\"dirty\") is not limiting factor and we have to\n\t\t * make decision based on wb counters. But there is an\n\t\t * important case when global pos_ratio should get precedence:\n\t\t * global limits are exceeded (e.g. due to activities on other\n\t\t * wb's) while given strictlimit wb is below limit.\n\t\t *\n\t\t * \"pos_ratio * wb_pos_ratio\" would work for the case above,\n\t\t * but it would look too non-natural for the case of all\n\t\t * activity in the system coming from a single strictlimit wb\n\t\t * with bdi->max_ratio == 100%.\n\t\t *\n\t\t * Note that min() below somewhat changes the dynamics of the\n\t\t * control system. Normally, pos_ratio value can be well over 3\n\t\t * (when globally we are at freerun and wb is well below wb\n\t\t * setpoint). Now the maximum pos_ratio in the same situation\n\t\t * is 2. We might want to tweak this if we observe the control\n\t\t * system is too slow to adapt.\n\t\t */\n\t\tdtc->pos_ratio = min(pos_ratio, wb_pos_ratio);\n\t\treturn;\n\t}\n\n\t/*\n\t * We have computed basic pos_ratio above based on global situation. If\n\t * the wb is over/under its share of dirty pages, we want to scale\n\t * pos_ratio further down/up. That is done by the following mechanism.\n\t */\n\n\t/*\n\t * wb setpoint\n\t *\n\t *        f(wb_dirty) := 1.0 + k * (wb_dirty - wb_setpoint)\n\t *\n\t *                        x_intercept - wb_dirty\n\t *                     := --------------------------\n\t *                        x_intercept - wb_setpoint\n\t *\n\t * The main wb control line is a linear function that subjects to\n\t *\n\t * (1) f(wb_setpoint) = 1.0\n\t * (2) k = - 1 / (8 * write_bw)  (in single wb case)\n\t *     or equally: x_intercept = wb_setpoint + 8 * write_bw\n\t *\n\t * For single wb case, the dirty pages are observed to fluctuate\n\t * regularly within range\n\t *        [wb_setpoint - write_bw/2, wb_setpoint + write_bw/2]\n\t * for various filesystems, where (2) can yield in a reasonable 12.5%\n\t * fluctuation range for pos_ratio.\n\t *\n\t * For JBOD case, wb_thresh (not wb_dirty!) could fluctuate up to its\n\t * own size, so move the slope over accordingly and choose a slope that\n\t * yields 100% pos_ratio fluctuation on suddenly doubled wb_thresh.\n\t */\n\tif (unlikely(wb_thresh > dtc->thresh))\n\t\twb_thresh = dtc->thresh;\n\t/*\n\t * It's very possible that wb_thresh is close to 0 not because the\n\t * device is slow, but that it has remained inactive for long time.\n\t * Honour such devices a reasonable good (hopefully IO efficient)\n\t * threshold, so that the occasional writes won't be blocked and active\n\t * writes can rampup the threshold quickly.\n\t */\n\twb_thresh = max(wb_thresh, (limit - dtc->dirty) / 8);\n\t/*\n\t * scale global setpoint to wb's:\n\t *\twb_setpoint = setpoint * wb_thresh / thresh\n\t */\n\tx = div_u64((u64)wb_thresh << 16, dtc->thresh | 1);\n\twb_setpoint = setpoint * (u64)x >> 16;\n\t/*\n\t * Use span=(8*write_bw) in single wb case as indicated by\n\t * (thresh - wb_thresh ~= 0) and transit to wb_thresh in JBOD case.\n\t *\n\t *        wb_thresh                    thresh - wb_thresh\n\t * span = --------- * (8 * write_bw) + ------------------ * wb_thresh\n\t *         thresh                           thresh\n\t */\n\tspan = (dtc->thresh - wb_thresh + 8 * write_bw) * (u64)x >> 16;\n\tx_intercept = wb_setpoint + span;\n\n\tif (dtc->wb_dirty < x_intercept - span / 4) {\n\t\tpos_ratio = div64_u64(pos_ratio * (x_intercept - dtc->wb_dirty),\n\t\t\t\t      (x_intercept - wb_setpoint) | 1);\n\t} else\n\t\tpos_ratio /= 4;\n\n\t/*\n\t * wb reserve area, safeguard against dirty pool underrun and disk idle\n\t * It may push the desired control point of global dirty pages higher\n\t * than setpoint.\n\t */\n\tx_intercept = wb_thresh / 2;\n\tif (dtc->wb_dirty < x_intercept) {\n\t\tif (dtc->wb_dirty > x_intercept / 8)\n\t\t\tpos_ratio = div_u64(pos_ratio * x_intercept,\n\t\t\t\t\t    dtc->wb_dirty);\n\t\telse\n\t\t\tpos_ratio *= 8;\n\t}\n\n\tdtc->pos_ratio = pos_ratio;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define RATELIMIT_CALC_SHIFT\t10"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "pos_ratio * x_intercept",
            "dtc->wb_dirty"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "pos_ratio * (x_intercept - dtc->wb_dirty)",
            "(x_intercept - wb_setpoint) | 1"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "(u64)wb_thresh << 16",
            "dtc->thresh | 1"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "wb_thresh",
            "(limit - dtc->dirty) / 8"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "wb_thresh > dtc->thresh"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "pos_ratio",
            "wb_pos_ratio"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_set_min_ratio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "674-693",
          "snippet": "int bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)\n{\n\tint ret = 0;\n\n\tspin_lock_bh(&bdi_lock);\n\tif (min_ratio > bdi->max_ratio) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tmin_ratio -= bdi->min_ratio;\n\t\tif (bdi_min_ratio + min_ratio < 100) {\n\t\t\tbdi_min_ratio += min_ratio;\n\t\t\tbdi->min_ratio += min_ratio;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tspin_unlock_bh(&bdi_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int bdi_min_ratio;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned int bdi_min_ratio;\n\nint bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)\n{\n\tint ret = 0;\n\n\tspin_lock_bh(&bdi_lock);\n\tif (min_ratio > bdi->max_ratio) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tmin_ratio -= bdi->min_ratio;\n\t\tif (bdi_min_ratio + min_ratio < 100) {\n\t\t\tbdi_min_ratio += min_ratio;\n\t\t\tbdi->min_ratio += min_ratio;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tspin_unlock_bh(&bdi_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pos_ratio_polynom",
          "args": [
            "wb_setpoint",
            "dtc->wb_dirty",
            "wb_thresh"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "pos_ratio_polynom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "811-826",
          "snippet": "static long long pos_ratio_polynom(unsigned long setpoint,\n\t\t\t\t\t  unsigned long dirty,\n\t\t\t\t\t  unsigned long limit)\n{\n\tlong long pos_ratio;\n\tlong x;\n\n\tx = div64_s64(((s64)setpoint - (s64)dirty) << RATELIMIT_CALC_SHIFT,\n\t\t      (limit - setpoint) | 1);\n\tpos_ratio = x;\n\tpos_ratio = pos_ratio * x >> RATELIMIT_CALC_SHIFT;\n\tpos_ratio = pos_ratio * x >> RATELIMIT_CALC_SHIFT;\n\tpos_ratio += 1 << RATELIMIT_CALC_SHIFT;\n\n\treturn clamp(pos_ratio, 0LL, 2LL << RATELIMIT_CALC_SHIFT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define RATELIMIT_CALC_SHIFT\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define RATELIMIT_CALC_SHIFT\t10\n\nstatic long long pos_ratio_polynom(unsigned long setpoint,\n\t\t\t\t\t  unsigned long dirty,\n\t\t\t\t\t  unsigned long limit)\n{\n\tlong long pos_ratio;\n\tlong x;\n\n\tx = div64_s64(((s64)setpoint - (s64)dirty) << RATELIMIT_CALC_SHIFT,\n\t\t      (limit - setpoint) | 1);\n\tpos_ratio = x;\n\tpos_ratio = pos_ratio * x >> RATELIMIT_CALC_SHIFT;\n\tpos_ratio = pos_ratio * x >> RATELIMIT_CALC_SHIFT;\n\tpos_ratio += 1 << RATELIMIT_CALC_SHIFT;\n\n\treturn clamp(pos_ratio, 0LL, 2LL << RATELIMIT_CALC_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dirty_freerun_ceiling",
          "args": [
            "wb_thresh",
            "dtc->wb_bg_thresh"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "dirty_freerun_ceiling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "715-719",
          "snippet": "static unsigned long dirty_freerun_ceiling(unsigned long thresh,\n\t\t\t\t\t   unsigned long bg_thresh)\n{\n\treturn (thresh + bg_thresh) / 2;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned long dirty_freerun_ceiling(unsigned long thresh,\n\t\t\t\t\t   unsigned long bg_thresh)\n{\n\treturn (thresh + bg_thresh) / 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "longlong",
            "pos_ratio * 2",
            "2 << RATELIMIT_CALC_SHIFT"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "wb->bdi->capabilities & BDI_CAP_STRICTLIMIT"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dtc->dirty >= limit"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hard_dirty_limit",
          "args": [
            "dtc_dom(dtc)",
            "dtc->thresh"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "hard_dirty_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "721-725",
          "snippet": "static unsigned long hard_dirty_limit(struct wb_domain *dom,\n\t\t\t\t      unsigned long thresh)\n{\n\treturn max(thresh, dom->dirty_limit);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned long hard_dirty_limit(struct wb_domain *dom,\n\t\t\t\t      unsigned long thresh)\n{\n\treturn max(thresh, dom->dirty_limit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtc_dom",
          "args": [
            "dtc"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "dtc_dom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "227-230",
          "snippet": "static struct wb_domain *dtc_dom(struct dirty_throttle_control *dtc)\n{\n\treturn &global_wb_domain;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct wb_domain global_wb_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct wb_domain global_wb_domain;\n\nstatic struct wb_domain *dtc_dom(struct dirty_throttle_control *dtc)\n{\n\treturn &global_wb_domain;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define RATELIMIT_CALC_SHIFT\t10\n\nstatic void wb_position_ratio(struct dirty_throttle_control *dtc)\n{\n\tstruct bdi_writeback *wb = dtc->wb;\n\tunsigned long write_bw = wb->avg_write_bandwidth;\n\tunsigned long freerun = dirty_freerun_ceiling(dtc->thresh, dtc->bg_thresh);\n\tunsigned long limit = hard_dirty_limit(dtc_dom(dtc), dtc->thresh);\n\tunsigned long wb_thresh = dtc->wb_thresh;\n\tunsigned long x_intercept;\n\tunsigned long setpoint;\t\t/* dirty pages' target balance point */\n\tunsigned long wb_setpoint;\n\tunsigned long span;\n\tlong long pos_ratio;\t\t/* for scaling up/down the rate limit */\n\tlong x;\n\n\tdtc->pos_ratio = 0;\n\n\tif (unlikely(dtc->dirty >= limit))\n\t\treturn;\n\n\t/*\n\t * global setpoint\n\t *\n\t * See comment for pos_ratio_polynom().\n\t */\n\tsetpoint = (freerun + limit) / 2;\n\tpos_ratio = pos_ratio_polynom(setpoint, dtc->dirty, limit);\n\n\t/*\n\t * The strictlimit feature is a tool preventing mistrusted filesystems\n\t * from growing a large number of dirty pages before throttling. For\n\t * such filesystems balance_dirty_pages always checks wb counters\n\t * against wb limits. Even if global \"nr_dirty\" is under \"freerun\".\n\t * This is especially important for fuse which sets bdi->max_ratio to\n\t * 1% by default. Without strictlimit feature, fuse writeback may\n\t * consume arbitrary amount of RAM because it is accounted in\n\t * NR_WRITEBACK_TEMP which is not involved in calculating \"nr_dirty\".\n\t *\n\t * Here, in wb_position_ratio(), we calculate pos_ratio based on\n\t * two values: wb_dirty and wb_thresh. Let's consider an example:\n\t * total amount of RAM is 16GB, bdi->max_ratio is equal to 1%, global\n\t * limits are set by default to 10% and 20% (background and throttle).\n\t * Then wb_thresh is 1% of 20% of 16GB. This amounts to ~8K pages.\n\t * wb_calc_thresh(wb, bg_thresh) is about ~4K pages. wb_setpoint is\n\t * about ~6K pages (as the average of background and throttle wb\n\t * limits). The 3rd order polynomial will provide positive feedback if\n\t * wb_dirty is under wb_setpoint and vice versa.\n\t *\n\t * Note, that we cannot use global counters in these calculations\n\t * because we want to throttle process writing to a strictlimit wb\n\t * much earlier than global \"freerun\" is reached (~23MB vs. ~2.3GB\n\t * in the example above).\n\t */\n\tif (unlikely(wb->bdi->capabilities & BDI_CAP_STRICTLIMIT)) {\n\t\tlong long wb_pos_ratio;\n\n\t\tif (dtc->wb_dirty < 8) {\n\t\t\tdtc->pos_ratio = min_t(long long, pos_ratio * 2,\n\t\t\t\t\t   2 << RATELIMIT_CALC_SHIFT);\n\t\t\treturn;\n\t\t}\n\n\t\tif (dtc->wb_dirty >= wb_thresh)\n\t\t\treturn;\n\n\t\twb_setpoint = dirty_freerun_ceiling(wb_thresh,\n\t\t\t\t\t\t    dtc->wb_bg_thresh);\n\n\t\tif (wb_setpoint == 0 || wb_setpoint == wb_thresh)\n\t\t\treturn;\n\n\t\twb_pos_ratio = pos_ratio_polynom(wb_setpoint, dtc->wb_dirty,\n\t\t\t\t\t\t wb_thresh);\n\n\t\t/*\n\t\t * Typically, for strictlimit case, wb_setpoint << setpoint\n\t\t * and pos_ratio >> wb_pos_ratio. In the other words global\n\t\t * state (\"dirty\") is not limiting factor and we have to\n\t\t * make decision based on wb counters. But there is an\n\t\t * important case when global pos_ratio should get precedence:\n\t\t * global limits are exceeded (e.g. due to activities on other\n\t\t * wb's) while given strictlimit wb is below limit.\n\t\t *\n\t\t * \"pos_ratio * wb_pos_ratio\" would work for the case above,\n\t\t * but it would look too non-natural for the case of all\n\t\t * activity in the system coming from a single strictlimit wb\n\t\t * with bdi->max_ratio == 100%.\n\t\t *\n\t\t * Note that min() below somewhat changes the dynamics of the\n\t\t * control system. Normally, pos_ratio value can be well over 3\n\t\t * (when globally we are at freerun and wb is well below wb\n\t\t * setpoint). Now the maximum pos_ratio in the same situation\n\t\t * is 2. We might want to tweak this if we observe the control\n\t\t * system is too slow to adapt.\n\t\t */\n\t\tdtc->pos_ratio = min(pos_ratio, wb_pos_ratio);\n\t\treturn;\n\t}\n\n\t/*\n\t * We have computed basic pos_ratio above based on global situation. If\n\t * the wb is over/under its share of dirty pages, we want to scale\n\t * pos_ratio further down/up. That is done by the following mechanism.\n\t */\n\n\t/*\n\t * wb setpoint\n\t *\n\t *        f(wb_dirty) := 1.0 + k * (wb_dirty - wb_setpoint)\n\t *\n\t *                        x_intercept - wb_dirty\n\t *                     := --------------------------\n\t *                        x_intercept - wb_setpoint\n\t *\n\t * The main wb control line is a linear function that subjects to\n\t *\n\t * (1) f(wb_setpoint) = 1.0\n\t * (2) k = - 1 / (8 * write_bw)  (in single wb case)\n\t *     or equally: x_intercept = wb_setpoint + 8 * write_bw\n\t *\n\t * For single wb case, the dirty pages are observed to fluctuate\n\t * regularly within range\n\t *        [wb_setpoint - write_bw/2, wb_setpoint + write_bw/2]\n\t * for various filesystems, where (2) can yield in a reasonable 12.5%\n\t * fluctuation range for pos_ratio.\n\t *\n\t * For JBOD case, wb_thresh (not wb_dirty!) could fluctuate up to its\n\t * own size, so move the slope over accordingly and choose a slope that\n\t * yields 100% pos_ratio fluctuation on suddenly doubled wb_thresh.\n\t */\n\tif (unlikely(wb_thresh > dtc->thresh))\n\t\twb_thresh = dtc->thresh;\n\t/*\n\t * It's very possible that wb_thresh is close to 0 not because the\n\t * device is slow, but that it has remained inactive for long time.\n\t * Honour such devices a reasonable good (hopefully IO efficient)\n\t * threshold, so that the occasional writes won't be blocked and active\n\t * writes can rampup the threshold quickly.\n\t */\n\twb_thresh = max(wb_thresh, (limit - dtc->dirty) / 8);\n\t/*\n\t * scale global setpoint to wb's:\n\t *\twb_setpoint = setpoint * wb_thresh / thresh\n\t */\n\tx = div_u64((u64)wb_thresh << 16, dtc->thresh | 1);\n\twb_setpoint = setpoint * (u64)x >> 16;\n\t/*\n\t * Use span=(8*write_bw) in single wb case as indicated by\n\t * (thresh - wb_thresh ~= 0) and transit to wb_thresh in JBOD case.\n\t *\n\t *        wb_thresh                    thresh - wb_thresh\n\t * span = --------- * (8 * write_bw) + ------------------ * wb_thresh\n\t *         thresh                           thresh\n\t */\n\tspan = (dtc->thresh - wb_thresh + 8 * write_bw) * (u64)x >> 16;\n\tx_intercept = wb_setpoint + span;\n\n\tif (dtc->wb_dirty < x_intercept - span / 4) {\n\t\tpos_ratio = div64_u64(pos_ratio * (x_intercept - dtc->wb_dirty),\n\t\t\t\t      (x_intercept - wb_setpoint) | 1);\n\t} else\n\t\tpos_ratio /= 4;\n\n\t/*\n\t * wb reserve area, safeguard against dirty pool underrun and disk idle\n\t * It may push the desired control point of global dirty pages higher\n\t * than setpoint.\n\t */\n\tx_intercept = wb_thresh / 2;\n\tif (dtc->wb_dirty < x_intercept) {\n\t\tif (dtc->wb_dirty > x_intercept / 8)\n\t\t\tpos_ratio = div_u64(pos_ratio * x_intercept,\n\t\t\t\t\t    dtc->wb_dirty);\n\t\telse\n\t\t\tpos_ratio *= 8;\n\t}\n\n\tdtc->pos_ratio = pos_ratio;\n}"
  },
  {
    "function_name": "pos_ratio_polynom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "811-826",
    "snippet": "static long long pos_ratio_polynom(unsigned long setpoint,\n\t\t\t\t\t  unsigned long dirty,\n\t\t\t\t\t  unsigned long limit)\n{\n\tlong long pos_ratio;\n\tlong x;\n\n\tx = div64_s64(((s64)setpoint - (s64)dirty) << RATELIMIT_CALC_SHIFT,\n\t\t      (limit - setpoint) | 1);\n\tpos_ratio = x;\n\tpos_ratio = pos_ratio * x >> RATELIMIT_CALC_SHIFT;\n\tpos_ratio = pos_ratio * x >> RATELIMIT_CALC_SHIFT;\n\tpos_ratio += 1 << RATELIMIT_CALC_SHIFT;\n\n\treturn clamp(pos_ratio, 0LL, 2LL << RATELIMIT_CALC_SHIFT);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define RATELIMIT_CALC_SHIFT\t10"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clamp",
          "args": [
            "pos_ratio",
            "0LL",
            "2LL << RATELIMIT_CALC_SHIFT"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div64_s64",
          "args": [
            "((s64)setpoint - (s64)dirty) << RATELIMIT_CALC_SHIFT",
            "(limit - setpoint) | 1"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define RATELIMIT_CALC_SHIFT\t10\n\nstatic long long pos_ratio_polynom(unsigned long setpoint,\n\t\t\t\t\t  unsigned long dirty,\n\t\t\t\t\t  unsigned long limit)\n{\n\tlong long pos_ratio;\n\tlong x;\n\n\tx = div64_s64(((s64)setpoint - (s64)dirty) << RATELIMIT_CALC_SHIFT,\n\t\t      (limit - setpoint) | 1);\n\tpos_ratio = x;\n\tpos_ratio = pos_ratio * x >> RATELIMIT_CALC_SHIFT;\n\tpos_ratio = pos_ratio * x >> RATELIMIT_CALC_SHIFT;\n\tpos_ratio += 1 << RATELIMIT_CALC_SHIFT;\n\n\treturn clamp(pos_ratio, 0LL, 2LL << RATELIMIT_CALC_SHIFT);\n}"
  },
  {
    "function_name": "wb_calc_thresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "790-795",
    "snippet": "unsigned long wb_calc_thresh(struct bdi_writeback *wb, unsigned long thresh)\n{\n\tstruct dirty_throttle_control gdtc = { GDTC_INIT(wb),\n\t\t\t\t\t       .thresh = thresh };\n\treturn __wb_calc_thresh(&gdtc);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wb_calc_thresh",
          "args": [
            "&gdtc"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "__wb_calc_thresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "763-788",
          "snippet": "static unsigned long __wb_calc_thresh(struct dirty_throttle_control *dtc)\n{\n\tstruct wb_domain *dom = dtc_dom(dtc);\n\tunsigned long thresh = dtc->thresh;\n\tu64 wb_thresh;\n\tlong numerator, denominator;\n\tunsigned long wb_min_ratio, wb_max_ratio;\n\n\t/*\n\t * Calculate this BDI's share of the thresh ratio.\n\t */\n\tfprop_fraction_percpu(&dom->completions, dtc->wb_completions,\n\t\t\t      &numerator, &denominator);\n\n\twb_thresh = (thresh * (100 - bdi_min_ratio)) / 100;\n\twb_thresh *= numerator;\n\tdo_div(wb_thresh, denominator);\n\n\twb_min_max_ratio(dtc->wb, &wb_min_ratio, &wb_max_ratio);\n\n\twb_thresh += (thresh * wb_min_ratio) / 100;\n\tif (wb_thresh > (thresh * wb_max_ratio) / 100)\n\t\twb_thresh = thresh * wb_max_ratio / 100;\n\n\treturn wb_thresh;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int bdi_min_ratio;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned int bdi_min_ratio;\n\nstatic unsigned long __wb_calc_thresh(struct dirty_throttle_control *dtc)\n{\n\tstruct wb_domain *dom = dtc_dom(dtc);\n\tunsigned long thresh = dtc->thresh;\n\tu64 wb_thresh;\n\tlong numerator, denominator;\n\tunsigned long wb_min_ratio, wb_max_ratio;\n\n\t/*\n\t * Calculate this BDI's share of the thresh ratio.\n\t */\n\tfprop_fraction_percpu(&dom->completions, dtc->wb_completions,\n\t\t\t      &numerator, &denominator);\n\n\twb_thresh = (thresh * (100 - bdi_min_ratio)) / 100;\n\twb_thresh *= numerator;\n\tdo_div(wb_thresh, denominator);\n\n\twb_min_max_ratio(dtc->wb, &wb_min_ratio, &wb_max_ratio);\n\n\twb_thresh += (thresh * wb_min_ratio) / 100;\n\tif (wb_thresh > (thresh * wb_max_ratio) / 100)\n\t\twb_thresh = thresh * wb_max_ratio / 100;\n\n\treturn wb_thresh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GDTC_INIT",
          "args": [
            "wb"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nunsigned long wb_calc_thresh(struct bdi_writeback *wb, unsigned long thresh)\n{\n\tstruct dirty_throttle_control gdtc = { GDTC_INIT(wb),\n\t\t\t\t\t       .thresh = thresh };\n\treturn __wb_calc_thresh(&gdtc);\n}"
  },
  {
    "function_name": "__wb_calc_thresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "763-788",
    "snippet": "static unsigned long __wb_calc_thresh(struct dirty_throttle_control *dtc)\n{\n\tstruct wb_domain *dom = dtc_dom(dtc);\n\tunsigned long thresh = dtc->thresh;\n\tu64 wb_thresh;\n\tlong numerator, denominator;\n\tunsigned long wb_min_ratio, wb_max_ratio;\n\n\t/*\n\t * Calculate this BDI's share of the thresh ratio.\n\t */\n\tfprop_fraction_percpu(&dom->completions, dtc->wb_completions,\n\t\t\t      &numerator, &denominator);\n\n\twb_thresh = (thresh * (100 - bdi_min_ratio)) / 100;\n\twb_thresh *= numerator;\n\tdo_div(wb_thresh, denominator);\n\n\twb_min_max_ratio(dtc->wb, &wb_min_ratio, &wb_max_ratio);\n\n\twb_thresh += (thresh * wb_min_ratio) / 100;\n\tif (wb_thresh > (thresh * wb_max_ratio) / 100)\n\t\twb_thresh = thresh * wb_max_ratio / 100;\n\n\treturn wb_thresh;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int bdi_min_ratio;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wb_min_max_ratio",
          "args": [
            "dtc->wb",
            "&wb_min_ratio",
            "&wb_max_ratio"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "wb_min_max_ratio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "242-247",
          "snippet": "static void wb_min_max_ratio(struct bdi_writeback *wb,\n\t\t\t     unsigned long *minp, unsigned long *maxp)\n{\n\t*minp = wb->bdi->min_ratio;\n\t*maxp = wb->bdi->max_ratio;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_min_max_ratio(struct bdi_writeback *wb,\n\t\t\t     unsigned long *minp, unsigned long *maxp)\n{\n\t*minp = wb->bdi->min_ratio;\n\t*maxp = wb->bdi->max_ratio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "wb_thresh",
            "denominator"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprop_fraction_percpu",
          "args": [
            "&dom->completions",
            "dtc->wb_completions",
            "&numerator",
            "&denominator"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtc_dom",
          "args": [
            "dtc"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "dtc_dom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "227-230",
          "snippet": "static struct wb_domain *dtc_dom(struct dirty_throttle_control *dtc)\n{\n\treturn &global_wb_domain;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct wb_domain global_wb_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct wb_domain global_wb_domain;\n\nstatic struct wb_domain *dtc_dom(struct dirty_throttle_control *dtc)\n{\n\treturn &global_wb_domain;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned int bdi_min_ratio;\n\nstatic unsigned long __wb_calc_thresh(struct dirty_throttle_control *dtc)\n{\n\tstruct wb_domain *dom = dtc_dom(dtc);\n\tunsigned long thresh = dtc->thresh;\n\tu64 wb_thresh;\n\tlong numerator, denominator;\n\tunsigned long wb_min_ratio, wb_max_ratio;\n\n\t/*\n\t * Calculate this BDI's share of the thresh ratio.\n\t */\n\tfprop_fraction_percpu(&dom->completions, dtc->wb_completions,\n\t\t\t      &numerator, &denominator);\n\n\twb_thresh = (thresh * (100 - bdi_min_ratio)) / 100;\n\twb_thresh *= numerator;\n\tdo_div(wb_thresh, denominator);\n\n\twb_min_max_ratio(dtc->wb, &wb_min_ratio, &wb_max_ratio);\n\n\twb_thresh += (thresh * wb_min_ratio) / 100;\n\tif (wb_thresh > (thresh * wb_max_ratio) / 100)\n\t\twb_thresh = thresh * wb_max_ratio / 100;\n\n\treturn wb_thresh;\n}"
  },
  {
    "function_name": "mdtc_calc_avail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "731-740",
    "snippet": "static void mdtc_calc_avail(struct dirty_throttle_control *mdtc,\n\t\t\t    unsigned long filepages, unsigned long headroom)\n{\n\tstruct dirty_throttle_control *gdtc = mdtc_gdtc(mdtc);\n\tunsigned long clean = filepages - min(filepages, mdtc->dirty);\n\tunsigned long global_clean = gdtc->avail - min(gdtc->avail, gdtc->dirty);\n\tunsigned long other_clean = global_clean - min(global_clean, clean);\n\n\tmdtc->avail = filepages + min(headroom, other_clean);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "headroom",
            "other_clean"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_set_min_ratio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "674-693",
          "snippet": "int bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)\n{\n\tint ret = 0;\n\n\tspin_lock_bh(&bdi_lock);\n\tif (min_ratio > bdi->max_ratio) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tmin_ratio -= bdi->min_ratio;\n\t\tif (bdi_min_ratio + min_ratio < 100) {\n\t\t\tbdi_min_ratio += min_ratio;\n\t\t\tbdi->min_ratio += min_ratio;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tspin_unlock_bh(&bdi_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int bdi_min_ratio;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned int bdi_min_ratio;\n\nint bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)\n{\n\tint ret = 0;\n\n\tspin_lock_bh(&bdi_lock);\n\tif (min_ratio > bdi->max_ratio) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tmin_ratio -= bdi->min_ratio;\n\t\tif (bdi_min_ratio + min_ratio < 100) {\n\t\t\tbdi_min_ratio += min_ratio;\n\t\t\tbdi->min_ratio += min_ratio;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tspin_unlock_bh(&bdi_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mdtc_gdtc",
          "args": [
            "mdtc"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "mdtc_gdtc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "232-235",
          "snippet": "static struct dirty_throttle_control *mdtc_gdtc(struct dirty_throttle_control *mdtc)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct dirty_throttle_control *mdtc_gdtc(struct dirty_throttle_control *mdtc)\n{\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void mdtc_calc_avail(struct dirty_throttle_control *mdtc,\n\t\t\t    unsigned long filepages, unsigned long headroom)\n{\n\tstruct dirty_throttle_control *gdtc = mdtc_gdtc(mdtc);\n\tunsigned long clean = filepages - min(filepages, mdtc->dirty);\n\tunsigned long global_clean = gdtc->avail - min(gdtc->avail, gdtc->dirty);\n\tunsigned long other_clean = global_clean - min(global_clean, clean);\n\n\tmdtc->avail = filepages + min(headroom, other_clean);\n}"
  },
  {
    "function_name": "hard_dirty_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "721-725",
    "snippet": "static unsigned long hard_dirty_limit(struct wb_domain *dom,\n\t\t\t\t      unsigned long thresh)\n{\n\treturn max(thresh, dom->dirty_limit);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "thresh",
            "dom->dirty_limit"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned long hard_dirty_limit(struct wb_domain *dom,\n\t\t\t\t      unsigned long thresh)\n{\n\treturn max(thresh, dom->dirty_limit);\n}"
  },
  {
    "function_name": "dirty_freerun_ceiling",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "715-719",
    "snippet": "static unsigned long dirty_freerun_ceiling(unsigned long thresh,\n\t\t\t\t\t   unsigned long bg_thresh)\n{\n\treturn (thresh + bg_thresh) / 2;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned long dirty_freerun_ceiling(unsigned long thresh,\n\t\t\t\t\t   unsigned long bg_thresh)\n{\n\treturn (thresh + bg_thresh) / 2;\n}"
  },
  {
    "function_name": "bdi_set_max_ratio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "695-712",
    "snippet": "int bdi_set_max_ratio(struct backing_dev_info *bdi, unsigned max_ratio)\n{\n\tint ret = 0;\n\n\tif (max_ratio > 100)\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&bdi_lock);\n\tif (bdi->min_ratio > max_ratio) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tbdi->max_ratio = max_ratio;\n\t\tbdi->max_prop_frac = (FPROP_FRAC_BASE * max_ratio) / 100;\n\t}\n\tspin_unlock_bh(&bdi_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&bdi_lock"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&bdi_lock"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint bdi_set_max_ratio(struct backing_dev_info *bdi, unsigned max_ratio)\n{\n\tint ret = 0;\n\n\tif (max_ratio > 100)\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&bdi_lock);\n\tif (bdi->min_ratio > max_ratio) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tbdi->max_ratio = max_ratio;\n\t\tbdi->max_prop_frac = (FPROP_FRAC_BASE * max_ratio) / 100;\n\t}\n\tspin_unlock_bh(&bdi_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "bdi_set_min_ratio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "674-693",
    "snippet": "int bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)\n{\n\tint ret = 0;\n\n\tspin_lock_bh(&bdi_lock);\n\tif (min_ratio > bdi->max_ratio) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tmin_ratio -= bdi->min_ratio;\n\t\tif (bdi_min_ratio + min_ratio < 100) {\n\t\t\tbdi_min_ratio += min_ratio;\n\t\t\tbdi->min_ratio += min_ratio;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tspin_unlock_bh(&bdi_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int bdi_min_ratio;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&bdi_lock"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&bdi_lock"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned int bdi_min_ratio;\n\nint bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)\n{\n\tint ret = 0;\n\n\tspin_lock_bh(&bdi_lock);\n\tif (min_ratio > bdi->max_ratio) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tmin_ratio -= bdi->min_ratio;\n\t\tif (bdi_min_ratio + min_ratio < 100) {\n\t\t\tbdi_min_ratio += min_ratio;\n\t\t\tbdi->min_ratio += min_ratio;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tspin_unlock_bh(&bdi_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "wb_domain_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "660-664",
    "snippet": "void wb_domain_exit(struct wb_domain *dom)\n{\n\tdel_timer_sync(&dom->period_timer);\n\tfprop_global_destroy(&dom->completions);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprop_global_destroy",
          "args": [
            "&dom->completions"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "&dom->period_timer"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid wb_domain_exit(struct wb_domain *dom)\n{\n\tdel_timer_sync(&dom->period_timer);\n\tfprop_global_destroy(&dom->completions);\n}"
  },
  {
    "function_name": "wb_domain_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "646-657",
    "snippet": "int wb_domain_init(struct wb_domain *dom, gfp_t gfp)\n{\n\tmemset(dom, 0, sizeof(*dom));\n\n\tspin_lock_init(&dom->lock);\n\n\ttimer_setup(&dom->period_timer, writeout_period, TIMER_DEFERRABLE);\n\n\tdom->dirty_limit_tstamp = jiffies;\n\n\treturn fprop_global_init(&dom->completions, gfp);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprop_global_init",
          "args": [
            "&dom->completions",
            "gfp"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_setup",
          "args": [
            "&dom->period_timer",
            "writeout_period",
            "TIMER_DEFERRABLE"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&dom->lock"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dom",
            "0",
            "sizeof(*dom)"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint wb_domain_init(struct wb_domain *dom, gfp_t gfp)\n{\n\tmemset(dom, 0, sizeof(*dom));\n\n\tspin_lock_init(&dom->lock);\n\n\ttimer_setup(&dom->period_timer, writeout_period, TIMER_DEFERRABLE);\n\n\tdom->dirty_limit_tstamp = jiffies;\n\n\treturn fprop_global_init(&dom->completions, gfp);\n}"
  },
  {
    "function_name": "writeout_period",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "627-644",
    "snippet": "static void writeout_period(struct timer_list *t)\n{\n\tstruct wb_domain *dom = from_timer(dom, t, period_timer);\n\tint miss_periods = (jiffies - dom->period_time) /\n\t\t\t\t\t\t VM_COMPLETIONS_PERIOD_LEN;\n\n\tif (fprop_new_period(&dom->completions, miss_periods + 1)) {\n\t\tdom->period_time = wp_next_time(dom->period_time +\n\t\t\t\tmiss_periods * VM_COMPLETIONS_PERIOD_LEN);\n\t\tmod_timer(&dom->period_timer, dom->period_time);\n\t} else {\n\t\t/*\n\t\t * Aging has zeroed all fractions. Stop wasting CPU on period\n\t\t * updates.\n\t\t */\n\t\tdom->period_time = 0;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define VM_COMPLETIONS_PERIOD_LEN (3*HZ)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&dom->period_timer",
            "dom->period_time"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wp_next_time",
          "args": [
            "dom->period_time +\n\t\t\t\tmiss_periods * VM_COMPLETIONS_PERIOD_LEN"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "wp_next_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "567-574",
          "snippet": "static unsigned long wp_next_time(unsigned long cur_time)\n{\n\tcur_time += VM_COMPLETIONS_PERIOD_LEN;\n\t/* 0 has a special meaning... */\n\tif (!cur_time)\n\t\treturn 1;\n\treturn cur_time;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define VM_COMPLETIONS_PERIOD_LEN (3*HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define VM_COMPLETIONS_PERIOD_LEN (3*HZ)\n\nstatic unsigned long wp_next_time(unsigned long cur_time)\n{\n\tcur_time += VM_COMPLETIONS_PERIOD_LEN;\n\t/* 0 has a special meaning... */\n\tif (!cur_time)\n\t\treturn 1;\n\treturn cur_time;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprop_new_period",
          "args": [
            "&dom->completions",
            "miss_periods + 1"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_timer",
          "args": [
            "dom",
            "t",
            "period_timer"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define VM_COMPLETIONS_PERIOD_LEN (3*HZ)\n\nstatic void writeout_period(struct timer_list *t)\n{\n\tstruct wb_domain *dom = from_timer(dom, t, period_timer);\n\tint miss_periods = (jiffies - dom->period_time) /\n\t\t\t\t\t\t VM_COMPLETIONS_PERIOD_LEN;\n\n\tif (fprop_new_period(&dom->completions, miss_periods + 1)) {\n\t\tdom->period_time = wp_next_time(dom->period_time +\n\t\t\t\tmiss_periods * VM_COMPLETIONS_PERIOD_LEN);\n\t\tmod_timer(&dom->period_timer, dom->period_time);\n\t} else {\n\t\t/*\n\t\t * Aging has zeroed all fractions. Stop wasting CPU on period\n\t\t * updates.\n\t\t */\n\t\tdom->period_time = 0;\n\t}\n}"
  },
  {
    "function_name": "wb_writeout_inc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "613-620",
    "snippet": "void wb_writeout_inc(struct bdi_writeback *wb)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__wb_writeout_inc(wb);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wb_writeout_inc",
          "args": [
            "wb"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "__wb_writeout_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "599-611",
          "snippet": "static inline void __wb_writeout_inc(struct bdi_writeback *wb)\n{\n\tstruct wb_domain *cgdom;\n\n\tinc_wb_stat(wb, WB_WRITTEN);\n\twb_domain_writeout_inc(&global_wb_domain, &wb->completions,\n\t\t\t       wb->bdi->max_prop_frac);\n\n\tcgdom = mem_cgroup_wb_domain(wb);\n\tif (cgdom)\n\t\twb_domain_writeout_inc(cgdom, wb_memcg_completions(wb),\n\t\t\t\t       wb->bdi->max_prop_frac);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct wb_domain global_wb_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct wb_domain global_wb_domain;\n\nstatic inline void __wb_writeout_inc(struct bdi_writeback *wb)\n{\n\tstruct wb_domain *cgdom;\n\n\tinc_wb_stat(wb, WB_WRITTEN);\n\twb_domain_writeout_inc(&global_wb_domain, &wb->completions,\n\t\t\t       wb->bdi->max_prop_frac);\n\n\tcgdom = mem_cgroup_wb_domain(wb);\n\tif (cgdom)\n\t\twb_domain_writeout_inc(cgdom, wb_memcg_completions(wb),\n\t\t\t\t       wb->bdi->max_prop_frac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid wb_writeout_inc(struct bdi_writeback *wb)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__wb_writeout_inc(wb);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "__wb_writeout_inc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "599-611",
    "snippet": "static inline void __wb_writeout_inc(struct bdi_writeback *wb)\n{\n\tstruct wb_domain *cgdom;\n\n\tinc_wb_stat(wb, WB_WRITTEN);\n\twb_domain_writeout_inc(&global_wb_domain, &wb->completions,\n\t\t\t       wb->bdi->max_prop_frac);\n\n\tcgdom = mem_cgroup_wb_domain(wb);\n\tif (cgdom)\n\t\twb_domain_writeout_inc(cgdom, wb_memcg_completions(wb),\n\t\t\t\t       wb->bdi->max_prop_frac);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct wb_domain global_wb_domain;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wb_domain_writeout_inc",
          "args": [
            "cgdom",
            "wb_memcg_completions(wb)",
            "wb->bdi->max_prop_frac"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "wb_domain_writeout_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "576-593",
          "snippet": "static void wb_domain_writeout_inc(struct wb_domain *dom,\n\t\t\t\t   struct fprop_local_percpu *completions,\n\t\t\t\t   unsigned int max_prop_frac)\n{\n\t__fprop_inc_percpu_max(&dom->completions, completions,\n\t\t\t       max_prop_frac);\n\t/* First event after period switching was turned off? */\n\tif (unlikely(!dom->period_time)) {\n\t\t/*\n\t\t * We can race with other __bdi_writeout_inc calls here but\n\t\t * it does not cause any harm since the resulting time when\n\t\t * timer will fire and what is in writeout_period_time will be\n\t\t * roughly the same.\n\t\t */\n\t\tdom->period_time = wp_next_time(jiffies);\n\t\tmod_timer(&dom->period_timer, dom->period_time);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_domain_writeout_inc(struct wb_domain *dom,\n\t\t\t\t   struct fprop_local_percpu *completions,\n\t\t\t\t   unsigned int max_prop_frac)\n{\n\t__fprop_inc_percpu_max(&dom->completions, completions,\n\t\t\t       max_prop_frac);\n\t/* First event after period switching was turned off? */\n\tif (unlikely(!dom->period_time)) {\n\t\t/*\n\t\t * We can race with other __bdi_writeout_inc calls here but\n\t\t * it does not cause any harm since the resulting time when\n\t\t * timer will fire and what is in writeout_period_time will be\n\t\t * roughly the same.\n\t\t */\n\t\tdom->period_time = wp_next_time(jiffies);\n\t\tmod_timer(&dom->period_timer, dom->period_time);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_memcg_completions",
          "args": [
            "wb"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "wb_memcg_completions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "237-240",
          "snippet": "static struct fprop_local_percpu *wb_memcg_completions(struct bdi_writeback *wb)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct fprop_local_percpu *wb_memcg_completions(struct bdi_writeback *wb)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_wb_domain",
          "args": [
            "wb"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_wb_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "3843-3851",
          "snippet": "struct wb_domain *mem_cgroup_wb_domain(struct bdi_writeback *wb)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(wb->memcg_css);\n\n\tif (!memcg->css.parent)\n\t\treturn NULL;\n\n\treturn &memcg->cgwb_domain;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct wb_domain *mem_cgroup_wb_domain(struct bdi_writeback *wb)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(wb->memcg_css);\n\n\tif (!memcg->css.parent)\n\t\treturn NULL;\n\n\treturn &memcg->cgwb_domain;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_wb_stat",
          "args": [
            "wb",
            "WB_WRITTEN"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct wb_domain global_wb_domain;\n\nstatic inline void __wb_writeout_inc(struct bdi_writeback *wb)\n{\n\tstruct wb_domain *cgdom;\n\n\tinc_wb_stat(wb, WB_WRITTEN);\n\twb_domain_writeout_inc(&global_wb_domain, &wb->completions,\n\t\t\t       wb->bdi->max_prop_frac);\n\n\tcgdom = mem_cgroup_wb_domain(wb);\n\tif (cgdom)\n\t\twb_domain_writeout_inc(cgdom, wb_memcg_completions(wb),\n\t\t\t\t       wb->bdi->max_prop_frac);\n}"
  },
  {
    "function_name": "wb_domain_writeout_inc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "576-593",
    "snippet": "static void wb_domain_writeout_inc(struct wb_domain *dom,\n\t\t\t\t   struct fprop_local_percpu *completions,\n\t\t\t\t   unsigned int max_prop_frac)\n{\n\t__fprop_inc_percpu_max(&dom->completions, completions,\n\t\t\t       max_prop_frac);\n\t/* First event after period switching was turned off? */\n\tif (unlikely(!dom->period_time)) {\n\t\t/*\n\t\t * We can race with other __bdi_writeout_inc calls here but\n\t\t * it does not cause any harm since the resulting time when\n\t\t * timer will fire and what is in writeout_period_time will be\n\t\t * roughly the same.\n\t\t */\n\t\tdom->period_time = wp_next_time(jiffies);\n\t\tmod_timer(&dom->period_timer, dom->period_time);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&dom->period_timer",
            "dom->period_time"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wp_next_time",
          "args": [
            "jiffies"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "wp_next_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "567-574",
          "snippet": "static unsigned long wp_next_time(unsigned long cur_time)\n{\n\tcur_time += VM_COMPLETIONS_PERIOD_LEN;\n\t/* 0 has a special meaning... */\n\tif (!cur_time)\n\t\treturn 1;\n\treturn cur_time;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define VM_COMPLETIONS_PERIOD_LEN (3*HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define VM_COMPLETIONS_PERIOD_LEN (3*HZ)\n\nstatic unsigned long wp_next_time(unsigned long cur_time)\n{\n\tcur_time += VM_COMPLETIONS_PERIOD_LEN;\n\t/* 0 has a special meaning... */\n\tif (!cur_time)\n\t\treturn 1;\n\treturn cur_time;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!dom->period_time"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fprop_inc_percpu_max",
          "args": [
            "&dom->completions",
            "completions",
            "max_prop_frac"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_domain_writeout_inc(struct wb_domain *dom,\n\t\t\t\t   struct fprop_local_percpu *completions,\n\t\t\t\t   unsigned int max_prop_frac)\n{\n\t__fprop_inc_percpu_max(&dom->completions, completions,\n\t\t\t       max_prop_frac);\n\t/* First event after period switching was turned off? */\n\tif (unlikely(!dom->period_time)) {\n\t\t/*\n\t\t * We can race with other __bdi_writeout_inc calls here but\n\t\t * it does not cause any harm since the resulting time when\n\t\t * timer will fire and what is in writeout_period_time will be\n\t\t * roughly the same.\n\t\t */\n\t\tdom->period_time = wp_next_time(jiffies);\n\t\tmod_timer(&dom->period_timer, dom->period_time);\n\t}\n}"
  },
  {
    "function_name": "wp_next_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "567-574",
    "snippet": "static unsigned long wp_next_time(unsigned long cur_time)\n{\n\tcur_time += VM_COMPLETIONS_PERIOD_LEN;\n\t/* 0 has a special meaning... */\n\tif (!cur_time)\n\t\treturn 1;\n\treturn cur_time;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define VM_COMPLETIONS_PERIOD_LEN (3*HZ)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define VM_COMPLETIONS_PERIOD_LEN (3*HZ)\n\nstatic unsigned long wp_next_time(unsigned long cur_time)\n{\n\tcur_time += VM_COMPLETIONS_PERIOD_LEN;\n\t/* 0 has a special meaning... */\n\tif (!cur_time)\n\t\treturn 1;\n\treturn cur_time;\n}"
  },
  {
    "function_name": "dirty_bytes_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "552-565",
    "snippet": "int dirty_bytes_handler(struct ctl_table *table, int write,\n\t\tvoid __user *buffer, size_t *lenp,\n\t\tloff_t *ppos)\n{\n\tunsigned long old_bytes = vm_dirty_bytes;\n\tint ret;\n\n\tret = proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\n\tif (ret == 0 && write && vm_dirty_bytes != old_bytes) {\n\t\twriteback_set_ratelimit();\n\t\tvm_dirty_ratio = 0;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int vm_dirty_ratio = 20;",
      "unsigned long vm_dirty_bytes;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeback_set_ratelimit",
          "args": [],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "writeback_set_ratelimit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2039-2050",
          "snippet": "void writeback_set_ratelimit(void)\n{\n\tstruct wb_domain *dom = &global_wb_domain;\n\tunsigned long background_thresh;\n\tunsigned long dirty_thresh;\n\n\tglobal_dirty_limits(&background_thresh, &dirty_thresh);\n\tdom->dirty_limit = dirty_thresh;\n\tratelimit_pages = dirty_thresh / (num_online_cpus() * 32);\n\tif (ratelimit_pages < 16)\n\t\tratelimit_pages = 16;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long ratelimit_pages = 32;",
            "struct wb_domain global_wb_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long ratelimit_pages = 32;\nstruct wb_domain global_wb_domain;\n\nvoid writeback_set_ratelimit(void)\n{\n\tstruct wb_domain *dom = &global_wb_domain;\n\tunsigned long background_thresh;\n\tunsigned long dirty_thresh;\n\n\tglobal_dirty_limits(&background_thresh, &dirty_thresh);\n\tdom->dirty_limit = dirty_thresh;\n\tratelimit_pages = dirty_thresh / (num_online_cpus() * 32);\n\tif (ratelimit_pages < 16)\n\t\tratelimit_pages = 16;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_doulongvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint vm_dirty_ratio = 20;\nunsigned long vm_dirty_bytes;\n\nint dirty_bytes_handler(struct ctl_table *table, int write,\n\t\tvoid __user *buffer, size_t *lenp,\n\t\tloff_t *ppos)\n{\n\tunsigned long old_bytes = vm_dirty_bytes;\n\tint ret;\n\n\tret = proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\n\tif (ret == 0 && write && vm_dirty_bytes != old_bytes) {\n\t\twriteback_set_ratelimit();\n\t\tvm_dirty_ratio = 0;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "dirty_ratio_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "537-550",
    "snippet": "int dirty_ratio_handler(struct ctl_table *table, int write,\n\t\tvoid __user *buffer, size_t *lenp,\n\t\tloff_t *ppos)\n{\n\tint old_ratio = vm_dirty_ratio;\n\tint ret;\n\n\tret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\tif (ret == 0 && write && vm_dirty_ratio != old_ratio) {\n\t\twriteback_set_ratelimit();\n\t\tvm_dirty_bytes = 0;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int vm_dirty_ratio = 20;",
      "unsigned long vm_dirty_bytes;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeback_set_ratelimit",
          "args": [],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "writeback_set_ratelimit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2039-2050",
          "snippet": "void writeback_set_ratelimit(void)\n{\n\tstruct wb_domain *dom = &global_wb_domain;\n\tunsigned long background_thresh;\n\tunsigned long dirty_thresh;\n\n\tglobal_dirty_limits(&background_thresh, &dirty_thresh);\n\tdom->dirty_limit = dirty_thresh;\n\tratelimit_pages = dirty_thresh / (num_online_cpus() * 32);\n\tif (ratelimit_pages < 16)\n\t\tratelimit_pages = 16;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long ratelimit_pages = 32;",
            "struct wb_domain global_wb_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long ratelimit_pages = 32;\nstruct wb_domain global_wb_domain;\n\nvoid writeback_set_ratelimit(void)\n{\n\tstruct wb_domain *dom = &global_wb_domain;\n\tunsigned long background_thresh;\n\tunsigned long dirty_thresh;\n\n\tglobal_dirty_limits(&background_thresh, &dirty_thresh);\n\tdom->dirty_limit = dirty_thresh;\n\tratelimit_pages = dirty_thresh / (num_online_cpus() * 32);\n\tif (ratelimit_pages < 16)\n\t\tratelimit_pages = 16;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint vm_dirty_ratio = 20;\nunsigned long vm_dirty_bytes;\n\nint dirty_ratio_handler(struct ctl_table *table, int write,\n\t\tvoid __user *buffer, size_t *lenp,\n\t\tloff_t *ppos)\n{\n\tint old_ratio = vm_dirty_ratio;\n\tint ret;\n\n\tret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\tif (ret == 0 && write && vm_dirty_ratio != old_ratio) {\n\t\twriteback_set_ratelimit();\n\t\tvm_dirty_bytes = 0;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "dirty_background_bytes_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "525-535",
    "snippet": "int dirty_background_bytes_handler(struct ctl_table *table, int write,\n\t\tvoid __user *buffer, size_t *lenp,\n\t\tloff_t *ppos)\n{\n\tint ret;\n\n\tret = proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\n\tif (ret == 0 && write)\n\t\tdirty_background_ratio = 0;\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int dirty_background_ratio = 10;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_doulongvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint dirty_background_ratio = 10;\n\nint dirty_background_bytes_handler(struct ctl_table *table, int write,\n\t\tvoid __user *buffer, size_t *lenp,\n\t\tloff_t *ppos)\n{\n\tint ret;\n\n\tret = proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\n\tif (ret == 0 && write)\n\t\tdirty_background_ratio = 0;\n\treturn ret;\n}"
  },
  {
    "function_name": "dirty_background_ratio_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "513-523",
    "snippet": "int dirty_background_ratio_handler(struct ctl_table *table, int write,\n\t\tvoid __user *buffer, size_t *lenp,\n\t\tloff_t *ppos)\n{\n\tint ret;\n\n\tret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\tif (ret == 0 && write)\n\t\tdirty_background_bytes = 0;\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long dirty_background_bytes;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nunsigned long dirty_background_bytes;\n\nint dirty_background_ratio_handler(struct ctl_table *table, int write,\n\t\tvoid __user *buffer, size_t *lenp,\n\t\tloff_t *ppos)\n{\n\tint ret;\n\n\tret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\tif (ret == 0 && write)\n\t\tdirty_background_bytes = 0;\n\treturn ret;\n}"
  },
  {
    "function_name": "node_dirty_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "501-511",
    "snippet": "bool node_dirty_ok(struct pglist_data *pgdat)\n{\n\tunsigned long limit = node_dirty_limit(pgdat);\n\tunsigned long nr_pages = 0;\n\n\tnr_pages += node_page_state(pgdat, NR_FILE_DIRTY);\n\tnr_pages += node_page_state(pgdat, NR_UNSTABLE_NFS);\n\tnr_pages += node_page_state(pgdat, NR_WRITEBACK);\n\n\treturn nr_pages <= limit;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_page_state",
          "args": [
            "pgdat",
            "NR_WRITEBACK"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "991-1000",
          "snippet": "unsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nunsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_dirty_limit",
          "args": [
            "pgdat"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "node_dirty_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "476-492",
          "snippet": "static unsigned long node_dirty_limit(struct pglist_data *pgdat)\n{\n\tunsigned long node_memory = node_dirtyable_memory(pgdat);\n\tstruct task_struct *tsk = current;\n\tunsigned long dirty;\n\n\tif (vm_dirty_bytes)\n\t\tdirty = DIV_ROUND_UP(vm_dirty_bytes, PAGE_SIZE) *\n\t\t\tnode_memory / global_dirtyable_memory();\n\telse\n\t\tdirty = vm_dirty_ratio * node_memory / 100;\n\n\tif (tsk->flags & PF_LESS_THROTTLE || rt_task(tsk))\n\t\tdirty += dirty / 4;\n\n\treturn dirty;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int vm_dirty_ratio = 20;",
            "unsigned long vm_dirty_bytes;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint vm_dirty_ratio = 20;\nunsigned long vm_dirty_bytes;\n\nstatic unsigned long node_dirty_limit(struct pglist_data *pgdat)\n{\n\tunsigned long node_memory = node_dirtyable_memory(pgdat);\n\tstruct task_struct *tsk = current;\n\tunsigned long dirty;\n\n\tif (vm_dirty_bytes)\n\t\tdirty = DIV_ROUND_UP(vm_dirty_bytes, PAGE_SIZE) *\n\t\t\tnode_memory / global_dirtyable_memory();\n\telse\n\t\tdirty = vm_dirty_ratio * node_memory / 100;\n\n\tif (tsk->flags & PF_LESS_THROTTLE || rt_task(tsk))\n\t\tdirty += dirty / 4;\n\n\treturn dirty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nbool node_dirty_ok(struct pglist_data *pgdat)\n{\n\tunsigned long limit = node_dirty_limit(pgdat);\n\tunsigned long nr_pages = 0;\n\n\tnr_pages += node_page_state(pgdat, NR_FILE_DIRTY);\n\tnr_pages += node_page_state(pgdat, NR_UNSTABLE_NFS);\n\tnr_pages += node_page_state(pgdat, NR_WRITEBACK);\n\n\treturn nr_pages <= limit;\n}"
  },
  {
    "function_name": "node_dirty_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "476-492",
    "snippet": "static unsigned long node_dirty_limit(struct pglist_data *pgdat)\n{\n\tunsigned long node_memory = node_dirtyable_memory(pgdat);\n\tstruct task_struct *tsk = current;\n\tunsigned long dirty;\n\n\tif (vm_dirty_bytes)\n\t\tdirty = DIV_ROUND_UP(vm_dirty_bytes, PAGE_SIZE) *\n\t\t\tnode_memory / global_dirtyable_memory();\n\telse\n\t\tdirty = vm_dirty_ratio * node_memory / 100;\n\n\tif (tsk->flags & PF_LESS_THROTTLE || rt_task(tsk))\n\t\tdirty += dirty / 4;\n\n\treturn dirty;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int vm_dirty_ratio = 20;",
      "unsigned long vm_dirty_bytes;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rt_task",
          "args": [
            "tsk"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_dirtyable_memory",
          "args": [],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "global_dirtyable_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "361-380",
          "snippet": "static unsigned long global_dirtyable_memory(void)\n{\n\tunsigned long x;\n\n\tx = global_zone_page_state(NR_FREE_PAGES);\n\t/*\n\t * Pages reserved for the kernel should not be considered\n\t * dirtyable, to prevent a situation where reclaim has to\n\t * clean pages in order to balance the zones.\n\t */\n\tx -= min(x, totalreserve_pages);\n\n\tx += global_node_page_state(NR_INACTIVE_FILE);\n\tx += global_node_page_state(NR_ACTIVE_FILE);\n\n\tif (!vm_highmem_is_dirtyable)\n\t\tx -= highmem_dirtyable_memory(x);\n\n\treturn x + 1;\t/* Ensure that we never return 0 */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int vm_highmem_is_dirtyable;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint vm_highmem_is_dirtyable;\n\nstatic unsigned long global_dirtyable_memory(void)\n{\n\tunsigned long x;\n\n\tx = global_zone_page_state(NR_FREE_PAGES);\n\t/*\n\t * Pages reserved for the kernel should not be considered\n\t * dirtyable, to prevent a situation where reclaim has to\n\t * clean pages in order to balance the zones.\n\t */\n\tx -= min(x, totalreserve_pages);\n\n\tx += global_node_page_state(NR_INACTIVE_FILE);\n\tx += global_node_page_state(NR_ACTIVE_FILE);\n\n\tif (!vm_highmem_is_dirtyable)\n\t\tx -= highmem_dirtyable_memory(x);\n\n\treturn x + 1;\t/* Ensure that we never return 0 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "vm_dirty_bytes",
            "PAGE_SIZE"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_dirtyable_memory",
          "args": [
            "pgdat"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "node_dirtyable_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "276-301",
          "snippet": "static unsigned long node_dirtyable_memory(struct pglist_data *pgdat)\n{\n\tunsigned long nr_pages = 0;\n\tint z;\n\n\tfor (z = 0; z < MAX_NR_ZONES; z++) {\n\t\tstruct zone *zone = pgdat->node_zones + z;\n\n\t\tif (!populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tnr_pages += zone_page_state(zone, NR_FREE_PAGES);\n\t}\n\n\t/*\n\t * Pages reserved for the kernel should not be considered\n\t * dirtyable, to prevent a situation where reclaim has to\n\t * clean pages in order to balance the zones.\n\t */\n\tnr_pages -= min(nr_pages, pgdat->totalreserve_pages);\n\n\tnr_pages += node_page_state(pgdat, NR_INACTIVE_FILE);\n\tnr_pages += node_page_state(pgdat, NR_ACTIVE_FILE);\n\n\treturn nr_pages;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned long node_dirtyable_memory(struct pglist_data *pgdat)\n{\n\tunsigned long nr_pages = 0;\n\tint z;\n\n\tfor (z = 0; z < MAX_NR_ZONES; z++) {\n\t\tstruct zone *zone = pgdat->node_zones + z;\n\n\t\tif (!populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tnr_pages += zone_page_state(zone, NR_FREE_PAGES);\n\t}\n\n\t/*\n\t * Pages reserved for the kernel should not be considered\n\t * dirtyable, to prevent a situation where reclaim has to\n\t * clean pages in order to balance the zones.\n\t */\n\tnr_pages -= min(nr_pages, pgdat->totalreserve_pages);\n\n\tnr_pages += node_page_state(pgdat, NR_INACTIVE_FILE);\n\tnr_pages += node_page_state(pgdat, NR_ACTIVE_FILE);\n\n\treturn nr_pages;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint vm_dirty_ratio = 20;\nunsigned long vm_dirty_bytes;\n\nstatic unsigned long node_dirty_limit(struct pglist_data *pgdat)\n{\n\tunsigned long node_memory = node_dirtyable_memory(pgdat);\n\tstruct task_struct *tsk = current;\n\tunsigned long dirty;\n\n\tif (vm_dirty_bytes)\n\t\tdirty = DIV_ROUND_UP(vm_dirty_bytes, PAGE_SIZE) *\n\t\t\tnode_memory / global_dirtyable_memory();\n\telse\n\t\tdirty = vm_dirty_ratio * node_memory / 100;\n\n\tif (tsk->flags & PF_LESS_THROTTLE || rt_task(tsk))\n\t\tdirty += dirty / 4;\n\n\treturn dirty;\n}"
  },
  {
    "function_name": "global_dirty_limits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "458-467",
    "snippet": "void global_dirty_limits(unsigned long *pbackground, unsigned long *pdirty)\n{\n\tstruct dirty_throttle_control gdtc = { GDTC_INIT_NO_WB };\n\n\tgdtc.avail = global_dirtyable_memory();\n\tdomain_dirty_limits(&gdtc);\n\n\t*pbackground = gdtc.bg_thresh;\n\t*pdirty = gdtc.thresh;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define GDTC_INIT_NO_WB",
      "#define GDTC_INIT_NO_WB\t\t.dom = &global_wb_domain"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "domain_dirty_limits",
          "args": [
            "&gdtc"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "domain_dirty_limits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "392-448",
          "snippet": "static void domain_dirty_limits(struct dirty_throttle_control *dtc)\n{\n\tconst unsigned long available_memory = dtc->avail;\n\tstruct dirty_throttle_control *gdtc = mdtc_gdtc(dtc);\n\tunsigned long bytes = vm_dirty_bytes;\n\tunsigned long bg_bytes = dirty_background_bytes;\n\t/* convert ratios to per-PAGE_SIZE for higher precision */\n\tunsigned long ratio = (vm_dirty_ratio * PAGE_SIZE) / 100;\n\tunsigned long bg_ratio = (dirty_background_ratio * PAGE_SIZE) / 100;\n\tunsigned long thresh;\n\tunsigned long bg_thresh;\n\tstruct task_struct *tsk;\n\n\t/* gdtc is !NULL iff @dtc is for memcg domain */\n\tif (gdtc) {\n\t\tunsigned long global_avail = gdtc->avail;\n\n\t\t/*\n\t\t * The byte settings can't be applied directly to memcg\n\t\t * domains.  Convert them to ratios by scaling against\n\t\t * globally available memory.  As the ratios are in\n\t\t * per-PAGE_SIZE, they can be obtained by dividing bytes by\n\t\t * number of pages.\n\t\t */\n\t\tif (bytes)\n\t\t\tratio = min(DIV_ROUND_UP(bytes, global_avail),\n\t\t\t\t    PAGE_SIZE);\n\t\tif (bg_bytes)\n\t\t\tbg_ratio = min(DIV_ROUND_UP(bg_bytes, global_avail),\n\t\t\t\t       PAGE_SIZE);\n\t\tbytes = bg_bytes = 0;\n\t}\n\n\tif (bytes)\n\t\tthresh = DIV_ROUND_UP(bytes, PAGE_SIZE);\n\telse\n\t\tthresh = (ratio * available_memory) / PAGE_SIZE;\n\n\tif (bg_bytes)\n\t\tbg_thresh = DIV_ROUND_UP(bg_bytes, PAGE_SIZE);\n\telse\n\t\tbg_thresh = (bg_ratio * available_memory) / PAGE_SIZE;\n\n\tif (bg_thresh >= thresh)\n\t\tbg_thresh = thresh / 2;\n\ttsk = current;\n\tif (tsk->flags & PF_LESS_THROTTLE || rt_task(tsk)) {\n\t\tbg_thresh += bg_thresh / 4 + global_wb_domain.dirty_limit / 32;\n\t\tthresh += thresh / 4 + global_wb_domain.dirty_limit / 32;\n\t}\n\tdtc->thresh = thresh;\n\tdtc->bg_thresh = bg_thresh;\n\n\t/* we should eventually report the domain in the TP */\n\tif (!gdtc)\n\t\ttrace_global_dirty_state(bg_thresh, thresh);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int dirty_background_ratio = 10;",
            "unsigned long dirty_background_bytes;",
            "int vm_dirty_ratio = 20;",
            "unsigned long vm_dirty_bytes;",
            "struct wb_domain global_wb_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint dirty_background_ratio = 10;\nunsigned long dirty_background_bytes;\nint vm_dirty_ratio = 20;\nunsigned long vm_dirty_bytes;\nstruct wb_domain global_wb_domain;\n\nstatic void domain_dirty_limits(struct dirty_throttle_control *dtc)\n{\n\tconst unsigned long available_memory = dtc->avail;\n\tstruct dirty_throttle_control *gdtc = mdtc_gdtc(dtc);\n\tunsigned long bytes = vm_dirty_bytes;\n\tunsigned long bg_bytes = dirty_background_bytes;\n\t/* convert ratios to per-PAGE_SIZE for higher precision */\n\tunsigned long ratio = (vm_dirty_ratio * PAGE_SIZE) / 100;\n\tunsigned long bg_ratio = (dirty_background_ratio * PAGE_SIZE) / 100;\n\tunsigned long thresh;\n\tunsigned long bg_thresh;\n\tstruct task_struct *tsk;\n\n\t/* gdtc is !NULL iff @dtc is for memcg domain */\n\tif (gdtc) {\n\t\tunsigned long global_avail = gdtc->avail;\n\n\t\t/*\n\t\t * The byte settings can't be applied directly to memcg\n\t\t * domains.  Convert them to ratios by scaling against\n\t\t * globally available memory.  As the ratios are in\n\t\t * per-PAGE_SIZE, they can be obtained by dividing bytes by\n\t\t * number of pages.\n\t\t */\n\t\tif (bytes)\n\t\t\tratio = min(DIV_ROUND_UP(bytes, global_avail),\n\t\t\t\t    PAGE_SIZE);\n\t\tif (bg_bytes)\n\t\t\tbg_ratio = min(DIV_ROUND_UP(bg_bytes, global_avail),\n\t\t\t\t       PAGE_SIZE);\n\t\tbytes = bg_bytes = 0;\n\t}\n\n\tif (bytes)\n\t\tthresh = DIV_ROUND_UP(bytes, PAGE_SIZE);\n\telse\n\t\tthresh = (ratio * available_memory) / PAGE_SIZE;\n\n\tif (bg_bytes)\n\t\tbg_thresh = DIV_ROUND_UP(bg_bytes, PAGE_SIZE);\n\telse\n\t\tbg_thresh = (bg_ratio * available_memory) / PAGE_SIZE;\n\n\tif (bg_thresh >= thresh)\n\t\tbg_thresh = thresh / 2;\n\ttsk = current;\n\tif (tsk->flags & PF_LESS_THROTTLE || rt_task(tsk)) {\n\t\tbg_thresh += bg_thresh / 4 + global_wb_domain.dirty_limit / 32;\n\t\tthresh += thresh / 4 + global_wb_domain.dirty_limit / 32;\n\t}\n\tdtc->thresh = thresh;\n\tdtc->bg_thresh = bg_thresh;\n\n\t/* we should eventually report the domain in the TP */\n\tif (!gdtc)\n\t\ttrace_global_dirty_state(bg_thresh, thresh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_dirtyable_memory",
          "args": [],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "global_dirtyable_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "361-380",
          "snippet": "static unsigned long global_dirtyable_memory(void)\n{\n\tunsigned long x;\n\n\tx = global_zone_page_state(NR_FREE_PAGES);\n\t/*\n\t * Pages reserved for the kernel should not be considered\n\t * dirtyable, to prevent a situation where reclaim has to\n\t * clean pages in order to balance the zones.\n\t */\n\tx -= min(x, totalreserve_pages);\n\n\tx += global_node_page_state(NR_INACTIVE_FILE);\n\tx += global_node_page_state(NR_ACTIVE_FILE);\n\n\tif (!vm_highmem_is_dirtyable)\n\t\tx -= highmem_dirtyable_memory(x);\n\n\treturn x + 1;\t/* Ensure that we never return 0 */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int vm_highmem_is_dirtyable;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint vm_highmem_is_dirtyable;\n\nstatic unsigned long global_dirtyable_memory(void)\n{\n\tunsigned long x;\n\n\tx = global_zone_page_state(NR_FREE_PAGES);\n\t/*\n\t * Pages reserved for the kernel should not be considered\n\t * dirtyable, to prevent a situation where reclaim has to\n\t * clean pages in order to balance the zones.\n\t */\n\tx -= min(x, totalreserve_pages);\n\n\tx += global_node_page_state(NR_INACTIVE_FILE);\n\tx += global_node_page_state(NR_ACTIVE_FILE);\n\n\tif (!vm_highmem_is_dirtyable)\n\t\tx -= highmem_dirtyable_memory(x);\n\n\treturn x + 1;\t/* Ensure that we never return 0 */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define GDTC_INIT_NO_WB\n#define GDTC_INIT_NO_WB\t\t.dom = &global_wb_domain\n\nvoid global_dirty_limits(unsigned long *pbackground, unsigned long *pdirty)\n{\n\tstruct dirty_throttle_control gdtc = { GDTC_INIT_NO_WB };\n\n\tgdtc.avail = global_dirtyable_memory();\n\tdomain_dirty_limits(&gdtc);\n\n\t*pbackground = gdtc.bg_thresh;\n\t*pdirty = gdtc.thresh;\n}"
  },
  {
    "function_name": "domain_dirty_limits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "392-448",
    "snippet": "static void domain_dirty_limits(struct dirty_throttle_control *dtc)\n{\n\tconst unsigned long available_memory = dtc->avail;\n\tstruct dirty_throttle_control *gdtc = mdtc_gdtc(dtc);\n\tunsigned long bytes = vm_dirty_bytes;\n\tunsigned long bg_bytes = dirty_background_bytes;\n\t/* convert ratios to per-PAGE_SIZE for higher precision */\n\tunsigned long ratio = (vm_dirty_ratio * PAGE_SIZE) / 100;\n\tunsigned long bg_ratio = (dirty_background_ratio * PAGE_SIZE) / 100;\n\tunsigned long thresh;\n\tunsigned long bg_thresh;\n\tstruct task_struct *tsk;\n\n\t/* gdtc is !NULL iff @dtc is for memcg domain */\n\tif (gdtc) {\n\t\tunsigned long global_avail = gdtc->avail;\n\n\t\t/*\n\t\t * The byte settings can't be applied directly to memcg\n\t\t * domains.  Convert them to ratios by scaling against\n\t\t * globally available memory.  As the ratios are in\n\t\t * per-PAGE_SIZE, they can be obtained by dividing bytes by\n\t\t * number of pages.\n\t\t */\n\t\tif (bytes)\n\t\t\tratio = min(DIV_ROUND_UP(bytes, global_avail),\n\t\t\t\t    PAGE_SIZE);\n\t\tif (bg_bytes)\n\t\t\tbg_ratio = min(DIV_ROUND_UP(bg_bytes, global_avail),\n\t\t\t\t       PAGE_SIZE);\n\t\tbytes = bg_bytes = 0;\n\t}\n\n\tif (bytes)\n\t\tthresh = DIV_ROUND_UP(bytes, PAGE_SIZE);\n\telse\n\t\tthresh = (ratio * available_memory) / PAGE_SIZE;\n\n\tif (bg_bytes)\n\t\tbg_thresh = DIV_ROUND_UP(bg_bytes, PAGE_SIZE);\n\telse\n\t\tbg_thresh = (bg_ratio * available_memory) / PAGE_SIZE;\n\n\tif (bg_thresh >= thresh)\n\t\tbg_thresh = thresh / 2;\n\ttsk = current;\n\tif (tsk->flags & PF_LESS_THROTTLE || rt_task(tsk)) {\n\t\tbg_thresh += bg_thresh / 4 + global_wb_domain.dirty_limit / 32;\n\t\tthresh += thresh / 4 + global_wb_domain.dirty_limit / 32;\n\t}\n\tdtc->thresh = thresh;\n\tdtc->bg_thresh = bg_thresh;\n\n\t/* we should eventually report the domain in the TP */\n\tif (!gdtc)\n\t\ttrace_global_dirty_state(bg_thresh, thresh);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int dirty_background_ratio = 10;",
      "unsigned long dirty_background_bytes;",
      "int vm_dirty_ratio = 20;",
      "unsigned long vm_dirty_bytes;",
      "struct wb_domain global_wb_domain;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_global_dirty_state",
          "args": [
            "bg_thresh",
            "thresh"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rt_task",
          "args": [
            "tsk"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "bg_bytes",
            "PAGE_SIZE"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "bytes",
            "PAGE_SIZE"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "DIV_ROUND_UP(bg_bytes, global_avail)",
            "PAGE_SIZE"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_set_min_ratio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "674-693",
          "snippet": "int bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)\n{\n\tint ret = 0;\n\n\tspin_lock_bh(&bdi_lock);\n\tif (min_ratio > bdi->max_ratio) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tmin_ratio -= bdi->min_ratio;\n\t\tif (bdi_min_ratio + min_ratio < 100) {\n\t\t\tbdi_min_ratio += min_ratio;\n\t\t\tbdi->min_ratio += min_ratio;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tspin_unlock_bh(&bdi_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int bdi_min_ratio;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned int bdi_min_ratio;\n\nint bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)\n{\n\tint ret = 0;\n\n\tspin_lock_bh(&bdi_lock);\n\tif (min_ratio > bdi->max_ratio) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tmin_ratio -= bdi->min_ratio;\n\t\tif (bdi_min_ratio + min_ratio < 100) {\n\t\t\tbdi_min_ratio += min_ratio;\n\t\t\tbdi->min_ratio += min_ratio;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tspin_unlock_bh(&bdi_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "bg_bytes",
            "global_avail"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "bytes",
            "global_avail"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdtc_gdtc",
          "args": [
            "dtc"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "mdtc_gdtc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "232-235",
          "snippet": "static struct dirty_throttle_control *mdtc_gdtc(struct dirty_throttle_control *mdtc)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct dirty_throttle_control *mdtc_gdtc(struct dirty_throttle_control *mdtc)\n{\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint dirty_background_ratio = 10;\nunsigned long dirty_background_bytes;\nint vm_dirty_ratio = 20;\nunsigned long vm_dirty_bytes;\nstruct wb_domain global_wb_domain;\n\nstatic void domain_dirty_limits(struct dirty_throttle_control *dtc)\n{\n\tconst unsigned long available_memory = dtc->avail;\n\tstruct dirty_throttle_control *gdtc = mdtc_gdtc(dtc);\n\tunsigned long bytes = vm_dirty_bytes;\n\tunsigned long bg_bytes = dirty_background_bytes;\n\t/* convert ratios to per-PAGE_SIZE for higher precision */\n\tunsigned long ratio = (vm_dirty_ratio * PAGE_SIZE) / 100;\n\tunsigned long bg_ratio = (dirty_background_ratio * PAGE_SIZE) / 100;\n\tunsigned long thresh;\n\tunsigned long bg_thresh;\n\tstruct task_struct *tsk;\n\n\t/* gdtc is !NULL iff @dtc is for memcg domain */\n\tif (gdtc) {\n\t\tunsigned long global_avail = gdtc->avail;\n\n\t\t/*\n\t\t * The byte settings can't be applied directly to memcg\n\t\t * domains.  Convert them to ratios by scaling against\n\t\t * globally available memory.  As the ratios are in\n\t\t * per-PAGE_SIZE, they can be obtained by dividing bytes by\n\t\t * number of pages.\n\t\t */\n\t\tif (bytes)\n\t\t\tratio = min(DIV_ROUND_UP(bytes, global_avail),\n\t\t\t\t    PAGE_SIZE);\n\t\tif (bg_bytes)\n\t\t\tbg_ratio = min(DIV_ROUND_UP(bg_bytes, global_avail),\n\t\t\t\t       PAGE_SIZE);\n\t\tbytes = bg_bytes = 0;\n\t}\n\n\tif (bytes)\n\t\tthresh = DIV_ROUND_UP(bytes, PAGE_SIZE);\n\telse\n\t\tthresh = (ratio * available_memory) / PAGE_SIZE;\n\n\tif (bg_bytes)\n\t\tbg_thresh = DIV_ROUND_UP(bg_bytes, PAGE_SIZE);\n\telse\n\t\tbg_thresh = (bg_ratio * available_memory) / PAGE_SIZE;\n\n\tif (bg_thresh >= thresh)\n\t\tbg_thresh = thresh / 2;\n\ttsk = current;\n\tif (tsk->flags & PF_LESS_THROTTLE || rt_task(tsk)) {\n\t\tbg_thresh += bg_thresh / 4 + global_wb_domain.dirty_limit / 32;\n\t\tthresh += thresh / 4 + global_wb_domain.dirty_limit / 32;\n\t}\n\tdtc->thresh = thresh;\n\tdtc->bg_thresh = bg_thresh;\n\n\t/* we should eventually report the domain in the TP */\n\tif (!gdtc)\n\t\ttrace_global_dirty_state(bg_thresh, thresh);\n}"
  },
  {
    "function_name": "global_dirtyable_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "361-380",
    "snippet": "static unsigned long global_dirtyable_memory(void)\n{\n\tunsigned long x;\n\n\tx = global_zone_page_state(NR_FREE_PAGES);\n\t/*\n\t * Pages reserved for the kernel should not be considered\n\t * dirtyable, to prevent a situation where reclaim has to\n\t * clean pages in order to balance the zones.\n\t */\n\tx -= min(x, totalreserve_pages);\n\n\tx += global_node_page_state(NR_INACTIVE_FILE);\n\tx += global_node_page_state(NR_ACTIVE_FILE);\n\n\tif (!vm_highmem_is_dirtyable)\n\t\tx -= highmem_dirtyable_memory(x);\n\n\treturn x + 1;\t/* Ensure that we never return 0 */\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int vm_highmem_is_dirtyable;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "highmem_dirtyable_memory",
          "args": [
            "x"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "highmem_dirtyable_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "303-353",
          "snippet": "static unsigned long highmem_dirtyable_memory(unsigned long total)\n{\n#ifdef CONFIG_HIGHMEM\n\tint node;\n\tunsigned long x = 0;\n\tint i;\n\n\tfor_each_node_state(node, N_HIGH_MEMORY) {\n\t\tfor (i = ZONE_NORMAL + 1; i < MAX_NR_ZONES; i++) {\n\t\t\tstruct zone *z;\n\t\t\tunsigned long nr_pages;\n\n\t\t\tif (!is_highmem_idx(i))\n\t\t\t\tcontinue;\n\n\t\t\tz = &NODE_DATA(node)->node_zones[i];\n\t\t\tif (!populated_zone(z))\n\t\t\t\tcontinue;\n\n\t\t\tnr_pages = zone_page_state(z, NR_FREE_PAGES);\n\t\t\t/* watch for underflows */\n\t\t\tnr_pages -= min(nr_pages, high_wmark_pages(z));\n\t\t\tnr_pages += zone_page_state(z, NR_ZONE_INACTIVE_FILE);\n\t\t\tnr_pages += zone_page_state(z, NR_ZONE_ACTIVE_FILE);\n\t\t\tx += nr_pages;\n\t\t}\n\t}\n\n\t/*\n\t * Unreclaimable memory (kernel memory or anonymous memory\n\t * without swap) can bring down the dirtyable pages below\n\t * the zone's dirty balance reserve and the above calculation\n\t * will underflow.  However we still want to add in nodes\n\t * which are below threshold (negative values) to get a more\n\t * accurate calculation but make sure that the total never\n\t * underflows.\n\t */\n\tif ((long)x < 0)\n\t\tx = 0;\n\n\t/*\n\t * Make sure that the number of highmem pages is never larger\n\t * than the number of the total dirtyable memory. This can only\n\t * occur in very strange VM situations but we want to make sure\n\t * that this does not occur.\n\t */\n\treturn min(x, total);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned long highmem_dirtyable_memory(unsigned long total)\n{\n#ifdef CONFIG_HIGHMEM\n\tint node;\n\tunsigned long x = 0;\n\tint i;\n\n\tfor_each_node_state(node, N_HIGH_MEMORY) {\n\t\tfor (i = ZONE_NORMAL + 1; i < MAX_NR_ZONES; i++) {\n\t\t\tstruct zone *z;\n\t\t\tunsigned long nr_pages;\n\n\t\t\tif (!is_highmem_idx(i))\n\t\t\t\tcontinue;\n\n\t\t\tz = &NODE_DATA(node)->node_zones[i];\n\t\t\tif (!populated_zone(z))\n\t\t\t\tcontinue;\n\n\t\t\tnr_pages = zone_page_state(z, NR_FREE_PAGES);\n\t\t\t/* watch for underflows */\n\t\t\tnr_pages -= min(nr_pages, high_wmark_pages(z));\n\t\t\tnr_pages += zone_page_state(z, NR_ZONE_INACTIVE_FILE);\n\t\t\tnr_pages += zone_page_state(z, NR_ZONE_ACTIVE_FILE);\n\t\t\tx += nr_pages;\n\t\t}\n\t}\n\n\t/*\n\t * Unreclaimable memory (kernel memory or anonymous memory\n\t * without swap) can bring down the dirtyable pages below\n\t * the zone's dirty balance reserve and the above calculation\n\t * will underflow.  However we still want to add in nodes\n\t * which are below threshold (negative values) to get a more\n\t * accurate calculation but make sure that the total never\n\t * underflows.\n\t */\n\tif ((long)x < 0)\n\t\tx = 0;\n\n\t/*\n\t * Make sure that the number of highmem pages is never larger\n\t * than the number of the total dirtyable memory. This can only\n\t * occur in very strange VM situations but we want to make sure\n\t * that this does not occur.\n\t */\n\treturn min(x, total);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_ACTIVE_FILE"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_INACTIVE_FILE"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "x",
            "totalreserve_pages"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_set_min_ratio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "674-693",
          "snippet": "int bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)\n{\n\tint ret = 0;\n\n\tspin_lock_bh(&bdi_lock);\n\tif (min_ratio > bdi->max_ratio) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tmin_ratio -= bdi->min_ratio;\n\t\tif (bdi_min_ratio + min_ratio < 100) {\n\t\t\tbdi_min_ratio += min_ratio;\n\t\t\tbdi->min_ratio += min_ratio;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tspin_unlock_bh(&bdi_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int bdi_min_ratio;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned int bdi_min_ratio;\n\nint bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)\n{\n\tint ret = 0;\n\n\tspin_lock_bh(&bdi_lock);\n\tif (min_ratio > bdi->max_ratio) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tmin_ratio -= bdi->min_ratio;\n\t\tif (bdi_min_ratio + min_ratio < 100) {\n\t\t\tbdi_min_ratio += min_ratio;\n\t\t\tbdi->min_ratio += min_ratio;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tspin_unlock_bh(&bdi_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_zone_page_state",
          "args": [
            "NR_FREE_PAGES"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint vm_highmem_is_dirtyable;\n\nstatic unsigned long global_dirtyable_memory(void)\n{\n\tunsigned long x;\n\n\tx = global_zone_page_state(NR_FREE_PAGES);\n\t/*\n\t * Pages reserved for the kernel should not be considered\n\t * dirtyable, to prevent a situation where reclaim has to\n\t * clean pages in order to balance the zones.\n\t */\n\tx -= min(x, totalreserve_pages);\n\n\tx += global_node_page_state(NR_INACTIVE_FILE);\n\tx += global_node_page_state(NR_ACTIVE_FILE);\n\n\tif (!vm_highmem_is_dirtyable)\n\t\tx -= highmem_dirtyable_memory(x);\n\n\treturn x + 1;\t/* Ensure that we never return 0 */\n}"
  },
  {
    "function_name": "highmem_dirtyable_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "303-353",
    "snippet": "static unsigned long highmem_dirtyable_memory(unsigned long total)\n{\n#ifdef CONFIG_HIGHMEM\n\tint node;\n\tunsigned long x = 0;\n\tint i;\n\n\tfor_each_node_state(node, N_HIGH_MEMORY) {\n\t\tfor (i = ZONE_NORMAL + 1; i < MAX_NR_ZONES; i++) {\n\t\t\tstruct zone *z;\n\t\t\tunsigned long nr_pages;\n\n\t\t\tif (!is_highmem_idx(i))\n\t\t\t\tcontinue;\n\n\t\t\tz = &NODE_DATA(node)->node_zones[i];\n\t\t\tif (!populated_zone(z))\n\t\t\t\tcontinue;\n\n\t\t\tnr_pages = zone_page_state(z, NR_FREE_PAGES);\n\t\t\t/* watch for underflows */\n\t\t\tnr_pages -= min(nr_pages, high_wmark_pages(z));\n\t\t\tnr_pages += zone_page_state(z, NR_ZONE_INACTIVE_FILE);\n\t\t\tnr_pages += zone_page_state(z, NR_ZONE_ACTIVE_FILE);\n\t\t\tx += nr_pages;\n\t\t}\n\t}\n\n\t/*\n\t * Unreclaimable memory (kernel memory or anonymous memory\n\t * without swap) can bring down the dirtyable pages below\n\t * the zone's dirty balance reserve and the above calculation\n\t * will underflow.  However we still want to add in nodes\n\t * which are below threshold (negative values) to get a more\n\t * accurate calculation but make sure that the total never\n\t * underflows.\n\t */\n\tif ((long)x < 0)\n\t\tx = 0;\n\n\t/*\n\t * Make sure that the number of highmem pages is never larger\n\t * than the number of the total dirtyable memory. This can only\n\t * occur in very strange VM situations but we want to make sure\n\t * that this does not occur.\n\t */\n\treturn min(x, total);\n#else\n\treturn 0;\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "x",
            "total"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_set_min_ratio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "674-693",
          "snippet": "int bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)\n{\n\tint ret = 0;\n\n\tspin_lock_bh(&bdi_lock);\n\tif (min_ratio > bdi->max_ratio) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tmin_ratio -= bdi->min_ratio;\n\t\tif (bdi_min_ratio + min_ratio < 100) {\n\t\t\tbdi_min_ratio += min_ratio;\n\t\t\tbdi->min_ratio += min_ratio;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tspin_unlock_bh(&bdi_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int bdi_min_ratio;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned int bdi_min_ratio;\n\nint bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)\n{\n\tint ret = 0;\n\n\tspin_lock_bh(&bdi_lock);\n\tif (min_ratio > bdi->max_ratio) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tmin_ratio -= bdi->min_ratio;\n\t\tif (bdi_min_ratio + min_ratio < 100) {\n\t\t\tbdi_min_ratio += min_ratio;\n\t\t\tbdi->min_ratio += min_ratio;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tspin_unlock_bh(&bdi_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_page_state",
          "args": [
            "z",
            "NR_ZONE_ACTIVE_FILE"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "dec_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "624-631",
          "snippet": "void dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "high_wmark_pages",
          "args": [
            "z"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "populated_zone",
          "args": [
            "z"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "node"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_highmem_idx",
          "args": [
            "i"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_node_state",
          "args": [
            "node",
            "N_HIGH_MEMORY"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned long highmem_dirtyable_memory(unsigned long total)\n{\n#ifdef CONFIG_HIGHMEM\n\tint node;\n\tunsigned long x = 0;\n\tint i;\n\n\tfor_each_node_state(node, N_HIGH_MEMORY) {\n\t\tfor (i = ZONE_NORMAL + 1; i < MAX_NR_ZONES; i++) {\n\t\t\tstruct zone *z;\n\t\t\tunsigned long nr_pages;\n\n\t\t\tif (!is_highmem_idx(i))\n\t\t\t\tcontinue;\n\n\t\t\tz = &NODE_DATA(node)->node_zones[i];\n\t\t\tif (!populated_zone(z))\n\t\t\t\tcontinue;\n\n\t\t\tnr_pages = zone_page_state(z, NR_FREE_PAGES);\n\t\t\t/* watch for underflows */\n\t\t\tnr_pages -= min(nr_pages, high_wmark_pages(z));\n\t\t\tnr_pages += zone_page_state(z, NR_ZONE_INACTIVE_FILE);\n\t\t\tnr_pages += zone_page_state(z, NR_ZONE_ACTIVE_FILE);\n\t\t\tx += nr_pages;\n\t\t}\n\t}\n\n\t/*\n\t * Unreclaimable memory (kernel memory or anonymous memory\n\t * without swap) can bring down the dirtyable pages below\n\t * the zone's dirty balance reserve and the above calculation\n\t * will underflow.  However we still want to add in nodes\n\t * which are below threshold (negative values) to get a more\n\t * accurate calculation but make sure that the total never\n\t * underflows.\n\t */\n\tif ((long)x < 0)\n\t\tx = 0;\n\n\t/*\n\t * Make sure that the number of highmem pages is never larger\n\t * than the number of the total dirtyable memory. This can only\n\t * occur in very strange VM situations but we want to make sure\n\t * that this does not occur.\n\t */\n\treturn min(x, total);\n#else\n\treturn 0;\n#endif\n}"
  },
  {
    "function_name": "node_dirtyable_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "276-301",
    "snippet": "static unsigned long node_dirtyable_memory(struct pglist_data *pgdat)\n{\n\tunsigned long nr_pages = 0;\n\tint z;\n\n\tfor (z = 0; z < MAX_NR_ZONES; z++) {\n\t\tstruct zone *zone = pgdat->node_zones + z;\n\n\t\tif (!populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tnr_pages += zone_page_state(zone, NR_FREE_PAGES);\n\t}\n\n\t/*\n\t * Pages reserved for the kernel should not be considered\n\t * dirtyable, to prevent a situation where reclaim has to\n\t * clean pages in order to balance the zones.\n\t */\n\tnr_pages -= min(nr_pages, pgdat->totalreserve_pages);\n\n\tnr_pages += node_page_state(pgdat, NR_INACTIVE_FILE);\n\tnr_pages += node_page_state(pgdat, NR_ACTIVE_FILE);\n\n\treturn nr_pages;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_page_state",
          "args": [
            "pgdat",
            "NR_ACTIVE_FILE"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "991-1000",
          "snippet": "unsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nunsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "nr_pages",
            "pgdat->totalreserve_pages"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_set_min_ratio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "674-693",
          "snippet": "int bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)\n{\n\tint ret = 0;\n\n\tspin_lock_bh(&bdi_lock);\n\tif (min_ratio > bdi->max_ratio) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tmin_ratio -= bdi->min_ratio;\n\t\tif (bdi_min_ratio + min_ratio < 100) {\n\t\t\tbdi_min_ratio += min_ratio;\n\t\t\tbdi->min_ratio += min_ratio;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tspin_unlock_bh(&bdi_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int bdi_min_ratio;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned int bdi_min_ratio;\n\nint bdi_set_min_ratio(struct backing_dev_info *bdi, unsigned int min_ratio)\n{\n\tint ret = 0;\n\n\tspin_lock_bh(&bdi_lock);\n\tif (min_ratio > bdi->max_ratio) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tmin_ratio -= bdi->min_ratio;\n\t\tif (bdi_min_ratio + min_ratio < 100) {\n\t\t\tbdi_min_ratio += min_ratio;\n\t\t\tbdi->min_ratio += min_ratio;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tspin_unlock_bh(&bdi_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_page_state",
          "args": [
            "zone",
            "NR_FREE_PAGES"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "dec_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "624-631",
          "snippet": "void dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "populated_zone",
          "args": [
            "zone"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned long node_dirtyable_memory(struct pglist_data *pgdat)\n{\n\tunsigned long nr_pages = 0;\n\tint z;\n\n\tfor (z = 0; z < MAX_NR_ZONES; z++) {\n\t\tstruct zone *zone = pgdat->node_zones + z;\n\n\t\tif (!populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tnr_pages += zone_page_state(zone, NR_FREE_PAGES);\n\t}\n\n\t/*\n\t * Pages reserved for the kernel should not be considered\n\t * dirtyable, to prevent a situation where reclaim has to\n\t * clean pages in order to balance the zones.\n\t */\n\tnr_pages -= min(nr_pages, pgdat->totalreserve_pages);\n\n\tnr_pages += node_page_state(pgdat, NR_INACTIVE_FILE);\n\tnr_pages += node_page_state(pgdat, NR_ACTIVE_FILE);\n\n\treturn nr_pages;\n}"
  },
  {
    "function_name": "wb_min_max_ratio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "242-247",
    "snippet": "static void wb_min_max_ratio(struct bdi_writeback *wb,\n\t\t\t     unsigned long *minp, unsigned long *maxp)\n{\n\t*minp = wb->bdi->min_ratio;\n\t*maxp = wb->bdi->max_ratio;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_min_max_ratio(struct bdi_writeback *wb,\n\t\t\t     unsigned long *minp, unsigned long *maxp)\n{\n\t*minp = wb->bdi->min_ratio;\n\t*maxp = wb->bdi->max_ratio;\n}"
  },
  {
    "function_name": "wb_memcg_completions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "237-240",
    "snippet": "static struct fprop_local_percpu *wb_memcg_completions(struct bdi_writeback *wb)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct fprop_local_percpu *wb_memcg_completions(struct bdi_writeback *wb)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "mdtc_gdtc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "232-235",
    "snippet": "static struct dirty_throttle_control *mdtc_gdtc(struct dirty_throttle_control *mdtc)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct dirty_throttle_control *mdtc_gdtc(struct dirty_throttle_control *mdtc)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "dtc_dom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "227-230",
    "snippet": "static struct wb_domain *dtc_dom(struct dirty_throttle_control *dtc)\n{\n\treturn &global_wb_domain;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct wb_domain global_wb_domain;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct wb_domain global_wb_domain;\n\nstatic struct wb_domain *dtc_dom(struct dirty_throttle_control *dtc)\n{\n\treturn &global_wb_domain;\n}"
  },
  {
    "function_name": "mdtc_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "222-225",
    "snippet": "static bool mdtc_valid(struct dirty_throttle_control *dtc)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic bool mdtc_valid(struct dirty_throttle_control *dtc)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "wb_min_max_ratio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "188-213",
    "snippet": "static void wb_min_max_ratio(struct bdi_writeback *wb,\n\t\t\t     unsigned long *minp, unsigned long *maxp)\n{\n\tunsigned long this_bw = wb->avg_write_bandwidth;\n\tunsigned long tot_bw = atomic_long_read(&wb->bdi->tot_write_bandwidth);\n\tunsigned long long min = wb->bdi->min_ratio;\n\tunsigned long long max = wb->bdi->max_ratio;\n\n\t/*\n\t * @wb may already be clean by the time control reaches here and\n\t * the total may not include its bw.\n\t */\n\tif (this_bw < tot_bw) {\n\t\tif (min) {\n\t\t\tmin *= this_bw;\n\t\t\tdo_div(min, tot_bw);\n\t\t}\n\t\tif (max < 100) {\n\t\t\tmax *= this_bw;\n\t\t\tdo_div(max, tot_bw);\n\t\t}\n\t}\n\n\t*minp = min;\n\t*maxp = max;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "max",
            "tot_bw"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "min",
            "tot_bw"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&wb->bdi->tot_write_bandwidth"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_min_max_ratio(struct bdi_writeback *wb,\n\t\t\t     unsigned long *minp, unsigned long *maxp)\n{\n\tunsigned long this_bw = wb->avg_write_bandwidth;\n\tunsigned long tot_bw = atomic_long_read(&wb->bdi->tot_write_bandwidth);\n\tunsigned long long min = wb->bdi->min_ratio;\n\tunsigned long long max = wb->bdi->max_ratio;\n\n\t/*\n\t * @wb may already be clean by the time control reaches here and\n\t * the total may not include its bw.\n\t */\n\tif (this_bw < tot_bw) {\n\t\tif (min) {\n\t\t\tmin *= this_bw;\n\t\t\tdo_div(min, tot_bw);\n\t\t}\n\t\tif (max < 100) {\n\t\t\tmax *= this_bw;\n\t\t\tdo_div(max, tot_bw);\n\t\t}\n\t}\n\n\t*minp = min;\n\t*maxp = max;\n}"
  },
  {
    "function_name": "wb_memcg_completions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "183-186",
    "snippet": "static struct fprop_local_percpu *wb_memcg_completions(struct bdi_writeback *wb)\n{\n\treturn &wb->memcg_completions;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct fprop_local_percpu *wb_memcg_completions(struct bdi_writeback *wb)\n{\n\treturn &wb->memcg_completions;\n}"
  },
  {
    "function_name": "mdtc_gdtc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "178-181",
    "snippet": "static struct dirty_throttle_control *mdtc_gdtc(struct dirty_throttle_control *mdtc)\n{\n\treturn mdtc->gdtc;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct dirty_throttle_control *mdtc_gdtc(struct dirty_throttle_control *mdtc)\n{\n\treturn mdtc->gdtc;\n}"
  },
  {
    "function_name": "dtc_dom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "173-176",
    "snippet": "static struct wb_domain *dtc_dom(struct dirty_throttle_control *dtc)\n{\n\treturn dtc->dom;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct wb_domain *dtc_dom(struct dirty_throttle_control *dtc)\n{\n\treturn dtc->dom;\n}"
  },
  {
    "function_name": "mdtc_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
    "lines": "168-171",
    "snippet": "static bool mdtc_valid(struct dirty_throttle_control *dtc)\n{\n\treturn dtc->dom;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/timer.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/smp.h>",
      "#include <linux/percpu.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/init.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic bool mdtc_valid(struct dirty_throttle_control *dtc)\n{\n\treturn dtc->dom;\n}"
  }
]