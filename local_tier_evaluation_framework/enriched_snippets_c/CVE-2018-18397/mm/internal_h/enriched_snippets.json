[
  {
    "function_name": "is_migrate_highatomic_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "523-526",
    "snippet": "static inline bool is_migrate_highatomic_page(struct page *page)\n{\n\treturn get_pageblock_migratetype(page) == MIGRATE_HIGHATOMIC;\n}",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_pageblock_migratetype",
          "args": [
            "page"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline bool is_migrate_highatomic_page(struct page *page)\n{\n\treturn get_pageblock_migratetype(page) == MIGRATE_HIGHATOMIC;\n}"
  },
  {
    "function_name": "is_migrate_highatomic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "518-521",
    "snippet": "static inline bool is_migrate_highatomic(enum migratetype migratetype)\n{\n\treturn migratetype == MIGRATE_HIGHATOMIC;\n}",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline bool is_migrate_highatomic(enum migratetype migratetype)\n{\n\treturn migratetype == MIGRATE_HIGHATOMIC;\n}"
  },
  {
    "function_name": "flush_tlb_batched_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "509-511",
    "snippet": "static inline void flush_tlb_batched_pending(struct mm_struct *mm)\n{\n}",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void flush_tlb_batched_pending(struct mm_struct *mm)\n{\n}"
  },
  {
    "function_name": "try_to_unmap_flush_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "506-508",
    "snippet": "static inline void try_to_unmap_flush_dirty(void)\n{\n}",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void try_to_unmap_flush_dirty(void)\n{\n}"
  },
  {
    "function_name": "try_to_unmap_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "503-505",
    "snippet": "static inline void try_to_unmap_flush(void)\n{\n}",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void try_to_unmap_flush(void)\n{\n}"
  },
  {
    "function_name": "mminit_validate_memmodel_limits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "436-439",
    "snippet": "static inline void mminit_validate_memmodel_limits(unsigned long *start_pfn,\n\t\t\t\tunsigned long *end_pfn)\n{\n}",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mminit_validate_memmodel_limits(unsigned long *start_pfn,\n\t\t\t\tunsigned long *end_pfn)\n{\n}"
  },
  {
    "function_name": "mminit_verify_zonelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "426-428",
    "snippet": "static inline void mminit_verify_zonelist(void)\n{\n}",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mminit_verify_zonelist(void)\n{\n}"
  },
  {
    "function_name": "mminit_verify_pageflags_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "422-424",
    "snippet": "static inline void mminit_verify_pageflags_layout(void)\n{\n}",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mminit_verify_pageflags_layout(void)\n{\n}"
  },
  {
    "function_name": "mminit_dprintk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "417-420",
    "snippet": "static inline void mminit_dprintk(enum mminit_level level,\n\t\t\t\tconst char *prefix, const char *fmt, ...)\n{\n}",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mminit_dprintk(enum mminit_level level,\n\t\t\t\tconst char *prefix, const char *fmt, ...)\n{\n}"
  },
  {
    "function_name": "mem_map_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "380-390",
    "snippet": "static inline struct page *mem_map_next(struct page *iter,\n\t\t\t\t\t\tstruct page *base, int offset)\n{\n\tif (unlikely((offset & (MAX_ORDER_NR_PAGES - 1)) == 0)) {\n\t\tunsigned long pfn = page_to_pfn(base) + offset;\n\t\tif (!pfn_valid(pfn))\n\t\t\treturn NULL;\n\t\treturn pfn_to_page(pfn);\n\t}\n\treturn iter + 1;\n}",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "base"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(offset & (MAX_ORDER_NR_PAGES - 1)) == 0"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline struct page *mem_map_next(struct page *iter,\n\t\t\t\t\t\tstruct page *base, int offset)\n{\n\tif (unlikely((offset & (MAX_ORDER_NR_PAGES - 1)) == 0)) {\n\t\tunsigned long pfn = page_to_pfn(base) + offset;\n\t\tif (!pfn_valid(pfn))\n\t\t\treturn NULL;\n\t\treturn pfn_to_page(pfn);\n\t}\n\treturn iter + 1;\n}"
  },
  {
    "function_name": "mem_map_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "369-374",
    "snippet": "static inline struct page *mem_map_offset(struct page *base, int offset)\n{\n\tif (unlikely(offset >= MAX_ORDER_NR_PAGES))\n\t\treturn nth_page(base, offset);\n\treturn base + offset;\n}",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nth_page",
          "args": [
            "base",
            "offset"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "offset >= MAX_ORDER_NR_PAGES"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline struct page *mem_map_offset(struct page *base, int offset)\n{\n\tif (unlikely(offset >= MAX_ORDER_NR_PAGES))\n\t\treturn nth_page(base, offset);\n\treturn base + offset;\n}"
  },
  {
    "function_name": "mlock_migrate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "360-360",
    "snippet": "static inline void mlock_migrate_page(struct page *new, struct page *old) { }",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mlock_migrate_page(struct page *new, struct page *old) { }"
  },
  {
    "function_name": "mlock_vma_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "359-359",
    "snippet": "static inline void mlock_vma_page(struct page *page) { }",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mlock_vma_page(struct page *page) { }"
  },
  {
    "function_name": "clear_page_mlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "358-358",
    "snippet": "static inline void clear_page_mlock(struct page *page) { }",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void clear_page_mlock(struct page *page) { }"
  },
  {
    "function_name": "vma_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "343-355",
    "snippet": "static inline unsigned long\nvma_address(struct page *page, struct vm_area_struct *vma)\n{\n\tunsigned long start, end;\n\n\tstart = __vma_address(page, vma);\n\tend = start + PAGE_SIZE * (hpage_nr_pages(page) - 1);\n\n\t/* page should be within @vma mapping range */\n\tVM_BUG_ON_VMA(end < vma->vm_start || start >= vma->vm_end, vma);\n\n\treturn max(start, vma->vm_start);\n}",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "start",
            "vma->vm_start"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_VMA",
          "args": [
            "end < vma->vm_start || start >= vma->vm_end",
            "vma"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vma_address",
          "args": [
            "page",
            "vma"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "__vma_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "336-341",
          "snippet": "static inline unsigned long\n__vma_address(struct page *page, struct vm_area_struct *vma)\n{\n\tpgoff_t pgoff = page_to_pgoff(page);\n\treturn vma->vm_start + ((pgoff - vma->vm_pgoff) << PAGE_SHIFT);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline unsigned long\n__vma_address(struct page *page, struct vm_area_struct *vma)\n{\n\tpgoff_t pgoff = page_to_pgoff(page);\n\treturn vma->vm_start + ((pgoff - vma->vm_pgoff) << PAGE_SHIFT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline unsigned long\nvma_address(struct page *page, struct vm_area_struct *vma)\n{\n\tunsigned long start, end;\n\n\tstart = __vma_address(page, vma);\n\tend = start + PAGE_SIZE * (hpage_nr_pages(page) - 1);\n\n\t/* page should be within @vma mapping range */\n\tVM_BUG_ON_VMA(end < vma->vm_start || start >= vma->vm_end, vma);\n\n\treturn max(start, vma->vm_start);\n}"
  },
  {
    "function_name": "__vma_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "336-341",
    "snippet": "static inline unsigned long\n__vma_address(struct page *page, struct vm_area_struct *vma)\n{\n\tpgoff_t pgoff = page_to_pgoff(page);\n\treturn vma->vm_start + ((pgoff - vma->vm_pgoff) << PAGE_SHIFT);\n}",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_to_pgoff",
          "args": [
            "page"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline unsigned long\n__vma_address(struct page *page, struct vm_area_struct *vma)\n{\n\tpgoff_t pgoff = page_to_pgoff(page);\n\treturn vma->vm_start + ((pgoff - vma->vm_pgoff) << PAGE_SHIFT);\n}"
  },
  {
    "function_name": "mlock_migrate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "319-329",
    "snippet": "static inline void mlock_migrate_page(struct page *newpage, struct page *page)\n{\n\tif (TestClearPageMlocked(page)) {\n\t\tint nr_pages = hpage_nr_pages(page);\n\n\t\t/* Holding pmd lock, no change in irq context: __mod is safe */\n\t\t__mod_zone_page_state(page_zone(page), NR_MLOCK, -nr_pages);\n\t\tSetPageMlocked(newpage);\n\t\t__mod_zone_page_state(page_zone(newpage), NR_MLOCK, nr_pages);\n\t}\n}",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mod_zone_page_state",
          "args": [
            "page_zone(newpage)",
            "NR_MLOCK",
            "nr_pages"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "__mod_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "315-332",
          "snippet": "void __mod_zone_page_state(struct zone *zone, enum zone_stat_item item,\n\t\t\t   long delta)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tzone_page_state_add(x, zone, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __mod_zone_page_state(struct zone *zone, enum zone_stat_item item,\n\t\t\t   long delta)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tzone_page_state_add(x, zone, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "newpage"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageMlocked",
          "args": [
            "newpage"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestClearPageMlocked",
          "args": [
            "page"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mlock_migrate_page(struct page *newpage, struct page *page)\n{\n\tif (TestClearPageMlocked(page)) {\n\t\tint nr_pages = hpage_nr_pages(page);\n\n\t\t/* Holding pmd lock, no change in irq context: __mod is safe */\n\t\t__mod_zone_page_state(page_zone(page), NR_MLOCK, -nr_pages);\n\t\tSetPageMlocked(newpage);\n\t\t__mod_zone_page_state(page_zone(newpage), NR_MLOCK, nr_pages);\n\t}\n}"
  },
  {
    "function_name": "munlock_vma_pages_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "292-295",
    "snippet": "static inline void munlock_vma_pages_all(struct vm_area_struct *vma)\n{\n\tmunlock_vma_pages_range(vma, vma->vm_start, vma->vm_end);\n}",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "munlock_vma_pages_range",
          "args": [
            "vma",
            "vma->vm_start",
            "vma->vm_end"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "munlock_vma_pages_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
          "lines": "445-508",
          "snippet": "void munlock_vma_pages_range(struct vm_area_struct *vma,\n\t\t\t     unsigned long start, unsigned long end)\n{\n\tvma->vm_flags &= VM_LOCKED_CLEAR_MASK;\n\n\twhile (start < end) {\n\t\tstruct page *page;\n\t\tunsigned int page_mask = 0;\n\t\tunsigned long page_increm;\n\t\tstruct pagevec pvec;\n\t\tstruct zone *zone;\n\n\t\tpagevec_init(&pvec);\n\t\t/*\n\t\t * Although FOLL_DUMP is intended for get_dump_page(),\n\t\t * it just so happens that its special treatment of the\n\t\t * ZERO_PAGE (returning an error instead of doing get_page)\n\t\t * suits munlock very well (and if somehow an abnormal page\n\t\t * has sneaked into the range, we won't oops here: great).\n\t\t */\n\t\tpage = follow_page(vma, start, FOLL_GET | FOLL_DUMP);\n\n\t\tif (page && !IS_ERR(page)) {\n\t\t\tif (PageTransTail(page)) {\n\t\t\t\tVM_BUG_ON_PAGE(PageMlocked(page), page);\n\t\t\t\tput_page(page); /* follow_page_mask() */\n\t\t\t} else if (PageTransHuge(page)) {\n\t\t\t\tlock_page(page);\n\t\t\t\t/*\n\t\t\t\t * Any THP page found by follow_page_mask() may\n\t\t\t\t * have gotten split before reaching\n\t\t\t\t * munlock_vma_page(), so we need to compute\n\t\t\t\t * the page_mask here instead.\n\t\t\t\t */\n\t\t\t\tpage_mask = munlock_vma_page(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page); /* follow_page_mask() */\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Non-huge pages are handled in batches via\n\t\t\t\t * pagevec. The pin from follow_page_mask()\n\t\t\t\t * prevents them from collapsing by THP.\n\t\t\t\t */\n\t\t\t\tpagevec_add(&pvec, page);\n\t\t\t\tzone = page_zone(page);\n\n\t\t\t\t/*\n\t\t\t\t * Try to fill the rest of pagevec using fast\n\t\t\t\t * pte walk. This will also update start to\n\t\t\t\t * the next page to process. Then munlock the\n\t\t\t\t * pagevec.\n\t\t\t\t */\n\t\t\t\tstart = __munlock_pagevec_fill(&pvec, vma,\n\t\t\t\t\t\tzone, start, end);\n\t\t\t\t__munlock_pagevec(&pvec, zone);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\t\tpage_increm = 1 + page_mask;\n\t\tstart += page_increm * PAGE_SIZE;\nnext:\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/rmap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/mm.h>",
            "#include <linux/mman.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nvoid munlock_vma_pages_range(struct vm_area_struct *vma,\n\t\t\t     unsigned long start, unsigned long end)\n{\n\tvma->vm_flags &= VM_LOCKED_CLEAR_MASK;\n\n\twhile (start < end) {\n\t\tstruct page *page;\n\t\tunsigned int page_mask = 0;\n\t\tunsigned long page_increm;\n\t\tstruct pagevec pvec;\n\t\tstruct zone *zone;\n\n\t\tpagevec_init(&pvec);\n\t\t/*\n\t\t * Although FOLL_DUMP is intended for get_dump_page(),\n\t\t * it just so happens that its special treatment of the\n\t\t * ZERO_PAGE (returning an error instead of doing get_page)\n\t\t * suits munlock very well (and if somehow an abnormal page\n\t\t * has sneaked into the range, we won't oops here: great).\n\t\t */\n\t\tpage = follow_page(vma, start, FOLL_GET | FOLL_DUMP);\n\n\t\tif (page && !IS_ERR(page)) {\n\t\t\tif (PageTransTail(page)) {\n\t\t\t\tVM_BUG_ON_PAGE(PageMlocked(page), page);\n\t\t\t\tput_page(page); /* follow_page_mask() */\n\t\t\t} else if (PageTransHuge(page)) {\n\t\t\t\tlock_page(page);\n\t\t\t\t/*\n\t\t\t\t * Any THP page found by follow_page_mask() may\n\t\t\t\t * have gotten split before reaching\n\t\t\t\t * munlock_vma_page(), so we need to compute\n\t\t\t\t * the page_mask here instead.\n\t\t\t\t */\n\t\t\t\tpage_mask = munlock_vma_page(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page); /* follow_page_mask() */\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Non-huge pages are handled in batches via\n\t\t\t\t * pagevec. The pin from follow_page_mask()\n\t\t\t\t * prevents them from collapsing by THP.\n\t\t\t\t */\n\t\t\t\tpagevec_add(&pvec, page);\n\t\t\t\tzone = page_zone(page);\n\n\t\t\t\t/*\n\t\t\t\t * Try to fill the rest of pagevec using fast\n\t\t\t\t * pte walk. This will also update start to\n\t\t\t\t * the next page to process. Then munlock the\n\t\t\t\t * pagevec.\n\t\t\t\t */\n\t\t\t\tstart = __munlock_pagevec_fill(&pvec, vma,\n\t\t\t\t\t\tzone, start, end);\n\t\t\t\t__munlock_pagevec(&pvec, zone);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\t\tpage_increm = 1 + page_mask;\n\t\tstart += page_increm * PAGE_SIZE;\nnext:\n\t\tcond_resched();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void munlock_vma_pages_all(struct vm_area_struct *vma)\n{\n\tmunlock_vma_pages_range(vma, vma->vm_start, vma->vm_end);\n}"
  },
  {
    "function_name": "is_data_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "278-281",
    "snippet": "static inline bool is_data_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_WRITE | VM_SHARED | VM_STACK)) == VM_WRITE;\n}",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline bool is_data_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_WRITE | VM_SHARED | VM_STACK)) == VM_WRITE;\n}"
  },
  {
    "function_name": "is_stack_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "270-273",
    "snippet": "static inline bool is_stack_mapping(vm_flags_t flags)\n{\n\treturn (flags & VM_STACK) == VM_STACK;\n}",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline bool is_stack_mapping(vm_flags_t flags)\n{\n\treturn (flags & VM_STACK) == VM_STACK;\n}"
  },
  {
    "function_name": "is_exec_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "259-262",
    "snippet": "static inline bool is_exec_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_EXEC | VM_WRITE | VM_STACK)) == VM_EXEC;\n}",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline bool is_exec_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_EXEC | VM_WRITE | VM_STACK)) == VM_EXEC;\n}"
  },
  {
    "function_name": "is_cow_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "247-250",
    "snippet": "static inline bool is_cow_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n}",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline bool is_cow_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n}"
  },
  {
    "function_name": "page_order",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "228-232",
    "snippet": "static inline unsigned int page_order(struct page *page)\n{\n\t/* PageBuddy() must be checked by the caller */\n\treturn page_private(page);\n}",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int page_order(struct page *page)\n{\n\t/* PageBuddy() must be checked by the caller */\n\treturn page_private(page);\n}"
  },
  {
    "function_name": "pageblock_pfn_to_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "154-161",
    "snippet": "static inline struct page *pageblock_pfn_to_page(unsigned long start_pfn,\n\t\t\t\tunsigned long end_pfn, struct zone *zone)\n{\n\tif (zone->contiguous)\n\t\treturn pfn_to_page(start_pfn);\n\n\treturn __pageblock_pfn_to_page(start_pfn, end_pfn, zone);\n}",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pageblock_pfn_to_page",
          "args": [
            "start_pfn",
            "end_pfn",
            "zone"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "__pageblock_pfn_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1366-1392",
          "snippet": "struct page *__pageblock_pfn_to_page(unsigned long start_pfn,\n\t\t\t\t     unsigned long end_pfn, struct zone *zone)\n{\n\tstruct page *start_page;\n\tstruct page *end_page;\n\n\t/* end_pfn is one past the range we are checking */\n\tend_pfn--;\n\n\tif (!pfn_valid(start_pfn) || !pfn_valid(end_pfn))\n\t\treturn NULL;\n\n\tstart_page = pfn_to_online_page(start_pfn);\n\tif (!start_page)\n\t\treturn NULL;\n\n\tif (page_zone(start_page) != zone)\n\t\treturn NULL;\n\n\tend_page = pfn_to_page(end_pfn);\n\n\t/* This gives a shorter code than deriving page_zone(end_page) */\n\tif (page_zone_id(start_page) != page_zone_id(end_page))\n\t\treturn NULL;\n\n\treturn start_page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstruct page *__pageblock_pfn_to_page(unsigned long start_pfn,\n\t\t\t\t     unsigned long end_pfn, struct zone *zone)\n{\n\tstruct page *start_page;\n\tstruct page *end_page;\n\n\t/* end_pfn is one past the range we are checking */\n\tend_pfn--;\n\n\tif (!pfn_valid(start_pfn) || !pfn_valid(end_pfn))\n\t\treturn NULL;\n\n\tstart_page = pfn_to_online_page(start_pfn);\n\tif (!start_page)\n\t\treturn NULL;\n\n\tif (page_zone(start_page) != zone)\n\t\treturn NULL;\n\n\tend_page = pfn_to_page(end_pfn);\n\n\t/* This gives a shorter code than deriving page_zone(end_page) */\n\tif (page_zone_id(start_page) != page_zone_id(end_page))\n\t\treturn NULL;\n\n\treturn start_page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "start_pfn"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline struct page *pageblock_pfn_to_page(unsigned long start_pfn,\n\t\t\t\tunsigned long end_pfn, struct zone *zone)\n{\n\tif (zone->contiguous)\n\t\treturn pfn_to_page(start_pfn);\n\n\treturn __pageblock_pfn_to_page(start_pfn, end_pfn, zone);\n}"
  },
  {
    "function_name": "__find_buddy_pfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "145-149",
    "snippet": "static inline unsigned long\n__find_buddy_pfn(unsigned long page_pfn, unsigned int order)\n{\n\treturn page_pfn ^ (1 << order);\n}",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline unsigned long\n__find_buddy_pfn(unsigned long page_pfn, unsigned int order)\n{\n\treturn page_pfn ^ (1 << order);\n}"
  },
  {
    "function_name": "set_page_refcounted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "74-79",
    "snippet": "static inline void set_page_refcounted(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(page_ref_count(page), page);\n\tset_page_count(page, 1);\n}",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_page_count",
          "args": [
            "page",
            "1"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "page_ref_count(page)",
            "page"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_count",
          "args": [
            "page"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageTail(page)",
            "page"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTail",
          "args": [
            "page"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void set_page_refcounted(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(page_ref_count(page), page);\n\tset_page_count(page, 1);\n}"
  },
  {
    "function_name": "ra_submit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "63-68",
    "snippet": "static inline unsigned long ra_submit(struct file_ra_state *ra,\n\t\tstruct address_space *mapping, struct file *filp)\n{\n\treturn __do_page_cache_readahead(mapping, filp,\n\t\t\t\t\tra->start, ra->size, ra->async_size);\n}",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__do_page_cache_readahead",
          "args": [
            "mapping",
            "filp",
            "ra->start",
            "ra->size",
            "ra->async_size"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "__do_page_cache_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
          "lines": "152-213",
          "snippet": "unsigned int __do_page_cache_readahead(struct address_space *mapping,\n\t\tstruct file *filp, pgoff_t offset, unsigned long nr_to_read,\n\t\tunsigned long lookahead_size)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tunsigned long end_index;\t/* The last page we want to read */\n\tLIST_HEAD(page_pool);\n\tint page_idx;\n\tunsigned int nr_pages = 0;\n\tloff_t isize = i_size_read(inode);\n\tgfp_t gfp_mask = readahead_gfp_mask(mapping);\n\n\tif (isize == 0)\n\t\tgoto out;\n\n\tend_index = ((isize - 1) >> PAGE_SHIFT);\n\n\t/*\n\t * Preallocate as many pages as we will need.\n\t */\n\tfor (page_idx = 0; page_idx < nr_to_read; page_idx++) {\n\t\tpgoff_t page_offset = offset + page_idx;\n\n\t\tif (page_offset > end_index)\n\t\t\tbreak;\n\n\t\tpage = xa_load(&mapping->i_pages, page_offset);\n\t\tif (page && !xa_is_value(page)) {\n\t\t\t/*\n\t\t\t * Page already present?  Kick off the current batch of\n\t\t\t * contiguous pages before continuing with the next\n\t\t\t * batch.\n\t\t\t */\n\t\t\tif (nr_pages)\n\t\t\t\tread_pages(mapping, filp, &page_pool, nr_pages,\n\t\t\t\t\t\tgfp_mask);\n\t\t\tnr_pages = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage = __page_cache_alloc(gfp_mask);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tpage->index = page_offset;\n\t\tlist_add(&page->lru, &page_pool);\n\t\tif (page_idx == nr_to_read - lookahead_size)\n\t\t\tSetPageReadahead(page);\n\t\tnr_pages++;\n\t}\n\n\t/*\n\t * Now start the IO.  We ignore I/O errors - if the page is not\n\t * uptodate then the caller will launch readpage again, and\n\t * will then handle the error.\n\t */\n\tif (nr_pages)\n\t\tread_pages(mapping, filp, &page_pool, nr_pages, gfp_mask);\n\tBUG_ON(!list_empty(&page_pool));\nout:\n\treturn nr_pages;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fadvise.h>",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/export.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nunsigned int __do_page_cache_readahead(struct address_space *mapping,\n\t\tstruct file *filp, pgoff_t offset, unsigned long nr_to_read,\n\t\tunsigned long lookahead_size)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tunsigned long end_index;\t/* The last page we want to read */\n\tLIST_HEAD(page_pool);\n\tint page_idx;\n\tunsigned int nr_pages = 0;\n\tloff_t isize = i_size_read(inode);\n\tgfp_t gfp_mask = readahead_gfp_mask(mapping);\n\n\tif (isize == 0)\n\t\tgoto out;\n\n\tend_index = ((isize - 1) >> PAGE_SHIFT);\n\n\t/*\n\t * Preallocate as many pages as we will need.\n\t */\n\tfor (page_idx = 0; page_idx < nr_to_read; page_idx++) {\n\t\tpgoff_t page_offset = offset + page_idx;\n\n\t\tif (page_offset > end_index)\n\t\t\tbreak;\n\n\t\tpage = xa_load(&mapping->i_pages, page_offset);\n\t\tif (page && !xa_is_value(page)) {\n\t\t\t/*\n\t\t\t * Page already present?  Kick off the current batch of\n\t\t\t * contiguous pages before continuing with the next\n\t\t\t * batch.\n\t\t\t */\n\t\t\tif (nr_pages)\n\t\t\t\tread_pages(mapping, filp, &page_pool, nr_pages,\n\t\t\t\t\t\tgfp_mask);\n\t\t\tnr_pages = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage = __page_cache_alloc(gfp_mask);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tpage->index = page_offset;\n\t\tlist_add(&page->lru, &page_pool);\n\t\tif (page_idx == nr_to_read - lookahead_size)\n\t\t\tSetPageReadahead(page);\n\t\tnr_pages++;\n\t}\n\n\t/*\n\t * Now start the IO.  We ignore I/O errors - if the page is not\n\t * uptodate then the caller will launch readpage again, and\n\t * will then handle the error.\n\t */\n\tif (nr_pages)\n\t\tread_pages(mapping, filp, &page_pool, nr_pages, gfp_mask);\n\tBUG_ON(!list_empty(&page_pool));\nout:\n\treturn nr_pages;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline unsigned long ra_submit(struct file_ra_state *ra,\n\t\tstruct address_space *mapping, struct file *filp)\n{\n\treturn __do_page_cache_readahead(mapping, filp,\n\t\t\t\t\tra->start, ra->size, ra->async_size);\n}"
  },
  {
    "function_name": "can_madv_dontneed_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
    "lines": "46-49",
    "snippet": "static inline bool can_madv_dontneed_vma(struct vm_area_struct *vma)\n{\n\treturn !(vma->vm_flags & (VM_LOCKED|VM_HUGETLB|VM_PFNMAP));\n}",
    "includes": [
      "#include <linux/tracepoint-defs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline bool can_madv_dontneed_vma(struct vm_area_struct *vma)\n{\n\treturn !(vma->vm_flags & (VM_LOCKED|VM_HUGETLB|VM_PFNMAP));\n}"
  }
]