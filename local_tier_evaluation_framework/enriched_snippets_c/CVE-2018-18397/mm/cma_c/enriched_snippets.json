[
  {
    "function_name": "cma_for_each_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
    "lines": "512-524",
    "snippet": "int cma_for_each_area(int (*it)(struct cma *cma, void *data), void *data)\n{\n\tint i;\n\n\tfor (i = 0; i < cma_area_count; i++) {\n\t\tint ret = it(&cma_areas[i], data);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cma.h\"",
      "#include <trace/events/cma.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/io.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cma.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/sizes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cma cma_areas[MAX_CMA_AREAS];",
      "unsigned cma_area_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "it",
          "args": [
            "&cma_areas[i]",
            "data"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "cma_bitmap_pages_to_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
          "lines": "81-85",
          "snippet": "static unsigned long cma_bitmap_pages_to_bits(const struct cma *cma,\n\t\t\t\t\t      unsigned long pages)\n{\n\treturn ALIGN(pages, 1UL << cma->order_per_bit) >> cma->order_per_bit;\n}",
          "includes": [
            "#include \"cma.h\"",
            "#include <trace/events/cma.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/io.h>",
            "#include <linux/highmem.h>",
            "#include <linux/cma.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/sizes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nstatic unsigned long cma_bitmap_pages_to_bits(const struct cma *cma,\n\t\t\t\t\t      unsigned long pages)\n{\n\treturn ALIGN(pages, 1UL << cma->order_per_bit) >> cma->order_per_bit;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nstruct cma cma_areas[MAX_CMA_AREAS];\nunsigned cma_area_count;\n\nint cma_for_each_area(int (*it)(struct cma *cma, void *data), void *data)\n{\n\tint i;\n\n\tfor (i = 0; i < cma_area_count; i++) {\n\t\tint ret = it(&cma_areas[i], data);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cma_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
    "lines": "489-510",
    "snippet": "bool cma_release(struct cma *cma, const struct page *pages, unsigned int count)\n{\n\tunsigned long pfn;\n\n\tif (!cma || !pages)\n\t\treturn false;\n\n\tpr_debug(\"%s(page %p)\\n\", __func__, (void *)pages);\n\n\tpfn = page_to_pfn(pages);\n\n\tif (pfn < cma->base_pfn || pfn >= cma->base_pfn + cma->count)\n\t\treturn false;\n\n\tVM_BUG_ON(pfn + count > cma->base_pfn + cma->count);\n\n\tfree_contig_range(pfn, count);\n\tcma_clear_bitmap(cma, pfn, count);\n\ttrace_cma_release(pfn, pages, count);\n\n\treturn true;\n}",
    "includes": [
      "#include \"cma.h\"",
      "#include <trace/events/cma.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/io.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cma.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/sizes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_cma_release",
          "args": [
            "pfn",
            "pages",
            "count"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cma_clear_bitmap",
          "args": [
            "cma",
            "pfn",
            "count"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "cma_clear_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
          "lines": "87-98",
          "snippet": "static void cma_clear_bitmap(struct cma *cma, unsigned long pfn,\n\t\t\t     unsigned int count)\n{\n\tunsigned long bitmap_no, bitmap_count;\n\n\tbitmap_no = (pfn - cma->base_pfn) >> cma->order_per_bit;\n\tbitmap_count = cma_bitmap_pages_to_bits(cma, count);\n\n\tmutex_lock(&cma->lock);\n\tbitmap_clear(cma->bitmap, bitmap_no, bitmap_count);\n\tmutex_unlock(&cma->lock);\n}",
          "includes": [
            "#include \"cma.h\"",
            "#include <trace/events/cma.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/io.h>",
            "#include <linux/highmem.h>",
            "#include <linux/cma.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/sizes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nstatic void cma_clear_bitmap(struct cma *cma, unsigned long pfn,\n\t\t\t     unsigned int count)\n{\n\tunsigned long bitmap_no, bitmap_count;\n\n\tbitmap_no = (pfn - cma->base_pfn) >> cma->order_per_bit;\n\tbitmap_count = cma_bitmap_pages_to_bits(cma, count);\n\n\tmutex_lock(&cma->lock);\n\tbitmap_clear(cma->bitmap, bitmap_no, bitmap_count);\n\tmutex_unlock(&cma->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_contig_range",
          "args": [
            "pfn",
            "count"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "pfn + count > cma->base_pfn + cma->count"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "pages"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(page %p)\\n\"",
            "__func__",
            "(void *)pages"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nbool cma_release(struct cma *cma, const struct page *pages, unsigned int count)\n{\n\tunsigned long pfn;\n\n\tif (!cma || !pages)\n\t\treturn false;\n\n\tpr_debug(\"%s(page %p)\\n\", __func__, (void *)pages);\n\n\tpfn = page_to_pfn(pages);\n\n\tif (pfn < cma->base_pfn || pfn >= cma->base_pfn + cma->count)\n\t\treturn false;\n\n\tVM_BUG_ON(pfn + count > cma->base_pfn + cma->count);\n\n\tfree_contig_range(pfn, count);\n\tcma_clear_bitmap(cma, pfn, count);\n\ttrace_cma_release(pfn, pages, count);\n\n\treturn true;\n}"
  },
  {
    "function_name": "cma_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
    "lines": "403-477",
    "snippet": "struct page *cma_alloc(struct cma *cma, size_t count, unsigned int align,\n\t\t       bool no_warn)\n{\n\tunsigned long mask, offset;\n\tunsigned long pfn = -1;\n\tunsigned long start = 0;\n\tunsigned long bitmap_maxno, bitmap_no, bitmap_count;\n\tstruct page *page = NULL;\n\tint ret = -ENOMEM;\n\n\tif (!cma || !cma->count)\n\t\treturn NULL;\n\n\tpr_debug(\"%s(cma %p, count %zu, align %d)\\n\", __func__, (void *)cma,\n\t\t count, align);\n\n\tif (!count)\n\t\treturn NULL;\n\n\tmask = cma_bitmap_aligned_mask(cma, align);\n\toffset = cma_bitmap_aligned_offset(cma, align);\n\tbitmap_maxno = cma_bitmap_maxno(cma);\n\tbitmap_count = cma_bitmap_pages_to_bits(cma, count);\n\n\tif (bitmap_count > bitmap_maxno)\n\t\treturn NULL;\n\n\tfor (;;) {\n\t\tmutex_lock(&cma->lock);\n\t\tbitmap_no = bitmap_find_next_zero_area_off(cma->bitmap,\n\t\t\t\tbitmap_maxno, start, bitmap_count, mask,\n\t\t\t\toffset);\n\t\tif (bitmap_no >= bitmap_maxno) {\n\t\t\tmutex_unlock(&cma->lock);\n\t\t\tbreak;\n\t\t}\n\t\tbitmap_set(cma->bitmap, bitmap_no, bitmap_count);\n\t\t/*\n\t\t * It's safe to drop the lock here. We've marked this region for\n\t\t * our exclusive use. If the migration fails we will take the\n\t\t * lock again and unmark it.\n\t\t */\n\t\tmutex_unlock(&cma->lock);\n\n\t\tpfn = cma->base_pfn + (bitmap_no << cma->order_per_bit);\n\t\tmutex_lock(&cma_mutex);\n\t\tret = alloc_contig_range(pfn, pfn + count, MIGRATE_CMA,\n\t\t\t\t     GFP_KERNEL | (no_warn ? __GFP_NOWARN : 0));\n\t\tmutex_unlock(&cma_mutex);\n\t\tif (ret == 0) {\n\t\t\tpage = pfn_to_page(pfn);\n\t\t\tbreak;\n\t\t}\n\n\t\tcma_clear_bitmap(cma, pfn, count);\n\t\tif (ret != -EBUSY)\n\t\t\tbreak;\n\n\t\tpr_debug(\"%s(): memory range at %p is busy, retrying\\n\",\n\t\t\t __func__, pfn_to_page(pfn));\n\t\t/* try again with a bit different memory target */\n\t\tstart = bitmap_no + mask + 1;\n\t}\n\n\ttrace_cma_alloc(pfn, page, count, align);\n\n\tif (ret && !no_warn) {\n\t\tpr_err(\"%s: alloc failed, req-size: %zu pages, ret: %d\\n\",\n\t\t\t__func__, count, ret);\n\t\tcma_debug_show_areas(cma);\n\t}\n\n\tpr_debug(\"%s(): returned %p\\n\", __func__, page);\n\treturn page;\n}",
    "includes": [
      "#include \"cma.h\"",
      "#include <trace/events/cma.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/io.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cma.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/sizes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(cma_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(): returned %p\\n\"",
            "__func__",
            "page"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cma_debug_show_areas",
          "args": [
            "cma"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "cma_debug_show_areas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
          "lines": "390-390",
          "snippet": "static inline void cma_debug_show_areas(struct cma *cma) { }",
          "includes": [
            "#include \"cma.h\"",
            "#include <trace/events/cma.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/io.h>",
            "#include <linux/highmem.h>",
            "#include <linux/cma.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/sizes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nstatic inline void cma_debug_show_areas(struct cma *cma) { }"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: alloc failed, req-size: %zu pages, ret: %d\\n\"",
            "__func__",
            "count",
            "ret"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_cma_alloc",
          "args": [
            "pfn",
            "page",
            "count",
            "align"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(): memory range at %p is busy, retrying\\n\"",
            "__func__",
            "pfn_to_page(pfn)"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cma_clear_bitmap",
          "args": [
            "cma",
            "pfn",
            "count"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "cma_clear_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
          "lines": "87-98",
          "snippet": "static void cma_clear_bitmap(struct cma *cma, unsigned long pfn,\n\t\t\t     unsigned int count)\n{\n\tunsigned long bitmap_no, bitmap_count;\n\n\tbitmap_no = (pfn - cma->base_pfn) >> cma->order_per_bit;\n\tbitmap_count = cma_bitmap_pages_to_bits(cma, count);\n\n\tmutex_lock(&cma->lock);\n\tbitmap_clear(cma->bitmap, bitmap_no, bitmap_count);\n\tmutex_unlock(&cma->lock);\n}",
          "includes": [
            "#include \"cma.h\"",
            "#include <trace/events/cma.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/io.h>",
            "#include <linux/highmem.h>",
            "#include <linux/cma.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/sizes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nstatic void cma_clear_bitmap(struct cma *cma, unsigned long pfn,\n\t\t\t     unsigned int count)\n{\n\tunsigned long bitmap_no, bitmap_count;\n\n\tbitmap_no = (pfn - cma->base_pfn) >> cma->order_per_bit;\n\tbitmap_count = cma_bitmap_pages_to_bits(cma, count);\n\n\tmutex_lock(&cma->lock);\n\tbitmap_clear(cma->bitmap, bitmap_no, bitmap_count);\n\tmutex_unlock(&cma->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cma_mutex"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_contig_range",
          "args": [
            "pfn",
            "pfn + count",
            "MIGRATE_CMA",
            "GFP_KERNEL | (no_warn ? __GFP_NOWARN : 0)"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cma_mutex"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cma->lock"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_set",
          "args": [
            "cma->bitmap",
            "bitmap_no",
            "bitmap_count"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cma->lock"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_find_next_zero_area_off",
          "args": [
            "cma->bitmap",
            "bitmap_maxno",
            "start",
            "bitmap_count",
            "mask",
            "offset"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cma->lock"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cma_bitmap_pages_to_bits",
          "args": [
            "cma",
            "count"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "cma_bitmap_pages_to_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
          "lines": "81-85",
          "snippet": "static unsigned long cma_bitmap_pages_to_bits(const struct cma *cma,\n\t\t\t\t\t      unsigned long pages)\n{\n\treturn ALIGN(pages, 1UL << cma->order_per_bit) >> cma->order_per_bit;\n}",
          "includes": [
            "#include \"cma.h\"",
            "#include <trace/events/cma.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/io.h>",
            "#include <linux/highmem.h>",
            "#include <linux/cma.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/sizes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nstatic unsigned long cma_bitmap_pages_to_bits(const struct cma *cma,\n\t\t\t\t\t      unsigned long pages)\n{\n\treturn ALIGN(pages, 1UL << cma->order_per_bit) >> cma->order_per_bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cma_bitmap_maxno",
          "args": [
            "cma"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "cma_bitmap_maxno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.h",
          "lines": "21-24",
          "snippet": "static inline unsigned long cma_bitmap_maxno(struct cma *cma)\n{\n\treturn cma->count >> cma->order_per_bit;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long cma_bitmap_maxno(struct cma *cma)\n{\n\treturn cma->count >> cma->order_per_bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cma_bitmap_aligned_offset",
          "args": [
            "cma",
            "align"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "cma_bitmap_aligned_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
          "lines": "74-79",
          "snippet": "static unsigned long cma_bitmap_aligned_offset(const struct cma *cma,\n\t\t\t\t\t       unsigned int align_order)\n{\n\treturn (cma->base_pfn & ((1UL << align_order) - 1))\n\t\t>> cma->order_per_bit;\n}",
          "includes": [
            "#include \"cma.h\"",
            "#include <trace/events/cma.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/io.h>",
            "#include <linux/highmem.h>",
            "#include <linux/cma.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/sizes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nstatic unsigned long cma_bitmap_aligned_offset(const struct cma *cma,\n\t\t\t\t\t       unsigned int align_order)\n{\n\treturn (cma->base_pfn & ((1UL << align_order) - 1))\n\t\t>> cma->order_per_bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cma_bitmap_aligned_mask",
          "args": [
            "cma",
            "align"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "cma_bitmap_aligned_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
          "lines": "62-68",
          "snippet": "static unsigned long cma_bitmap_aligned_mask(const struct cma *cma,\n\t\t\t\t\t     unsigned int align_order)\n{\n\tif (align_order <= cma->order_per_bit)\n\t\treturn 0;\n\treturn (1UL << (align_order - cma->order_per_bit)) - 1;\n}",
          "includes": [
            "#include \"cma.h\"",
            "#include <trace/events/cma.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/io.h>",
            "#include <linux/highmem.h>",
            "#include <linux/cma.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/sizes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nstatic unsigned long cma_bitmap_aligned_mask(const struct cma *cma,\n\t\t\t\t\t     unsigned int align_order)\n{\n\tif (align_order <= cma->order_per_bit)\n\t\treturn 0;\n\treturn (1UL << (align_order - cma->order_per_bit)) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(cma %p, count %zu, align %d)\\n\"",
            "__func__",
            "(void *)cma",
            "count",
            "align"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nstatic DEFINE_MUTEX(cma_mutex);\n\nstruct page *cma_alloc(struct cma *cma, size_t count, unsigned int align,\n\t\t       bool no_warn)\n{\n\tunsigned long mask, offset;\n\tunsigned long pfn = -1;\n\tunsigned long start = 0;\n\tunsigned long bitmap_maxno, bitmap_no, bitmap_count;\n\tstruct page *page = NULL;\n\tint ret = -ENOMEM;\n\n\tif (!cma || !cma->count)\n\t\treturn NULL;\n\n\tpr_debug(\"%s(cma %p, count %zu, align %d)\\n\", __func__, (void *)cma,\n\t\t count, align);\n\n\tif (!count)\n\t\treturn NULL;\n\n\tmask = cma_bitmap_aligned_mask(cma, align);\n\toffset = cma_bitmap_aligned_offset(cma, align);\n\tbitmap_maxno = cma_bitmap_maxno(cma);\n\tbitmap_count = cma_bitmap_pages_to_bits(cma, count);\n\n\tif (bitmap_count > bitmap_maxno)\n\t\treturn NULL;\n\n\tfor (;;) {\n\t\tmutex_lock(&cma->lock);\n\t\tbitmap_no = bitmap_find_next_zero_area_off(cma->bitmap,\n\t\t\t\tbitmap_maxno, start, bitmap_count, mask,\n\t\t\t\toffset);\n\t\tif (bitmap_no >= bitmap_maxno) {\n\t\t\tmutex_unlock(&cma->lock);\n\t\t\tbreak;\n\t\t}\n\t\tbitmap_set(cma->bitmap, bitmap_no, bitmap_count);\n\t\t/*\n\t\t * It's safe to drop the lock here. We've marked this region for\n\t\t * our exclusive use. If the migration fails we will take the\n\t\t * lock again and unmark it.\n\t\t */\n\t\tmutex_unlock(&cma->lock);\n\n\t\tpfn = cma->base_pfn + (bitmap_no << cma->order_per_bit);\n\t\tmutex_lock(&cma_mutex);\n\t\tret = alloc_contig_range(pfn, pfn + count, MIGRATE_CMA,\n\t\t\t\t     GFP_KERNEL | (no_warn ? __GFP_NOWARN : 0));\n\t\tmutex_unlock(&cma_mutex);\n\t\tif (ret == 0) {\n\t\t\tpage = pfn_to_page(pfn);\n\t\t\tbreak;\n\t\t}\n\n\t\tcma_clear_bitmap(cma, pfn, count);\n\t\tif (ret != -EBUSY)\n\t\t\tbreak;\n\n\t\tpr_debug(\"%s(): memory range at %p is busy, retrying\\n\",\n\t\t\t __func__, pfn_to_page(pfn));\n\t\t/* try again with a bit different memory target */\n\t\tstart = bitmap_no + mask + 1;\n\t}\n\n\ttrace_cma_alloc(pfn, page, count, align);\n\n\tif (ret && !no_warn) {\n\t\tpr_err(\"%s: alloc failed, req-size: %zu pages, ret: %d\\n\",\n\t\t\t__func__, count, ret);\n\t\tcma_debug_show_areas(cma);\n\t}\n\n\tpr_debug(\"%s(): returned %p\\n\", __func__, page);\n\treturn page;\n}"
  },
  {
    "function_name": "cma_debug_show_areas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
    "lines": "390-390",
    "snippet": "static inline void cma_debug_show_areas(struct cma *cma) { }",
    "includes": [
      "#include \"cma.h\"",
      "#include <trace/events/cma.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/io.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cma.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/sizes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nstatic inline void cma_debug_show_areas(struct cma *cma) { }"
  },
  {
    "function_name": "cma_debug_show_areas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
    "lines": "368-388",
    "snippet": "static void cma_debug_show_areas(struct cma *cma)\n{\n\tunsigned long next_zero_bit, next_set_bit;\n\tunsigned long start = 0;\n\tunsigned int nr_zero, nr_total = 0;\n\n\tmutex_lock(&cma->lock);\n\tpr_info(\"number of available pages: \");\n\tfor (;;) {\n\t\tnext_zero_bit = find_next_zero_bit(cma->bitmap, cma->count, start);\n\t\tif (next_zero_bit >= cma->count)\n\t\t\tbreak;\n\t\tnext_set_bit = find_next_bit(cma->bitmap, cma->count, next_zero_bit);\n\t\tnr_zero = next_set_bit - next_zero_bit;\n\t\tpr_cont(\"%s%u@%lu\", nr_total ? \"+\" : \"\", nr_zero, next_zero_bit);\n\t\tnr_total += nr_zero;\n\t\tstart = next_zero_bit + nr_zero;\n\t}\n\tpr_cont(\"=> %u free of %lu total pages\\n\", nr_total, cma->count);\n\tmutex_unlock(&cma->lock);\n}",
    "includes": [
      "#include \"cma.h\"",
      "#include <trace/events/cma.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/io.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cma.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/sizes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cma->lock"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"=> %u free of %lu total pages\\n\"",
            "nr_total",
            "cma->count"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%s%u@%lu\"",
            "nr_total ? \"+\" : \"\"",
            "nr_zero",
            "next_zero_bit"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "cma->bitmap",
            "cma->count",
            "next_zero_bit"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_zero_bit",
          "args": [
            "cma->bitmap",
            "cma->count",
            "start"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"number of available pages: \""
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cma->lock"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nstatic void cma_debug_show_areas(struct cma *cma)\n{\n\tunsigned long next_zero_bit, next_set_bit;\n\tunsigned long start = 0;\n\tunsigned int nr_zero, nr_total = 0;\n\n\tmutex_lock(&cma->lock);\n\tpr_info(\"number of available pages: \");\n\tfor (;;) {\n\t\tnext_zero_bit = find_next_zero_bit(cma->bitmap, cma->count, start);\n\t\tif (next_zero_bit >= cma->count)\n\t\t\tbreak;\n\t\tnext_set_bit = find_next_bit(cma->bitmap, cma->count, next_zero_bit);\n\t\tnr_zero = next_set_bit - next_zero_bit;\n\t\tpr_cont(\"%s%u@%lu\", nr_total ? \"+\" : \"\", nr_zero, next_zero_bit);\n\t\tnr_total += nr_zero;\n\t\tstart = next_zero_bit + nr_zero;\n\t}\n\tpr_cont(\"=> %u free of %lu total pages\\n\", nr_total, cma->count);\n\tmutex_unlock(&cma->lock);\n}"
  },
  {
    "function_name": "cma_declare_contiguous",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
    "lines": "245-365",
    "snippet": "int __init cma_declare_contiguous(phys_addr_t base,\n\t\t\tphys_addr_t size, phys_addr_t limit,\n\t\t\tphys_addr_t alignment, unsigned int order_per_bit,\n\t\t\tbool fixed, const char *name, struct cma **res_cma)\n{\n\tphys_addr_t memblock_end = memblock_end_of_DRAM();\n\tphys_addr_t highmem_start;\n\tint ret = 0;\n\n\t/*\n\t * We can't use __pa(high_memory) directly, since high_memory\n\t * isn't a valid direct map VA, and DEBUG_VIRTUAL will (validly)\n\t * complain. Find the boundary by adding one to the last valid\n\t * address.\n\t */\n\thighmem_start = __pa(high_memory - 1) + 1;\n\tpr_debug(\"%s(size %pa, base %pa, limit %pa alignment %pa)\\n\",\n\t\t__func__, &size, &base, &limit, &alignment);\n\n\tif (cma_area_count == ARRAY_SIZE(cma_areas)) {\n\t\tpr_err(\"Not enough slots for CMA reserved regions!\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tif (!size)\n\t\treturn -EINVAL;\n\n\tif (alignment && !is_power_of_2(alignment))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Sanitise input arguments.\n\t * Pages both ends in CMA area could be merged into adjacent unmovable\n\t * migratetype page by page allocator's buddy algorithm. In the case,\n\t * you couldn't get a contiguous memory, which is not what we want.\n\t */\n\talignment = max(alignment,  (phys_addr_t)PAGE_SIZE <<\n\t\t\t  max_t(unsigned long, MAX_ORDER - 1, pageblock_order));\n\tbase = ALIGN(base, alignment);\n\tsize = ALIGN(size, alignment);\n\tlimit &= ~(alignment - 1);\n\n\tif (!base)\n\t\tfixed = false;\n\n\t/* size should be aligned with order_per_bit */\n\tif (!IS_ALIGNED(size >> PAGE_SHIFT, 1 << order_per_bit))\n\t\treturn -EINVAL;\n\n\t/*\n\t * If allocating at a fixed base the request region must not cross the\n\t * low/high memory boundary.\n\t */\n\tif (fixed && base < highmem_start && base + size > highmem_start) {\n\t\tret = -EINVAL;\n\t\tpr_err(\"Region at %pa defined on low/high memory boundary (%pa)\\n\",\n\t\t\t&base, &highmem_start);\n\t\tgoto err;\n\t}\n\n\t/*\n\t * If the limit is unspecified or above the memblock end, its effective\n\t * value will be the memblock end. Set it explicitly to simplify further\n\t * checks.\n\t */\n\tif (limit == 0 || limit > memblock_end)\n\t\tlimit = memblock_end;\n\n\t/* Reserve memory */\n\tif (fixed) {\n\t\tif (memblock_is_region_reserved(base, size) ||\n\t\t    memblock_reserve(base, size) < 0) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tphys_addr_t addr = 0;\n\n\t\t/*\n\t\t * All pages in the reserved area must come from the same zone.\n\t\t * If the requested region crosses the low/high memory boundary,\n\t\t * try allocating from high memory first and fall back to low\n\t\t * memory in case of failure.\n\t\t */\n\t\tif (base < highmem_start && limit > highmem_start) {\n\t\t\taddr = memblock_alloc_range(size, alignment,\n\t\t\t\t\t\t    highmem_start, limit,\n\t\t\t\t\t\t    MEMBLOCK_NONE);\n\t\t\tlimit = highmem_start;\n\t\t}\n\n\t\tif (!addr) {\n\t\t\taddr = memblock_alloc_range(size, alignment, base,\n\t\t\t\t\t\t    limit,\n\t\t\t\t\t\t    MEMBLOCK_NONE);\n\t\t\tif (!addr) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * kmemleak scans/reads tracked objects for pointers to other\n\t\t * objects but this address isn't mapped and accessible\n\t\t */\n\t\tkmemleak_ignore_phys(addr);\n\t\tbase = addr;\n\t}\n\n\tret = cma_init_reserved_mem(base, size, order_per_bit, name, res_cma);\n\tif (ret)\n\t\tgoto err;\n\n\tpr_info(\"Reserved %ld MiB at %pa\\n\", (unsigned long)size / SZ_1M,\n\t\t&base);\n\treturn 0;\n\nerr:\n\tpr_err(\"Failed to reserve %ld MiB\\n\", (unsigned long)size / SZ_1M);\n\treturn ret;\n}",
    "includes": [
      "#include \"cma.h\"",
      "#include <trace/events/cma.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/io.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cma.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/sizes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cma cma_areas[MAX_CMA_AREAS];",
      "unsigned cma_area_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to reserve %ld MiB\\n\"",
            "(unsigned long)size / SZ_1M"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Reserved %ld MiB at %pa\\n\"",
            "(unsigned long)size / SZ_1M",
            "&base"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cma_init_reserved_mem",
          "args": [
            "base",
            "size",
            "order_per_bit",
            "name",
            "res_cma"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "cma_init_reserved_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
          "lines": "176-224",
          "snippet": "int __init cma_init_reserved_mem(phys_addr_t base, phys_addr_t size,\n\t\t\t\t unsigned int order_per_bit,\n\t\t\t\t const char *name,\n\t\t\t\t struct cma **res_cma)\n{\n\tstruct cma *cma;\n\tphys_addr_t alignment;\n\n\t/* Sanity checks */\n\tif (cma_area_count == ARRAY_SIZE(cma_areas)) {\n\t\tpr_err(\"Not enough slots for CMA reserved regions!\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tif (!size || !memblock_is_region_reserved(base, size))\n\t\treturn -EINVAL;\n\n\t/* ensure minimal alignment required by mm core */\n\talignment = PAGE_SIZE <<\n\t\t\tmax_t(unsigned long, MAX_ORDER - 1, pageblock_order);\n\n\t/* alignment should be aligned with order_per_bit */\n\tif (!IS_ALIGNED(alignment >> PAGE_SHIFT, 1 << order_per_bit))\n\t\treturn -EINVAL;\n\n\tif (ALIGN(base, alignment) != base || ALIGN(size, alignment) != size)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Each reserved area must be initialised later, when more kernel\n\t * subsystems (like slab allocator) are available.\n\t */\n\tcma = &cma_areas[cma_area_count];\n\tif (name) {\n\t\tcma->name = name;\n\t} else {\n\t\tcma->name = kasprintf(GFP_KERNEL, \"cma%d\\n\", cma_area_count);\n\t\tif (!cma->name)\n\t\t\treturn -ENOMEM;\n\t}\n\tcma->base_pfn = PFN_DOWN(base);\n\tcma->count = size >> PAGE_SHIFT;\n\tcma->order_per_bit = order_per_bit;\n\t*res_cma = cma;\n\tcma_area_count++;\n\ttotalcma_pages += (size / PAGE_SIZE);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cma.h\"",
            "#include <trace/events/cma.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/io.h>",
            "#include <linux/highmem.h>",
            "#include <linux/cma.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/sizes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cma cma_areas[MAX_CMA_AREAS];",
            "unsigned cma_area_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nstruct cma cma_areas[MAX_CMA_AREAS];\nunsigned cma_area_count;\n\nint __init cma_init_reserved_mem(phys_addr_t base, phys_addr_t size,\n\t\t\t\t unsigned int order_per_bit,\n\t\t\t\t const char *name,\n\t\t\t\t struct cma **res_cma)\n{\n\tstruct cma *cma;\n\tphys_addr_t alignment;\n\n\t/* Sanity checks */\n\tif (cma_area_count == ARRAY_SIZE(cma_areas)) {\n\t\tpr_err(\"Not enough slots for CMA reserved regions!\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tif (!size || !memblock_is_region_reserved(base, size))\n\t\treturn -EINVAL;\n\n\t/* ensure minimal alignment required by mm core */\n\talignment = PAGE_SIZE <<\n\t\t\tmax_t(unsigned long, MAX_ORDER - 1, pageblock_order);\n\n\t/* alignment should be aligned with order_per_bit */\n\tif (!IS_ALIGNED(alignment >> PAGE_SHIFT, 1 << order_per_bit))\n\t\treturn -EINVAL;\n\n\tif (ALIGN(base, alignment) != base || ALIGN(size, alignment) != size)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Each reserved area must be initialised later, when more kernel\n\t * subsystems (like slab allocator) are available.\n\t */\n\tcma = &cma_areas[cma_area_count];\n\tif (name) {\n\t\tcma->name = name;\n\t} else {\n\t\tcma->name = kasprintf(GFP_KERNEL, \"cma%d\\n\", cma_area_count);\n\t\tif (!cma->name)\n\t\t\treturn -ENOMEM;\n\t}\n\tcma->base_pfn = PFN_DOWN(base);\n\tcma->count = size >> PAGE_SHIFT;\n\tcma->order_per_bit = order_per_bit;\n\t*res_cma = cma;\n\tcma_area_count++;\n\ttotalcma_pages += (size / PAGE_SIZE);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_ignore_phys",
          "args": [
            "addr"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_ignore_phys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1259-1263",
          "snippet": "void __ref kmemleak_ignore_phys(phys_addr_t phys)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_ignore(__va(phys));\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid __ref kmemleak_ignore_phys(phys_addr_t phys)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_ignore(__va(phys));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_alloc_range",
          "args": [
            "size",
            "alignment",
            "base",
            "limit",
            "MEMBLOCK_NONE"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_alloc_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1269-1275",
          "snippet": "phys_addr_t __init memblock_alloc_range(phys_addr_t size, phys_addr_t align,\n\t\t\t\t\tphys_addr_t start, phys_addr_t end,\n\t\t\t\t\tenum memblock_flags flags)\n{\n\treturn memblock_alloc_range_nid(size, align, start, end, NUMA_NO_NODE,\n\t\t\t\t\tflags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nphys_addr_t __init memblock_alloc_range(phys_addr_t size, phys_addr_t align,\n\t\t\t\t\tphys_addr_t start, phys_addr_t end,\n\t\t\t\t\tenum memblock_flags flags)\n{\n\treturn memblock_alloc_range_nid(size, align, start, end, NUMA_NO_NODE,\n\t\t\t\t\tflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_reserve",
          "args": [
            "base",
            "size"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "815-823",
          "snippet": "int __init_memblock memblock_reserve(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"memblock_reserve: [%pa-%pa] %pF\\n\",\n\t\t     &base, &end, (void *)_RET_IP_);\n\n\treturn memblock_add_range(&memblock.reserved, base, size, MAX_NUMNODES, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nint __init_memblock memblock_reserve(phys_addr_t base, phys_addr_t size)\n{\n\tphys_addr_t end = base + size - 1;\n\n\tmemblock_dbg(\"memblock_reserve: [%pa-%pa] %pF\\n\",\n\t\t     &base, &end, (void *)_RET_IP_);\n\n\treturn memblock_add_range(&memblock.reserved, base, size, MAX_NUMNODES, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_is_region_reserved",
          "args": [
            "base",
            "size"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_is_region_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1798-1802",
          "snippet": "bool __init_memblock memblock_is_region_reserved(phys_addr_t base, phys_addr_t size)\n{\n\tmemblock_cap_size(base, &size);\n\treturn memblock_overlaps_region(&memblock.reserved, base, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nbool __init_memblock memblock_is_region_reserved(phys_addr_t base, phys_addr_t size)\n{\n\tmemblock_cap_size(base, &size);\n\treturn memblock_overlaps_region(&memblock.reserved, base, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Region at %pa defined on low/high memory boundary (%pa)\\n\"",
            "&base",
            "&highmem_start"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "size >> PAGE_SHIFT",
            "1 << order_per_bit"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "size",
            "alignment"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "base",
            "alignment"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "alignment",
            "(phys_addr_t)PAGE_SIZE <<\n\t\t\t  max_t(unsigned long, MAX_ORDER - 1, pageblock_order)"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedlong",
            "MAX_ORDER - 1",
            "pageblock_order"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "alignment"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Not enough slots for CMA reserved regions!\\n\""
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "cma_areas"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(size %pa, base %pa, limit %pa alignment %pa)\\n\"",
            "__func__",
            "&size",
            "&base",
            "&limit",
            "&alignment"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "high_memory - 1"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_end_of_DRAM",
          "args": [],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nstruct cma cma_areas[MAX_CMA_AREAS];\nunsigned cma_area_count;\n\nint __init cma_declare_contiguous(phys_addr_t base,\n\t\t\tphys_addr_t size, phys_addr_t limit,\n\t\t\tphys_addr_t alignment, unsigned int order_per_bit,\n\t\t\tbool fixed, const char *name, struct cma **res_cma)\n{\n\tphys_addr_t memblock_end = memblock_end_of_DRAM();\n\tphys_addr_t highmem_start;\n\tint ret = 0;\n\n\t/*\n\t * We can't use __pa(high_memory) directly, since high_memory\n\t * isn't a valid direct map VA, and DEBUG_VIRTUAL will (validly)\n\t * complain. Find the boundary by adding one to the last valid\n\t * address.\n\t */\n\thighmem_start = __pa(high_memory - 1) + 1;\n\tpr_debug(\"%s(size %pa, base %pa, limit %pa alignment %pa)\\n\",\n\t\t__func__, &size, &base, &limit, &alignment);\n\n\tif (cma_area_count == ARRAY_SIZE(cma_areas)) {\n\t\tpr_err(\"Not enough slots for CMA reserved regions!\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tif (!size)\n\t\treturn -EINVAL;\n\n\tif (alignment && !is_power_of_2(alignment))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Sanitise input arguments.\n\t * Pages both ends in CMA area could be merged into adjacent unmovable\n\t * migratetype page by page allocator's buddy algorithm. In the case,\n\t * you couldn't get a contiguous memory, which is not what we want.\n\t */\n\talignment = max(alignment,  (phys_addr_t)PAGE_SIZE <<\n\t\t\t  max_t(unsigned long, MAX_ORDER - 1, pageblock_order));\n\tbase = ALIGN(base, alignment);\n\tsize = ALIGN(size, alignment);\n\tlimit &= ~(alignment - 1);\n\n\tif (!base)\n\t\tfixed = false;\n\n\t/* size should be aligned with order_per_bit */\n\tif (!IS_ALIGNED(size >> PAGE_SHIFT, 1 << order_per_bit))\n\t\treturn -EINVAL;\n\n\t/*\n\t * If allocating at a fixed base the request region must not cross the\n\t * low/high memory boundary.\n\t */\n\tif (fixed && base < highmem_start && base + size > highmem_start) {\n\t\tret = -EINVAL;\n\t\tpr_err(\"Region at %pa defined on low/high memory boundary (%pa)\\n\",\n\t\t\t&base, &highmem_start);\n\t\tgoto err;\n\t}\n\n\t/*\n\t * If the limit is unspecified or above the memblock end, its effective\n\t * value will be the memblock end. Set it explicitly to simplify further\n\t * checks.\n\t */\n\tif (limit == 0 || limit > memblock_end)\n\t\tlimit = memblock_end;\n\n\t/* Reserve memory */\n\tif (fixed) {\n\t\tif (memblock_is_region_reserved(base, size) ||\n\t\t    memblock_reserve(base, size) < 0) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tphys_addr_t addr = 0;\n\n\t\t/*\n\t\t * All pages in the reserved area must come from the same zone.\n\t\t * If the requested region crosses the low/high memory boundary,\n\t\t * try allocating from high memory first and fall back to low\n\t\t * memory in case of failure.\n\t\t */\n\t\tif (base < highmem_start && limit > highmem_start) {\n\t\t\taddr = memblock_alloc_range(size, alignment,\n\t\t\t\t\t\t    highmem_start, limit,\n\t\t\t\t\t\t    MEMBLOCK_NONE);\n\t\t\tlimit = highmem_start;\n\t\t}\n\n\t\tif (!addr) {\n\t\t\taddr = memblock_alloc_range(size, alignment, base,\n\t\t\t\t\t\t    limit,\n\t\t\t\t\t\t    MEMBLOCK_NONE);\n\t\t\tif (!addr) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * kmemleak scans/reads tracked objects for pointers to other\n\t\t * objects but this address isn't mapped and accessible\n\t\t */\n\t\tkmemleak_ignore_phys(addr);\n\t\tbase = addr;\n\t}\n\n\tret = cma_init_reserved_mem(base, size, order_per_bit, name, res_cma);\n\tif (ret)\n\t\tgoto err;\n\n\tpr_info(\"Reserved %ld MiB at %pa\\n\", (unsigned long)size / SZ_1M,\n\t\t&base);\n\treturn 0;\n\nerr:\n\tpr_err(\"Failed to reserve %ld MiB\\n\", (unsigned long)size / SZ_1M);\n\treturn ret;\n}"
  },
  {
    "function_name": "cma_init_reserved_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
    "lines": "176-224",
    "snippet": "int __init cma_init_reserved_mem(phys_addr_t base, phys_addr_t size,\n\t\t\t\t unsigned int order_per_bit,\n\t\t\t\t const char *name,\n\t\t\t\t struct cma **res_cma)\n{\n\tstruct cma *cma;\n\tphys_addr_t alignment;\n\n\t/* Sanity checks */\n\tif (cma_area_count == ARRAY_SIZE(cma_areas)) {\n\t\tpr_err(\"Not enough slots for CMA reserved regions!\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tif (!size || !memblock_is_region_reserved(base, size))\n\t\treturn -EINVAL;\n\n\t/* ensure minimal alignment required by mm core */\n\talignment = PAGE_SIZE <<\n\t\t\tmax_t(unsigned long, MAX_ORDER - 1, pageblock_order);\n\n\t/* alignment should be aligned with order_per_bit */\n\tif (!IS_ALIGNED(alignment >> PAGE_SHIFT, 1 << order_per_bit))\n\t\treturn -EINVAL;\n\n\tif (ALIGN(base, alignment) != base || ALIGN(size, alignment) != size)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Each reserved area must be initialised later, when more kernel\n\t * subsystems (like slab allocator) are available.\n\t */\n\tcma = &cma_areas[cma_area_count];\n\tif (name) {\n\t\tcma->name = name;\n\t} else {\n\t\tcma->name = kasprintf(GFP_KERNEL, \"cma%d\\n\", cma_area_count);\n\t\tif (!cma->name)\n\t\t\treturn -ENOMEM;\n\t}\n\tcma->base_pfn = PFN_DOWN(base);\n\tcma->count = size >> PAGE_SHIFT;\n\tcma->order_per_bit = order_per_bit;\n\t*res_cma = cma;\n\tcma_area_count++;\n\ttotalcma_pages += (size / PAGE_SIZE);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cma.h\"",
      "#include <trace/events/cma.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/io.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cma.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/sizes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cma cma_areas[MAX_CMA_AREAS];",
      "unsigned cma_area_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "base"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"cma%d\\n\"",
            "cma_area_count"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "size",
            "alignment"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "base",
            "alignment"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "alignment >> PAGE_SHIFT",
            "1 << order_per_bit"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedlong",
            "MAX_ORDER - 1",
            "pageblock_order"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_is_region_reserved",
          "args": [
            "base",
            "size"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_is_region_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1798-1802",
          "snippet": "bool __init_memblock memblock_is_region_reserved(phys_addr_t base, phys_addr_t size)\n{\n\tmemblock_cap_size(base, &size);\n\treturn memblock_overlaps_region(&memblock.reserved, base, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nbool __init_memblock memblock_is_region_reserved(phys_addr_t base, phys_addr_t size)\n{\n\tmemblock_cap_size(base, &size);\n\treturn memblock_overlaps_region(&memblock.reserved, base, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Not enough slots for CMA reserved regions!\\n\""
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "cma_areas"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nstruct cma cma_areas[MAX_CMA_AREAS];\nunsigned cma_area_count;\n\nint __init cma_init_reserved_mem(phys_addr_t base, phys_addr_t size,\n\t\t\t\t unsigned int order_per_bit,\n\t\t\t\t const char *name,\n\t\t\t\t struct cma **res_cma)\n{\n\tstruct cma *cma;\n\tphys_addr_t alignment;\n\n\t/* Sanity checks */\n\tif (cma_area_count == ARRAY_SIZE(cma_areas)) {\n\t\tpr_err(\"Not enough slots for CMA reserved regions!\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tif (!size || !memblock_is_region_reserved(base, size))\n\t\treturn -EINVAL;\n\n\t/* ensure minimal alignment required by mm core */\n\talignment = PAGE_SIZE <<\n\t\t\tmax_t(unsigned long, MAX_ORDER - 1, pageblock_order);\n\n\t/* alignment should be aligned with order_per_bit */\n\tif (!IS_ALIGNED(alignment >> PAGE_SHIFT, 1 << order_per_bit))\n\t\treturn -EINVAL;\n\n\tif (ALIGN(base, alignment) != base || ALIGN(size, alignment) != size)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Each reserved area must be initialised later, when more kernel\n\t * subsystems (like slab allocator) are available.\n\t */\n\tcma = &cma_areas[cma_area_count];\n\tif (name) {\n\t\tcma->name = name;\n\t} else {\n\t\tcma->name = kasprintf(GFP_KERNEL, \"cma%d\\n\", cma_area_count);\n\t\tif (!cma->name)\n\t\t\treturn -ENOMEM;\n\t}\n\tcma->base_pfn = PFN_DOWN(base);\n\tcma->count = size >> PAGE_SHIFT;\n\tcma->order_per_bit = order_per_bit;\n\t*res_cma = cma;\n\tcma_area_count++;\n\ttotalcma_pages += (size / PAGE_SIZE);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cma_init_reserved_areas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
    "lines": "149-161",
    "snippet": "static int __init cma_init_reserved_areas(void)\n{\n\tint i;\n\n\tfor (i = 0; i < cma_area_count; i++) {\n\t\tint ret = cma_activate_area(&cma_areas[i]);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cma.h\"",
      "#include <trace/events/cma.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/io.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cma.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/sizes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cma cma_areas[MAX_CMA_AREAS];",
      "unsigned cma_area_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cma_activate_area",
          "args": [
            "&cma_areas[i]"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "cma_activate_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
          "lines": "100-147",
          "snippet": "static int __init cma_activate_area(struct cma *cma)\n{\n\tint bitmap_size = BITS_TO_LONGS(cma_bitmap_maxno(cma)) * sizeof(long);\n\tunsigned long base_pfn = cma->base_pfn, pfn = base_pfn;\n\tunsigned i = cma->count >> pageblock_order;\n\tstruct zone *zone;\n\n\tcma->bitmap = kzalloc(bitmap_size, GFP_KERNEL);\n\n\tif (!cma->bitmap)\n\t\treturn -ENOMEM;\n\n\tWARN_ON_ONCE(!pfn_valid(pfn));\n\tzone = page_zone(pfn_to_page(pfn));\n\n\tdo {\n\t\tunsigned j;\n\n\t\tbase_pfn = pfn;\n\t\tfor (j = pageblock_nr_pages; j; --j, pfn++) {\n\t\t\tWARN_ON_ONCE(!pfn_valid(pfn));\n\t\t\t/*\n\t\t\t * alloc_contig_range requires the pfn range\n\t\t\t * specified to be in the same zone. Make this\n\t\t\t * simple by forcing the entire CMA resv range\n\t\t\t * to be in the same zone.\n\t\t\t */\n\t\t\tif (page_zone(pfn_to_page(pfn)) != zone)\n\t\t\t\tgoto not_in_zone;\n\t\t}\n\t\tinit_cma_reserved_pageblock(pfn_to_page(base_pfn));\n\t} while (--i);\n\n\tmutex_init(&cma->lock);\n\n#ifdef CONFIG_CMA_DEBUGFS\n\tINIT_HLIST_HEAD(&cma->mem_head);\n\tspin_lock_init(&cma->mem_head_lock);\n#endif\n\n\treturn 0;\n\nnot_in_zone:\n\tpr_err(\"CMA area %s could not be activated\\n\", cma->name);\n\tkfree(cma->bitmap);\n\tcma->count = 0;\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"cma.h\"",
            "#include <trace/events/cma.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/io.h>",
            "#include <linux/highmem.h>",
            "#include <linux/cma.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/sizes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nstatic int __init cma_activate_area(struct cma *cma)\n{\n\tint bitmap_size = BITS_TO_LONGS(cma_bitmap_maxno(cma)) * sizeof(long);\n\tunsigned long base_pfn = cma->base_pfn, pfn = base_pfn;\n\tunsigned i = cma->count >> pageblock_order;\n\tstruct zone *zone;\n\n\tcma->bitmap = kzalloc(bitmap_size, GFP_KERNEL);\n\n\tif (!cma->bitmap)\n\t\treturn -ENOMEM;\n\n\tWARN_ON_ONCE(!pfn_valid(pfn));\n\tzone = page_zone(pfn_to_page(pfn));\n\n\tdo {\n\t\tunsigned j;\n\n\t\tbase_pfn = pfn;\n\t\tfor (j = pageblock_nr_pages; j; --j, pfn++) {\n\t\t\tWARN_ON_ONCE(!pfn_valid(pfn));\n\t\t\t/*\n\t\t\t * alloc_contig_range requires the pfn range\n\t\t\t * specified to be in the same zone. Make this\n\t\t\t * simple by forcing the entire CMA resv range\n\t\t\t * to be in the same zone.\n\t\t\t */\n\t\t\tif (page_zone(pfn_to_page(pfn)) != zone)\n\t\t\t\tgoto not_in_zone;\n\t\t}\n\t\tinit_cma_reserved_pageblock(pfn_to_page(base_pfn));\n\t} while (--i);\n\n\tmutex_init(&cma->lock);\n\n#ifdef CONFIG_CMA_DEBUGFS\n\tINIT_HLIST_HEAD(&cma->mem_head);\n\tspin_lock_init(&cma->mem_head_lock);\n#endif\n\n\treturn 0;\n\nnot_in_zone:\n\tpr_err(\"CMA area %s could not be activated\\n\", cma->name);\n\tkfree(cma->bitmap);\n\tcma->count = 0;\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nstruct cma cma_areas[MAX_CMA_AREAS];\nunsigned cma_area_count;\n\nstatic int __init cma_init_reserved_areas(void)\n{\n\tint i;\n\n\tfor (i = 0; i < cma_area_count; i++) {\n\t\tint ret = cma_activate_area(&cma_areas[i]);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cma_activate_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
    "lines": "100-147",
    "snippet": "static int __init cma_activate_area(struct cma *cma)\n{\n\tint bitmap_size = BITS_TO_LONGS(cma_bitmap_maxno(cma)) * sizeof(long);\n\tunsigned long base_pfn = cma->base_pfn, pfn = base_pfn;\n\tunsigned i = cma->count >> pageblock_order;\n\tstruct zone *zone;\n\n\tcma->bitmap = kzalloc(bitmap_size, GFP_KERNEL);\n\n\tif (!cma->bitmap)\n\t\treturn -ENOMEM;\n\n\tWARN_ON_ONCE(!pfn_valid(pfn));\n\tzone = page_zone(pfn_to_page(pfn));\n\n\tdo {\n\t\tunsigned j;\n\n\t\tbase_pfn = pfn;\n\t\tfor (j = pageblock_nr_pages; j; --j, pfn++) {\n\t\t\tWARN_ON_ONCE(!pfn_valid(pfn));\n\t\t\t/*\n\t\t\t * alloc_contig_range requires the pfn range\n\t\t\t * specified to be in the same zone. Make this\n\t\t\t * simple by forcing the entire CMA resv range\n\t\t\t * to be in the same zone.\n\t\t\t */\n\t\t\tif (page_zone(pfn_to_page(pfn)) != zone)\n\t\t\t\tgoto not_in_zone;\n\t\t}\n\t\tinit_cma_reserved_pageblock(pfn_to_page(base_pfn));\n\t} while (--i);\n\n\tmutex_init(&cma->lock);\n\n#ifdef CONFIG_CMA_DEBUGFS\n\tINIT_HLIST_HEAD(&cma->mem_head);\n\tspin_lock_init(&cma->mem_head_lock);\n#endif\n\n\treturn 0;\n\nnot_in_zone:\n\tpr_err(\"CMA area %s could not be activated\\n\", cma->name);\n\tkfree(cma->bitmap);\n\tcma->count = 0;\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"cma.h\"",
      "#include <trace/events/cma.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/io.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cma.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/sizes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cma->bitmap"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"CMA area %s could not be activated\\n\"",
            "cma->name"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&cma->mem_head_lock"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&cma->mem_head"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&cma->lock"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_cma_reserved_pageblock",
          "args": [
            "pfn_to_page(base_pfn)"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "init_cma_reserved_pageblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1756-1782",
          "snippet": "void __init init_cma_reserved_pageblock(struct page *page)\n{\n\tunsigned i = pageblock_nr_pages;\n\tstruct page *p = page;\n\n\tdo {\n\t\t__ClearPageReserved(p);\n\t\tset_page_count(p, 0);\n\t} while (++p, --i);\n\n\tset_pageblock_migratetype(page, MIGRATE_CMA);\n\n\tif (pageblock_order >= MAX_ORDER) {\n\t\ti = pageblock_nr_pages;\n\t\tp = page;\n\t\tdo {\n\t\t\tset_page_refcounted(p);\n\t\t\t__free_pages(p, MAX_ORDER - 1);\n\t\t\tp += MAX_ORDER_NR_PAGES;\n\t\t} while (i -= MAX_ORDER_NR_PAGES);\n\t} else {\n\t\tset_page_refcounted(page);\n\t\t__free_pages(page, pageblock_order);\n\t}\n\n\tadjust_managed_page_count(page, pageblock_nr_pages);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid __init init_cma_reserved_pageblock(struct page *page)\n{\n\tunsigned i = pageblock_nr_pages;\n\tstruct page *p = page;\n\n\tdo {\n\t\t__ClearPageReserved(p);\n\t\tset_page_count(p, 0);\n\t} while (++p, --i);\n\n\tset_pageblock_migratetype(page, MIGRATE_CMA);\n\n\tif (pageblock_order >= MAX_ORDER) {\n\t\ti = pageblock_nr_pages;\n\t\tp = page;\n\t\tdo {\n\t\t\tset_page_refcounted(p);\n\t\t\t__free_pages(p, MAX_ORDER - 1);\n\t\t\tp += MAX_ORDER_NR_PAGES;\n\t\t} while (i -= MAX_ORDER_NR_PAGES);\n\t} else {\n\t\tset_page_refcounted(page);\n\t\t__free_pages(page, pageblock_order);\n\t}\n\n\tadjust_managed_page_count(page, pageblock_nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "base_pfn"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "pfn_to_page(pfn)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!pfn_valid(pfn)"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "pfn_to_page(pfn)"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!pfn_valid(pfn)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "bitmap_size",
            "GFP_KERNEL"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "cma_bitmap_maxno(cma)"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cma_bitmap_maxno",
          "args": [
            "cma"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "cma_bitmap_maxno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.h",
          "lines": "21-24",
          "snippet": "static inline unsigned long cma_bitmap_maxno(struct cma *cma)\n{\n\treturn cma->count >> cma->order_per_bit;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long cma_bitmap_maxno(struct cma *cma)\n{\n\treturn cma->count >> cma->order_per_bit;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nstatic int __init cma_activate_area(struct cma *cma)\n{\n\tint bitmap_size = BITS_TO_LONGS(cma_bitmap_maxno(cma)) * sizeof(long);\n\tunsigned long base_pfn = cma->base_pfn, pfn = base_pfn;\n\tunsigned i = cma->count >> pageblock_order;\n\tstruct zone *zone;\n\n\tcma->bitmap = kzalloc(bitmap_size, GFP_KERNEL);\n\n\tif (!cma->bitmap)\n\t\treturn -ENOMEM;\n\n\tWARN_ON_ONCE(!pfn_valid(pfn));\n\tzone = page_zone(pfn_to_page(pfn));\n\n\tdo {\n\t\tunsigned j;\n\n\t\tbase_pfn = pfn;\n\t\tfor (j = pageblock_nr_pages; j; --j, pfn++) {\n\t\t\tWARN_ON_ONCE(!pfn_valid(pfn));\n\t\t\t/*\n\t\t\t * alloc_contig_range requires the pfn range\n\t\t\t * specified to be in the same zone. Make this\n\t\t\t * simple by forcing the entire CMA resv range\n\t\t\t * to be in the same zone.\n\t\t\t */\n\t\t\tif (page_zone(pfn_to_page(pfn)) != zone)\n\t\t\t\tgoto not_in_zone;\n\t\t}\n\t\tinit_cma_reserved_pageblock(pfn_to_page(base_pfn));\n\t} while (--i);\n\n\tmutex_init(&cma->lock);\n\n#ifdef CONFIG_CMA_DEBUGFS\n\tINIT_HLIST_HEAD(&cma->mem_head);\n\tspin_lock_init(&cma->mem_head_lock);\n#endif\n\n\treturn 0;\n\nnot_in_zone:\n\tpr_err(\"CMA area %s could not be activated\\n\", cma->name);\n\tkfree(cma->bitmap);\n\tcma->count = 0;\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "cma_clear_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
    "lines": "87-98",
    "snippet": "static void cma_clear_bitmap(struct cma *cma, unsigned long pfn,\n\t\t\t     unsigned int count)\n{\n\tunsigned long bitmap_no, bitmap_count;\n\n\tbitmap_no = (pfn - cma->base_pfn) >> cma->order_per_bit;\n\tbitmap_count = cma_bitmap_pages_to_bits(cma, count);\n\n\tmutex_lock(&cma->lock);\n\tbitmap_clear(cma->bitmap, bitmap_no, bitmap_count);\n\tmutex_unlock(&cma->lock);\n}",
    "includes": [
      "#include \"cma.h\"",
      "#include <trace/events/cma.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/io.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cma.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/sizes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cma->lock"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_clear",
          "args": [
            "cma->bitmap",
            "bitmap_no",
            "bitmap_count"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cma->lock"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cma_bitmap_pages_to_bits",
          "args": [
            "cma",
            "count"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "cma_bitmap_pages_to_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
          "lines": "81-85",
          "snippet": "static unsigned long cma_bitmap_pages_to_bits(const struct cma *cma,\n\t\t\t\t\t      unsigned long pages)\n{\n\treturn ALIGN(pages, 1UL << cma->order_per_bit) >> cma->order_per_bit;\n}",
          "includes": [
            "#include \"cma.h\"",
            "#include <trace/events/cma.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/io.h>",
            "#include <linux/highmem.h>",
            "#include <linux/cma.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/sizes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nstatic unsigned long cma_bitmap_pages_to_bits(const struct cma *cma,\n\t\t\t\t\t      unsigned long pages)\n{\n\treturn ALIGN(pages, 1UL << cma->order_per_bit) >> cma->order_per_bit;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nstatic void cma_clear_bitmap(struct cma *cma, unsigned long pfn,\n\t\t\t     unsigned int count)\n{\n\tunsigned long bitmap_no, bitmap_count;\n\n\tbitmap_no = (pfn - cma->base_pfn) >> cma->order_per_bit;\n\tbitmap_count = cma_bitmap_pages_to_bits(cma, count);\n\n\tmutex_lock(&cma->lock);\n\tbitmap_clear(cma->bitmap, bitmap_no, bitmap_count);\n\tmutex_unlock(&cma->lock);\n}"
  },
  {
    "function_name": "cma_bitmap_pages_to_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
    "lines": "81-85",
    "snippet": "static unsigned long cma_bitmap_pages_to_bits(const struct cma *cma,\n\t\t\t\t\t      unsigned long pages)\n{\n\treturn ALIGN(pages, 1UL << cma->order_per_bit) >> cma->order_per_bit;\n}",
    "includes": [
      "#include \"cma.h\"",
      "#include <trace/events/cma.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/io.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cma.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/sizes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "pages",
            "1UL << cma->order_per_bit"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nstatic unsigned long cma_bitmap_pages_to_bits(const struct cma *cma,\n\t\t\t\t\t      unsigned long pages)\n{\n\treturn ALIGN(pages, 1UL << cma->order_per_bit) >> cma->order_per_bit;\n}"
  },
  {
    "function_name": "cma_bitmap_aligned_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
    "lines": "74-79",
    "snippet": "static unsigned long cma_bitmap_aligned_offset(const struct cma *cma,\n\t\t\t\t\t       unsigned int align_order)\n{\n\treturn (cma->base_pfn & ((1UL << align_order) - 1))\n\t\t>> cma->order_per_bit;\n}",
    "includes": [
      "#include \"cma.h\"",
      "#include <trace/events/cma.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/io.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cma.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/sizes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nstatic unsigned long cma_bitmap_aligned_offset(const struct cma *cma,\n\t\t\t\t\t       unsigned int align_order)\n{\n\treturn (cma->base_pfn & ((1UL << align_order) - 1))\n\t\t>> cma->order_per_bit;\n}"
  },
  {
    "function_name": "cma_bitmap_aligned_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
    "lines": "62-68",
    "snippet": "static unsigned long cma_bitmap_aligned_mask(const struct cma *cma,\n\t\t\t\t\t     unsigned int align_order)\n{\n\tif (align_order <= cma->order_per_bit)\n\t\treturn 0;\n\treturn (1UL << (align_order - cma->order_per_bit)) - 1;\n}",
    "includes": [
      "#include \"cma.h\"",
      "#include <trace/events/cma.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/io.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cma.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/sizes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nstatic unsigned long cma_bitmap_aligned_mask(const struct cma *cma,\n\t\t\t\t\t     unsigned int align_order)\n{\n\tif (align_order <= cma->order_per_bit)\n\t\treturn 0;\n\treturn (1UL << (align_order - cma->order_per_bit)) - 1;\n}"
  },
  {
    "function_name": "cma_get_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
    "lines": "57-60",
    "snippet": "const char *cma_get_name(const struct cma *cma)\n{\n\treturn cma->name ? cma->name : \"(undefined)\";\n}",
    "includes": [
      "#include \"cma.h\"",
      "#include <trace/events/cma.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/io.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cma.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/sizes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nconst char *cma_get_name(const struct cma *cma)\n{\n\treturn cma->name ? cma->name : \"(undefined)\";\n}"
  },
  {
    "function_name": "cma_get_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
    "lines": "52-55",
    "snippet": "unsigned long cma_get_size(const struct cma *cma)\n{\n\treturn cma->count << PAGE_SHIFT;\n}",
    "includes": [
      "#include \"cma.h\"",
      "#include <trace/events/cma.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/io.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cma.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/sizes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nunsigned long cma_get_size(const struct cma *cma)\n{\n\treturn cma->count << PAGE_SHIFT;\n}"
  },
  {
    "function_name": "cma_get_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
    "lines": "47-50",
    "snippet": "phys_addr_t cma_get_base(const struct cma *cma)\n{\n\treturn PFN_PHYS(cma->base_pfn);\n}",
    "includes": [
      "#include \"cma.h\"",
      "#include <trace/events/cma.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/io.h>",
      "#include <linux/highmem.h>",
      "#include <linux/cma.h>",
      "#include <linux/log2.h>",
      "#include <linux/slab.h>",
      "#include <linux/sizes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/err.h>",
      "#include <linux/memblock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PFN_PHYS",
          "args": [
            "cma->base_pfn"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nphys_addr_t cma_get_base(const struct cma *cma)\n{\n\treturn PFN_PHYS(cma->base_pfn);\n}"
  }
]