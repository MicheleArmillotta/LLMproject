[
  {
    "function_name": "ptlock_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "4562-4565",
    "snippet": "void ptlock_free(struct page *page)\n{\n\tkmem_cache_free(page_ptl_cachep, page->ptl);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "page_ptl_cachep",
            "page->ptl"
          ],
          "line": 4564
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3749-3764",
          "snippet": "void kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid ptlock_free(struct page *page)\n{\n\tkmem_cache_free(page_ptl_cachep, page->ptl);\n}"
  },
  {
    "function_name": "ptlock_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "4551-4560",
    "snippet": "bool ptlock_alloc(struct page *page)\n{\n\tspinlock_t *ptl;\n\n\tptl = kmem_cache_alloc(page_ptl_cachep, GFP_KERNEL);\n\tif (!ptl)\n\t\treturn false;\n\tpage->ptl = ptl;\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "page_ptl_cachep",
            "GFP_KERNEL"
          ],
          "line": 4555
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3550-3559",
          "snippet": "void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *ret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc(_RET_IP_, ret,\n\t\t\t       cachep->object_size, cachep->size, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *ret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc(_RET_IP_, ret,\n\t\t\t       cachep->object_size, cachep->size, flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nbool ptlock_alloc(struct page *page)\n{\n\tspinlock_t *ptl;\n\n\tptl = kmem_cache_alloc(page_ptl_cachep, GFP_KERNEL);\n\tif (!ptl)\n\t\treturn false;\n\tpage->ptl = ptl;\n\treturn true;\n}"
  },
  {
    "function_name": "ptlock_cache_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "4545-4549",
    "snippet": "void __init ptlock_cache_init(void)\n{\n\tpage_ptl_cachep = kmem_cache_create(\"page->ptl\", sizeof(spinlock_t), 0,\n\t\t\tSLAB_PANIC, NULL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"page->ptl\"",
            "sizeof(spinlock_t)",
            "0",
            "SLAB_PANIC",
            "NULL"
          ],
          "line": 4547
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "517-523",
          "snippet": "struct kmem_cache *\nkmem_cache_create(const char *name, unsigned int size, unsigned int align,\n\t\tslab_flags_t flags, void (*ctor)(void *))\n{\n\treturn kmem_cache_create_usercopy(name, size, align, flags, 0, 0,\n\t\t\t\t\t  ctor);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstruct kmem_cache *\nkmem_cache_create(const char *name, unsigned int size, unsigned int align,\n\t\tslab_flags_t flags, void (*ctor)(void *))\n{\n\treturn kmem_cache_create_usercopy(name, size, align, flags, 0, 0,\n\t\t\t\t\t  ctor);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid __init ptlock_cache_init(void)\n{\n\tpage_ptl_cachep = kmem_cache_create(\"page->ptl\", sizeof(spinlock_t), 0,\n\t\t\tSLAB_PANIC, NULL);\n}"
  },
  {
    "function_name": "copy_huge_page_from_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "4508-4538",
    "snippet": "long copy_huge_page_from_user(struct page *dst_page,\n\t\t\t\tconst void __user *usr_src,\n\t\t\t\tunsigned int pages_per_huge_page,\n\t\t\t\tbool allow_pagefault)\n{\n\tvoid *src = (void *)usr_src;\n\tvoid *page_kaddr;\n\tunsigned long i, rc = 0;\n\tunsigned long ret_val = pages_per_huge_page * PAGE_SIZE;\n\n\tfor (i = 0; i < pages_per_huge_page; i++) {\n\t\tif (allow_pagefault)\n\t\t\tpage_kaddr = kmap(dst_page + i);\n\t\telse\n\t\t\tpage_kaddr = kmap_atomic(dst_page + i);\n\t\trc = copy_from_user(page_kaddr,\n\t\t\t\t(const void __user *)(src + i * PAGE_SIZE),\n\t\t\t\tPAGE_SIZE);\n\t\tif (allow_pagefault)\n\t\t\tkunmap(dst_page + i);\n\t\telse\n\t\t\tkunmap_atomic(page_kaddr);\n\n\t\tret_val -= (PAGE_SIZE - rc);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n\treturn ret_val;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 4535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "page_kaddr"
          ],
          "line": 4529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "dst_page + i"
          ],
          "line": 4527
        },
        "resolved": true,
        "details": {
          "function_name": "kunmap_high",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "329-370",
          "snippet": "void kunmap_high(struct page *page)\n{\n\tunsigned long vaddr;\n\tunsigned long nr;\n\tunsigned long flags;\n\tint need_wakeup;\n\tunsigned int color = get_pkmap_color(page);\n\twait_queue_head_t *pkmap_map_wait;\n\n\tlock_kmap_any(flags);\n\tvaddr = (unsigned long)page_address(page);\n\tBUG_ON(!vaddr);\n\tnr = PKMAP_NR(vaddr);\n\n\t/*\n\t * A count must never go down to zero\n\t * without a TLB flush!\n\t */\n\tneed_wakeup = 0;\n\tswitch (--pkmap_count[nr]) {\n\tcase 0:\n\t\tBUG();\n\tcase 1:\n\t\t/*\n\t\t * Avoid an unnecessary wake_up() function call.\n\t\t * The common case is pkmap_count[] == 1, but\n\t\t * no waiters.\n\t\t * The tasks queued in the wait-queue are guarded\n\t\t * by both the lock in the wait-queue-head and by\n\t\t * the kmap_lock.  As the kmap_lock is held here,\n\t\t * no need for the wait-queue-head's lock.  Simply\n\t\t * test if the queue is empty.\n\t\t */\n\t\tpkmap_map_wait = get_pkmap_wait_queue_head(color);\n\t\tneed_wakeup = waitqueue_active(pkmap_map_wait);\n\t}\n\tunlock_kmap_any(flags);\n\n\t/* do wake-up, if needed, race-free outside of the spin lock */\n\tif (need_wakeup)\n\t\twake_up(pkmap_map_wait);\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define get_pkmap_color get_pkmap_color"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\n#define get_pkmap_color get_pkmap_color\n\nvoid kunmap_high(struct page *page)\n{\n\tunsigned long vaddr;\n\tunsigned long nr;\n\tunsigned long flags;\n\tint need_wakeup;\n\tunsigned int color = get_pkmap_color(page);\n\twait_queue_head_t *pkmap_map_wait;\n\n\tlock_kmap_any(flags);\n\tvaddr = (unsigned long)page_address(page);\n\tBUG_ON(!vaddr);\n\tnr = PKMAP_NR(vaddr);\n\n\t/*\n\t * A count must never go down to zero\n\t * without a TLB flush!\n\t */\n\tneed_wakeup = 0;\n\tswitch (--pkmap_count[nr]) {\n\tcase 0:\n\t\tBUG();\n\tcase 1:\n\t\t/*\n\t\t * Avoid an unnecessary wake_up() function call.\n\t\t * The common case is pkmap_count[] == 1, but\n\t\t * no waiters.\n\t\t * The tasks queued in the wait-queue are guarded\n\t\t * by both the lock in the wait-queue-head and by\n\t\t * the kmap_lock.  As the kmap_lock is held here,\n\t\t * no need for the wait-queue-head's lock.  Simply\n\t\t * test if the queue is empty.\n\t\t */\n\t\tpkmap_map_wait = get_pkmap_wait_queue_head(color);\n\t\tneed_wakeup = waitqueue_active(pkmap_map_wait);\n\t}\n\tunlock_kmap_any(flags);\n\n\t/* do wake-up, if needed, race-free outside of the spin lock */\n\tif (need_wakeup)\n\t\twake_up(pkmap_map_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "page_kaddr",
            "(const void __user *)(src + i * PAGE_SIZE)",
            "PAGE_SIZE"
          ],
          "line": 4523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "dst_page + i"
          ],
          "line": 4522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "dst_page + i"
          ],
          "line": 4520
        },
        "resolved": true,
        "details": {
          "function_name": "kmap_high_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "307-319",
          "snippet": "void *kmap_high_get(struct page *page)\n{\n\tunsigned long vaddr, flags;\n\n\tlock_kmap_any(flags);\n\tvaddr = (unsigned long)page_address(page);\n\tif (vaddr) {\n\t\tBUG_ON(pkmap_count[PKMAP_NR(vaddr)] < 1);\n\t\tpkmap_count[PKMAP_NR(vaddr)]++;\n\t}\n\tunlock_kmap_any(flags);\n\treturn (void*) vaddr;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *kmap_high_get(struct page *page)\n{\n\tunsigned long vaddr, flags;\n\n\tlock_kmap_any(flags);\n\tvaddr = (unsigned long)page_address(page);\n\tif (vaddr) {\n\t\tBUG_ON(pkmap_count[PKMAP_NR(vaddr)] < 1);\n\t\tpkmap_count[PKMAP_NR(vaddr)]++;\n\t}\n\tunlock_kmap_any(flags);\n\treturn (void*) vaddr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nlong copy_huge_page_from_user(struct page *dst_page,\n\t\t\t\tconst void __user *usr_src,\n\t\t\t\tunsigned int pages_per_huge_page,\n\t\t\t\tbool allow_pagefault)\n{\n\tvoid *src = (void *)usr_src;\n\tvoid *page_kaddr;\n\tunsigned long i, rc = 0;\n\tunsigned long ret_val = pages_per_huge_page * PAGE_SIZE;\n\n\tfor (i = 0; i < pages_per_huge_page; i++) {\n\t\tif (allow_pagefault)\n\t\t\tpage_kaddr = kmap(dst_page + i);\n\t\telse\n\t\t\tpage_kaddr = kmap_atomic(dst_page + i);\n\t\trc = copy_from_user(page_kaddr,\n\t\t\t\t(const void __user *)(src + i * PAGE_SIZE),\n\t\t\t\tPAGE_SIZE);\n\t\tif (allow_pagefault)\n\t\t\tkunmap(dst_page + i);\n\t\telse\n\t\t\tkunmap_atomic(page_kaddr);\n\n\t\tret_val -= (PAGE_SIZE - rc);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n\treturn ret_val;\n}"
  },
  {
    "function_name": "copy_user_huge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "4487-4506",
    "snippet": "void copy_user_huge_page(struct page *dst, struct page *src,\n\t\t\t unsigned long addr_hint, struct vm_area_struct *vma,\n\t\t\t unsigned int pages_per_huge_page)\n{\n\tunsigned long addr = addr_hint &\n\t\t~(((unsigned long)pages_per_huge_page << PAGE_SHIFT) - 1);\n\tstruct copy_subpage_arg arg = {\n\t\t.dst = dst,\n\t\t.src = src,\n\t\t.vma = vma,\n\t};\n\n\tif (unlikely(pages_per_huge_page > MAX_ORDER_NR_PAGES)) {\n\t\tcopy_user_gigantic_page(dst, src, addr, vma,\n\t\t\t\t\tpages_per_huge_page);\n\t\treturn;\n\t}\n\n\tprocess_huge_page(addr_hint, pages_per_huge_page, copy_subpage, &arg);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_huge_page",
          "args": [
            "addr_hint",
            "pages_per_huge_page",
            "copy_subpage",
            "&arg"
          ],
          "line": 4505
        },
        "resolved": true,
        "details": {
          "function_name": "process_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "4372-4416",
          "snippet": "static inline void process_huge_page(\n\tunsigned long addr_hint, unsigned int pages_per_huge_page,\n\tvoid (*process_subpage)(unsigned long addr, int idx, void *arg),\n\tvoid *arg)\n{\n\tint i, n, base, l;\n\tunsigned long addr = addr_hint &\n\t\t~(((unsigned long)pages_per_huge_page << PAGE_SHIFT) - 1);\n\n\t/* Process target subpage last to keep its cache lines hot */\n\tmight_sleep();\n\tn = (addr_hint - addr) / PAGE_SIZE;\n\tif (2 * n <= pages_per_huge_page) {\n\t\t/* If target subpage in first half of huge page */\n\t\tbase = 0;\n\t\tl = n;\n\t\t/* Process subpages at the end of huge page */\n\t\tfor (i = pages_per_huge_page - 1; i >= 2 * n; i--) {\n\t\t\tcond_resched();\n\t\t\tprocess_subpage(addr + i * PAGE_SIZE, i, arg);\n\t\t}\n\t} else {\n\t\t/* If target subpage in second half of huge page */\n\t\tbase = pages_per_huge_page - 2 * (pages_per_huge_page - n);\n\t\tl = pages_per_huge_page - n;\n\t\t/* Process subpages at the begin of huge page */\n\t\tfor (i = 0; i < base; i++) {\n\t\t\tcond_resched();\n\t\t\tprocess_subpage(addr + i * PAGE_SIZE, i, arg);\n\t\t}\n\t}\n\t/*\n\t * Process remaining subpages in left-right-left-right pattern\n\t * towards the target subpage\n\t */\n\tfor (i = 0; i < l; i++) {\n\t\tint left_idx = base + i;\n\t\tint right_idx = base + 2 * l - 1 - i;\n\n\t\tcond_resched();\n\t\tprocess_subpage(addr + left_idx * PAGE_SIZE, left_idx, arg);\n\t\tcond_resched();\n\t\tprocess_subpage(addr + right_idx * PAGE_SIZE, right_idx, arg);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void process_huge_page(\n\tunsigned long addr_hint, unsigned int pages_per_huge_page,\n\tvoid (*process_subpage)(unsigned long addr, int idx, void *arg),\n\tvoid *arg)\n{\n\tint i, n, base, l;\n\tunsigned long addr = addr_hint &\n\t\t~(((unsigned long)pages_per_huge_page << PAGE_SHIFT) - 1);\n\n\t/* Process target subpage last to keep its cache lines hot */\n\tmight_sleep();\n\tn = (addr_hint - addr) / PAGE_SIZE;\n\tif (2 * n <= pages_per_huge_page) {\n\t\t/* If target subpage in first half of huge page */\n\t\tbase = 0;\n\t\tl = n;\n\t\t/* Process subpages at the end of huge page */\n\t\tfor (i = pages_per_huge_page - 1; i >= 2 * n; i--) {\n\t\t\tcond_resched();\n\t\t\tprocess_subpage(addr + i * PAGE_SIZE, i, arg);\n\t\t}\n\t} else {\n\t\t/* If target subpage in second half of huge page */\n\t\tbase = pages_per_huge_page - 2 * (pages_per_huge_page - n);\n\t\tl = pages_per_huge_page - n;\n\t\t/* Process subpages at the begin of huge page */\n\t\tfor (i = 0; i < base; i++) {\n\t\t\tcond_resched();\n\t\t\tprocess_subpage(addr + i * PAGE_SIZE, i, arg);\n\t\t}\n\t}\n\t/*\n\t * Process remaining subpages in left-right-left-right pattern\n\t * towards the target subpage\n\t */\n\tfor (i = 0; i < l; i++) {\n\t\tint left_idx = base + i;\n\t\tint right_idx = base + 2 * l - 1 - i;\n\n\t\tcond_resched();\n\t\tprocess_subpage(addr + left_idx * PAGE_SIZE, left_idx, arg);\n\t\tcond_resched();\n\t\tprocess_subpage(addr + right_idx * PAGE_SIZE, right_idx, arg);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_user_gigantic_page",
          "args": [
            "dst",
            "src",
            "addr",
            "vma",
            "pages_per_huge_page"
          ],
          "line": 4500
        },
        "resolved": true,
        "details": {
          "function_name": "copy_user_gigantic_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "4454-4471",
          "snippet": "static void copy_user_gigantic_page(struct page *dst, struct page *src,\n\t\t\t\t    unsigned long addr,\n\t\t\t\t    struct vm_area_struct *vma,\n\t\t\t\t    unsigned int pages_per_huge_page)\n{\n\tint i;\n\tstruct page *dst_base = dst;\n\tstruct page *src_base = src;\n\n\tfor (i = 0; i < pages_per_huge_page; ) {\n\t\tcond_resched();\n\t\tcopy_user_highpage(dst, src, addr + i*PAGE_SIZE, vma);\n\n\t\ti++;\n\t\tdst = mem_map_next(dst, dst_base, i);\n\t\tsrc = mem_map_next(src, src_base, i);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void copy_user_gigantic_page(struct page *dst, struct page *src,\n\t\t\t\t    unsigned long addr,\n\t\t\t\t    struct vm_area_struct *vma,\n\t\t\t\t    unsigned int pages_per_huge_page)\n{\n\tint i;\n\tstruct page *dst_base = dst;\n\tstruct page *src_base = src;\n\n\tfor (i = 0; i < pages_per_huge_page; ) {\n\t\tcond_resched();\n\t\tcopy_user_highpage(dst, src, addr + i*PAGE_SIZE, vma);\n\n\t\ti++;\n\t\tdst = mem_map_next(dst, dst_base, i);\n\t\tsrc = mem_map_next(src, src_base, i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pages_per_huge_page > MAX_ORDER_NR_PAGES"
          ],
          "line": 4499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid copy_user_huge_page(struct page *dst, struct page *src,\n\t\t\t unsigned long addr_hint, struct vm_area_struct *vma,\n\t\t\t unsigned int pages_per_huge_page)\n{\n\tunsigned long addr = addr_hint &\n\t\t~(((unsigned long)pages_per_huge_page << PAGE_SHIFT) - 1);\n\tstruct copy_subpage_arg arg = {\n\t\t.dst = dst,\n\t\t.src = src,\n\t\t.vma = vma,\n\t};\n\n\tif (unlikely(pages_per_huge_page > MAX_ORDER_NR_PAGES)) {\n\t\tcopy_user_gigantic_page(dst, src, addr, vma,\n\t\t\t\t\tpages_per_huge_page);\n\t\treturn;\n\t}\n\n\tprocess_huge_page(addr_hint, pages_per_huge_page, copy_subpage, &arg);\n}"
  },
  {
    "function_name": "copy_subpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "4479-4485",
    "snippet": "static void copy_subpage(unsigned long addr, int idx, void *arg)\n{\n\tstruct copy_subpage_arg *copy_arg = arg;\n\n\tcopy_user_highpage(copy_arg->dst + idx, copy_arg->src + idx,\n\t\t\t   addr, copy_arg->vma);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_user_highpage",
          "args": [
            "copy_arg->dst + idx",
            "copy_arg->src + idx",
            "addr",
            "copy_arg->vma"
          ],
          "line": 4483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void copy_subpage(unsigned long addr, int idx, void *arg)\n{\n\tstruct copy_subpage_arg *copy_arg = arg;\n\n\tcopy_user_highpage(copy_arg->dst + idx, copy_arg->src + idx,\n\t\t\t   addr, copy_arg->vma);\n}"
  },
  {
    "function_name": "copy_user_gigantic_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "4454-4471",
    "snippet": "static void copy_user_gigantic_page(struct page *dst, struct page *src,\n\t\t\t\t    unsigned long addr,\n\t\t\t\t    struct vm_area_struct *vma,\n\t\t\t\t    unsigned int pages_per_huge_page)\n{\n\tint i;\n\tstruct page *dst_base = dst;\n\tstruct page *src_base = src;\n\n\tfor (i = 0; i < pages_per_huge_page; ) {\n\t\tcond_resched();\n\t\tcopy_user_highpage(dst, src, addr + i*PAGE_SIZE, vma);\n\n\t\ti++;\n\t\tdst = mem_map_next(dst, dst_base, i);\n\t\tsrc = mem_map_next(src, src_base, i);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_map_next",
          "args": [
            "src",
            "src_base",
            "i"
          ],
          "line": 4469
        },
        "resolved": true,
        "details": {
          "function_name": "mem_map_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "380-390",
          "snippet": "static inline struct page *mem_map_next(struct page *iter,\n\t\t\t\t\t\tstruct page *base, int offset)\n{\n\tif (unlikely((offset & (MAX_ORDER_NR_PAGES - 1)) == 0)) {\n\t\tunsigned long pfn = page_to_pfn(base) + offset;\n\t\tif (!pfn_valid(pfn))\n\t\t\treturn NULL;\n\t\treturn pfn_to_page(pfn);\n\t}\n\treturn iter + 1;\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline struct page *mem_map_next(struct page *iter,\n\t\t\t\t\t\tstruct page *base, int offset)\n{\n\tif (unlikely((offset & (MAX_ORDER_NR_PAGES - 1)) == 0)) {\n\t\tunsigned long pfn = page_to_pfn(base) + offset;\n\t\tif (!pfn_valid(pfn))\n\t\t\treturn NULL;\n\t\treturn pfn_to_page(pfn);\n\t}\n\treturn iter + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_user_highpage",
          "args": [
            "dst",
            "src",
            "addr + i*PAGE_SIZE",
            "vma"
          ],
          "line": 4465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 4464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void copy_user_gigantic_page(struct page *dst, struct page *src,\n\t\t\t\t    unsigned long addr,\n\t\t\t\t    struct vm_area_struct *vma,\n\t\t\t\t    unsigned int pages_per_huge_page)\n{\n\tint i;\n\tstruct page *dst_base = dst;\n\tstruct page *src_base = src;\n\n\tfor (i = 0; i < pages_per_huge_page; ) {\n\t\tcond_resched();\n\t\tcopy_user_highpage(dst, src, addr + i*PAGE_SIZE, vma);\n\n\t\ti++;\n\t\tdst = mem_map_next(dst, dst_base, i);\n\t\tsrc = mem_map_next(src, src_base, i);\n\t}\n}"
  },
  {
    "function_name": "clear_huge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "4440-4452",
    "snippet": "void clear_huge_page(struct page *page,\n\t\t     unsigned long addr_hint, unsigned int pages_per_huge_page)\n{\n\tunsigned long addr = addr_hint &\n\t\t~(((unsigned long)pages_per_huge_page << PAGE_SHIFT) - 1);\n\n\tif (unlikely(pages_per_huge_page > MAX_ORDER_NR_PAGES)) {\n\t\tclear_gigantic_page(page, addr, pages_per_huge_page);\n\t\treturn;\n\t}\n\n\tprocess_huge_page(addr_hint, pages_per_huge_page, clear_subpage, page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_huge_page",
          "args": [
            "addr_hint",
            "pages_per_huge_page",
            "clear_subpage",
            "page"
          ],
          "line": 4451
        },
        "resolved": true,
        "details": {
          "function_name": "process_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "4372-4416",
          "snippet": "static inline void process_huge_page(\n\tunsigned long addr_hint, unsigned int pages_per_huge_page,\n\tvoid (*process_subpage)(unsigned long addr, int idx, void *arg),\n\tvoid *arg)\n{\n\tint i, n, base, l;\n\tunsigned long addr = addr_hint &\n\t\t~(((unsigned long)pages_per_huge_page << PAGE_SHIFT) - 1);\n\n\t/* Process target subpage last to keep its cache lines hot */\n\tmight_sleep();\n\tn = (addr_hint - addr) / PAGE_SIZE;\n\tif (2 * n <= pages_per_huge_page) {\n\t\t/* If target subpage in first half of huge page */\n\t\tbase = 0;\n\t\tl = n;\n\t\t/* Process subpages at the end of huge page */\n\t\tfor (i = pages_per_huge_page - 1; i >= 2 * n; i--) {\n\t\t\tcond_resched();\n\t\t\tprocess_subpage(addr + i * PAGE_SIZE, i, arg);\n\t\t}\n\t} else {\n\t\t/* If target subpage in second half of huge page */\n\t\tbase = pages_per_huge_page - 2 * (pages_per_huge_page - n);\n\t\tl = pages_per_huge_page - n;\n\t\t/* Process subpages at the begin of huge page */\n\t\tfor (i = 0; i < base; i++) {\n\t\t\tcond_resched();\n\t\t\tprocess_subpage(addr + i * PAGE_SIZE, i, arg);\n\t\t}\n\t}\n\t/*\n\t * Process remaining subpages in left-right-left-right pattern\n\t * towards the target subpage\n\t */\n\tfor (i = 0; i < l; i++) {\n\t\tint left_idx = base + i;\n\t\tint right_idx = base + 2 * l - 1 - i;\n\n\t\tcond_resched();\n\t\tprocess_subpage(addr + left_idx * PAGE_SIZE, left_idx, arg);\n\t\tcond_resched();\n\t\tprocess_subpage(addr + right_idx * PAGE_SIZE, right_idx, arg);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void process_huge_page(\n\tunsigned long addr_hint, unsigned int pages_per_huge_page,\n\tvoid (*process_subpage)(unsigned long addr, int idx, void *arg),\n\tvoid *arg)\n{\n\tint i, n, base, l;\n\tunsigned long addr = addr_hint &\n\t\t~(((unsigned long)pages_per_huge_page << PAGE_SHIFT) - 1);\n\n\t/* Process target subpage last to keep its cache lines hot */\n\tmight_sleep();\n\tn = (addr_hint - addr) / PAGE_SIZE;\n\tif (2 * n <= pages_per_huge_page) {\n\t\t/* If target subpage in first half of huge page */\n\t\tbase = 0;\n\t\tl = n;\n\t\t/* Process subpages at the end of huge page */\n\t\tfor (i = pages_per_huge_page - 1; i >= 2 * n; i--) {\n\t\t\tcond_resched();\n\t\t\tprocess_subpage(addr + i * PAGE_SIZE, i, arg);\n\t\t}\n\t} else {\n\t\t/* If target subpage in second half of huge page */\n\t\tbase = pages_per_huge_page - 2 * (pages_per_huge_page - n);\n\t\tl = pages_per_huge_page - n;\n\t\t/* Process subpages at the begin of huge page */\n\t\tfor (i = 0; i < base; i++) {\n\t\t\tcond_resched();\n\t\t\tprocess_subpage(addr + i * PAGE_SIZE, i, arg);\n\t\t}\n\t}\n\t/*\n\t * Process remaining subpages in left-right-left-right pattern\n\t * towards the target subpage\n\t */\n\tfor (i = 0; i < l; i++) {\n\t\tint left_idx = base + i;\n\t\tint right_idx = base + 2 * l - 1 - i;\n\n\t\tcond_resched();\n\t\tprocess_subpage(addr + left_idx * PAGE_SIZE, left_idx, arg);\n\t\tcond_resched();\n\t\tprocess_subpage(addr + right_idx * PAGE_SIZE, right_idx, arg);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_gigantic_page",
          "args": [
            "page",
            "addr",
            "pages_per_huge_page"
          ],
          "line": 4447
        },
        "resolved": true,
        "details": {
          "function_name": "clear_gigantic_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "4418-4431",
          "snippet": "static void clear_gigantic_page(struct page *page,\n\t\t\t\tunsigned long addr,\n\t\t\t\tunsigned int pages_per_huge_page)\n{\n\tint i;\n\tstruct page *p = page;\n\n\tmight_sleep();\n\tfor (i = 0; i < pages_per_huge_page;\n\t     i++, p = mem_map_next(p, page, i)) {\n\t\tcond_resched();\n\t\tclear_user_highpage(p, addr + i * PAGE_SIZE);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void clear_gigantic_page(struct page *page,\n\t\t\t\tunsigned long addr,\n\t\t\t\tunsigned int pages_per_huge_page)\n{\n\tint i;\n\tstruct page *p = page;\n\n\tmight_sleep();\n\tfor (i = 0; i < pages_per_huge_page;\n\t     i++, p = mem_map_next(p, page, i)) {\n\t\tcond_resched();\n\t\tclear_user_highpage(p, addr + i * PAGE_SIZE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pages_per_huge_page > MAX_ORDER_NR_PAGES"
          ],
          "line": 4446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid clear_huge_page(struct page *page,\n\t\t     unsigned long addr_hint, unsigned int pages_per_huge_page)\n{\n\tunsigned long addr = addr_hint &\n\t\t~(((unsigned long)pages_per_huge_page << PAGE_SHIFT) - 1);\n\n\tif (unlikely(pages_per_huge_page > MAX_ORDER_NR_PAGES)) {\n\t\tclear_gigantic_page(page, addr, pages_per_huge_page);\n\t\treturn;\n\t}\n\n\tprocess_huge_page(addr_hint, pages_per_huge_page, clear_subpage, page);\n}"
  },
  {
    "function_name": "clear_subpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "4433-4438",
    "snippet": "static void clear_subpage(unsigned long addr, int idx, void *arg)\n{\n\tstruct page *page = arg;\n\n\tclear_user_highpage(page + idx, addr);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_user_highpage",
          "args": [
            "page + idx",
            "addr"
          ],
          "line": 4437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void clear_subpage(unsigned long addr, int idx, void *arg)\n{\n\tstruct page *page = arg;\n\n\tclear_user_highpage(page + idx, addr);\n}"
  },
  {
    "function_name": "clear_gigantic_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "4418-4431",
    "snippet": "static void clear_gigantic_page(struct page *page,\n\t\t\t\tunsigned long addr,\n\t\t\t\tunsigned int pages_per_huge_page)\n{\n\tint i;\n\tstruct page *p = page;\n\n\tmight_sleep();\n\tfor (i = 0; i < pages_per_huge_page;\n\t     i++, p = mem_map_next(p, page, i)) {\n\t\tcond_resched();\n\t\tclear_user_highpage(p, addr + i * PAGE_SIZE);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_user_highpage",
          "args": [
            "p",
            "addr + i * PAGE_SIZE"
          ],
          "line": 4429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 4428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_map_next",
          "args": [
            "p",
            "page",
            "i"
          ],
          "line": 4427
        },
        "resolved": true,
        "details": {
          "function_name": "mem_map_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "380-390",
          "snippet": "static inline struct page *mem_map_next(struct page *iter,\n\t\t\t\t\t\tstruct page *base, int offset)\n{\n\tif (unlikely((offset & (MAX_ORDER_NR_PAGES - 1)) == 0)) {\n\t\tunsigned long pfn = page_to_pfn(base) + offset;\n\t\tif (!pfn_valid(pfn))\n\t\t\treturn NULL;\n\t\treturn pfn_to_page(pfn);\n\t}\n\treturn iter + 1;\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline struct page *mem_map_next(struct page *iter,\n\t\t\t\t\t\tstruct page *base, int offset)\n{\n\tif (unlikely((offset & (MAX_ORDER_NR_PAGES - 1)) == 0)) {\n\t\tunsigned long pfn = page_to_pfn(base) + offset;\n\t\tif (!pfn_valid(pfn))\n\t\t\treturn NULL;\n\t\treturn pfn_to_page(pfn);\n\t}\n\treturn iter + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 4425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void clear_gigantic_page(struct page *page,\n\t\t\t\tunsigned long addr,\n\t\t\t\tunsigned int pages_per_huge_page)\n{\n\tint i;\n\tstruct page *p = page;\n\n\tmight_sleep();\n\tfor (i = 0; i < pages_per_huge_page;\n\t     i++, p = mem_map_next(p, page, i)) {\n\t\tcond_resched();\n\t\tclear_user_highpage(p, addr + i * PAGE_SIZE);\n\t}\n}"
  },
  {
    "function_name": "process_huge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "4372-4416",
    "snippet": "static inline void process_huge_page(\n\tunsigned long addr_hint, unsigned int pages_per_huge_page,\n\tvoid (*process_subpage)(unsigned long addr, int idx, void *arg),\n\tvoid *arg)\n{\n\tint i, n, base, l;\n\tunsigned long addr = addr_hint &\n\t\t~(((unsigned long)pages_per_huge_page << PAGE_SHIFT) - 1);\n\n\t/* Process target subpage last to keep its cache lines hot */\n\tmight_sleep();\n\tn = (addr_hint - addr) / PAGE_SIZE;\n\tif (2 * n <= pages_per_huge_page) {\n\t\t/* If target subpage in first half of huge page */\n\t\tbase = 0;\n\t\tl = n;\n\t\t/* Process subpages at the end of huge page */\n\t\tfor (i = pages_per_huge_page - 1; i >= 2 * n; i--) {\n\t\t\tcond_resched();\n\t\t\tprocess_subpage(addr + i * PAGE_SIZE, i, arg);\n\t\t}\n\t} else {\n\t\t/* If target subpage in second half of huge page */\n\t\tbase = pages_per_huge_page - 2 * (pages_per_huge_page - n);\n\t\tl = pages_per_huge_page - n;\n\t\t/* Process subpages at the begin of huge page */\n\t\tfor (i = 0; i < base; i++) {\n\t\t\tcond_resched();\n\t\t\tprocess_subpage(addr + i * PAGE_SIZE, i, arg);\n\t\t}\n\t}\n\t/*\n\t * Process remaining subpages in left-right-left-right pattern\n\t * towards the target subpage\n\t */\n\tfor (i = 0; i < l; i++) {\n\t\tint left_idx = base + i;\n\t\tint right_idx = base + 2 * l - 1 - i;\n\n\t\tcond_resched();\n\t\tprocess_subpage(addr + left_idx * PAGE_SIZE, left_idx, arg);\n\t\tcond_resched();\n\t\tprocess_subpage(addr + right_idx * PAGE_SIZE, right_idx, arg);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_subpage",
          "args": [
            "addr + right_idx * PAGE_SIZE",
            "right_idx",
            "arg"
          ],
          "line": 4414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 4413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_subpage",
          "args": [
            "addr + left_idx * PAGE_SIZE",
            "left_idx",
            "arg"
          ],
          "line": 4412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 4411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_subpage",
          "args": [
            "addr + i * PAGE_SIZE",
            "i",
            "arg"
          ],
          "line": 4400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 4399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_subpage",
          "args": [
            "addr + i * PAGE_SIZE",
            "i",
            "arg"
          ],
          "line": 4391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 4390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 4382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void process_huge_page(\n\tunsigned long addr_hint, unsigned int pages_per_huge_page,\n\tvoid (*process_subpage)(unsigned long addr, int idx, void *arg),\n\tvoid *arg)\n{\n\tint i, n, base, l;\n\tunsigned long addr = addr_hint &\n\t\t~(((unsigned long)pages_per_huge_page << PAGE_SHIFT) - 1);\n\n\t/* Process target subpage last to keep its cache lines hot */\n\tmight_sleep();\n\tn = (addr_hint - addr) / PAGE_SIZE;\n\tif (2 * n <= pages_per_huge_page) {\n\t\t/* If target subpage in first half of huge page */\n\t\tbase = 0;\n\t\tl = n;\n\t\t/* Process subpages at the end of huge page */\n\t\tfor (i = pages_per_huge_page - 1; i >= 2 * n; i--) {\n\t\t\tcond_resched();\n\t\t\tprocess_subpage(addr + i * PAGE_SIZE, i, arg);\n\t\t}\n\t} else {\n\t\t/* If target subpage in second half of huge page */\n\t\tbase = pages_per_huge_page - 2 * (pages_per_huge_page - n);\n\t\tl = pages_per_huge_page - n;\n\t\t/* Process subpages at the begin of huge page */\n\t\tfor (i = 0; i < base; i++) {\n\t\t\tcond_resched();\n\t\t\tprocess_subpage(addr + i * PAGE_SIZE, i, arg);\n\t\t}\n\t}\n\t/*\n\t * Process remaining subpages in left-right-left-right pattern\n\t * towards the target subpage\n\t */\n\tfor (i = 0; i < l; i++) {\n\t\tint left_idx = base + i;\n\t\tint right_idx = base + 2 * l - 1 - i;\n\n\t\tcond_resched();\n\t\tprocess_subpage(addr + left_idx * PAGE_SIZE, left_idx, arg);\n\t\tcond_resched();\n\t\tprocess_subpage(addr + right_idx * PAGE_SIZE, right_idx, arg);\n\t}\n}"
  },
  {
    "function_name": "__might_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "4345-4362",
    "snippet": "void __might_fault(const char *file, int line)\n{\n\t/*\n\t * Some code (nfs/sunrpc) uses socket ops on kernel memory while\n\t * holding the mmap_sem, this is safe because kernel memory doesn't\n\t * get paged out, therefore we'll never actually fault, and the\n\t * below annotations will generate false positives.\n\t */\n\tif (uaccess_kernel())\n\t\treturn;\n\tif (pagefault_disabled())\n\t\treturn;\n\t__might_sleep(file, line, 0);\n#if defined(CONFIG_DEBUG_ATOMIC_SLEEP)\n\tif (current->mm)\n\t\tmight_lock_read(&current->mm->mmap_sem);\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "might_lock_read",
          "args": [
            "&current->mm->mmap_sem"
          ],
          "line": 4360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__might_sleep",
          "args": [
            "file",
            "line",
            "0"
          ],
          "line": 4357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagefault_disabled",
          "args": [],
          "line": 4355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uaccess_kernel",
          "args": [],
          "line": 4353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid __might_fault(const char *file, int line)\n{\n\t/*\n\t * Some code (nfs/sunrpc) uses socket ops on kernel memory while\n\t * holding the mmap_sem, this is safe because kernel memory doesn't\n\t * get paged out, therefore we'll never actually fault, and the\n\t * below annotations will generate false positives.\n\t */\n\tif (uaccess_kernel())\n\t\treturn;\n\tif (pagefault_disabled())\n\t\treturn;\n\t__might_sleep(file, line, 0);\n#if defined(CONFIG_DEBUG_ATOMIC_SLEEP)\n\tif (current->mm)\n\t\tmight_lock_read(&current->mm->mmap_sem);\n#endif\n}"
  },
  {
    "function_name": "print_vma_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "4314-4342",
    "snippet": "void print_vma_addr(char *prefix, unsigned long ip)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * we might be running from an atomic context so we cannot sleep\n\t */\n\tif (!down_read_trylock(&mm->mmap_sem))\n\t\treturn;\n\n\tvma = find_vma(mm, ip);\n\tif (vma && vma->vm_file) {\n\t\tstruct file *f = vma->vm_file;\n\t\tchar *buf = (char *)__get_free_page(GFP_NOWAIT);\n\t\tif (buf) {\n\t\t\tchar *p;\n\n\t\t\tp = file_path(f, buf, PAGE_SIZE);\n\t\t\tif (IS_ERR(p))\n\t\t\t\tp = \"?\";\n\t\t\tprintk(\"%s%s[%lx+%lx]\", prefix, kbasename(p),\n\t\t\t\t\tvma->vm_start,\n\t\t\t\t\tvma->vm_end - vma->vm_start);\n\t\t\tfree_page((unsigned long)buf);\n\t\t}\n\t}\n\tup_read(&mm->mmap_sem);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 4341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)buf"
          ],
          "line": 4338
        },
        "resolved": true,
        "details": {
          "function_name": "soft_offline_free_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "1857-1871",
          "snippet": "static int soft_offline_free_page(struct page *page)\n{\n\tint rc = 0;\n\tstruct page *head = compound_head(page);\n\n\tif (PageHuge(head))\n\t\trc = dissolve_free_huge_page(page);\n\tif (!rc) {\n\t\tif (set_hwpoison_free_buddy_page(page))\n\t\t\tnum_poisoned_pages_inc();\n\t\telse\n\t\t\trc = -EBUSY;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define head\t\t(1UL << PG_head)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define head\t\t(1UL << PG_head)\n\nstatic int soft_offline_free_page(struct page *page)\n{\n\tint rc = 0;\n\tstruct page *head = compound_head(page);\n\n\tif (PageHuge(head))\n\t\trc = dissolve_free_huge_page(page);\n\tif (!rc) {\n\t\tif (set_hwpoison_free_buddy_page(page))\n\t\t\tnum_poisoned_pages_inc();\n\t\telse\n\t\t\trc = -EBUSY;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%s%s[%lx+%lx]\"",
            "prefix",
            "kbasename(p)",
            "vma->vm_start",
            "vma->vm_end - vma->vm_start"
          ],
          "line": 4335
        },
        "resolved": true,
        "details": {
          "function_name": "mminit_dprintk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "417-420",
          "snippet": "static inline void mminit_dprintk(enum mminit_level level,\n\t\t\t\tconst char *prefix, const char *fmt, ...)\n{\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mminit_dprintk(enum mminit_level level,\n\t\t\t\tconst char *prefix, const char *fmt, ...)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbasename",
          "args": [
            "p"
          ],
          "line": 4335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "p"
          ],
          "line": 4333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_path",
          "args": [
            "f",
            "buf",
            "PAGE_SIZE"
          ],
          "line": 4332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_NOWAIT"
          ],
          "line": 4328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "mm",
            "ip"
          ],
          "line": 4325
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "775-796",
          "snippet": "struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read_trylock",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 4322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid print_vma_addr(char *prefix, unsigned long ip)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * we might be running from an atomic context so we cannot sleep\n\t */\n\tif (!down_read_trylock(&mm->mmap_sem))\n\t\treturn;\n\n\tvma = find_vma(mm, ip);\n\tif (vma && vma->vm_file) {\n\t\tstruct file *f = vma->vm_file;\n\t\tchar *buf = (char *)__get_free_page(GFP_NOWAIT);\n\t\tif (buf) {\n\t\t\tchar *p;\n\n\t\t\tp = file_path(f, buf, PAGE_SIZE);\n\t\t\tif (IS_ERR(p))\n\t\t\t\tp = \"?\";\n\t\t\tprintk(\"%s%s[%lx+%lx]\", prefix, kbasename(p),\n\t\t\t\t\tvma->vm_start,\n\t\t\t\t\tvma->vm_end - vma->vm_start);\n\t\t\tfree_page((unsigned long)buf);\n\t\t}\n\t}\n\tup_read(&mm->mmap_sem);\n}"
  },
  {
    "function_name": "access_process_vm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "4293-4308",
    "snippet": "int access_process_vm(struct task_struct *tsk, unsigned long addr,\n\t\tvoid *buf, int len, unsigned int gup_flags)\n{\n\tstruct mm_struct *mm;\n\tint ret;\n\n\tmm = get_task_mm(tsk);\n\tif (!mm)\n\t\treturn 0;\n\n\tret = __access_remote_vm(tsk, mm, addr, buf, len, gup_flags);\n\n\tmmput(mm);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 4305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__access_remote_vm",
          "args": [
            "tsk",
            "mm",
            "addr",
            "buf",
            "len",
            "gup_flags"
          ],
          "line": 4303
        },
        "resolved": true,
        "details": {
          "function_name": "__access_remote_vm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "4211-4270",
          "snippet": "int __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long addr, void *buf, int len, unsigned int gup_flags)\n{\n\tstruct vm_area_struct *vma;\n\tvoid *old_buf = buf;\n\tint write = gup_flags & FOLL_WRITE;\n\n\tdown_read(&mm->mmap_sem);\n\t/* ignore errors, just check how much was successfully transferred */\n\twhile (len) {\n\t\tint bytes, ret, offset;\n\t\tvoid *maddr;\n\t\tstruct page *page = NULL;\n\n\t\tret = get_user_pages_remote(tsk, mm, addr, 1,\n\t\t\t\tgup_flags, &page, &vma, NULL);\n\t\tif (ret <= 0) {\n#ifndef CONFIG_HAVE_IOREMAP_PROT\n\t\t\tbreak;\n#else\n\t\t\t/*\n\t\t\t * Check if this is a VM_IO | VM_PFNMAP VMA, which\n\t\t\t * we can access using slightly different code.\n\t\t\t */\n\t\t\tvma = find_vma(mm, addr);\n\t\t\tif (!vma || vma->vm_start > addr)\n\t\t\t\tbreak;\n\t\t\tif (vma->vm_ops && vma->vm_ops->access)\n\t\t\t\tret = vma->vm_ops->access(vma, addr, buf,\n\t\t\t\t\t\t\t  len, write);\n\t\t\tif (ret <= 0)\n\t\t\t\tbreak;\n\t\t\tbytes = ret;\n#endif\n\t\t} else {\n\t\t\tbytes = len;\n\t\t\toffset = addr & (PAGE_SIZE-1);\n\t\t\tif (bytes > PAGE_SIZE-offset)\n\t\t\t\tbytes = PAGE_SIZE-offset;\n\n\t\t\tmaddr = kmap(page);\n\t\t\tif (write) {\n\t\t\t\tcopy_to_user_page(vma, page, addr,\n\t\t\t\t\t\t  maddr + offset, buf, bytes);\n\t\t\t\tset_page_dirty_lock(page);\n\t\t\t} else {\n\t\t\t\tcopy_from_user_page(vma, page, addr,\n\t\t\t\t\t\t    buf, maddr + offset, bytes);\n\t\t\t}\n\t\t\tkunmap(page);\n\t\t\tput_page(page);\n\t\t}\n\t\tlen -= bytes;\n\t\tbuf += bytes;\n\t\taddr += bytes;\n\t}\n\tup_read(&mm->mmap_sem);\n\n\treturn buf - old_buf;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long addr, void *buf, int len, unsigned int gup_flags)\n{\n\tstruct vm_area_struct *vma;\n\tvoid *old_buf = buf;\n\tint write = gup_flags & FOLL_WRITE;\n\n\tdown_read(&mm->mmap_sem);\n\t/* ignore errors, just check how much was successfully transferred */\n\twhile (len) {\n\t\tint bytes, ret, offset;\n\t\tvoid *maddr;\n\t\tstruct page *page = NULL;\n\n\t\tret = get_user_pages_remote(tsk, mm, addr, 1,\n\t\t\t\tgup_flags, &page, &vma, NULL);\n\t\tif (ret <= 0) {\n#ifndef CONFIG_HAVE_IOREMAP_PROT\n\t\t\tbreak;\n#else\n\t\t\t/*\n\t\t\t * Check if this is a VM_IO | VM_PFNMAP VMA, which\n\t\t\t * we can access using slightly different code.\n\t\t\t */\n\t\t\tvma = find_vma(mm, addr);\n\t\t\tif (!vma || vma->vm_start > addr)\n\t\t\t\tbreak;\n\t\t\tif (vma->vm_ops && vma->vm_ops->access)\n\t\t\t\tret = vma->vm_ops->access(vma, addr, buf,\n\t\t\t\t\t\t\t  len, write);\n\t\t\tif (ret <= 0)\n\t\t\t\tbreak;\n\t\t\tbytes = ret;\n#endif\n\t\t} else {\n\t\t\tbytes = len;\n\t\t\toffset = addr & (PAGE_SIZE-1);\n\t\t\tif (bytes > PAGE_SIZE-offset)\n\t\t\t\tbytes = PAGE_SIZE-offset;\n\n\t\t\tmaddr = kmap(page);\n\t\t\tif (write) {\n\t\t\t\tcopy_to_user_page(vma, page, addr,\n\t\t\t\t\t\t  maddr + offset, buf, bytes);\n\t\t\t\tset_page_dirty_lock(page);\n\t\t\t} else {\n\t\t\t\tcopy_from_user_page(vma, page, addr,\n\t\t\t\t\t\t    buf, maddr + offset, bytes);\n\t\t\t}\n\t\t\tkunmap(page);\n\t\t\tput_page(page);\n\t\t}\n\t\tlen -= bytes;\n\t\tbuf += bytes;\n\t\taddr += bytes;\n\t}\n\tup_read(&mm->mmap_sem);\n\n\treturn buf - old_buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_mm",
          "args": [
            "tsk"
          ],
          "line": 4299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint access_process_vm(struct task_struct *tsk, unsigned long addr,\n\t\tvoid *buf, int len, unsigned int gup_flags)\n{\n\tstruct mm_struct *mm;\n\tint ret;\n\n\tmm = get_task_mm(tsk);\n\tif (!mm)\n\t\treturn 0;\n\n\tret = __access_remote_vm(tsk, mm, addr, buf, len, gup_flags);\n\n\tmmput(mm);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "access_remote_vm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "4282-4286",
    "snippet": "int access_remote_vm(struct mm_struct *mm, unsigned long addr,\n\t\tvoid *buf, int len, unsigned int gup_flags)\n{\n\treturn __access_remote_vm(NULL, mm, addr, buf, len, gup_flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__access_remote_vm",
          "args": [
            "NULL",
            "mm",
            "addr",
            "buf",
            "len",
            "gup_flags"
          ],
          "line": 4285
        },
        "resolved": true,
        "details": {
          "function_name": "__access_remote_vm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "4211-4270",
          "snippet": "int __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long addr, void *buf, int len, unsigned int gup_flags)\n{\n\tstruct vm_area_struct *vma;\n\tvoid *old_buf = buf;\n\tint write = gup_flags & FOLL_WRITE;\n\n\tdown_read(&mm->mmap_sem);\n\t/* ignore errors, just check how much was successfully transferred */\n\twhile (len) {\n\t\tint bytes, ret, offset;\n\t\tvoid *maddr;\n\t\tstruct page *page = NULL;\n\n\t\tret = get_user_pages_remote(tsk, mm, addr, 1,\n\t\t\t\tgup_flags, &page, &vma, NULL);\n\t\tif (ret <= 0) {\n#ifndef CONFIG_HAVE_IOREMAP_PROT\n\t\t\tbreak;\n#else\n\t\t\t/*\n\t\t\t * Check if this is a VM_IO | VM_PFNMAP VMA, which\n\t\t\t * we can access using slightly different code.\n\t\t\t */\n\t\t\tvma = find_vma(mm, addr);\n\t\t\tif (!vma || vma->vm_start > addr)\n\t\t\t\tbreak;\n\t\t\tif (vma->vm_ops && vma->vm_ops->access)\n\t\t\t\tret = vma->vm_ops->access(vma, addr, buf,\n\t\t\t\t\t\t\t  len, write);\n\t\t\tif (ret <= 0)\n\t\t\t\tbreak;\n\t\t\tbytes = ret;\n#endif\n\t\t} else {\n\t\t\tbytes = len;\n\t\t\toffset = addr & (PAGE_SIZE-1);\n\t\t\tif (bytes > PAGE_SIZE-offset)\n\t\t\t\tbytes = PAGE_SIZE-offset;\n\n\t\t\tmaddr = kmap(page);\n\t\t\tif (write) {\n\t\t\t\tcopy_to_user_page(vma, page, addr,\n\t\t\t\t\t\t  maddr + offset, buf, bytes);\n\t\t\t\tset_page_dirty_lock(page);\n\t\t\t} else {\n\t\t\t\tcopy_from_user_page(vma, page, addr,\n\t\t\t\t\t\t    buf, maddr + offset, bytes);\n\t\t\t}\n\t\t\tkunmap(page);\n\t\t\tput_page(page);\n\t\t}\n\t\tlen -= bytes;\n\t\tbuf += bytes;\n\t\taddr += bytes;\n\t}\n\tup_read(&mm->mmap_sem);\n\n\treturn buf - old_buf;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long addr, void *buf, int len, unsigned int gup_flags)\n{\n\tstruct vm_area_struct *vma;\n\tvoid *old_buf = buf;\n\tint write = gup_flags & FOLL_WRITE;\n\n\tdown_read(&mm->mmap_sem);\n\t/* ignore errors, just check how much was successfully transferred */\n\twhile (len) {\n\t\tint bytes, ret, offset;\n\t\tvoid *maddr;\n\t\tstruct page *page = NULL;\n\n\t\tret = get_user_pages_remote(tsk, mm, addr, 1,\n\t\t\t\tgup_flags, &page, &vma, NULL);\n\t\tif (ret <= 0) {\n#ifndef CONFIG_HAVE_IOREMAP_PROT\n\t\t\tbreak;\n#else\n\t\t\t/*\n\t\t\t * Check if this is a VM_IO | VM_PFNMAP VMA, which\n\t\t\t * we can access using slightly different code.\n\t\t\t */\n\t\t\tvma = find_vma(mm, addr);\n\t\t\tif (!vma || vma->vm_start > addr)\n\t\t\t\tbreak;\n\t\t\tif (vma->vm_ops && vma->vm_ops->access)\n\t\t\t\tret = vma->vm_ops->access(vma, addr, buf,\n\t\t\t\t\t\t\t  len, write);\n\t\t\tif (ret <= 0)\n\t\t\t\tbreak;\n\t\t\tbytes = ret;\n#endif\n\t\t} else {\n\t\t\tbytes = len;\n\t\t\toffset = addr & (PAGE_SIZE-1);\n\t\t\tif (bytes > PAGE_SIZE-offset)\n\t\t\t\tbytes = PAGE_SIZE-offset;\n\n\t\t\tmaddr = kmap(page);\n\t\t\tif (write) {\n\t\t\t\tcopy_to_user_page(vma, page, addr,\n\t\t\t\t\t\t  maddr + offset, buf, bytes);\n\t\t\t\tset_page_dirty_lock(page);\n\t\t\t} else {\n\t\t\t\tcopy_from_user_page(vma, page, addr,\n\t\t\t\t\t\t    buf, maddr + offset, bytes);\n\t\t\t}\n\t\t\tkunmap(page);\n\t\t\tput_page(page);\n\t\t}\n\t\tlen -= bytes;\n\t\tbuf += bytes;\n\t\taddr += bytes;\n\t}\n\tup_read(&mm->mmap_sem);\n\n\treturn buf - old_buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint access_remote_vm(struct mm_struct *mm, unsigned long addr,\n\t\tvoid *buf, int len, unsigned int gup_flags)\n{\n\treturn __access_remote_vm(NULL, mm, addr, buf, len, gup_flags);\n}"
  },
  {
    "function_name": "__access_remote_vm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "4211-4270",
    "snippet": "int __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long addr, void *buf, int len, unsigned int gup_flags)\n{\n\tstruct vm_area_struct *vma;\n\tvoid *old_buf = buf;\n\tint write = gup_flags & FOLL_WRITE;\n\n\tdown_read(&mm->mmap_sem);\n\t/* ignore errors, just check how much was successfully transferred */\n\twhile (len) {\n\t\tint bytes, ret, offset;\n\t\tvoid *maddr;\n\t\tstruct page *page = NULL;\n\n\t\tret = get_user_pages_remote(tsk, mm, addr, 1,\n\t\t\t\tgup_flags, &page, &vma, NULL);\n\t\tif (ret <= 0) {\n#ifndef CONFIG_HAVE_IOREMAP_PROT\n\t\t\tbreak;\n#else\n\t\t\t/*\n\t\t\t * Check if this is a VM_IO | VM_PFNMAP VMA, which\n\t\t\t * we can access using slightly different code.\n\t\t\t */\n\t\t\tvma = find_vma(mm, addr);\n\t\t\tif (!vma || vma->vm_start > addr)\n\t\t\t\tbreak;\n\t\t\tif (vma->vm_ops && vma->vm_ops->access)\n\t\t\t\tret = vma->vm_ops->access(vma, addr, buf,\n\t\t\t\t\t\t\t  len, write);\n\t\t\tif (ret <= 0)\n\t\t\t\tbreak;\n\t\t\tbytes = ret;\n#endif\n\t\t} else {\n\t\t\tbytes = len;\n\t\t\toffset = addr & (PAGE_SIZE-1);\n\t\t\tif (bytes > PAGE_SIZE-offset)\n\t\t\t\tbytes = PAGE_SIZE-offset;\n\n\t\t\tmaddr = kmap(page);\n\t\t\tif (write) {\n\t\t\t\tcopy_to_user_page(vma, page, addr,\n\t\t\t\t\t\t  maddr + offset, buf, bytes);\n\t\t\t\tset_page_dirty_lock(page);\n\t\t\t} else {\n\t\t\t\tcopy_from_user_page(vma, page, addr,\n\t\t\t\t\t\t    buf, maddr + offset, bytes);\n\t\t\t}\n\t\t\tkunmap(page);\n\t\t\tput_page(page);\n\t\t}\n\t\tlen -= bytes;\n\t\tbuf += bytes;\n\t\taddr += bytes;\n\t}\n\tup_read(&mm->mmap_sem);\n\n\treturn buf - old_buf;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 4267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 4261
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 4260
        },
        "resolved": true,
        "details": {
          "function_name": "kunmap_high",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "329-370",
          "snippet": "void kunmap_high(struct page *page)\n{\n\tunsigned long vaddr;\n\tunsigned long nr;\n\tunsigned long flags;\n\tint need_wakeup;\n\tunsigned int color = get_pkmap_color(page);\n\twait_queue_head_t *pkmap_map_wait;\n\n\tlock_kmap_any(flags);\n\tvaddr = (unsigned long)page_address(page);\n\tBUG_ON(!vaddr);\n\tnr = PKMAP_NR(vaddr);\n\n\t/*\n\t * A count must never go down to zero\n\t * without a TLB flush!\n\t */\n\tneed_wakeup = 0;\n\tswitch (--pkmap_count[nr]) {\n\tcase 0:\n\t\tBUG();\n\tcase 1:\n\t\t/*\n\t\t * Avoid an unnecessary wake_up() function call.\n\t\t * The common case is pkmap_count[] == 1, but\n\t\t * no waiters.\n\t\t * The tasks queued in the wait-queue are guarded\n\t\t * by both the lock in the wait-queue-head and by\n\t\t * the kmap_lock.  As the kmap_lock is held here,\n\t\t * no need for the wait-queue-head's lock.  Simply\n\t\t * test if the queue is empty.\n\t\t */\n\t\tpkmap_map_wait = get_pkmap_wait_queue_head(color);\n\t\tneed_wakeup = waitqueue_active(pkmap_map_wait);\n\t}\n\tunlock_kmap_any(flags);\n\n\t/* do wake-up, if needed, race-free outside of the spin lock */\n\tif (need_wakeup)\n\t\twake_up(pkmap_map_wait);\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define get_pkmap_color get_pkmap_color"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\n#define get_pkmap_color get_pkmap_color\n\nvoid kunmap_high(struct page *page)\n{\n\tunsigned long vaddr;\n\tunsigned long nr;\n\tunsigned long flags;\n\tint need_wakeup;\n\tunsigned int color = get_pkmap_color(page);\n\twait_queue_head_t *pkmap_map_wait;\n\n\tlock_kmap_any(flags);\n\tvaddr = (unsigned long)page_address(page);\n\tBUG_ON(!vaddr);\n\tnr = PKMAP_NR(vaddr);\n\n\t/*\n\t * A count must never go down to zero\n\t * without a TLB flush!\n\t */\n\tneed_wakeup = 0;\n\tswitch (--pkmap_count[nr]) {\n\tcase 0:\n\t\tBUG();\n\tcase 1:\n\t\t/*\n\t\t * Avoid an unnecessary wake_up() function call.\n\t\t * The common case is pkmap_count[] == 1, but\n\t\t * no waiters.\n\t\t * The tasks queued in the wait-queue are guarded\n\t\t * by both the lock in the wait-queue-head and by\n\t\t * the kmap_lock.  As the kmap_lock is held here,\n\t\t * no need for the wait-queue-head's lock.  Simply\n\t\t * test if the queue is empty.\n\t\t */\n\t\tpkmap_map_wait = get_pkmap_wait_queue_head(color);\n\t\tneed_wakeup = waitqueue_active(pkmap_map_wait);\n\t}\n\tunlock_kmap_any(flags);\n\n\t/* do wake-up, if needed, race-free outside of the spin lock */\n\tif (need_wakeup)\n\t\twake_up(pkmap_map_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user_page",
          "args": [
            "vma",
            "page",
            "addr",
            "buf",
            "maddr + offset",
            "bytes"
          ],
          "line": 4257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty_lock",
          "args": [
            "page"
          ],
          "line": 4255
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_dirty_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2573-2581",
          "snippet": "int set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user_page",
          "args": [
            "vma",
            "page",
            "addr",
            "maddr + offset",
            "buf",
            "bytes"
          ],
          "line": 4253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 4251
        },
        "resolved": true,
        "details": {
          "function_name": "kmap_high_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "307-319",
          "snippet": "void *kmap_high_get(struct page *page)\n{\n\tunsigned long vaddr, flags;\n\n\tlock_kmap_any(flags);\n\tvaddr = (unsigned long)page_address(page);\n\tif (vaddr) {\n\t\tBUG_ON(pkmap_count[PKMAP_NR(vaddr)] < 1);\n\t\tpkmap_count[PKMAP_NR(vaddr)]++;\n\t}\n\tunlock_kmap_any(flags);\n\treturn (void*) vaddr;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *kmap_high_get(struct page *page)\n{\n\tunsigned long vaddr, flags;\n\n\tlock_kmap_any(flags);\n\tvaddr = (unsigned long)page_address(page);\n\tif (vaddr) {\n\t\tBUG_ON(pkmap_count[PKMAP_NR(vaddr)] < 1);\n\t\tpkmap_count[PKMAP_NR(vaddr)]++;\n\t}\n\tunlock_kmap_any(flags);\n\treturn (void*) vaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma->vm_ops->access",
          "args": [
            "vma",
            "addr",
            "buf",
            "len",
            "write"
          ],
          "line": 4239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "mm",
            "addr"
          ],
          "line": 4235
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "775-796",
          "snippet": "struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user_pages_remote",
          "args": [
            "tsk",
            "mm",
            "addr",
            "1",
            "gup_flags",
            "&page",
            "&vma",
            "NULL"
          ],
          "line": 4225
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_pages_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1101-1109",
          "snippet": "long get_user_pages_remote(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long start, unsigned long nr_pages,\n\t\tunsigned int gup_flags, struct page **pages,\n\t\tstruct vm_area_struct **vmas, int *locked)\n{\n\treturn __get_user_pages_locked(tsk, mm, start, nr_pages, pages, vmas,\n\t\t\t\t       locked,\n\t\t\t\t       gup_flags | FOLL_TOUCH | FOLL_REMOTE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nlong get_user_pages_remote(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long start, unsigned long nr_pages,\n\t\tunsigned int gup_flags, struct page **pages,\n\t\tstruct vm_area_struct **vmas, int *locked)\n{\n\treturn __get_user_pages_locked(tsk, mm, start, nr_pages, pages, vmas,\n\t\t\t\t       locked,\n\t\t\t\t       gup_flags | FOLL_TOUCH | FOLL_REMOTE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 4218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long addr, void *buf, int len, unsigned int gup_flags)\n{\n\tstruct vm_area_struct *vma;\n\tvoid *old_buf = buf;\n\tint write = gup_flags & FOLL_WRITE;\n\n\tdown_read(&mm->mmap_sem);\n\t/* ignore errors, just check how much was successfully transferred */\n\twhile (len) {\n\t\tint bytes, ret, offset;\n\t\tvoid *maddr;\n\t\tstruct page *page = NULL;\n\n\t\tret = get_user_pages_remote(tsk, mm, addr, 1,\n\t\t\t\tgup_flags, &page, &vma, NULL);\n\t\tif (ret <= 0) {\n#ifndef CONFIG_HAVE_IOREMAP_PROT\n\t\t\tbreak;\n#else\n\t\t\t/*\n\t\t\t * Check if this is a VM_IO | VM_PFNMAP VMA, which\n\t\t\t * we can access using slightly different code.\n\t\t\t */\n\t\t\tvma = find_vma(mm, addr);\n\t\t\tif (!vma || vma->vm_start > addr)\n\t\t\t\tbreak;\n\t\t\tif (vma->vm_ops && vma->vm_ops->access)\n\t\t\t\tret = vma->vm_ops->access(vma, addr, buf,\n\t\t\t\t\t\t\t  len, write);\n\t\t\tif (ret <= 0)\n\t\t\t\tbreak;\n\t\t\tbytes = ret;\n#endif\n\t\t} else {\n\t\t\tbytes = len;\n\t\t\toffset = addr & (PAGE_SIZE-1);\n\t\t\tif (bytes > PAGE_SIZE-offset)\n\t\t\t\tbytes = PAGE_SIZE-offset;\n\n\t\t\tmaddr = kmap(page);\n\t\t\tif (write) {\n\t\t\t\tcopy_to_user_page(vma, page, addr,\n\t\t\t\t\t\t  maddr + offset, buf, bytes);\n\t\t\t\tset_page_dirty_lock(page);\n\t\t\t} else {\n\t\t\t\tcopy_from_user_page(vma, page, addr,\n\t\t\t\t\t\t    buf, maddr + offset, bytes);\n\t\t\t}\n\t\t\tkunmap(page);\n\t\t\tput_page(page);\n\t\t}\n\t\tlen -= bytes;\n\t\tbuf += bytes;\n\t\taddr += bytes;\n\t}\n\tup_read(&mm->mmap_sem);\n\n\treturn buf - old_buf;\n}"
  },
  {
    "function_name": "generic_access_phys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "4181-4203",
    "snippet": "int generic_access_phys(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tvoid *buf, int len, int write)\n{\n\tresource_size_t phys_addr;\n\tunsigned long prot = 0;\n\tvoid __iomem *maddr;\n\tint offset = addr & (PAGE_SIZE-1);\n\n\tif (follow_phys(vma, addr, write, &prot, &phys_addr))\n\t\treturn -EINVAL;\n\n\tmaddr = ioremap_prot(phys_addr, PAGE_ALIGN(len + offset), prot);\n\tif (!maddr)\n\t\treturn -ENOMEM;\n\n\tif (write)\n\t\tmemcpy_toio(maddr + offset, buf, len);\n\telse\n\t\tmemcpy_fromio(buf, maddr + offset, len);\n\tiounmap(maddr);\n\n\treturn len;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iounmap",
          "args": [
            "maddr"
          ],
          "line": 4200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy_fromio",
          "args": [
            "buf",
            "maddr + offset",
            "len"
          ],
          "line": 4199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy_toio",
          "args": [
            "maddr + offset",
            "buf",
            "len"
          ],
          "line": 4197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioremap_prot",
          "args": [
            "phys_addr",
            "PAGE_ALIGN(len + offset)",
            "prot"
          ],
          "line": 4192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "len + offset"
          ],
          "line": 4192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_phys",
          "args": [
            "vma",
            "addr",
            "write",
            "&prot",
            "&phys_addr"
          ],
          "line": 4189
        },
        "resolved": true,
        "details": {
          "function_name": "follow_phys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "4153-4179",
          "snippet": "int follow_phys(struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int flags,\n\t\tunsigned long *prot, resource_size_t *phys)\n{\n\tint ret = -EINVAL;\n\tpte_t *ptep, pte;\n\tspinlock_t *ptl;\n\n\tif (!(vma->vm_flags & (VM_IO | VM_PFNMAP)))\n\t\tgoto out;\n\n\tif (follow_pte(vma->vm_mm, address, &ptep, &ptl))\n\t\tgoto out;\n\tpte = *ptep;\n\n\tif ((flags & FOLL_WRITE) && !pte_write(pte))\n\t\tgoto unlock;\n\n\t*prot = pgprot_val(pte_pgprot(pte));\n\t*phys = (resource_size_t)pte_pfn(pte) << PAGE_SHIFT;\n\n\tret = 0;\nunlock:\n\tpte_unmap_unlock(ptep, ptl);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint follow_phys(struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int flags,\n\t\tunsigned long *prot, resource_size_t *phys)\n{\n\tint ret = -EINVAL;\n\tpte_t *ptep, pte;\n\tspinlock_t *ptl;\n\n\tif (!(vma->vm_flags & (VM_IO | VM_PFNMAP)))\n\t\tgoto out;\n\n\tif (follow_pte(vma->vm_mm, address, &ptep, &ptl))\n\t\tgoto out;\n\tpte = *ptep;\n\n\tif ((flags & FOLL_WRITE) && !pte_write(pte))\n\t\tgoto unlock;\n\n\t*prot = pgprot_val(pte_pgprot(pte));\n\t*phys = (resource_size_t)pte_pfn(pte) << PAGE_SHIFT;\n\n\tret = 0;\nunlock:\n\tpte_unmap_unlock(ptep, ptl);\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint generic_access_phys(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tvoid *buf, int len, int write)\n{\n\tresource_size_t phys_addr;\n\tunsigned long prot = 0;\n\tvoid __iomem *maddr;\n\tint offset = addr & (PAGE_SIZE-1);\n\n\tif (follow_phys(vma, addr, write, &prot, &phys_addr))\n\t\treturn -EINVAL;\n\n\tmaddr = ioremap_prot(phys_addr, PAGE_ALIGN(len + offset), prot);\n\tif (!maddr)\n\t\treturn -ENOMEM;\n\n\tif (write)\n\t\tmemcpy_toio(maddr + offset, buf, len);\n\telse\n\t\tmemcpy_fromio(buf, maddr + offset, len);\n\tiounmap(maddr);\n\n\treturn len;\n}"
  },
  {
    "function_name": "follow_phys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "4153-4179",
    "snippet": "int follow_phys(struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int flags,\n\t\tunsigned long *prot, resource_size_t *phys)\n{\n\tint ret = -EINVAL;\n\tpte_t *ptep, pte;\n\tspinlock_t *ptl;\n\n\tif (!(vma->vm_flags & (VM_IO | VM_PFNMAP)))\n\t\tgoto out;\n\n\tif (follow_pte(vma->vm_mm, address, &ptep, &ptl))\n\t\tgoto out;\n\tpte = *ptep;\n\n\tif ((flags & FOLL_WRITE) && !pte_write(pte))\n\t\tgoto unlock;\n\n\t*prot = pgprot_val(pte_pgprot(pte));\n\t*phys = (resource_size_t)pte_pfn(pte) << PAGE_SHIFT;\n\n\tret = 0;\nunlock:\n\tpte_unmap_unlock(ptep, ptl);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "ptep",
            "ptl"
          ],
          "line": 4176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "pte"
          ],
          "line": 4172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprot_val",
          "args": [
            "pte_pgprot(pte)"
          ],
          "line": 4171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pgprot",
          "args": [
            "pte"
          ],
          "line": 4171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_write",
          "args": [
            "pte"
          ],
          "line": 4168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_pte",
          "args": [
            "vma->vm_mm",
            "address",
            "&ptep",
            "&ptl"
          ],
          "line": 4164
        },
        "resolved": true,
        "details": {
          "function_name": "follow_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "4097-4107",
          "snippet": "static inline int follow_pte(struct mm_struct *mm, unsigned long address,\n\t\t\t     pte_t **ptepp, spinlock_t **ptlp)\n{\n\tint res;\n\n\t/* (void) is needed to make gcc happy */\n\t(void) __cond_lock(*ptlp,\n\t\t\t   !(res = __follow_pte_pmd(mm, address, NULL, NULL,\n\t\t\t\t\t\t    ptepp, NULL, ptlp)));\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline int follow_pte(struct mm_struct *mm, unsigned long address,\n\t\t\t     pte_t **ptepp, spinlock_t **ptlp)\n{\n\tint res;\n\n\t/* (void) is needed to make gcc happy */\n\t(void) __cond_lock(*ptlp,\n\t\t\t   !(res = __follow_pte_pmd(mm, address, NULL, NULL,\n\t\t\t\t\t\t    ptepp, NULL, ptlp)));\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint follow_phys(struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int flags,\n\t\tunsigned long *prot, resource_size_t *phys)\n{\n\tint ret = -EINVAL;\n\tpte_t *ptep, pte;\n\tspinlock_t *ptl;\n\n\tif (!(vma->vm_flags & (VM_IO | VM_PFNMAP)))\n\t\tgoto out;\n\n\tif (follow_pte(vma->vm_mm, address, &ptep, &ptl))\n\t\tgoto out;\n\tpte = *ptep;\n\n\tif ((flags & FOLL_WRITE) && !pte_write(pte))\n\t\tgoto unlock;\n\n\t*prot = pgprot_val(pte_pgprot(pte));\n\t*phys = (resource_size_t)pte_pfn(pte) << PAGE_SHIFT;\n\n\tret = 0;\nunlock:\n\tpte_unmap_unlock(ptep, ptl);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "follow_pfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "4133-4149",
    "snippet": "int follow_pfn(struct vm_area_struct *vma, unsigned long address,\n\tunsigned long *pfn)\n{\n\tint ret = -EINVAL;\n\tspinlock_t *ptl;\n\tpte_t *ptep;\n\n\tif (!(vma->vm_flags & (VM_IO | VM_PFNMAP)))\n\t\treturn ret;\n\n\tret = follow_pte(vma->vm_mm, address, &ptep, &ptl);\n\tif (ret)\n\t\treturn ret;\n\t*pfn = pte_pfn(*ptep);\n\tpte_unmap_unlock(ptep, ptl);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "ptep",
            "ptl"
          ],
          "line": 4147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "*ptep"
          ],
          "line": 4146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_pte",
          "args": [
            "vma->vm_mm",
            "address",
            "&ptep",
            "&ptl"
          ],
          "line": 4143
        },
        "resolved": true,
        "details": {
          "function_name": "follow_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "4097-4107",
          "snippet": "static inline int follow_pte(struct mm_struct *mm, unsigned long address,\n\t\t\t     pte_t **ptepp, spinlock_t **ptlp)\n{\n\tint res;\n\n\t/* (void) is needed to make gcc happy */\n\t(void) __cond_lock(*ptlp,\n\t\t\t   !(res = __follow_pte_pmd(mm, address, NULL, NULL,\n\t\t\t\t\t\t    ptepp, NULL, ptlp)));\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline int follow_pte(struct mm_struct *mm, unsigned long address,\n\t\t\t     pte_t **ptepp, spinlock_t **ptlp)\n{\n\tint res;\n\n\t/* (void) is needed to make gcc happy */\n\t(void) __cond_lock(*ptlp,\n\t\t\t   !(res = __follow_pte_pmd(mm, address, NULL, NULL,\n\t\t\t\t\t\t    ptepp, NULL, ptlp)));\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint follow_pfn(struct vm_area_struct *vma, unsigned long address,\n\tunsigned long *pfn)\n{\n\tint ret = -EINVAL;\n\tspinlock_t *ptl;\n\tpte_t *ptep;\n\n\tif (!(vma->vm_flags & (VM_IO | VM_PFNMAP)))\n\t\treturn ret;\n\n\tret = follow_pte(vma->vm_mm, address, &ptep, &ptl);\n\tif (ret)\n\t\treturn ret;\n\t*pfn = pte_pfn(*ptep);\n\tpte_unmap_unlock(ptep, ptl);\n\treturn 0;\n}"
  },
  {
    "function_name": "follow_pte_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "4109-4120",
    "snippet": "int follow_pte_pmd(struct mm_struct *mm, unsigned long address,\n\t\t\t     unsigned long *start, unsigned long *end,\n\t\t\t     pte_t **ptepp, pmd_t **pmdpp, spinlock_t **ptlp)\n{\n\tint res;\n\n\t/* (void) is needed to make gcc happy */\n\t(void) __cond_lock(*ptlp,\n\t\t\t   !(res = __follow_pte_pmd(mm, address, start, end,\n\t\t\t\t\t\t    ptepp, pmdpp, ptlp)));\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cond_lock",
          "args": [
            "*ptlp",
            "!(res = __follow_pte_pmd(mm, address, start, end,\n\t\t\t\t\t\t    ptepp, pmdpp, ptlp))"
          ],
          "line": 4116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__follow_pte_pmd",
          "args": [
            "mm",
            "address",
            "start",
            "end",
            "ptepp",
            "pmdpp",
            "ptlp"
          ],
          "line": 4117
        },
        "resolved": true,
        "details": {
          "function_name": "__follow_pte_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "4032-4095",
          "snippet": "static int __follow_pte_pmd(struct mm_struct *mm, unsigned long address,\n\t\t\t    unsigned long *start, unsigned long *end,\n\t\t\t    pte_t **ptepp, pmd_t **pmdpp, spinlock_t **ptlp)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *ptep;\n\n\tpgd = pgd_offset(mm, address);\n\tif (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))\n\t\tgoto out;\n\n\tp4d = p4d_offset(pgd, address);\n\tif (p4d_none(*p4d) || unlikely(p4d_bad(*p4d)))\n\t\tgoto out;\n\n\tpud = pud_offset(p4d, address);\n\tif (pud_none(*pud) || unlikely(pud_bad(*pud)))\n\t\tgoto out;\n\n\tpmd = pmd_offset(pud, address);\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\n\tif (pmd_huge(*pmd)) {\n\t\tif (!pmdpp)\n\t\t\tgoto out;\n\n\t\tif (start && end) {\n\t\t\t*start = address & PMD_MASK;\n\t\t\t*end = *start + PMD_SIZE;\n\t\t\tmmu_notifier_invalidate_range_start(mm, *start, *end);\n\t\t}\n\t\t*ptlp = pmd_lock(mm, pmd);\n\t\tif (pmd_huge(*pmd)) {\n\t\t\t*pmdpp = pmd;\n\t\t\treturn 0;\n\t\t}\n\t\tspin_unlock(*ptlp);\n\t\tif (start && end)\n\t\t\tmmu_notifier_invalidate_range_end(mm, *start, *end);\n\t}\n\n\tif (pmd_none(*pmd) || unlikely(pmd_bad(*pmd)))\n\t\tgoto out;\n\n\tif (start && end) {\n\t\t*start = address & PAGE_MASK;\n\t\t*end = *start + PAGE_SIZE;\n\t\tmmu_notifier_invalidate_range_start(mm, *start, *end);\n\t}\n\tptep = pte_offset_map_lock(mm, pmd, address, ptlp);\n\tif (!pte_present(*ptep))\n\t\tgoto unlock;\n\t*ptepp = ptep;\n\treturn 0;\nunlock:\n\tpte_unmap_unlock(ptep, *ptlp);\n\tif (start && end)\n\t\tmmu_notifier_invalidate_range_end(mm, *start, *end);\nout:\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int __follow_pte_pmd(struct mm_struct *mm, unsigned long address,\n\t\t\t    unsigned long *start, unsigned long *end,\n\t\t\t    pte_t **ptepp, pmd_t **pmdpp, spinlock_t **ptlp)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *ptep;\n\n\tpgd = pgd_offset(mm, address);\n\tif (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))\n\t\tgoto out;\n\n\tp4d = p4d_offset(pgd, address);\n\tif (p4d_none(*p4d) || unlikely(p4d_bad(*p4d)))\n\t\tgoto out;\n\n\tpud = pud_offset(p4d, address);\n\tif (pud_none(*pud) || unlikely(pud_bad(*pud)))\n\t\tgoto out;\n\n\tpmd = pmd_offset(pud, address);\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\n\tif (pmd_huge(*pmd)) {\n\t\tif (!pmdpp)\n\t\t\tgoto out;\n\n\t\tif (start && end) {\n\t\t\t*start = address & PMD_MASK;\n\t\t\t*end = *start + PMD_SIZE;\n\t\t\tmmu_notifier_invalidate_range_start(mm, *start, *end);\n\t\t}\n\t\t*ptlp = pmd_lock(mm, pmd);\n\t\tif (pmd_huge(*pmd)) {\n\t\t\t*pmdpp = pmd;\n\t\t\treturn 0;\n\t\t}\n\t\tspin_unlock(*ptlp);\n\t\tif (start && end)\n\t\t\tmmu_notifier_invalidate_range_end(mm, *start, *end);\n\t}\n\n\tif (pmd_none(*pmd) || unlikely(pmd_bad(*pmd)))\n\t\tgoto out;\n\n\tif (start && end) {\n\t\t*start = address & PAGE_MASK;\n\t\t*end = *start + PAGE_SIZE;\n\t\tmmu_notifier_invalidate_range_start(mm, *start, *end);\n\t}\n\tptep = pte_offset_map_lock(mm, pmd, address, ptlp);\n\tif (!pte_present(*ptep))\n\t\tgoto unlock;\n\t*ptepp = ptep;\n\treturn 0;\nunlock:\n\tpte_unmap_unlock(ptep, *ptlp);\n\tif (start && end)\n\t\tmmu_notifier_invalidate_range_end(mm, *start, *end);\nout:\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint follow_pte_pmd(struct mm_struct *mm, unsigned long address,\n\t\t\t     unsigned long *start, unsigned long *end,\n\t\t\t     pte_t **ptepp, pmd_t **pmdpp, spinlock_t **ptlp)\n{\n\tint res;\n\n\t/* (void) is needed to make gcc happy */\n\t(void) __cond_lock(*ptlp,\n\t\t\t   !(res = __follow_pte_pmd(mm, address, start, end,\n\t\t\t\t\t\t    ptepp, pmdpp, ptlp)));\n\treturn res;\n}"
  },
  {
    "function_name": "follow_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "4097-4107",
    "snippet": "static inline int follow_pte(struct mm_struct *mm, unsigned long address,\n\t\t\t     pte_t **ptepp, spinlock_t **ptlp)\n{\n\tint res;\n\n\t/* (void) is needed to make gcc happy */\n\t(void) __cond_lock(*ptlp,\n\t\t\t   !(res = __follow_pte_pmd(mm, address, NULL, NULL,\n\t\t\t\t\t\t    ptepp, NULL, ptlp)));\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cond_lock",
          "args": [
            "*ptlp",
            "!(res = __follow_pte_pmd(mm, address, NULL, NULL,\n\t\t\t\t\t\t    ptepp, NULL, ptlp))"
          ],
          "line": 4103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__follow_pte_pmd",
          "args": [
            "mm",
            "address",
            "NULL",
            "NULL",
            "ptepp",
            "NULL",
            "ptlp"
          ],
          "line": 4104
        },
        "resolved": true,
        "details": {
          "function_name": "__follow_pte_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "4032-4095",
          "snippet": "static int __follow_pte_pmd(struct mm_struct *mm, unsigned long address,\n\t\t\t    unsigned long *start, unsigned long *end,\n\t\t\t    pte_t **ptepp, pmd_t **pmdpp, spinlock_t **ptlp)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *ptep;\n\n\tpgd = pgd_offset(mm, address);\n\tif (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))\n\t\tgoto out;\n\n\tp4d = p4d_offset(pgd, address);\n\tif (p4d_none(*p4d) || unlikely(p4d_bad(*p4d)))\n\t\tgoto out;\n\n\tpud = pud_offset(p4d, address);\n\tif (pud_none(*pud) || unlikely(pud_bad(*pud)))\n\t\tgoto out;\n\n\tpmd = pmd_offset(pud, address);\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\n\tif (pmd_huge(*pmd)) {\n\t\tif (!pmdpp)\n\t\t\tgoto out;\n\n\t\tif (start && end) {\n\t\t\t*start = address & PMD_MASK;\n\t\t\t*end = *start + PMD_SIZE;\n\t\t\tmmu_notifier_invalidate_range_start(mm, *start, *end);\n\t\t}\n\t\t*ptlp = pmd_lock(mm, pmd);\n\t\tif (pmd_huge(*pmd)) {\n\t\t\t*pmdpp = pmd;\n\t\t\treturn 0;\n\t\t}\n\t\tspin_unlock(*ptlp);\n\t\tif (start && end)\n\t\t\tmmu_notifier_invalidate_range_end(mm, *start, *end);\n\t}\n\n\tif (pmd_none(*pmd) || unlikely(pmd_bad(*pmd)))\n\t\tgoto out;\n\n\tif (start && end) {\n\t\t*start = address & PAGE_MASK;\n\t\t*end = *start + PAGE_SIZE;\n\t\tmmu_notifier_invalidate_range_start(mm, *start, *end);\n\t}\n\tptep = pte_offset_map_lock(mm, pmd, address, ptlp);\n\tif (!pte_present(*ptep))\n\t\tgoto unlock;\n\t*ptepp = ptep;\n\treturn 0;\nunlock:\n\tpte_unmap_unlock(ptep, *ptlp);\n\tif (start && end)\n\t\tmmu_notifier_invalidate_range_end(mm, *start, *end);\nout:\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int __follow_pte_pmd(struct mm_struct *mm, unsigned long address,\n\t\t\t    unsigned long *start, unsigned long *end,\n\t\t\t    pte_t **ptepp, pmd_t **pmdpp, spinlock_t **ptlp)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *ptep;\n\n\tpgd = pgd_offset(mm, address);\n\tif (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))\n\t\tgoto out;\n\n\tp4d = p4d_offset(pgd, address);\n\tif (p4d_none(*p4d) || unlikely(p4d_bad(*p4d)))\n\t\tgoto out;\n\n\tpud = pud_offset(p4d, address);\n\tif (pud_none(*pud) || unlikely(pud_bad(*pud)))\n\t\tgoto out;\n\n\tpmd = pmd_offset(pud, address);\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\n\tif (pmd_huge(*pmd)) {\n\t\tif (!pmdpp)\n\t\t\tgoto out;\n\n\t\tif (start && end) {\n\t\t\t*start = address & PMD_MASK;\n\t\t\t*end = *start + PMD_SIZE;\n\t\t\tmmu_notifier_invalidate_range_start(mm, *start, *end);\n\t\t}\n\t\t*ptlp = pmd_lock(mm, pmd);\n\t\tif (pmd_huge(*pmd)) {\n\t\t\t*pmdpp = pmd;\n\t\t\treturn 0;\n\t\t}\n\t\tspin_unlock(*ptlp);\n\t\tif (start && end)\n\t\t\tmmu_notifier_invalidate_range_end(mm, *start, *end);\n\t}\n\n\tif (pmd_none(*pmd) || unlikely(pmd_bad(*pmd)))\n\t\tgoto out;\n\n\tif (start && end) {\n\t\t*start = address & PAGE_MASK;\n\t\t*end = *start + PAGE_SIZE;\n\t\tmmu_notifier_invalidate_range_start(mm, *start, *end);\n\t}\n\tptep = pte_offset_map_lock(mm, pmd, address, ptlp);\n\tif (!pte_present(*ptep))\n\t\tgoto unlock;\n\t*ptepp = ptep;\n\treturn 0;\nunlock:\n\tpte_unmap_unlock(ptep, *ptlp);\n\tif (start && end)\n\t\tmmu_notifier_invalidate_range_end(mm, *start, *end);\nout:\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline int follow_pte(struct mm_struct *mm, unsigned long address,\n\t\t\t     pte_t **ptepp, spinlock_t **ptlp)\n{\n\tint res;\n\n\t/* (void) is needed to make gcc happy */\n\t(void) __cond_lock(*ptlp,\n\t\t\t   !(res = __follow_pte_pmd(mm, address, NULL, NULL,\n\t\t\t\t\t\t    ptepp, NULL, ptlp)));\n\treturn res;\n}"
  },
  {
    "function_name": "__follow_pte_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "4032-4095",
    "snippet": "static int __follow_pte_pmd(struct mm_struct *mm, unsigned long address,\n\t\t\t    unsigned long *start, unsigned long *end,\n\t\t\t    pte_t **ptepp, pmd_t **pmdpp, spinlock_t **ptlp)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *ptep;\n\n\tpgd = pgd_offset(mm, address);\n\tif (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))\n\t\tgoto out;\n\n\tp4d = p4d_offset(pgd, address);\n\tif (p4d_none(*p4d) || unlikely(p4d_bad(*p4d)))\n\t\tgoto out;\n\n\tpud = pud_offset(p4d, address);\n\tif (pud_none(*pud) || unlikely(pud_bad(*pud)))\n\t\tgoto out;\n\n\tpmd = pmd_offset(pud, address);\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\n\tif (pmd_huge(*pmd)) {\n\t\tif (!pmdpp)\n\t\t\tgoto out;\n\n\t\tif (start && end) {\n\t\t\t*start = address & PMD_MASK;\n\t\t\t*end = *start + PMD_SIZE;\n\t\t\tmmu_notifier_invalidate_range_start(mm, *start, *end);\n\t\t}\n\t\t*ptlp = pmd_lock(mm, pmd);\n\t\tif (pmd_huge(*pmd)) {\n\t\t\t*pmdpp = pmd;\n\t\t\treturn 0;\n\t\t}\n\t\tspin_unlock(*ptlp);\n\t\tif (start && end)\n\t\t\tmmu_notifier_invalidate_range_end(mm, *start, *end);\n\t}\n\n\tif (pmd_none(*pmd) || unlikely(pmd_bad(*pmd)))\n\t\tgoto out;\n\n\tif (start && end) {\n\t\t*start = address & PAGE_MASK;\n\t\t*end = *start + PAGE_SIZE;\n\t\tmmu_notifier_invalidate_range_start(mm, *start, *end);\n\t}\n\tptep = pte_offset_map_lock(mm, pmd, address, ptlp);\n\tif (!pte_present(*ptep))\n\t\tgoto unlock;\n\t*ptepp = ptep;\n\treturn 0;\nunlock:\n\tpte_unmap_unlock(ptep, *ptlp);\n\tif (start && end)\n\t\tmmu_notifier_invalidate_range_end(mm, *start, *end);\nout:\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_end",
          "args": [
            "mm",
            "*start",
            "*end"
          ],
          "line": 4092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "ptep",
            "*ptlp"
          ],
          "line": 4090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "*ptep"
          ],
          "line": 4085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "mm",
            "pmd",
            "address",
            "ptlp"
          ],
          "line": 4084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "mm",
            "*start",
            "*end"
          ],
          "line": 4082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pmd_bad(*pmd)"
          ],
          "line": 4076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_bad",
          "args": [
            "*pmd"
          ],
          "line": 4076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "*pmd"
          ],
          "line": 4076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_end",
          "args": [
            "mm",
            "*start",
            "*end"
          ],
          "line": 4073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "*ptlp"
          ],
          "line": 4071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_huge",
          "args": [
            "*pmd"
          ],
          "line": 4067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_lock",
          "args": [
            "mm",
            "pmd"
          ],
          "line": 4066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "mm",
            "*start",
            "*end"
          ],
          "line": 4064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_huge",
          "args": [
            "*pmd"
          ],
          "line": 4057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "pmd_trans_huge(*pmd)"
          ],
          "line": 4055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "*pmd"
          ],
          "line": 4055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_offset",
          "args": [
            "pud",
            "address"
          ],
          "line": 4054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pud_bad(*pud)"
          ],
          "line": 4051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_bad",
          "args": [
            "*pud"
          ],
          "line": 4051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_none",
          "args": [
            "*pud"
          ],
          "line": 4051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_offset",
          "args": [
            "p4d",
            "address"
          ],
          "line": 4050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p4d_bad(*p4d)"
          ],
          "line": 4047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_bad",
          "args": [
            "*p4d"
          ],
          "line": 4047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_none",
          "args": [
            "*p4d"
          ],
          "line": 4047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_offset",
          "args": [
            "pgd",
            "address"
          ],
          "line": 4046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pgd_bad(*pgd)"
          ],
          "line": 4043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_bad",
          "args": [
            "*pgd"
          ],
          "line": 4043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_none",
          "args": [
            "*pgd"
          ],
          "line": 4043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_offset",
          "args": [
            "mm",
            "address"
          ],
          "line": 4042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int __follow_pte_pmd(struct mm_struct *mm, unsigned long address,\n\t\t\t    unsigned long *start, unsigned long *end,\n\t\t\t    pte_t **ptepp, pmd_t **pmdpp, spinlock_t **ptlp)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *ptep;\n\n\tpgd = pgd_offset(mm, address);\n\tif (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))\n\t\tgoto out;\n\n\tp4d = p4d_offset(pgd, address);\n\tif (p4d_none(*p4d) || unlikely(p4d_bad(*p4d)))\n\t\tgoto out;\n\n\tpud = pud_offset(p4d, address);\n\tif (pud_none(*pud) || unlikely(pud_bad(*pud)))\n\t\tgoto out;\n\n\tpmd = pmd_offset(pud, address);\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\n\tif (pmd_huge(*pmd)) {\n\t\tif (!pmdpp)\n\t\t\tgoto out;\n\n\t\tif (start && end) {\n\t\t\t*start = address & PMD_MASK;\n\t\t\t*end = *start + PMD_SIZE;\n\t\t\tmmu_notifier_invalidate_range_start(mm, *start, *end);\n\t\t}\n\t\t*ptlp = pmd_lock(mm, pmd);\n\t\tif (pmd_huge(*pmd)) {\n\t\t\t*pmdpp = pmd;\n\t\t\treturn 0;\n\t\t}\n\t\tspin_unlock(*ptlp);\n\t\tif (start && end)\n\t\t\tmmu_notifier_invalidate_range_end(mm, *start, *end);\n\t}\n\n\tif (pmd_none(*pmd) || unlikely(pmd_bad(*pmd)))\n\t\tgoto out;\n\n\tif (start && end) {\n\t\t*start = address & PAGE_MASK;\n\t\t*end = *start + PAGE_SIZE;\n\t\tmmu_notifier_invalidate_range_start(mm, *start, *end);\n\t}\n\tptep = pte_offset_map_lock(mm, pmd, address, ptlp);\n\tif (!pte_present(*ptep))\n\t\tgoto unlock;\n\t*ptepp = ptep;\n\treturn 0;\nunlock:\n\tpte_unmap_unlock(ptep, *ptlp);\n\tif (start && end)\n\t\tmmu_notifier_invalidate_range_end(mm, *start, *end);\nout:\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "__pmd_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "4004-4029",
    "snippet": "int __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tptl = pud_lock(mm, pud);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (!pud_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpud_populate(mm, pud, new);\n\t} else\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n#else\n\tif (!pgd_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpgd_populate(mm, pud, new);\n\t} else /* Another has populated it */\n\t\tpmd_free(mm, new);\n#endif /* __ARCH_HAS_4LEVEL_HACK */\n\tspin_unlock(ptl);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 4027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_free",
          "args": [
            "mm",
            "new"
          ],
          "line": 4025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_populate",
          "args": [
            "mm",
            "pud",
            "new"
          ],
          "line": 4023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_inc_nr_pmds",
          "args": [
            "mm"
          ],
          "line": 4022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_present",
          "args": [
            "*pud"
          ],
          "line": 4021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_free",
          "args": [
            "mm",
            "new"
          ],
          "line": 4019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_populate",
          "args": [
            "mm",
            "pud",
            "new"
          ],
          "line": 4017
        },
        "resolved": true,
        "details": {
          "function_name": "zero_pud_populate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan_init.c",
          "lines": "137-170",
          "snippet": "static int __ref zero_pud_populate(p4d_t *p4d, unsigned long addr,\n\t\t\t\tunsigned long end)\n{\n\tpud_t *pud = pud_offset(p4d, addr);\n\tunsigned long next;\n\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (IS_ALIGNED(addr, PUD_SIZE) && end - addr >= PUD_SIZE) {\n\t\t\tpmd_t *pmd;\n\n\t\t\tpud_populate(&init_mm, pud, lm_alias(kasan_zero_pmd));\n\t\t\tpmd = pmd_offset(pud, addr);\n\t\t\tpmd_populate_kernel(&init_mm, pmd, lm_alias(kasan_zero_pte));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pud_none(*pud)) {\n\t\t\tpmd_t *p;\n\n\t\t\tif (slab_is_available()) {\n\t\t\t\tp = pmd_alloc(&init_mm, pud, addr);\n\t\t\t\tif (!p)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t} else {\n\t\t\t\tpud_populate(&init_mm, pud,\n\t\t\t\t\tearly_alloc(PAGE_SIZE, NUMA_NO_NODE));\n\t\t\t}\n\t\t}\n\t\tzero_pmd_populate(pud, addr, next);\n\t} while (pud++, addr = next, addr != end);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kasan.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/page.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/memblock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pte_t kasan_zero_pte[PTRS_PER_PTE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kasan.h\"\n#include <asm/pgalloc.h>\n#include <asm/page.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/memblock.h>\n\npte_t kasan_zero_pte[PTRS_PER_PTE];\n\nstatic int __ref zero_pud_populate(p4d_t *p4d, unsigned long addr,\n\t\t\t\tunsigned long end)\n{\n\tpud_t *pud = pud_offset(p4d, addr);\n\tunsigned long next;\n\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (IS_ALIGNED(addr, PUD_SIZE) && end - addr >= PUD_SIZE) {\n\t\t\tpmd_t *pmd;\n\n\t\t\tpud_populate(&init_mm, pud, lm_alias(kasan_zero_pmd));\n\t\t\tpmd = pmd_offset(pud, addr);\n\t\t\tpmd_populate_kernel(&init_mm, pmd, lm_alias(kasan_zero_pte));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pud_none(*pud)) {\n\t\t\tpmd_t *p;\n\n\t\t\tif (slab_is_available()) {\n\t\t\t\tp = pmd_alloc(&init_mm, pud, addr);\n\t\t\t\tif (!p)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t} else {\n\t\t\t\tpud_populate(&init_mm, pud,\n\t\t\t\t\tearly_alloc(PAGE_SIZE, NUMA_NO_NODE));\n\t\t\t}\n\t\t}\n\t\tzero_pmd_populate(pud, addr, next);\n\t} while (pud++, addr = next, addr != end);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_inc_nr_pmds",
          "args": [
            "mm"
          ],
          "line": 4016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_present",
          "args": [
            "*pud"
          ],
          "line": 4015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_lock",
          "args": [
            "mm",
            "pud"
          ],
          "line": 4013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 4011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_alloc_one",
          "args": [
            "mm",
            "address"
          ],
          "line": 4007
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tptl = pud_lock(mm, pud);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (!pud_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpud_populate(mm, pud, new);\n\t} else\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n#else\n\tif (!pgd_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpgd_populate(mm, pud, new);\n\t} else /* Another has populated it */\n\t\tpmd_free(mm, new);\n#endif /* __ARCH_HAS_4LEVEL_HACK */\n\tspin_unlock(ptl);\n\treturn 0;\n}"
  },
  {
    "function_name": "__pud_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3972-3996",
    "snippet": "int __pud_alloc(struct mm_struct *mm, p4d_t *p4d, unsigned long address)\n{\n\tpud_t *new = pud_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_5LEVEL_HACK\n\tif (!p4d_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tp4d_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#else\n\tif (!pgd_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tpgd_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#endif /* __ARCH_HAS_5LEVEL_HACK */\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mm->page_table_lock"
          ],
          "line": 3994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_free",
          "args": [
            "mm",
            "new"
          ],
          "line": 3992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_populate",
          "args": [
            "mm",
            "p4d",
            "new"
          ],
          "line": 3990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_inc_nr_puds",
          "args": [
            "mm"
          ],
          "line": 3989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_present",
          "args": [
            "*p4d"
          ],
          "line": 3988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_free",
          "args": [
            "mm",
            "new"
          ],
          "line": 3986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_populate",
          "args": [
            "mm",
            "p4d",
            "new"
          ],
          "line": 3984
        },
        "resolved": true,
        "details": {
          "function_name": "zero_p4d_populate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan_init.c",
          "lines": "172-209",
          "snippet": "static int __ref zero_p4d_populate(pgd_t *pgd, unsigned long addr,\n\t\t\t\tunsigned long end)\n{\n\tp4d_t *p4d = p4d_offset(pgd, addr);\n\tunsigned long next;\n\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (IS_ALIGNED(addr, P4D_SIZE) && end - addr >= P4D_SIZE) {\n\t\t\tpud_t *pud;\n\t\t\tpmd_t *pmd;\n\n\t\t\tp4d_populate(&init_mm, p4d, lm_alias(kasan_zero_pud));\n\t\t\tpud = pud_offset(p4d, addr);\n\t\t\tpud_populate(&init_mm, pud, lm_alias(kasan_zero_pmd));\n\t\t\tpmd = pmd_offset(pud, addr);\n\t\t\tpmd_populate_kernel(&init_mm, pmd,\n\t\t\t\t\t\tlm_alias(kasan_zero_pte));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (p4d_none(*p4d)) {\n\t\t\tpud_t *p;\n\n\t\t\tif (slab_is_available()) {\n\t\t\t\tp = pud_alloc(&init_mm, p4d, addr);\n\t\t\t\tif (!p)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t} else {\n\t\t\t\tp4d_populate(&init_mm, p4d,\n\t\t\t\t\tearly_alloc(PAGE_SIZE, NUMA_NO_NODE));\n\t\t\t}\n\t\t}\n\t\tzero_pud_populate(p4d, addr, next);\n\t} while (p4d++, addr = next, addr != end);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kasan.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/page.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/memblock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pte_t kasan_zero_pte[PTRS_PER_PTE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kasan.h\"\n#include <asm/pgalloc.h>\n#include <asm/page.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/memblock.h>\n\npte_t kasan_zero_pte[PTRS_PER_PTE];\n\nstatic int __ref zero_p4d_populate(pgd_t *pgd, unsigned long addr,\n\t\t\t\tunsigned long end)\n{\n\tp4d_t *p4d = p4d_offset(pgd, addr);\n\tunsigned long next;\n\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (IS_ALIGNED(addr, P4D_SIZE) && end - addr >= P4D_SIZE) {\n\t\t\tpud_t *pud;\n\t\t\tpmd_t *pmd;\n\n\t\t\tp4d_populate(&init_mm, p4d, lm_alias(kasan_zero_pud));\n\t\t\tpud = pud_offset(p4d, addr);\n\t\t\tpud_populate(&init_mm, pud, lm_alias(kasan_zero_pmd));\n\t\t\tpmd = pmd_offset(pud, addr);\n\t\t\tpmd_populate_kernel(&init_mm, pmd,\n\t\t\t\t\t\tlm_alias(kasan_zero_pte));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (p4d_none(*p4d)) {\n\t\t\tpud_t *p;\n\n\t\t\tif (slab_is_available()) {\n\t\t\t\tp = pud_alloc(&init_mm, p4d, addr);\n\t\t\t\tif (!p)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t} else {\n\t\t\t\tp4d_populate(&init_mm, p4d,\n\t\t\t\t\tearly_alloc(PAGE_SIZE, NUMA_NO_NODE));\n\t\t\t}\n\t\t}\n\t\tzero_pud_populate(p4d, addr, next);\n\t} while (p4d++, addr = next, addr != end);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_inc_nr_puds",
          "args": [
            "mm"
          ],
          "line": 3983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_present",
          "args": [
            "*p4d"
          ],
          "line": 3982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mm->page_table_lock"
          ],
          "line": 3980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 3978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_alloc_one",
          "args": [
            "mm",
            "address"
          ],
          "line": 3974
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pud_alloc(struct mm_struct *mm, p4d_t *p4d, unsigned long address)\n{\n\tpud_t *new = pud_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_5LEVEL_HACK\n\tif (!p4d_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tp4d_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#else\n\tif (!pgd_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tpgd_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#endif /* __ARCH_HAS_5LEVEL_HACK */\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "__p4d_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3949-3964",
    "snippet": "int __p4d_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)\n{\n\tp4d_t *new = p4d_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n\tif (pgd_present(*pgd))\t\t/* Another has populated it */\n\t\tp4d_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pgd, new);\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mm->page_table_lock"
          ],
          "line": 3962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_populate",
          "args": [
            "mm",
            "pgd",
            "new"
          ],
          "line": 3961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_free",
          "args": [
            "mm",
            "new"
          ],
          "line": 3959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_present",
          "args": [
            "*pgd"
          ],
          "line": 3958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mm->page_table_lock"
          ],
          "line": 3957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 3955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_alloc_one",
          "args": [
            "mm",
            "address"
          ],
          "line": 3951
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __p4d_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)\n{\n\tp4d_t *new = p4d_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n\tif (pgd_present(*pgd))\t\t/* Another has populated it */\n\t\tp4d_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pgd, new);\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "handle_mm_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3898-3941",
    "snippet": "vm_fault_t handle_mm_fault(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned int flags)\n{\n\tvm_fault_t ret;\n\n\t__set_current_state(TASK_RUNNING);\n\n\tcount_vm_event(PGFAULT);\n\tcount_memcg_event_mm(vma->vm_mm, PGFAULT);\n\n\t/* do counter updates before entering really critical section. */\n\tcheck_sync_rss_stat(current);\n\n\tif (!arch_vma_access_permitted(vma, flags & FAULT_FLAG_WRITE,\n\t\t\t\t\t    flags & FAULT_FLAG_INSTRUCTION,\n\t\t\t\t\t    flags & FAULT_FLAG_REMOTE))\n\t\treturn VM_FAULT_SIGSEGV;\n\n\t/*\n\t * Enable the memcg OOM handling for faults triggered in user\n\t * space.  Kernel faults are handled more gracefully.\n\t */\n\tif (flags & FAULT_FLAG_USER)\n\t\tmem_cgroup_enter_user_fault();\n\n\tif (unlikely(is_vm_hugetlb_page(vma)))\n\t\tret = hugetlb_fault(vma->vm_mm, vma, address, flags);\n\telse\n\t\tret = __handle_mm_fault(vma, address, flags);\n\n\tif (flags & FAULT_FLAG_USER) {\n\t\tmem_cgroup_exit_user_fault();\n\t\t/*\n\t\t * The task may have entered a memcg OOM situation but\n\t\t * if the allocation error was handled gracefully (no\n\t\t * VM_FAULT_OOM), there is no need to kill anything.\n\t\t * Just clean up the OOM state peacefully.\n\t\t */\n\t\tif (task_in_memcg_oom(current) && !(ret & VM_FAULT_OOM))\n\t\t\tmem_cgroup_oom_synchronize(false);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_oom_synchronize",
          "args": [
            "false"
          ],
          "line": 3937
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_oom_synchronize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1726-1777",
          "snippet": "bool mem_cgroup_oom_synchronize(bool handle)\n{\n\tstruct mem_cgroup *memcg = current->memcg_in_oom;\n\tstruct oom_wait_info owait;\n\tbool locked;\n\n\t/* OOM is global, do not handle */\n\tif (!memcg)\n\t\treturn false;\n\n\tif (!handle)\n\t\tgoto cleanup;\n\n\towait.memcg = memcg;\n\towait.wait.flags = 0;\n\towait.wait.func = memcg_oom_wake_function;\n\towait.wait.private = current;\n\tINIT_LIST_HEAD(&owait.wait.entry);\n\n\tprepare_to_wait(&memcg_oom_waitq, &owait.wait, TASK_KILLABLE);\n\tmem_cgroup_mark_under_oom(memcg);\n\n\tlocked = mem_cgroup_oom_trylock(memcg);\n\n\tif (locked)\n\t\tmem_cgroup_oom_notify(memcg);\n\n\tif (locked && !memcg->oom_kill_disable) {\n\t\tmem_cgroup_unmark_under_oom(memcg);\n\t\tfinish_wait(&memcg_oom_waitq, &owait.wait);\n\t\tmem_cgroup_out_of_memory(memcg, current->memcg_oom_gfp_mask,\n\t\t\t\t\t current->memcg_oom_order);\n\t} else {\n\t\tschedule();\n\t\tmem_cgroup_unmark_under_oom(memcg);\n\t\tfinish_wait(&memcg_oom_waitq, &owait.wait);\n\t}\n\n\tif (locked) {\n\t\tmem_cgroup_oom_unlock(memcg);\n\t\t/*\n\t\t * There is no guarantee that an OOM-lock contender\n\t\t * sees the wakeups triggered by the OOM kill\n\t\t * uncharges.  Wake any sleepers explicitely.\n\t\t */\n\t\tmemcg_oom_recover(memcg);\n\t}\ncleanup:\n\tcurrent->memcg_in_oom = NULL;\n\tcss_put(&memcg->css);\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DECLARE_WAIT_QUEUE_HEAD(memcg_oom_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DECLARE_WAIT_QUEUE_HEAD(memcg_oom_waitq);\n\nbool mem_cgroup_oom_synchronize(bool handle)\n{\n\tstruct mem_cgroup *memcg = current->memcg_in_oom;\n\tstruct oom_wait_info owait;\n\tbool locked;\n\n\t/* OOM is global, do not handle */\n\tif (!memcg)\n\t\treturn false;\n\n\tif (!handle)\n\t\tgoto cleanup;\n\n\towait.memcg = memcg;\n\towait.wait.flags = 0;\n\towait.wait.func = memcg_oom_wake_function;\n\towait.wait.private = current;\n\tINIT_LIST_HEAD(&owait.wait.entry);\n\n\tprepare_to_wait(&memcg_oom_waitq, &owait.wait, TASK_KILLABLE);\n\tmem_cgroup_mark_under_oom(memcg);\n\n\tlocked = mem_cgroup_oom_trylock(memcg);\n\n\tif (locked)\n\t\tmem_cgroup_oom_notify(memcg);\n\n\tif (locked && !memcg->oom_kill_disable) {\n\t\tmem_cgroup_unmark_under_oom(memcg);\n\t\tfinish_wait(&memcg_oom_waitq, &owait.wait);\n\t\tmem_cgroup_out_of_memory(memcg, current->memcg_oom_gfp_mask,\n\t\t\t\t\t current->memcg_oom_order);\n\t} else {\n\t\tschedule();\n\t\tmem_cgroup_unmark_under_oom(memcg);\n\t\tfinish_wait(&memcg_oom_waitq, &owait.wait);\n\t}\n\n\tif (locked) {\n\t\tmem_cgroup_oom_unlock(memcg);\n\t\t/*\n\t\t * There is no guarantee that an OOM-lock contender\n\t\t * sees the wakeups triggered by the OOM kill\n\t\t * uncharges.  Wake any sleepers explicitely.\n\t\t */\n\t\tmemcg_oom_recover(memcg);\n\t}\ncleanup:\n\tcurrent->memcg_in_oom = NULL;\n\tcss_put(&memcg->css);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_in_memcg_oom",
          "args": [
            "current"
          ],
          "line": 3936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_exit_user_fault",
          "args": [],
          "line": 3929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__handle_mm_fault",
          "args": [
            "vma",
            "address",
            "flags"
          ],
          "line": 3926
        },
        "resolved": true,
        "details": {
          "function_name": "__handle_mm_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3809-3890",
          "snippet": "static vm_fault_t __handle_mm_fault(struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int flags)\n{\n\tstruct vm_fault vmf = {\n\t\t.vma = vma,\n\t\t.address = address & PAGE_MASK,\n\t\t.flags = flags,\n\t\t.pgoff = linear_page_index(vma, address),\n\t\t.gfp_mask = __get_fault_gfp_mask(vma),\n\t};\n\tunsigned int dirty = flags & FAULT_FLAG_WRITE;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tvm_fault_t ret;\n\n\tpgd = pgd_offset(mm, address);\n\tp4d = p4d_alloc(mm, pgd, address);\n\tif (!p4d)\n\t\treturn VM_FAULT_OOM;\n\n\tvmf.pud = pud_alloc(mm, p4d, address);\n\tif (!vmf.pud)\n\t\treturn VM_FAULT_OOM;\n\tif (pud_none(*vmf.pud) && transparent_hugepage_enabled(vma)) {\n\t\tret = create_huge_pud(&vmf);\n\t\tif (!(ret & VM_FAULT_FALLBACK))\n\t\t\treturn ret;\n\t} else {\n\t\tpud_t orig_pud = *vmf.pud;\n\n\t\tbarrier();\n\t\tif (pud_trans_huge(orig_pud) || pud_devmap(orig_pud)) {\n\n\t\t\t/* NUMA case for anonymous PUDs would go here */\n\n\t\t\tif (dirty && !pud_write(orig_pud)) {\n\t\t\t\tret = wp_huge_pud(&vmf, orig_pud);\n\t\t\t\tif (!(ret & VM_FAULT_FALLBACK))\n\t\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\thuge_pud_set_accessed(&vmf, orig_pud);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvmf.pmd = pmd_alloc(mm, vmf.pud, address);\n\tif (!vmf.pmd)\n\t\treturn VM_FAULT_OOM;\n\tif (pmd_none(*vmf.pmd) && transparent_hugepage_enabled(vma)) {\n\t\tret = create_huge_pmd(&vmf);\n\t\tif (!(ret & VM_FAULT_FALLBACK))\n\t\t\treturn ret;\n\t} else {\n\t\tpmd_t orig_pmd = *vmf.pmd;\n\n\t\tbarrier();\n\t\tif (unlikely(is_swap_pmd(orig_pmd))) {\n\t\t\tVM_BUG_ON(thp_migration_supported() &&\n\t\t\t\t\t  !is_pmd_migration_entry(orig_pmd));\n\t\t\tif (is_pmd_migration_entry(orig_pmd))\n\t\t\t\tpmd_migration_entry_wait(mm, vmf.pmd);\n\t\t\treturn 0;\n\t\t}\n\t\tif (pmd_trans_huge(orig_pmd) || pmd_devmap(orig_pmd)) {\n\t\t\tif (pmd_protnone(orig_pmd) && vma_is_accessible(vma))\n\t\t\t\treturn do_huge_pmd_numa_page(&vmf, orig_pmd);\n\n\t\t\tif (dirty && !pmd_write(orig_pmd)) {\n\t\t\t\tret = wp_huge_pmd(&vmf, orig_pmd);\n\t\t\t\tif (!(ret & VM_FAULT_FALLBACK))\n\t\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\thuge_pmd_set_accessed(&vmf, orig_pmd);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn handle_pte_fault(&vmf);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t __handle_mm_fault(struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int flags)\n{\n\tstruct vm_fault vmf = {\n\t\t.vma = vma,\n\t\t.address = address & PAGE_MASK,\n\t\t.flags = flags,\n\t\t.pgoff = linear_page_index(vma, address),\n\t\t.gfp_mask = __get_fault_gfp_mask(vma),\n\t};\n\tunsigned int dirty = flags & FAULT_FLAG_WRITE;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tvm_fault_t ret;\n\n\tpgd = pgd_offset(mm, address);\n\tp4d = p4d_alloc(mm, pgd, address);\n\tif (!p4d)\n\t\treturn VM_FAULT_OOM;\n\n\tvmf.pud = pud_alloc(mm, p4d, address);\n\tif (!vmf.pud)\n\t\treturn VM_FAULT_OOM;\n\tif (pud_none(*vmf.pud) && transparent_hugepage_enabled(vma)) {\n\t\tret = create_huge_pud(&vmf);\n\t\tif (!(ret & VM_FAULT_FALLBACK))\n\t\t\treturn ret;\n\t} else {\n\t\tpud_t orig_pud = *vmf.pud;\n\n\t\tbarrier();\n\t\tif (pud_trans_huge(orig_pud) || pud_devmap(orig_pud)) {\n\n\t\t\t/* NUMA case for anonymous PUDs would go here */\n\n\t\t\tif (dirty && !pud_write(orig_pud)) {\n\t\t\t\tret = wp_huge_pud(&vmf, orig_pud);\n\t\t\t\tif (!(ret & VM_FAULT_FALLBACK))\n\t\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\thuge_pud_set_accessed(&vmf, orig_pud);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvmf.pmd = pmd_alloc(mm, vmf.pud, address);\n\tif (!vmf.pmd)\n\t\treturn VM_FAULT_OOM;\n\tif (pmd_none(*vmf.pmd) && transparent_hugepage_enabled(vma)) {\n\t\tret = create_huge_pmd(&vmf);\n\t\tif (!(ret & VM_FAULT_FALLBACK))\n\t\t\treturn ret;\n\t} else {\n\t\tpmd_t orig_pmd = *vmf.pmd;\n\n\t\tbarrier();\n\t\tif (unlikely(is_swap_pmd(orig_pmd))) {\n\t\t\tVM_BUG_ON(thp_migration_supported() &&\n\t\t\t\t\t  !is_pmd_migration_entry(orig_pmd));\n\t\t\tif (is_pmd_migration_entry(orig_pmd))\n\t\t\t\tpmd_migration_entry_wait(mm, vmf.pmd);\n\t\t\treturn 0;\n\t\t}\n\t\tif (pmd_trans_huge(orig_pmd) || pmd_devmap(orig_pmd)) {\n\t\t\tif (pmd_protnone(orig_pmd) && vma_is_accessible(vma))\n\t\t\t\treturn do_huge_pmd_numa_page(&vmf, orig_pmd);\n\n\t\t\tif (dirty && !pmd_write(orig_pmd)) {\n\t\t\t\tret = wp_huge_pmd(&vmf, orig_pmd);\n\t\t\t\tif (!(ret & VM_FAULT_FALLBACK))\n\t\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\thuge_pmd_set_accessed(&vmf, orig_pmd);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn handle_pte_fault(&vmf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugetlb_fault",
          "args": [
            "vma->vm_mm",
            "vma",
            "address",
            "flags"
          ],
          "line": 3924
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3913-4048",
          "snippet": "vm_fault_t hugetlb_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\tunsigned long address, unsigned int flags)\n{\n\tpte_t *ptep, entry;\n\tspinlock_t *ptl;\n\tvm_fault_t ret;\n\tu32 hash;\n\tpgoff_t idx;\n\tstruct page *page = NULL;\n\tstruct page *pagecache_page = NULL;\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct address_space *mapping;\n\tint need_wait_lock = 0;\n\tunsigned long haddr = address & huge_page_mask(h);\n\n\tptep = huge_pte_offset(mm, haddr, huge_page_size(h));\n\tif (ptep) {\n\t\tentry = huge_ptep_get(ptep);\n\t\tif (unlikely(is_hugetlb_entry_migration(entry))) {\n\t\t\tmigration_entry_wait_huge(vma, mm, ptep);\n\t\t\treturn 0;\n\t\t} else if (unlikely(is_hugetlb_entry_hwpoisoned(entry)))\n\t\t\treturn VM_FAULT_HWPOISON_LARGE |\n\t\t\t\tVM_FAULT_SET_HINDEX(hstate_index(h));\n\t} else {\n\t\tptep = huge_pte_alloc(mm, haddr, huge_page_size(h));\n\t\tif (!ptep)\n\t\t\treturn VM_FAULT_OOM;\n\t}\n\n\tmapping = vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, vma, haddr);\n\n\t/*\n\t * Serialize hugepage allocation and instantiation, so that we don't\n\t * get spurious allocation failures if two CPUs race to instantiate\n\t * the same page in the page cache.\n\t */\n\thash = hugetlb_fault_mutex_hash(h, mm, vma, mapping, idx, haddr);\n\tmutex_lock(&hugetlb_fault_mutex_table[hash]);\n\n\tentry = huge_ptep_get(ptep);\n\tif (huge_pte_none(entry)) {\n\t\tret = hugetlb_no_page(mm, vma, mapping, idx, address, ptep, flags);\n\t\tgoto out_mutex;\n\t}\n\n\tret = 0;\n\n\t/*\n\t * entry could be a migration/hwpoison entry at this point, so this\n\t * check prevents the kernel from going below assuming that we have\n\t * a active hugepage in pagecache. This goto expects the 2nd page fault,\n\t * and is_hugetlb_entry_(migration|hwpoisoned) check will properly\n\t * handle it.\n\t */\n\tif (!pte_present(entry))\n\t\tgoto out_mutex;\n\n\t/*\n\t * If we are going to COW the mapping later, we examine the pending\n\t * reservations for this page now. This will ensure that any\n\t * allocations necessary to record that reservation occur outside the\n\t * spinlock. For private mappings, we also lookup the pagecache\n\t * page now as it is used to determine if a reservation has been\n\t * consumed.\n\t */\n\tif ((flags & FAULT_FLAG_WRITE) && !huge_pte_write(entry)) {\n\t\tif (vma_needs_reservation(h, vma, haddr) < 0) {\n\t\t\tret = VM_FAULT_OOM;\n\t\t\tgoto out_mutex;\n\t\t}\n\t\t/* Just decrements count, does not deallocate */\n\t\tvma_end_reservation(h, vma, haddr);\n\n\t\tif (!(vma->vm_flags & VM_MAYSHARE))\n\t\t\tpagecache_page = hugetlbfs_pagecache_page(h,\n\t\t\t\t\t\t\t\tvma, haddr);\n\t}\n\n\tptl = huge_pte_lock(h, mm, ptep);\n\n\t/* Check for a racing update before calling hugetlb_cow */\n\tif (unlikely(!pte_same(entry, huge_ptep_get(ptep))))\n\t\tgoto out_ptl;\n\n\t/*\n\t * hugetlb_cow() requires page locks of pte_page(entry) and\n\t * pagecache_page, so here we need take the former one\n\t * when page != pagecache_page or !pagecache_page.\n\t */\n\tpage = pte_page(entry);\n\tif (page != pagecache_page)\n\t\tif (!trylock_page(page)) {\n\t\t\tneed_wait_lock = 1;\n\t\t\tgoto out_ptl;\n\t\t}\n\n\tget_page(page);\n\n\tif (flags & FAULT_FLAG_WRITE) {\n\t\tif (!huge_pte_write(entry)) {\n\t\t\tret = hugetlb_cow(mm, vma, address, ptep,\n\t\t\t\t\t  pagecache_page, ptl);\n\t\t\tgoto out_put_page;\n\t\t}\n\t\tentry = huge_pte_mkdirty(entry);\n\t}\n\tentry = pte_mkyoung(entry);\n\tif (huge_ptep_set_access_flags(vma, haddr, ptep, entry,\n\t\t\t\t\t\tflags & FAULT_FLAG_WRITE))\n\t\tupdate_mmu_cache(vma, haddr, ptep);\nout_put_page:\n\tif (page != pagecache_page)\n\t\tunlock_page(page);\n\tput_page(page);\nout_ptl:\n\tspin_unlock(ptl);\n\n\tif (pagecache_page) {\n\t\tunlock_page(pagecache_page);\n\t\tput_page(pagecache_page);\n\t}\nout_mutex:\n\tmutex_unlock(&hugetlb_fault_mutex_table[hash]);\n\t/*\n\t * Generally it's safe to hold refcount during waiting page lock. But\n\t * here we just wait to defer the next page fault to avoid busy loop and\n\t * the page is not used after unlocked before returning from the current\n\t * page fault. So we are safe from accessing freed page, even if we wait\n\t * here without taking refcount.\n\t */\n\tif (need_wait_lock)\n\t\twait_on_page_locked(page);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mutex *hugetlb_fault_mutex_table"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstruct mutex *hugetlb_fault_mutex_table;\n\nvm_fault_t hugetlb_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\tunsigned long address, unsigned int flags)\n{\n\tpte_t *ptep, entry;\n\tspinlock_t *ptl;\n\tvm_fault_t ret;\n\tu32 hash;\n\tpgoff_t idx;\n\tstruct page *page = NULL;\n\tstruct page *pagecache_page = NULL;\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct address_space *mapping;\n\tint need_wait_lock = 0;\n\tunsigned long haddr = address & huge_page_mask(h);\n\n\tptep = huge_pte_offset(mm, haddr, huge_page_size(h));\n\tif (ptep) {\n\t\tentry = huge_ptep_get(ptep);\n\t\tif (unlikely(is_hugetlb_entry_migration(entry))) {\n\t\t\tmigration_entry_wait_huge(vma, mm, ptep);\n\t\t\treturn 0;\n\t\t} else if (unlikely(is_hugetlb_entry_hwpoisoned(entry)))\n\t\t\treturn VM_FAULT_HWPOISON_LARGE |\n\t\t\t\tVM_FAULT_SET_HINDEX(hstate_index(h));\n\t} else {\n\t\tptep = huge_pte_alloc(mm, haddr, huge_page_size(h));\n\t\tif (!ptep)\n\t\t\treturn VM_FAULT_OOM;\n\t}\n\n\tmapping = vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, vma, haddr);\n\n\t/*\n\t * Serialize hugepage allocation and instantiation, so that we don't\n\t * get spurious allocation failures if two CPUs race to instantiate\n\t * the same page in the page cache.\n\t */\n\thash = hugetlb_fault_mutex_hash(h, mm, vma, mapping, idx, haddr);\n\tmutex_lock(&hugetlb_fault_mutex_table[hash]);\n\n\tentry = huge_ptep_get(ptep);\n\tif (huge_pte_none(entry)) {\n\t\tret = hugetlb_no_page(mm, vma, mapping, idx, address, ptep, flags);\n\t\tgoto out_mutex;\n\t}\n\n\tret = 0;\n\n\t/*\n\t * entry could be a migration/hwpoison entry at this point, so this\n\t * check prevents the kernel from going below assuming that we have\n\t * a active hugepage in pagecache. This goto expects the 2nd page fault,\n\t * and is_hugetlb_entry_(migration|hwpoisoned) check will properly\n\t * handle it.\n\t */\n\tif (!pte_present(entry))\n\t\tgoto out_mutex;\n\n\t/*\n\t * If we are going to COW the mapping later, we examine the pending\n\t * reservations for this page now. This will ensure that any\n\t * allocations necessary to record that reservation occur outside the\n\t * spinlock. For private mappings, we also lookup the pagecache\n\t * page now as it is used to determine if a reservation has been\n\t * consumed.\n\t */\n\tif ((flags & FAULT_FLAG_WRITE) && !huge_pte_write(entry)) {\n\t\tif (vma_needs_reservation(h, vma, haddr) < 0) {\n\t\t\tret = VM_FAULT_OOM;\n\t\t\tgoto out_mutex;\n\t\t}\n\t\t/* Just decrements count, does not deallocate */\n\t\tvma_end_reservation(h, vma, haddr);\n\n\t\tif (!(vma->vm_flags & VM_MAYSHARE))\n\t\t\tpagecache_page = hugetlbfs_pagecache_page(h,\n\t\t\t\t\t\t\t\tvma, haddr);\n\t}\n\n\tptl = huge_pte_lock(h, mm, ptep);\n\n\t/* Check for a racing update before calling hugetlb_cow */\n\tif (unlikely(!pte_same(entry, huge_ptep_get(ptep))))\n\t\tgoto out_ptl;\n\n\t/*\n\t * hugetlb_cow() requires page locks of pte_page(entry) and\n\t * pagecache_page, so here we need take the former one\n\t * when page != pagecache_page or !pagecache_page.\n\t */\n\tpage = pte_page(entry);\n\tif (page != pagecache_page)\n\t\tif (!trylock_page(page)) {\n\t\t\tneed_wait_lock = 1;\n\t\t\tgoto out_ptl;\n\t\t}\n\n\tget_page(page);\n\n\tif (flags & FAULT_FLAG_WRITE) {\n\t\tif (!huge_pte_write(entry)) {\n\t\t\tret = hugetlb_cow(mm, vma, address, ptep,\n\t\t\t\t\t  pagecache_page, ptl);\n\t\t\tgoto out_put_page;\n\t\t}\n\t\tentry = huge_pte_mkdirty(entry);\n\t}\n\tentry = pte_mkyoung(entry);\n\tif (huge_ptep_set_access_flags(vma, haddr, ptep, entry,\n\t\t\t\t\t\tflags & FAULT_FLAG_WRITE))\n\t\tupdate_mmu_cache(vma, haddr, ptep);\nout_put_page:\n\tif (page != pagecache_page)\n\t\tunlock_page(page);\n\tput_page(page);\nout_ptl:\n\tspin_unlock(ptl);\n\n\tif (pagecache_page) {\n\t\tunlock_page(pagecache_page);\n\t\tput_page(pagecache_page);\n\t}\nout_mutex:\n\tmutex_unlock(&hugetlb_fault_mutex_table[hash]);\n\t/*\n\t * Generally it's safe to hold refcount during waiting page lock. But\n\t * here we just wait to defer the next page fault to avoid busy loop and\n\t * the page is not used after unlocked before returning from the current\n\t * page fault. So we are safe from accessing freed page, even if we wait\n\t * here without taking refcount.\n\t */\n\tif (need_wait_lock)\n\t\twait_on_page_locked(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_vm_hugetlb_page(vma)"
          ],
          "line": 3923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 3923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_enter_user_fault",
          "args": [],
          "line": 3921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_vma_access_permitted",
          "args": [
            "vma",
            "flags & FAULT_FLAG_WRITE",
            "flags & FAULT_FLAG_INSTRUCTION",
            "flags & FAULT_FLAG_REMOTE"
          ],
          "line": 3911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_sync_rss_stat",
          "args": [
            "current"
          ],
          "line": 3909
        },
        "resolved": true,
        "details": {
          "function_name": "check_sync_rss_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "183-185",
          "snippet": "static void check_sync_rss_stat(struct task_struct *task)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void check_sync_rss_stat(struct task_struct *task)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_memcg_event_mm",
          "args": [
            "vma->vm_mm",
            "PGFAULT"
          ],
          "line": 3906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "PGFAULT"
          ],
          "line": 3905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 3903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvm_fault_t handle_mm_fault(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned int flags)\n{\n\tvm_fault_t ret;\n\n\t__set_current_state(TASK_RUNNING);\n\n\tcount_vm_event(PGFAULT);\n\tcount_memcg_event_mm(vma->vm_mm, PGFAULT);\n\n\t/* do counter updates before entering really critical section. */\n\tcheck_sync_rss_stat(current);\n\n\tif (!arch_vma_access_permitted(vma, flags & FAULT_FLAG_WRITE,\n\t\t\t\t\t    flags & FAULT_FLAG_INSTRUCTION,\n\t\t\t\t\t    flags & FAULT_FLAG_REMOTE))\n\t\treturn VM_FAULT_SIGSEGV;\n\n\t/*\n\t * Enable the memcg OOM handling for faults triggered in user\n\t * space.  Kernel faults are handled more gracefully.\n\t */\n\tif (flags & FAULT_FLAG_USER)\n\t\tmem_cgroup_enter_user_fault();\n\n\tif (unlikely(is_vm_hugetlb_page(vma)))\n\t\tret = hugetlb_fault(vma->vm_mm, vma, address, flags);\n\telse\n\t\tret = __handle_mm_fault(vma, address, flags);\n\n\tif (flags & FAULT_FLAG_USER) {\n\t\tmem_cgroup_exit_user_fault();\n\t\t/*\n\t\t * The task may have entered a memcg OOM situation but\n\t\t * if the allocation error was handled gracefully (no\n\t\t * VM_FAULT_OOM), there is no need to kill anything.\n\t\t * Just clean up the OOM state peacefully.\n\t\t */\n\t\tif (task_in_memcg_oom(current) && !(ret & VM_FAULT_OOM))\n\t\t\tmem_cgroup_oom_synchronize(false);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__handle_mm_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3809-3890",
    "snippet": "static vm_fault_t __handle_mm_fault(struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int flags)\n{\n\tstruct vm_fault vmf = {\n\t\t.vma = vma,\n\t\t.address = address & PAGE_MASK,\n\t\t.flags = flags,\n\t\t.pgoff = linear_page_index(vma, address),\n\t\t.gfp_mask = __get_fault_gfp_mask(vma),\n\t};\n\tunsigned int dirty = flags & FAULT_FLAG_WRITE;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tvm_fault_t ret;\n\n\tpgd = pgd_offset(mm, address);\n\tp4d = p4d_alloc(mm, pgd, address);\n\tif (!p4d)\n\t\treturn VM_FAULT_OOM;\n\n\tvmf.pud = pud_alloc(mm, p4d, address);\n\tif (!vmf.pud)\n\t\treturn VM_FAULT_OOM;\n\tif (pud_none(*vmf.pud) && transparent_hugepage_enabled(vma)) {\n\t\tret = create_huge_pud(&vmf);\n\t\tif (!(ret & VM_FAULT_FALLBACK))\n\t\t\treturn ret;\n\t} else {\n\t\tpud_t orig_pud = *vmf.pud;\n\n\t\tbarrier();\n\t\tif (pud_trans_huge(orig_pud) || pud_devmap(orig_pud)) {\n\n\t\t\t/* NUMA case for anonymous PUDs would go here */\n\n\t\t\tif (dirty && !pud_write(orig_pud)) {\n\t\t\t\tret = wp_huge_pud(&vmf, orig_pud);\n\t\t\t\tif (!(ret & VM_FAULT_FALLBACK))\n\t\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\thuge_pud_set_accessed(&vmf, orig_pud);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvmf.pmd = pmd_alloc(mm, vmf.pud, address);\n\tif (!vmf.pmd)\n\t\treturn VM_FAULT_OOM;\n\tif (pmd_none(*vmf.pmd) && transparent_hugepage_enabled(vma)) {\n\t\tret = create_huge_pmd(&vmf);\n\t\tif (!(ret & VM_FAULT_FALLBACK))\n\t\t\treturn ret;\n\t} else {\n\t\tpmd_t orig_pmd = *vmf.pmd;\n\n\t\tbarrier();\n\t\tif (unlikely(is_swap_pmd(orig_pmd))) {\n\t\t\tVM_BUG_ON(thp_migration_supported() &&\n\t\t\t\t\t  !is_pmd_migration_entry(orig_pmd));\n\t\t\tif (is_pmd_migration_entry(orig_pmd))\n\t\t\t\tpmd_migration_entry_wait(mm, vmf.pmd);\n\t\t\treturn 0;\n\t\t}\n\t\tif (pmd_trans_huge(orig_pmd) || pmd_devmap(orig_pmd)) {\n\t\t\tif (pmd_protnone(orig_pmd) && vma_is_accessible(vma))\n\t\t\t\treturn do_huge_pmd_numa_page(&vmf, orig_pmd);\n\n\t\t\tif (dirty && !pmd_write(orig_pmd)) {\n\t\t\t\tret = wp_huge_pmd(&vmf, orig_pmd);\n\t\t\t\tif (!(ret & VM_FAULT_FALLBACK))\n\t\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\thuge_pmd_set_accessed(&vmf, orig_pmd);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn handle_pte_fault(&vmf);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_pte_fault",
          "args": [
            "&vmf"
          ],
          "line": 3889
        },
        "resolved": true,
        "details": {
          "function_name": "handle_pte_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3721-3801",
          "snippet": "static vm_fault_t handle_pte_fault(struct vm_fault *vmf)\n{\n\tpte_t entry;\n\n\tif (unlikely(pmd_none(*vmf->pmd))) {\n\t\t/*\n\t\t * Leave __pte_alloc() until later: because vm_ops->fault may\n\t\t * want to allocate huge page, and if we expose page table\n\t\t * for an instant, it will be difficult to retract from\n\t\t * concurrent faults and from rmap lookups.\n\t\t */\n\t\tvmf->pte = NULL;\n\t} else {\n\t\t/* See comment in pte_alloc_one_map() */\n\t\tif (pmd_devmap_trans_unstable(vmf->pmd))\n\t\t\treturn 0;\n\t\t/*\n\t\t * A regular pmd is established and it can't morph into a huge\n\t\t * pmd from under us anymore at this point because we hold the\n\t\t * mmap_sem read mode and khugepaged takes it in write mode.\n\t\t * So now it's safe to run pte_offset_map().\n\t\t */\n\t\tvmf->pte = pte_offset_map(vmf->pmd, vmf->address);\n\t\tvmf->orig_pte = *vmf->pte;\n\n\t\t/*\n\t\t * some architectures can have larger ptes than wordsize,\n\t\t * e.g.ppc44x-defconfig has CONFIG_PTE_64BIT=y and\n\t\t * CONFIG_32BIT=y, so READ_ONCE cannot guarantee atomic\n\t\t * accesses.  The code below just needs a consistent view\n\t\t * for the ifs and we later double check anyway with the\n\t\t * ptl lock held. So here a barrier will do.\n\t\t */\n\t\tbarrier();\n\t\tif (pte_none(vmf->orig_pte)) {\n\t\t\tpte_unmap(vmf->pte);\n\t\t\tvmf->pte = NULL;\n\t\t}\n\t}\n\n\tif (!vmf->pte) {\n\t\tif (vma_is_anonymous(vmf->vma))\n\t\t\treturn do_anonymous_page(vmf);\n\t\telse\n\t\t\treturn do_fault(vmf);\n\t}\n\n\tif (!pte_present(vmf->orig_pte))\n\t\treturn do_swap_page(vmf);\n\n\tif (pte_protnone(vmf->orig_pte) && vma_is_accessible(vmf->vma))\n\t\treturn do_numa_page(vmf);\n\n\tvmf->ptl = pte_lockptr(vmf->vma->vm_mm, vmf->pmd);\n\tspin_lock(vmf->ptl);\n\tentry = vmf->orig_pte;\n\tif (unlikely(!pte_same(*vmf->pte, entry)))\n\t\tgoto unlock;\n\tif (vmf->flags & FAULT_FLAG_WRITE) {\n\t\tif (!pte_write(entry))\n\t\t\treturn do_wp_page(vmf);\n\t\tentry = pte_mkdirty(entry);\n\t}\n\tentry = pte_mkyoung(entry);\n\tif (ptep_set_access_flags(vmf->vma, vmf->address, vmf->pte, entry,\n\t\t\t\tvmf->flags & FAULT_FLAG_WRITE)) {\n\t\tupdate_mmu_cache(vmf->vma, vmf->address, vmf->pte);\n\t} else {\n\t\t/*\n\t\t * This is needed only for protection faults but the arch code\n\t\t * is not yet telling us if this is a protection fault or not.\n\t\t * This still avoids useless tlb flushes for .text page faults\n\t\t * with threads.\n\t\t */\n\t\tif (vmf->flags & FAULT_FLAG_WRITE)\n\t\t\tflush_tlb_fix_spurious_fault(vmf->vma, vmf->address);\n\t}\nunlock:\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t handle_pte_fault(struct vm_fault *vmf)\n{\n\tpte_t entry;\n\n\tif (unlikely(pmd_none(*vmf->pmd))) {\n\t\t/*\n\t\t * Leave __pte_alloc() until later: because vm_ops->fault may\n\t\t * want to allocate huge page, and if we expose page table\n\t\t * for an instant, it will be difficult to retract from\n\t\t * concurrent faults and from rmap lookups.\n\t\t */\n\t\tvmf->pte = NULL;\n\t} else {\n\t\t/* See comment in pte_alloc_one_map() */\n\t\tif (pmd_devmap_trans_unstable(vmf->pmd))\n\t\t\treturn 0;\n\t\t/*\n\t\t * A regular pmd is established and it can't morph into a huge\n\t\t * pmd from under us anymore at this point because we hold the\n\t\t * mmap_sem read mode and khugepaged takes it in write mode.\n\t\t * So now it's safe to run pte_offset_map().\n\t\t */\n\t\tvmf->pte = pte_offset_map(vmf->pmd, vmf->address);\n\t\tvmf->orig_pte = *vmf->pte;\n\n\t\t/*\n\t\t * some architectures can have larger ptes than wordsize,\n\t\t * e.g.ppc44x-defconfig has CONFIG_PTE_64BIT=y and\n\t\t * CONFIG_32BIT=y, so READ_ONCE cannot guarantee atomic\n\t\t * accesses.  The code below just needs a consistent view\n\t\t * for the ifs and we later double check anyway with the\n\t\t * ptl lock held. So here a barrier will do.\n\t\t */\n\t\tbarrier();\n\t\tif (pte_none(vmf->orig_pte)) {\n\t\t\tpte_unmap(vmf->pte);\n\t\t\tvmf->pte = NULL;\n\t\t}\n\t}\n\n\tif (!vmf->pte) {\n\t\tif (vma_is_anonymous(vmf->vma))\n\t\t\treturn do_anonymous_page(vmf);\n\t\telse\n\t\t\treturn do_fault(vmf);\n\t}\n\n\tif (!pte_present(vmf->orig_pte))\n\t\treturn do_swap_page(vmf);\n\n\tif (pte_protnone(vmf->orig_pte) && vma_is_accessible(vmf->vma))\n\t\treturn do_numa_page(vmf);\n\n\tvmf->ptl = pte_lockptr(vmf->vma->vm_mm, vmf->pmd);\n\tspin_lock(vmf->ptl);\n\tentry = vmf->orig_pte;\n\tif (unlikely(!pte_same(*vmf->pte, entry)))\n\t\tgoto unlock;\n\tif (vmf->flags & FAULT_FLAG_WRITE) {\n\t\tif (!pte_write(entry))\n\t\t\treturn do_wp_page(vmf);\n\t\tentry = pte_mkdirty(entry);\n\t}\n\tentry = pte_mkyoung(entry);\n\tif (ptep_set_access_flags(vmf->vma, vmf->address, vmf->pte, entry,\n\t\t\t\tvmf->flags & FAULT_FLAG_WRITE)) {\n\t\tupdate_mmu_cache(vmf->vma, vmf->address, vmf->pte);\n\t} else {\n\t\t/*\n\t\t * This is needed only for protection faults but the arch code\n\t\t * is not yet telling us if this is a protection fault or not.\n\t\t * This still avoids useless tlb flushes for .text page faults\n\t\t * with threads.\n\t\t */\n\t\tif (vmf->flags & FAULT_FLAG_WRITE)\n\t\t\tflush_tlb_fix_spurious_fault(vmf->vma, vmf->address);\n\t}\nunlock:\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_pmd_set_accessed",
          "args": [
            "&vmf",
            "orig_pmd"
          ],
          "line": 3883
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pmd_set_accessed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1115-1134",
          "snippet": "void huge_pmd_set_accessed(struct vm_fault *vmf, pmd_t orig_pmd)\n{\n\tpmd_t entry;\n\tunsigned long haddr;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\n\tvmf->ptl = pmd_lock(vmf->vma->vm_mm, vmf->pmd);\n\tif (unlikely(!pmd_same(*vmf->pmd, orig_pmd)))\n\t\tgoto unlock;\n\n\tentry = pmd_mkyoung(orig_pmd);\n\tif (write)\n\t\tentry = pmd_mkdirty(entry);\n\thaddr = vmf->address & HPAGE_PMD_MASK;\n\tif (pmdp_set_access_flags(vmf->vma, haddr, vmf->pmd, entry, write))\n\t\tupdate_mmu_cache_pmd(vmf->vma, vmf->address, vmf->pmd);\n\nunlock:\n\tspin_unlock(vmf->ptl);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid huge_pmd_set_accessed(struct vm_fault *vmf, pmd_t orig_pmd)\n{\n\tpmd_t entry;\n\tunsigned long haddr;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\n\tvmf->ptl = pmd_lock(vmf->vma->vm_mm, vmf->pmd);\n\tif (unlikely(!pmd_same(*vmf->pmd, orig_pmd)))\n\t\tgoto unlock;\n\n\tentry = pmd_mkyoung(orig_pmd);\n\tif (write)\n\t\tentry = pmd_mkdirty(entry);\n\thaddr = vmf->address & HPAGE_PMD_MASK;\n\tif (pmdp_set_access_flags(vmf->vma, haddr, vmf->pmd, entry, write))\n\t\tupdate_mmu_cache_pmd(vmf->vma, vmf->address, vmf->pmd);\n\nunlock:\n\tspin_unlock(vmf->ptl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wp_huge_pmd",
          "args": [
            "&vmf",
            "orig_pmd"
          ],
          "line": 3879
        },
        "resolved": true,
        "details": {
          "function_name": "wp_huge_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3663-3675",
          "snippet": "static inline vm_fault_t wp_huge_pmd(struct vm_fault *vmf, pmd_t orig_pmd)\n{\n\tif (vma_is_anonymous(vmf->vma))\n\t\treturn do_huge_pmd_wp_page(vmf, orig_pmd);\n\tif (vmf->vma->vm_ops->huge_fault)\n\t\treturn vmf->vma->vm_ops->huge_fault(vmf, PE_SIZE_PMD);\n\n\t/* COW handled on pte level: split pmd */\n\tVM_BUG_ON_VMA(vmf->vma->vm_flags & VM_SHARED, vmf->vma);\n\t__split_huge_pmd(vmf->vma, vmf->pmd, vmf->address, false, NULL);\n\n\treturn VM_FAULT_FALLBACK;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline vm_fault_t wp_huge_pmd(struct vm_fault *vmf, pmd_t orig_pmd)\n{\n\tif (vma_is_anonymous(vmf->vma))\n\t\treturn do_huge_pmd_wp_page(vmf, orig_pmd);\n\tif (vmf->vma->vm_ops->huge_fault)\n\t\treturn vmf->vma->vm_ops->huge_fault(vmf, PE_SIZE_PMD);\n\n\t/* COW handled on pte level: split pmd */\n\tVM_BUG_ON_VMA(vmf->vma->vm_flags & VM_SHARED, vmf->vma);\n\t__split_huge_pmd(vmf->vma, vmf->pmd, vmf->address, false, NULL);\n\n\treturn VM_FAULT_FALLBACK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_write",
          "args": [
            "orig_pmd"
          ],
          "line": 3878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_huge_pmd_numa_page",
          "args": [
            "&vmf",
            "orig_pmd"
          ],
          "line": 3876
        },
        "resolved": true,
        "details": {
          "function_name": "do_huge_pmd_numa_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1477-1633",
          "snippet": "vm_fault_t do_huge_pmd_numa_page(struct vm_fault *vmf, pmd_t pmd)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct anon_vma *anon_vma = NULL;\n\tstruct page *page;\n\tunsigned long haddr = vmf->address & HPAGE_PMD_MASK;\n\tint page_nid = -1, this_nid = numa_node_id();\n\tint target_nid, last_cpupid = -1;\n\tbool page_locked;\n\tbool migrated = false;\n\tbool was_writable;\n\tint flags = 0;\n\n\tvmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);\n\tif (unlikely(!pmd_same(pmd, *vmf->pmd)))\n\t\tgoto out_unlock;\n\n\t/*\n\t * If there are potential migrations, wait for completion and retry\n\t * without disrupting NUMA hinting information. Do not relock and\n\t * check_same as the page may no longer be mapped.\n\t */\n\tif (unlikely(pmd_trans_migrating(*vmf->pmd))) {\n\t\tpage = pmd_page(*vmf->pmd);\n\t\tif (!get_page_unless_zero(page))\n\t\t\tgoto out_unlock;\n\t\tspin_unlock(vmf->ptl);\n\t\twait_on_page_locked(page);\n\t\tput_page(page);\n\t\tgoto out;\n\t}\n\n\tpage = pmd_page(pmd);\n\tBUG_ON(is_huge_zero_page(page));\n\tpage_nid = page_to_nid(page);\n\tlast_cpupid = page_cpupid_last(page);\n\tcount_vm_numa_event(NUMA_HINT_FAULTS);\n\tif (page_nid == this_nid) {\n\t\tcount_vm_numa_event(NUMA_HINT_FAULTS_LOCAL);\n\t\tflags |= TNF_FAULT_LOCAL;\n\t}\n\n\t/* See similar comment in do_numa_page for explanation */\n\tif (!pmd_savedwrite(pmd))\n\t\tflags |= TNF_NO_GROUP;\n\n\t/*\n\t * Acquire the page lock to serialise THP migrations but avoid dropping\n\t * page_table_lock if at all possible\n\t */\n\tpage_locked = trylock_page(page);\n\ttarget_nid = mpol_misplaced(page, vma, haddr);\n\tif (target_nid == -1) {\n\t\t/* If the page was locked, there are no parallel migrations */\n\t\tif (page_locked)\n\t\t\tgoto clear_pmdnuma;\n\t}\n\n\t/* Migration could have started since the pmd_trans_migrating check */\n\tif (!page_locked) {\n\t\tpage_nid = -1;\n\t\tif (!get_page_unless_zero(page))\n\t\t\tgoto out_unlock;\n\t\tspin_unlock(vmf->ptl);\n\t\twait_on_page_locked(page);\n\t\tput_page(page);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Page is misplaced. Page lock serialises migrations. Acquire anon_vma\n\t * to serialises splits\n\t */\n\tget_page(page);\n\tspin_unlock(vmf->ptl);\n\tanon_vma = page_lock_anon_vma_read(page);\n\n\t/* Confirm the PMD did not change while page_table_lock was released */\n\tspin_lock(vmf->ptl);\n\tif (unlikely(!pmd_same(pmd, *vmf->pmd))) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tpage_nid = -1;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Bail if we fail to protect against THP splits for any reason */\n\tif (unlikely(!anon_vma)) {\n\t\tput_page(page);\n\t\tpage_nid = -1;\n\t\tgoto clear_pmdnuma;\n\t}\n\n\t/*\n\t * Since we took the NUMA fault, we must have observed the !accessible\n\t * bit. Make sure all other CPUs agree with that, to avoid them\n\t * modifying the page we're about to migrate.\n\t *\n\t * Must be done under PTL such that we'll observe the relevant\n\t * inc_tlb_flush_pending().\n\t *\n\t * We are not sure a pending tlb flush here is for a huge page\n\t * mapping or not. Hence use the tlb range variant\n\t */\n\tif (mm_tlb_flush_pending(vma->vm_mm)) {\n\t\tflush_tlb_range(vma, haddr, haddr + HPAGE_PMD_SIZE);\n\t\t/*\n\t\t * change_huge_pmd() released the pmd lock before\n\t\t * invalidating the secondary MMUs sharing the primary\n\t\t * MMU pagetables (with ->invalidate_range()). The\n\t\t * mmu_notifier_invalidate_range_end() (which\n\t\t * internally calls ->invalidate_range()) in\n\t\t * change_pmd_range() will run after us, so we can't\n\t\t * rely on it here and we need an explicit invalidate.\n\t\t */\n\t\tmmu_notifier_invalidate_range(vma->vm_mm, haddr,\n\t\t\t\t\t      haddr + HPAGE_PMD_SIZE);\n\t}\n\n\t/*\n\t * Migrate the THP to the requested node, returns with page unlocked\n\t * and access rights restored.\n\t */\n\tspin_unlock(vmf->ptl);\n\n\tmigrated = migrate_misplaced_transhuge_page(vma->vm_mm, vma,\n\t\t\t\tvmf->pmd, pmd, vmf->address, page, target_nid);\n\tif (migrated) {\n\t\tflags |= TNF_MIGRATED;\n\t\tpage_nid = target_nid;\n\t} else\n\t\tflags |= TNF_MIGRATE_FAIL;\n\n\tgoto out;\nclear_pmdnuma:\n\tBUG_ON(!PageLocked(page));\n\twas_writable = pmd_savedwrite(pmd);\n\tpmd = pmd_modify(pmd, vma->vm_page_prot);\n\tpmd = pmd_mkyoung(pmd);\n\tif (was_writable)\n\t\tpmd = pmd_mkwrite(pmd);\n\tset_pmd_at(vma->vm_mm, haddr, vmf->pmd, pmd);\n\tupdate_mmu_cache_pmd(vma, vmf->address, vmf->pmd);\n\tunlock_page(page);\nout_unlock:\n\tspin_unlock(vmf->ptl);\n\nout:\n\tif (anon_vma)\n\t\tpage_unlock_anon_vma_read(anon_vma);\n\n\tif (page_nid != -1)\n\t\ttask_numa_fault(last_cpupid, page_nid, HPAGE_PMD_NR,\n\t\t\t\tflags);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvm_fault_t do_huge_pmd_numa_page(struct vm_fault *vmf, pmd_t pmd)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct anon_vma *anon_vma = NULL;\n\tstruct page *page;\n\tunsigned long haddr = vmf->address & HPAGE_PMD_MASK;\n\tint page_nid = -1, this_nid = numa_node_id();\n\tint target_nid, last_cpupid = -1;\n\tbool page_locked;\n\tbool migrated = false;\n\tbool was_writable;\n\tint flags = 0;\n\n\tvmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);\n\tif (unlikely(!pmd_same(pmd, *vmf->pmd)))\n\t\tgoto out_unlock;\n\n\t/*\n\t * If there are potential migrations, wait for completion and retry\n\t * without disrupting NUMA hinting information. Do not relock and\n\t * check_same as the page may no longer be mapped.\n\t */\n\tif (unlikely(pmd_trans_migrating(*vmf->pmd))) {\n\t\tpage = pmd_page(*vmf->pmd);\n\t\tif (!get_page_unless_zero(page))\n\t\t\tgoto out_unlock;\n\t\tspin_unlock(vmf->ptl);\n\t\twait_on_page_locked(page);\n\t\tput_page(page);\n\t\tgoto out;\n\t}\n\n\tpage = pmd_page(pmd);\n\tBUG_ON(is_huge_zero_page(page));\n\tpage_nid = page_to_nid(page);\n\tlast_cpupid = page_cpupid_last(page);\n\tcount_vm_numa_event(NUMA_HINT_FAULTS);\n\tif (page_nid == this_nid) {\n\t\tcount_vm_numa_event(NUMA_HINT_FAULTS_LOCAL);\n\t\tflags |= TNF_FAULT_LOCAL;\n\t}\n\n\t/* See similar comment in do_numa_page for explanation */\n\tif (!pmd_savedwrite(pmd))\n\t\tflags |= TNF_NO_GROUP;\n\n\t/*\n\t * Acquire the page lock to serialise THP migrations but avoid dropping\n\t * page_table_lock if at all possible\n\t */\n\tpage_locked = trylock_page(page);\n\ttarget_nid = mpol_misplaced(page, vma, haddr);\n\tif (target_nid == -1) {\n\t\t/* If the page was locked, there are no parallel migrations */\n\t\tif (page_locked)\n\t\t\tgoto clear_pmdnuma;\n\t}\n\n\t/* Migration could have started since the pmd_trans_migrating check */\n\tif (!page_locked) {\n\t\tpage_nid = -1;\n\t\tif (!get_page_unless_zero(page))\n\t\t\tgoto out_unlock;\n\t\tspin_unlock(vmf->ptl);\n\t\twait_on_page_locked(page);\n\t\tput_page(page);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Page is misplaced. Page lock serialises migrations. Acquire anon_vma\n\t * to serialises splits\n\t */\n\tget_page(page);\n\tspin_unlock(vmf->ptl);\n\tanon_vma = page_lock_anon_vma_read(page);\n\n\t/* Confirm the PMD did not change while page_table_lock was released */\n\tspin_lock(vmf->ptl);\n\tif (unlikely(!pmd_same(pmd, *vmf->pmd))) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tpage_nid = -1;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Bail if we fail to protect against THP splits for any reason */\n\tif (unlikely(!anon_vma)) {\n\t\tput_page(page);\n\t\tpage_nid = -1;\n\t\tgoto clear_pmdnuma;\n\t}\n\n\t/*\n\t * Since we took the NUMA fault, we must have observed the !accessible\n\t * bit. Make sure all other CPUs agree with that, to avoid them\n\t * modifying the page we're about to migrate.\n\t *\n\t * Must be done under PTL such that we'll observe the relevant\n\t * inc_tlb_flush_pending().\n\t *\n\t * We are not sure a pending tlb flush here is for a huge page\n\t * mapping or not. Hence use the tlb range variant\n\t */\n\tif (mm_tlb_flush_pending(vma->vm_mm)) {\n\t\tflush_tlb_range(vma, haddr, haddr + HPAGE_PMD_SIZE);\n\t\t/*\n\t\t * change_huge_pmd() released the pmd lock before\n\t\t * invalidating the secondary MMUs sharing the primary\n\t\t * MMU pagetables (with ->invalidate_range()). The\n\t\t * mmu_notifier_invalidate_range_end() (which\n\t\t * internally calls ->invalidate_range()) in\n\t\t * change_pmd_range() will run after us, so we can't\n\t\t * rely on it here and we need an explicit invalidate.\n\t\t */\n\t\tmmu_notifier_invalidate_range(vma->vm_mm, haddr,\n\t\t\t\t\t      haddr + HPAGE_PMD_SIZE);\n\t}\n\n\t/*\n\t * Migrate the THP to the requested node, returns with page unlocked\n\t * and access rights restored.\n\t */\n\tspin_unlock(vmf->ptl);\n\n\tmigrated = migrate_misplaced_transhuge_page(vma->vm_mm, vma,\n\t\t\t\tvmf->pmd, pmd, vmf->address, page, target_nid);\n\tif (migrated) {\n\t\tflags |= TNF_MIGRATED;\n\t\tpage_nid = target_nid;\n\t} else\n\t\tflags |= TNF_MIGRATE_FAIL;\n\n\tgoto out;\nclear_pmdnuma:\n\tBUG_ON(!PageLocked(page));\n\twas_writable = pmd_savedwrite(pmd);\n\tpmd = pmd_modify(pmd, vma->vm_page_prot);\n\tpmd = pmd_mkyoung(pmd);\n\tif (was_writable)\n\t\tpmd = pmd_mkwrite(pmd);\n\tset_pmd_at(vma->vm_mm, haddr, vmf->pmd, pmd);\n\tupdate_mmu_cache_pmd(vma, vmf->address, vmf->pmd);\n\tunlock_page(page);\nout_unlock:\n\tspin_unlock(vmf->ptl);\n\nout:\n\tif (anon_vma)\n\t\tpage_unlock_anon_vma_read(anon_vma);\n\n\tif (page_nid != -1)\n\t\ttask_numa_fault(last_cpupid, page_nid, HPAGE_PMD_NR,\n\t\t\t\tflags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_is_accessible",
          "args": [
            "vma"
          ],
          "line": 3875
        },
        "resolved": true,
        "details": {
          "function_name": "vma_is_accessible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3677-3680",
          "snippet": "static inline bool vma_is_accessible(struct vm_area_struct *vma)\n{\n\treturn vma->vm_flags & (VM_READ | VM_EXEC | VM_WRITE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline bool vma_is_accessible(struct vm_area_struct *vma)\n{\n\treturn vma->vm_flags & (VM_READ | VM_EXEC | VM_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_protnone",
          "args": [
            "orig_pmd"
          ],
          "line": 3875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_devmap",
          "args": [
            "orig_pmd"
          ],
          "line": 3874
        },
        "resolved": true,
        "details": {
          "function_name": "pmd_devmap_trans_unstable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3023-3026",
          "snippet": "static int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "orig_pmd"
          ],
          "line": 3874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_migration_entry_wait",
          "args": [
            "mm",
            "vmf.pmd"
          ],
          "line": 3871
        },
        "resolved": true,
        "details": {
          "function_name": "pmd_migration_entry_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "361-378",
          "snippet": "void pmd_migration_entry_wait(struct mm_struct *mm, pmd_t *pmd)\n{\n\tspinlock_t *ptl;\n\tstruct page *page;\n\n\tptl = pmd_lock(mm, pmd);\n\tif (!is_pmd_migration_entry(*pmd))\n\t\tgoto unlock;\n\tpage = migration_entry_to_page(pmd_to_swp_entry(*pmd));\n\tif (!get_page_unless_zero(page))\n\t\tgoto unlock;\n\tspin_unlock(ptl);\n\twait_on_page_locked(page);\n\tput_page(page);\n\treturn;\nunlock:\n\tspin_unlock(ptl);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid pmd_migration_entry_wait(struct mm_struct *mm, pmd_t *pmd)\n{\n\tspinlock_t *ptl;\n\tstruct page *page;\n\n\tptl = pmd_lock(mm, pmd);\n\tif (!is_pmd_migration_entry(*pmd))\n\t\tgoto unlock;\n\tpage = migration_entry_to_page(pmd_to_swp_entry(*pmd));\n\tif (!get_page_unless_zero(page))\n\t\tgoto unlock;\n\tspin_unlock(ptl);\n\twait_on_page_locked(page);\n\tput_page(page);\n\treturn;\nunlock:\n\tspin_unlock(ptl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_pmd_migration_entry",
          "args": [
            "orig_pmd"
          ],
          "line": 3870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "thp_migration_supported() &&\n\t\t\t\t\t  !is_pmd_migration_entry(orig_pmd)"
          ],
          "line": 3868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_pmd_migration_entry",
          "args": [
            "orig_pmd"
          ],
          "line": 3869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thp_migration_supported",
          "args": [],
          "line": 3868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_swap_pmd(orig_pmd)"
          ],
          "line": 3867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swap_pmd",
          "args": [
            "orig_pmd"
          ],
          "line": 3867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 3866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_huge_pmd",
          "args": [
            "&vmf"
          ],
          "line": 3860
        },
        "resolved": true,
        "details": {
          "function_name": "create_huge_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3653-3660",
          "snippet": "static inline vm_fault_t create_huge_pmd(struct vm_fault *vmf)\n{\n\tif (vma_is_anonymous(vmf->vma))\n\t\treturn do_huge_pmd_anonymous_page(vmf);\n\tif (vmf->vma->vm_ops->huge_fault)\n\t\treturn vmf->vma->vm_ops->huge_fault(vmf, PE_SIZE_PMD);\n\treturn VM_FAULT_FALLBACK;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline vm_fault_t create_huge_pmd(struct vm_fault *vmf)\n{\n\tif (vma_is_anonymous(vmf->vma))\n\t\treturn do_huge_pmd_anonymous_page(vmf);\n\tif (vmf->vma->vm_ops->huge_fault)\n\t\treturn vmf->vma->vm_ops->huge_fault(vmf, PE_SIZE_PMD);\n\treturn VM_FAULT_FALLBACK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "transparent_hugepage_enabled",
          "args": [
            "vma"
          ],
          "line": 3859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "*vmf.pmd"
          ],
          "line": 3859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_alloc",
          "args": [
            "mm",
            "vmf.pud",
            "address"
          ],
          "line": 3856
        },
        "resolved": true,
        "details": {
          "function_name": "__pmd_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "4004-4029",
          "snippet": "int __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tptl = pud_lock(mm, pud);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (!pud_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpud_populate(mm, pud, new);\n\t} else\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n#else\n\tif (!pgd_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpgd_populate(mm, pud, new);\n\t} else /* Another has populated it */\n\t\tpmd_free(mm, new);\n#endif /* __ARCH_HAS_4LEVEL_HACK */\n\tspin_unlock(ptl);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tptl = pud_lock(mm, pud);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (!pud_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpud_populate(mm, pud, new);\n\t} else\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n#else\n\tif (!pgd_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpgd_populate(mm, pud, new);\n\t} else /* Another has populated it */\n\t\tpmd_free(mm, new);\n#endif /* __ARCH_HAS_4LEVEL_HACK */\n\tspin_unlock(ptl);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_pud_set_accessed",
          "args": [
            "&vmf",
            "orig_pud"
          ],
          "line": 3850
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pud_set_accessed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1093-1112",
          "snippet": "void huge_pud_set_accessed(struct vm_fault *vmf, pud_t orig_pud)\n{\n\tpud_t entry;\n\tunsigned long haddr;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\n\tvmf->ptl = pud_lock(vmf->vma->vm_mm, vmf->pud);\n\tif (unlikely(!pud_same(*vmf->pud, orig_pud)))\n\t\tgoto unlock;\n\n\tentry = pud_mkyoung(orig_pud);\n\tif (write)\n\t\tentry = pud_mkdirty(entry);\n\thaddr = vmf->address & HPAGE_PUD_MASK;\n\tif (pudp_set_access_flags(vmf->vma, haddr, vmf->pud, entry, write))\n\t\tupdate_mmu_cache_pud(vmf->vma, vmf->address, vmf->pud);\n\nunlock:\n\tspin_unlock(vmf->ptl);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid huge_pud_set_accessed(struct vm_fault *vmf, pud_t orig_pud)\n{\n\tpud_t entry;\n\tunsigned long haddr;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\n\tvmf->ptl = pud_lock(vmf->vma->vm_mm, vmf->pud);\n\tif (unlikely(!pud_same(*vmf->pud, orig_pud)))\n\t\tgoto unlock;\n\n\tentry = pud_mkyoung(orig_pud);\n\tif (write)\n\t\tentry = pud_mkdirty(entry);\n\thaddr = vmf->address & HPAGE_PUD_MASK;\n\tif (pudp_set_access_flags(vmf->vma, haddr, vmf->pud, entry, write))\n\t\tupdate_mmu_cache_pud(vmf->vma, vmf->address, vmf->pud);\n\nunlock:\n\tspin_unlock(vmf->ptl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wp_huge_pud",
          "args": [
            "&vmf",
            "orig_pud"
          ],
          "line": 3846
        },
        "resolved": true,
        "details": {
          "function_name": "wp_huge_pud",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3694-3704",
          "snippet": "static vm_fault_t wp_huge_pud(struct vm_fault *vmf, pud_t orig_pud)\n{\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t/* No support for anonymous transparent PUD pages yet */\n\tif (vma_is_anonymous(vmf->vma))\n\t\treturn VM_FAULT_FALLBACK;\n\tif (vmf->vma->vm_ops->huge_fault)\n\t\treturn vmf->vma->vm_ops->huge_fault(vmf, PE_SIZE_PUD);\n#endif /* CONFIG_TRANSPARENT_HUGEPAGE */\n\treturn VM_FAULT_FALLBACK;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t wp_huge_pud(struct vm_fault *vmf, pud_t orig_pud)\n{\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t/* No support for anonymous transparent PUD pages yet */\n\tif (vma_is_anonymous(vmf->vma))\n\t\treturn VM_FAULT_FALLBACK;\n\tif (vmf->vma->vm_ops->huge_fault)\n\t\treturn vmf->vma->vm_ops->huge_fault(vmf, PE_SIZE_PUD);\n#endif /* CONFIG_TRANSPARENT_HUGEPAGE */\n\treturn VM_FAULT_FALLBACK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pud_write",
          "args": [
            "orig_pud"
          ],
          "line": 3845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_devmap",
          "args": [
            "orig_pud"
          ],
          "line": 3841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_trans_huge",
          "args": [
            "orig_pud"
          ],
          "line": 3841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 3840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_huge_pud",
          "args": [
            "&vmf"
          ],
          "line": 3834
        },
        "resolved": true,
        "details": {
          "function_name": "create_huge_pud",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3682-3692",
          "snippet": "static vm_fault_t create_huge_pud(struct vm_fault *vmf)\n{\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t/* No support for anonymous transparent PUD pages yet */\n\tif (vma_is_anonymous(vmf->vma))\n\t\treturn VM_FAULT_FALLBACK;\n\tif (vmf->vma->vm_ops->huge_fault)\n\t\treturn vmf->vma->vm_ops->huge_fault(vmf, PE_SIZE_PUD);\n#endif /* CONFIG_TRANSPARENT_HUGEPAGE */\n\treturn VM_FAULT_FALLBACK;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t create_huge_pud(struct vm_fault *vmf)\n{\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t/* No support for anonymous transparent PUD pages yet */\n\tif (vma_is_anonymous(vmf->vma))\n\t\treturn VM_FAULT_FALLBACK;\n\tif (vmf->vma->vm_ops->huge_fault)\n\t\treturn vmf->vma->vm_ops->huge_fault(vmf, PE_SIZE_PUD);\n#endif /* CONFIG_TRANSPARENT_HUGEPAGE */\n\treturn VM_FAULT_FALLBACK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "transparent_hugepage_enabled",
          "args": [
            "vma"
          ],
          "line": 3833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_none",
          "args": [
            "*vmf.pud"
          ],
          "line": 3833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_alloc",
          "args": [
            "mm",
            "p4d",
            "address"
          ],
          "line": 3830
        },
        "resolved": true,
        "details": {
          "function_name": "__pud_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3972-3996",
          "snippet": "int __pud_alloc(struct mm_struct *mm, p4d_t *p4d, unsigned long address)\n{\n\tpud_t *new = pud_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_5LEVEL_HACK\n\tif (!p4d_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tp4d_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#else\n\tif (!pgd_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tpgd_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#endif /* __ARCH_HAS_5LEVEL_HACK */\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pud_alloc(struct mm_struct *mm, p4d_t *p4d, unsigned long address)\n{\n\tpud_t *new = pud_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_5LEVEL_HACK\n\tif (!p4d_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tp4d_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#else\n\tif (!pgd_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tpgd_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#endif /* __ARCH_HAS_5LEVEL_HACK */\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p4d_alloc",
          "args": [
            "mm",
            "pgd",
            "address"
          ],
          "line": 3826
        },
        "resolved": true,
        "details": {
          "function_name": "__p4d_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3949-3964",
          "snippet": "int __p4d_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)\n{\n\tp4d_t *new = p4d_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n\tif (pgd_present(*pgd))\t\t/* Another has populated it */\n\t\tp4d_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pgd, new);\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __p4d_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)\n{\n\tp4d_t *new = p4d_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n\tif (pgd_present(*pgd))\t\t/* Another has populated it */\n\t\tp4d_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pgd, new);\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgd_offset",
          "args": [
            "mm",
            "address"
          ],
          "line": 3825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_fault_gfp_mask",
          "args": [
            "vma"
          ],
          "line": 3817
        },
        "resolved": true,
        "details": {
          "function_name": "__get_fault_gfp_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2116-2128",
          "snippet": "static gfp_t __get_fault_gfp_mask(struct vm_area_struct *vma)\n{\n\tstruct file *vm_file = vma->vm_file;\n\n\tif (vm_file)\n\t\treturn mapping_gfp_mask(vm_file->f_mapping) | __GFP_FS | __GFP_IO;\n\n\t/*\n\t * Special mappings (e.g. VDSO) do not have any file so fake\n\t * a default GFP_KERNEL for them.\n\t */\n\treturn GFP_KERNEL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic gfp_t __get_fault_gfp_mask(struct vm_area_struct *vma)\n{\n\tstruct file *vm_file = vma->vm_file;\n\n\tif (vm_file)\n\t\treturn mapping_gfp_mask(vm_file->f_mapping) | __GFP_FS | __GFP_IO;\n\n\t/*\n\t * Special mappings (e.g. VDSO) do not have any file so fake\n\t * a default GFP_KERNEL for them.\n\t */\n\treturn GFP_KERNEL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "linear_page_index",
          "args": [
            "vma",
            "address"
          ],
          "line": 3816
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t __handle_mm_fault(struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int flags)\n{\n\tstruct vm_fault vmf = {\n\t\t.vma = vma,\n\t\t.address = address & PAGE_MASK,\n\t\t.flags = flags,\n\t\t.pgoff = linear_page_index(vma, address),\n\t\t.gfp_mask = __get_fault_gfp_mask(vma),\n\t};\n\tunsigned int dirty = flags & FAULT_FLAG_WRITE;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tvm_fault_t ret;\n\n\tpgd = pgd_offset(mm, address);\n\tp4d = p4d_alloc(mm, pgd, address);\n\tif (!p4d)\n\t\treturn VM_FAULT_OOM;\n\n\tvmf.pud = pud_alloc(mm, p4d, address);\n\tif (!vmf.pud)\n\t\treturn VM_FAULT_OOM;\n\tif (pud_none(*vmf.pud) && transparent_hugepage_enabled(vma)) {\n\t\tret = create_huge_pud(&vmf);\n\t\tif (!(ret & VM_FAULT_FALLBACK))\n\t\t\treturn ret;\n\t} else {\n\t\tpud_t orig_pud = *vmf.pud;\n\n\t\tbarrier();\n\t\tif (pud_trans_huge(orig_pud) || pud_devmap(orig_pud)) {\n\n\t\t\t/* NUMA case for anonymous PUDs would go here */\n\n\t\t\tif (dirty && !pud_write(orig_pud)) {\n\t\t\t\tret = wp_huge_pud(&vmf, orig_pud);\n\t\t\t\tif (!(ret & VM_FAULT_FALLBACK))\n\t\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\thuge_pud_set_accessed(&vmf, orig_pud);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvmf.pmd = pmd_alloc(mm, vmf.pud, address);\n\tif (!vmf.pmd)\n\t\treturn VM_FAULT_OOM;\n\tif (pmd_none(*vmf.pmd) && transparent_hugepage_enabled(vma)) {\n\t\tret = create_huge_pmd(&vmf);\n\t\tif (!(ret & VM_FAULT_FALLBACK))\n\t\t\treturn ret;\n\t} else {\n\t\tpmd_t orig_pmd = *vmf.pmd;\n\n\t\tbarrier();\n\t\tif (unlikely(is_swap_pmd(orig_pmd))) {\n\t\t\tVM_BUG_ON(thp_migration_supported() &&\n\t\t\t\t\t  !is_pmd_migration_entry(orig_pmd));\n\t\t\tif (is_pmd_migration_entry(orig_pmd))\n\t\t\t\tpmd_migration_entry_wait(mm, vmf.pmd);\n\t\t\treturn 0;\n\t\t}\n\t\tif (pmd_trans_huge(orig_pmd) || pmd_devmap(orig_pmd)) {\n\t\t\tif (pmd_protnone(orig_pmd) && vma_is_accessible(vma))\n\t\t\t\treturn do_huge_pmd_numa_page(&vmf, orig_pmd);\n\n\t\t\tif (dirty && !pmd_write(orig_pmd)) {\n\t\t\t\tret = wp_huge_pmd(&vmf, orig_pmd);\n\t\t\t\tif (!(ret & VM_FAULT_FALLBACK))\n\t\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\thuge_pmd_set_accessed(&vmf, orig_pmd);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn handle_pte_fault(&vmf);\n}"
  },
  {
    "function_name": "handle_pte_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3721-3801",
    "snippet": "static vm_fault_t handle_pte_fault(struct vm_fault *vmf)\n{\n\tpte_t entry;\n\n\tif (unlikely(pmd_none(*vmf->pmd))) {\n\t\t/*\n\t\t * Leave __pte_alloc() until later: because vm_ops->fault may\n\t\t * want to allocate huge page, and if we expose page table\n\t\t * for an instant, it will be difficult to retract from\n\t\t * concurrent faults and from rmap lookups.\n\t\t */\n\t\tvmf->pte = NULL;\n\t} else {\n\t\t/* See comment in pte_alloc_one_map() */\n\t\tif (pmd_devmap_trans_unstable(vmf->pmd))\n\t\t\treturn 0;\n\t\t/*\n\t\t * A regular pmd is established and it can't morph into a huge\n\t\t * pmd from under us anymore at this point because we hold the\n\t\t * mmap_sem read mode and khugepaged takes it in write mode.\n\t\t * So now it's safe to run pte_offset_map().\n\t\t */\n\t\tvmf->pte = pte_offset_map(vmf->pmd, vmf->address);\n\t\tvmf->orig_pte = *vmf->pte;\n\n\t\t/*\n\t\t * some architectures can have larger ptes than wordsize,\n\t\t * e.g.ppc44x-defconfig has CONFIG_PTE_64BIT=y and\n\t\t * CONFIG_32BIT=y, so READ_ONCE cannot guarantee atomic\n\t\t * accesses.  The code below just needs a consistent view\n\t\t * for the ifs and we later double check anyway with the\n\t\t * ptl lock held. So here a barrier will do.\n\t\t */\n\t\tbarrier();\n\t\tif (pte_none(vmf->orig_pte)) {\n\t\t\tpte_unmap(vmf->pte);\n\t\t\tvmf->pte = NULL;\n\t\t}\n\t}\n\n\tif (!vmf->pte) {\n\t\tif (vma_is_anonymous(vmf->vma))\n\t\t\treturn do_anonymous_page(vmf);\n\t\telse\n\t\t\treturn do_fault(vmf);\n\t}\n\n\tif (!pte_present(vmf->orig_pte))\n\t\treturn do_swap_page(vmf);\n\n\tif (pte_protnone(vmf->orig_pte) && vma_is_accessible(vmf->vma))\n\t\treturn do_numa_page(vmf);\n\n\tvmf->ptl = pte_lockptr(vmf->vma->vm_mm, vmf->pmd);\n\tspin_lock(vmf->ptl);\n\tentry = vmf->orig_pte;\n\tif (unlikely(!pte_same(*vmf->pte, entry)))\n\t\tgoto unlock;\n\tif (vmf->flags & FAULT_FLAG_WRITE) {\n\t\tif (!pte_write(entry))\n\t\t\treturn do_wp_page(vmf);\n\t\tentry = pte_mkdirty(entry);\n\t}\n\tentry = pte_mkyoung(entry);\n\tif (ptep_set_access_flags(vmf->vma, vmf->address, vmf->pte, entry,\n\t\t\t\tvmf->flags & FAULT_FLAG_WRITE)) {\n\t\tupdate_mmu_cache(vmf->vma, vmf->address, vmf->pte);\n\t} else {\n\t\t/*\n\t\t * This is needed only for protection faults but the arch code\n\t\t * is not yet telling us if this is a protection fault or not.\n\t\t * This still avoids useless tlb flushes for .text page faults\n\t\t * with threads.\n\t\t */\n\t\tif (vmf->flags & FAULT_FLAG_WRITE)\n\t\t\tflush_tlb_fix_spurious_fault(vmf->vma, vmf->address);\n\t}\nunlock:\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "vmf->pte",
            "vmf->ptl"
          ],
          "line": 3799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_tlb_fix_spurious_fault",
          "args": [
            "vmf->vma",
            "vmf->address"
          ],
          "line": 3796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_mmu_cache",
          "args": [
            "vmf->vma",
            "vmf->address",
            "vmf->pte"
          ],
          "line": 3787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptep_set_access_flags",
          "args": [
            "vmf->vma",
            "vmf->address",
            "vmf->pte",
            "entry",
            "vmf->flags & FAULT_FLAG_WRITE"
          ],
          "line": 3785
        },
        "resolved": true,
        "details": {
          "function_name": "ptep_set_access_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "55-65",
          "snippet": "int ptep_set_access_flags(struct vm_area_struct *vma,\n\t\t\t  unsigned long address, pte_t *ptep,\n\t\t\t  pte_t entry, int dirty)\n{\n\tint changed = !pte_same(*ptep, entry);\n\tif (changed) {\n\t\tset_pte_at(vma->vm_mm, address, ptep, entry);\n\t\tflush_tlb_fix_spurious_fault(vma, address);\n\t}\n\treturn changed;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\nint ptep_set_access_flags(struct vm_area_struct *vma,\n\t\t\t  unsigned long address, pte_t *ptep,\n\t\t\t  pte_t entry, int dirty)\n{\n\tint changed = !pte_same(*ptep, entry);\n\tif (changed) {\n\t\tset_pte_at(vma->vm_mm, address, ptep, entry);\n\t\tflush_tlb_fix_spurious_fault(vma, address);\n\t}\n\treturn changed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_mkyoung",
          "args": [
            "entry"
          ],
          "line": 3784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkdirty",
          "args": [
            "entry"
          ],
          "line": 3782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_wp_page",
          "args": [
            "vmf"
          ],
          "line": 3781
        },
        "resolved": true,
        "details": {
          "function_name": "do_wp_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2480-2550",
          "snippet": "static vm_fault_t do_wp_page(struct vm_fault *vmf)\n\t__releases(vmf->ptl)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\n\tvmf->page = vm_normal_page(vma, vmf->address, vmf->orig_pte);\n\tif (!vmf->page) {\n\t\t/*\n\t\t * VM_MIXEDMAP !pfn_valid() case, or VM_SOFTDIRTY clear on a\n\t\t * VM_PFNMAP VMA.\n\t\t *\n\t\t * We should not cow pages in a shared writeable mapping.\n\t\t * Just mark the pages writable and/or call ops->pfn_mkwrite.\n\t\t */\n\t\tif ((vma->vm_flags & (VM_WRITE|VM_SHARED)) ==\n\t\t\t\t     (VM_WRITE|VM_SHARED))\n\t\t\treturn wp_pfn_shared(vmf);\n\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\treturn wp_page_copy(vmf);\n\t}\n\n\t/*\n\t * Take out anonymous pages first, anonymous shared vmas are\n\t * not dirty accountable.\n\t */\n\tif (PageAnon(vmf->page) && !PageKsm(vmf->page)) {\n\t\tint total_map_swapcount;\n\t\tif (!trylock_page(vmf->page)) {\n\t\t\tget_page(vmf->page);\n\t\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\t\tlock_page(vmf->page);\n\t\t\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd,\n\t\t\t\t\tvmf->address, &vmf->ptl);\n\t\t\tif (!pte_same(*vmf->pte, vmf->orig_pte)) {\n\t\t\t\tunlock_page(vmf->page);\n\t\t\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\t\t\tput_page(vmf->page);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tput_page(vmf->page);\n\t\t}\n\t\tif (reuse_swap_page(vmf->page, &total_map_swapcount)) {\n\t\t\tif (total_map_swapcount == 1) {\n\t\t\t\t/*\n\t\t\t\t * The page is all ours. Move it to\n\t\t\t\t * our anon_vma so the rmap code will\n\t\t\t\t * not search our parent or siblings.\n\t\t\t\t * Protected against the rmap code by\n\t\t\t\t * the page lock.\n\t\t\t\t */\n\t\t\t\tpage_move_anon_rmap(vmf->page, vma);\n\t\t\t}\n\t\t\tunlock_page(vmf->page);\n\t\t\twp_page_reuse(vmf);\n\t\t\treturn VM_FAULT_WRITE;\n\t\t}\n\t\tunlock_page(vmf->page);\n\t} else if (unlikely((vma->vm_flags & (VM_WRITE|VM_SHARED)) ==\n\t\t\t\t\t(VM_WRITE|VM_SHARED))) {\n\t\treturn wp_page_shared(vmf);\n\t}\n\n\t/*\n\t * Ok, we need to copy. Oh, well..\n\t */\n\tget_page(vmf->page);\n\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\treturn wp_page_copy(vmf);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t do_wp_page(struct vm_fault *vmf)\n\t__releases(vmf->ptl)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\n\tvmf->page = vm_normal_page(vma, vmf->address, vmf->orig_pte);\n\tif (!vmf->page) {\n\t\t/*\n\t\t * VM_MIXEDMAP !pfn_valid() case, or VM_SOFTDIRTY clear on a\n\t\t * VM_PFNMAP VMA.\n\t\t *\n\t\t * We should not cow pages in a shared writeable mapping.\n\t\t * Just mark the pages writable and/or call ops->pfn_mkwrite.\n\t\t */\n\t\tif ((vma->vm_flags & (VM_WRITE|VM_SHARED)) ==\n\t\t\t\t     (VM_WRITE|VM_SHARED))\n\t\t\treturn wp_pfn_shared(vmf);\n\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\treturn wp_page_copy(vmf);\n\t}\n\n\t/*\n\t * Take out anonymous pages first, anonymous shared vmas are\n\t * not dirty accountable.\n\t */\n\tif (PageAnon(vmf->page) && !PageKsm(vmf->page)) {\n\t\tint total_map_swapcount;\n\t\tif (!trylock_page(vmf->page)) {\n\t\t\tget_page(vmf->page);\n\t\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\t\tlock_page(vmf->page);\n\t\t\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd,\n\t\t\t\t\tvmf->address, &vmf->ptl);\n\t\t\tif (!pte_same(*vmf->pte, vmf->orig_pte)) {\n\t\t\t\tunlock_page(vmf->page);\n\t\t\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\t\t\tput_page(vmf->page);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tput_page(vmf->page);\n\t\t}\n\t\tif (reuse_swap_page(vmf->page, &total_map_swapcount)) {\n\t\t\tif (total_map_swapcount == 1) {\n\t\t\t\t/*\n\t\t\t\t * The page is all ours. Move it to\n\t\t\t\t * our anon_vma so the rmap code will\n\t\t\t\t * not search our parent or siblings.\n\t\t\t\t * Protected against the rmap code by\n\t\t\t\t * the page lock.\n\t\t\t\t */\n\t\t\t\tpage_move_anon_rmap(vmf->page, vma);\n\t\t\t}\n\t\t\tunlock_page(vmf->page);\n\t\t\twp_page_reuse(vmf);\n\t\t\treturn VM_FAULT_WRITE;\n\t\t}\n\t\tunlock_page(vmf->page);\n\t} else if (unlikely((vma->vm_flags & (VM_WRITE|VM_SHARED)) ==\n\t\t\t\t\t(VM_WRITE|VM_SHARED))) {\n\t\treturn wp_page_shared(vmf);\n\t}\n\n\t/*\n\t * Ok, we need to copy. Oh, well..\n\t */\n\tget_page(vmf->page);\n\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\treturn wp_page_copy(vmf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_write",
          "args": [
            "entry"
          ],
          "line": 3780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pte_same(*vmf->pte, entry)"
          ],
          "line": 3777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_same",
          "args": [
            "*vmf->pte",
            "entry"
          ],
          "line": 3777
        },
        "resolved": true,
        "details": {
          "function_name": "pte_same_as_swp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1735-1738",
          "snippet": "static inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "vmf->ptl"
          ],
          "line": 3775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_lockptr",
          "args": [
            "vmf->vma->vm_mm",
            "vmf->pmd"
          ],
          "line": 3774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_numa_page",
          "args": [
            "vmf"
          ],
          "line": 3772
        },
        "resolved": true,
        "details": {
          "function_name": "do_numa_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3563-3651",
          "snippet": "static vm_fault_t do_numa_page(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page = NULL;\n\tint page_nid = -1;\n\tint last_cpupid;\n\tint target_nid;\n\tbool migrated = false;\n\tpte_t pte;\n\tbool was_writable = pte_savedwrite(vmf->orig_pte);\n\tint flags = 0;\n\n\t/*\n\t * The \"pte\" at this point cannot be used safely without\n\t * validation through pte_unmap_same(). It's of NUMA type but\n\t * the pfn may be screwed if the read is non atomic.\n\t */\n\tvmf->ptl = pte_lockptr(vma->vm_mm, vmf->pmd);\n\tspin_lock(vmf->ptl);\n\tif (unlikely(!pte_same(*vmf->pte, vmf->orig_pte))) {\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Make it present again, Depending on how arch implementes non\n\t * accessible ptes, some can allow access by kernel mode.\n\t */\n\tpte = ptep_modify_prot_start(vma->vm_mm, vmf->address, vmf->pte);\n\tpte = pte_modify(pte, vma->vm_page_prot);\n\tpte = pte_mkyoung(pte);\n\tif (was_writable)\n\t\tpte = pte_mkwrite(pte);\n\tptep_modify_prot_commit(vma->vm_mm, vmf->address, vmf->pte, pte);\n\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\n\n\tpage = vm_normal_page(vma, vmf->address, pte);\n\tif (!page) {\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\treturn 0;\n\t}\n\n\t/* TODO: handle PTE-mapped THP */\n\tif (PageCompound(page)) {\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Avoid grouping on RO pages in general. RO pages shouldn't hurt as\n\t * much anyway since they can be in shared cache state. This misses\n\t * the case where a mapping is writable but the process never writes\n\t * to it but pte_write gets cleared during protection updates and\n\t * pte_dirty has unpredictable behaviour between PTE scan updates,\n\t * background writeback, dirty balancing and application behaviour.\n\t */\n\tif (!pte_write(pte))\n\t\tflags |= TNF_NO_GROUP;\n\n\t/*\n\t * Flag if the page is shared between multiple address spaces. This\n\t * is later used when determining whether to group tasks together\n\t */\n\tif (page_mapcount(page) > 1 && (vma->vm_flags & VM_SHARED))\n\t\tflags |= TNF_SHARED;\n\n\tlast_cpupid = page_cpupid_last(page);\n\tpage_nid = page_to_nid(page);\n\ttarget_nid = numa_migrate_prep(page, vma, vmf->address, page_nid,\n\t\t\t&flags);\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\tif (target_nid == -1) {\n\t\tput_page(page);\n\t\tgoto out;\n\t}\n\n\t/* Migrate to the requested node */\n\tmigrated = migrate_misplaced_page(page, vma, target_nid);\n\tif (migrated) {\n\t\tpage_nid = target_nid;\n\t\tflags |= TNF_MIGRATED;\n\t} else\n\t\tflags |= TNF_MIGRATE_FAIL;\n\nout:\n\tif (page_nid != -1)\n\t\ttask_numa_fault(last_cpupid, page_nid, 1, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t do_numa_page(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page = NULL;\n\tint page_nid = -1;\n\tint last_cpupid;\n\tint target_nid;\n\tbool migrated = false;\n\tpte_t pte;\n\tbool was_writable = pte_savedwrite(vmf->orig_pte);\n\tint flags = 0;\n\n\t/*\n\t * The \"pte\" at this point cannot be used safely without\n\t * validation through pte_unmap_same(). It's of NUMA type but\n\t * the pfn may be screwed if the read is non atomic.\n\t */\n\tvmf->ptl = pte_lockptr(vma->vm_mm, vmf->pmd);\n\tspin_lock(vmf->ptl);\n\tif (unlikely(!pte_same(*vmf->pte, vmf->orig_pte))) {\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Make it present again, Depending on how arch implementes non\n\t * accessible ptes, some can allow access by kernel mode.\n\t */\n\tpte = ptep_modify_prot_start(vma->vm_mm, vmf->address, vmf->pte);\n\tpte = pte_modify(pte, vma->vm_page_prot);\n\tpte = pte_mkyoung(pte);\n\tif (was_writable)\n\t\tpte = pte_mkwrite(pte);\n\tptep_modify_prot_commit(vma->vm_mm, vmf->address, vmf->pte, pte);\n\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\n\n\tpage = vm_normal_page(vma, vmf->address, pte);\n\tif (!page) {\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\treturn 0;\n\t}\n\n\t/* TODO: handle PTE-mapped THP */\n\tif (PageCompound(page)) {\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Avoid grouping on RO pages in general. RO pages shouldn't hurt as\n\t * much anyway since they can be in shared cache state. This misses\n\t * the case where a mapping is writable but the process never writes\n\t * to it but pte_write gets cleared during protection updates and\n\t * pte_dirty has unpredictable behaviour between PTE scan updates,\n\t * background writeback, dirty balancing and application behaviour.\n\t */\n\tif (!pte_write(pte))\n\t\tflags |= TNF_NO_GROUP;\n\n\t/*\n\t * Flag if the page is shared between multiple address spaces. This\n\t * is later used when determining whether to group tasks together\n\t */\n\tif (page_mapcount(page) > 1 && (vma->vm_flags & VM_SHARED))\n\t\tflags |= TNF_SHARED;\n\n\tlast_cpupid = page_cpupid_last(page);\n\tpage_nid = page_to_nid(page);\n\ttarget_nid = numa_migrate_prep(page, vma, vmf->address, page_nid,\n\t\t\t&flags);\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\tif (target_nid == -1) {\n\t\tput_page(page);\n\t\tgoto out;\n\t}\n\n\t/* Migrate to the requested node */\n\tmigrated = migrate_misplaced_page(page, vma, target_nid);\n\tif (migrated) {\n\t\tpage_nid = target_nid;\n\t\tflags |= TNF_MIGRATED;\n\t} else\n\t\tflags |= TNF_MIGRATE_FAIL;\n\nout:\n\tif (page_nid != -1)\n\t\ttask_numa_fault(last_cpupid, page_nid, 1, flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_is_accessible",
          "args": [
            "vmf->vma"
          ],
          "line": 3771
        },
        "resolved": true,
        "details": {
          "function_name": "vma_is_accessible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3677-3680",
          "snippet": "static inline bool vma_is_accessible(struct vm_area_struct *vma)\n{\n\treturn vma->vm_flags & (VM_READ | VM_EXEC | VM_WRITE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline bool vma_is_accessible(struct vm_area_struct *vma)\n{\n\treturn vma->vm_flags & (VM_READ | VM_EXEC | VM_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_protnone",
          "args": [
            "vmf->orig_pte"
          ],
          "line": 3771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_swap_page",
          "args": [
            "vmf"
          ],
          "line": 3769
        },
        "resolved": true,
        "details": {
          "function_name": "do_swap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2656-2869",
          "snippet": "vm_fault_t do_swap_page(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page = NULL, *swapcache;\n\tstruct mem_cgroup *memcg;\n\tswp_entry_t entry;\n\tpte_t pte;\n\tint locked;\n\tint exclusive = 0;\n\tvm_fault_t ret = 0;\n\n\tif (!pte_unmap_same(vma->vm_mm, vmf->pmd, vmf->pte, vmf->orig_pte))\n\t\tgoto out;\n\n\tentry = pte_to_swp_entry(vmf->orig_pte);\n\tif (unlikely(non_swap_entry(entry))) {\n\t\tif (is_migration_entry(entry)) {\n\t\t\tmigration_entry_wait(vma->vm_mm, vmf->pmd,\n\t\t\t\t\t     vmf->address);\n\t\t} else if (is_device_private_entry(entry)) {\n\t\t\t/*\n\t\t\t * For un-addressable device memory we call the pgmap\n\t\t\t * fault handler callback. The callback must migrate\n\t\t\t * the page back to some CPU accessible page.\n\t\t\t */\n\t\t\tret = device_private_entry_fault(vma, vmf->address, entry,\n\t\t\t\t\t\t vmf->flags, vmf->pmd);\n\t\t} else if (is_hwpoison_entry(entry)) {\n\t\t\tret = VM_FAULT_HWPOISON;\n\t\t} else {\n\t\t\tprint_bad_pte(vma, vmf->address, vmf->orig_pte, NULL);\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\t}\n\t\tgoto out;\n\t}\n\n\n\tdelayacct_set_flag(DELAYACCT_PF_SWAPIN);\n\tpage = lookup_swap_cache(entry, vma, vmf->address);\n\tswapcache = page;\n\n\tif (!page) {\n\t\tstruct swap_info_struct *si = swp_swap_info(entry);\n\n\t\tif (si->flags & SWP_SYNCHRONOUS_IO &&\n\t\t\t\t__swap_count(si, entry) == 1) {\n\t\t\t/* skip swapcache */\n\t\t\tpage = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma,\n\t\t\t\t\t\t\tvmf->address);\n\t\t\tif (page) {\n\t\t\t\t__SetPageLocked(page);\n\t\t\t\t__SetPageSwapBacked(page);\n\t\t\t\tset_page_private(page, entry.val);\n\t\t\t\tlru_cache_add_anon(page);\n\t\t\t\tswap_readpage(page, true);\n\t\t\t}\n\t\t} else {\n\t\t\tpage = swapin_readahead(entry, GFP_HIGHUSER_MOVABLE,\n\t\t\t\t\t\tvmf);\n\t\t\tswapcache = page;\n\t\t}\n\n\t\tif (!page) {\n\t\t\t/*\n\t\t\t * Back out if somebody else faulted in this pte\n\t\t\t * while we released the pte lock.\n\t\t\t */\n\t\t\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd,\n\t\t\t\t\tvmf->address, &vmf->ptl);\n\t\t\tif (likely(pte_same(*vmf->pte, vmf->orig_pte)))\n\t\t\t\tret = VM_FAULT_OOM;\n\t\t\tdelayacct_clear_flag(DELAYACCT_PF_SWAPIN);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\t/* Had to read the page from swap area: Major fault */\n\t\tret = VM_FAULT_MAJOR;\n\t\tcount_vm_event(PGMAJFAULT);\n\t\tcount_memcg_event_mm(vma->vm_mm, PGMAJFAULT);\n\t} else if (PageHWPoison(page)) {\n\t\t/*\n\t\t * hwpoisoned dirty swapcache pages are kept for killing\n\t\t * owner processes (which may be unknown at hwpoison time)\n\t\t */\n\t\tret = VM_FAULT_HWPOISON;\n\t\tdelayacct_clear_flag(DELAYACCT_PF_SWAPIN);\n\t\tgoto out_release;\n\t}\n\n\tlocked = lock_page_or_retry(page, vma->vm_mm, vmf->flags);\n\n\tdelayacct_clear_flag(DELAYACCT_PF_SWAPIN);\n\tif (!locked) {\n\t\tret |= VM_FAULT_RETRY;\n\t\tgoto out_release;\n\t}\n\n\t/*\n\t * Make sure try_to_free_swap or reuse_swap_page or swapoff did not\n\t * release the swapcache from under us.  The page pin, and pte_same\n\t * test below, are not enough to exclude that.  Even if it is still\n\t * swapcache, we need to check that the page's swap has not changed.\n\t */\n\tif (unlikely((!PageSwapCache(page) ||\n\t\t\tpage_private(page) != entry.val)) && swapcache)\n\t\tgoto out_page;\n\n\tpage = ksm_might_need_to_copy(page, vma, vmf->address);\n\tif (unlikely(!page)) {\n\t\tret = VM_FAULT_OOM;\n\t\tpage = swapcache;\n\t\tgoto out_page;\n\t}\n\n\tif (mem_cgroup_try_charge_delay(page, vma->vm_mm, GFP_KERNEL,\n\t\t\t\t\t&memcg, false)) {\n\t\tret = VM_FAULT_OOM;\n\t\tgoto out_page;\n\t}\n\n\t/*\n\t * Back out if somebody else already faulted in this pte.\n\t */\n\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd, vmf->address,\n\t\t\t&vmf->ptl);\n\tif (unlikely(!pte_same(*vmf->pte, vmf->orig_pte)))\n\t\tgoto out_nomap;\n\n\tif (unlikely(!PageUptodate(page))) {\n\t\tret = VM_FAULT_SIGBUS;\n\t\tgoto out_nomap;\n\t}\n\n\t/*\n\t * The page isn't present yet, go ahead with the fault.\n\t *\n\t * Be careful about the sequence of operations here.\n\t * To get its accounting right, reuse_swap_page() must be called\n\t * while the page is counted on swap but not yet in mapcount i.e.\n\t * before page_add_anon_rmap() and swap_free(); try_to_free_swap()\n\t * must be called after the swap_free(), or it will never succeed.\n\t */\n\n\tinc_mm_counter_fast(vma->vm_mm, MM_ANONPAGES);\n\tdec_mm_counter_fast(vma->vm_mm, MM_SWAPENTS);\n\tpte = mk_pte(page, vma->vm_page_prot);\n\tif ((vmf->flags & FAULT_FLAG_WRITE) && reuse_swap_page(page, NULL)) {\n\t\tpte = maybe_mkwrite(pte_mkdirty(pte), vma);\n\t\tvmf->flags &= ~FAULT_FLAG_WRITE;\n\t\tret |= VM_FAULT_WRITE;\n\t\texclusive = RMAP_EXCLUSIVE;\n\t}\n\tflush_icache_page(vma, page);\n\tif (pte_swp_soft_dirty(vmf->orig_pte))\n\t\tpte = pte_mksoft_dirty(pte);\n\tset_pte_at(vma->vm_mm, vmf->address, vmf->pte, pte);\n\tarch_do_swap_page(vma->vm_mm, vma, vmf->address, pte, vmf->orig_pte);\n\tvmf->orig_pte = pte;\n\n\t/* ksm created a completely new copy */\n\tif (unlikely(page != swapcache && swapcache)) {\n\t\tpage_add_new_anon_rmap(page, vma, vmf->address, false);\n\t\tmem_cgroup_commit_charge(page, memcg, false, false);\n\t\tlru_cache_add_active_or_unevictable(page, vma);\n\t} else {\n\t\tdo_page_add_anon_rmap(page, vma, vmf->address, exclusive);\n\t\tmem_cgroup_commit_charge(page, memcg, true, false);\n\t\tactivate_page(page);\n\t}\n\n\tswap_free(entry);\n\tif (mem_cgroup_swap_full(page) ||\n\t    (vma->vm_flags & VM_LOCKED) || PageMlocked(page))\n\t\ttry_to_free_swap(page);\n\tunlock_page(page);\n\tif (page != swapcache && swapcache) {\n\t\t/*\n\t\t * Hold the lock to avoid the swap entry to be reused\n\t\t * until we take the PT lock for the pte_same() check\n\t\t * (to avoid false positives from pte_same). For\n\t\t * further safety release the lock after the swap_free\n\t\t * so that the swap count won't change under a\n\t\t * parallel locked swapcache.\n\t\t */\n\t\tunlock_page(swapcache);\n\t\tput_page(swapcache);\n\t}\n\n\tif (vmf->flags & FAULT_FLAG_WRITE) {\n\t\tret |= do_wp_page(vmf);\n\t\tif (ret & VM_FAULT_ERROR)\n\t\t\tret &= VM_FAULT_ERROR;\n\t\tgoto out;\n\t}\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\nunlock:\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\nout:\n\treturn ret;\nout_nomap:\n\tmem_cgroup_cancel_charge(page, memcg, false);\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\nout_page:\n\tunlock_page(page);\nout_release:\n\tput_page(page);\n\tif (page != swapcache && swapcache) {\n\t\tunlock_page(swapcache);\n\t\tput_page(swapcache);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvm_fault_t do_swap_page(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page = NULL, *swapcache;\n\tstruct mem_cgroup *memcg;\n\tswp_entry_t entry;\n\tpte_t pte;\n\tint locked;\n\tint exclusive = 0;\n\tvm_fault_t ret = 0;\n\n\tif (!pte_unmap_same(vma->vm_mm, vmf->pmd, vmf->pte, vmf->orig_pte))\n\t\tgoto out;\n\n\tentry = pte_to_swp_entry(vmf->orig_pte);\n\tif (unlikely(non_swap_entry(entry))) {\n\t\tif (is_migration_entry(entry)) {\n\t\t\tmigration_entry_wait(vma->vm_mm, vmf->pmd,\n\t\t\t\t\t     vmf->address);\n\t\t} else if (is_device_private_entry(entry)) {\n\t\t\t/*\n\t\t\t * For un-addressable device memory we call the pgmap\n\t\t\t * fault handler callback. The callback must migrate\n\t\t\t * the page back to some CPU accessible page.\n\t\t\t */\n\t\t\tret = device_private_entry_fault(vma, vmf->address, entry,\n\t\t\t\t\t\t vmf->flags, vmf->pmd);\n\t\t} else if (is_hwpoison_entry(entry)) {\n\t\t\tret = VM_FAULT_HWPOISON;\n\t\t} else {\n\t\t\tprint_bad_pte(vma, vmf->address, vmf->orig_pte, NULL);\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\t}\n\t\tgoto out;\n\t}\n\n\n\tdelayacct_set_flag(DELAYACCT_PF_SWAPIN);\n\tpage = lookup_swap_cache(entry, vma, vmf->address);\n\tswapcache = page;\n\n\tif (!page) {\n\t\tstruct swap_info_struct *si = swp_swap_info(entry);\n\n\t\tif (si->flags & SWP_SYNCHRONOUS_IO &&\n\t\t\t\t__swap_count(si, entry) == 1) {\n\t\t\t/* skip swapcache */\n\t\t\tpage = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma,\n\t\t\t\t\t\t\tvmf->address);\n\t\t\tif (page) {\n\t\t\t\t__SetPageLocked(page);\n\t\t\t\t__SetPageSwapBacked(page);\n\t\t\t\tset_page_private(page, entry.val);\n\t\t\t\tlru_cache_add_anon(page);\n\t\t\t\tswap_readpage(page, true);\n\t\t\t}\n\t\t} else {\n\t\t\tpage = swapin_readahead(entry, GFP_HIGHUSER_MOVABLE,\n\t\t\t\t\t\tvmf);\n\t\t\tswapcache = page;\n\t\t}\n\n\t\tif (!page) {\n\t\t\t/*\n\t\t\t * Back out if somebody else faulted in this pte\n\t\t\t * while we released the pte lock.\n\t\t\t */\n\t\t\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd,\n\t\t\t\t\tvmf->address, &vmf->ptl);\n\t\t\tif (likely(pte_same(*vmf->pte, vmf->orig_pte)))\n\t\t\t\tret = VM_FAULT_OOM;\n\t\t\tdelayacct_clear_flag(DELAYACCT_PF_SWAPIN);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\t/* Had to read the page from swap area: Major fault */\n\t\tret = VM_FAULT_MAJOR;\n\t\tcount_vm_event(PGMAJFAULT);\n\t\tcount_memcg_event_mm(vma->vm_mm, PGMAJFAULT);\n\t} else if (PageHWPoison(page)) {\n\t\t/*\n\t\t * hwpoisoned dirty swapcache pages are kept for killing\n\t\t * owner processes (which may be unknown at hwpoison time)\n\t\t */\n\t\tret = VM_FAULT_HWPOISON;\n\t\tdelayacct_clear_flag(DELAYACCT_PF_SWAPIN);\n\t\tgoto out_release;\n\t}\n\n\tlocked = lock_page_or_retry(page, vma->vm_mm, vmf->flags);\n\n\tdelayacct_clear_flag(DELAYACCT_PF_SWAPIN);\n\tif (!locked) {\n\t\tret |= VM_FAULT_RETRY;\n\t\tgoto out_release;\n\t}\n\n\t/*\n\t * Make sure try_to_free_swap or reuse_swap_page or swapoff did not\n\t * release the swapcache from under us.  The page pin, and pte_same\n\t * test below, are not enough to exclude that.  Even if it is still\n\t * swapcache, we need to check that the page's swap has not changed.\n\t */\n\tif (unlikely((!PageSwapCache(page) ||\n\t\t\tpage_private(page) != entry.val)) && swapcache)\n\t\tgoto out_page;\n\n\tpage = ksm_might_need_to_copy(page, vma, vmf->address);\n\tif (unlikely(!page)) {\n\t\tret = VM_FAULT_OOM;\n\t\tpage = swapcache;\n\t\tgoto out_page;\n\t}\n\n\tif (mem_cgroup_try_charge_delay(page, vma->vm_mm, GFP_KERNEL,\n\t\t\t\t\t&memcg, false)) {\n\t\tret = VM_FAULT_OOM;\n\t\tgoto out_page;\n\t}\n\n\t/*\n\t * Back out if somebody else already faulted in this pte.\n\t */\n\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd, vmf->address,\n\t\t\t&vmf->ptl);\n\tif (unlikely(!pte_same(*vmf->pte, vmf->orig_pte)))\n\t\tgoto out_nomap;\n\n\tif (unlikely(!PageUptodate(page))) {\n\t\tret = VM_FAULT_SIGBUS;\n\t\tgoto out_nomap;\n\t}\n\n\t/*\n\t * The page isn't present yet, go ahead with the fault.\n\t *\n\t * Be careful about the sequence of operations here.\n\t * To get its accounting right, reuse_swap_page() must be called\n\t * while the page is counted on swap but not yet in mapcount i.e.\n\t * before page_add_anon_rmap() and swap_free(); try_to_free_swap()\n\t * must be called after the swap_free(), or it will never succeed.\n\t */\n\n\tinc_mm_counter_fast(vma->vm_mm, MM_ANONPAGES);\n\tdec_mm_counter_fast(vma->vm_mm, MM_SWAPENTS);\n\tpte = mk_pte(page, vma->vm_page_prot);\n\tif ((vmf->flags & FAULT_FLAG_WRITE) && reuse_swap_page(page, NULL)) {\n\t\tpte = maybe_mkwrite(pte_mkdirty(pte), vma);\n\t\tvmf->flags &= ~FAULT_FLAG_WRITE;\n\t\tret |= VM_FAULT_WRITE;\n\t\texclusive = RMAP_EXCLUSIVE;\n\t}\n\tflush_icache_page(vma, page);\n\tif (pte_swp_soft_dirty(vmf->orig_pte))\n\t\tpte = pte_mksoft_dirty(pte);\n\tset_pte_at(vma->vm_mm, vmf->address, vmf->pte, pte);\n\tarch_do_swap_page(vma->vm_mm, vma, vmf->address, pte, vmf->orig_pte);\n\tvmf->orig_pte = pte;\n\n\t/* ksm created a completely new copy */\n\tif (unlikely(page != swapcache && swapcache)) {\n\t\tpage_add_new_anon_rmap(page, vma, vmf->address, false);\n\t\tmem_cgroup_commit_charge(page, memcg, false, false);\n\t\tlru_cache_add_active_or_unevictable(page, vma);\n\t} else {\n\t\tdo_page_add_anon_rmap(page, vma, vmf->address, exclusive);\n\t\tmem_cgroup_commit_charge(page, memcg, true, false);\n\t\tactivate_page(page);\n\t}\n\n\tswap_free(entry);\n\tif (mem_cgroup_swap_full(page) ||\n\t    (vma->vm_flags & VM_LOCKED) || PageMlocked(page))\n\t\ttry_to_free_swap(page);\n\tunlock_page(page);\n\tif (page != swapcache && swapcache) {\n\t\t/*\n\t\t * Hold the lock to avoid the swap entry to be reused\n\t\t * until we take the PT lock for the pte_same() check\n\t\t * (to avoid false positives from pte_same). For\n\t\t * further safety release the lock after the swap_free\n\t\t * so that the swap count won't change under a\n\t\t * parallel locked swapcache.\n\t\t */\n\t\tunlock_page(swapcache);\n\t\tput_page(swapcache);\n\t}\n\n\tif (vmf->flags & FAULT_FLAG_WRITE) {\n\t\tret |= do_wp_page(vmf);\n\t\tif (ret & VM_FAULT_ERROR)\n\t\t\tret &= VM_FAULT_ERROR;\n\t\tgoto out;\n\t}\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\nunlock:\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\nout:\n\treturn ret;\nout_nomap:\n\tmem_cgroup_cancel_charge(page, memcg, false);\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\nout_page:\n\tunlock_page(page);\nout_release:\n\tput_page(page);\n\tif (page != swapcache && swapcache) {\n\t\tunlock_page(swapcache);\n\t\tput_page(swapcache);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "vmf->orig_pte"
          ],
          "line": 3768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_fault",
          "args": [
            "vmf"
          ],
          "line": 3765
        },
        "resolved": true,
        "details": {
          "function_name": "do_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3499-3546",
          "snippet": "static vm_fault_t do_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tvm_fault_t ret;\n\n\t/*\n\t * The VMA was not fully populated on mmap() or missing VM_DONTEXPAND\n\t */\n\tif (!vma->vm_ops->fault) {\n\t\t/*\n\t\t * If we find a migration pmd entry or a none pmd entry, which\n\t\t * should never happen, return SIGBUS\n\t\t */\n\t\tif (unlikely(!pmd_present(*vmf->pmd)))\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\telse {\n\t\t\tvmf->pte = pte_offset_map_lock(vmf->vma->vm_mm,\n\t\t\t\t\t\t       vmf->pmd,\n\t\t\t\t\t\t       vmf->address,\n\t\t\t\t\t\t       &vmf->ptl);\n\t\t\t/*\n\t\t\t * Make sure this is not a temporary clearing of pte\n\t\t\t * by holding ptl and checking again. A R/M/W update\n\t\t\t * of pte involves: take ptl, clearing the pte so that\n\t\t\t * we don't have concurrent modification by hardware\n\t\t\t * followed by an update.\n\t\t\t */\n\t\t\tif (unlikely(pte_none(*vmf->pte)))\n\t\t\t\tret = VM_FAULT_SIGBUS;\n\t\t\telse\n\t\t\t\tret = VM_FAULT_NOPAGE;\n\n\t\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\t}\n\t} else if (!(vmf->flags & FAULT_FLAG_WRITE))\n\t\tret = do_read_fault(vmf);\n\telse if (!(vma->vm_flags & VM_SHARED))\n\t\tret = do_cow_fault(vmf);\n\telse\n\t\tret = do_shared_fault(vmf);\n\n\t/* preallocated pagetable is unused: free it */\n\tif (vmf->prealloc_pte) {\n\t\tpte_free(vma->vm_mm, vmf->prealloc_pte);\n\t\tvmf->prealloc_pte = NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t do_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tvm_fault_t ret;\n\n\t/*\n\t * The VMA was not fully populated on mmap() or missing VM_DONTEXPAND\n\t */\n\tif (!vma->vm_ops->fault) {\n\t\t/*\n\t\t * If we find a migration pmd entry or a none pmd entry, which\n\t\t * should never happen, return SIGBUS\n\t\t */\n\t\tif (unlikely(!pmd_present(*vmf->pmd)))\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\telse {\n\t\t\tvmf->pte = pte_offset_map_lock(vmf->vma->vm_mm,\n\t\t\t\t\t\t       vmf->pmd,\n\t\t\t\t\t\t       vmf->address,\n\t\t\t\t\t\t       &vmf->ptl);\n\t\t\t/*\n\t\t\t * Make sure this is not a temporary clearing of pte\n\t\t\t * by holding ptl and checking again. A R/M/W update\n\t\t\t * of pte involves: take ptl, clearing the pte so that\n\t\t\t * we don't have concurrent modification by hardware\n\t\t\t * followed by an update.\n\t\t\t */\n\t\t\tif (unlikely(pte_none(*vmf->pte)))\n\t\t\t\tret = VM_FAULT_SIGBUS;\n\t\t\telse\n\t\t\t\tret = VM_FAULT_NOPAGE;\n\n\t\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\t}\n\t} else if (!(vmf->flags & FAULT_FLAG_WRITE))\n\t\tret = do_read_fault(vmf);\n\telse if (!(vma->vm_flags & VM_SHARED))\n\t\tret = do_cow_fault(vmf);\n\telse\n\t\tret = do_shared_fault(vmf);\n\n\t/* preallocated pagetable is unused: free it */\n\tif (vmf->prealloc_pte) {\n\t\tpte_free(vma->vm_mm, vmf->prealloc_pte);\n\t\tvmf->prealloc_pte = NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_anonymous_page",
          "args": [
            "vmf"
          ],
          "line": 3763
        },
        "resolved": true,
        "details": {
          "function_name": "do_anonymous_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2876-2984",
          "snippet": "static vm_fault_t do_anonymous_page(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct mem_cgroup *memcg;\n\tstruct page *page;\n\tvm_fault_t ret = 0;\n\tpte_t entry;\n\n\t/* File mapping without ->vm_ops ? */\n\tif (vma->vm_flags & VM_SHARED)\n\t\treturn VM_FAULT_SIGBUS;\n\n\t/*\n\t * Use pte_alloc() instead of pte_alloc_map().  We can't run\n\t * pte_offset_map() on pmds where a huge pmd might be created\n\t * from a different thread.\n\t *\n\t * pte_alloc_map() is safe to use under down_write(mmap_sem) or when\n\t * parallel threads are excluded by other means.\n\t *\n\t * Here we only have down_read(mmap_sem).\n\t */\n\tif (pte_alloc(vma->vm_mm, vmf->pmd, vmf->address))\n\t\treturn VM_FAULT_OOM;\n\n\t/* See the comment in pte_alloc_one_map() */\n\tif (unlikely(pmd_trans_unstable(vmf->pmd)))\n\t\treturn 0;\n\n\t/* Use the zero-page for reads */\n\tif (!(vmf->flags & FAULT_FLAG_WRITE) &&\n\t\t\t!mm_forbids_zeropage(vma->vm_mm)) {\n\t\tentry = pte_mkspecial(pfn_pte(my_zero_pfn(vmf->address),\n\t\t\t\t\t\tvma->vm_page_prot));\n\t\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd,\n\t\t\t\tvmf->address, &vmf->ptl);\n\t\tif (!pte_none(*vmf->pte))\n\t\t\tgoto unlock;\n\t\tret = check_stable_address_space(vma->vm_mm);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t\t/* Deliver the page fault to userland, check inside PT lock */\n\t\tif (userfaultfd_missing(vma)) {\n\t\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\t\treturn handle_userfault(vmf, VM_UFFD_MISSING);\n\t\t}\n\t\tgoto setpte;\n\t}\n\n\t/* Allocate our own private page. */\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto oom;\n\tpage = alloc_zeroed_user_highpage_movable(vma, vmf->address);\n\tif (!page)\n\t\tgoto oom;\n\n\tif (mem_cgroup_try_charge_delay(page, vma->vm_mm, GFP_KERNEL, &memcg,\n\t\t\t\t\tfalse))\n\t\tgoto oom_free_page;\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceeding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\n\tentry = mk_pte(page, vma->vm_page_prot);\n\tif (vma->vm_flags & VM_WRITE)\n\t\tentry = pte_mkwrite(pte_mkdirty(entry));\n\n\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd, vmf->address,\n\t\t\t&vmf->ptl);\n\tif (!pte_none(*vmf->pte))\n\t\tgoto release;\n\n\tret = check_stable_address_space(vma->vm_mm);\n\tif (ret)\n\t\tgoto release;\n\n\t/* Deliver the page fault to userland, check inside PT lock */\n\tif (userfaultfd_missing(vma)) {\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\tmem_cgroup_cancel_charge(page, memcg, false);\n\t\tput_page(page);\n\t\treturn handle_userfault(vmf, VM_UFFD_MISSING);\n\t}\n\n\tinc_mm_counter_fast(vma->vm_mm, MM_ANONPAGES);\n\tpage_add_new_anon_rmap(page, vma, vmf->address, false);\n\tmem_cgroup_commit_charge(page, memcg, false, false);\n\tlru_cache_add_active_or_unevictable(page, vma);\nsetpte:\n\tset_pte_at(vma->vm_mm, vmf->address, vmf->pte, entry);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\nunlock:\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\treturn ret;\nrelease:\n\tmem_cgroup_cancel_charge(page, memcg, false);\n\tput_page(page);\n\tgoto unlock;\noom_free_page:\n\tput_page(page);\noom:\n\treturn VM_FAULT_OOM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t do_anonymous_page(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct mem_cgroup *memcg;\n\tstruct page *page;\n\tvm_fault_t ret = 0;\n\tpte_t entry;\n\n\t/* File mapping without ->vm_ops ? */\n\tif (vma->vm_flags & VM_SHARED)\n\t\treturn VM_FAULT_SIGBUS;\n\n\t/*\n\t * Use pte_alloc() instead of pte_alloc_map().  We can't run\n\t * pte_offset_map() on pmds where a huge pmd might be created\n\t * from a different thread.\n\t *\n\t * pte_alloc_map() is safe to use under down_write(mmap_sem) or when\n\t * parallel threads are excluded by other means.\n\t *\n\t * Here we only have down_read(mmap_sem).\n\t */\n\tif (pte_alloc(vma->vm_mm, vmf->pmd, vmf->address))\n\t\treturn VM_FAULT_OOM;\n\n\t/* See the comment in pte_alloc_one_map() */\n\tif (unlikely(pmd_trans_unstable(vmf->pmd)))\n\t\treturn 0;\n\n\t/* Use the zero-page for reads */\n\tif (!(vmf->flags & FAULT_FLAG_WRITE) &&\n\t\t\t!mm_forbids_zeropage(vma->vm_mm)) {\n\t\tentry = pte_mkspecial(pfn_pte(my_zero_pfn(vmf->address),\n\t\t\t\t\t\tvma->vm_page_prot));\n\t\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd,\n\t\t\t\tvmf->address, &vmf->ptl);\n\t\tif (!pte_none(*vmf->pte))\n\t\t\tgoto unlock;\n\t\tret = check_stable_address_space(vma->vm_mm);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t\t/* Deliver the page fault to userland, check inside PT lock */\n\t\tif (userfaultfd_missing(vma)) {\n\t\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\t\treturn handle_userfault(vmf, VM_UFFD_MISSING);\n\t\t}\n\t\tgoto setpte;\n\t}\n\n\t/* Allocate our own private page. */\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto oom;\n\tpage = alloc_zeroed_user_highpage_movable(vma, vmf->address);\n\tif (!page)\n\t\tgoto oom;\n\n\tif (mem_cgroup_try_charge_delay(page, vma->vm_mm, GFP_KERNEL, &memcg,\n\t\t\t\t\tfalse))\n\t\tgoto oom_free_page;\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceeding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\n\tentry = mk_pte(page, vma->vm_page_prot);\n\tif (vma->vm_flags & VM_WRITE)\n\t\tentry = pte_mkwrite(pte_mkdirty(entry));\n\n\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd, vmf->address,\n\t\t\t&vmf->ptl);\n\tif (!pte_none(*vmf->pte))\n\t\tgoto release;\n\n\tret = check_stable_address_space(vma->vm_mm);\n\tif (ret)\n\t\tgoto release;\n\n\t/* Deliver the page fault to userland, check inside PT lock */\n\tif (userfaultfd_missing(vma)) {\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\tmem_cgroup_cancel_charge(page, memcg, false);\n\t\tput_page(page);\n\t\treturn handle_userfault(vmf, VM_UFFD_MISSING);\n\t}\n\n\tinc_mm_counter_fast(vma->vm_mm, MM_ANONPAGES);\n\tpage_add_new_anon_rmap(page, vma, vmf->address, false);\n\tmem_cgroup_commit_charge(page, memcg, false, false);\n\tlru_cache_add_active_or_unevictable(page, vma);\nsetpte:\n\tset_pte_at(vma->vm_mm, vmf->address, vmf->pte, entry);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\nunlock:\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\treturn ret;\nrelease:\n\tmem_cgroup_cancel_charge(page, memcg, false);\n\tput_page(page);\n\tgoto unlock;\noom_free_page:\n\tput_page(page);\noom:\n\treturn VM_FAULT_OOM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_is_anonymous",
          "args": [
            "vmf->vma"
          ],
          "line": 3762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap",
          "args": [
            "vmf->pte"
          ],
          "line": 3756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "vmf->orig_pte"
          ],
          "line": 3755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 3754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map",
          "args": [
            "vmf->pmd",
            "vmf->address"
          ],
          "line": 3743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_devmap_trans_unstable",
          "args": [
            "vmf->pmd"
          ],
          "line": 3735
        },
        "resolved": true,
        "details": {
          "function_name": "pmd_devmap_trans_unstable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3023-3026",
          "snippet": "static int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pmd_none(*vmf->pmd)"
          ],
          "line": 3725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "*vmf->pmd"
          ],
          "line": 3725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t handle_pte_fault(struct vm_fault *vmf)\n{\n\tpte_t entry;\n\n\tif (unlikely(pmd_none(*vmf->pmd))) {\n\t\t/*\n\t\t * Leave __pte_alloc() until later: because vm_ops->fault may\n\t\t * want to allocate huge page, and if we expose page table\n\t\t * for an instant, it will be difficult to retract from\n\t\t * concurrent faults and from rmap lookups.\n\t\t */\n\t\tvmf->pte = NULL;\n\t} else {\n\t\t/* See comment in pte_alloc_one_map() */\n\t\tif (pmd_devmap_trans_unstable(vmf->pmd))\n\t\t\treturn 0;\n\t\t/*\n\t\t * A regular pmd is established and it can't morph into a huge\n\t\t * pmd from under us anymore at this point because we hold the\n\t\t * mmap_sem read mode and khugepaged takes it in write mode.\n\t\t * So now it's safe to run pte_offset_map().\n\t\t */\n\t\tvmf->pte = pte_offset_map(vmf->pmd, vmf->address);\n\t\tvmf->orig_pte = *vmf->pte;\n\n\t\t/*\n\t\t * some architectures can have larger ptes than wordsize,\n\t\t * e.g.ppc44x-defconfig has CONFIG_PTE_64BIT=y and\n\t\t * CONFIG_32BIT=y, so READ_ONCE cannot guarantee atomic\n\t\t * accesses.  The code below just needs a consistent view\n\t\t * for the ifs and we later double check anyway with the\n\t\t * ptl lock held. So here a barrier will do.\n\t\t */\n\t\tbarrier();\n\t\tif (pte_none(vmf->orig_pte)) {\n\t\t\tpte_unmap(vmf->pte);\n\t\t\tvmf->pte = NULL;\n\t\t}\n\t}\n\n\tif (!vmf->pte) {\n\t\tif (vma_is_anonymous(vmf->vma))\n\t\t\treturn do_anonymous_page(vmf);\n\t\telse\n\t\t\treturn do_fault(vmf);\n\t}\n\n\tif (!pte_present(vmf->orig_pte))\n\t\treturn do_swap_page(vmf);\n\n\tif (pte_protnone(vmf->orig_pte) && vma_is_accessible(vmf->vma))\n\t\treturn do_numa_page(vmf);\n\n\tvmf->ptl = pte_lockptr(vmf->vma->vm_mm, vmf->pmd);\n\tspin_lock(vmf->ptl);\n\tentry = vmf->orig_pte;\n\tif (unlikely(!pte_same(*vmf->pte, entry)))\n\t\tgoto unlock;\n\tif (vmf->flags & FAULT_FLAG_WRITE) {\n\t\tif (!pte_write(entry))\n\t\t\treturn do_wp_page(vmf);\n\t\tentry = pte_mkdirty(entry);\n\t}\n\tentry = pte_mkyoung(entry);\n\tif (ptep_set_access_flags(vmf->vma, vmf->address, vmf->pte, entry,\n\t\t\t\tvmf->flags & FAULT_FLAG_WRITE)) {\n\t\tupdate_mmu_cache(vmf->vma, vmf->address, vmf->pte);\n\t} else {\n\t\t/*\n\t\t * This is needed only for protection faults but the arch code\n\t\t * is not yet telling us if this is a protection fault or not.\n\t\t * This still avoids useless tlb flushes for .text page faults\n\t\t * with threads.\n\t\t */\n\t\tif (vmf->flags & FAULT_FLAG_WRITE)\n\t\t\tflush_tlb_fix_spurious_fault(vmf->vma, vmf->address);\n\t}\nunlock:\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\treturn 0;\n}"
  },
  {
    "function_name": "wp_huge_pud",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3694-3704",
    "snippet": "static vm_fault_t wp_huge_pud(struct vm_fault *vmf, pud_t orig_pud)\n{\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t/* No support for anonymous transparent PUD pages yet */\n\tif (vma_is_anonymous(vmf->vma))\n\t\treturn VM_FAULT_FALLBACK;\n\tif (vmf->vma->vm_ops->huge_fault)\n\t\treturn vmf->vma->vm_ops->huge_fault(vmf, PE_SIZE_PUD);\n#endif /* CONFIG_TRANSPARENT_HUGEPAGE */\n\treturn VM_FAULT_FALLBACK;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmf->vma->vm_ops->huge_fault",
          "args": [
            "vmf",
            "PE_SIZE_PUD"
          ],
          "line": 3701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_is_anonymous",
          "args": [
            "vmf->vma"
          ],
          "line": 3698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t wp_huge_pud(struct vm_fault *vmf, pud_t orig_pud)\n{\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t/* No support for anonymous transparent PUD pages yet */\n\tif (vma_is_anonymous(vmf->vma))\n\t\treturn VM_FAULT_FALLBACK;\n\tif (vmf->vma->vm_ops->huge_fault)\n\t\treturn vmf->vma->vm_ops->huge_fault(vmf, PE_SIZE_PUD);\n#endif /* CONFIG_TRANSPARENT_HUGEPAGE */\n\treturn VM_FAULT_FALLBACK;\n}"
  },
  {
    "function_name": "create_huge_pud",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3682-3692",
    "snippet": "static vm_fault_t create_huge_pud(struct vm_fault *vmf)\n{\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t/* No support for anonymous transparent PUD pages yet */\n\tif (vma_is_anonymous(vmf->vma))\n\t\treturn VM_FAULT_FALLBACK;\n\tif (vmf->vma->vm_ops->huge_fault)\n\t\treturn vmf->vma->vm_ops->huge_fault(vmf, PE_SIZE_PUD);\n#endif /* CONFIG_TRANSPARENT_HUGEPAGE */\n\treturn VM_FAULT_FALLBACK;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmf->vma->vm_ops->huge_fault",
          "args": [
            "vmf",
            "PE_SIZE_PUD"
          ],
          "line": 3689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_is_anonymous",
          "args": [
            "vmf->vma"
          ],
          "line": 3686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t create_huge_pud(struct vm_fault *vmf)\n{\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t/* No support for anonymous transparent PUD pages yet */\n\tif (vma_is_anonymous(vmf->vma))\n\t\treturn VM_FAULT_FALLBACK;\n\tif (vmf->vma->vm_ops->huge_fault)\n\t\treturn vmf->vma->vm_ops->huge_fault(vmf, PE_SIZE_PUD);\n#endif /* CONFIG_TRANSPARENT_HUGEPAGE */\n\treturn VM_FAULT_FALLBACK;\n}"
  },
  {
    "function_name": "vma_is_accessible",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3677-3680",
    "snippet": "static inline bool vma_is_accessible(struct vm_area_struct *vma)\n{\n\treturn vma->vm_flags & (VM_READ | VM_EXEC | VM_WRITE);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline bool vma_is_accessible(struct vm_area_struct *vma)\n{\n\treturn vma->vm_flags & (VM_READ | VM_EXEC | VM_WRITE);\n}"
  },
  {
    "function_name": "wp_huge_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3663-3675",
    "snippet": "static inline vm_fault_t wp_huge_pmd(struct vm_fault *vmf, pmd_t orig_pmd)\n{\n\tif (vma_is_anonymous(vmf->vma))\n\t\treturn do_huge_pmd_wp_page(vmf, orig_pmd);\n\tif (vmf->vma->vm_ops->huge_fault)\n\t\treturn vmf->vma->vm_ops->huge_fault(vmf, PE_SIZE_PMD);\n\n\t/* COW handled on pte level: split pmd */\n\tVM_BUG_ON_VMA(vmf->vma->vm_flags & VM_SHARED, vmf->vma);\n\t__split_huge_pmd(vmf->vma, vmf->pmd, vmf->address, false, NULL);\n\n\treturn VM_FAULT_FALLBACK;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__split_huge_pmd",
          "args": [
            "vmf->vma",
            "vmf->pmd",
            "vmf->address",
            "false",
            "NULL"
          ],
          "line": 3672
        },
        "resolved": true,
        "details": {
          "function_name": "__split_huge_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2243-2285",
          "snippet": "void __split_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long address, bool freeze, struct page *page)\n{\n\tspinlock_t *ptl;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long haddr = address & HPAGE_PMD_MASK;\n\n\tmmu_notifier_invalidate_range_start(mm, haddr, haddr + HPAGE_PMD_SIZE);\n\tptl = pmd_lock(mm, pmd);\n\n\t/*\n\t * If caller asks to setup a migration entries, we need a page to check\n\t * pmd against. Otherwise we can end up replacing wrong page.\n\t */\n\tVM_BUG_ON(freeze && !page);\n\tif (page && page != pmd_page(*pmd))\n\t        goto out;\n\n\tif (pmd_trans_huge(*pmd)) {\n\t\tpage = pmd_page(*pmd);\n\t\tif (PageMlocked(page))\n\t\t\tclear_page_mlock(page);\n\t} else if (!(pmd_devmap(*pmd) || is_pmd_migration_entry(*pmd)))\n\t\tgoto out;\n\t__split_huge_pmd_locked(vma, pmd, haddr, freeze);\nout:\n\tspin_unlock(ptl);\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback.\n\t * They are 3 cases to consider inside __split_huge_pmd_locked():\n\t *  1) pmdp_huge_clear_flush_notify() call invalidate_range() obvious\n\t *  2) __split_huge_zero_page_pmd() read only zero page and any write\n\t *    fault will trigger a flush_notify before pointing to a new page\n\t *    (it is fine if the secondary mmu keeps pointing to the old zero\n\t *    page in the meantime)\n\t *  3) Split a huge pmd into pte pointing to the same page. No need\n\t *     to invalidate secondary tlb entry they are all still valid.\n\t *     any further changes to individual pte will notify. So no need\n\t *     to call mmu_notifier->invalidate_range()\n\t */\n\tmmu_notifier_invalidate_range_only_end(mm, haddr, haddr +\n\t\t\t\t\t       HPAGE_PMD_SIZE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid __split_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long address, bool freeze, struct page *page)\n{\n\tspinlock_t *ptl;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long haddr = address & HPAGE_PMD_MASK;\n\n\tmmu_notifier_invalidate_range_start(mm, haddr, haddr + HPAGE_PMD_SIZE);\n\tptl = pmd_lock(mm, pmd);\n\n\t/*\n\t * If caller asks to setup a migration entries, we need a page to check\n\t * pmd against. Otherwise we can end up replacing wrong page.\n\t */\n\tVM_BUG_ON(freeze && !page);\n\tif (page && page != pmd_page(*pmd))\n\t        goto out;\n\n\tif (pmd_trans_huge(*pmd)) {\n\t\tpage = pmd_page(*pmd);\n\t\tif (PageMlocked(page))\n\t\t\tclear_page_mlock(page);\n\t} else if (!(pmd_devmap(*pmd) || is_pmd_migration_entry(*pmd)))\n\t\tgoto out;\n\t__split_huge_pmd_locked(vma, pmd, haddr, freeze);\nout:\n\tspin_unlock(ptl);\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback.\n\t * They are 3 cases to consider inside __split_huge_pmd_locked():\n\t *  1) pmdp_huge_clear_flush_notify() call invalidate_range() obvious\n\t *  2) __split_huge_zero_page_pmd() read only zero page and any write\n\t *    fault will trigger a flush_notify before pointing to a new page\n\t *    (it is fine if the secondary mmu keeps pointing to the old zero\n\t *    page in the meantime)\n\t *  3) Split a huge pmd into pte pointing to the same page. No need\n\t *     to invalidate secondary tlb entry they are all still valid.\n\t *     any further changes to individual pte will notify. So no need\n\t *     to call mmu_notifier->invalidate_range()\n\t */\n\tmmu_notifier_invalidate_range_only_end(mm, haddr, haddr +\n\t\t\t\t\t       HPAGE_PMD_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_VMA",
          "args": [
            "vmf->vma->vm_flags & VM_SHARED",
            "vmf->vma"
          ],
          "line": 3671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmf->vma->vm_ops->huge_fault",
          "args": [
            "vmf",
            "PE_SIZE_PMD"
          ],
          "line": 3668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_huge_pmd_wp_page",
          "args": [
            "vmf",
            "orig_pmd"
          ],
          "line": 3666
        },
        "resolved": true,
        "details": {
          "function_name": "do_huge_pmd_wp_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1255-1396",
          "snippet": "vm_fault_t do_huge_pmd_wp_page(struct vm_fault *vmf, pmd_t orig_pmd)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page = NULL, *new_page;\n\tstruct mem_cgroup *memcg;\n\tunsigned long haddr = vmf->address & HPAGE_PMD_MASK;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\tgfp_t huge_gfp;\t\t\t/* for allocation and charge */\n\tvm_fault_t ret = 0;\n\n\tvmf->ptl = pmd_lockptr(vma->vm_mm, vmf->pmd);\n\tVM_BUG_ON_VMA(!vma->anon_vma, vma);\n\tif (is_huge_zero_pmd(orig_pmd))\n\t\tgoto alloc;\n\tspin_lock(vmf->ptl);\n\tif (unlikely(!pmd_same(*vmf->pmd, orig_pmd)))\n\t\tgoto out_unlock;\n\n\tpage = pmd_page(orig_pmd);\n\tVM_BUG_ON_PAGE(!PageCompound(page) || !PageHead(page), page);\n\t/*\n\t * We can only reuse the page if nobody else maps the huge page or it's\n\t * part.\n\t */\n\tif (!trylock_page(page)) {\n\t\tget_page(page);\n\t\tspin_unlock(vmf->ptl);\n\t\tlock_page(page);\n\t\tspin_lock(vmf->ptl);\n\t\tif (unlikely(!pmd_same(*vmf->pmd, orig_pmd))) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tput_page(page);\n\t}\n\tif (reuse_swap_page(page, NULL)) {\n\t\tpmd_t entry;\n\t\tentry = pmd_mkyoung(orig_pmd);\n\t\tentry = maybe_pmd_mkwrite(pmd_mkdirty(entry), vma);\n\t\tif (pmdp_set_access_flags(vma, haddr, vmf->pmd, entry,  1))\n\t\t\tupdate_mmu_cache_pmd(vma, vmf->address, vmf->pmd);\n\t\tret |= VM_FAULT_WRITE;\n\t\tunlock_page(page);\n\t\tgoto out_unlock;\n\t}\n\tunlock_page(page);\n\tget_page(page);\n\tspin_unlock(vmf->ptl);\nalloc:\n\tif (transparent_hugepage_enabled(vma) &&\n\t    !transparent_hugepage_debug_cow()) {\n\t\thuge_gfp = alloc_hugepage_direct_gfpmask(vma, haddr);\n\t\tnew_page = alloc_pages_vma(huge_gfp, HPAGE_PMD_ORDER, vma,\n\t\t\t\thaddr, numa_node_id());\n\t} else\n\t\tnew_page = NULL;\n\n\tif (likely(new_page)) {\n\t\tprep_transhuge_page(new_page);\n\t} else {\n\t\tif (!page) {\n\t\t\tsplit_huge_pmd(vma, vmf->pmd, vmf->address);\n\t\t\tret |= VM_FAULT_FALLBACK;\n\t\t} else {\n\t\t\tret = do_huge_pmd_wp_page_fallback(vmf, orig_pmd, page);\n\t\t\tif (ret & VM_FAULT_OOM) {\n\t\t\t\tsplit_huge_pmd(vma, vmf->pmd, vmf->address);\n\t\t\t\tret |= VM_FAULT_FALLBACK;\n\t\t\t}\n\t\t\tput_page(page);\n\t\t}\n\t\tcount_vm_event(THP_FAULT_FALLBACK);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(mem_cgroup_try_charge_delay(new_page, vma->vm_mm,\n\t\t\t\t\thuge_gfp, &memcg, true))) {\n\t\tput_page(new_page);\n\t\tsplit_huge_pmd(vma, vmf->pmd, vmf->address);\n\t\tif (page)\n\t\t\tput_page(page);\n\t\tret |= VM_FAULT_FALLBACK;\n\t\tcount_vm_event(THP_FAULT_FALLBACK);\n\t\tgoto out;\n\t}\n\n\tcount_vm_event(THP_FAULT_ALLOC);\n\n\tif (!page)\n\t\tclear_huge_page(new_page, vmf->address, HPAGE_PMD_NR);\n\telse\n\t\tcopy_user_huge_page(new_page, page, vmf->address,\n\t\t\t\t    vma, HPAGE_PMD_NR);\n\t__SetPageUptodate(new_page);\n\n\tmmun_start = haddr;\n\tmmun_end   = haddr + HPAGE_PMD_SIZE;\n\tmmu_notifier_invalidate_range_start(vma->vm_mm, mmun_start, mmun_end);\n\n\tspin_lock(vmf->ptl);\n\tif (page)\n\t\tput_page(page);\n\tif (unlikely(!pmd_same(*vmf->pmd, orig_pmd))) {\n\t\tspin_unlock(vmf->ptl);\n\t\tmem_cgroup_cancel_charge(new_page, memcg, true);\n\t\tput_page(new_page);\n\t\tgoto out_mn;\n\t} else {\n\t\tpmd_t entry;\n\t\tentry = mk_huge_pmd(new_page, vma->vm_page_prot);\n\t\tentry = maybe_pmd_mkwrite(pmd_mkdirty(entry), vma);\n\t\tpmdp_huge_clear_flush_notify(vma, haddr, vmf->pmd);\n\t\tpage_add_new_anon_rmap(new_page, vma, haddr, true);\n\t\tmem_cgroup_commit_charge(new_page, memcg, false, true);\n\t\tlru_cache_add_active_or_unevictable(new_page, vma);\n\t\tset_pmd_at(vma->vm_mm, haddr, vmf->pmd, entry);\n\t\tupdate_mmu_cache_pmd(vma, vmf->address, vmf->pmd);\n\t\tif (!page) {\n\t\t\tadd_mm_counter(vma->vm_mm, MM_ANONPAGES, HPAGE_PMD_NR);\n\t\t} else {\n\t\t\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\t\t\tpage_remove_rmap(page, true);\n\t\t\tput_page(page);\n\t\t}\n\t\tret |= VM_FAULT_WRITE;\n\t}\n\tspin_unlock(vmf->ptl);\nout_mn:\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback as\n\t * the above pmdp_huge_clear_flush_notify() did already call it.\n\t */\n\tmmu_notifier_invalidate_range_only_end(vma->vm_mm, mmun_start,\n\t\t\t\t\t       mmun_end);\nout:\n\treturn ret;\nout_unlock:\n\tspin_unlock(vmf->ptl);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvm_fault_t do_huge_pmd_wp_page(struct vm_fault *vmf, pmd_t orig_pmd)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page = NULL, *new_page;\n\tstruct mem_cgroup *memcg;\n\tunsigned long haddr = vmf->address & HPAGE_PMD_MASK;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\tgfp_t huge_gfp;\t\t\t/* for allocation and charge */\n\tvm_fault_t ret = 0;\n\n\tvmf->ptl = pmd_lockptr(vma->vm_mm, vmf->pmd);\n\tVM_BUG_ON_VMA(!vma->anon_vma, vma);\n\tif (is_huge_zero_pmd(orig_pmd))\n\t\tgoto alloc;\n\tspin_lock(vmf->ptl);\n\tif (unlikely(!pmd_same(*vmf->pmd, orig_pmd)))\n\t\tgoto out_unlock;\n\n\tpage = pmd_page(orig_pmd);\n\tVM_BUG_ON_PAGE(!PageCompound(page) || !PageHead(page), page);\n\t/*\n\t * We can only reuse the page if nobody else maps the huge page or it's\n\t * part.\n\t */\n\tif (!trylock_page(page)) {\n\t\tget_page(page);\n\t\tspin_unlock(vmf->ptl);\n\t\tlock_page(page);\n\t\tspin_lock(vmf->ptl);\n\t\tif (unlikely(!pmd_same(*vmf->pmd, orig_pmd))) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tput_page(page);\n\t}\n\tif (reuse_swap_page(page, NULL)) {\n\t\tpmd_t entry;\n\t\tentry = pmd_mkyoung(orig_pmd);\n\t\tentry = maybe_pmd_mkwrite(pmd_mkdirty(entry), vma);\n\t\tif (pmdp_set_access_flags(vma, haddr, vmf->pmd, entry,  1))\n\t\t\tupdate_mmu_cache_pmd(vma, vmf->address, vmf->pmd);\n\t\tret |= VM_FAULT_WRITE;\n\t\tunlock_page(page);\n\t\tgoto out_unlock;\n\t}\n\tunlock_page(page);\n\tget_page(page);\n\tspin_unlock(vmf->ptl);\nalloc:\n\tif (transparent_hugepage_enabled(vma) &&\n\t    !transparent_hugepage_debug_cow()) {\n\t\thuge_gfp = alloc_hugepage_direct_gfpmask(vma, haddr);\n\t\tnew_page = alloc_pages_vma(huge_gfp, HPAGE_PMD_ORDER, vma,\n\t\t\t\thaddr, numa_node_id());\n\t} else\n\t\tnew_page = NULL;\n\n\tif (likely(new_page)) {\n\t\tprep_transhuge_page(new_page);\n\t} else {\n\t\tif (!page) {\n\t\t\tsplit_huge_pmd(vma, vmf->pmd, vmf->address);\n\t\t\tret |= VM_FAULT_FALLBACK;\n\t\t} else {\n\t\t\tret = do_huge_pmd_wp_page_fallback(vmf, orig_pmd, page);\n\t\t\tif (ret & VM_FAULT_OOM) {\n\t\t\t\tsplit_huge_pmd(vma, vmf->pmd, vmf->address);\n\t\t\t\tret |= VM_FAULT_FALLBACK;\n\t\t\t}\n\t\t\tput_page(page);\n\t\t}\n\t\tcount_vm_event(THP_FAULT_FALLBACK);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(mem_cgroup_try_charge_delay(new_page, vma->vm_mm,\n\t\t\t\t\thuge_gfp, &memcg, true))) {\n\t\tput_page(new_page);\n\t\tsplit_huge_pmd(vma, vmf->pmd, vmf->address);\n\t\tif (page)\n\t\t\tput_page(page);\n\t\tret |= VM_FAULT_FALLBACK;\n\t\tcount_vm_event(THP_FAULT_FALLBACK);\n\t\tgoto out;\n\t}\n\n\tcount_vm_event(THP_FAULT_ALLOC);\n\n\tif (!page)\n\t\tclear_huge_page(new_page, vmf->address, HPAGE_PMD_NR);\n\telse\n\t\tcopy_user_huge_page(new_page, page, vmf->address,\n\t\t\t\t    vma, HPAGE_PMD_NR);\n\t__SetPageUptodate(new_page);\n\n\tmmun_start = haddr;\n\tmmun_end   = haddr + HPAGE_PMD_SIZE;\n\tmmu_notifier_invalidate_range_start(vma->vm_mm, mmun_start, mmun_end);\n\n\tspin_lock(vmf->ptl);\n\tif (page)\n\t\tput_page(page);\n\tif (unlikely(!pmd_same(*vmf->pmd, orig_pmd))) {\n\t\tspin_unlock(vmf->ptl);\n\t\tmem_cgroup_cancel_charge(new_page, memcg, true);\n\t\tput_page(new_page);\n\t\tgoto out_mn;\n\t} else {\n\t\tpmd_t entry;\n\t\tentry = mk_huge_pmd(new_page, vma->vm_page_prot);\n\t\tentry = maybe_pmd_mkwrite(pmd_mkdirty(entry), vma);\n\t\tpmdp_huge_clear_flush_notify(vma, haddr, vmf->pmd);\n\t\tpage_add_new_anon_rmap(new_page, vma, haddr, true);\n\t\tmem_cgroup_commit_charge(new_page, memcg, false, true);\n\t\tlru_cache_add_active_or_unevictable(new_page, vma);\n\t\tset_pmd_at(vma->vm_mm, haddr, vmf->pmd, entry);\n\t\tupdate_mmu_cache_pmd(vma, vmf->address, vmf->pmd);\n\t\tif (!page) {\n\t\t\tadd_mm_counter(vma->vm_mm, MM_ANONPAGES, HPAGE_PMD_NR);\n\t\t} else {\n\t\t\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\t\t\tpage_remove_rmap(page, true);\n\t\t\tput_page(page);\n\t\t}\n\t\tret |= VM_FAULT_WRITE;\n\t}\n\tspin_unlock(vmf->ptl);\nout_mn:\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback as\n\t * the above pmdp_huge_clear_flush_notify() did already call it.\n\t */\n\tmmu_notifier_invalidate_range_only_end(vma->vm_mm, mmun_start,\n\t\t\t\t\t       mmun_end);\nout:\n\treturn ret;\nout_unlock:\n\tspin_unlock(vmf->ptl);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_is_anonymous",
          "args": [
            "vmf->vma"
          ],
          "line": 3665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline vm_fault_t wp_huge_pmd(struct vm_fault *vmf, pmd_t orig_pmd)\n{\n\tif (vma_is_anonymous(vmf->vma))\n\t\treturn do_huge_pmd_wp_page(vmf, orig_pmd);\n\tif (vmf->vma->vm_ops->huge_fault)\n\t\treturn vmf->vma->vm_ops->huge_fault(vmf, PE_SIZE_PMD);\n\n\t/* COW handled on pte level: split pmd */\n\tVM_BUG_ON_VMA(vmf->vma->vm_flags & VM_SHARED, vmf->vma);\n\t__split_huge_pmd(vmf->vma, vmf->pmd, vmf->address, false, NULL);\n\n\treturn VM_FAULT_FALLBACK;\n}"
  },
  {
    "function_name": "create_huge_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3653-3660",
    "snippet": "static inline vm_fault_t create_huge_pmd(struct vm_fault *vmf)\n{\n\tif (vma_is_anonymous(vmf->vma))\n\t\treturn do_huge_pmd_anonymous_page(vmf);\n\tif (vmf->vma->vm_ops->huge_fault)\n\t\treturn vmf->vma->vm_ops->huge_fault(vmf, PE_SIZE_PMD);\n\treturn VM_FAULT_FALLBACK;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmf->vma->vm_ops->huge_fault",
          "args": [
            "vmf",
            "PE_SIZE_PMD"
          ],
          "line": 3658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_huge_pmd_anonymous_page",
          "args": [
            "vmf"
          ],
          "line": 3656
        },
        "resolved": true,
        "details": {
          "function_name": "do_huge_pmd_anonymous_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "685-745",
          "snippet": "vm_fault_t do_huge_pmd_anonymous_page(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tgfp_t gfp;\n\tstruct page *page;\n\tunsigned long haddr = vmf->address & HPAGE_PMD_MASK;\n\n\tif (haddr < vma->vm_start || haddr + HPAGE_PMD_SIZE > vma->vm_end)\n\t\treturn VM_FAULT_FALLBACK;\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn VM_FAULT_OOM;\n\tif (unlikely(khugepaged_enter(vma, vma->vm_flags)))\n\t\treturn VM_FAULT_OOM;\n\tif (!(vmf->flags & FAULT_FLAG_WRITE) &&\n\t\t\t!mm_forbids_zeropage(vma->vm_mm) &&\n\t\t\ttransparent_hugepage_use_zero_page()) {\n\t\tpgtable_t pgtable;\n\t\tstruct page *zero_page;\n\t\tbool set;\n\t\tvm_fault_t ret;\n\t\tpgtable = pte_alloc_one(vma->vm_mm, haddr);\n\t\tif (unlikely(!pgtable))\n\t\t\treturn VM_FAULT_OOM;\n\t\tzero_page = mm_get_huge_zero_page(vma->vm_mm);\n\t\tif (unlikely(!zero_page)) {\n\t\t\tpte_free(vma->vm_mm, pgtable);\n\t\t\tcount_vm_event(THP_FAULT_FALLBACK);\n\t\t\treturn VM_FAULT_FALLBACK;\n\t\t}\n\t\tvmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);\n\t\tret = 0;\n\t\tset = false;\n\t\tif (pmd_none(*vmf->pmd)) {\n\t\t\tret = check_stable_address_space(vma->vm_mm);\n\t\t\tif (ret) {\n\t\t\t\tspin_unlock(vmf->ptl);\n\t\t\t} else if (userfaultfd_missing(vma)) {\n\t\t\t\tspin_unlock(vmf->ptl);\n\t\t\t\tret = handle_userfault(vmf, VM_UFFD_MISSING);\n\t\t\t\tVM_BUG_ON(ret & VM_FAULT_FALLBACK);\n\t\t\t} else {\n\t\t\t\tset_huge_zero_page(pgtable, vma->vm_mm, vma,\n\t\t\t\t\t\t   haddr, vmf->pmd, zero_page);\n\t\t\t\tspin_unlock(vmf->ptl);\n\t\t\t\tset = true;\n\t\t\t}\n\t\t} else\n\t\t\tspin_unlock(vmf->ptl);\n\t\tif (!set)\n\t\t\tpte_free(vma->vm_mm, pgtable);\n\t\treturn ret;\n\t}\n\tgfp = alloc_hugepage_direct_gfpmask(vma, haddr);\n\tpage = alloc_pages_vma(gfp, HPAGE_PMD_ORDER, vma, haddr, numa_node_id());\n\tif (unlikely(!page)) {\n\t\tcount_vm_event(THP_FAULT_FALLBACK);\n\t\treturn VM_FAULT_FALLBACK;\n\t}\n\tprep_transhuge_page(page);\n\treturn __do_huge_pmd_anonymous_page(vmf, page, gfp);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvm_fault_t do_huge_pmd_anonymous_page(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tgfp_t gfp;\n\tstruct page *page;\n\tunsigned long haddr = vmf->address & HPAGE_PMD_MASK;\n\n\tif (haddr < vma->vm_start || haddr + HPAGE_PMD_SIZE > vma->vm_end)\n\t\treturn VM_FAULT_FALLBACK;\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn VM_FAULT_OOM;\n\tif (unlikely(khugepaged_enter(vma, vma->vm_flags)))\n\t\treturn VM_FAULT_OOM;\n\tif (!(vmf->flags & FAULT_FLAG_WRITE) &&\n\t\t\t!mm_forbids_zeropage(vma->vm_mm) &&\n\t\t\ttransparent_hugepage_use_zero_page()) {\n\t\tpgtable_t pgtable;\n\t\tstruct page *zero_page;\n\t\tbool set;\n\t\tvm_fault_t ret;\n\t\tpgtable = pte_alloc_one(vma->vm_mm, haddr);\n\t\tif (unlikely(!pgtable))\n\t\t\treturn VM_FAULT_OOM;\n\t\tzero_page = mm_get_huge_zero_page(vma->vm_mm);\n\t\tif (unlikely(!zero_page)) {\n\t\t\tpte_free(vma->vm_mm, pgtable);\n\t\t\tcount_vm_event(THP_FAULT_FALLBACK);\n\t\t\treturn VM_FAULT_FALLBACK;\n\t\t}\n\t\tvmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);\n\t\tret = 0;\n\t\tset = false;\n\t\tif (pmd_none(*vmf->pmd)) {\n\t\t\tret = check_stable_address_space(vma->vm_mm);\n\t\t\tif (ret) {\n\t\t\t\tspin_unlock(vmf->ptl);\n\t\t\t} else if (userfaultfd_missing(vma)) {\n\t\t\t\tspin_unlock(vmf->ptl);\n\t\t\t\tret = handle_userfault(vmf, VM_UFFD_MISSING);\n\t\t\t\tVM_BUG_ON(ret & VM_FAULT_FALLBACK);\n\t\t\t} else {\n\t\t\t\tset_huge_zero_page(pgtable, vma->vm_mm, vma,\n\t\t\t\t\t\t   haddr, vmf->pmd, zero_page);\n\t\t\t\tspin_unlock(vmf->ptl);\n\t\t\t\tset = true;\n\t\t\t}\n\t\t} else\n\t\t\tspin_unlock(vmf->ptl);\n\t\tif (!set)\n\t\t\tpte_free(vma->vm_mm, pgtable);\n\t\treturn ret;\n\t}\n\tgfp = alloc_hugepage_direct_gfpmask(vma, haddr);\n\tpage = alloc_pages_vma(gfp, HPAGE_PMD_ORDER, vma, haddr, numa_node_id());\n\tif (unlikely(!page)) {\n\t\tcount_vm_event(THP_FAULT_FALLBACK);\n\t\treturn VM_FAULT_FALLBACK;\n\t}\n\tprep_transhuge_page(page);\n\treturn __do_huge_pmd_anonymous_page(vmf, page, gfp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_is_anonymous",
          "args": [
            "vmf->vma"
          ],
          "line": 3655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline vm_fault_t create_huge_pmd(struct vm_fault *vmf)\n{\n\tif (vma_is_anonymous(vmf->vma))\n\t\treturn do_huge_pmd_anonymous_page(vmf);\n\tif (vmf->vma->vm_ops->huge_fault)\n\t\treturn vmf->vma->vm_ops->huge_fault(vmf, PE_SIZE_PMD);\n\treturn VM_FAULT_FALLBACK;\n}"
  },
  {
    "function_name": "do_numa_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3563-3651",
    "snippet": "static vm_fault_t do_numa_page(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page = NULL;\n\tint page_nid = -1;\n\tint last_cpupid;\n\tint target_nid;\n\tbool migrated = false;\n\tpte_t pte;\n\tbool was_writable = pte_savedwrite(vmf->orig_pte);\n\tint flags = 0;\n\n\t/*\n\t * The \"pte\" at this point cannot be used safely without\n\t * validation through pte_unmap_same(). It's of NUMA type but\n\t * the pfn may be screwed if the read is non atomic.\n\t */\n\tvmf->ptl = pte_lockptr(vma->vm_mm, vmf->pmd);\n\tspin_lock(vmf->ptl);\n\tif (unlikely(!pte_same(*vmf->pte, vmf->orig_pte))) {\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Make it present again, Depending on how arch implementes non\n\t * accessible ptes, some can allow access by kernel mode.\n\t */\n\tpte = ptep_modify_prot_start(vma->vm_mm, vmf->address, vmf->pte);\n\tpte = pte_modify(pte, vma->vm_page_prot);\n\tpte = pte_mkyoung(pte);\n\tif (was_writable)\n\t\tpte = pte_mkwrite(pte);\n\tptep_modify_prot_commit(vma->vm_mm, vmf->address, vmf->pte, pte);\n\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\n\n\tpage = vm_normal_page(vma, vmf->address, pte);\n\tif (!page) {\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\treturn 0;\n\t}\n\n\t/* TODO: handle PTE-mapped THP */\n\tif (PageCompound(page)) {\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Avoid grouping on RO pages in general. RO pages shouldn't hurt as\n\t * much anyway since they can be in shared cache state. This misses\n\t * the case where a mapping is writable but the process never writes\n\t * to it but pte_write gets cleared during protection updates and\n\t * pte_dirty has unpredictable behaviour between PTE scan updates,\n\t * background writeback, dirty balancing and application behaviour.\n\t */\n\tif (!pte_write(pte))\n\t\tflags |= TNF_NO_GROUP;\n\n\t/*\n\t * Flag if the page is shared between multiple address spaces. This\n\t * is later used when determining whether to group tasks together\n\t */\n\tif (page_mapcount(page) > 1 && (vma->vm_flags & VM_SHARED))\n\t\tflags |= TNF_SHARED;\n\n\tlast_cpupid = page_cpupid_last(page);\n\tpage_nid = page_to_nid(page);\n\ttarget_nid = numa_migrate_prep(page, vma, vmf->address, page_nid,\n\t\t\t&flags);\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\tif (target_nid == -1) {\n\t\tput_page(page);\n\t\tgoto out;\n\t}\n\n\t/* Migrate to the requested node */\n\tmigrated = migrate_misplaced_page(page, vma, target_nid);\n\tif (migrated) {\n\t\tpage_nid = target_nid;\n\t\tflags |= TNF_MIGRATED;\n\t} else\n\t\tflags |= TNF_MIGRATE_FAIL;\n\nout:\n\tif (page_nid != -1)\n\t\ttask_numa_fault(last_cpupid, page_nid, 1, flags);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_numa_fault",
          "args": [
            "last_cpupid",
            "page_nid",
            "1",
            "flags"
          ],
          "line": 3649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_misplaced_page",
          "args": [
            "page",
            "vma",
            "target_nid"
          ],
          "line": 3640
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_misplaced_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "1900-1947",
          "snippet": "int migrate_misplaced_page(struct page *page, struct vm_area_struct *vma,\n\t\t\t   int node)\n{\n\tpg_data_t *pgdat = NODE_DATA(node);\n\tint isolated;\n\tint nr_remaining;\n\tLIST_HEAD(migratepages);\n\n\t/*\n\t * Don't migrate file pages that are mapped in multiple processes\n\t * with execute permissions as they are probably shared libraries.\n\t */\n\tif (page_mapcount(page) != 1 && page_is_file_cache(page) &&\n\t    (vma->vm_flags & VM_EXEC))\n\t\tgoto out;\n\n\t/*\n\t * Also do not migrate dirty pages as not all filesystems can move\n\t * dirty pages in MIGRATE_ASYNC mode which is a waste of cycles.\n\t */\n\tif (page_is_file_cache(page) && PageDirty(page))\n\t\tgoto out;\n\n\tisolated = numamigrate_isolate_page(pgdat, page);\n\tif (!isolated)\n\t\tgoto out;\n\n\tlist_add(&page->lru, &migratepages);\n\tnr_remaining = migrate_pages(&migratepages, alloc_misplaced_dst_page,\n\t\t\t\t     NULL, node, MIGRATE_ASYNC,\n\t\t\t\t     MR_NUMA_MISPLACED);\n\tif (nr_remaining) {\n\t\tif (!list_empty(&migratepages)) {\n\t\t\tlist_del(&page->lru);\n\t\t\tdec_node_page_state(page, NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page));\n\t\t\tputback_lru_page(page);\n\t\t}\n\t\tisolated = 0;\n\t} else\n\t\tcount_vm_numa_event(NUMA_PAGE_MIGRATE);\n\tBUG_ON(!list_empty(&migratepages));\n\treturn isolated;\n\nout:\n\tput_page(page);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint migrate_misplaced_page(struct page *page, struct vm_area_struct *vma,\n\t\t\t   int node)\n{\n\tpg_data_t *pgdat = NODE_DATA(node);\n\tint isolated;\n\tint nr_remaining;\n\tLIST_HEAD(migratepages);\n\n\t/*\n\t * Don't migrate file pages that are mapped in multiple processes\n\t * with execute permissions as they are probably shared libraries.\n\t */\n\tif (page_mapcount(page) != 1 && page_is_file_cache(page) &&\n\t    (vma->vm_flags & VM_EXEC))\n\t\tgoto out;\n\n\t/*\n\t * Also do not migrate dirty pages as not all filesystems can move\n\t * dirty pages in MIGRATE_ASYNC mode which is a waste of cycles.\n\t */\n\tif (page_is_file_cache(page) && PageDirty(page))\n\t\tgoto out;\n\n\tisolated = numamigrate_isolate_page(pgdat, page);\n\tif (!isolated)\n\t\tgoto out;\n\n\tlist_add(&page->lru, &migratepages);\n\tnr_remaining = migrate_pages(&migratepages, alloc_misplaced_dst_page,\n\t\t\t\t     NULL, node, MIGRATE_ASYNC,\n\t\t\t\t     MR_NUMA_MISPLACED);\n\tif (nr_remaining) {\n\t\tif (!list_empty(&migratepages)) {\n\t\t\tlist_del(&page->lru);\n\t\t\tdec_node_page_state(page, NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page));\n\t\t\tputback_lru_page(page);\n\t\t}\n\t\tisolated = 0;\n\t} else\n\t\tcount_vm_numa_event(NUMA_PAGE_MIGRATE);\n\tBUG_ON(!list_empty(&migratepages));\n\treturn isolated;\n\nout:\n\tput_page(page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 3635
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "vmf->pte",
            "vmf->ptl"
          ],
          "line": 3633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_migrate_prep",
          "args": [
            "page",
            "vma",
            "vmf->address",
            "page_nid",
            "&flags"
          ],
          "line": 3631
        },
        "resolved": true,
        "details": {
          "function_name": "numa_migrate_prep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3548-3561",
          "snippet": "static int numa_migrate_prep(struct page *page, struct vm_area_struct *vma,\n\t\t\t\tunsigned long addr, int page_nid,\n\t\t\t\tint *flags)\n{\n\tget_page(page);\n\n\tcount_vm_numa_event(NUMA_HINT_FAULTS);\n\tif (page_nid == numa_node_id()) {\n\t\tcount_vm_numa_event(NUMA_HINT_FAULTS_LOCAL);\n\t\t*flags |= TNF_FAULT_LOCAL;\n\t}\n\n\treturn mpol_misplaced(page, vma, addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int numa_migrate_prep(struct page *page, struct vm_area_struct *vma,\n\t\t\t\tunsigned long addr, int page_nid,\n\t\t\t\tint *flags)\n{\n\tget_page(page);\n\n\tcount_vm_numa_event(NUMA_HINT_FAULTS);\n\tif (page_nid == numa_node_id()) {\n\t\tcount_vm_numa_event(NUMA_HINT_FAULTS_LOCAL);\n\t\t*flags |= TNF_FAULT_LOCAL;\n\t}\n\n\treturn mpol_misplaced(page, vma, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 3630
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cpupid_last",
          "args": [
            "page"
          ],
          "line": 3629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "page"
          ],
          "line": 3626
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_write",
          "args": [
            "pte"
          ],
          "line": 3619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "vmf->pte",
            "vmf->ptl"
          ],
          "line": 3607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 3606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "vmf->pte",
            "vmf->ptl"
          ],
          "line": 3601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_normal_page",
          "args": [
            "vma",
            "vmf->address",
            "pte"
          ],
          "line": 3599
        },
        "resolved": true,
        "details": {
          "function_name": "vm_normal_page_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "651-689",
          "snippet": "struct page *vm_normal_page_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tpmd_t pmd)\n{\n\tunsigned long pfn = pmd_pfn(pmd);\n\n\t/*\n\t * There is no pmd_special() but there may be special pmds, e.g.\n\t * in a direct-access (dax) mapping, so let's just replicate the\n\t * !CONFIG_ARCH_HAS_PTE_SPECIAL case from vm_normal_page() here.\n\t */\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (pmd_devmap(pmd))\n\t\treturn NULL;\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\tif (unlikely(pfn > highest_memmap_pfn))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstruct page *vm_normal_page_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tpmd_t pmd)\n{\n\tunsigned long pfn = pmd_pfn(pmd);\n\n\t/*\n\t * There is no pmd_special() but there may be special pmds, e.g.\n\t * in a direct-access (dax) mapping, so let's just replicate the\n\t * !CONFIG_ARCH_HAS_PTE_SPECIAL case from vm_normal_page() here.\n\t */\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (pmd_devmap(pmd))\n\t\treturn NULL;\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\tif (unlikely(pfn > highest_memmap_pfn))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_mmu_cache",
          "args": [
            "vma",
            "vmf->address",
            "vmf->pte"
          ],
          "line": 3597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptep_modify_prot_commit",
          "args": [
            "vma->vm_mm",
            "vmf->address",
            "vmf->pte",
            "pte"
          ],
          "line": 3596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkwrite",
          "args": [
            "pte"
          ],
          "line": 3595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkyoung",
          "args": [
            "pte"
          ],
          "line": 3593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_modify",
          "args": [
            "pte",
            "vma->vm_page_prot"
          ],
          "line": 3592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptep_modify_prot_start",
          "args": [
            "vma->vm_mm",
            "vmf->address",
            "vmf->pte"
          ],
          "line": 3591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "vmf->pte",
            "vmf->ptl"
          ],
          "line": 3583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pte_same(*vmf->pte, vmf->orig_pte)"
          ],
          "line": 3582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_same",
          "args": [
            "*vmf->pte",
            "vmf->orig_pte"
          ],
          "line": 3582
        },
        "resolved": true,
        "details": {
          "function_name": "pte_same_as_swp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1735-1738",
          "snippet": "static inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "vmf->ptl"
          ],
          "line": 3581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_lockptr",
          "args": [
            "vma->vm_mm",
            "vmf->pmd"
          ],
          "line": 3580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_savedwrite",
          "args": [
            "vmf->orig_pte"
          ],
          "line": 3572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t do_numa_page(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page = NULL;\n\tint page_nid = -1;\n\tint last_cpupid;\n\tint target_nid;\n\tbool migrated = false;\n\tpte_t pte;\n\tbool was_writable = pte_savedwrite(vmf->orig_pte);\n\tint flags = 0;\n\n\t/*\n\t * The \"pte\" at this point cannot be used safely without\n\t * validation through pte_unmap_same(). It's of NUMA type but\n\t * the pfn may be screwed if the read is non atomic.\n\t */\n\tvmf->ptl = pte_lockptr(vma->vm_mm, vmf->pmd);\n\tspin_lock(vmf->ptl);\n\tif (unlikely(!pte_same(*vmf->pte, vmf->orig_pte))) {\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Make it present again, Depending on how arch implementes non\n\t * accessible ptes, some can allow access by kernel mode.\n\t */\n\tpte = ptep_modify_prot_start(vma->vm_mm, vmf->address, vmf->pte);\n\tpte = pte_modify(pte, vma->vm_page_prot);\n\tpte = pte_mkyoung(pte);\n\tif (was_writable)\n\t\tpte = pte_mkwrite(pte);\n\tptep_modify_prot_commit(vma->vm_mm, vmf->address, vmf->pte, pte);\n\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\n\n\tpage = vm_normal_page(vma, vmf->address, pte);\n\tif (!page) {\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\treturn 0;\n\t}\n\n\t/* TODO: handle PTE-mapped THP */\n\tif (PageCompound(page)) {\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Avoid grouping on RO pages in general. RO pages shouldn't hurt as\n\t * much anyway since they can be in shared cache state. This misses\n\t * the case where a mapping is writable but the process never writes\n\t * to it but pte_write gets cleared during protection updates and\n\t * pte_dirty has unpredictable behaviour between PTE scan updates,\n\t * background writeback, dirty balancing and application behaviour.\n\t */\n\tif (!pte_write(pte))\n\t\tflags |= TNF_NO_GROUP;\n\n\t/*\n\t * Flag if the page is shared between multiple address spaces. This\n\t * is later used when determining whether to group tasks together\n\t */\n\tif (page_mapcount(page) > 1 && (vma->vm_flags & VM_SHARED))\n\t\tflags |= TNF_SHARED;\n\n\tlast_cpupid = page_cpupid_last(page);\n\tpage_nid = page_to_nid(page);\n\ttarget_nid = numa_migrate_prep(page, vma, vmf->address, page_nid,\n\t\t\t&flags);\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\tif (target_nid == -1) {\n\t\tput_page(page);\n\t\tgoto out;\n\t}\n\n\t/* Migrate to the requested node */\n\tmigrated = migrate_misplaced_page(page, vma, target_nid);\n\tif (migrated) {\n\t\tpage_nid = target_nid;\n\t\tflags |= TNF_MIGRATED;\n\t} else\n\t\tflags |= TNF_MIGRATE_FAIL;\n\nout:\n\tif (page_nid != -1)\n\t\ttask_numa_fault(last_cpupid, page_nid, 1, flags);\n\treturn 0;\n}"
  },
  {
    "function_name": "numa_migrate_prep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3548-3561",
    "snippet": "static int numa_migrate_prep(struct page *page, struct vm_area_struct *vma,\n\t\t\t\tunsigned long addr, int page_nid,\n\t\t\t\tint *flags)\n{\n\tget_page(page);\n\n\tcount_vm_numa_event(NUMA_HINT_FAULTS);\n\tif (page_nid == numa_node_id()) {\n\t\tcount_vm_numa_event(NUMA_HINT_FAULTS_LOCAL);\n\t\t*flags |= TNF_FAULT_LOCAL;\n\t}\n\n\treturn mpol_misplaced(page, vma, addr);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpol_misplaced",
          "args": [
            "page",
            "vma",
            "addr"
          ],
          "line": 3560
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_misplaced",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2273-2337",
          "snippet": "int mpol_misplaced(struct page *page, struct vm_area_struct *vma, unsigned long addr)\n{\n\tstruct mempolicy *pol;\n\tstruct zoneref *z;\n\tint curnid = page_to_nid(page);\n\tunsigned long pgoff;\n\tint thiscpu = raw_smp_processor_id();\n\tint thisnid = cpu_to_node(thiscpu);\n\tint polnid = -1;\n\tint ret = -1;\n\n\tpol = get_vma_policy(vma, addr);\n\tif (!(pol->flags & MPOL_F_MOF))\n\t\tgoto out;\n\n\tswitch (pol->mode) {\n\tcase MPOL_INTERLEAVE:\n\t\tpgoff = vma->vm_pgoff;\n\t\tpgoff += (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\tpolnid = offset_il_node(pol, pgoff);\n\t\tbreak;\n\n\tcase MPOL_PREFERRED:\n\t\tif (pol->flags & MPOL_F_LOCAL)\n\t\t\tpolnid = numa_node_id();\n\t\telse\n\t\t\tpolnid = pol->v.preferred_node;\n\t\tbreak;\n\n\tcase MPOL_BIND:\n\n\t\t/*\n\t\t * allows binding to multiple nodes.\n\t\t * use current page if in policy nodemask,\n\t\t * else select nearest allowed node, if any.\n\t\t * If no allowed nodes, use current [!misplaced].\n\t\t */\n\t\tif (node_isset(curnid, pol->v.nodes))\n\t\t\tgoto out;\n\t\tz = first_zones_zonelist(\n\t\t\t\tnode_zonelist(numa_node_id(), GFP_HIGHUSER),\n\t\t\t\tgfp_zone(GFP_HIGHUSER),\n\t\t\t\t&pol->v.nodes);\n\t\tpolnid = zone_to_nid(z->zone);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/* Migrate the page towards the node whose CPU is referencing it */\n\tif (pol->flags & MPOL_F_MORON) {\n\t\tpolnid = thisnid;\n\n\t\tif (!should_numa_migrate_memory(current, page, curnid, thiscpu))\n\t\t\tgoto out;\n\t}\n\n\tif (curnid != polnid)\n\t\tret = polnid;\nout:\n\tmpol_cond_put(pol);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nint mpol_misplaced(struct page *page, struct vm_area_struct *vma, unsigned long addr)\n{\n\tstruct mempolicy *pol;\n\tstruct zoneref *z;\n\tint curnid = page_to_nid(page);\n\tunsigned long pgoff;\n\tint thiscpu = raw_smp_processor_id();\n\tint thisnid = cpu_to_node(thiscpu);\n\tint polnid = -1;\n\tint ret = -1;\n\n\tpol = get_vma_policy(vma, addr);\n\tif (!(pol->flags & MPOL_F_MOF))\n\t\tgoto out;\n\n\tswitch (pol->mode) {\n\tcase MPOL_INTERLEAVE:\n\t\tpgoff = vma->vm_pgoff;\n\t\tpgoff += (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\tpolnid = offset_il_node(pol, pgoff);\n\t\tbreak;\n\n\tcase MPOL_PREFERRED:\n\t\tif (pol->flags & MPOL_F_LOCAL)\n\t\t\tpolnid = numa_node_id();\n\t\telse\n\t\t\tpolnid = pol->v.preferred_node;\n\t\tbreak;\n\n\tcase MPOL_BIND:\n\n\t\t/*\n\t\t * allows binding to multiple nodes.\n\t\t * use current page if in policy nodemask,\n\t\t * else select nearest allowed node, if any.\n\t\t * If no allowed nodes, use current [!misplaced].\n\t\t */\n\t\tif (node_isset(curnid, pol->v.nodes))\n\t\t\tgoto out;\n\t\tz = first_zones_zonelist(\n\t\t\t\tnode_zonelist(numa_node_id(), GFP_HIGHUSER),\n\t\t\t\tgfp_zone(GFP_HIGHUSER),\n\t\t\t\t&pol->v.nodes);\n\t\tpolnid = zone_to_nid(z->zone);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/* Migrate the page towards the node whose CPU is referencing it */\n\tif (pol->flags & MPOL_F_MORON) {\n\t\tpolnid = thisnid;\n\n\t\tif (!should_numa_migrate_memory(current, page, curnid, thiscpu))\n\t\t\tgoto out;\n\t}\n\n\tif (curnid != polnid)\n\t\tret = polnid;\nout:\n\tmpol_cond_put(pol);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_vm_numa_event",
          "args": [
            "NUMA_HINT_FAULTS_LOCAL"
          ],
          "line": 3556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_node_id",
          "args": [],
          "line": 3555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_numa_event",
          "args": [
            "NUMA_HINT_FAULTS"
          ],
          "line": 3554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 3552
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int numa_migrate_prep(struct page *page, struct vm_area_struct *vma,\n\t\t\t\tunsigned long addr, int page_nid,\n\t\t\t\tint *flags)\n{\n\tget_page(page);\n\n\tcount_vm_numa_event(NUMA_HINT_FAULTS);\n\tif (page_nid == numa_node_id()) {\n\t\tcount_vm_numa_event(NUMA_HINT_FAULTS_LOCAL);\n\t\t*flags |= TNF_FAULT_LOCAL;\n\t}\n\n\treturn mpol_misplaced(page, vma, addr);\n}"
  },
  {
    "function_name": "do_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3499-3546",
    "snippet": "static vm_fault_t do_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tvm_fault_t ret;\n\n\t/*\n\t * The VMA was not fully populated on mmap() or missing VM_DONTEXPAND\n\t */\n\tif (!vma->vm_ops->fault) {\n\t\t/*\n\t\t * If we find a migration pmd entry or a none pmd entry, which\n\t\t * should never happen, return SIGBUS\n\t\t */\n\t\tif (unlikely(!pmd_present(*vmf->pmd)))\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\telse {\n\t\t\tvmf->pte = pte_offset_map_lock(vmf->vma->vm_mm,\n\t\t\t\t\t\t       vmf->pmd,\n\t\t\t\t\t\t       vmf->address,\n\t\t\t\t\t\t       &vmf->ptl);\n\t\t\t/*\n\t\t\t * Make sure this is not a temporary clearing of pte\n\t\t\t * by holding ptl and checking again. A R/M/W update\n\t\t\t * of pte involves: take ptl, clearing the pte so that\n\t\t\t * we don't have concurrent modification by hardware\n\t\t\t * followed by an update.\n\t\t\t */\n\t\t\tif (unlikely(pte_none(*vmf->pte)))\n\t\t\t\tret = VM_FAULT_SIGBUS;\n\t\t\telse\n\t\t\t\tret = VM_FAULT_NOPAGE;\n\n\t\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\t}\n\t} else if (!(vmf->flags & FAULT_FLAG_WRITE))\n\t\tret = do_read_fault(vmf);\n\telse if (!(vma->vm_flags & VM_SHARED))\n\t\tret = do_cow_fault(vmf);\n\telse\n\t\tret = do_shared_fault(vmf);\n\n\t/* preallocated pagetable is unused: free it */\n\tif (vmf->prealloc_pte) {\n\t\tpte_free(vma->vm_mm, vmf->prealloc_pte);\n\t\tvmf->prealloc_pte = NULL;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_free",
          "args": [
            "vma->vm_mm",
            "vmf->prealloc_pte"
          ],
          "line": 3542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_shared_fault",
          "args": [
            "vmf"
          ],
          "line": 3538
        },
        "resolved": true,
        "details": {
          "function_name": "do_shared_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3458-3491",
          "snippet": "static vm_fault_t do_shared_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tvm_fault_t ret, tmp;\n\n\tret = __do_fault(vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))\n\t\treturn ret;\n\n\t/*\n\t * Check if the backing address space wants to know that the page is\n\t * about to become writable\n\t */\n\tif (vma->vm_ops->page_mkwrite) {\n\t\tunlock_page(vmf->page);\n\t\ttmp = do_page_mkwrite(vmf);\n\t\tif (unlikely(!tmp ||\n\t\t\t\t(tmp & (VM_FAULT_ERROR | VM_FAULT_NOPAGE)))) {\n\t\t\tput_page(vmf->page);\n\t\t\treturn tmp;\n\t\t}\n\t}\n\n\tret |= finish_fault(vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE |\n\t\t\t\t\tVM_FAULT_RETRY))) {\n\t\tunlock_page(vmf->page);\n\t\tput_page(vmf->page);\n\t\treturn ret;\n\t}\n\n\tfault_dirty_shared_page(vma, vmf->page);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t do_shared_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tvm_fault_t ret, tmp;\n\n\tret = __do_fault(vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))\n\t\treturn ret;\n\n\t/*\n\t * Check if the backing address space wants to know that the page is\n\t * about to become writable\n\t */\n\tif (vma->vm_ops->page_mkwrite) {\n\t\tunlock_page(vmf->page);\n\t\ttmp = do_page_mkwrite(vmf);\n\t\tif (unlikely(!tmp ||\n\t\t\t\t(tmp & (VM_FAULT_ERROR | VM_FAULT_NOPAGE)))) {\n\t\t\tput_page(vmf->page);\n\t\t\treturn tmp;\n\t\t}\n\t}\n\n\tret |= finish_fault(vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE |\n\t\t\t\t\tVM_FAULT_RETRY))) {\n\t\tunlock_page(vmf->page);\n\t\tput_page(vmf->page);\n\t\treturn ret;\n\t}\n\n\tfault_dirty_shared_page(vma, vmf->page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_cow_fault",
          "args": [
            "vmf"
          ],
          "line": 3536
        },
        "resolved": true,
        "details": {
          "function_name": "do_cow_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3419-3456",
          "snippet": "static vm_fault_t do_cow_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tvm_fault_t ret;\n\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn VM_FAULT_OOM;\n\n\tvmf->cow_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, vmf->address);\n\tif (!vmf->cow_page)\n\t\treturn VM_FAULT_OOM;\n\n\tif (mem_cgroup_try_charge_delay(vmf->cow_page, vma->vm_mm, GFP_KERNEL,\n\t\t\t\t&vmf->memcg, false)) {\n\t\tput_page(vmf->cow_page);\n\t\treturn VM_FAULT_OOM;\n\t}\n\n\tret = __do_fault(vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))\n\t\tgoto uncharge_out;\n\tif (ret & VM_FAULT_DONE_COW)\n\t\treturn ret;\n\n\tcopy_user_highpage(vmf->cow_page, vmf->page, vmf->address, vma);\n\t__SetPageUptodate(vmf->cow_page);\n\n\tret |= finish_fault(vmf);\n\tunlock_page(vmf->page);\n\tput_page(vmf->page);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))\n\t\tgoto uncharge_out;\n\treturn ret;\nuncharge_out:\n\tmem_cgroup_cancel_charge(vmf->cow_page, vmf->memcg, false);\n\tput_page(vmf->cow_page);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t do_cow_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tvm_fault_t ret;\n\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn VM_FAULT_OOM;\n\n\tvmf->cow_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, vmf->address);\n\tif (!vmf->cow_page)\n\t\treturn VM_FAULT_OOM;\n\n\tif (mem_cgroup_try_charge_delay(vmf->cow_page, vma->vm_mm, GFP_KERNEL,\n\t\t\t\t&vmf->memcg, false)) {\n\t\tput_page(vmf->cow_page);\n\t\treturn VM_FAULT_OOM;\n\t}\n\n\tret = __do_fault(vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))\n\t\tgoto uncharge_out;\n\tif (ret & VM_FAULT_DONE_COW)\n\t\treturn ret;\n\n\tcopy_user_highpage(vmf->cow_page, vmf->page, vmf->address, vma);\n\t__SetPageUptodate(vmf->cow_page);\n\n\tret |= finish_fault(vmf);\n\tunlock_page(vmf->page);\n\tput_page(vmf->page);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))\n\t\tgoto uncharge_out;\n\treturn ret;\nuncharge_out:\n\tmem_cgroup_cancel_charge(vmf->cow_page, vmf->memcg, false);\n\tput_page(vmf->cow_page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_read_fault",
          "args": [
            "vmf"
          ],
          "line": 3534
        },
        "resolved": true,
        "details": {
          "function_name": "do_read_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3392-3417",
          "snippet": "static vm_fault_t do_read_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tvm_fault_t ret = 0;\n\n\t/*\n\t * Let's call ->map_pages() first and use ->fault() as fallback\n\t * if page by the offset is not ready to be mapped (cold cache or\n\t * something).\n\t */\n\tif (vma->vm_ops->map_pages && fault_around_bytes >> PAGE_SHIFT > 1) {\n\t\tret = do_fault_around(vmf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = __do_fault(vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))\n\t\treturn ret;\n\n\tret |= finish_fault(vmf);\n\tunlock_page(vmf->page);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))\n\t\tput_page(vmf->page);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t do_read_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tvm_fault_t ret = 0;\n\n\t/*\n\t * Let's call ->map_pages() first and use ->fault() as fallback\n\t * if page by the offset is not ready to be mapped (cold cache or\n\t * something).\n\t */\n\tif (vma->vm_ops->map_pages && fault_around_bytes >> PAGE_SHIFT > 1) {\n\t\tret = do_fault_around(vmf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = __do_fault(vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))\n\t\treturn ret;\n\n\tret |= finish_fault(vmf);\n\tunlock_page(vmf->page);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))\n\t\tput_page(vmf->page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "vmf->pte",
            "vmf->ptl"
          ],
          "line": 3531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pte_none(*vmf->pte)"
          ],
          "line": 3526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "*vmf->pte"
          ],
          "line": 3526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "vmf->vma->vm_mm",
            "vmf->pmd",
            "vmf->address",
            "&vmf->ptl"
          ],
          "line": 3515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pmd_present(*vmf->pmd)"
          ],
          "line": 3512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_present",
          "args": [
            "*vmf->pmd"
          ],
          "line": 3512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t do_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tvm_fault_t ret;\n\n\t/*\n\t * The VMA was not fully populated on mmap() or missing VM_DONTEXPAND\n\t */\n\tif (!vma->vm_ops->fault) {\n\t\t/*\n\t\t * If we find a migration pmd entry or a none pmd entry, which\n\t\t * should never happen, return SIGBUS\n\t\t */\n\t\tif (unlikely(!pmd_present(*vmf->pmd)))\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\telse {\n\t\t\tvmf->pte = pte_offset_map_lock(vmf->vma->vm_mm,\n\t\t\t\t\t\t       vmf->pmd,\n\t\t\t\t\t\t       vmf->address,\n\t\t\t\t\t\t       &vmf->ptl);\n\t\t\t/*\n\t\t\t * Make sure this is not a temporary clearing of pte\n\t\t\t * by holding ptl and checking again. A R/M/W update\n\t\t\t * of pte involves: take ptl, clearing the pte so that\n\t\t\t * we don't have concurrent modification by hardware\n\t\t\t * followed by an update.\n\t\t\t */\n\t\t\tif (unlikely(pte_none(*vmf->pte)))\n\t\t\t\tret = VM_FAULT_SIGBUS;\n\t\t\telse\n\t\t\t\tret = VM_FAULT_NOPAGE;\n\n\t\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\t}\n\t} else if (!(vmf->flags & FAULT_FLAG_WRITE))\n\t\tret = do_read_fault(vmf);\n\telse if (!(vma->vm_flags & VM_SHARED))\n\t\tret = do_cow_fault(vmf);\n\telse\n\t\tret = do_shared_fault(vmf);\n\n\t/* preallocated pagetable is unused: free it */\n\tif (vmf->prealloc_pte) {\n\t\tpte_free(vma->vm_mm, vmf->prealloc_pte);\n\t\tvmf->prealloc_pte = NULL;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "do_shared_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3458-3491",
    "snippet": "static vm_fault_t do_shared_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tvm_fault_t ret, tmp;\n\n\tret = __do_fault(vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))\n\t\treturn ret;\n\n\t/*\n\t * Check if the backing address space wants to know that the page is\n\t * about to become writable\n\t */\n\tif (vma->vm_ops->page_mkwrite) {\n\t\tunlock_page(vmf->page);\n\t\ttmp = do_page_mkwrite(vmf);\n\t\tif (unlikely(!tmp ||\n\t\t\t\t(tmp & (VM_FAULT_ERROR | VM_FAULT_NOPAGE)))) {\n\t\t\tput_page(vmf->page);\n\t\t\treturn tmp;\n\t\t}\n\t}\n\n\tret |= finish_fault(vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE |\n\t\t\t\t\tVM_FAULT_RETRY))) {\n\t\tunlock_page(vmf->page);\n\t\tput_page(vmf->page);\n\t\treturn ret;\n\t}\n\n\tfault_dirty_shared_page(vma, vmf->page);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fault_dirty_shared_page",
          "args": [
            "vma",
            "vmf->page"
          ],
          "line": 3489
        },
        "resolved": true,
        "details": {
          "function_name": "fault_dirty_shared_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2166-2194",
          "snippet": "static void fault_dirty_shared_page(struct vm_area_struct *vma,\n\t\t\t\t    struct page *page)\n{\n\tstruct address_space *mapping;\n\tbool dirtied;\n\tbool page_mkwrite = vma->vm_ops && vma->vm_ops->page_mkwrite;\n\n\tdirtied = set_page_dirty(page);\n\tVM_BUG_ON_PAGE(PageAnon(page), page);\n\t/*\n\t * Take a local copy of the address_space - page.mapping may be zeroed\n\t * by truncate after unlock_page().   The address_space itself remains\n\t * pinned by vma->vm_file's reference.  We rely on unlock_page()'s\n\t * release semantics to prevent the compiler from undoing this copying.\n\t */\n\tmapping = page_rmapping(page);\n\tunlock_page(page);\n\n\tif ((dirtied || page_mkwrite) && mapping) {\n\t\t/*\n\t\t * Some device drivers do not set page.mapping\n\t\t * but still dirty their pages\n\t\t */\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t}\n\n\tif (!page_mkwrite)\n\t\tfile_update_time(vma->vm_file);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void fault_dirty_shared_page(struct vm_area_struct *vma,\n\t\t\t\t    struct page *page)\n{\n\tstruct address_space *mapping;\n\tbool dirtied;\n\tbool page_mkwrite = vma->vm_ops && vma->vm_ops->page_mkwrite;\n\n\tdirtied = set_page_dirty(page);\n\tVM_BUG_ON_PAGE(PageAnon(page), page);\n\t/*\n\t * Take a local copy of the address_space - page.mapping may be zeroed\n\t * by truncate after unlock_page().   The address_space itself remains\n\t * pinned by vma->vm_file's reference.  We rely on unlock_page()'s\n\t * release semantics to prevent the compiler from undoing this copying.\n\t */\n\tmapping = page_rmapping(page);\n\tunlock_page(page);\n\n\tif ((dirtied || page_mkwrite) && mapping) {\n\t\t/*\n\t\t * Some device drivers do not set page.mapping\n\t\t * but still dirty their pages\n\t\t */\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t}\n\n\tif (!page_mkwrite)\n\t\tfile_update_time(vma->vm_file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "vmf->page"
          ],
          "line": 3485
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "vmf->page"
          ],
          "line": 3484
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE |\n\t\t\t\t\tVM_FAULT_RETRY)"
          ],
          "line": 3482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_fault",
          "args": [
            "vmf"
          ],
          "line": 3481
        },
        "resolved": true,
        "details": {
          "function_name": "finish_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3247-3270",
          "snippet": "vm_fault_t finish_fault(struct vm_fault *vmf)\n{\n\tstruct page *page;\n\tvm_fault_t ret = 0;\n\n\t/* Did we COW the page? */\n\tif ((vmf->flags & FAULT_FLAG_WRITE) &&\n\t    !(vmf->vma->vm_flags & VM_SHARED))\n\t\tpage = vmf->cow_page;\n\telse\n\t\tpage = vmf->page;\n\n\t/*\n\t * check even for read faults because we might have lost our CoWed\n\t * page\n\t */\n\tif (!(vmf->vma->vm_flags & VM_SHARED))\n\t\tret = check_stable_address_space(vmf->vma->vm_mm);\n\tif (!ret)\n\t\tret = alloc_set_pte(vmf, vmf->memcg, page);\n\tif (vmf->pte)\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvm_fault_t finish_fault(struct vm_fault *vmf)\n{\n\tstruct page *page;\n\tvm_fault_t ret = 0;\n\n\t/* Did we COW the page? */\n\tif ((vmf->flags & FAULT_FLAG_WRITE) &&\n\t    !(vmf->vma->vm_flags & VM_SHARED))\n\t\tpage = vmf->cow_page;\n\telse\n\t\tpage = vmf->page;\n\n\t/*\n\t * check even for read faults because we might have lost our CoWed\n\t * page\n\t */\n\tif (!(vmf->vma->vm_flags & VM_SHARED))\n\t\tret = check_stable_address_space(vmf->vma->vm_mm);\n\tif (!ret)\n\t\tret = alloc_set_pte(vmf, vmf->memcg, page);\n\tif (vmf->pte)\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tmp ||\n\t\t\t\t(tmp & (VM_FAULT_ERROR | VM_FAULT_NOPAGE))"
          ],
          "line": 3474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_page_mkwrite",
          "args": [
            "vmf"
          ],
          "line": 3473
        },
        "resolved": true,
        "details": {
          "function_name": "do_page_mkwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2136-2159",
          "snippet": "static vm_fault_t do_page_mkwrite(struct vm_fault *vmf)\n{\n\tvm_fault_t ret;\n\tstruct page *page = vmf->page;\n\tunsigned int old_flags = vmf->flags;\n\n\tvmf->flags = FAULT_FLAG_WRITE|FAULT_FLAG_MKWRITE;\n\n\tret = vmf->vma->vm_ops->page_mkwrite(vmf);\n\t/* Restore original flags so that caller is not surprised */\n\tvmf->flags = old_flags;\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE)))\n\t\treturn ret;\n\tif (unlikely(!(ret & VM_FAULT_LOCKED))) {\n\t\tlock_page(page);\n\t\tif (!page->mapping) {\n\t\t\tunlock_page(page);\n\t\t\treturn 0; /* retry */\n\t\t}\n\t\tret |= VM_FAULT_LOCKED;\n\t} else\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t do_page_mkwrite(struct vm_fault *vmf)\n{\n\tvm_fault_t ret;\n\tstruct page *page = vmf->page;\n\tunsigned int old_flags = vmf->flags;\n\n\tvmf->flags = FAULT_FLAG_WRITE|FAULT_FLAG_MKWRITE;\n\n\tret = vmf->vma->vm_ops->page_mkwrite(vmf);\n\t/* Restore original flags so that caller is not surprised */\n\tvmf->flags = old_flags;\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE)))\n\t\treturn ret;\n\tif (unlikely(!(ret & VM_FAULT_LOCKED))) {\n\t\tlock_page(page);\n\t\tif (!page->mapping) {\n\t\t\tunlock_page(page);\n\t\t\treturn 0; /* retry */\n\t\t}\n\t\tret |= VM_FAULT_LOCKED;\n\t} else\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)"
          ],
          "line": 3464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__do_fault",
          "args": [
            "vmf"
          ],
          "line": 3463
        },
        "resolved": true,
        "details": {
          "function_name": "__do_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2991-3015",
          "snippet": "static vm_fault_t __do_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tvm_fault_t ret;\n\n\tret = vma->vm_ops->fault(vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY |\n\t\t\t    VM_FAULT_DONE_COW)))\n\t\treturn ret;\n\n\tif (unlikely(PageHWPoison(vmf->page))) {\n\t\tif (ret & VM_FAULT_LOCKED)\n\t\t\tunlock_page(vmf->page);\n\t\tput_page(vmf->page);\n\t\tvmf->page = NULL;\n\t\treturn VM_FAULT_HWPOISON;\n\t}\n\n\tif (unlikely(!(ret & VM_FAULT_LOCKED)))\n\t\tlock_page(vmf->page);\n\telse\n\t\tVM_BUG_ON_PAGE(!PageLocked(vmf->page), vmf->page);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t __do_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tvm_fault_t ret;\n\n\tret = vma->vm_ops->fault(vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY |\n\t\t\t    VM_FAULT_DONE_COW)))\n\t\treturn ret;\n\n\tif (unlikely(PageHWPoison(vmf->page))) {\n\t\tif (ret & VM_FAULT_LOCKED)\n\t\t\tunlock_page(vmf->page);\n\t\tput_page(vmf->page);\n\t\tvmf->page = NULL;\n\t\treturn VM_FAULT_HWPOISON;\n\t}\n\n\tif (unlikely(!(ret & VM_FAULT_LOCKED)))\n\t\tlock_page(vmf->page);\n\telse\n\t\tVM_BUG_ON_PAGE(!PageLocked(vmf->page), vmf->page);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t do_shared_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tvm_fault_t ret, tmp;\n\n\tret = __do_fault(vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))\n\t\treturn ret;\n\n\t/*\n\t * Check if the backing address space wants to know that the page is\n\t * about to become writable\n\t */\n\tif (vma->vm_ops->page_mkwrite) {\n\t\tunlock_page(vmf->page);\n\t\ttmp = do_page_mkwrite(vmf);\n\t\tif (unlikely(!tmp ||\n\t\t\t\t(tmp & (VM_FAULT_ERROR | VM_FAULT_NOPAGE)))) {\n\t\t\tput_page(vmf->page);\n\t\t\treturn tmp;\n\t\t}\n\t}\n\n\tret |= finish_fault(vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE |\n\t\t\t\t\tVM_FAULT_RETRY))) {\n\t\tunlock_page(vmf->page);\n\t\tput_page(vmf->page);\n\t\treturn ret;\n\t}\n\n\tfault_dirty_shared_page(vma, vmf->page);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_cow_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3419-3456",
    "snippet": "static vm_fault_t do_cow_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tvm_fault_t ret;\n\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn VM_FAULT_OOM;\n\n\tvmf->cow_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, vmf->address);\n\tif (!vmf->cow_page)\n\t\treturn VM_FAULT_OOM;\n\n\tif (mem_cgroup_try_charge_delay(vmf->cow_page, vma->vm_mm, GFP_KERNEL,\n\t\t\t\t&vmf->memcg, false)) {\n\t\tput_page(vmf->cow_page);\n\t\treturn VM_FAULT_OOM;\n\t}\n\n\tret = __do_fault(vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))\n\t\tgoto uncharge_out;\n\tif (ret & VM_FAULT_DONE_COW)\n\t\treturn ret;\n\n\tcopy_user_highpage(vmf->cow_page, vmf->page, vmf->address, vma);\n\t__SetPageUptodate(vmf->cow_page);\n\n\tret |= finish_fault(vmf);\n\tunlock_page(vmf->page);\n\tput_page(vmf->page);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))\n\t\tgoto uncharge_out;\n\treturn ret;\nuncharge_out:\n\tmem_cgroup_cancel_charge(vmf->cow_page, vmf->memcg, false);\n\tput_page(vmf->cow_page);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "vmf->cow_page"
          ],
          "line": 3454
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_cancel_charge",
          "args": [
            "vmf->cow_page",
            "vmf->memcg",
            "false"
          ],
          "line": 3453
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_cancel_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5972-5988",
          "snippet": "void mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,\n\t\tbool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcancel_charge(memcg, nr_pages);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,\n\t\tbool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcancel_charge(memcg, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)"
          ],
          "line": 3449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "vmf->page"
          ],
          "line": 3447
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_fault",
          "args": [
            "vmf"
          ],
          "line": 3446
        },
        "resolved": true,
        "details": {
          "function_name": "finish_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3247-3270",
          "snippet": "vm_fault_t finish_fault(struct vm_fault *vmf)\n{\n\tstruct page *page;\n\tvm_fault_t ret = 0;\n\n\t/* Did we COW the page? */\n\tif ((vmf->flags & FAULT_FLAG_WRITE) &&\n\t    !(vmf->vma->vm_flags & VM_SHARED))\n\t\tpage = vmf->cow_page;\n\telse\n\t\tpage = vmf->page;\n\n\t/*\n\t * check even for read faults because we might have lost our CoWed\n\t * page\n\t */\n\tif (!(vmf->vma->vm_flags & VM_SHARED))\n\t\tret = check_stable_address_space(vmf->vma->vm_mm);\n\tif (!ret)\n\t\tret = alloc_set_pte(vmf, vmf->memcg, page);\n\tif (vmf->pte)\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvm_fault_t finish_fault(struct vm_fault *vmf)\n{\n\tstruct page *page;\n\tvm_fault_t ret = 0;\n\n\t/* Did we COW the page? */\n\tif ((vmf->flags & FAULT_FLAG_WRITE) &&\n\t    !(vmf->vma->vm_flags & VM_SHARED))\n\t\tpage = vmf->cow_page;\n\telse\n\t\tpage = vmf->page;\n\n\t/*\n\t * check even for read faults because we might have lost our CoWed\n\t * page\n\t */\n\tif (!(vmf->vma->vm_flags & VM_SHARED))\n\t\tret = check_stable_address_space(vmf->vma->vm_mm);\n\tif (!ret)\n\t\tret = alloc_set_pte(vmf, vmf->memcg, page);\n\tif (vmf->pte)\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__SetPageUptodate",
          "args": [
            "vmf->cow_page"
          ],
          "line": 3444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_user_highpage",
          "args": [
            "vmf->cow_page",
            "vmf->page",
            "vmf->address",
            "vma"
          ],
          "line": 3443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)"
          ],
          "line": 3438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__do_fault",
          "args": [
            "vmf"
          ],
          "line": 3437
        },
        "resolved": true,
        "details": {
          "function_name": "__do_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2991-3015",
          "snippet": "static vm_fault_t __do_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tvm_fault_t ret;\n\n\tret = vma->vm_ops->fault(vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY |\n\t\t\t    VM_FAULT_DONE_COW)))\n\t\treturn ret;\n\n\tif (unlikely(PageHWPoison(vmf->page))) {\n\t\tif (ret & VM_FAULT_LOCKED)\n\t\t\tunlock_page(vmf->page);\n\t\tput_page(vmf->page);\n\t\tvmf->page = NULL;\n\t\treturn VM_FAULT_HWPOISON;\n\t}\n\n\tif (unlikely(!(ret & VM_FAULT_LOCKED)))\n\t\tlock_page(vmf->page);\n\telse\n\t\tVM_BUG_ON_PAGE(!PageLocked(vmf->page), vmf->page);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t __do_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tvm_fault_t ret;\n\n\tret = vma->vm_ops->fault(vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY |\n\t\t\t    VM_FAULT_DONE_COW)))\n\t\treturn ret;\n\n\tif (unlikely(PageHWPoison(vmf->page))) {\n\t\tif (ret & VM_FAULT_LOCKED)\n\t\t\tunlock_page(vmf->page);\n\t\tput_page(vmf->page);\n\t\tvmf->page = NULL;\n\t\treturn VM_FAULT_HWPOISON;\n\t}\n\n\tif (unlikely(!(ret & VM_FAULT_LOCKED)))\n\t\tlock_page(vmf->page);\n\telse\n\t\tVM_BUG_ON_PAGE(!PageLocked(vmf->page), vmf->page);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_try_charge_delay",
          "args": [
            "vmf->cow_page",
            "vma->vm_mm",
            "GFP_KERNEL",
            "&vmf->memcg",
            "false"
          ],
          "line": 3431
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_try_charge_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5898-5909",
          "snippet": "int mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\tret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);\n\tmemcg = *memcgp;\n\tmem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nint mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\tret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);\n\tmemcg = *memcgp;\n\tmem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page_vma",
          "args": [
            "GFP_HIGHUSER_MOVABLE",
            "vma",
            "vmf->address"
          ],
          "line": 3427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "anon_vma_prepare(vma)"
          ],
          "line": 3424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_prepare",
          "args": [
            "vma"
          ],
          "line": 3424
        },
        "resolved": true,
        "details": {
          "function_name": "__anon_vma_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "175-221",
          "snippet": "int __anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct anon_vma *anon_vma, *allocated;\n\tstruct anon_vma_chain *avc;\n\n\tmight_sleep();\n\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_enomem;\n\n\tanon_vma = find_mergeable_anon_vma(vma);\n\tallocated = NULL;\n\tif (!anon_vma) {\n\t\tanon_vma = anon_vma_alloc();\n\t\tif (unlikely(!anon_vma))\n\t\t\tgoto out_enomem_free_avc;\n\t\tallocated = anon_vma;\n\t}\n\n\tanon_vma_lock_write(anon_vma);\n\t/* page_table_lock to protect against threads */\n\tspin_lock(&mm->page_table_lock);\n\tif (likely(!vma->anon_vma)) {\n\t\tvma->anon_vma = anon_vma;\n\t\tanon_vma_chain_link(vma, avc, anon_vma);\n\t\t/* vma reference or self-parent link for new root */\n\t\tanon_vma->degree++;\n\t\tallocated = NULL;\n\t\tavc = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tanon_vma_unlock_write(anon_vma);\n\n\tif (unlikely(allocated))\n\t\tput_anon_vma(allocated);\n\tif (unlikely(avc))\n\t\tanon_vma_chain_free(avc);\n\n\treturn 0;\n\n out_enomem_free_avc:\n\tanon_vma_chain_free(avc);\n out_enomem:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint __anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct anon_vma *anon_vma, *allocated;\n\tstruct anon_vma_chain *avc;\n\n\tmight_sleep();\n\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_enomem;\n\n\tanon_vma = find_mergeable_anon_vma(vma);\n\tallocated = NULL;\n\tif (!anon_vma) {\n\t\tanon_vma = anon_vma_alloc();\n\t\tif (unlikely(!anon_vma))\n\t\t\tgoto out_enomem_free_avc;\n\t\tallocated = anon_vma;\n\t}\n\n\tanon_vma_lock_write(anon_vma);\n\t/* page_table_lock to protect against threads */\n\tspin_lock(&mm->page_table_lock);\n\tif (likely(!vma->anon_vma)) {\n\t\tvma->anon_vma = anon_vma;\n\t\tanon_vma_chain_link(vma, avc, anon_vma);\n\t\t/* vma reference or self-parent link for new root */\n\t\tanon_vma->degree++;\n\t\tallocated = NULL;\n\t\tavc = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tanon_vma_unlock_write(anon_vma);\n\n\tif (unlikely(allocated))\n\t\tput_anon_vma(allocated);\n\tif (unlikely(avc))\n\t\tanon_vma_chain_free(avc);\n\n\treturn 0;\n\n out_enomem_free_avc:\n\tanon_vma_chain_free(avc);\n out_enomem:\n\treturn -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t do_cow_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tvm_fault_t ret;\n\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn VM_FAULT_OOM;\n\n\tvmf->cow_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, vmf->address);\n\tif (!vmf->cow_page)\n\t\treturn VM_FAULT_OOM;\n\n\tif (mem_cgroup_try_charge_delay(vmf->cow_page, vma->vm_mm, GFP_KERNEL,\n\t\t\t\t&vmf->memcg, false)) {\n\t\tput_page(vmf->cow_page);\n\t\treturn VM_FAULT_OOM;\n\t}\n\n\tret = __do_fault(vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))\n\t\tgoto uncharge_out;\n\tif (ret & VM_FAULT_DONE_COW)\n\t\treturn ret;\n\n\tcopy_user_highpage(vmf->cow_page, vmf->page, vmf->address, vma);\n\t__SetPageUptodate(vmf->cow_page);\n\n\tret |= finish_fault(vmf);\n\tunlock_page(vmf->page);\n\tput_page(vmf->page);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))\n\t\tgoto uncharge_out;\n\treturn ret;\nuncharge_out:\n\tmem_cgroup_cancel_charge(vmf->cow_page, vmf->memcg, false);\n\tput_page(vmf->cow_page);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_read_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3392-3417",
    "snippet": "static vm_fault_t do_read_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tvm_fault_t ret = 0;\n\n\t/*\n\t * Let's call ->map_pages() first and use ->fault() as fallback\n\t * if page by the offset is not ready to be mapped (cold cache or\n\t * something).\n\t */\n\tif (vma->vm_ops->map_pages && fault_around_bytes >> PAGE_SHIFT > 1) {\n\t\tret = do_fault_around(vmf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = __do_fault(vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))\n\t\treturn ret;\n\n\tret |= finish_fault(vmf);\n\tunlock_page(vmf->page);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))\n\t\tput_page(vmf->page);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "vmf->page"
          ],
          "line": 3415
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)"
          ],
          "line": 3414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "vmf->page"
          ],
          "line": 3413
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_fault",
          "args": [
            "vmf"
          ],
          "line": 3412
        },
        "resolved": true,
        "details": {
          "function_name": "finish_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3247-3270",
          "snippet": "vm_fault_t finish_fault(struct vm_fault *vmf)\n{\n\tstruct page *page;\n\tvm_fault_t ret = 0;\n\n\t/* Did we COW the page? */\n\tif ((vmf->flags & FAULT_FLAG_WRITE) &&\n\t    !(vmf->vma->vm_flags & VM_SHARED))\n\t\tpage = vmf->cow_page;\n\telse\n\t\tpage = vmf->page;\n\n\t/*\n\t * check even for read faults because we might have lost our CoWed\n\t * page\n\t */\n\tif (!(vmf->vma->vm_flags & VM_SHARED))\n\t\tret = check_stable_address_space(vmf->vma->vm_mm);\n\tif (!ret)\n\t\tret = alloc_set_pte(vmf, vmf->memcg, page);\n\tif (vmf->pte)\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvm_fault_t finish_fault(struct vm_fault *vmf)\n{\n\tstruct page *page;\n\tvm_fault_t ret = 0;\n\n\t/* Did we COW the page? */\n\tif ((vmf->flags & FAULT_FLAG_WRITE) &&\n\t    !(vmf->vma->vm_flags & VM_SHARED))\n\t\tpage = vmf->cow_page;\n\telse\n\t\tpage = vmf->page;\n\n\t/*\n\t * check even for read faults because we might have lost our CoWed\n\t * page\n\t */\n\tif (!(vmf->vma->vm_flags & VM_SHARED))\n\t\tret = check_stable_address_space(vmf->vma->vm_mm);\n\tif (!ret)\n\t\tret = alloc_set_pte(vmf, vmf->memcg, page);\n\tif (vmf->pte)\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)"
          ],
          "line": 3409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__do_fault",
          "args": [
            "vmf"
          ],
          "line": 3408
        },
        "resolved": true,
        "details": {
          "function_name": "__do_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2991-3015",
          "snippet": "static vm_fault_t __do_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tvm_fault_t ret;\n\n\tret = vma->vm_ops->fault(vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY |\n\t\t\t    VM_FAULT_DONE_COW)))\n\t\treturn ret;\n\n\tif (unlikely(PageHWPoison(vmf->page))) {\n\t\tif (ret & VM_FAULT_LOCKED)\n\t\t\tunlock_page(vmf->page);\n\t\tput_page(vmf->page);\n\t\tvmf->page = NULL;\n\t\treturn VM_FAULT_HWPOISON;\n\t}\n\n\tif (unlikely(!(ret & VM_FAULT_LOCKED)))\n\t\tlock_page(vmf->page);\n\telse\n\t\tVM_BUG_ON_PAGE(!PageLocked(vmf->page), vmf->page);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t __do_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tvm_fault_t ret;\n\n\tret = vma->vm_ops->fault(vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY |\n\t\t\t    VM_FAULT_DONE_COW)))\n\t\treturn ret;\n\n\tif (unlikely(PageHWPoison(vmf->page))) {\n\t\tif (ret & VM_FAULT_LOCKED)\n\t\t\tunlock_page(vmf->page);\n\t\tput_page(vmf->page);\n\t\tvmf->page = NULL;\n\t\treturn VM_FAULT_HWPOISON;\n\t}\n\n\tif (unlikely(!(ret & VM_FAULT_LOCKED)))\n\t\tlock_page(vmf->page);\n\telse\n\t\tVM_BUG_ON_PAGE(!PageLocked(vmf->page), vmf->page);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_fault_around",
          "args": [
            "vmf"
          ],
          "line": 3403
        },
        "resolved": true,
        "details": {
          "function_name": "do_fault_around",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3336-3390",
          "snippet": "static vm_fault_t do_fault_around(struct vm_fault *vmf)\n{\n\tunsigned long address = vmf->address, nr_pages, mask;\n\tpgoff_t start_pgoff = vmf->pgoff;\n\tpgoff_t end_pgoff;\n\tint off;\n\tvm_fault_t ret = 0;\n\n\tnr_pages = READ_ONCE(fault_around_bytes) >> PAGE_SHIFT;\n\tmask = ~(nr_pages * PAGE_SIZE - 1) & PAGE_MASK;\n\n\tvmf->address = max(address & mask, vmf->vma->vm_start);\n\toff = ((address - vmf->address) >> PAGE_SHIFT) & (PTRS_PER_PTE - 1);\n\tstart_pgoff -= off;\n\n\t/*\n\t *  end_pgoff is either the end of the page table, the end of\n\t *  the vma or nr_pages from start_pgoff, depending what is nearest.\n\t */\n\tend_pgoff = start_pgoff -\n\t\t((vmf->address >> PAGE_SHIFT) & (PTRS_PER_PTE - 1)) +\n\t\tPTRS_PER_PTE - 1;\n\tend_pgoff = min3(end_pgoff, vma_pages(vmf->vma) + vmf->vma->vm_pgoff - 1,\n\t\t\tstart_pgoff + nr_pages - 1);\n\n\tif (pmd_none(*vmf->pmd)) {\n\t\tvmf->prealloc_pte = pte_alloc_one(vmf->vma->vm_mm,\n\t\t\t\t\t\t  vmf->address);\n\t\tif (!vmf->prealloc_pte)\n\t\t\tgoto out;\n\t\tsmp_wmb(); /* See comment in __pte_alloc() */\n\t}\n\n\tvmf->vma->vm_ops->map_pages(vmf, start_pgoff, end_pgoff);\n\n\t/* Huge page is mapped? Page fault is solved */\n\tif (pmd_trans_huge(*vmf->pmd)) {\n\t\tret = VM_FAULT_NOPAGE;\n\t\tgoto out;\n\t}\n\n\t/* ->map_pages() haven't done anything useful. Cold page cache? */\n\tif (!vmf->pte)\n\t\tgoto out;\n\n\t/* check if the page fault is solved */\n\tvmf->pte -= (vmf->address >> PAGE_SHIFT) - (address >> PAGE_SHIFT);\n\tif (!pte_none(*vmf->pte))\n\t\tret = VM_FAULT_NOPAGE;\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\nout:\n\tvmf->address = address;\n\tvmf->pte = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t do_fault_around(struct vm_fault *vmf)\n{\n\tunsigned long address = vmf->address, nr_pages, mask;\n\tpgoff_t start_pgoff = vmf->pgoff;\n\tpgoff_t end_pgoff;\n\tint off;\n\tvm_fault_t ret = 0;\n\n\tnr_pages = READ_ONCE(fault_around_bytes) >> PAGE_SHIFT;\n\tmask = ~(nr_pages * PAGE_SIZE - 1) & PAGE_MASK;\n\n\tvmf->address = max(address & mask, vmf->vma->vm_start);\n\toff = ((address - vmf->address) >> PAGE_SHIFT) & (PTRS_PER_PTE - 1);\n\tstart_pgoff -= off;\n\n\t/*\n\t *  end_pgoff is either the end of the page table, the end of\n\t *  the vma or nr_pages from start_pgoff, depending what is nearest.\n\t */\n\tend_pgoff = start_pgoff -\n\t\t((vmf->address >> PAGE_SHIFT) & (PTRS_PER_PTE - 1)) +\n\t\tPTRS_PER_PTE - 1;\n\tend_pgoff = min3(end_pgoff, vma_pages(vmf->vma) + vmf->vma->vm_pgoff - 1,\n\t\t\tstart_pgoff + nr_pages - 1);\n\n\tif (pmd_none(*vmf->pmd)) {\n\t\tvmf->prealloc_pte = pte_alloc_one(vmf->vma->vm_mm,\n\t\t\t\t\t\t  vmf->address);\n\t\tif (!vmf->prealloc_pte)\n\t\t\tgoto out;\n\t\tsmp_wmb(); /* See comment in __pte_alloc() */\n\t}\n\n\tvmf->vma->vm_ops->map_pages(vmf, start_pgoff, end_pgoff);\n\n\t/* Huge page is mapped? Page fault is solved */\n\tif (pmd_trans_huge(*vmf->pmd)) {\n\t\tret = VM_FAULT_NOPAGE;\n\t\tgoto out;\n\t}\n\n\t/* ->map_pages() haven't done anything useful. Cold page cache? */\n\tif (!vmf->pte)\n\t\tgoto out;\n\n\t/* check if the page fault is solved */\n\tvmf->pte -= (vmf->address >> PAGE_SHIFT) - (address >> PAGE_SHIFT);\n\tif (!pte_none(*vmf->pte))\n\t\tret = VM_FAULT_NOPAGE;\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\nout:\n\tvmf->address = address;\n\tvmf->pte = NULL;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t do_read_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tvm_fault_t ret = 0;\n\n\t/*\n\t * Let's call ->map_pages() first and use ->fault() as fallback\n\t * if page by the offset is not ready to be mapped (cold cache or\n\t * something).\n\t */\n\tif (vma->vm_ops->map_pages && fault_around_bytes >> PAGE_SHIFT > 1) {\n\t\tret = do_fault_around(vmf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = __do_fault(vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))\n\t\treturn ret;\n\n\tret |= finish_fault(vmf);\n\tunlock_page(vmf->page);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))\n\t\tput_page(vmf->page);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_fault_around",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3336-3390",
    "snippet": "static vm_fault_t do_fault_around(struct vm_fault *vmf)\n{\n\tunsigned long address = vmf->address, nr_pages, mask;\n\tpgoff_t start_pgoff = vmf->pgoff;\n\tpgoff_t end_pgoff;\n\tint off;\n\tvm_fault_t ret = 0;\n\n\tnr_pages = READ_ONCE(fault_around_bytes) >> PAGE_SHIFT;\n\tmask = ~(nr_pages * PAGE_SIZE - 1) & PAGE_MASK;\n\n\tvmf->address = max(address & mask, vmf->vma->vm_start);\n\toff = ((address - vmf->address) >> PAGE_SHIFT) & (PTRS_PER_PTE - 1);\n\tstart_pgoff -= off;\n\n\t/*\n\t *  end_pgoff is either the end of the page table, the end of\n\t *  the vma or nr_pages from start_pgoff, depending what is nearest.\n\t */\n\tend_pgoff = start_pgoff -\n\t\t((vmf->address >> PAGE_SHIFT) & (PTRS_PER_PTE - 1)) +\n\t\tPTRS_PER_PTE - 1;\n\tend_pgoff = min3(end_pgoff, vma_pages(vmf->vma) + vmf->vma->vm_pgoff - 1,\n\t\t\tstart_pgoff + nr_pages - 1);\n\n\tif (pmd_none(*vmf->pmd)) {\n\t\tvmf->prealloc_pte = pte_alloc_one(vmf->vma->vm_mm,\n\t\t\t\t\t\t  vmf->address);\n\t\tif (!vmf->prealloc_pte)\n\t\t\tgoto out;\n\t\tsmp_wmb(); /* See comment in __pte_alloc() */\n\t}\n\n\tvmf->vma->vm_ops->map_pages(vmf, start_pgoff, end_pgoff);\n\n\t/* Huge page is mapped? Page fault is solved */\n\tif (pmd_trans_huge(*vmf->pmd)) {\n\t\tret = VM_FAULT_NOPAGE;\n\t\tgoto out;\n\t}\n\n\t/* ->map_pages() haven't done anything useful. Cold page cache? */\n\tif (!vmf->pte)\n\t\tgoto out;\n\n\t/* check if the page fault is solved */\n\tvmf->pte -= (vmf->address >> PAGE_SHIFT) - (address >> PAGE_SHIFT);\n\tif (!pte_none(*vmf->pte))\n\t\tret = VM_FAULT_NOPAGE;\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\nout:\n\tvmf->address = address;\n\tvmf->pte = NULL;\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "vmf->pte",
            "vmf->ptl"
          ],
          "line": 3385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "*vmf->pte"
          ],
          "line": 3383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "*vmf->pmd"
          ],
          "line": 3372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmf->vma->vm_ops->map_pages",
          "args": [
            "vmf",
            "start_pgoff",
            "end_pgoff"
          ],
          "line": 3369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 3366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_alloc_one",
          "args": [
            "vmf->vma->vm_mm",
            "vmf->address"
          ],
          "line": 3362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "*vmf->pmd"
          ],
          "line": 3361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min3",
          "args": [
            "end_pgoff",
            "vma_pages(vmf->vma) + vmf->vma->vm_pgoff - 1",
            "start_pgoff + nr_pages - 1"
          ],
          "line": 3358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_pages",
          "args": [
            "vmf->vma"
          ],
          "line": 3358
        },
        "resolved": true,
        "details": {
          "function_name": "munlock_vma_pages_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "292-295",
          "snippet": "static inline void munlock_vma_pages_all(struct vm_area_struct *vma)\n{\n\tmunlock_vma_pages_range(vma, vma->vm_start, vma->vm_end);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void munlock_vma_pages_all(struct vm_area_struct *vma)\n{\n\tmunlock_vma_pages_range(vma, vma->vm_start, vma->vm_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "address & mask",
            "vmf->vma->vm_start"
          ],
          "line": 3347
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "fault_around_bytes"
          ],
          "line": 3344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t do_fault_around(struct vm_fault *vmf)\n{\n\tunsigned long address = vmf->address, nr_pages, mask;\n\tpgoff_t start_pgoff = vmf->pgoff;\n\tpgoff_t end_pgoff;\n\tint off;\n\tvm_fault_t ret = 0;\n\n\tnr_pages = READ_ONCE(fault_around_bytes) >> PAGE_SHIFT;\n\tmask = ~(nr_pages * PAGE_SIZE - 1) & PAGE_MASK;\n\n\tvmf->address = max(address & mask, vmf->vma->vm_start);\n\toff = ((address - vmf->address) >> PAGE_SHIFT) & (PTRS_PER_PTE - 1);\n\tstart_pgoff -= off;\n\n\t/*\n\t *  end_pgoff is either the end of the page table, the end of\n\t *  the vma or nr_pages from start_pgoff, depending what is nearest.\n\t */\n\tend_pgoff = start_pgoff -\n\t\t((vmf->address >> PAGE_SHIFT) & (PTRS_PER_PTE - 1)) +\n\t\tPTRS_PER_PTE - 1;\n\tend_pgoff = min3(end_pgoff, vma_pages(vmf->vma) + vmf->vma->vm_pgoff - 1,\n\t\t\tstart_pgoff + nr_pages - 1);\n\n\tif (pmd_none(*vmf->pmd)) {\n\t\tvmf->prealloc_pte = pte_alloc_one(vmf->vma->vm_mm,\n\t\t\t\t\t\t  vmf->address);\n\t\tif (!vmf->prealloc_pte)\n\t\t\tgoto out;\n\t\tsmp_wmb(); /* See comment in __pte_alloc() */\n\t}\n\n\tvmf->vma->vm_ops->map_pages(vmf, start_pgoff, end_pgoff);\n\n\t/* Huge page is mapped? Page fault is solved */\n\tif (pmd_trans_huge(*vmf->pmd)) {\n\t\tret = VM_FAULT_NOPAGE;\n\t\tgoto out;\n\t}\n\n\t/* ->map_pages() haven't done anything useful. Cold page cache? */\n\tif (!vmf->pte)\n\t\tgoto out;\n\n\t/* check if the page fault is solved */\n\tvmf->pte -= (vmf->address >> PAGE_SHIFT) - (address >> PAGE_SHIFT);\n\tif (!pte_none(*vmf->pte))\n\t\tret = VM_FAULT_NOPAGE;\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\nout:\n\tvmf->address = address;\n\tvmf->pte = NULL;\n\treturn ret;\n}"
  },
  {
    "function_name": "fault_around_debugfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3299-3308",
    "snippet": "static int __init fault_around_debugfs(void)\n{\n\tvoid *ret;\n\n\tret = debugfs_create_file_unsafe(\"fault_around_bytes\", 0644, NULL, NULL,\n\t\t\t&fault_around_bytes_fops);\n\tif (!ret)\n\t\tpr_warn(\"Failed to create fault_around_bytes in debugfs\");\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to create fault_around_bytes in debugfs\""
          ],
          "line": 3306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file_unsafe",
          "args": [
            "\"fault_around_bytes\"",
            "0644",
            "NULL",
            "NULL",
            "&fault_around_bytes_fops"
          ],
          "line": 3303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int __init fault_around_debugfs(void)\n{\n\tvoid *ret;\n\n\tret = debugfs_create_file_unsafe(\"fault_around_bytes\", 0644, NULL, NULL,\n\t\t\t&fault_around_bytes_fops);\n\tif (!ret)\n\t\tpr_warn(\"Failed to create fault_around_bytes in debugfs\");\n\treturn 0;\n}"
  },
  {
    "function_name": "fault_around_bytes_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3286-3295",
    "snippet": "static int fault_around_bytes_set(void *data, u64 val)\n{\n\tif (val / PAGE_SIZE > PTRS_PER_PTE)\n\t\treturn -EINVAL;\n\tif (val > PAGE_SIZE)\n\t\tfault_around_bytes = rounddown_pow_of_two(val);\n\telse\n\t\tfault_around_bytes = PAGE_SIZE; /* rounddown_pow_of_two(0) is undefined */\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rounddown_pow_of_two",
          "args": [
            "val"
          ],
          "line": 3291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int fault_around_bytes_set(void *data, u64 val)\n{\n\tif (val / PAGE_SIZE > PTRS_PER_PTE)\n\t\treturn -EINVAL;\n\tif (val > PAGE_SIZE)\n\t\tfault_around_bytes = rounddown_pow_of_two(val);\n\telse\n\t\tfault_around_bytes = PAGE_SIZE; /* rounddown_pow_of_two(0) is undefined */\n\treturn 0;\n}"
  },
  {
    "function_name": "fault_around_bytes_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3276-3280",
    "snippet": "static int fault_around_bytes_get(void *data, u64 *val)\n{\n\t*val = fault_around_bytes;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int fault_around_bytes_get(void *data, u64 *val)\n{\n\t*val = fault_around_bytes;\n\treturn 0;\n}"
  },
  {
    "function_name": "finish_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3247-3270",
    "snippet": "vm_fault_t finish_fault(struct vm_fault *vmf)\n{\n\tstruct page *page;\n\tvm_fault_t ret = 0;\n\n\t/* Did we COW the page? */\n\tif ((vmf->flags & FAULT_FLAG_WRITE) &&\n\t    !(vmf->vma->vm_flags & VM_SHARED))\n\t\tpage = vmf->cow_page;\n\telse\n\t\tpage = vmf->page;\n\n\t/*\n\t * check even for read faults because we might have lost our CoWed\n\t * page\n\t */\n\tif (!(vmf->vma->vm_flags & VM_SHARED))\n\t\tret = check_stable_address_space(vmf->vma->vm_mm);\n\tif (!ret)\n\t\tret = alloc_set_pte(vmf, vmf->memcg, page);\n\tif (vmf->pte)\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "vmf->pte",
            "vmf->ptl"
          ],
          "line": 3268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_set_pte",
          "args": [
            "vmf",
            "vmf->memcg",
            "page"
          ],
          "line": 3266
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_set_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3182-3230",
          "snippet": "vm_fault_t alloc_set_pte(struct vm_fault *vmf, struct mem_cgroup *memcg,\n\t\tstruct page *page)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\tpte_t entry;\n\tvm_fault_t ret;\n\n\tif (pmd_none(*vmf->pmd) && PageTransCompound(page) &&\n\t\t\tIS_ENABLED(CONFIG_TRANSPARENT_HUGE_PAGECACHE)) {\n\t\t/* THP on COW? */\n\t\tVM_BUG_ON_PAGE(memcg, page);\n\n\t\tret = do_set_pmd(vmf, page);\n\t\tif (ret != VM_FAULT_FALLBACK)\n\t\t\treturn ret;\n\t}\n\n\tif (!vmf->pte) {\n\t\tret = pte_alloc_one_map(vmf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Re-check under ptl */\n\tif (unlikely(!pte_none(*vmf->pte)))\n\t\treturn VM_FAULT_NOPAGE;\n\n\tflush_icache_page(vma, page);\n\tentry = mk_pte(page, vma->vm_page_prot);\n\tif (write)\n\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t/* copy-on-write page */\n\tif (write && !(vma->vm_flags & VM_SHARED)) {\n\t\tinc_mm_counter_fast(vma->vm_mm, MM_ANONPAGES);\n\t\tpage_add_new_anon_rmap(page, vma, vmf->address, false);\n\t\tmem_cgroup_commit_charge(page, memcg, false, false);\n\t\tlru_cache_add_active_or_unevictable(page, vma);\n\t} else {\n\t\tinc_mm_counter_fast(vma->vm_mm, mm_counter_file(page));\n\t\tpage_add_file_rmap(page, false);\n\t}\n\tset_pte_at(vma->vm_mm, vmf->address, vmf->pte, entry);\n\n\t/* no need to invalidate: a not-present page won't be cached */\n\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvm_fault_t alloc_set_pte(struct vm_fault *vmf, struct mem_cgroup *memcg,\n\t\tstruct page *page)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\tpte_t entry;\n\tvm_fault_t ret;\n\n\tif (pmd_none(*vmf->pmd) && PageTransCompound(page) &&\n\t\t\tIS_ENABLED(CONFIG_TRANSPARENT_HUGE_PAGECACHE)) {\n\t\t/* THP on COW? */\n\t\tVM_BUG_ON_PAGE(memcg, page);\n\n\t\tret = do_set_pmd(vmf, page);\n\t\tif (ret != VM_FAULT_FALLBACK)\n\t\t\treturn ret;\n\t}\n\n\tif (!vmf->pte) {\n\t\tret = pte_alloc_one_map(vmf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Re-check under ptl */\n\tif (unlikely(!pte_none(*vmf->pte)))\n\t\treturn VM_FAULT_NOPAGE;\n\n\tflush_icache_page(vma, page);\n\tentry = mk_pte(page, vma->vm_page_prot);\n\tif (write)\n\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t/* copy-on-write page */\n\tif (write && !(vma->vm_flags & VM_SHARED)) {\n\t\tinc_mm_counter_fast(vma->vm_mm, MM_ANONPAGES);\n\t\tpage_add_new_anon_rmap(page, vma, vmf->address, false);\n\t\tmem_cgroup_commit_charge(page, memcg, false, false);\n\t\tlru_cache_add_active_or_unevictable(page, vma);\n\t} else {\n\t\tinc_mm_counter_fast(vma->vm_mm, mm_counter_file(page));\n\t\tpage_add_file_rmap(page, false);\n\t}\n\tset_pte_at(vma->vm_mm, vmf->address, vmf->pte, entry);\n\n\t/* no need to invalidate: a not-present page won't be cached */\n\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_stable_address_space",
          "args": [
            "vmf->vma->vm_mm"
          ],
          "line": 3264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvm_fault_t finish_fault(struct vm_fault *vmf)\n{\n\tstruct page *page;\n\tvm_fault_t ret = 0;\n\n\t/* Did we COW the page? */\n\tif ((vmf->flags & FAULT_FLAG_WRITE) &&\n\t    !(vmf->vma->vm_flags & VM_SHARED))\n\t\tpage = vmf->cow_page;\n\telse\n\t\tpage = vmf->page;\n\n\t/*\n\t * check even for read faults because we might have lost our CoWed\n\t * page\n\t */\n\tif (!(vmf->vma->vm_flags & VM_SHARED))\n\t\tret = check_stable_address_space(vmf->vma->vm_mm);\n\tif (!ret)\n\t\tret = alloc_set_pte(vmf, vmf->memcg, page);\n\tif (vmf->pte)\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\treturn ret;\n}"
  },
  {
    "function_name": "alloc_set_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3182-3230",
    "snippet": "vm_fault_t alloc_set_pte(struct vm_fault *vmf, struct mem_cgroup *memcg,\n\t\tstruct page *page)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\tpte_t entry;\n\tvm_fault_t ret;\n\n\tif (pmd_none(*vmf->pmd) && PageTransCompound(page) &&\n\t\t\tIS_ENABLED(CONFIG_TRANSPARENT_HUGE_PAGECACHE)) {\n\t\t/* THP on COW? */\n\t\tVM_BUG_ON_PAGE(memcg, page);\n\n\t\tret = do_set_pmd(vmf, page);\n\t\tif (ret != VM_FAULT_FALLBACK)\n\t\t\treturn ret;\n\t}\n\n\tif (!vmf->pte) {\n\t\tret = pte_alloc_one_map(vmf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Re-check under ptl */\n\tif (unlikely(!pte_none(*vmf->pte)))\n\t\treturn VM_FAULT_NOPAGE;\n\n\tflush_icache_page(vma, page);\n\tentry = mk_pte(page, vma->vm_page_prot);\n\tif (write)\n\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t/* copy-on-write page */\n\tif (write && !(vma->vm_flags & VM_SHARED)) {\n\t\tinc_mm_counter_fast(vma->vm_mm, MM_ANONPAGES);\n\t\tpage_add_new_anon_rmap(page, vma, vmf->address, false);\n\t\tmem_cgroup_commit_charge(page, memcg, false, false);\n\t\tlru_cache_add_active_or_unevictable(page, vma);\n\t} else {\n\t\tinc_mm_counter_fast(vma->vm_mm, mm_counter_file(page));\n\t\tpage_add_file_rmap(page, false);\n\t}\n\tset_pte_at(vma->vm_mm, vmf->address, vmf->pte, entry);\n\n\t/* no need to invalidate: a not-present page won't be cached */\n\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_mmu_cache",
          "args": [
            "vma",
            "vmf->address",
            "vmf->pte"
          ],
          "line": 3227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "vma->vm_mm",
            "vmf->address",
            "vmf->pte",
            "entry"
          ],
          "line": 3224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_add_file_rmap",
          "args": [
            "page",
            "false"
          ],
          "line": 3222
        },
        "resolved": true,
        "details": {
          "function_name": "page_add_file_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1179-1208",
          "snippet": "void page_add_file_rmap(struct page *page, bool compound)\n{\n\tint i, nr = 1;\n\n\tVM_BUG_ON_PAGE(compound && !PageTransHuge(page), page);\n\tlock_page_memcg(page);\n\tif (compound && PageTransHuge(page)) {\n\t\tfor (i = 0, nr = 0; i < HPAGE_PMD_NR; i++) {\n\t\t\tif (atomic_inc_and_test(&page[i]._mapcount))\n\t\t\t\tnr++;\n\t\t}\n\t\tif (!atomic_inc_and_test(compound_mapcount_ptr(page)))\n\t\t\tgoto out;\n\t\tVM_BUG_ON_PAGE(!PageSwapBacked(page), page);\n\t\t__inc_node_page_state(page, NR_SHMEM_PMDMAPPED);\n\t} else {\n\t\tif (PageTransCompound(page) && page_mapping(page)) {\n\t\t\tVM_WARN_ON_ONCE(!PageLocked(page));\n\n\t\t\tSetPageDoubleMap(compound_head(page));\n\t\t\tif (PageMlocked(page))\n\t\t\t\tclear_page_mlock(compound_head(page));\n\t\t}\n\t\tif (!atomic_inc_and_test(&page->_mapcount))\n\t\t\tgoto out;\n\t}\n\t__mod_lruvec_page_state(page, NR_FILE_MAPPED, nr);\nout:\n\tunlock_page_memcg(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_add_file_rmap(struct page *page, bool compound)\n{\n\tint i, nr = 1;\n\n\tVM_BUG_ON_PAGE(compound && !PageTransHuge(page), page);\n\tlock_page_memcg(page);\n\tif (compound && PageTransHuge(page)) {\n\t\tfor (i = 0, nr = 0; i < HPAGE_PMD_NR; i++) {\n\t\t\tif (atomic_inc_and_test(&page[i]._mapcount))\n\t\t\t\tnr++;\n\t\t}\n\t\tif (!atomic_inc_and_test(compound_mapcount_ptr(page)))\n\t\t\tgoto out;\n\t\tVM_BUG_ON_PAGE(!PageSwapBacked(page), page);\n\t\t__inc_node_page_state(page, NR_SHMEM_PMDMAPPED);\n\t} else {\n\t\tif (PageTransCompound(page) && page_mapping(page)) {\n\t\t\tVM_WARN_ON_ONCE(!PageLocked(page));\n\n\t\t\tSetPageDoubleMap(compound_head(page));\n\t\t\tif (PageMlocked(page))\n\t\t\t\tclear_page_mlock(compound_head(page));\n\t\t}\n\t\tif (!atomic_inc_and_test(&page->_mapcount))\n\t\t\tgoto out;\n\t}\n\t__mod_lruvec_page_state(page, NR_FILE_MAPPED, nr);\nout:\n\tunlock_page_memcg(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_mm_counter_fast",
          "args": [
            "vma->vm_mm",
            "mm_counter_file(page)"
          ],
          "line": 3221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_counter_file",
          "args": [
            "page"
          ],
          "line": 3221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_cache_add_active_or_unevictable",
          "args": [
            "page",
            "vma"
          ],
          "line": 3219
        },
        "resolved": true,
        "details": {
          "function_name": "lru_cache_add_active_or_unevictable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "458-476",
          "snippet": "void lru_cache_add_active_or_unevictable(struct page *page,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\tif (likely((vma->vm_flags & (VM_LOCKED | VM_SPECIAL)) != VM_LOCKED))\n\t\tSetPageActive(page);\n\telse if (!TestSetPageMlocked(page)) {\n\t\t/*\n\t\t * We use the irq-unsafe __mod_zone_page_stat because this\n\t\t * counter is not modified from interrupt context, and the pte\n\t\t * lock is held(spinlock), which implies preemption disabled.\n\t\t */\n\t\t__mod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t}\n\tlru_cache_add(page);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid lru_cache_add_active_or_unevictable(struct page *page,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\tif (likely((vma->vm_flags & (VM_LOCKED | VM_SPECIAL)) != VM_LOCKED))\n\t\tSetPageActive(page);\n\telse if (!TestSetPageMlocked(page)) {\n\t\t/*\n\t\t * We use the irq-unsafe __mod_zone_page_stat because this\n\t\t * counter is not modified from interrupt context, and the pte\n\t\t * lock is held(spinlock), which implies preemption disabled.\n\t\t */\n\t\t__mod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t}\n\tlru_cache_add(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_commit_charge",
          "args": [
            "page",
            "memcg",
            "false",
            "false"
          ],
          "line": 3218
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_commit_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5928-5962",
          "snippet": "void mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t      bool lrucare, bool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_PAGE(!page->mapping, page);\n\tVM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcommit_charge(page, memcg, lrucare);\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(memcg, page, compound, nr_pages);\n\tmemcg_check_events(memcg, page);\n\tlocal_irq_enable();\n\n\tif (do_memsw_account() && PageSwapCache(page)) {\n\t\tswp_entry_t entry = { .val = page_private(page) };\n\t\t/*\n\t\t * The swap entry might not get freed for a long time,\n\t\t * let's not wait for it.  The page already received a\n\t\t * memory+swap charge, drop the swap entry duplicate.\n\t\t */\n\t\tmem_cgroup_uncharge_swap(entry, nr_pages);\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t      bool lrucare, bool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_PAGE(!page->mapping, page);\n\tVM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcommit_charge(page, memcg, lrucare);\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(memcg, page, compound, nr_pages);\n\tmemcg_check_events(memcg, page);\n\tlocal_irq_enable();\n\n\tif (do_memsw_account() && PageSwapCache(page)) {\n\t\tswp_entry_t entry = { .val = page_private(page) };\n\t\t/*\n\t\t * The swap entry might not get freed for a long time,\n\t\t * let's not wait for it.  The page already received a\n\t\t * memory+swap charge, drop the swap entry duplicate.\n\t\t */\n\t\tmem_cgroup_uncharge_swap(entry, nr_pages);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_add_new_anon_rmap",
          "args": [
            "page",
            "vma",
            "vmf->address",
            "false"
          ],
          "line": 3217
        },
        "resolved": true,
        "details": {
          "function_name": "page_add_new_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1150-1170",
          "snippet": "void page_add_new_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, bool compound)\n{\n\tint nr = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\t__SetPageSwapBacked(page);\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(compound_mapcount_ptr(page), 0);\n\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t} else {\n\t\t/* Anon THP always mapped first with PMD */\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(&page->_mapcount, 0);\n\t}\n\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t__page_set_anon_rmap(page, vma, address, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_add_new_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, bool compound)\n{\n\tint nr = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\t__SetPageSwapBacked(page);\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(compound_mapcount_ptr(page), 0);\n\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t} else {\n\t\t/* Anon THP always mapped first with PMD */\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(&page->_mapcount, 0);\n\t}\n\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t__page_set_anon_rmap(page, vma, address, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_mm_counter_fast",
          "args": [
            "vma->vm_mm",
            "MM_ANONPAGES"
          ],
          "line": 3216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "maybe_mkwrite",
          "args": [
            "pte_mkdirty(entry)",
            "vma"
          ],
          "line": 3213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkdirty",
          "args": [
            "entry"
          ],
          "line": 3213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mk_pte",
          "args": [
            "page",
            "vma->vm_page_prot"
          ],
          "line": 3211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_icache_page",
          "args": [
            "vma",
            "page"
          ],
          "line": 3210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pte_none(*vmf->pte)"
          ],
          "line": 3207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "*vmf->pte"
          ],
          "line": 3207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_alloc_one_map",
          "args": [
            "vmf"
          ],
          "line": 3201
        },
        "resolved": true,
        "details": {
          "function_name": "pte_alloc_one_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3028-3075",
          "snippet": "static vm_fault_t pte_alloc_one_map(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\n\tif (!pmd_none(*vmf->pmd))\n\t\tgoto map_pte;\n\tif (vmf->prealloc_pte) {\n\t\tvmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);\n\t\tif (unlikely(!pmd_none(*vmf->pmd))) {\n\t\t\tspin_unlock(vmf->ptl);\n\t\t\tgoto map_pte;\n\t\t}\n\n\t\tmm_inc_nr_ptes(vma->vm_mm);\n\t\tpmd_populate(vma->vm_mm, vmf->pmd, vmf->prealloc_pte);\n\t\tspin_unlock(vmf->ptl);\n\t\tvmf->prealloc_pte = NULL;\n\t} else if (unlikely(pte_alloc(vma->vm_mm, vmf->pmd, vmf->address))) {\n\t\treturn VM_FAULT_OOM;\n\t}\nmap_pte:\n\t/*\n\t * If a huge pmd materialized under us just retry later.  Use\n\t * pmd_trans_unstable() via pmd_devmap_trans_unstable() instead of\n\t * pmd_trans_huge() to ensure the pmd didn't become pmd_trans_huge\n\t * under us and then back to pmd_none, as a result of MADV_DONTNEED\n\t * running immediately after a huge pmd fault in a different thread of\n\t * this mm, in turn leading to a misleading pmd_trans_huge() retval.\n\t * All we have to ensure is that it is a regular pmd that we can walk\n\t * with pte_offset_map() and we can do that through an atomic read in\n\t * C, which is what pmd_trans_unstable() provides.\n\t */\n\tif (pmd_devmap_trans_unstable(vmf->pmd))\n\t\treturn VM_FAULT_NOPAGE;\n\n\t/*\n\t * At this point we know that our vmf->pmd points to a page of ptes\n\t * and it cannot become pmd_none(), pmd_devmap() or pmd_trans_huge()\n\t * for the duration of the fault.  If a racing MADV_DONTNEED runs and\n\t * we zap the ptes pointed to by our vmf->pmd, the vmf->ptl will still\n\t * be valid and we will re-check to make sure the vmf->pte isn't\n\t * pte_none() under vmf->ptl protection when we return to\n\t * alloc_set_pte().\n\t */\n\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd, vmf->address,\n\t\t\t&vmf->ptl);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t pte_alloc_one_map(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\n\tif (!pmd_none(*vmf->pmd))\n\t\tgoto map_pte;\n\tif (vmf->prealloc_pte) {\n\t\tvmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);\n\t\tif (unlikely(!pmd_none(*vmf->pmd))) {\n\t\t\tspin_unlock(vmf->ptl);\n\t\t\tgoto map_pte;\n\t\t}\n\n\t\tmm_inc_nr_ptes(vma->vm_mm);\n\t\tpmd_populate(vma->vm_mm, vmf->pmd, vmf->prealloc_pte);\n\t\tspin_unlock(vmf->ptl);\n\t\tvmf->prealloc_pte = NULL;\n\t} else if (unlikely(pte_alloc(vma->vm_mm, vmf->pmd, vmf->address))) {\n\t\treturn VM_FAULT_OOM;\n\t}\nmap_pte:\n\t/*\n\t * If a huge pmd materialized under us just retry later.  Use\n\t * pmd_trans_unstable() via pmd_devmap_trans_unstable() instead of\n\t * pmd_trans_huge() to ensure the pmd didn't become pmd_trans_huge\n\t * under us and then back to pmd_none, as a result of MADV_DONTNEED\n\t * running immediately after a huge pmd fault in a different thread of\n\t * this mm, in turn leading to a misleading pmd_trans_huge() retval.\n\t * All we have to ensure is that it is a regular pmd that we can walk\n\t * with pte_offset_map() and we can do that through an atomic read in\n\t * C, which is what pmd_trans_unstable() provides.\n\t */\n\tif (pmd_devmap_trans_unstable(vmf->pmd))\n\t\treturn VM_FAULT_NOPAGE;\n\n\t/*\n\t * At this point we know that our vmf->pmd points to a page of ptes\n\t * and it cannot become pmd_none(), pmd_devmap() or pmd_trans_huge()\n\t * for the duration of the fault.  If a racing MADV_DONTNEED runs and\n\t * we zap the ptes pointed to by our vmf->pmd, the vmf->ptl will still\n\t * be valid and we will re-check to make sure the vmf->pte isn't\n\t * pte_none() under vmf->ptl protection when we return to\n\t * alloc_set_pte().\n\t */\n\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd, vmf->address,\n\t\t\t&vmf->ptl);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_set_pmd",
          "args": [
            "vmf",
            "page"
          ],
          "line": 3195
        },
        "resolved": true,
        "details": {
          "function_name": "do_set_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3161-3165",
          "snippet": "static vm_fault_t do_set_pmd(struct vm_fault *vmf, struct page *page)\n{\n\tBUILD_BUG();\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t do_set_pmd(struct vm_fault *vmf, struct page *page)\n{\n\tBUILD_BUG();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "memcg",
            "page"
          ],
          "line": 3193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_TRANSPARENT_HUGE_PAGECACHE"
          ],
          "line": 3191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "page"
          ],
          "line": 3190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "*vmf->pmd"
          ],
          "line": 3190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvm_fault_t alloc_set_pte(struct vm_fault *vmf, struct mem_cgroup *memcg,\n\t\tstruct page *page)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\tpte_t entry;\n\tvm_fault_t ret;\n\n\tif (pmd_none(*vmf->pmd) && PageTransCompound(page) &&\n\t\t\tIS_ENABLED(CONFIG_TRANSPARENT_HUGE_PAGECACHE)) {\n\t\t/* THP on COW? */\n\t\tVM_BUG_ON_PAGE(memcg, page);\n\n\t\tret = do_set_pmd(vmf, page);\n\t\tif (ret != VM_FAULT_FALLBACK)\n\t\t\treturn ret;\n\t}\n\n\tif (!vmf->pte) {\n\t\tret = pte_alloc_one_map(vmf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Re-check under ptl */\n\tif (unlikely(!pte_none(*vmf->pte)))\n\t\treturn VM_FAULT_NOPAGE;\n\n\tflush_icache_page(vma, page);\n\tentry = mk_pte(page, vma->vm_page_prot);\n\tif (write)\n\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t/* copy-on-write page */\n\tif (write && !(vma->vm_flags & VM_SHARED)) {\n\t\tinc_mm_counter_fast(vma->vm_mm, MM_ANONPAGES);\n\t\tpage_add_new_anon_rmap(page, vma, vmf->address, false);\n\t\tmem_cgroup_commit_charge(page, memcg, false, false);\n\t\tlru_cache_add_active_or_unevictable(page, vma);\n\t} else {\n\t\tinc_mm_counter_fast(vma->vm_mm, mm_counter_file(page));\n\t\tpage_add_file_rmap(page, false);\n\t}\n\tset_pte_at(vma->vm_mm, vmf->address, vmf->pte, entry);\n\n\t/* no need to invalidate: a not-present page won't be cached */\n\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "do_set_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3161-3165",
    "snippet": "static vm_fault_t do_set_pmd(struct vm_fault *vmf, struct page *page)\n{\n\tBUILD_BUG();\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUILD_BUG",
          "args": [],
          "line": 3163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t do_set_pmd(struct vm_fault *vmf, struct page *page)\n{\n\tBUILD_BUG();\n\treturn 0;\n}"
  },
  {
    "function_name": "do_set_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3104-3159",
    "snippet": "static vm_fault_t do_set_pmd(struct vm_fault *vmf, struct page *page)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\tunsigned long haddr = vmf->address & HPAGE_PMD_MASK;\n\tpmd_t entry;\n\tint i;\n\tvm_fault_t ret;\n\n\tif (!transhuge_vma_suitable(vma, haddr))\n\t\treturn VM_FAULT_FALLBACK;\n\n\tret = VM_FAULT_FALLBACK;\n\tpage = compound_head(page);\n\n\t/*\n\t * Archs like ppc64 need additonal space to store information\n\t * related to pte entry. Use the preallocated table for that.\n\t */\n\tif (arch_needs_pgtable_deposit() && !vmf->prealloc_pte) {\n\t\tvmf->prealloc_pte = pte_alloc_one(vma->vm_mm, vmf->address);\n\t\tif (!vmf->prealloc_pte)\n\t\t\treturn VM_FAULT_OOM;\n\t\tsmp_wmb(); /* See comment in __pte_alloc() */\n\t}\n\n\tvmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);\n\tif (unlikely(!pmd_none(*vmf->pmd)))\n\t\tgoto out;\n\n\tfor (i = 0; i < HPAGE_PMD_NR; i++)\n\t\tflush_icache_page(vma, page + i);\n\n\tentry = mk_huge_pmd(page, vma->vm_page_prot);\n\tif (write)\n\t\tentry = maybe_pmd_mkwrite(pmd_mkdirty(entry), vma);\n\n\tadd_mm_counter(vma->vm_mm, mm_counter_file(page), HPAGE_PMD_NR);\n\tpage_add_file_rmap(page, true);\n\t/*\n\t * deposit and withdraw with pmd lock held\n\t */\n\tif (arch_needs_pgtable_deposit())\n\t\tdeposit_prealloc_pte(vmf);\n\n\tset_pmd_at(vma->vm_mm, haddr, vmf->pmd, entry);\n\n\tupdate_mmu_cache_pmd(vma, haddr, vmf->pmd);\n\n\t/* fault is handled */\n\tret = 0;\n\tcount_vm_event(THP_FILE_MAPPED);\nout:\n\tspin_unlock(vmf->ptl);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "vmf->ptl"
          ],
          "line": 3157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "THP_FILE_MAPPED"
          ],
          "line": 3155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_mmu_cache_pmd",
          "args": [
            "vma",
            "haddr",
            "vmf->pmd"
          ],
          "line": 3151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pmd_at",
          "args": [
            "vma->vm_mm",
            "haddr",
            "vmf->pmd",
            "entry"
          ],
          "line": 3149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deposit_prealloc_pte",
          "args": [
            "vmf"
          ],
          "line": 3147
        },
        "resolved": true,
        "details": {
          "function_name": "deposit_prealloc_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3091-3102",
          "snippet": "static void deposit_prealloc_pte(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\n\tpgtable_trans_huge_deposit(vma->vm_mm, vmf->pmd, vmf->prealloc_pte);\n\t/*\n\t * We are going to consume the prealloc table,\n\t * count that as nr_ptes.\n\t */\n\tmm_inc_nr_ptes(vma->vm_mm);\n\tvmf->prealloc_pte = NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void deposit_prealloc_pte(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\n\tpgtable_trans_huge_deposit(vma->vm_mm, vmf->pmd, vmf->prealloc_pte);\n\t/*\n\t * We are going to consume the prealloc table,\n\t * count that as nr_ptes.\n\t */\n\tmm_inc_nr_ptes(vma->vm_mm);\n\tvmf->prealloc_pte = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_needs_pgtable_deposit",
          "args": [],
          "line": 3146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_add_file_rmap",
          "args": [
            "page",
            "true"
          ],
          "line": 3142
        },
        "resolved": true,
        "details": {
          "function_name": "page_add_file_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1179-1208",
          "snippet": "void page_add_file_rmap(struct page *page, bool compound)\n{\n\tint i, nr = 1;\n\n\tVM_BUG_ON_PAGE(compound && !PageTransHuge(page), page);\n\tlock_page_memcg(page);\n\tif (compound && PageTransHuge(page)) {\n\t\tfor (i = 0, nr = 0; i < HPAGE_PMD_NR; i++) {\n\t\t\tif (atomic_inc_and_test(&page[i]._mapcount))\n\t\t\t\tnr++;\n\t\t}\n\t\tif (!atomic_inc_and_test(compound_mapcount_ptr(page)))\n\t\t\tgoto out;\n\t\tVM_BUG_ON_PAGE(!PageSwapBacked(page), page);\n\t\t__inc_node_page_state(page, NR_SHMEM_PMDMAPPED);\n\t} else {\n\t\tif (PageTransCompound(page) && page_mapping(page)) {\n\t\t\tVM_WARN_ON_ONCE(!PageLocked(page));\n\n\t\t\tSetPageDoubleMap(compound_head(page));\n\t\t\tif (PageMlocked(page))\n\t\t\t\tclear_page_mlock(compound_head(page));\n\t\t}\n\t\tif (!atomic_inc_and_test(&page->_mapcount))\n\t\t\tgoto out;\n\t}\n\t__mod_lruvec_page_state(page, NR_FILE_MAPPED, nr);\nout:\n\tunlock_page_memcg(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_add_file_rmap(struct page *page, bool compound)\n{\n\tint i, nr = 1;\n\n\tVM_BUG_ON_PAGE(compound && !PageTransHuge(page), page);\n\tlock_page_memcg(page);\n\tif (compound && PageTransHuge(page)) {\n\t\tfor (i = 0, nr = 0; i < HPAGE_PMD_NR; i++) {\n\t\t\tif (atomic_inc_and_test(&page[i]._mapcount))\n\t\t\t\tnr++;\n\t\t}\n\t\tif (!atomic_inc_and_test(compound_mapcount_ptr(page)))\n\t\t\tgoto out;\n\t\tVM_BUG_ON_PAGE(!PageSwapBacked(page), page);\n\t\t__inc_node_page_state(page, NR_SHMEM_PMDMAPPED);\n\t} else {\n\t\tif (PageTransCompound(page) && page_mapping(page)) {\n\t\t\tVM_WARN_ON_ONCE(!PageLocked(page));\n\n\t\t\tSetPageDoubleMap(compound_head(page));\n\t\t\tif (PageMlocked(page))\n\t\t\t\tclear_page_mlock(compound_head(page));\n\t\t}\n\t\tif (!atomic_inc_and_test(&page->_mapcount))\n\t\t\tgoto out;\n\t}\n\t__mod_lruvec_page_state(page, NR_FILE_MAPPED, nr);\nout:\n\tunlock_page_memcg(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_mm_counter",
          "args": [
            "vma->vm_mm",
            "mm_counter_file(page)",
            "HPAGE_PMD_NR"
          ],
          "line": 3141
        },
        "resolved": true,
        "details": {
          "function_name": "add_mm_counter_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "157-165",
          "snippet": "static void add_mm_counter_fast(struct mm_struct *mm, int member, int val)\n{\n\tstruct task_struct *task = current;\n\n\tif (likely(task->mm == mm))\n\t\ttask->rss_stat.count[member] += val;\n\telse\n\t\tadd_mm_counter(mm, member, val);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void add_mm_counter_fast(struct mm_struct *mm, int member, int val)\n{\n\tstruct task_struct *task = current;\n\n\tif (likely(task->mm == mm))\n\t\ttask->rss_stat.count[member] += val;\n\telse\n\t\tadd_mm_counter(mm, member, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_counter_file",
          "args": [
            "page"
          ],
          "line": 3141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "maybe_pmd_mkwrite",
          "args": [
            "pmd_mkdirty(entry)",
            "vma"
          ],
          "line": 3139
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_pmd_mkwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "477-482",
          "snippet": "pmd_t maybe_pmd_mkwrite(pmd_t pmd, struct vm_area_struct *vma)\n{\n\tif (likely(vma->vm_flags & VM_WRITE))\n\t\tpmd = pmd_mkwrite(pmd);\n\treturn pmd;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\npmd_t maybe_pmd_mkwrite(pmd_t pmd, struct vm_area_struct *vma)\n{\n\tif (likely(vma->vm_flags & VM_WRITE))\n\t\tpmd = pmd_mkwrite(pmd);\n\treturn pmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_mkdirty",
          "args": [
            "entry"
          ],
          "line": 3139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mk_huge_pmd",
          "args": [
            "page",
            "vma->vm_page_prot"
          ],
          "line": 3137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_icache_page",
          "args": [
            "vma",
            "page + i"
          ],
          "line": 3135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pmd_none(*vmf->pmd)"
          ],
          "line": 3131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "*vmf->pmd"
          ],
          "line": 3131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_lock",
          "args": [
            "vma->vm_mm",
            "vmf->pmd"
          ],
          "line": 3130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 3127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_alloc_one",
          "args": [
            "vma->vm_mm",
            "vmf->address"
          ],
          "line": 3124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_needs_pgtable_deposit",
          "args": [],
          "line": 3123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 3117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "transhuge_vma_suitable",
          "args": [
            "vma",
            "haddr"
          ],
          "line": 3113
        },
        "resolved": true,
        "details": {
          "function_name": "transhuge_vma_suitable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3080-3089",
          "snippet": "static inline bool transhuge_vma_suitable(struct vm_area_struct *vma,\n\t\tunsigned long haddr)\n{\n\tif (((vma->vm_start >> PAGE_SHIFT) & HPAGE_CACHE_INDEX_MASK) !=\n\t\t\t(vma->vm_pgoff & HPAGE_CACHE_INDEX_MASK))\n\t\treturn false;\n\tif (haddr < vma->vm_start || haddr + HPAGE_PMD_SIZE > vma->vm_end)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [
            "#define HPAGE_CACHE_INDEX_MASK (HPAGE_PMD_NR - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\n#define HPAGE_CACHE_INDEX_MASK (HPAGE_PMD_NR - 1)\n\nstatic inline bool transhuge_vma_suitable(struct vm_area_struct *vma,\n\t\tunsigned long haddr)\n{\n\tif (((vma->vm_start >> PAGE_SHIFT) & HPAGE_CACHE_INDEX_MASK) !=\n\t\t\t(vma->vm_pgoff & HPAGE_CACHE_INDEX_MASK))\n\t\treturn false;\n\tif (haddr < vma->vm_start || haddr + HPAGE_PMD_SIZE > vma->vm_end)\n\t\treturn false;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t do_set_pmd(struct vm_fault *vmf, struct page *page)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\tunsigned long haddr = vmf->address & HPAGE_PMD_MASK;\n\tpmd_t entry;\n\tint i;\n\tvm_fault_t ret;\n\n\tif (!transhuge_vma_suitable(vma, haddr))\n\t\treturn VM_FAULT_FALLBACK;\n\n\tret = VM_FAULT_FALLBACK;\n\tpage = compound_head(page);\n\n\t/*\n\t * Archs like ppc64 need additonal space to store information\n\t * related to pte entry. Use the preallocated table for that.\n\t */\n\tif (arch_needs_pgtable_deposit() && !vmf->prealloc_pte) {\n\t\tvmf->prealloc_pte = pte_alloc_one(vma->vm_mm, vmf->address);\n\t\tif (!vmf->prealloc_pte)\n\t\t\treturn VM_FAULT_OOM;\n\t\tsmp_wmb(); /* See comment in __pte_alloc() */\n\t}\n\n\tvmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);\n\tif (unlikely(!pmd_none(*vmf->pmd)))\n\t\tgoto out;\n\n\tfor (i = 0; i < HPAGE_PMD_NR; i++)\n\t\tflush_icache_page(vma, page + i);\n\n\tentry = mk_huge_pmd(page, vma->vm_page_prot);\n\tif (write)\n\t\tentry = maybe_pmd_mkwrite(pmd_mkdirty(entry), vma);\n\n\tadd_mm_counter(vma->vm_mm, mm_counter_file(page), HPAGE_PMD_NR);\n\tpage_add_file_rmap(page, true);\n\t/*\n\t * deposit and withdraw with pmd lock held\n\t */\n\tif (arch_needs_pgtable_deposit())\n\t\tdeposit_prealloc_pte(vmf);\n\n\tset_pmd_at(vma->vm_mm, haddr, vmf->pmd, entry);\n\n\tupdate_mmu_cache_pmd(vma, haddr, vmf->pmd);\n\n\t/* fault is handled */\n\tret = 0;\n\tcount_vm_event(THP_FILE_MAPPED);\nout:\n\tspin_unlock(vmf->ptl);\n\treturn ret;\n}"
  },
  {
    "function_name": "deposit_prealloc_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3091-3102",
    "snippet": "static void deposit_prealloc_pte(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\n\tpgtable_trans_huge_deposit(vma->vm_mm, vmf->pmd, vmf->prealloc_pte);\n\t/*\n\t * We are going to consume the prealloc table,\n\t * count that as nr_ptes.\n\t */\n\tmm_inc_nr_ptes(vma->vm_mm);\n\tvmf->prealloc_pte = NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mm_inc_nr_ptes",
          "args": [
            "vma->vm_mm"
          ],
          "line": 3100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgtable_trans_huge_deposit",
          "args": [
            "vma->vm_mm",
            "vmf->pmd",
            "vmf->prealloc_pte"
          ],
          "line": 3095
        },
        "resolved": true,
        "details": {
          "function_name": "pgtable_trans_huge_deposit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "152-163",
          "snippet": "void pgtable_trans_huge_deposit(struct mm_struct *mm, pmd_t *pmdp,\n\t\t\t\tpgtable_t pgtable)\n{\n\tassert_spin_locked(pmd_lockptr(mm, pmdp));\n\n\t/* FIFO */\n\tif (!pmd_huge_pte(mm, pmdp))\n\t\tINIT_LIST_HEAD(&pgtable->lru);\n\telse\n\t\tlist_add(&pgtable->lru, &pmd_huge_pte(mm, pmdp)->lru);\n\tpmd_huge_pte(mm, pmdp) = pgtable;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\nvoid pgtable_trans_huge_deposit(struct mm_struct *mm, pmd_t *pmdp,\n\t\t\t\tpgtable_t pgtable)\n{\n\tassert_spin_locked(pmd_lockptr(mm, pmdp));\n\n\t/* FIFO */\n\tif (!pmd_huge_pte(mm, pmdp))\n\t\tINIT_LIST_HEAD(&pgtable->lru);\n\telse\n\t\tlist_add(&pgtable->lru, &pmd_huge_pte(mm, pmdp)->lru);\n\tpmd_huge_pte(mm, pmdp) = pgtable;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void deposit_prealloc_pte(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\n\tpgtable_trans_huge_deposit(vma->vm_mm, vmf->pmd, vmf->prealloc_pte);\n\t/*\n\t * We are going to consume the prealloc table,\n\t * count that as nr_ptes.\n\t */\n\tmm_inc_nr_ptes(vma->vm_mm);\n\tvmf->prealloc_pte = NULL;\n}"
  },
  {
    "function_name": "transhuge_vma_suitable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3080-3089",
    "snippet": "static inline bool transhuge_vma_suitable(struct vm_area_struct *vma,\n\t\tunsigned long haddr)\n{\n\tif (((vma->vm_start >> PAGE_SHIFT) & HPAGE_CACHE_INDEX_MASK) !=\n\t\t\t(vma->vm_pgoff & HPAGE_CACHE_INDEX_MASK))\n\t\treturn false;\n\tif (haddr < vma->vm_start || haddr + HPAGE_PMD_SIZE > vma->vm_end)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [
      "#define HPAGE_CACHE_INDEX_MASK (HPAGE_PMD_NR - 1)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\n#define HPAGE_CACHE_INDEX_MASK (HPAGE_PMD_NR - 1)\n\nstatic inline bool transhuge_vma_suitable(struct vm_area_struct *vma,\n\t\tunsigned long haddr)\n{\n\tif (((vma->vm_start >> PAGE_SHIFT) & HPAGE_CACHE_INDEX_MASK) !=\n\t\t\t(vma->vm_pgoff & HPAGE_CACHE_INDEX_MASK))\n\t\treturn false;\n\tif (haddr < vma->vm_start || haddr + HPAGE_PMD_SIZE > vma->vm_end)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "pte_alloc_one_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3028-3075",
    "snippet": "static vm_fault_t pte_alloc_one_map(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\n\tif (!pmd_none(*vmf->pmd))\n\t\tgoto map_pte;\n\tif (vmf->prealloc_pte) {\n\t\tvmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);\n\t\tif (unlikely(!pmd_none(*vmf->pmd))) {\n\t\t\tspin_unlock(vmf->ptl);\n\t\t\tgoto map_pte;\n\t\t}\n\n\t\tmm_inc_nr_ptes(vma->vm_mm);\n\t\tpmd_populate(vma->vm_mm, vmf->pmd, vmf->prealloc_pte);\n\t\tspin_unlock(vmf->ptl);\n\t\tvmf->prealloc_pte = NULL;\n\t} else if (unlikely(pte_alloc(vma->vm_mm, vmf->pmd, vmf->address))) {\n\t\treturn VM_FAULT_OOM;\n\t}\nmap_pte:\n\t/*\n\t * If a huge pmd materialized under us just retry later.  Use\n\t * pmd_trans_unstable() via pmd_devmap_trans_unstable() instead of\n\t * pmd_trans_huge() to ensure the pmd didn't become pmd_trans_huge\n\t * under us and then back to pmd_none, as a result of MADV_DONTNEED\n\t * running immediately after a huge pmd fault in a different thread of\n\t * this mm, in turn leading to a misleading pmd_trans_huge() retval.\n\t * All we have to ensure is that it is a regular pmd that we can walk\n\t * with pte_offset_map() and we can do that through an atomic read in\n\t * C, which is what pmd_trans_unstable() provides.\n\t */\n\tif (pmd_devmap_trans_unstable(vmf->pmd))\n\t\treturn VM_FAULT_NOPAGE;\n\n\t/*\n\t * At this point we know that our vmf->pmd points to a page of ptes\n\t * and it cannot become pmd_none(), pmd_devmap() or pmd_trans_huge()\n\t * for the duration of the fault.  If a racing MADV_DONTNEED runs and\n\t * we zap the ptes pointed to by our vmf->pmd, the vmf->ptl will still\n\t * be valid and we will re-check to make sure the vmf->pte isn't\n\t * pte_none() under vmf->ptl protection when we return to\n\t * alloc_set_pte().\n\t */\n\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd, vmf->address,\n\t\t\t&vmf->ptl);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "vma->vm_mm",
            "vmf->pmd",
            "vmf->address",
            "&vmf->ptl"
          ],
          "line": 3072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_devmap_trans_unstable",
          "args": [
            "vmf->pmd"
          ],
          "line": 3060
        },
        "resolved": true,
        "details": {
          "function_name": "pmd_devmap_trans_unstable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3023-3026",
          "snippet": "static int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pte_alloc(vma->vm_mm, vmf->pmd, vmf->address)"
          ],
          "line": 3045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_alloc",
          "args": [
            "vma->vm_mm",
            "vmf->pmd",
            "vmf->address"
          ],
          "line": 3045
        },
        "resolved": true,
        "details": {
          "function_name": "__pte_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "403-435",
          "snippet": "int __pte_alloc(struct mm_struct *mm, pmd_t *pmd, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpgtable_t new = pte_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Ensure all pte setup (eg. pte page lock and page clearing) are\n\t * visible before the pte is made visible to other CPUs by being\n\t * put into page tables.\n\t *\n\t * The other side of the story is the pointer chasing in the page\n\t * table walking code (when walking the page table without locking;\n\t * ie. most of the time). Fortunately, these data accesses consist\n\t * of a chain of data-dependent loads, meaning most CPUs (alpha\n\t * being the notable exception) will already guarantee loads are\n\t * seen in-order. See the alpha page table accessors for the\n\t * smp_read_barrier_depends() barriers in page table walking code.\n\t */\n\tsmp_wmb(); /* Could be smp_wmb__xxx(before|after)_spin_lock */\n\n\tptl = pmd_lock(mm, pmd);\n\tif (likely(pmd_none(*pmd))) {\t/* Has another populated it ? */\n\t\tmm_inc_nr_ptes(mm);\n\t\tpmd_populate(mm, pmd, new);\n\t\tnew = NULL;\n\t}\n\tspin_unlock(ptl);\n\tif (new)\n\t\tpte_free(mm, new);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pte_alloc(struct mm_struct *mm, pmd_t *pmd, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpgtable_t new = pte_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Ensure all pte setup (eg. pte page lock and page clearing) are\n\t * visible before the pte is made visible to other CPUs by being\n\t * put into page tables.\n\t *\n\t * The other side of the story is the pointer chasing in the page\n\t * table walking code (when walking the page table without locking;\n\t * ie. most of the time). Fortunately, these data accesses consist\n\t * of a chain of data-dependent loads, meaning most CPUs (alpha\n\t * being the notable exception) will already guarantee loads are\n\t * seen in-order. See the alpha page table accessors for the\n\t * smp_read_barrier_depends() barriers in page table walking code.\n\t */\n\tsmp_wmb(); /* Could be smp_wmb__xxx(before|after)_spin_lock */\n\n\tptl = pmd_lock(mm, pmd);\n\tif (likely(pmd_none(*pmd))) {\t/* Has another populated it ? */\n\t\tmm_inc_nr_ptes(mm);\n\t\tpmd_populate(mm, pmd, new);\n\t\tnew = NULL;\n\t}\n\tspin_unlock(ptl);\n\tif (new)\n\t\tpte_free(mm, new);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "vmf->ptl"
          ],
          "line": 3043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_populate",
          "args": [
            "vma->vm_mm",
            "vmf->pmd",
            "vmf->prealloc_pte"
          ],
          "line": 3042
        },
        "resolved": true,
        "details": {
          "function_name": "zero_pmd_populate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan_init.c",
          "lines": "105-135",
          "snippet": "static int __ref zero_pmd_populate(pud_t *pud, unsigned long addr,\n\t\t\t\tunsigned long end)\n{\n\tpmd_t *pmd = pmd_offset(pud, addr);\n\tunsigned long next;\n\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\n\t\tif (IS_ALIGNED(addr, PMD_SIZE) && end - addr >= PMD_SIZE) {\n\t\t\tpmd_populate_kernel(&init_mm, pmd, lm_alias(kasan_zero_pte));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pmd_none(*pmd)) {\n\t\t\tpte_t *p;\n\n\t\t\tif (slab_is_available())\n\t\t\t\tp = pte_alloc_one_kernel(&init_mm, addr);\n\t\t\telse\n\t\t\t\tp = early_alloc(PAGE_SIZE, NUMA_NO_NODE);\n\t\t\tif (!p)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tpmd_populate_kernel(&init_mm, pmd, p);\n\t\t}\n\t\tzero_pte_populate(pmd, addr, next);\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kasan.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/page.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/memblock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pte_t kasan_zero_pte[PTRS_PER_PTE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kasan.h\"\n#include <asm/pgalloc.h>\n#include <asm/page.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/memblock.h>\n\npte_t kasan_zero_pte[PTRS_PER_PTE];\n\nstatic int __ref zero_pmd_populate(pud_t *pud, unsigned long addr,\n\t\t\t\tunsigned long end)\n{\n\tpmd_t *pmd = pmd_offset(pud, addr);\n\tunsigned long next;\n\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\n\t\tif (IS_ALIGNED(addr, PMD_SIZE) && end - addr >= PMD_SIZE) {\n\t\t\tpmd_populate_kernel(&init_mm, pmd, lm_alias(kasan_zero_pte));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pmd_none(*pmd)) {\n\t\t\tpte_t *p;\n\n\t\t\tif (slab_is_available())\n\t\t\t\tp = pte_alloc_one_kernel(&init_mm, addr);\n\t\t\telse\n\t\t\t\tp = early_alloc(PAGE_SIZE, NUMA_NO_NODE);\n\t\t\tif (!p)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tpmd_populate_kernel(&init_mm, pmd, p);\n\t\t}\n\t\tzero_pte_populate(pmd, addr, next);\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_inc_nr_ptes",
          "args": [
            "vma->vm_mm"
          ],
          "line": 3041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "vmf->ptl"
          ],
          "line": 3037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pmd_none(*vmf->pmd)"
          ],
          "line": 3036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "*vmf->pmd"
          ],
          "line": 3036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_lock",
          "args": [
            "vma->vm_mm",
            "vmf->pmd"
          ],
          "line": 3035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "*vmf->pmd"
          ],
          "line": 3032
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t pte_alloc_one_map(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\n\tif (!pmd_none(*vmf->pmd))\n\t\tgoto map_pte;\n\tif (vmf->prealloc_pte) {\n\t\tvmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);\n\t\tif (unlikely(!pmd_none(*vmf->pmd))) {\n\t\t\tspin_unlock(vmf->ptl);\n\t\t\tgoto map_pte;\n\t\t}\n\n\t\tmm_inc_nr_ptes(vma->vm_mm);\n\t\tpmd_populate(vma->vm_mm, vmf->pmd, vmf->prealloc_pte);\n\t\tspin_unlock(vmf->ptl);\n\t\tvmf->prealloc_pte = NULL;\n\t} else if (unlikely(pte_alloc(vma->vm_mm, vmf->pmd, vmf->address))) {\n\t\treturn VM_FAULT_OOM;\n\t}\nmap_pte:\n\t/*\n\t * If a huge pmd materialized under us just retry later.  Use\n\t * pmd_trans_unstable() via pmd_devmap_trans_unstable() instead of\n\t * pmd_trans_huge() to ensure the pmd didn't become pmd_trans_huge\n\t * under us and then back to pmd_none, as a result of MADV_DONTNEED\n\t * running immediately after a huge pmd fault in a different thread of\n\t * this mm, in turn leading to a misleading pmd_trans_huge() retval.\n\t * All we have to ensure is that it is a regular pmd that we can walk\n\t * with pte_offset_map() and we can do that through an atomic read in\n\t * C, which is what pmd_trans_unstable() provides.\n\t */\n\tif (pmd_devmap_trans_unstable(vmf->pmd))\n\t\treturn VM_FAULT_NOPAGE;\n\n\t/*\n\t * At this point we know that our vmf->pmd points to a page of ptes\n\t * and it cannot become pmd_none(), pmd_devmap() or pmd_trans_huge()\n\t * for the duration of the fault.  If a racing MADV_DONTNEED runs and\n\t * we zap the ptes pointed to by our vmf->pmd, the vmf->ptl will still\n\t * be valid and we will re-check to make sure the vmf->pte isn't\n\t * pte_none() under vmf->ptl protection when we return to\n\t * alloc_set_pte().\n\t */\n\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd, vmf->address,\n\t\t\t&vmf->ptl);\n\treturn 0;\n}"
  },
  {
    "function_name": "pmd_devmap_trans_unstable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "3023-3026",
    "snippet": "static int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pmd_trans_unstable",
          "args": [
            "pmd"
          ],
          "line": 3025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_devmap",
          "args": [
            "*pmd"
          ],
          "line": 3025
        },
        "resolved": true,
        "details": {
          "function_name": "pmd_devmap_trans_unstable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3023-3026",
          "snippet": "static int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}"
  },
  {
    "function_name": "__do_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "2991-3015",
    "snippet": "static vm_fault_t __do_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tvm_fault_t ret;\n\n\tret = vma->vm_ops->fault(vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY |\n\t\t\t    VM_FAULT_DONE_COW)))\n\t\treturn ret;\n\n\tif (unlikely(PageHWPoison(vmf->page))) {\n\t\tif (ret & VM_FAULT_LOCKED)\n\t\t\tunlock_page(vmf->page);\n\t\tput_page(vmf->page);\n\t\tvmf->page = NULL;\n\t\treturn VM_FAULT_HWPOISON;\n\t}\n\n\tif (unlikely(!(ret & VM_FAULT_LOCKED)))\n\t\tlock_page(vmf->page);\n\telse\n\t\tVM_BUG_ON_PAGE(!PageLocked(vmf->page), vmf->page);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(vmf->page)",
            "vmf->page"
          ],
          "line": 3012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "vmf->page"
          ],
          "line": 3012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "vmf->page"
          ],
          "line": 3010
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(ret & VM_FAULT_LOCKED)"
          ],
          "line": 3009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "vmf->page"
          ],
          "line": 3004
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageHWPoison(vmf->page)"
          ],
          "line": 3001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHWPoison",
          "args": [
            "vmf->page"
          ],
          "line": 3001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY |\n\t\t\t    VM_FAULT_DONE_COW)"
          ],
          "line": 2997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma->vm_ops->fault",
          "args": [
            "vmf"
          ],
          "line": 2996
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t __do_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tvm_fault_t ret;\n\n\tret = vma->vm_ops->fault(vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY |\n\t\t\t    VM_FAULT_DONE_COW)))\n\t\treturn ret;\n\n\tif (unlikely(PageHWPoison(vmf->page))) {\n\t\tif (ret & VM_FAULT_LOCKED)\n\t\t\tunlock_page(vmf->page);\n\t\tput_page(vmf->page);\n\t\tvmf->page = NULL;\n\t\treturn VM_FAULT_HWPOISON;\n\t}\n\n\tif (unlikely(!(ret & VM_FAULT_LOCKED)))\n\t\tlock_page(vmf->page);\n\telse\n\t\tVM_BUG_ON_PAGE(!PageLocked(vmf->page), vmf->page);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "do_anonymous_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "2876-2984",
    "snippet": "static vm_fault_t do_anonymous_page(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct mem_cgroup *memcg;\n\tstruct page *page;\n\tvm_fault_t ret = 0;\n\tpte_t entry;\n\n\t/* File mapping without ->vm_ops ? */\n\tif (vma->vm_flags & VM_SHARED)\n\t\treturn VM_FAULT_SIGBUS;\n\n\t/*\n\t * Use pte_alloc() instead of pte_alloc_map().  We can't run\n\t * pte_offset_map() on pmds where a huge pmd might be created\n\t * from a different thread.\n\t *\n\t * pte_alloc_map() is safe to use under down_write(mmap_sem) or when\n\t * parallel threads are excluded by other means.\n\t *\n\t * Here we only have down_read(mmap_sem).\n\t */\n\tif (pte_alloc(vma->vm_mm, vmf->pmd, vmf->address))\n\t\treturn VM_FAULT_OOM;\n\n\t/* See the comment in pte_alloc_one_map() */\n\tif (unlikely(pmd_trans_unstable(vmf->pmd)))\n\t\treturn 0;\n\n\t/* Use the zero-page for reads */\n\tif (!(vmf->flags & FAULT_FLAG_WRITE) &&\n\t\t\t!mm_forbids_zeropage(vma->vm_mm)) {\n\t\tentry = pte_mkspecial(pfn_pte(my_zero_pfn(vmf->address),\n\t\t\t\t\t\tvma->vm_page_prot));\n\t\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd,\n\t\t\t\tvmf->address, &vmf->ptl);\n\t\tif (!pte_none(*vmf->pte))\n\t\t\tgoto unlock;\n\t\tret = check_stable_address_space(vma->vm_mm);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t\t/* Deliver the page fault to userland, check inside PT lock */\n\t\tif (userfaultfd_missing(vma)) {\n\t\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\t\treturn handle_userfault(vmf, VM_UFFD_MISSING);\n\t\t}\n\t\tgoto setpte;\n\t}\n\n\t/* Allocate our own private page. */\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto oom;\n\tpage = alloc_zeroed_user_highpage_movable(vma, vmf->address);\n\tif (!page)\n\t\tgoto oom;\n\n\tif (mem_cgroup_try_charge_delay(page, vma->vm_mm, GFP_KERNEL, &memcg,\n\t\t\t\t\tfalse))\n\t\tgoto oom_free_page;\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceeding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\n\tentry = mk_pte(page, vma->vm_page_prot);\n\tif (vma->vm_flags & VM_WRITE)\n\t\tentry = pte_mkwrite(pte_mkdirty(entry));\n\n\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd, vmf->address,\n\t\t\t&vmf->ptl);\n\tif (!pte_none(*vmf->pte))\n\t\tgoto release;\n\n\tret = check_stable_address_space(vma->vm_mm);\n\tif (ret)\n\t\tgoto release;\n\n\t/* Deliver the page fault to userland, check inside PT lock */\n\tif (userfaultfd_missing(vma)) {\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\tmem_cgroup_cancel_charge(page, memcg, false);\n\t\tput_page(page);\n\t\treturn handle_userfault(vmf, VM_UFFD_MISSING);\n\t}\n\n\tinc_mm_counter_fast(vma->vm_mm, MM_ANONPAGES);\n\tpage_add_new_anon_rmap(page, vma, vmf->address, false);\n\tmem_cgroup_commit_charge(page, memcg, false, false);\n\tlru_cache_add_active_or_unevictable(page, vma);\nsetpte:\n\tset_pte_at(vma->vm_mm, vmf->address, vmf->pte, entry);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\nunlock:\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\treturn ret;\nrelease:\n\tmem_cgroup_cancel_charge(page, memcg, false);\n\tput_page(page);\n\tgoto unlock;\noom_free_page:\n\tput_page(page);\noom:\n\treturn VM_FAULT_OOM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 2981
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_cancel_charge",
          "args": [
            "page",
            "memcg",
            "false"
          ],
          "line": 2977
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_cancel_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5972-5988",
          "snippet": "void mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,\n\t\tbool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcancel_charge(memcg, nr_pages);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,\n\t\tbool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcancel_charge(memcg, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "vmf->pte",
            "vmf->ptl"
          ],
          "line": 2974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_mmu_cache",
          "args": [
            "vma",
            "vmf->address",
            "vmf->pte"
          ],
          "line": 2972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "vma->vm_mm",
            "vmf->address",
            "vmf->pte",
            "entry"
          ],
          "line": 2969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_cache_add_active_or_unevictable",
          "args": [
            "page",
            "vma"
          ],
          "line": 2967
        },
        "resolved": true,
        "details": {
          "function_name": "lru_cache_add_active_or_unevictable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "458-476",
          "snippet": "void lru_cache_add_active_or_unevictable(struct page *page,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\tif (likely((vma->vm_flags & (VM_LOCKED | VM_SPECIAL)) != VM_LOCKED))\n\t\tSetPageActive(page);\n\telse if (!TestSetPageMlocked(page)) {\n\t\t/*\n\t\t * We use the irq-unsafe __mod_zone_page_stat because this\n\t\t * counter is not modified from interrupt context, and the pte\n\t\t * lock is held(spinlock), which implies preemption disabled.\n\t\t */\n\t\t__mod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t}\n\tlru_cache_add(page);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid lru_cache_add_active_or_unevictable(struct page *page,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\tif (likely((vma->vm_flags & (VM_LOCKED | VM_SPECIAL)) != VM_LOCKED))\n\t\tSetPageActive(page);\n\telse if (!TestSetPageMlocked(page)) {\n\t\t/*\n\t\t * We use the irq-unsafe __mod_zone_page_stat because this\n\t\t * counter is not modified from interrupt context, and the pte\n\t\t * lock is held(spinlock), which implies preemption disabled.\n\t\t */\n\t\t__mod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t}\n\tlru_cache_add(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_commit_charge",
          "args": [
            "page",
            "memcg",
            "false",
            "false"
          ],
          "line": 2966
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_commit_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5928-5962",
          "snippet": "void mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t      bool lrucare, bool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_PAGE(!page->mapping, page);\n\tVM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcommit_charge(page, memcg, lrucare);\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(memcg, page, compound, nr_pages);\n\tmemcg_check_events(memcg, page);\n\tlocal_irq_enable();\n\n\tif (do_memsw_account() && PageSwapCache(page)) {\n\t\tswp_entry_t entry = { .val = page_private(page) };\n\t\t/*\n\t\t * The swap entry might not get freed for a long time,\n\t\t * let's not wait for it.  The page already received a\n\t\t * memory+swap charge, drop the swap entry duplicate.\n\t\t */\n\t\tmem_cgroup_uncharge_swap(entry, nr_pages);\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t      bool lrucare, bool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_PAGE(!page->mapping, page);\n\tVM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcommit_charge(page, memcg, lrucare);\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(memcg, page, compound, nr_pages);\n\tmemcg_check_events(memcg, page);\n\tlocal_irq_enable();\n\n\tif (do_memsw_account() && PageSwapCache(page)) {\n\t\tswp_entry_t entry = { .val = page_private(page) };\n\t\t/*\n\t\t * The swap entry might not get freed for a long time,\n\t\t * let's not wait for it.  The page already received a\n\t\t * memory+swap charge, drop the swap entry duplicate.\n\t\t */\n\t\tmem_cgroup_uncharge_swap(entry, nr_pages);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_add_new_anon_rmap",
          "args": [
            "page",
            "vma",
            "vmf->address",
            "false"
          ],
          "line": 2965
        },
        "resolved": true,
        "details": {
          "function_name": "page_add_new_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1150-1170",
          "snippet": "void page_add_new_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, bool compound)\n{\n\tint nr = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\t__SetPageSwapBacked(page);\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(compound_mapcount_ptr(page), 0);\n\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t} else {\n\t\t/* Anon THP always mapped first with PMD */\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(&page->_mapcount, 0);\n\t}\n\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t__page_set_anon_rmap(page, vma, address, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_add_new_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, bool compound)\n{\n\tint nr = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\t__SetPageSwapBacked(page);\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(compound_mapcount_ptr(page), 0);\n\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t} else {\n\t\t/* Anon THP always mapped first with PMD */\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(&page->_mapcount, 0);\n\t}\n\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t__page_set_anon_rmap(page, vma, address, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_mm_counter_fast",
          "args": [
            "vma->vm_mm",
            "MM_ANONPAGES"
          ],
          "line": 2964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_userfault",
          "args": [
            "vmf",
            "VM_UFFD_MISSING"
          ],
          "line": 2961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "vmf->pte",
            "vmf->ptl"
          ],
          "line": 2958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userfaultfd_missing",
          "args": [
            "vma"
          ],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stable_address_space",
          "args": [
            "vma->vm_mm"
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "*vmf->pte"
          ],
          "line": 2949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "vma->vm_mm",
            "vmf->pmd",
            "vmf->address",
            "&vmf->ptl"
          ],
          "line": 2947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkwrite",
          "args": [
            "pte_mkdirty(entry)"
          ],
          "line": 2945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkdirty",
          "args": [
            "entry"
          ],
          "line": 2945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mk_pte",
          "args": [
            "page",
            "vma->vm_page_prot"
          ],
          "line": 2943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 2941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_try_charge_delay",
          "args": [
            "page",
            "vma->vm_mm",
            "GFP_KERNEL",
            "&memcg",
            "false"
          ],
          "line": 2932
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_try_charge_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5898-5909",
          "snippet": "int mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\tret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);\n\tmemcg = *memcgp;\n\tmem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nint mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\tret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);\n\tmemcg = *memcgp;\n\tmem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_zeroed_user_highpage_movable",
          "args": [
            "vma",
            "vmf->address"
          ],
          "line": 2928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "anon_vma_prepare(vma)"
          ],
          "line": 2926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_prepare",
          "args": [
            "vma"
          ],
          "line": 2926
        },
        "resolved": true,
        "details": {
          "function_name": "__anon_vma_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "175-221",
          "snippet": "int __anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct anon_vma *anon_vma, *allocated;\n\tstruct anon_vma_chain *avc;\n\n\tmight_sleep();\n\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_enomem;\n\n\tanon_vma = find_mergeable_anon_vma(vma);\n\tallocated = NULL;\n\tif (!anon_vma) {\n\t\tanon_vma = anon_vma_alloc();\n\t\tif (unlikely(!anon_vma))\n\t\t\tgoto out_enomem_free_avc;\n\t\tallocated = anon_vma;\n\t}\n\n\tanon_vma_lock_write(anon_vma);\n\t/* page_table_lock to protect against threads */\n\tspin_lock(&mm->page_table_lock);\n\tif (likely(!vma->anon_vma)) {\n\t\tvma->anon_vma = anon_vma;\n\t\tanon_vma_chain_link(vma, avc, anon_vma);\n\t\t/* vma reference or self-parent link for new root */\n\t\tanon_vma->degree++;\n\t\tallocated = NULL;\n\t\tavc = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tanon_vma_unlock_write(anon_vma);\n\n\tif (unlikely(allocated))\n\t\tput_anon_vma(allocated);\n\tif (unlikely(avc))\n\t\tanon_vma_chain_free(avc);\n\n\treturn 0;\n\n out_enomem_free_avc:\n\tanon_vma_chain_free(avc);\n out_enomem:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint __anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct anon_vma *anon_vma, *allocated;\n\tstruct anon_vma_chain *avc;\n\n\tmight_sleep();\n\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_enomem;\n\n\tanon_vma = find_mergeable_anon_vma(vma);\n\tallocated = NULL;\n\tif (!anon_vma) {\n\t\tanon_vma = anon_vma_alloc();\n\t\tif (unlikely(!anon_vma))\n\t\t\tgoto out_enomem_free_avc;\n\t\tallocated = anon_vma;\n\t}\n\n\tanon_vma_lock_write(anon_vma);\n\t/* page_table_lock to protect against threads */\n\tspin_lock(&mm->page_table_lock);\n\tif (likely(!vma->anon_vma)) {\n\t\tvma->anon_vma = anon_vma;\n\t\tanon_vma_chain_link(vma, avc, anon_vma);\n\t\t/* vma reference or self-parent link for new root */\n\t\tanon_vma->degree++;\n\t\tallocated = NULL;\n\t\tavc = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tanon_vma_unlock_write(anon_vma);\n\n\tif (unlikely(allocated))\n\t\tput_anon_vma(allocated);\n\tif (unlikely(avc))\n\t\tanon_vma_chain_free(avc);\n\n\treturn 0;\n\n out_enomem_free_avc:\n\tanon_vma_chain_free(avc);\n out_enomem:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_userfault",
          "args": [
            "vmf",
            "VM_UFFD_MISSING"
          ],
          "line": 2920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "vmf->pte",
            "vmf->ptl"
          ],
          "line": 2919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userfaultfd_missing",
          "args": [
            "vma"
          ],
          "line": 2918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stable_address_space",
          "args": [
            "vma->vm_mm"
          ],
          "line": 2914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "*vmf->pte"
          ],
          "line": 2912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "vma->vm_mm",
            "vmf->pmd",
            "vmf->address",
            "&vmf->ptl"
          ],
          "line": 2910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkspecial",
          "args": [
            "pfn_pte(my_zero_pfn(vmf->address),\n\t\t\t\t\t\tvma->vm_page_prot)"
          ],
          "line": 2908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_pte",
          "args": [
            "my_zero_pfn(vmf->address)",
            "vma->vm_page_prot"
          ],
          "line": 2908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "my_zero_pfn",
          "args": [
            "vmf->address"
          ],
          "line": 2908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_forbids_zeropage",
          "args": [
            "vma->vm_mm"
          ],
          "line": 2907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pmd_trans_unstable(vmf->pmd)"
          ],
          "line": 2902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_unstable",
          "args": [
            "vmf->pmd"
          ],
          "line": 2902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_alloc",
          "args": [
            "vma->vm_mm",
            "vmf->pmd",
            "vmf->address"
          ],
          "line": 2898
        },
        "resolved": true,
        "details": {
          "function_name": "__pte_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "403-435",
          "snippet": "int __pte_alloc(struct mm_struct *mm, pmd_t *pmd, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpgtable_t new = pte_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Ensure all pte setup (eg. pte page lock and page clearing) are\n\t * visible before the pte is made visible to other CPUs by being\n\t * put into page tables.\n\t *\n\t * The other side of the story is the pointer chasing in the page\n\t * table walking code (when walking the page table without locking;\n\t * ie. most of the time). Fortunately, these data accesses consist\n\t * of a chain of data-dependent loads, meaning most CPUs (alpha\n\t * being the notable exception) will already guarantee loads are\n\t * seen in-order. See the alpha page table accessors for the\n\t * smp_read_barrier_depends() barriers in page table walking code.\n\t */\n\tsmp_wmb(); /* Could be smp_wmb__xxx(before|after)_spin_lock */\n\n\tptl = pmd_lock(mm, pmd);\n\tif (likely(pmd_none(*pmd))) {\t/* Has another populated it ? */\n\t\tmm_inc_nr_ptes(mm);\n\t\tpmd_populate(mm, pmd, new);\n\t\tnew = NULL;\n\t}\n\tspin_unlock(ptl);\n\tif (new)\n\t\tpte_free(mm, new);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pte_alloc(struct mm_struct *mm, pmd_t *pmd, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpgtable_t new = pte_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Ensure all pte setup (eg. pte page lock and page clearing) are\n\t * visible before the pte is made visible to other CPUs by being\n\t * put into page tables.\n\t *\n\t * The other side of the story is the pointer chasing in the page\n\t * table walking code (when walking the page table without locking;\n\t * ie. most of the time). Fortunately, these data accesses consist\n\t * of a chain of data-dependent loads, meaning most CPUs (alpha\n\t * being the notable exception) will already guarantee loads are\n\t * seen in-order. See the alpha page table accessors for the\n\t * smp_read_barrier_depends() barriers in page table walking code.\n\t */\n\tsmp_wmb(); /* Could be smp_wmb__xxx(before|after)_spin_lock */\n\n\tptl = pmd_lock(mm, pmd);\n\tif (likely(pmd_none(*pmd))) {\t/* Has another populated it ? */\n\t\tmm_inc_nr_ptes(mm);\n\t\tpmd_populate(mm, pmd, new);\n\t\tnew = NULL;\n\t}\n\tspin_unlock(ptl);\n\tif (new)\n\t\tpte_free(mm, new);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t do_anonymous_page(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct mem_cgroup *memcg;\n\tstruct page *page;\n\tvm_fault_t ret = 0;\n\tpte_t entry;\n\n\t/* File mapping without ->vm_ops ? */\n\tif (vma->vm_flags & VM_SHARED)\n\t\treturn VM_FAULT_SIGBUS;\n\n\t/*\n\t * Use pte_alloc() instead of pte_alloc_map().  We can't run\n\t * pte_offset_map() on pmds where a huge pmd might be created\n\t * from a different thread.\n\t *\n\t * pte_alloc_map() is safe to use under down_write(mmap_sem) or when\n\t * parallel threads are excluded by other means.\n\t *\n\t * Here we only have down_read(mmap_sem).\n\t */\n\tif (pte_alloc(vma->vm_mm, vmf->pmd, vmf->address))\n\t\treturn VM_FAULT_OOM;\n\n\t/* See the comment in pte_alloc_one_map() */\n\tif (unlikely(pmd_trans_unstable(vmf->pmd)))\n\t\treturn 0;\n\n\t/* Use the zero-page for reads */\n\tif (!(vmf->flags & FAULT_FLAG_WRITE) &&\n\t\t\t!mm_forbids_zeropage(vma->vm_mm)) {\n\t\tentry = pte_mkspecial(pfn_pte(my_zero_pfn(vmf->address),\n\t\t\t\t\t\tvma->vm_page_prot));\n\t\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd,\n\t\t\t\tvmf->address, &vmf->ptl);\n\t\tif (!pte_none(*vmf->pte))\n\t\t\tgoto unlock;\n\t\tret = check_stable_address_space(vma->vm_mm);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t\t/* Deliver the page fault to userland, check inside PT lock */\n\t\tif (userfaultfd_missing(vma)) {\n\t\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\t\treturn handle_userfault(vmf, VM_UFFD_MISSING);\n\t\t}\n\t\tgoto setpte;\n\t}\n\n\t/* Allocate our own private page. */\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto oom;\n\tpage = alloc_zeroed_user_highpage_movable(vma, vmf->address);\n\tif (!page)\n\t\tgoto oom;\n\n\tif (mem_cgroup_try_charge_delay(page, vma->vm_mm, GFP_KERNEL, &memcg,\n\t\t\t\t\tfalse))\n\t\tgoto oom_free_page;\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceeding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\n\tentry = mk_pte(page, vma->vm_page_prot);\n\tif (vma->vm_flags & VM_WRITE)\n\t\tentry = pte_mkwrite(pte_mkdirty(entry));\n\n\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd, vmf->address,\n\t\t\t&vmf->ptl);\n\tif (!pte_none(*vmf->pte))\n\t\tgoto release;\n\n\tret = check_stable_address_space(vma->vm_mm);\n\tif (ret)\n\t\tgoto release;\n\n\t/* Deliver the page fault to userland, check inside PT lock */\n\tif (userfaultfd_missing(vma)) {\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\tmem_cgroup_cancel_charge(page, memcg, false);\n\t\tput_page(page);\n\t\treturn handle_userfault(vmf, VM_UFFD_MISSING);\n\t}\n\n\tinc_mm_counter_fast(vma->vm_mm, MM_ANONPAGES);\n\tpage_add_new_anon_rmap(page, vma, vmf->address, false);\n\tmem_cgroup_commit_charge(page, memcg, false, false);\n\tlru_cache_add_active_or_unevictable(page, vma);\nsetpte:\n\tset_pte_at(vma->vm_mm, vmf->address, vmf->pte, entry);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\nunlock:\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\treturn ret;\nrelease:\n\tmem_cgroup_cancel_charge(page, memcg, false);\n\tput_page(page);\n\tgoto unlock;\noom_free_page:\n\tput_page(page);\noom:\n\treturn VM_FAULT_OOM;\n}"
  },
  {
    "function_name": "do_swap_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "2656-2869",
    "snippet": "vm_fault_t do_swap_page(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page = NULL, *swapcache;\n\tstruct mem_cgroup *memcg;\n\tswp_entry_t entry;\n\tpte_t pte;\n\tint locked;\n\tint exclusive = 0;\n\tvm_fault_t ret = 0;\n\n\tif (!pte_unmap_same(vma->vm_mm, vmf->pmd, vmf->pte, vmf->orig_pte))\n\t\tgoto out;\n\n\tentry = pte_to_swp_entry(vmf->orig_pte);\n\tif (unlikely(non_swap_entry(entry))) {\n\t\tif (is_migration_entry(entry)) {\n\t\t\tmigration_entry_wait(vma->vm_mm, vmf->pmd,\n\t\t\t\t\t     vmf->address);\n\t\t} else if (is_device_private_entry(entry)) {\n\t\t\t/*\n\t\t\t * For un-addressable device memory we call the pgmap\n\t\t\t * fault handler callback. The callback must migrate\n\t\t\t * the page back to some CPU accessible page.\n\t\t\t */\n\t\t\tret = device_private_entry_fault(vma, vmf->address, entry,\n\t\t\t\t\t\t vmf->flags, vmf->pmd);\n\t\t} else if (is_hwpoison_entry(entry)) {\n\t\t\tret = VM_FAULT_HWPOISON;\n\t\t} else {\n\t\t\tprint_bad_pte(vma, vmf->address, vmf->orig_pte, NULL);\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\t}\n\t\tgoto out;\n\t}\n\n\n\tdelayacct_set_flag(DELAYACCT_PF_SWAPIN);\n\tpage = lookup_swap_cache(entry, vma, vmf->address);\n\tswapcache = page;\n\n\tif (!page) {\n\t\tstruct swap_info_struct *si = swp_swap_info(entry);\n\n\t\tif (si->flags & SWP_SYNCHRONOUS_IO &&\n\t\t\t\t__swap_count(si, entry) == 1) {\n\t\t\t/* skip swapcache */\n\t\t\tpage = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma,\n\t\t\t\t\t\t\tvmf->address);\n\t\t\tif (page) {\n\t\t\t\t__SetPageLocked(page);\n\t\t\t\t__SetPageSwapBacked(page);\n\t\t\t\tset_page_private(page, entry.val);\n\t\t\t\tlru_cache_add_anon(page);\n\t\t\t\tswap_readpage(page, true);\n\t\t\t}\n\t\t} else {\n\t\t\tpage = swapin_readahead(entry, GFP_HIGHUSER_MOVABLE,\n\t\t\t\t\t\tvmf);\n\t\t\tswapcache = page;\n\t\t}\n\n\t\tif (!page) {\n\t\t\t/*\n\t\t\t * Back out if somebody else faulted in this pte\n\t\t\t * while we released the pte lock.\n\t\t\t */\n\t\t\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd,\n\t\t\t\t\tvmf->address, &vmf->ptl);\n\t\t\tif (likely(pte_same(*vmf->pte, vmf->orig_pte)))\n\t\t\t\tret = VM_FAULT_OOM;\n\t\t\tdelayacct_clear_flag(DELAYACCT_PF_SWAPIN);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\t/* Had to read the page from swap area: Major fault */\n\t\tret = VM_FAULT_MAJOR;\n\t\tcount_vm_event(PGMAJFAULT);\n\t\tcount_memcg_event_mm(vma->vm_mm, PGMAJFAULT);\n\t} else if (PageHWPoison(page)) {\n\t\t/*\n\t\t * hwpoisoned dirty swapcache pages are kept for killing\n\t\t * owner processes (which may be unknown at hwpoison time)\n\t\t */\n\t\tret = VM_FAULT_HWPOISON;\n\t\tdelayacct_clear_flag(DELAYACCT_PF_SWAPIN);\n\t\tgoto out_release;\n\t}\n\n\tlocked = lock_page_or_retry(page, vma->vm_mm, vmf->flags);\n\n\tdelayacct_clear_flag(DELAYACCT_PF_SWAPIN);\n\tif (!locked) {\n\t\tret |= VM_FAULT_RETRY;\n\t\tgoto out_release;\n\t}\n\n\t/*\n\t * Make sure try_to_free_swap or reuse_swap_page or swapoff did not\n\t * release the swapcache from under us.  The page pin, and pte_same\n\t * test below, are not enough to exclude that.  Even if it is still\n\t * swapcache, we need to check that the page's swap has not changed.\n\t */\n\tif (unlikely((!PageSwapCache(page) ||\n\t\t\tpage_private(page) != entry.val)) && swapcache)\n\t\tgoto out_page;\n\n\tpage = ksm_might_need_to_copy(page, vma, vmf->address);\n\tif (unlikely(!page)) {\n\t\tret = VM_FAULT_OOM;\n\t\tpage = swapcache;\n\t\tgoto out_page;\n\t}\n\n\tif (mem_cgroup_try_charge_delay(page, vma->vm_mm, GFP_KERNEL,\n\t\t\t\t\t&memcg, false)) {\n\t\tret = VM_FAULT_OOM;\n\t\tgoto out_page;\n\t}\n\n\t/*\n\t * Back out if somebody else already faulted in this pte.\n\t */\n\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd, vmf->address,\n\t\t\t&vmf->ptl);\n\tif (unlikely(!pte_same(*vmf->pte, vmf->orig_pte)))\n\t\tgoto out_nomap;\n\n\tif (unlikely(!PageUptodate(page))) {\n\t\tret = VM_FAULT_SIGBUS;\n\t\tgoto out_nomap;\n\t}\n\n\t/*\n\t * The page isn't present yet, go ahead with the fault.\n\t *\n\t * Be careful about the sequence of operations here.\n\t * To get its accounting right, reuse_swap_page() must be called\n\t * while the page is counted on swap but not yet in mapcount i.e.\n\t * before page_add_anon_rmap() and swap_free(); try_to_free_swap()\n\t * must be called after the swap_free(), or it will never succeed.\n\t */\n\n\tinc_mm_counter_fast(vma->vm_mm, MM_ANONPAGES);\n\tdec_mm_counter_fast(vma->vm_mm, MM_SWAPENTS);\n\tpte = mk_pte(page, vma->vm_page_prot);\n\tif ((vmf->flags & FAULT_FLAG_WRITE) && reuse_swap_page(page, NULL)) {\n\t\tpte = maybe_mkwrite(pte_mkdirty(pte), vma);\n\t\tvmf->flags &= ~FAULT_FLAG_WRITE;\n\t\tret |= VM_FAULT_WRITE;\n\t\texclusive = RMAP_EXCLUSIVE;\n\t}\n\tflush_icache_page(vma, page);\n\tif (pte_swp_soft_dirty(vmf->orig_pte))\n\t\tpte = pte_mksoft_dirty(pte);\n\tset_pte_at(vma->vm_mm, vmf->address, vmf->pte, pte);\n\tarch_do_swap_page(vma->vm_mm, vma, vmf->address, pte, vmf->orig_pte);\n\tvmf->orig_pte = pte;\n\n\t/* ksm created a completely new copy */\n\tif (unlikely(page != swapcache && swapcache)) {\n\t\tpage_add_new_anon_rmap(page, vma, vmf->address, false);\n\t\tmem_cgroup_commit_charge(page, memcg, false, false);\n\t\tlru_cache_add_active_or_unevictable(page, vma);\n\t} else {\n\t\tdo_page_add_anon_rmap(page, vma, vmf->address, exclusive);\n\t\tmem_cgroup_commit_charge(page, memcg, true, false);\n\t\tactivate_page(page);\n\t}\n\n\tswap_free(entry);\n\tif (mem_cgroup_swap_full(page) ||\n\t    (vma->vm_flags & VM_LOCKED) || PageMlocked(page))\n\t\ttry_to_free_swap(page);\n\tunlock_page(page);\n\tif (page != swapcache && swapcache) {\n\t\t/*\n\t\t * Hold the lock to avoid the swap entry to be reused\n\t\t * until we take the PT lock for the pte_same() check\n\t\t * (to avoid false positives from pte_same). For\n\t\t * further safety release the lock after the swap_free\n\t\t * so that the swap count won't change under a\n\t\t * parallel locked swapcache.\n\t\t */\n\t\tunlock_page(swapcache);\n\t\tput_page(swapcache);\n\t}\n\n\tif (vmf->flags & FAULT_FLAG_WRITE) {\n\t\tret |= do_wp_page(vmf);\n\t\tif (ret & VM_FAULT_ERROR)\n\t\t\tret &= VM_FAULT_ERROR;\n\t\tgoto out;\n\t}\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\nunlock:\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\nout:\n\treturn ret;\nout_nomap:\n\tmem_cgroup_cancel_charge(page, memcg, false);\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\nout_page:\n\tunlock_page(page);\nout_release:\n\tput_page(page);\n\tif (page != swapcache && swapcache) {\n\t\tunlock_page(swapcache);\n\t\tput_page(swapcache);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "swapcache"
          ],
          "line": 2866
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "swapcache"
          ],
          "line": 2865
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "vmf->pte",
            "vmf->ptl"
          ],
          "line": 2859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_cancel_charge",
          "args": [
            "page",
            "memcg",
            "false"
          ],
          "line": 2858
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_cancel_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5972-5988",
          "snippet": "void mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,\n\t\tbool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcancel_charge(memcg, nr_pages);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,\n\t\tbool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcancel_charge(memcg, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "vmf->pte",
            "vmf->ptl"
          ],
          "line": 2854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_mmu_cache",
          "args": [
            "vma",
            "vmf->address",
            "vmf->pte"
          ],
          "line": 2852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_wp_page",
          "args": [
            "vmf"
          ],
          "line": 2845
        },
        "resolved": true,
        "details": {
          "function_name": "do_wp_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2480-2550",
          "snippet": "static vm_fault_t do_wp_page(struct vm_fault *vmf)\n\t__releases(vmf->ptl)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\n\tvmf->page = vm_normal_page(vma, vmf->address, vmf->orig_pte);\n\tif (!vmf->page) {\n\t\t/*\n\t\t * VM_MIXEDMAP !pfn_valid() case, or VM_SOFTDIRTY clear on a\n\t\t * VM_PFNMAP VMA.\n\t\t *\n\t\t * We should not cow pages in a shared writeable mapping.\n\t\t * Just mark the pages writable and/or call ops->pfn_mkwrite.\n\t\t */\n\t\tif ((vma->vm_flags & (VM_WRITE|VM_SHARED)) ==\n\t\t\t\t     (VM_WRITE|VM_SHARED))\n\t\t\treturn wp_pfn_shared(vmf);\n\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\treturn wp_page_copy(vmf);\n\t}\n\n\t/*\n\t * Take out anonymous pages first, anonymous shared vmas are\n\t * not dirty accountable.\n\t */\n\tif (PageAnon(vmf->page) && !PageKsm(vmf->page)) {\n\t\tint total_map_swapcount;\n\t\tif (!trylock_page(vmf->page)) {\n\t\t\tget_page(vmf->page);\n\t\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\t\tlock_page(vmf->page);\n\t\t\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd,\n\t\t\t\t\tvmf->address, &vmf->ptl);\n\t\t\tif (!pte_same(*vmf->pte, vmf->orig_pte)) {\n\t\t\t\tunlock_page(vmf->page);\n\t\t\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\t\t\tput_page(vmf->page);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tput_page(vmf->page);\n\t\t}\n\t\tif (reuse_swap_page(vmf->page, &total_map_swapcount)) {\n\t\t\tif (total_map_swapcount == 1) {\n\t\t\t\t/*\n\t\t\t\t * The page is all ours. Move it to\n\t\t\t\t * our anon_vma so the rmap code will\n\t\t\t\t * not search our parent or siblings.\n\t\t\t\t * Protected against the rmap code by\n\t\t\t\t * the page lock.\n\t\t\t\t */\n\t\t\t\tpage_move_anon_rmap(vmf->page, vma);\n\t\t\t}\n\t\t\tunlock_page(vmf->page);\n\t\t\twp_page_reuse(vmf);\n\t\t\treturn VM_FAULT_WRITE;\n\t\t}\n\t\tunlock_page(vmf->page);\n\t} else if (unlikely((vma->vm_flags & (VM_WRITE|VM_SHARED)) ==\n\t\t\t\t\t(VM_WRITE|VM_SHARED))) {\n\t\treturn wp_page_shared(vmf);\n\t}\n\n\t/*\n\t * Ok, we need to copy. Oh, well..\n\t */\n\tget_page(vmf->page);\n\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\treturn wp_page_copy(vmf);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t do_wp_page(struct vm_fault *vmf)\n\t__releases(vmf->ptl)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\n\tvmf->page = vm_normal_page(vma, vmf->address, vmf->orig_pte);\n\tif (!vmf->page) {\n\t\t/*\n\t\t * VM_MIXEDMAP !pfn_valid() case, or VM_SOFTDIRTY clear on a\n\t\t * VM_PFNMAP VMA.\n\t\t *\n\t\t * We should not cow pages in a shared writeable mapping.\n\t\t * Just mark the pages writable and/or call ops->pfn_mkwrite.\n\t\t */\n\t\tif ((vma->vm_flags & (VM_WRITE|VM_SHARED)) ==\n\t\t\t\t     (VM_WRITE|VM_SHARED))\n\t\t\treturn wp_pfn_shared(vmf);\n\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\treturn wp_page_copy(vmf);\n\t}\n\n\t/*\n\t * Take out anonymous pages first, anonymous shared vmas are\n\t * not dirty accountable.\n\t */\n\tif (PageAnon(vmf->page) && !PageKsm(vmf->page)) {\n\t\tint total_map_swapcount;\n\t\tif (!trylock_page(vmf->page)) {\n\t\t\tget_page(vmf->page);\n\t\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\t\tlock_page(vmf->page);\n\t\t\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd,\n\t\t\t\t\tvmf->address, &vmf->ptl);\n\t\t\tif (!pte_same(*vmf->pte, vmf->orig_pte)) {\n\t\t\t\tunlock_page(vmf->page);\n\t\t\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\t\t\tput_page(vmf->page);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tput_page(vmf->page);\n\t\t}\n\t\tif (reuse_swap_page(vmf->page, &total_map_swapcount)) {\n\t\t\tif (total_map_swapcount == 1) {\n\t\t\t\t/*\n\t\t\t\t * The page is all ours. Move it to\n\t\t\t\t * our anon_vma so the rmap code will\n\t\t\t\t * not search our parent or siblings.\n\t\t\t\t * Protected against the rmap code by\n\t\t\t\t * the page lock.\n\t\t\t\t */\n\t\t\t\tpage_move_anon_rmap(vmf->page, vma);\n\t\t\t}\n\t\t\tunlock_page(vmf->page);\n\t\t\twp_page_reuse(vmf);\n\t\t\treturn VM_FAULT_WRITE;\n\t\t}\n\t\tunlock_page(vmf->page);\n\t} else if (unlikely((vma->vm_flags & (VM_WRITE|VM_SHARED)) ==\n\t\t\t\t\t(VM_WRITE|VM_SHARED))) {\n\t\treturn wp_page_shared(vmf);\n\t}\n\n\t/*\n\t * Ok, we need to copy. Oh, well..\n\t */\n\tget_page(vmf->page);\n\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\treturn wp_page_copy(vmf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_free_swap",
          "args": [
            "page"
          ],
          "line": 2829
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1584-1617",
          "snippet": "int try_to_free_swap(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (!PageSwapCache(page))\n\t\treturn 0;\n\tif (PageWriteback(page))\n\t\treturn 0;\n\tif (page_swapped(page))\n\t\treturn 0;\n\n\t/*\n\t * Once hibernation has begun to create its image of memory,\n\t * there's a danger that one of the calls to try_to_free_swap()\n\t * - most probably a call from __try_to_reclaim_swap() while\n\t * hibernation is allocating its own swap pages for the image,\n\t * but conceivably even a call from memory reclaim - will free\n\t * the swap from a page which has already been recorded in the\n\t * image as a clean swapcache page, and then reuse its swap for\n\t * another page of the image.  On waking from hibernation, the\n\t * original page might be freed under memory pressure, then\n\t * later read back in from swap, now with the wrong data.\n\t *\n\t * Hibernation suspends storage while it is writing the image\n\t * to disk so check that here.\n\t */\n\tif (pm_suspended_storage())\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\tdelete_from_swap_cache(page);\n\tSetPageDirty(page);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint try_to_free_swap(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (!PageSwapCache(page))\n\t\treturn 0;\n\tif (PageWriteback(page))\n\t\treturn 0;\n\tif (page_swapped(page))\n\t\treturn 0;\n\n\t/*\n\t * Once hibernation has begun to create its image of memory,\n\t * there's a danger that one of the calls to try_to_free_swap()\n\t * - most probably a call from __try_to_reclaim_swap() while\n\t * hibernation is allocating its own swap pages for the image,\n\t * but conceivably even a call from memory reclaim - will free\n\t * the swap from a page which has already been recorded in the\n\t * image as a clean swapcache page, and then reuse its swap for\n\t * another page of the image.  On waking from hibernation, the\n\t * original page might be freed under memory pressure, then\n\t * later read back in from swap, now with the wrong data.\n\t *\n\t * Hibernation suspends storage while it is writing the image\n\t * to disk so check that here.\n\t */\n\tif (pm_suspended_storage())\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\tdelete_from_swap_cache(page);\n\tSetPageDirty(page);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageMlocked",
          "args": [
            "page"
          ],
          "line": 2828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_swap_full",
          "args": [
            "page"
          ],
          "line": 2827
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_swap_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6532-6552",
          "snippet": "bool mem_cgroup_swap_full(struct page *page)\n{\n\tstruct mem_cgroup *memcg;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (vm_swap_full())\n\t\treturn true;\n\tif (!do_swap_account || !cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\treturn false;\n\n\tmemcg = page->mem_cgroup;\n\tif (!memcg)\n\t\treturn false;\n\n\tfor (; memcg != root_mem_cgroup; memcg = parent_mem_cgroup(memcg))\n\t\tif (page_counter_read(&memcg->swap) * 2 >= memcg->swap.max)\n\t\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define do_swap_account\t\t0"
          ],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nbool mem_cgroup_swap_full(struct page *page)\n{\n\tstruct mem_cgroup *memcg;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (vm_swap_full())\n\t\treturn true;\n\tif (!do_swap_account || !cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\treturn false;\n\n\tmemcg = page->mem_cgroup;\n\tif (!memcg)\n\t\treturn false;\n\n\tfor (; memcg != root_mem_cgroup; memcg = parent_mem_cgroup(memcg))\n\t\tif (page_counter_read(&memcg->swap) * 2 >= memcg->swap.max)\n\t\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_free",
          "args": [
            "entry"
          ],
          "line": 2826
        },
        "resolved": true,
        "details": {
          "function_name": "swap_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1213-1220",
          "snippet": "void swap_free(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = _swap_info_get(entry);\n\tif (p)\n\t\t__swap_entry_free(p, entry, 1);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nvoid swap_free(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\n\tp = _swap_info_get(entry);\n\tif (p)\n\t\t__swap_entry_free(p, entry, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "activate_page",
          "args": [
            "page"
          ],
          "line": 2823
        },
        "resolved": true,
        "details": {
          "function_name": "__lru_cache_activate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "339-364",
          "snippet": "static void __lru_cache_activate_page(struct page *page)\n{\n\tstruct pagevec *pvec = &get_cpu_var(lru_add_pvec);\n\tint i;\n\n\t/*\n\t * Search backwards on the optimistic assumption that the page being\n\t * activated has just been added to this pagevec. Note that only\n\t * the local pagevec is examined as a !PageLRU page could be in the\n\t * process of being released, reclaimed, migrated or on a remote\n\t * pagevec that is currently being drained. Furthermore, marking\n\t * a remote pagevec's page PageActive potentially hits a race where\n\t * a page is marked PageActive just after it is added to the inactive\n\t * list causing accounting errors and BUG_ON checks to trigger.\n\t */\n\tfor (i = pagevec_count(pvec) - 1; i >= 0; i--) {\n\t\tstruct page *pagevec_page = pvec->pages[i];\n\n\t\tif (pagevec_page == page) {\n\t\t\tSetPageActive(page);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_cpu_var(lru_add_pvec);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\n\nstatic void __lru_cache_activate_page(struct page *page)\n{\n\tstruct pagevec *pvec = &get_cpu_var(lru_add_pvec);\n\tint i;\n\n\t/*\n\t * Search backwards on the optimistic assumption that the page being\n\t * activated has just been added to this pagevec. Note that only\n\t * the local pagevec is examined as a !PageLRU page could be in the\n\t * process of being released, reclaimed, migrated or on a remote\n\t * pagevec that is currently being drained. Furthermore, marking\n\t * a remote pagevec's page PageActive potentially hits a race where\n\t * a page is marked PageActive just after it is added to the inactive\n\t * list causing accounting errors and BUG_ON checks to trigger.\n\t */\n\tfor (i = pagevec_count(pvec) - 1; i >= 0; i--) {\n\t\tstruct page *pagevec_page = pvec->pages[i];\n\n\t\tif (pagevec_page == page) {\n\t\t\tSetPageActive(page);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_cpu_var(lru_add_pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_commit_charge",
          "args": [
            "page",
            "memcg",
            "true",
            "false"
          ],
          "line": 2822
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_commit_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5928-5962",
          "snippet": "void mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t      bool lrucare, bool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_PAGE(!page->mapping, page);\n\tVM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcommit_charge(page, memcg, lrucare);\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(memcg, page, compound, nr_pages);\n\tmemcg_check_events(memcg, page);\n\tlocal_irq_enable();\n\n\tif (do_memsw_account() && PageSwapCache(page)) {\n\t\tswp_entry_t entry = { .val = page_private(page) };\n\t\t/*\n\t\t * The swap entry might not get freed for a long time,\n\t\t * let's not wait for it.  The page already received a\n\t\t * memory+swap charge, drop the swap entry duplicate.\n\t\t */\n\t\tmem_cgroup_uncharge_swap(entry, nr_pages);\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t      bool lrucare, bool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_PAGE(!page->mapping, page);\n\tVM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcommit_charge(page, memcg, lrucare);\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(memcg, page, compound, nr_pages);\n\tmemcg_check_events(memcg, page);\n\tlocal_irq_enable();\n\n\tif (do_memsw_account() && PageSwapCache(page)) {\n\t\tswp_entry_t entry = { .val = page_private(page) };\n\t\t/*\n\t\t * The swap entry might not get freed for a long time,\n\t\t * let's not wait for it.  The page already received a\n\t\t * memory+swap charge, drop the swap entry duplicate.\n\t\t */\n\t\tmem_cgroup_uncharge_swap(entry, nr_pages);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_page_add_anon_rmap",
          "args": [
            "page",
            "vma",
            "vmf->address",
            "exclusive"
          ],
          "line": 2821
        },
        "resolved": true,
        "details": {
          "function_name": "do_page_add_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1098-1137",
          "snippet": "void do_page_add_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int flags)\n{\n\tbool compound = flags & RMAP_COMPOUND;\n\tbool first;\n\n\tif (compound) {\n\t\tatomic_t *mapcount;\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\tmapcount = compound_mapcount_ptr(page);\n\t\tfirst = atomic_inc_and_test(mapcount);\n\t} else {\n\t\tfirst = atomic_inc_and_test(&page->_mapcount);\n\t}\n\n\tif (first) {\n\t\tint nr = compound ? hpage_nr_pages(page) : 1;\n\t\t/*\n\t\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t\t * these counters are not modified in interrupt context, and\n\t\t * pte lock(a spinlock) is held, which implies preemption\n\t\t * disabled.\n\t\t */\n\t\tif (compound)\n\t\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t}\n\tif (unlikely(PageKsm(page)))\n\t\treturn;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\t/* address might be in next vma when migration races vma_adjust */\n\tif (first)\n\t\t__page_set_anon_rmap(page, vma, address,\n\t\t\t\tflags & RMAP_EXCLUSIVE);\n\telse\n\t\t__page_check_anon_rmap(page, vma, address);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid do_page_add_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int flags)\n{\n\tbool compound = flags & RMAP_COMPOUND;\n\tbool first;\n\n\tif (compound) {\n\t\tatomic_t *mapcount;\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\tmapcount = compound_mapcount_ptr(page);\n\t\tfirst = atomic_inc_and_test(mapcount);\n\t} else {\n\t\tfirst = atomic_inc_and_test(&page->_mapcount);\n\t}\n\n\tif (first) {\n\t\tint nr = compound ? hpage_nr_pages(page) : 1;\n\t\t/*\n\t\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t\t * these counters are not modified in interrupt context, and\n\t\t * pte lock(a spinlock) is held, which implies preemption\n\t\t * disabled.\n\t\t */\n\t\tif (compound)\n\t\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t}\n\tif (unlikely(PageKsm(page)))\n\t\treturn;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\t/* address might be in next vma when migration races vma_adjust */\n\tif (first)\n\t\t__page_set_anon_rmap(page, vma, address,\n\t\t\t\tflags & RMAP_EXCLUSIVE);\n\telse\n\t\t__page_check_anon_rmap(page, vma, address);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_cache_add_active_or_unevictable",
          "args": [
            "page",
            "vma"
          ],
          "line": 2819
        },
        "resolved": true,
        "details": {
          "function_name": "lru_cache_add_active_or_unevictable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "458-476",
          "snippet": "void lru_cache_add_active_or_unevictable(struct page *page,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\tif (likely((vma->vm_flags & (VM_LOCKED | VM_SPECIAL)) != VM_LOCKED))\n\t\tSetPageActive(page);\n\telse if (!TestSetPageMlocked(page)) {\n\t\t/*\n\t\t * We use the irq-unsafe __mod_zone_page_stat because this\n\t\t * counter is not modified from interrupt context, and the pte\n\t\t * lock is held(spinlock), which implies preemption disabled.\n\t\t */\n\t\t__mod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t}\n\tlru_cache_add(page);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid lru_cache_add_active_or_unevictable(struct page *page,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\tif (likely((vma->vm_flags & (VM_LOCKED | VM_SPECIAL)) != VM_LOCKED))\n\t\tSetPageActive(page);\n\telse if (!TestSetPageMlocked(page)) {\n\t\t/*\n\t\t * We use the irq-unsafe __mod_zone_page_stat because this\n\t\t * counter is not modified from interrupt context, and the pte\n\t\t * lock is held(spinlock), which implies preemption disabled.\n\t\t */\n\t\t__mod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t}\n\tlru_cache_add(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_add_new_anon_rmap",
          "args": [
            "page",
            "vma",
            "vmf->address",
            "false"
          ],
          "line": 2817
        },
        "resolved": true,
        "details": {
          "function_name": "page_add_new_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1150-1170",
          "snippet": "void page_add_new_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, bool compound)\n{\n\tint nr = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\t__SetPageSwapBacked(page);\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(compound_mapcount_ptr(page), 0);\n\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t} else {\n\t\t/* Anon THP always mapped first with PMD */\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(&page->_mapcount, 0);\n\t}\n\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t__page_set_anon_rmap(page, vma, address, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_add_new_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, bool compound)\n{\n\tint nr = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\t__SetPageSwapBacked(page);\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(compound_mapcount_ptr(page), 0);\n\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t} else {\n\t\t/* Anon THP always mapped first with PMD */\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(&page->_mapcount, 0);\n\t}\n\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t__page_set_anon_rmap(page, vma, address, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page != swapcache && swapcache"
          ],
          "line": 2816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_do_swap_page",
          "args": [
            "vma->vm_mm",
            "vma",
            "vmf->address",
            "pte",
            "vmf->orig_pte"
          ],
          "line": 2812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "vma->vm_mm",
            "vmf->address",
            "vmf->pte",
            "pte"
          ],
          "line": 2811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mksoft_dirty",
          "args": [
            "pte"
          ],
          "line": 2810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_swp_soft_dirty",
          "args": [
            "vmf->orig_pte"
          ],
          "line": 2809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_icache_page",
          "args": [
            "vma",
            "page"
          ],
          "line": 2808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "maybe_mkwrite",
          "args": [
            "pte_mkdirty(pte)",
            "vma"
          ],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkdirty",
          "args": [
            "pte"
          ],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reuse_swap_page",
          "args": [
            "page",
            "NULL"
          ],
          "line": 2802
        },
        "resolved": true,
        "details": {
          "function_name": "reuse_swap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1544-1578",
          "snippet": "bool reuse_swap_page(struct page *page, int *total_map_swapcount)\n{\n\tint count, total_mapcount, total_swapcount;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (unlikely(PageKsm(page)))\n\t\treturn false;\n\tcount = page_trans_huge_map_swapcount(page, &total_mapcount,\n\t\t\t\t\t      &total_swapcount);\n\tif (total_map_swapcount)\n\t\t*total_map_swapcount = total_mapcount + total_swapcount;\n\tif (count == 1 && PageSwapCache(page) &&\n\t    (likely(!PageTransCompound(page)) ||\n\t     /* The remaining swap count will be freed soon */\n\t     total_swapcount == page_swapcount(page))) {\n\t\tif (!PageWriteback(page)) {\n\t\t\tpage = compound_head(page);\n\t\t\tdelete_from_swap_cache(page);\n\t\t\tSetPageDirty(page);\n\t\t} else {\n\t\t\tswp_entry_t entry;\n\t\t\tstruct swap_info_struct *p;\n\n\t\t\tentry.val = page_private(page);\n\t\t\tp = swap_info_get(entry);\n\t\t\tif (p->flags & SWP_STABLE_WRITES) {\n\t\t\t\tspin_unlock(&p->lock);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tspin_unlock(&p->lock);\n\t\t}\n\t}\n\n\treturn count <= 1;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nbool reuse_swap_page(struct page *page, int *total_map_swapcount)\n{\n\tint count, total_mapcount, total_swapcount;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (unlikely(PageKsm(page)))\n\t\treturn false;\n\tcount = page_trans_huge_map_swapcount(page, &total_mapcount,\n\t\t\t\t\t      &total_swapcount);\n\tif (total_map_swapcount)\n\t\t*total_map_swapcount = total_mapcount + total_swapcount;\n\tif (count == 1 && PageSwapCache(page) &&\n\t    (likely(!PageTransCompound(page)) ||\n\t     /* The remaining swap count will be freed soon */\n\t     total_swapcount == page_swapcount(page))) {\n\t\tif (!PageWriteback(page)) {\n\t\t\tpage = compound_head(page);\n\t\t\tdelete_from_swap_cache(page);\n\t\t\tSetPageDirty(page);\n\t\t} else {\n\t\t\tswp_entry_t entry;\n\t\t\tstruct swap_info_struct *p;\n\n\t\t\tentry.val = page_private(page);\n\t\t\tp = swap_info_get(entry);\n\t\t\tif (p->flags & SWP_STABLE_WRITES) {\n\t\t\t\tspin_unlock(&p->lock);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tspin_unlock(&p->lock);\n\t\t}\n\t}\n\n\treturn count <= 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mk_pte",
          "args": [
            "page",
            "vma->vm_page_prot"
          ],
          "line": 2801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_mm_counter_fast",
          "args": [
            "vma->vm_mm",
            "MM_SWAPENTS"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_mm_counter_fast",
          "args": [
            "vma->vm_mm",
            "MM_ANONPAGES"
          ],
          "line": 2799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 2784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pte_same(*vmf->pte, vmf->orig_pte)"
          ],
          "line": 2781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_same",
          "args": [
            "*vmf->pte",
            "vmf->orig_pte"
          ],
          "line": 2781
        },
        "resolved": true,
        "details": {
          "function_name": "pte_same_as_swp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1735-1738",
          "snippet": "static inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "vma->vm_mm",
            "vmf->pmd",
            "vmf->address",
            "&vmf->ptl"
          ],
          "line": 2779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_try_charge_delay",
          "args": [
            "page",
            "vma->vm_mm",
            "GFP_KERNEL",
            "&memcg",
            "false"
          ],
          "line": 2770
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_try_charge_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5898-5909",
          "snippet": "int mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\tret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);\n\tmemcg = *memcgp;\n\tmem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nint mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\tret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);\n\tmemcg = *memcgp;\n\tmem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page"
          ],
          "line": 2764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ksm_might_need_to_copy",
          "args": [
            "page",
            "vma",
            "vmf->address"
          ],
          "line": 2763
        },
        "resolved": true,
        "details": {
          "function_name": "ksm_might_need_to_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "2548-2577",
          "snippet": "struct page *ksm_might_need_to_copy(struct page *page,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tstruct anon_vma *anon_vma = page_anon_vma(page);\n\tstruct page *new_page;\n\n\tif (PageKsm(page)) {\n\t\tif (page_stable_node(page) &&\n\t\t    !(ksm_run & KSM_RUN_UNMERGE))\n\t\t\treturn page;\t/* no need to copy it */\n\t} else if (!anon_vma) {\n\t\treturn page;\t\t/* no need to copy it */\n\t} else if (anon_vma->root == vma->anon_vma->root &&\n\t\t page->index == linear_page_index(vma, address)) {\n\t\treturn page;\t\t/* still no need to copy it */\n\t}\n\tif (!PageUptodate(page))\n\t\treturn page;\t\t/* let do_swap_page report the error */\n\n\tnew_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);\n\tif (new_page) {\n\t\tcopy_user_highpage(new_page, page, address, vma);\n\n\t\tSetPageDirty(new_page);\n\t\t__SetPageUptodate(new_page);\n\t\t__SetPageLocked(new_page);\n\t}\n\n\treturn new_page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define KSM_RUN_UNMERGE\t2"
          ],
          "globals_used": [
            "static unsigned long ksm_run = KSM_RUN_STOP;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define KSM_RUN_UNMERGE\t2\n\nstatic unsigned long ksm_run = KSM_RUN_STOP;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstruct page *ksm_might_need_to_copy(struct page *page,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tstruct anon_vma *anon_vma = page_anon_vma(page);\n\tstruct page *new_page;\n\n\tif (PageKsm(page)) {\n\t\tif (page_stable_node(page) &&\n\t\t    !(ksm_run & KSM_RUN_UNMERGE))\n\t\t\treturn page;\t/* no need to copy it */\n\t} else if (!anon_vma) {\n\t\treturn page;\t\t/* no need to copy it */\n\t} else if (anon_vma->root == vma->anon_vma->root &&\n\t\t page->index == linear_page_index(vma, address)) {\n\t\treturn page;\t\t/* still no need to copy it */\n\t}\n\tif (!PageUptodate(page))\n\t\treturn page;\t\t/* let do_swap_page report the error */\n\n\tnew_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);\n\tif (new_page) {\n\t\tcopy_user_highpage(new_page, page, address, vma);\n\n\t\tSetPageDirty(new_page);\n\t\t__SetPageUptodate(new_page);\n\t\t__SetPageLocked(new_page);\n\t}\n\n\treturn new_page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(!PageSwapCache(page) ||\n\t\t\tpage_private(page) != entry.val)"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delayacct_clear_flag",
          "args": [
            "DELAYACCT_PF_SWAPIN"
          ],
          "line": 2747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_page_or_retry",
          "args": [
            "page",
            "vma->vm_mm",
            "vmf->flags"
          ],
          "line": 2745
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_page_or_retry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1290-1320",
          "snippet": "int __lock_page_or_retry(struct page *page, struct mm_struct *mm,\n\t\t\t unsigned int flags)\n{\n\tif (flags & FAULT_FLAG_ALLOW_RETRY) {\n\t\t/*\n\t\t * CAUTION! In this case, mmap_sem is not released\n\t\t * even though return 0.\n\t\t */\n\t\tif (flags & FAULT_FLAG_RETRY_NOWAIT)\n\t\t\treturn 0;\n\n\t\tup_read(&mm->mmap_sem);\n\t\tif (flags & FAULT_FLAG_KILLABLE)\n\t\t\twait_on_page_locked_killable(page);\n\t\telse\n\t\t\twait_on_page_locked(page);\n\t\treturn 0;\n\t} else {\n\t\tif (flags & FAULT_FLAG_KILLABLE) {\n\t\t\tint ret;\n\n\t\t\tret = __lock_page_killable(page);\n\t\t\tif (ret) {\n\t\t\t\tup_read(&mm->mmap_sem);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else\n\t\t\t__lock_page(page);\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint __lock_page_or_retry(struct page *page, struct mm_struct *mm,\n\t\t\t unsigned int flags)\n{\n\tif (flags & FAULT_FLAG_ALLOW_RETRY) {\n\t\t/*\n\t\t * CAUTION! In this case, mmap_sem is not released\n\t\t * even though return 0.\n\t\t */\n\t\tif (flags & FAULT_FLAG_RETRY_NOWAIT)\n\t\t\treturn 0;\n\n\t\tup_read(&mm->mmap_sem);\n\t\tif (flags & FAULT_FLAG_KILLABLE)\n\t\t\twait_on_page_locked_killable(page);\n\t\telse\n\t\t\twait_on_page_locked(page);\n\t\treturn 0;\n\t} else {\n\t\tif (flags & FAULT_FLAG_KILLABLE) {\n\t\t\tint ret;\n\n\t\t\tret = __lock_page_killable(page);\n\t\t\tif (ret) {\n\t\t\t\tup_read(&mm->mmap_sem);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else\n\t\t\t__lock_page(page);\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "delayacct_clear_flag",
          "args": [
            "DELAYACCT_PF_SWAPIN"
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHWPoison",
          "args": [
            "page"
          ],
          "line": 2735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_memcg_event_mm",
          "args": [
            "vma->vm_mm",
            "PGMAJFAULT"
          ],
          "line": 2734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "PGMAJFAULT"
          ],
          "line": 2733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delayacct_clear_flag",
          "args": [
            "DELAYACCT_PF_SWAPIN"
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "pte_same(*vmf->pte, vmf->orig_pte)"
          ],
          "line": 2725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "vma->vm_mm",
            "vmf->pmd",
            "vmf->address",
            "&vmf->ptl"
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swapin_readahead",
          "args": [
            "entry",
            "GFP_HIGHUSER_MOVABLE",
            "vmf"
          ],
          "line": 2713
        },
        "resolved": true,
        "details": {
          "function_name": "force_swapin_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/madvise.c",
          "lines": "228-240",
          "snippet": "static void force_swapin_readahead(struct vm_area_struct *vma,\n\t\tunsigned long start, unsigned long end)\n{\n\tstruct mm_walk walk = {\n\t\t.mm = vma->vm_mm,\n\t\t.pmd_entry = swapin_walk_pmd_entry,\n\t\t.private = vma,\n\t};\n\n\twalk_page_range(start, end, &walk);\n\n\tlru_add_drain();\t/* Push any new pages onto the LRU now */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched.h>",
            "#include <linux/falloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/ksm.h>\n#include <linux/sched.h>\n#include <linux/falloc.h>\n#include <linux/hugetlb.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/page-isolation.h>\n#include <linux/mempolicy.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n\nstatic void force_swapin_readahead(struct vm_area_struct *vma,\n\t\tunsigned long start, unsigned long end)\n{\n\tstruct mm_walk walk = {\n\t\t.mm = vma->vm_mm,\n\t\t.pmd_entry = swapin_walk_pmd_entry,\n\t\t.private = vma,\n\t};\n\n\twalk_page_range(start, end, &walk);\n\n\tlru_add_drain();\t/* Push any new pages onto the LRU now */\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_readpage",
          "args": [
            "page",
            "true"
          ],
          "line": 2710
        },
        "resolved": true,
        "details": {
          "function_name": "swap_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_io.c",
          "lines": "351-420",
          "snippet": "int swap_readpage(struct page *page, bool synchronous)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\tstruct swap_info_struct *sis = page_swap_info(page);\n\tblk_qc_t qc;\n\tstruct gendisk *disk;\n\n\tVM_BUG_ON_PAGE(!PageSwapCache(page) && !synchronous, page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(PageUptodate(page), page);\n\tif (frontswap_load(page) == 0) {\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tgoto out;\n\t}\n\n\tif (sis->flags & SWP_FS) {\n\t\tstruct file *swap_file = sis->swap_file;\n\t\tstruct address_space *mapping = swap_file->f_mapping;\n\n\t\tret = mapping->a_ops->readpage(swap_file, page);\n\t\tif (!ret)\n\t\t\tcount_vm_event(PSWPIN);\n\t\treturn ret;\n\t}\n\n\tret = bdev_read_page(sis->bdev, swap_page_sector(page), page);\n\tif (!ret) {\n\t\tif (trylock_page(page)) {\n\t\t\tswap_slot_free_notify(page);\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\tcount_vm_event(PSWPIN);\n\t\treturn 0;\n\t}\n\n\tret = 0;\n\tbio = get_swap_bio(GFP_KERNEL, page, end_swap_bio_read);\n\tif (bio == NULL) {\n\t\tunlock_page(page);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tdisk = bio->bi_disk;\n\t/*\n\t * Keep this task valid during swap readpage because the oom killer may\n\t * attempt to access it in the page fault retry time check.\n\t */\n\tget_task_struct(current);\n\tbio->bi_private = current;\n\tbio_set_op_attrs(bio, REQ_OP_READ, 0);\n\tcount_vm_event(PSWPIN);\n\tbio_get(bio);\n\tqc = submit_bio(bio);\n\twhile (synchronous) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!READ_ONCE(bio->bi_private))\n\t\t\tbreak;\n\n\t\tif (!blk_poll(disk->queue, qc))\n\t\t\tbreak;\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tbio_put(bio);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/swapops.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/sched/task.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/frontswap.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swapops.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n\nint swap_readpage(struct page *page, bool synchronous)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\tstruct swap_info_struct *sis = page_swap_info(page);\n\tblk_qc_t qc;\n\tstruct gendisk *disk;\n\n\tVM_BUG_ON_PAGE(!PageSwapCache(page) && !synchronous, page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(PageUptodate(page), page);\n\tif (frontswap_load(page) == 0) {\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tgoto out;\n\t}\n\n\tif (sis->flags & SWP_FS) {\n\t\tstruct file *swap_file = sis->swap_file;\n\t\tstruct address_space *mapping = swap_file->f_mapping;\n\n\t\tret = mapping->a_ops->readpage(swap_file, page);\n\t\tif (!ret)\n\t\t\tcount_vm_event(PSWPIN);\n\t\treturn ret;\n\t}\n\n\tret = bdev_read_page(sis->bdev, swap_page_sector(page), page);\n\tif (!ret) {\n\t\tif (trylock_page(page)) {\n\t\t\tswap_slot_free_notify(page);\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\tcount_vm_event(PSWPIN);\n\t\treturn 0;\n\t}\n\n\tret = 0;\n\tbio = get_swap_bio(GFP_KERNEL, page, end_swap_bio_read);\n\tif (bio == NULL) {\n\t\tunlock_page(page);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tdisk = bio->bi_disk;\n\t/*\n\t * Keep this task valid during swap readpage because the oom killer may\n\t * attempt to access it in the page fault retry time check.\n\t */\n\tget_task_struct(current);\n\tbio->bi_private = current;\n\tbio_set_op_attrs(bio, REQ_OP_READ, 0);\n\tcount_vm_event(PSWPIN);\n\tbio_get(bio);\n\tqc = submit_bio(bio);\n\twhile (synchronous) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!READ_ONCE(bio->bi_private))\n\t\t\tbreak;\n\n\t\tif (!blk_poll(disk->queue, qc))\n\t\t\tbreak;\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tbio_put(bio);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_cache_add_anon",
          "args": [
            "page"
          ],
          "line": 2709
        },
        "resolved": true,
        "details": {
          "function_name": "lru_cache_add_anon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "417-422",
          "snippet": "void lru_cache_add_anon(struct page *page)\n{\n\tif (PageActive(page))\n\t\tClearPageActive(page);\n\t__lru_cache_add(page);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid lru_cache_add_anon(struct page *page)\n{\n\tif (PageActive(page))\n\t\tClearPageActive(page);\n\t__lru_cache_add(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "entry.val"
          ],
          "line": 2708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SetPageSwapBacked",
          "args": [
            "page"
          ],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SetPageLocked",
          "args": [
            "page"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page_vma",
          "args": [
            "GFP_HIGHUSER_MOVABLE",
            "vma",
            "vmf->address"
          ],
          "line": 2703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__swap_count",
          "args": [
            "si",
            "entry"
          ],
          "line": 2701
        },
        "resolved": true,
        "details": {
          "function_name": "__swap_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1348-1353",
          "snippet": "int __swap_count(struct swap_info_struct *si, swp_entry_t entry)\n{\n\tpgoff_t offset = swp_offset(entry);\n\n\treturn swap_count(si->swap_map[offset]);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nint __swap_count(struct swap_info_struct *si, swp_entry_t entry)\n{\n\tpgoff_t offset = swp_offset(entry);\n\n\treturn swap_count(si->swap_map[offset]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swp_swap_info",
          "args": [
            "entry"
          ],
          "line": 2698
        },
        "resolved": true,
        "details": {
          "function_name": "swp_swap_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3465-3468",
          "snippet": "struct swap_info_struct *swp_swap_info(swp_entry_t entry)\n{\n\treturn swap_info[swp_type(entry)];\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "struct swap_info_struct *swap_info[MAX_SWAPFILES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nstruct swap_info_struct *swp_swap_info(swp_entry_t entry)\n{\n\treturn swap_info[swp_type(entry)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_swap_cache",
          "args": [
            "entry",
            "vma",
            "vmf->address"
          ],
          "line": 2694
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_swap_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "309-351",
          "snippet": "struct page *lookup_swap_cache(swp_entry_t entry, struct vm_area_struct *vma,\n\t\t\t       unsigned long addr)\n{\n\tstruct page *page;\n\n\tpage = find_get_page(swap_address_space(entry), swp_offset(entry));\n\n\tINC_CACHE_INFO(find_total);\n\tif (page) {\n\t\tbool vma_ra = swap_use_vma_readahead();\n\t\tbool readahead;\n\n\t\tINC_CACHE_INFO(find_success);\n\t\t/*\n\t\t * At the moment, we don't support PG_readahead for anon THP\n\t\t * so let's bail out rather than confusing the readahead stat.\n\t\t */\n\t\tif (unlikely(PageTransCompound(page)))\n\t\t\treturn page;\n\n\t\treadahead = TestClearPageReadahead(page);\n\t\tif (vma && vma_ra) {\n\t\t\tunsigned long ra_val;\n\t\t\tint win, hits;\n\n\t\t\tra_val = GET_SWAP_RA_VAL(vma);\n\t\t\twin = SWAP_RA_WIN(ra_val);\n\t\t\thits = SWAP_RA_HITS(ra_val);\n\t\t\tif (readahead)\n\t\t\t\thits = min_t(int, hits + 1, SWAP_RA_HITS_MAX);\n\t\t\tatomic_long_set(&vma->swap_readahead_info,\n\t\t\t\t\tSWAP_RA_VAL(addr, win, hits));\n\t\t}\n\n\t\tif (readahead) {\n\t\t\tcount_vm_event(SWAP_RA_HIT);\n\t\t\tif (!vma || !vma_ra)\n\t\t\t\tatomic_inc(&swapin_readahead_hits);\n\t\t}\n\t}\n\n\treturn page;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SWAP_RA_HITS_MAX\tSWAP_RA_HITS_MASK"
          ],
          "globals_used": [
            "static atomic_t swapin_readahead_hits = ATOMIC_INIT(4);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\n#define SWAP_RA_HITS_MAX\tSWAP_RA_HITS_MASK\n\nstatic atomic_t swapin_readahead_hits = ATOMIC_INIT(4);\n\nstruct page *lookup_swap_cache(swp_entry_t entry, struct vm_area_struct *vma,\n\t\t\t       unsigned long addr)\n{\n\tstruct page *page;\n\n\tpage = find_get_page(swap_address_space(entry), swp_offset(entry));\n\n\tINC_CACHE_INFO(find_total);\n\tif (page) {\n\t\tbool vma_ra = swap_use_vma_readahead();\n\t\tbool readahead;\n\n\t\tINC_CACHE_INFO(find_success);\n\t\t/*\n\t\t * At the moment, we don't support PG_readahead for anon THP\n\t\t * so let's bail out rather than confusing the readahead stat.\n\t\t */\n\t\tif (unlikely(PageTransCompound(page)))\n\t\t\treturn page;\n\n\t\treadahead = TestClearPageReadahead(page);\n\t\tif (vma && vma_ra) {\n\t\t\tunsigned long ra_val;\n\t\t\tint win, hits;\n\n\t\t\tra_val = GET_SWAP_RA_VAL(vma);\n\t\t\twin = SWAP_RA_WIN(ra_val);\n\t\t\thits = SWAP_RA_HITS(ra_val);\n\t\t\tif (readahead)\n\t\t\t\thits = min_t(int, hits + 1, SWAP_RA_HITS_MAX);\n\t\t\tatomic_long_set(&vma->swap_readahead_info,\n\t\t\t\t\tSWAP_RA_VAL(addr, win, hits));\n\t\t}\n\n\t\tif (readahead) {\n\t\t\tcount_vm_event(SWAP_RA_HIT);\n\t\t\tif (!vma || !vma_ra)\n\t\t\t\tatomic_inc(&swapin_readahead_hits);\n\t\t}\n\t}\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delayacct_set_flag",
          "args": [
            "DELAYACCT_PF_SWAPIN"
          ],
          "line": 2693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_bad_pte",
          "args": [
            "vma",
            "vmf->address",
            "vmf->orig_pte",
            "NULL"
          ],
          "line": 2686
        },
        "resolved": true,
        "details": {
          "function_name": "print_bad_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "479-528",
          "snippet": "static void print_bad_pte(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t  pte_t pte, struct page *page)\n{\n\tpgd_t *pgd = pgd_offset(vma->vm_mm, addr);\n\tp4d_t *p4d = p4d_offset(pgd, addr);\n\tpud_t *pud = pud_offset(p4d, addr);\n\tpmd_t *pmd = pmd_offset(pud, addr);\n\tstruct address_space *mapping;\n\tpgoff_t index;\n\tstatic unsigned long resume;\n\tstatic unsigned long nr_shown;\n\tstatic unsigned long nr_unshown;\n\n\t/*\n\t * Allow a burst of 60 reports, then keep quiet for that minute;\n\t * or allow a steady drip of one report per second.\n\t */\n\tif (nr_shown == 60) {\n\t\tif (time_before(jiffies, resume)) {\n\t\t\tnr_unshown++;\n\t\t\treturn;\n\t\t}\n\t\tif (nr_unshown) {\n\t\t\tpr_alert(\"BUG: Bad page map: %lu messages suppressed\\n\",\n\t\t\t\t nr_unshown);\n\t\t\tnr_unshown = 0;\n\t\t}\n\t\tnr_shown = 0;\n\t}\n\tif (nr_shown++ == 0)\n\t\tresume = jiffies + 60 * HZ;\n\n\tmapping = vma->vm_file ? vma->vm_file->f_mapping : NULL;\n\tindex = linear_page_index(vma, addr);\n\n\tpr_alert(\"BUG: Bad page map in process %s  pte:%08llx pmd:%08llx\\n\",\n\t\t current->comm,\n\t\t (long long)pte_val(pte), (long long)pmd_val(*pmd));\n\tif (page)\n\t\tdump_page(page, \"bad pte\");\n\tpr_alert(\"addr:%p vm_flags:%08lx anon_vma:%p mapping:%p index:%lx\\n\",\n\t\t (void *)addr, vma->vm_flags, vma->anon_vma, mapping, index);\n\tpr_alert(\"file:%pD fault:%pf mmap:%pf readpage:%pf\\n\",\n\t\t vma->vm_file,\n\t\t vma->vm_ops ? vma->vm_ops->fault : NULL,\n\t\t vma->vm_file ? vma->vm_file->f_op->mmap : NULL,\n\t\t mapping ? mapping->a_ops->readpage : NULL);\n\tdump_stack();\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void print_bad_pte(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t  pte_t pte, struct page *page)\n{\n\tpgd_t *pgd = pgd_offset(vma->vm_mm, addr);\n\tp4d_t *p4d = p4d_offset(pgd, addr);\n\tpud_t *pud = pud_offset(p4d, addr);\n\tpmd_t *pmd = pmd_offset(pud, addr);\n\tstruct address_space *mapping;\n\tpgoff_t index;\n\tstatic unsigned long resume;\n\tstatic unsigned long nr_shown;\n\tstatic unsigned long nr_unshown;\n\n\t/*\n\t * Allow a burst of 60 reports, then keep quiet for that minute;\n\t * or allow a steady drip of one report per second.\n\t */\n\tif (nr_shown == 60) {\n\t\tif (time_before(jiffies, resume)) {\n\t\t\tnr_unshown++;\n\t\t\treturn;\n\t\t}\n\t\tif (nr_unshown) {\n\t\t\tpr_alert(\"BUG: Bad page map: %lu messages suppressed\\n\",\n\t\t\t\t nr_unshown);\n\t\t\tnr_unshown = 0;\n\t\t}\n\t\tnr_shown = 0;\n\t}\n\tif (nr_shown++ == 0)\n\t\tresume = jiffies + 60 * HZ;\n\n\tmapping = vma->vm_file ? vma->vm_file->f_mapping : NULL;\n\tindex = linear_page_index(vma, addr);\n\n\tpr_alert(\"BUG: Bad page map in process %s  pte:%08llx pmd:%08llx\\n\",\n\t\t current->comm,\n\t\t (long long)pte_val(pte), (long long)pmd_val(*pmd));\n\tif (page)\n\t\tdump_page(page, \"bad pte\");\n\tpr_alert(\"addr:%p vm_flags:%08lx anon_vma:%p mapping:%p index:%lx\\n\",\n\t\t (void *)addr, vma->vm_flags, vma->anon_vma, mapping, index);\n\tpr_alert(\"file:%pD fault:%pf mmap:%pf readpage:%pf\\n\",\n\t\t vma->vm_file,\n\t\t vma->vm_ops ? vma->vm_ops->fault : NULL,\n\t\t vma->vm_file ? vma->vm_file->f_op->mmap : NULL,\n\t\t mapping ? mapping->a_ops->readpage : NULL);\n\tdump_stack();\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_hwpoison_entry",
          "args": [
            "entry"
          ],
          "line": 2683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_private_entry_fault",
          "args": [
            "vma",
            "vmf->address",
            "entry",
            "vmf->flags",
            "vmf->pmd"
          ],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_device_private_entry",
          "args": [
            "entry"
          ],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migration_entry_wait",
          "args": [
            "vma->vm_mm",
            "vmf->pmd",
            "vmf->address"
          ],
          "line": 2673
        },
        "resolved": true,
        "details": {
          "function_name": "migration_entry_wait_huge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "353-358",
          "snippet": "void migration_entry_wait_huge(struct vm_area_struct *vma,\n\t\tstruct mm_struct *mm, pte_t *pte)\n{\n\tspinlock_t *ptl = huge_pte_lockptr(hstate_vma(vma), mm, pte);\n\t__migration_entry_wait(mm, pte, ptl);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid migration_entry_wait_huge(struct vm_area_struct *vma,\n\t\tstruct mm_struct *mm, pte_t *pte)\n{\n\tspinlock_t *ptl = huge_pte_lockptr(hstate_vma(vma), mm, pte);\n\t__migration_entry_wait(mm, pte, ptl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_migration_entry",
          "args": [
            "entry"
          ],
          "line": 2672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "non_swap_entry(entry)"
          ],
          "line": 2671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "non_swap_entry",
          "args": [
            "entry"
          ],
          "line": 2671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_to_swp_entry",
          "args": [
            "vmf->orig_pte"
          ],
          "line": 2670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_same",
          "args": [
            "vma->vm_mm",
            "vmf->pmd",
            "vmf->pte",
            "vmf->orig_pte"
          ],
          "line": 2667
        },
        "resolved": true,
        "details": {
          "function_name": "pte_unmap_same",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2072-2086",
          "snippet": "static inline int pte_unmap_same(struct mm_struct *mm, pmd_t *pmd,\n\t\t\t\tpte_t *page_table, pte_t orig_pte)\n{\n\tint same = 1;\n#if defined(CONFIG_SMP) || defined(CONFIG_PREEMPT)\n\tif (sizeof(pte_t) > sizeof(unsigned long)) {\n\t\tspinlock_t *ptl = pte_lockptr(mm, pmd);\n\t\tspin_lock(ptl);\n\t\tsame = pte_same(*page_table, orig_pte);\n\t\tspin_unlock(ptl);\n\t}\n#endif\n\tpte_unmap(page_table);\n\treturn same;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline int pte_unmap_same(struct mm_struct *mm, pmd_t *pmd,\n\t\t\t\tpte_t *page_table, pte_t orig_pte)\n{\n\tint same = 1;\n#if defined(CONFIG_SMP) || defined(CONFIG_PREEMPT)\n\tif (sizeof(pte_t) > sizeof(unsigned long)) {\n\t\tspinlock_t *ptl = pte_lockptr(mm, pmd);\n\t\tspin_lock(ptl);\n\t\tsame = pte_same(*page_table, orig_pte);\n\t\tspin_unlock(ptl);\n\t}\n#endif\n\tpte_unmap(page_table);\n\treturn same;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvm_fault_t do_swap_page(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page = NULL, *swapcache;\n\tstruct mem_cgroup *memcg;\n\tswp_entry_t entry;\n\tpte_t pte;\n\tint locked;\n\tint exclusive = 0;\n\tvm_fault_t ret = 0;\n\n\tif (!pte_unmap_same(vma->vm_mm, vmf->pmd, vmf->pte, vmf->orig_pte))\n\t\tgoto out;\n\n\tentry = pte_to_swp_entry(vmf->orig_pte);\n\tif (unlikely(non_swap_entry(entry))) {\n\t\tif (is_migration_entry(entry)) {\n\t\t\tmigration_entry_wait(vma->vm_mm, vmf->pmd,\n\t\t\t\t\t     vmf->address);\n\t\t} else if (is_device_private_entry(entry)) {\n\t\t\t/*\n\t\t\t * For un-addressable device memory we call the pgmap\n\t\t\t * fault handler callback. The callback must migrate\n\t\t\t * the page back to some CPU accessible page.\n\t\t\t */\n\t\t\tret = device_private_entry_fault(vma, vmf->address, entry,\n\t\t\t\t\t\t vmf->flags, vmf->pmd);\n\t\t} else if (is_hwpoison_entry(entry)) {\n\t\t\tret = VM_FAULT_HWPOISON;\n\t\t} else {\n\t\t\tprint_bad_pte(vma, vmf->address, vmf->orig_pte, NULL);\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\t}\n\t\tgoto out;\n\t}\n\n\n\tdelayacct_set_flag(DELAYACCT_PF_SWAPIN);\n\tpage = lookup_swap_cache(entry, vma, vmf->address);\n\tswapcache = page;\n\n\tif (!page) {\n\t\tstruct swap_info_struct *si = swp_swap_info(entry);\n\n\t\tif (si->flags & SWP_SYNCHRONOUS_IO &&\n\t\t\t\t__swap_count(si, entry) == 1) {\n\t\t\t/* skip swapcache */\n\t\t\tpage = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma,\n\t\t\t\t\t\t\tvmf->address);\n\t\t\tif (page) {\n\t\t\t\t__SetPageLocked(page);\n\t\t\t\t__SetPageSwapBacked(page);\n\t\t\t\tset_page_private(page, entry.val);\n\t\t\t\tlru_cache_add_anon(page);\n\t\t\t\tswap_readpage(page, true);\n\t\t\t}\n\t\t} else {\n\t\t\tpage = swapin_readahead(entry, GFP_HIGHUSER_MOVABLE,\n\t\t\t\t\t\tvmf);\n\t\t\tswapcache = page;\n\t\t}\n\n\t\tif (!page) {\n\t\t\t/*\n\t\t\t * Back out if somebody else faulted in this pte\n\t\t\t * while we released the pte lock.\n\t\t\t */\n\t\t\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd,\n\t\t\t\t\tvmf->address, &vmf->ptl);\n\t\t\tif (likely(pte_same(*vmf->pte, vmf->orig_pte)))\n\t\t\t\tret = VM_FAULT_OOM;\n\t\t\tdelayacct_clear_flag(DELAYACCT_PF_SWAPIN);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\t/* Had to read the page from swap area: Major fault */\n\t\tret = VM_FAULT_MAJOR;\n\t\tcount_vm_event(PGMAJFAULT);\n\t\tcount_memcg_event_mm(vma->vm_mm, PGMAJFAULT);\n\t} else if (PageHWPoison(page)) {\n\t\t/*\n\t\t * hwpoisoned dirty swapcache pages are kept for killing\n\t\t * owner processes (which may be unknown at hwpoison time)\n\t\t */\n\t\tret = VM_FAULT_HWPOISON;\n\t\tdelayacct_clear_flag(DELAYACCT_PF_SWAPIN);\n\t\tgoto out_release;\n\t}\n\n\tlocked = lock_page_or_retry(page, vma->vm_mm, vmf->flags);\n\n\tdelayacct_clear_flag(DELAYACCT_PF_SWAPIN);\n\tif (!locked) {\n\t\tret |= VM_FAULT_RETRY;\n\t\tgoto out_release;\n\t}\n\n\t/*\n\t * Make sure try_to_free_swap or reuse_swap_page or swapoff did not\n\t * release the swapcache from under us.  The page pin, and pte_same\n\t * test below, are not enough to exclude that.  Even if it is still\n\t * swapcache, we need to check that the page's swap has not changed.\n\t */\n\tif (unlikely((!PageSwapCache(page) ||\n\t\t\tpage_private(page) != entry.val)) && swapcache)\n\t\tgoto out_page;\n\n\tpage = ksm_might_need_to_copy(page, vma, vmf->address);\n\tif (unlikely(!page)) {\n\t\tret = VM_FAULT_OOM;\n\t\tpage = swapcache;\n\t\tgoto out_page;\n\t}\n\n\tif (mem_cgroup_try_charge_delay(page, vma->vm_mm, GFP_KERNEL,\n\t\t\t\t\t&memcg, false)) {\n\t\tret = VM_FAULT_OOM;\n\t\tgoto out_page;\n\t}\n\n\t/*\n\t * Back out if somebody else already faulted in this pte.\n\t */\n\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd, vmf->address,\n\t\t\t&vmf->ptl);\n\tif (unlikely(!pte_same(*vmf->pte, vmf->orig_pte)))\n\t\tgoto out_nomap;\n\n\tif (unlikely(!PageUptodate(page))) {\n\t\tret = VM_FAULT_SIGBUS;\n\t\tgoto out_nomap;\n\t}\n\n\t/*\n\t * The page isn't present yet, go ahead with the fault.\n\t *\n\t * Be careful about the sequence of operations here.\n\t * To get its accounting right, reuse_swap_page() must be called\n\t * while the page is counted on swap but not yet in mapcount i.e.\n\t * before page_add_anon_rmap() and swap_free(); try_to_free_swap()\n\t * must be called after the swap_free(), or it will never succeed.\n\t */\n\n\tinc_mm_counter_fast(vma->vm_mm, MM_ANONPAGES);\n\tdec_mm_counter_fast(vma->vm_mm, MM_SWAPENTS);\n\tpte = mk_pte(page, vma->vm_page_prot);\n\tif ((vmf->flags & FAULT_FLAG_WRITE) && reuse_swap_page(page, NULL)) {\n\t\tpte = maybe_mkwrite(pte_mkdirty(pte), vma);\n\t\tvmf->flags &= ~FAULT_FLAG_WRITE;\n\t\tret |= VM_FAULT_WRITE;\n\t\texclusive = RMAP_EXCLUSIVE;\n\t}\n\tflush_icache_page(vma, page);\n\tif (pte_swp_soft_dirty(vmf->orig_pte))\n\t\tpte = pte_mksoft_dirty(pte);\n\tset_pte_at(vma->vm_mm, vmf->address, vmf->pte, pte);\n\tarch_do_swap_page(vma->vm_mm, vma, vmf->address, pte, vmf->orig_pte);\n\tvmf->orig_pte = pte;\n\n\t/* ksm created a completely new copy */\n\tif (unlikely(page != swapcache && swapcache)) {\n\t\tpage_add_new_anon_rmap(page, vma, vmf->address, false);\n\t\tmem_cgroup_commit_charge(page, memcg, false, false);\n\t\tlru_cache_add_active_or_unevictable(page, vma);\n\t} else {\n\t\tdo_page_add_anon_rmap(page, vma, vmf->address, exclusive);\n\t\tmem_cgroup_commit_charge(page, memcg, true, false);\n\t\tactivate_page(page);\n\t}\n\n\tswap_free(entry);\n\tif (mem_cgroup_swap_full(page) ||\n\t    (vma->vm_flags & VM_LOCKED) || PageMlocked(page))\n\t\ttry_to_free_swap(page);\n\tunlock_page(page);\n\tif (page != swapcache && swapcache) {\n\t\t/*\n\t\t * Hold the lock to avoid the swap entry to be reused\n\t\t * until we take the PT lock for the pte_same() check\n\t\t * (to avoid false positives from pte_same). For\n\t\t * further safety release the lock after the swap_free\n\t\t * so that the swap count won't change under a\n\t\t * parallel locked swapcache.\n\t\t */\n\t\tunlock_page(swapcache);\n\t\tput_page(swapcache);\n\t}\n\n\tif (vmf->flags & FAULT_FLAG_WRITE) {\n\t\tret |= do_wp_page(vmf);\n\t\tif (ret & VM_FAULT_ERROR)\n\t\t\tret &= VM_FAULT_ERROR;\n\t\tgoto out;\n\t}\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\nunlock:\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\nout:\n\treturn ret;\nout_nomap:\n\tmem_cgroup_cancel_charge(page, memcg, false);\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\nout_page:\n\tunlock_page(page);\nout_release:\n\tput_page(page);\n\tif (page != swapcache && swapcache) {\n\t\tunlock_page(swapcache);\n\t\tput_page(swapcache);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "unmap_mapping_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "2630-2645",
    "snippet": "void unmap_mapping_range(struct address_space *mapping,\n\t\tloff_t const holebegin, loff_t const holelen, int even_cows)\n{\n\tpgoff_t hba = holebegin >> PAGE_SHIFT;\n\tpgoff_t hlen = (holelen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\t/* Check for overflow. */\n\tif (sizeof(holelen) > sizeof(hlen)) {\n\t\tlong long holeend =\n\t\t\t(holebegin + holelen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tif (holeend & ~(long long)ULONG_MAX)\n\t\t\thlen = ULONG_MAX - hba + 1;\n\t}\n\n\tunmap_mapping_pages(mapping, hba, hlen, even_cows);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unmap_mapping_pages",
          "args": [
            "mapping",
            "hba",
            "hlen",
            "even_cows"
          ],
          "line": 2644
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mapping_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2596-2611",
          "snippet": "void unmap_mapping_pages(struct address_space *mapping, pgoff_t start,\n\t\tpgoff_t nr, bool even_cows)\n{\n\tstruct zap_details details = { };\n\n\tdetails.check_mapping = even_cows ? NULL : mapping;\n\tdetails.first_index = start;\n\tdetails.last_index = start + nr - 1;\n\tif (details.last_index < details.first_index)\n\t\tdetails.last_index = ULONG_MAX;\n\n\ti_mmap_lock_write(mapping);\n\tif (unlikely(!RB_EMPTY_ROOT(&mapping->i_mmap.rb_root)))\n\t\tunmap_mapping_range_tree(&mapping->i_mmap, &details);\n\ti_mmap_unlock_write(mapping);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid unmap_mapping_pages(struct address_space *mapping, pgoff_t start,\n\t\tpgoff_t nr, bool even_cows)\n{\n\tstruct zap_details details = { };\n\n\tdetails.check_mapping = even_cows ? NULL : mapping;\n\tdetails.first_index = start;\n\tdetails.last_index = start + nr - 1;\n\tif (details.last_index < details.first_index)\n\t\tdetails.last_index = ULONG_MAX;\n\n\ti_mmap_lock_write(mapping);\n\tif (unlikely(!RB_EMPTY_ROOT(&mapping->i_mmap.rb_root)))\n\t\tunmap_mapping_range_tree(&mapping->i_mmap, &details);\n\ti_mmap_unlock_write(mapping);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid unmap_mapping_range(struct address_space *mapping,\n\t\tloff_t const holebegin, loff_t const holelen, int even_cows)\n{\n\tpgoff_t hba = holebegin >> PAGE_SHIFT;\n\tpgoff_t hlen = (holelen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\t/* Check for overflow. */\n\tif (sizeof(holelen) > sizeof(hlen)) {\n\t\tlong long holeend =\n\t\t\t(holebegin + holelen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tif (holeend & ~(long long)ULONG_MAX)\n\t\t\thlen = ULONG_MAX - hba + 1;\n\t}\n\n\tunmap_mapping_pages(mapping, hba, hlen, even_cows);\n}"
  },
  {
    "function_name": "unmap_mapping_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "2596-2611",
    "snippet": "void unmap_mapping_pages(struct address_space *mapping, pgoff_t start,\n\t\tpgoff_t nr, bool even_cows)\n{\n\tstruct zap_details details = { };\n\n\tdetails.check_mapping = even_cows ? NULL : mapping;\n\tdetails.first_index = start;\n\tdetails.last_index = start + nr - 1;\n\tif (details.last_index < details.first_index)\n\t\tdetails.last_index = ULONG_MAX;\n\n\ti_mmap_lock_write(mapping);\n\tif (unlikely(!RB_EMPTY_ROOT(&mapping->i_mmap.rb_root)))\n\t\tunmap_mapping_range_tree(&mapping->i_mmap, &details);\n\ti_mmap_unlock_write(mapping);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_mmap_unlock_write",
          "args": [
            "mapping"
          ],
          "line": 2610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mapping_range_tree",
          "args": [
            "&mapping->i_mmap",
            "&details"
          ],
          "line": 2609
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mapping_range_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2559-2582",
          "snippet": "static inline void unmap_mapping_range_tree(struct rb_root_cached *root,\n\t\t\t\t\t    struct zap_details *details)\n{\n\tstruct vm_area_struct *vma;\n\tpgoff_t vba, vea, zba, zea;\n\n\tvma_interval_tree_foreach(vma, root,\n\t\t\tdetails->first_index, details->last_index) {\n\n\t\tvba = vma->vm_pgoff;\n\t\tvea = vba + vma_pages(vma) - 1;\n\t\tzba = details->first_index;\n\t\tif (zba < vba)\n\t\t\tzba = vba;\n\t\tzea = details->last_index;\n\t\tif (zea > vea)\n\t\t\tzea = vea;\n\n\t\tunmap_mapping_range_vma(vma,\n\t\t\t((zba - vba) << PAGE_SHIFT) + vma->vm_start,\n\t\t\t((zea - vba + 1) << PAGE_SHIFT) + vma->vm_start,\n\t\t\t\tdetails);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void unmap_mapping_range_tree(struct rb_root_cached *root,\n\t\t\t\t\t    struct zap_details *details)\n{\n\tstruct vm_area_struct *vma;\n\tpgoff_t vba, vea, zba, zea;\n\n\tvma_interval_tree_foreach(vma, root,\n\t\t\tdetails->first_index, details->last_index) {\n\n\t\tvba = vma->vm_pgoff;\n\t\tvea = vba + vma_pages(vma) - 1;\n\t\tzba = details->first_index;\n\t\tif (zba < vba)\n\t\t\tzba = vba;\n\t\tzea = details->last_index;\n\t\tif (zea > vea)\n\t\t\tzea = vea;\n\n\t\tunmap_mapping_range_vma(vma,\n\t\t\t((zba - vba) << PAGE_SHIFT) + vma->vm_start,\n\t\t\t((zea - vba + 1) << PAGE_SHIFT) + vma->vm_start,\n\t\t\t\tdetails);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!RB_EMPTY_ROOT(&mapping->i_mmap.rb_root)"
          ],
          "line": 2608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&mapping->i_mmap.rb_root"
          ],
          "line": 2608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_mmap_lock_write",
          "args": [
            "mapping"
          ],
          "line": 2607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid unmap_mapping_pages(struct address_space *mapping, pgoff_t start,\n\t\tpgoff_t nr, bool even_cows)\n{\n\tstruct zap_details details = { };\n\n\tdetails.check_mapping = even_cows ? NULL : mapping;\n\tdetails.first_index = start;\n\tdetails.last_index = start + nr - 1;\n\tif (details.last_index < details.first_index)\n\t\tdetails.last_index = ULONG_MAX;\n\n\ti_mmap_lock_write(mapping);\n\tif (unlikely(!RB_EMPTY_ROOT(&mapping->i_mmap.rb_root)))\n\t\tunmap_mapping_range_tree(&mapping->i_mmap, &details);\n\ti_mmap_unlock_write(mapping);\n}"
  },
  {
    "function_name": "unmap_mapping_range_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "2559-2582",
    "snippet": "static inline void unmap_mapping_range_tree(struct rb_root_cached *root,\n\t\t\t\t\t    struct zap_details *details)\n{\n\tstruct vm_area_struct *vma;\n\tpgoff_t vba, vea, zba, zea;\n\n\tvma_interval_tree_foreach(vma, root,\n\t\t\tdetails->first_index, details->last_index) {\n\n\t\tvba = vma->vm_pgoff;\n\t\tvea = vba + vma_pages(vma) - 1;\n\t\tzba = details->first_index;\n\t\tif (zba < vba)\n\t\t\tzba = vba;\n\t\tzea = details->last_index;\n\t\tif (zea > vea)\n\t\t\tzea = vea;\n\n\t\tunmap_mapping_range_vma(vma,\n\t\t\t((zba - vba) << PAGE_SHIFT) + vma->vm_start,\n\t\t\t((zea - vba + 1) << PAGE_SHIFT) + vma->vm_start,\n\t\t\t\tdetails);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unmap_mapping_range_vma",
          "args": [
            "vma",
            "((zba - vba) << PAGE_SHIFT) + vma->vm_start",
            "((zea - vba + 1) << PAGE_SHIFT) + vma->vm_start",
            "details"
          ],
          "line": 2577
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mapping_range_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2552-2557",
          "snippet": "static void unmap_mapping_range_vma(struct vm_area_struct *vma,\n\t\tunsigned long start_addr, unsigned long end_addr,\n\t\tstruct zap_details *details)\n{\n\tzap_page_range_single(vma, start_addr, end_addr - start_addr, details);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void unmap_mapping_range_vma(struct vm_area_struct *vma,\n\t\tunsigned long start_addr, unsigned long end_addr,\n\t\tstruct zap_details *details)\n{\n\tzap_page_range_single(vma, start_addr, end_addr - start_addr, details);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_pages",
          "args": [
            "vma"
          ],
          "line": 2569
        },
        "resolved": true,
        "details": {
          "function_name": "munlock_vma_pages_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "292-295",
          "snippet": "static inline void munlock_vma_pages_all(struct vm_area_struct *vma)\n{\n\tmunlock_vma_pages_range(vma, vma->vm_start, vma->vm_end);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void munlock_vma_pages_all(struct vm_area_struct *vma)\n{\n\tmunlock_vma_pages_range(vma, vma->vm_start, vma->vm_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_interval_tree_foreach",
          "args": [
            "vma",
            "root",
            "details->first_index",
            "details->last_index"
          ],
          "line": 2565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void unmap_mapping_range_tree(struct rb_root_cached *root,\n\t\t\t\t\t    struct zap_details *details)\n{\n\tstruct vm_area_struct *vma;\n\tpgoff_t vba, vea, zba, zea;\n\n\tvma_interval_tree_foreach(vma, root,\n\t\t\tdetails->first_index, details->last_index) {\n\n\t\tvba = vma->vm_pgoff;\n\t\tvea = vba + vma_pages(vma) - 1;\n\t\tzba = details->first_index;\n\t\tif (zba < vba)\n\t\t\tzba = vba;\n\t\tzea = details->last_index;\n\t\tif (zea > vea)\n\t\t\tzea = vea;\n\n\t\tunmap_mapping_range_vma(vma,\n\t\t\t((zba - vba) << PAGE_SHIFT) + vma->vm_start,\n\t\t\t((zea - vba + 1) << PAGE_SHIFT) + vma->vm_start,\n\t\t\t\tdetails);\n\t}\n}"
  },
  {
    "function_name": "unmap_mapping_range_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "2552-2557",
    "snippet": "static void unmap_mapping_range_vma(struct vm_area_struct *vma,\n\t\tunsigned long start_addr, unsigned long end_addr,\n\t\tstruct zap_details *details)\n{\n\tzap_page_range_single(vma, start_addr, end_addr - start_addr, details);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zap_page_range_single",
          "args": [
            "vma",
            "start_addr",
            "end_addr - start_addr",
            "details"
          ],
          "line": 2556
        },
        "resolved": true,
        "details": {
          "function_name": "zap_page_range_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1377-1391",
          "snippet": "static void zap_page_range_single(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned long size, struct zap_details *details)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mmu_gather tlb;\n\tunsigned long end = address + size;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, address, end);\n\tupdate_hiwater_rss(mm);\n\tmmu_notifier_invalidate_range_start(mm, address, end);\n\tunmap_single_vma(&tlb, vma, address, end, details);\n\tmmu_notifier_invalidate_range_end(mm, address, end);\n\ttlb_finish_mmu(&tlb, address, end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void zap_page_range_single(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned long size, struct zap_details *details)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mmu_gather tlb;\n\tunsigned long end = address + size;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, address, end);\n\tupdate_hiwater_rss(mm);\n\tmmu_notifier_invalidate_range_start(mm, address, end);\n\tunmap_single_vma(&tlb, vma, address, end, details);\n\tmmu_notifier_invalidate_range_end(mm, address, end);\n\ttlb_finish_mmu(&tlb, address, end);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void unmap_mapping_range_vma(struct vm_area_struct *vma,\n\t\tunsigned long start_addr, unsigned long end_addr,\n\t\tstruct zap_details *details)\n{\n\tzap_page_range_single(vma, start_addr, end_addr - start_addr, details);\n}"
  },
  {
    "function_name": "do_wp_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "2480-2550",
    "snippet": "static vm_fault_t do_wp_page(struct vm_fault *vmf)\n\t__releases(vmf->ptl)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\n\tvmf->page = vm_normal_page(vma, vmf->address, vmf->orig_pte);\n\tif (!vmf->page) {\n\t\t/*\n\t\t * VM_MIXEDMAP !pfn_valid() case, or VM_SOFTDIRTY clear on a\n\t\t * VM_PFNMAP VMA.\n\t\t *\n\t\t * We should not cow pages in a shared writeable mapping.\n\t\t * Just mark the pages writable and/or call ops->pfn_mkwrite.\n\t\t */\n\t\tif ((vma->vm_flags & (VM_WRITE|VM_SHARED)) ==\n\t\t\t\t     (VM_WRITE|VM_SHARED))\n\t\t\treturn wp_pfn_shared(vmf);\n\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\treturn wp_page_copy(vmf);\n\t}\n\n\t/*\n\t * Take out anonymous pages first, anonymous shared vmas are\n\t * not dirty accountable.\n\t */\n\tif (PageAnon(vmf->page) && !PageKsm(vmf->page)) {\n\t\tint total_map_swapcount;\n\t\tif (!trylock_page(vmf->page)) {\n\t\t\tget_page(vmf->page);\n\t\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\t\tlock_page(vmf->page);\n\t\t\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd,\n\t\t\t\t\tvmf->address, &vmf->ptl);\n\t\t\tif (!pte_same(*vmf->pte, vmf->orig_pte)) {\n\t\t\t\tunlock_page(vmf->page);\n\t\t\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\t\t\tput_page(vmf->page);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tput_page(vmf->page);\n\t\t}\n\t\tif (reuse_swap_page(vmf->page, &total_map_swapcount)) {\n\t\t\tif (total_map_swapcount == 1) {\n\t\t\t\t/*\n\t\t\t\t * The page is all ours. Move it to\n\t\t\t\t * our anon_vma so the rmap code will\n\t\t\t\t * not search our parent or siblings.\n\t\t\t\t * Protected against the rmap code by\n\t\t\t\t * the page lock.\n\t\t\t\t */\n\t\t\t\tpage_move_anon_rmap(vmf->page, vma);\n\t\t\t}\n\t\t\tunlock_page(vmf->page);\n\t\t\twp_page_reuse(vmf);\n\t\t\treturn VM_FAULT_WRITE;\n\t\t}\n\t\tunlock_page(vmf->page);\n\t} else if (unlikely((vma->vm_flags & (VM_WRITE|VM_SHARED)) ==\n\t\t\t\t\t(VM_WRITE|VM_SHARED))) {\n\t\treturn wp_page_shared(vmf);\n\t}\n\n\t/*\n\t * Ok, we need to copy. Oh, well..\n\t */\n\tget_page(vmf->page);\n\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\treturn wp_page_copy(vmf);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wp_page_copy",
          "args": [
            "vmf"
          ],
          "line": 2549
        },
        "resolved": true,
        "details": {
          "function_name": "wp_page_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2242-2373",
          "snippet": "static vm_fault_t wp_page_copy(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *old_page = vmf->page;\n\tstruct page *new_page = NULL;\n\tpte_t entry;\n\tint page_copied = 0;\n\tconst unsigned long mmun_start = vmf->address & PAGE_MASK;\n\tconst unsigned long mmun_end = mmun_start + PAGE_SIZE;\n\tstruct mem_cgroup *memcg;\n\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto oom;\n\n\tif (is_zero_pfn(pte_pfn(vmf->orig_pte))) {\n\t\tnew_page = alloc_zeroed_user_highpage_movable(vma,\n\t\t\t\t\t\t\t      vmf->address);\n\t\tif (!new_page)\n\t\t\tgoto oom;\n\t} else {\n\t\tnew_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma,\n\t\t\t\tvmf->address);\n\t\tif (!new_page)\n\t\t\tgoto oom;\n\t\tcow_user_page(new_page, old_page, vmf->address, vma);\n\t}\n\n\tif (mem_cgroup_try_charge_delay(new_page, mm, GFP_KERNEL, &memcg, false))\n\t\tgoto oom_free_new;\n\n\t__SetPageUptodate(new_page);\n\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\n\t/*\n\t * Re-check the pte - we dropped the lock\n\t */\n\tvmf->pte = pte_offset_map_lock(mm, vmf->pmd, vmf->address, &vmf->ptl);\n\tif (likely(pte_same(*vmf->pte, vmf->orig_pte))) {\n\t\tif (old_page) {\n\t\t\tif (!PageAnon(old_page)) {\n\t\t\t\tdec_mm_counter_fast(mm,\n\t\t\t\t\t\tmm_counter_file(old_page));\n\t\t\t\tinc_mm_counter_fast(mm, MM_ANONPAGES);\n\t\t\t}\n\t\t} else {\n\t\t\tinc_mm_counter_fast(mm, MM_ANONPAGES);\n\t\t}\n\t\tflush_cache_page(vma, vmf->address, pte_pfn(vmf->orig_pte));\n\t\tentry = mk_pte(new_page, vma->vm_page_prot);\n\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t\t/*\n\t\t * Clear the pte entry and flush it first, before updating the\n\t\t * pte with the new entry. This will avoid a race condition\n\t\t * seen in the presence of one thread doing SMC and another\n\t\t * thread doing COW.\n\t\t */\n\t\tptep_clear_flush_notify(vma, vmf->address, vmf->pte);\n\t\tpage_add_new_anon_rmap(new_page, vma, vmf->address, false);\n\t\tmem_cgroup_commit_charge(new_page, memcg, false, false);\n\t\tlru_cache_add_active_or_unevictable(new_page, vma);\n\t\t/*\n\t\t * We call the notify macro here because, when using secondary\n\t\t * mmu page tables (such as kvm shadow page tables), we want the\n\t\t * new page to be mapped directly into the secondary page table.\n\t\t */\n\t\tset_pte_at_notify(mm, vmf->address, vmf->pte, entry);\n\t\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\n\t\tif (old_page) {\n\t\t\t/*\n\t\t\t * Only after switching the pte to the new page may\n\t\t\t * we remove the mapcount here. Otherwise another\n\t\t\t * process may come and find the rmap count decremented\n\t\t\t * before the pte is switched to the new page, and\n\t\t\t * \"reuse\" the old page writing into it while our pte\n\t\t\t * here still points into it and can be read by other\n\t\t\t * threads.\n\t\t\t *\n\t\t\t * The critical issue is to order this\n\t\t\t * page_remove_rmap with the ptp_clear_flush above.\n\t\t\t * Those stores are ordered by (if nothing else,)\n\t\t\t * the barrier present in the atomic_add_negative\n\t\t\t * in page_remove_rmap.\n\t\t\t *\n\t\t\t * Then the TLB flush in ptep_clear_flush ensures that\n\t\t\t * no process can access the old page before the\n\t\t\t * decremented mapcount is visible. And the old page\n\t\t\t * cannot be reused until after the decremented\n\t\t\t * mapcount is visible. So transitively, TLBs to\n\t\t\t * old page will be flushed before it can be reused.\n\t\t\t */\n\t\t\tpage_remove_rmap(old_page, false);\n\t\t}\n\n\t\t/* Free the old page.. */\n\t\tnew_page = old_page;\n\t\tpage_copied = 1;\n\t} else {\n\t\tmem_cgroup_cancel_charge(new_page, memcg, false);\n\t}\n\n\tif (new_page)\n\t\tput_page(new_page);\n\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback as\n\t * the above ptep_clear_flush_notify() did already call it.\n\t */\n\tmmu_notifier_invalidate_range_only_end(mm, mmun_start, mmun_end);\n\tif (old_page) {\n\t\t/*\n\t\t * Don't let another task, with possibly unlocked vma,\n\t\t * keep the mlocked page.\n\t\t */\n\t\tif (page_copied && (vma->vm_flags & VM_LOCKED)) {\n\t\t\tlock_page(old_page);\t/* LRU manipulation */\n\t\t\tif (PageMlocked(old_page))\n\t\t\t\tmunlock_vma_page(old_page);\n\t\t\tunlock_page(old_page);\n\t\t}\n\t\tput_page(old_page);\n\t}\n\treturn page_copied ? VM_FAULT_WRITE : 0;\noom_free_new:\n\tput_page(new_page);\noom:\n\tif (old_page)\n\t\tput_page(old_page);\n\treturn VM_FAULT_OOM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t wp_page_copy(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *old_page = vmf->page;\n\tstruct page *new_page = NULL;\n\tpte_t entry;\n\tint page_copied = 0;\n\tconst unsigned long mmun_start = vmf->address & PAGE_MASK;\n\tconst unsigned long mmun_end = mmun_start + PAGE_SIZE;\n\tstruct mem_cgroup *memcg;\n\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto oom;\n\n\tif (is_zero_pfn(pte_pfn(vmf->orig_pte))) {\n\t\tnew_page = alloc_zeroed_user_highpage_movable(vma,\n\t\t\t\t\t\t\t      vmf->address);\n\t\tif (!new_page)\n\t\t\tgoto oom;\n\t} else {\n\t\tnew_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma,\n\t\t\t\tvmf->address);\n\t\tif (!new_page)\n\t\t\tgoto oom;\n\t\tcow_user_page(new_page, old_page, vmf->address, vma);\n\t}\n\n\tif (mem_cgroup_try_charge_delay(new_page, mm, GFP_KERNEL, &memcg, false))\n\t\tgoto oom_free_new;\n\n\t__SetPageUptodate(new_page);\n\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\n\t/*\n\t * Re-check the pte - we dropped the lock\n\t */\n\tvmf->pte = pte_offset_map_lock(mm, vmf->pmd, vmf->address, &vmf->ptl);\n\tif (likely(pte_same(*vmf->pte, vmf->orig_pte))) {\n\t\tif (old_page) {\n\t\t\tif (!PageAnon(old_page)) {\n\t\t\t\tdec_mm_counter_fast(mm,\n\t\t\t\t\t\tmm_counter_file(old_page));\n\t\t\t\tinc_mm_counter_fast(mm, MM_ANONPAGES);\n\t\t\t}\n\t\t} else {\n\t\t\tinc_mm_counter_fast(mm, MM_ANONPAGES);\n\t\t}\n\t\tflush_cache_page(vma, vmf->address, pte_pfn(vmf->orig_pte));\n\t\tentry = mk_pte(new_page, vma->vm_page_prot);\n\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t\t/*\n\t\t * Clear the pte entry and flush it first, before updating the\n\t\t * pte with the new entry. This will avoid a race condition\n\t\t * seen in the presence of one thread doing SMC and another\n\t\t * thread doing COW.\n\t\t */\n\t\tptep_clear_flush_notify(vma, vmf->address, vmf->pte);\n\t\tpage_add_new_anon_rmap(new_page, vma, vmf->address, false);\n\t\tmem_cgroup_commit_charge(new_page, memcg, false, false);\n\t\tlru_cache_add_active_or_unevictable(new_page, vma);\n\t\t/*\n\t\t * We call the notify macro here because, when using secondary\n\t\t * mmu page tables (such as kvm shadow page tables), we want the\n\t\t * new page to be mapped directly into the secondary page table.\n\t\t */\n\t\tset_pte_at_notify(mm, vmf->address, vmf->pte, entry);\n\t\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\n\t\tif (old_page) {\n\t\t\t/*\n\t\t\t * Only after switching the pte to the new page may\n\t\t\t * we remove the mapcount here. Otherwise another\n\t\t\t * process may come and find the rmap count decremented\n\t\t\t * before the pte is switched to the new page, and\n\t\t\t * \"reuse\" the old page writing into it while our pte\n\t\t\t * here still points into it and can be read by other\n\t\t\t * threads.\n\t\t\t *\n\t\t\t * The critical issue is to order this\n\t\t\t * page_remove_rmap with the ptp_clear_flush above.\n\t\t\t * Those stores are ordered by (if nothing else,)\n\t\t\t * the barrier present in the atomic_add_negative\n\t\t\t * in page_remove_rmap.\n\t\t\t *\n\t\t\t * Then the TLB flush in ptep_clear_flush ensures that\n\t\t\t * no process can access the old page before the\n\t\t\t * decremented mapcount is visible. And the old page\n\t\t\t * cannot be reused until after the decremented\n\t\t\t * mapcount is visible. So transitively, TLBs to\n\t\t\t * old page will be flushed before it can be reused.\n\t\t\t */\n\t\t\tpage_remove_rmap(old_page, false);\n\t\t}\n\n\t\t/* Free the old page.. */\n\t\tnew_page = old_page;\n\t\tpage_copied = 1;\n\t} else {\n\t\tmem_cgroup_cancel_charge(new_page, memcg, false);\n\t}\n\n\tif (new_page)\n\t\tput_page(new_page);\n\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback as\n\t * the above ptep_clear_flush_notify() did already call it.\n\t */\n\tmmu_notifier_invalidate_range_only_end(mm, mmun_start, mmun_end);\n\tif (old_page) {\n\t\t/*\n\t\t * Don't let another task, with possibly unlocked vma,\n\t\t * keep the mlocked page.\n\t\t */\n\t\tif (page_copied && (vma->vm_flags & VM_LOCKED)) {\n\t\t\tlock_page(old_page);\t/* LRU manipulation */\n\t\t\tif (PageMlocked(old_page))\n\t\t\t\tmunlock_vma_page(old_page);\n\t\t\tunlock_page(old_page);\n\t\t}\n\t\tput_page(old_page);\n\t}\n\treturn page_copied ? VM_FAULT_WRITE : 0;\noom_free_new:\n\tput_page(new_page);\noom:\n\tif (old_page)\n\t\tput_page(old_page);\n\treturn VM_FAULT_OOM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "vmf->pte",
            "vmf->ptl"
          ],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "vmf->page"
          ],
          "line": 2546
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wp_page_shared",
          "args": [
            "vmf"
          ],
          "line": 2540
        },
        "resolved": true,
        "details": {
          "function_name": "wp_page_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2429-2460",
          "snippet": "static vm_fault_t wp_page_shared(struct vm_fault *vmf)\n\t__releases(vmf->ptl)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\n\tget_page(vmf->page);\n\n\tif (vma->vm_ops && vma->vm_ops->page_mkwrite) {\n\t\tvm_fault_t tmp;\n\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\ttmp = do_page_mkwrite(vmf);\n\t\tif (unlikely(!tmp || (tmp &\n\t\t\t\t      (VM_FAULT_ERROR | VM_FAULT_NOPAGE)))) {\n\t\t\tput_page(vmf->page);\n\t\t\treturn tmp;\n\t\t}\n\t\ttmp = finish_mkwrite_fault(vmf);\n\t\tif (unlikely(tmp & (VM_FAULT_ERROR | VM_FAULT_NOPAGE))) {\n\t\t\tunlock_page(vmf->page);\n\t\t\tput_page(vmf->page);\n\t\t\treturn tmp;\n\t\t}\n\t} else {\n\t\twp_page_reuse(vmf);\n\t\tlock_page(vmf->page);\n\t}\n\tfault_dirty_shared_page(vma, vmf->page);\n\tput_page(vmf->page);\n\n\treturn VM_FAULT_WRITE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t wp_page_shared(struct vm_fault *vmf)\n\t__releases(vmf->ptl)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\n\tget_page(vmf->page);\n\n\tif (vma->vm_ops && vma->vm_ops->page_mkwrite) {\n\t\tvm_fault_t tmp;\n\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\ttmp = do_page_mkwrite(vmf);\n\t\tif (unlikely(!tmp || (tmp &\n\t\t\t\t      (VM_FAULT_ERROR | VM_FAULT_NOPAGE)))) {\n\t\t\tput_page(vmf->page);\n\t\t\treturn tmp;\n\t\t}\n\t\ttmp = finish_mkwrite_fault(vmf);\n\t\tif (unlikely(tmp & (VM_FAULT_ERROR | VM_FAULT_NOPAGE))) {\n\t\t\tunlock_page(vmf->page);\n\t\t\tput_page(vmf->page);\n\t\t\treturn tmp;\n\t\t}\n\t} else {\n\t\twp_page_reuse(vmf);\n\t\tlock_page(vmf->page);\n\t}\n\tfault_dirty_shared_page(vma, vmf->page);\n\tput_page(vmf->page);\n\n\treturn VM_FAULT_WRITE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(vma->vm_flags & (VM_WRITE|VM_SHARED)) ==\n\t\t\t\t\t(VM_WRITE|VM_SHARED)"
          ],
          "line": 2538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "vmf->page"
          ],
          "line": 2537
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wp_page_reuse",
          "args": [
            "vmf"
          ],
          "line": 2534
        },
        "resolved": true,
        "details": {
          "function_name": "wp_page_reuse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2204-2224",
          "snippet": "static inline void wp_page_reuse(struct vm_fault *vmf)\n\t__releases(vmf->ptl)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page = vmf->page;\n\tpte_t entry;\n\t/*\n\t * Clear the pages cpupid information as the existing\n\t * information potentially belongs to a now completely\n\t * unrelated process.\n\t */\n\tif (page)\n\t\tpage_cpupid_xchg_last(page, (1 << LAST_CPUPID_SHIFT) - 1);\n\n\tflush_cache_page(vma, vmf->address, pte_pfn(vmf->orig_pte));\n\tentry = pte_mkyoung(vmf->orig_pte);\n\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\tif (ptep_set_access_flags(vma, vmf->address, vmf->pte, entry, 1))\n\t\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void wp_page_reuse(struct vm_fault *vmf)\n\t__releases(vmf->ptl)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page = vmf->page;\n\tpte_t entry;\n\t/*\n\t * Clear the pages cpupid information as the existing\n\t * information potentially belongs to a now completely\n\t * unrelated process.\n\t */\n\tif (page)\n\t\tpage_cpupid_xchg_last(page, (1 << LAST_CPUPID_SHIFT) - 1);\n\n\tflush_cache_page(vma, vmf->address, pte_pfn(vmf->orig_pte));\n\tentry = pte_mkyoung(vmf->orig_pte);\n\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\tif (ptep_set_access_flags(vma, vmf->address, vmf->pte, entry, 1))\n\t\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_move_anon_rmap",
          "args": [
            "vmf->page",
            "vma"
          ],
          "line": 2531
        },
        "resolved": true,
        "details": {
          "function_name": "page_move_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1000-1016",
          "snippet": "void page_move_anon_rmap(struct page *page, struct vm_area_struct *vma)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\n\tpage = compound_head(page);\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_VMA(!anon_vma, vma);\n\n\tanon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;\n\t/*\n\t * Ensure that anon_vma and the PAGE_MAPPING_ANON bit are written\n\t * simultaneously, so a concurrent reader (eg page_referenced()'s\n\t * PageAnon()) will not see one without the other.\n\t */\n\tWRITE_ONCE(page->mapping, (struct address_space *) anon_vma);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_move_anon_rmap(struct page *page, struct vm_area_struct *vma)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\n\tpage = compound_head(page);\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_VMA(!anon_vma, vma);\n\n\tanon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;\n\t/*\n\t * Ensure that anon_vma and the PAGE_MAPPING_ANON bit are written\n\t * simultaneously, so a concurrent reader (eg page_referenced()'s\n\t * PageAnon()) will not see one without the other.\n\t */\n\tWRITE_ONCE(page->mapping, (struct address_space *) anon_vma);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reuse_swap_page",
          "args": [
            "vmf->page",
            "&total_map_swapcount"
          ],
          "line": 2522
        },
        "resolved": true,
        "details": {
          "function_name": "reuse_swap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1544-1578",
          "snippet": "bool reuse_swap_page(struct page *page, int *total_map_swapcount)\n{\n\tint count, total_mapcount, total_swapcount;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (unlikely(PageKsm(page)))\n\t\treturn false;\n\tcount = page_trans_huge_map_swapcount(page, &total_mapcount,\n\t\t\t\t\t      &total_swapcount);\n\tif (total_map_swapcount)\n\t\t*total_map_swapcount = total_mapcount + total_swapcount;\n\tif (count == 1 && PageSwapCache(page) &&\n\t    (likely(!PageTransCompound(page)) ||\n\t     /* The remaining swap count will be freed soon */\n\t     total_swapcount == page_swapcount(page))) {\n\t\tif (!PageWriteback(page)) {\n\t\t\tpage = compound_head(page);\n\t\t\tdelete_from_swap_cache(page);\n\t\t\tSetPageDirty(page);\n\t\t} else {\n\t\t\tswp_entry_t entry;\n\t\t\tstruct swap_info_struct *p;\n\n\t\t\tentry.val = page_private(page);\n\t\t\tp = swap_info_get(entry);\n\t\t\tif (p->flags & SWP_STABLE_WRITES) {\n\t\t\t\tspin_unlock(&p->lock);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tspin_unlock(&p->lock);\n\t\t}\n\t}\n\n\treturn count <= 1;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nbool reuse_swap_page(struct page *page, int *total_map_swapcount)\n{\n\tint count, total_mapcount, total_swapcount;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (unlikely(PageKsm(page)))\n\t\treturn false;\n\tcount = page_trans_huge_map_swapcount(page, &total_mapcount,\n\t\t\t\t\t      &total_swapcount);\n\tif (total_map_swapcount)\n\t\t*total_map_swapcount = total_mapcount + total_swapcount;\n\tif (count == 1 && PageSwapCache(page) &&\n\t    (likely(!PageTransCompound(page)) ||\n\t     /* The remaining swap count will be freed soon */\n\t     total_swapcount == page_swapcount(page))) {\n\t\tif (!PageWriteback(page)) {\n\t\t\tpage = compound_head(page);\n\t\t\tdelete_from_swap_cache(page);\n\t\t\tSetPageDirty(page);\n\t\t} else {\n\t\t\tswp_entry_t entry;\n\t\t\tstruct swap_info_struct *p;\n\n\t\t\tentry.val = page_private(page);\n\t\t\tp = swap_info_get(entry);\n\t\t\tif (p->flags & SWP_STABLE_WRITES) {\n\t\t\t\tspin_unlock(&p->lock);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tspin_unlock(&p->lock);\n\t\t}\n\t}\n\n\treturn count <= 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "vmf->page"
          ],
          "line": 2520
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "vmf->pte",
            "vmf->ptl"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_same",
          "args": [
            "*vmf->pte",
            "vmf->orig_pte"
          ],
          "line": 2514
        },
        "resolved": true,
        "details": {
          "function_name": "pte_same_as_swp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1735-1738",
          "snippet": "static inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "vma->vm_mm",
            "vmf->pmd",
            "vmf->address",
            "&vmf->ptl"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "vmf->pte",
            "vmf->ptl"
          ],
          "line": 2510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "vmf->page"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageKsm",
          "args": [
            "vmf->page"
          ],
          "line": 2506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "vmf->page"
          ],
          "line": 2506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "vmf->pte",
            "vmf->ptl"
          ],
          "line": 2498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wp_pfn_shared",
          "args": [
            "vmf"
          ],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "wp_pfn_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2411-2427",
          "snippet": "static vm_fault_t wp_pfn_shared(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\n\tif (vma->vm_ops && vma->vm_ops->pfn_mkwrite) {\n\t\tvm_fault_t ret;\n\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\tvmf->flags |= FAULT_FLAG_MKWRITE;\n\t\tret = vma->vm_ops->pfn_mkwrite(vmf);\n\t\tif (ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE))\n\t\t\treturn ret;\n\t\treturn finish_mkwrite_fault(vmf);\n\t}\n\twp_page_reuse(vmf);\n\treturn VM_FAULT_WRITE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t wp_pfn_shared(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\n\tif (vma->vm_ops && vma->vm_ops->pfn_mkwrite) {\n\t\tvm_fault_t ret;\n\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\tvmf->flags |= FAULT_FLAG_MKWRITE;\n\t\tret = vma->vm_ops->pfn_mkwrite(vmf);\n\t\tif (ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE))\n\t\t\treturn ret;\n\t\treturn finish_mkwrite_fault(vmf);\n\t}\n\twp_page_reuse(vmf);\n\treturn VM_FAULT_WRITE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vm_normal_page",
          "args": [
            "vma",
            "vmf->address",
            "vmf->orig_pte"
          ],
          "line": 2485
        },
        "resolved": true,
        "details": {
          "function_name": "vm_normal_page_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "651-689",
          "snippet": "struct page *vm_normal_page_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tpmd_t pmd)\n{\n\tunsigned long pfn = pmd_pfn(pmd);\n\n\t/*\n\t * There is no pmd_special() but there may be special pmds, e.g.\n\t * in a direct-access (dax) mapping, so let's just replicate the\n\t * !CONFIG_ARCH_HAS_PTE_SPECIAL case from vm_normal_page() here.\n\t */\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (pmd_devmap(pmd))\n\t\treturn NULL;\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\tif (unlikely(pfn > highest_memmap_pfn))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstruct page *vm_normal_page_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tpmd_t pmd)\n{\n\tunsigned long pfn = pmd_pfn(pmd);\n\n\t/*\n\t * There is no pmd_special() but there may be special pmds, e.g.\n\t * in a direct-access (dax) mapping, so let's just replicate the\n\t * !CONFIG_ARCH_HAS_PTE_SPECIAL case from vm_normal_page() here.\n\t */\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (pmd_devmap(pmd))\n\t\treturn NULL;\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\tif (unlikely(pfn > highest_memmap_pfn))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "vmf->ptl"
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t do_wp_page(struct vm_fault *vmf)\n\t__releases(vmf->ptl)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\n\tvmf->page = vm_normal_page(vma, vmf->address, vmf->orig_pte);\n\tif (!vmf->page) {\n\t\t/*\n\t\t * VM_MIXEDMAP !pfn_valid() case, or VM_SOFTDIRTY clear on a\n\t\t * VM_PFNMAP VMA.\n\t\t *\n\t\t * We should not cow pages in a shared writeable mapping.\n\t\t * Just mark the pages writable and/or call ops->pfn_mkwrite.\n\t\t */\n\t\tif ((vma->vm_flags & (VM_WRITE|VM_SHARED)) ==\n\t\t\t\t     (VM_WRITE|VM_SHARED))\n\t\t\treturn wp_pfn_shared(vmf);\n\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\treturn wp_page_copy(vmf);\n\t}\n\n\t/*\n\t * Take out anonymous pages first, anonymous shared vmas are\n\t * not dirty accountable.\n\t */\n\tif (PageAnon(vmf->page) && !PageKsm(vmf->page)) {\n\t\tint total_map_swapcount;\n\t\tif (!trylock_page(vmf->page)) {\n\t\t\tget_page(vmf->page);\n\t\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\t\tlock_page(vmf->page);\n\t\t\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd,\n\t\t\t\t\tvmf->address, &vmf->ptl);\n\t\t\tif (!pte_same(*vmf->pte, vmf->orig_pte)) {\n\t\t\t\tunlock_page(vmf->page);\n\t\t\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\t\t\tput_page(vmf->page);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tput_page(vmf->page);\n\t\t}\n\t\tif (reuse_swap_page(vmf->page, &total_map_swapcount)) {\n\t\t\tif (total_map_swapcount == 1) {\n\t\t\t\t/*\n\t\t\t\t * The page is all ours. Move it to\n\t\t\t\t * our anon_vma so the rmap code will\n\t\t\t\t * not search our parent or siblings.\n\t\t\t\t * Protected against the rmap code by\n\t\t\t\t * the page lock.\n\t\t\t\t */\n\t\t\t\tpage_move_anon_rmap(vmf->page, vma);\n\t\t\t}\n\t\t\tunlock_page(vmf->page);\n\t\t\twp_page_reuse(vmf);\n\t\t\treturn VM_FAULT_WRITE;\n\t\t}\n\t\tunlock_page(vmf->page);\n\t} else if (unlikely((vma->vm_flags & (VM_WRITE|VM_SHARED)) ==\n\t\t\t\t\t(VM_WRITE|VM_SHARED))) {\n\t\treturn wp_page_shared(vmf);\n\t}\n\n\t/*\n\t * Ok, we need to copy. Oh, well..\n\t */\n\tget_page(vmf->page);\n\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\treturn wp_page_copy(vmf);\n}"
  },
  {
    "function_name": "wp_page_shared",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "2429-2460",
    "snippet": "static vm_fault_t wp_page_shared(struct vm_fault *vmf)\n\t__releases(vmf->ptl)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\n\tget_page(vmf->page);\n\n\tif (vma->vm_ops && vma->vm_ops->page_mkwrite) {\n\t\tvm_fault_t tmp;\n\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\ttmp = do_page_mkwrite(vmf);\n\t\tif (unlikely(!tmp || (tmp &\n\t\t\t\t      (VM_FAULT_ERROR | VM_FAULT_NOPAGE)))) {\n\t\t\tput_page(vmf->page);\n\t\t\treturn tmp;\n\t\t}\n\t\ttmp = finish_mkwrite_fault(vmf);\n\t\tif (unlikely(tmp & (VM_FAULT_ERROR | VM_FAULT_NOPAGE))) {\n\t\t\tunlock_page(vmf->page);\n\t\t\tput_page(vmf->page);\n\t\t\treturn tmp;\n\t\t}\n\t} else {\n\t\twp_page_reuse(vmf);\n\t\tlock_page(vmf->page);\n\t}\n\tfault_dirty_shared_page(vma, vmf->page);\n\tput_page(vmf->page);\n\n\treturn VM_FAULT_WRITE;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "vmf->page"
          ],
          "line": 2457
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fault_dirty_shared_page",
          "args": [
            "vma",
            "vmf->page"
          ],
          "line": 2456
        },
        "resolved": true,
        "details": {
          "function_name": "fault_dirty_shared_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2166-2194",
          "snippet": "static void fault_dirty_shared_page(struct vm_area_struct *vma,\n\t\t\t\t    struct page *page)\n{\n\tstruct address_space *mapping;\n\tbool dirtied;\n\tbool page_mkwrite = vma->vm_ops && vma->vm_ops->page_mkwrite;\n\n\tdirtied = set_page_dirty(page);\n\tVM_BUG_ON_PAGE(PageAnon(page), page);\n\t/*\n\t * Take a local copy of the address_space - page.mapping may be zeroed\n\t * by truncate after unlock_page().   The address_space itself remains\n\t * pinned by vma->vm_file's reference.  We rely on unlock_page()'s\n\t * release semantics to prevent the compiler from undoing this copying.\n\t */\n\tmapping = page_rmapping(page);\n\tunlock_page(page);\n\n\tif ((dirtied || page_mkwrite) && mapping) {\n\t\t/*\n\t\t * Some device drivers do not set page.mapping\n\t\t * but still dirty their pages\n\t\t */\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t}\n\n\tif (!page_mkwrite)\n\t\tfile_update_time(vma->vm_file);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void fault_dirty_shared_page(struct vm_area_struct *vma,\n\t\t\t\t    struct page *page)\n{\n\tstruct address_space *mapping;\n\tbool dirtied;\n\tbool page_mkwrite = vma->vm_ops && vma->vm_ops->page_mkwrite;\n\n\tdirtied = set_page_dirty(page);\n\tVM_BUG_ON_PAGE(PageAnon(page), page);\n\t/*\n\t * Take a local copy of the address_space - page.mapping may be zeroed\n\t * by truncate after unlock_page().   The address_space itself remains\n\t * pinned by vma->vm_file's reference.  We rely on unlock_page()'s\n\t * release semantics to prevent the compiler from undoing this copying.\n\t */\n\tmapping = page_rmapping(page);\n\tunlock_page(page);\n\n\tif ((dirtied || page_mkwrite) && mapping) {\n\t\t/*\n\t\t * Some device drivers do not set page.mapping\n\t\t * but still dirty their pages\n\t\t */\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t}\n\n\tif (!page_mkwrite)\n\t\tfile_update_time(vma->vm_file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "vmf->page"
          ],
          "line": 2454
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wp_page_reuse",
          "args": [
            "vmf"
          ],
          "line": 2453
        },
        "resolved": true,
        "details": {
          "function_name": "wp_page_reuse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2204-2224",
          "snippet": "static inline void wp_page_reuse(struct vm_fault *vmf)\n\t__releases(vmf->ptl)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page = vmf->page;\n\tpte_t entry;\n\t/*\n\t * Clear the pages cpupid information as the existing\n\t * information potentially belongs to a now completely\n\t * unrelated process.\n\t */\n\tif (page)\n\t\tpage_cpupid_xchg_last(page, (1 << LAST_CPUPID_SHIFT) - 1);\n\n\tflush_cache_page(vma, vmf->address, pte_pfn(vmf->orig_pte));\n\tentry = pte_mkyoung(vmf->orig_pte);\n\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\tif (ptep_set_access_flags(vma, vmf->address, vmf->pte, entry, 1))\n\t\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void wp_page_reuse(struct vm_fault *vmf)\n\t__releases(vmf->ptl)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page = vmf->page;\n\tpte_t entry;\n\t/*\n\t * Clear the pages cpupid information as the existing\n\t * information potentially belongs to a now completely\n\t * unrelated process.\n\t */\n\tif (page)\n\t\tpage_cpupid_xchg_last(page, (1 << LAST_CPUPID_SHIFT) - 1);\n\n\tflush_cache_page(vma, vmf->address, pte_pfn(vmf->orig_pte));\n\tentry = pte_mkyoung(vmf->orig_pte);\n\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\tif (ptep_set_access_flags(vma, vmf->address, vmf->pte, entry, 1))\n\t\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tmp & (VM_FAULT_ERROR | VM_FAULT_NOPAGE)"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_mkwrite_fault",
          "args": [
            "vmf"
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "finish_mkwrite_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2390-2405",
          "snippet": "vm_fault_t finish_mkwrite_fault(struct vm_fault *vmf)\n{\n\tWARN_ON_ONCE(!(vmf->vma->vm_flags & VM_SHARED));\n\tvmf->pte = pte_offset_map_lock(vmf->vma->vm_mm, vmf->pmd, vmf->address,\n\t\t\t\t       &vmf->ptl);\n\t/*\n\t * We might have raced with another page fault while we released the\n\t * pte_offset_map_lock.\n\t */\n\tif (!pte_same(*vmf->pte, vmf->orig_pte)) {\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\treturn VM_FAULT_NOPAGE;\n\t}\n\twp_page_reuse(vmf);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvm_fault_t finish_mkwrite_fault(struct vm_fault *vmf)\n{\n\tWARN_ON_ONCE(!(vmf->vma->vm_flags & VM_SHARED));\n\tvmf->pte = pte_offset_map_lock(vmf->vma->vm_mm, vmf->pmd, vmf->address,\n\t\t\t\t       &vmf->ptl);\n\t/*\n\t * We might have raced with another page fault while we released the\n\t * pte_offset_map_lock.\n\t */\n\tif (!pte_same(*vmf->pte, vmf->orig_pte)) {\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\treturn VM_FAULT_NOPAGE;\n\t}\n\twp_page_reuse(vmf);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tmp || (tmp &\n\t\t\t\t      (VM_FAULT_ERROR | VM_FAULT_NOPAGE))"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_page_mkwrite",
          "args": [
            "vmf"
          ],
          "line": 2440
        },
        "resolved": true,
        "details": {
          "function_name": "do_page_mkwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2136-2159",
          "snippet": "static vm_fault_t do_page_mkwrite(struct vm_fault *vmf)\n{\n\tvm_fault_t ret;\n\tstruct page *page = vmf->page;\n\tunsigned int old_flags = vmf->flags;\n\n\tvmf->flags = FAULT_FLAG_WRITE|FAULT_FLAG_MKWRITE;\n\n\tret = vmf->vma->vm_ops->page_mkwrite(vmf);\n\t/* Restore original flags so that caller is not surprised */\n\tvmf->flags = old_flags;\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE)))\n\t\treturn ret;\n\tif (unlikely(!(ret & VM_FAULT_LOCKED))) {\n\t\tlock_page(page);\n\t\tif (!page->mapping) {\n\t\t\tunlock_page(page);\n\t\t\treturn 0; /* retry */\n\t\t}\n\t\tret |= VM_FAULT_LOCKED;\n\t} else\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t do_page_mkwrite(struct vm_fault *vmf)\n{\n\tvm_fault_t ret;\n\tstruct page *page = vmf->page;\n\tunsigned int old_flags = vmf->flags;\n\n\tvmf->flags = FAULT_FLAG_WRITE|FAULT_FLAG_MKWRITE;\n\n\tret = vmf->vma->vm_ops->page_mkwrite(vmf);\n\t/* Restore original flags so that caller is not surprised */\n\tvmf->flags = old_flags;\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE)))\n\t\treturn ret;\n\tif (unlikely(!(ret & VM_FAULT_LOCKED))) {\n\t\tlock_page(page);\n\t\tif (!page->mapping) {\n\t\t\tunlock_page(page);\n\t\t\treturn 0; /* retry */\n\t\t}\n\t\tret |= VM_FAULT_LOCKED;\n\t} else\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "vmf->pte",
            "vmf->ptl"
          ],
          "line": 2439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "vmf->page"
          ],
          "line": 2434
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "vmf->ptl"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t wp_page_shared(struct vm_fault *vmf)\n\t__releases(vmf->ptl)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\n\tget_page(vmf->page);\n\n\tif (vma->vm_ops && vma->vm_ops->page_mkwrite) {\n\t\tvm_fault_t tmp;\n\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\ttmp = do_page_mkwrite(vmf);\n\t\tif (unlikely(!tmp || (tmp &\n\t\t\t\t      (VM_FAULT_ERROR | VM_FAULT_NOPAGE)))) {\n\t\t\tput_page(vmf->page);\n\t\t\treturn tmp;\n\t\t}\n\t\ttmp = finish_mkwrite_fault(vmf);\n\t\tif (unlikely(tmp & (VM_FAULT_ERROR | VM_FAULT_NOPAGE))) {\n\t\t\tunlock_page(vmf->page);\n\t\t\tput_page(vmf->page);\n\t\t\treturn tmp;\n\t\t}\n\t} else {\n\t\twp_page_reuse(vmf);\n\t\tlock_page(vmf->page);\n\t}\n\tfault_dirty_shared_page(vma, vmf->page);\n\tput_page(vmf->page);\n\n\treturn VM_FAULT_WRITE;\n}"
  },
  {
    "function_name": "wp_pfn_shared",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "2411-2427",
    "snippet": "static vm_fault_t wp_pfn_shared(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\n\tif (vma->vm_ops && vma->vm_ops->pfn_mkwrite) {\n\t\tvm_fault_t ret;\n\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\tvmf->flags |= FAULT_FLAG_MKWRITE;\n\t\tret = vma->vm_ops->pfn_mkwrite(vmf);\n\t\tif (ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE))\n\t\t\treturn ret;\n\t\treturn finish_mkwrite_fault(vmf);\n\t}\n\twp_page_reuse(vmf);\n\treturn VM_FAULT_WRITE;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wp_page_reuse",
          "args": [
            "vmf"
          ],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "wp_page_reuse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2204-2224",
          "snippet": "static inline void wp_page_reuse(struct vm_fault *vmf)\n\t__releases(vmf->ptl)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page = vmf->page;\n\tpte_t entry;\n\t/*\n\t * Clear the pages cpupid information as the existing\n\t * information potentially belongs to a now completely\n\t * unrelated process.\n\t */\n\tif (page)\n\t\tpage_cpupid_xchg_last(page, (1 << LAST_CPUPID_SHIFT) - 1);\n\n\tflush_cache_page(vma, vmf->address, pte_pfn(vmf->orig_pte));\n\tentry = pte_mkyoung(vmf->orig_pte);\n\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\tif (ptep_set_access_flags(vma, vmf->address, vmf->pte, entry, 1))\n\t\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void wp_page_reuse(struct vm_fault *vmf)\n\t__releases(vmf->ptl)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page = vmf->page;\n\tpte_t entry;\n\t/*\n\t * Clear the pages cpupid information as the existing\n\t * information potentially belongs to a now completely\n\t * unrelated process.\n\t */\n\tif (page)\n\t\tpage_cpupid_xchg_last(page, (1 << LAST_CPUPID_SHIFT) - 1);\n\n\tflush_cache_page(vma, vmf->address, pte_pfn(vmf->orig_pte));\n\tentry = pte_mkyoung(vmf->orig_pte);\n\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\tif (ptep_set_access_flags(vma, vmf->address, vmf->pte, entry, 1))\n\t\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_mkwrite_fault",
          "args": [
            "vmf"
          ],
          "line": 2423
        },
        "resolved": true,
        "details": {
          "function_name": "finish_mkwrite_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2390-2405",
          "snippet": "vm_fault_t finish_mkwrite_fault(struct vm_fault *vmf)\n{\n\tWARN_ON_ONCE(!(vmf->vma->vm_flags & VM_SHARED));\n\tvmf->pte = pte_offset_map_lock(vmf->vma->vm_mm, vmf->pmd, vmf->address,\n\t\t\t\t       &vmf->ptl);\n\t/*\n\t * We might have raced with another page fault while we released the\n\t * pte_offset_map_lock.\n\t */\n\tif (!pte_same(*vmf->pte, vmf->orig_pte)) {\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\treturn VM_FAULT_NOPAGE;\n\t}\n\twp_page_reuse(vmf);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvm_fault_t finish_mkwrite_fault(struct vm_fault *vmf)\n{\n\tWARN_ON_ONCE(!(vmf->vma->vm_flags & VM_SHARED));\n\tvmf->pte = pte_offset_map_lock(vmf->vma->vm_mm, vmf->pmd, vmf->address,\n\t\t\t\t       &vmf->ptl);\n\t/*\n\t * We might have raced with another page fault while we released the\n\t * pte_offset_map_lock.\n\t */\n\tif (!pte_same(*vmf->pte, vmf->orig_pte)) {\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\treturn VM_FAULT_NOPAGE;\n\t}\n\twp_page_reuse(vmf);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma->vm_ops->pfn_mkwrite",
          "args": [
            "vmf"
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "vmf->pte",
            "vmf->ptl"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t wp_pfn_shared(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\n\tif (vma->vm_ops && vma->vm_ops->pfn_mkwrite) {\n\t\tvm_fault_t ret;\n\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\tvmf->flags |= FAULT_FLAG_MKWRITE;\n\t\tret = vma->vm_ops->pfn_mkwrite(vmf);\n\t\tif (ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE))\n\t\t\treturn ret;\n\t\treturn finish_mkwrite_fault(vmf);\n\t}\n\twp_page_reuse(vmf);\n\treturn VM_FAULT_WRITE;\n}"
  },
  {
    "function_name": "finish_mkwrite_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "2390-2405",
    "snippet": "vm_fault_t finish_mkwrite_fault(struct vm_fault *vmf)\n{\n\tWARN_ON_ONCE(!(vmf->vma->vm_flags & VM_SHARED));\n\tvmf->pte = pte_offset_map_lock(vmf->vma->vm_mm, vmf->pmd, vmf->address,\n\t\t\t\t       &vmf->ptl);\n\t/*\n\t * We might have raced with another page fault while we released the\n\t * pte_offset_map_lock.\n\t */\n\tif (!pte_same(*vmf->pte, vmf->orig_pte)) {\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\treturn VM_FAULT_NOPAGE;\n\t}\n\twp_page_reuse(vmf);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wp_page_reuse",
          "args": [
            "vmf"
          ],
          "line": 2403
        },
        "resolved": true,
        "details": {
          "function_name": "wp_page_reuse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2204-2224",
          "snippet": "static inline void wp_page_reuse(struct vm_fault *vmf)\n\t__releases(vmf->ptl)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page = vmf->page;\n\tpte_t entry;\n\t/*\n\t * Clear the pages cpupid information as the existing\n\t * information potentially belongs to a now completely\n\t * unrelated process.\n\t */\n\tif (page)\n\t\tpage_cpupid_xchg_last(page, (1 << LAST_CPUPID_SHIFT) - 1);\n\n\tflush_cache_page(vma, vmf->address, pte_pfn(vmf->orig_pte));\n\tentry = pte_mkyoung(vmf->orig_pte);\n\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\tif (ptep_set_access_flags(vma, vmf->address, vmf->pte, entry, 1))\n\t\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void wp_page_reuse(struct vm_fault *vmf)\n\t__releases(vmf->ptl)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page = vmf->page;\n\tpte_t entry;\n\t/*\n\t * Clear the pages cpupid information as the existing\n\t * information potentially belongs to a now completely\n\t * unrelated process.\n\t */\n\tif (page)\n\t\tpage_cpupid_xchg_last(page, (1 << LAST_CPUPID_SHIFT) - 1);\n\n\tflush_cache_page(vma, vmf->address, pte_pfn(vmf->orig_pte));\n\tentry = pte_mkyoung(vmf->orig_pte);\n\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\tif (ptep_set_access_flags(vma, vmf->address, vmf->pte, entry, 1))\n\t\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "vmf->pte",
            "vmf->ptl"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_same",
          "args": [
            "*vmf->pte",
            "vmf->orig_pte"
          ],
          "line": 2399
        },
        "resolved": true,
        "details": {
          "function_name": "pte_same_as_swp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1735-1738",
          "snippet": "static inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "vmf->vma->vm_mm",
            "vmf->pmd",
            "vmf->address",
            "&vmf->ptl"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(vmf->vma->vm_flags & VM_SHARED)"
          ],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvm_fault_t finish_mkwrite_fault(struct vm_fault *vmf)\n{\n\tWARN_ON_ONCE(!(vmf->vma->vm_flags & VM_SHARED));\n\tvmf->pte = pte_offset_map_lock(vmf->vma->vm_mm, vmf->pmd, vmf->address,\n\t\t\t\t       &vmf->ptl);\n\t/*\n\t * We might have raced with another page fault while we released the\n\t * pte_offset_map_lock.\n\t */\n\tif (!pte_same(*vmf->pte, vmf->orig_pte)) {\n\t\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t\treturn VM_FAULT_NOPAGE;\n\t}\n\twp_page_reuse(vmf);\n\treturn 0;\n}"
  },
  {
    "function_name": "wp_page_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "2242-2373",
    "snippet": "static vm_fault_t wp_page_copy(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *old_page = vmf->page;\n\tstruct page *new_page = NULL;\n\tpte_t entry;\n\tint page_copied = 0;\n\tconst unsigned long mmun_start = vmf->address & PAGE_MASK;\n\tconst unsigned long mmun_end = mmun_start + PAGE_SIZE;\n\tstruct mem_cgroup *memcg;\n\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto oom;\n\n\tif (is_zero_pfn(pte_pfn(vmf->orig_pte))) {\n\t\tnew_page = alloc_zeroed_user_highpage_movable(vma,\n\t\t\t\t\t\t\t      vmf->address);\n\t\tif (!new_page)\n\t\t\tgoto oom;\n\t} else {\n\t\tnew_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma,\n\t\t\t\tvmf->address);\n\t\tif (!new_page)\n\t\t\tgoto oom;\n\t\tcow_user_page(new_page, old_page, vmf->address, vma);\n\t}\n\n\tif (mem_cgroup_try_charge_delay(new_page, mm, GFP_KERNEL, &memcg, false))\n\t\tgoto oom_free_new;\n\n\t__SetPageUptodate(new_page);\n\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\n\t/*\n\t * Re-check the pte - we dropped the lock\n\t */\n\tvmf->pte = pte_offset_map_lock(mm, vmf->pmd, vmf->address, &vmf->ptl);\n\tif (likely(pte_same(*vmf->pte, vmf->orig_pte))) {\n\t\tif (old_page) {\n\t\t\tif (!PageAnon(old_page)) {\n\t\t\t\tdec_mm_counter_fast(mm,\n\t\t\t\t\t\tmm_counter_file(old_page));\n\t\t\t\tinc_mm_counter_fast(mm, MM_ANONPAGES);\n\t\t\t}\n\t\t} else {\n\t\t\tinc_mm_counter_fast(mm, MM_ANONPAGES);\n\t\t}\n\t\tflush_cache_page(vma, vmf->address, pte_pfn(vmf->orig_pte));\n\t\tentry = mk_pte(new_page, vma->vm_page_prot);\n\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t\t/*\n\t\t * Clear the pte entry and flush it first, before updating the\n\t\t * pte with the new entry. This will avoid a race condition\n\t\t * seen in the presence of one thread doing SMC and another\n\t\t * thread doing COW.\n\t\t */\n\t\tptep_clear_flush_notify(vma, vmf->address, vmf->pte);\n\t\tpage_add_new_anon_rmap(new_page, vma, vmf->address, false);\n\t\tmem_cgroup_commit_charge(new_page, memcg, false, false);\n\t\tlru_cache_add_active_or_unevictable(new_page, vma);\n\t\t/*\n\t\t * We call the notify macro here because, when using secondary\n\t\t * mmu page tables (such as kvm shadow page tables), we want the\n\t\t * new page to be mapped directly into the secondary page table.\n\t\t */\n\t\tset_pte_at_notify(mm, vmf->address, vmf->pte, entry);\n\t\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\n\t\tif (old_page) {\n\t\t\t/*\n\t\t\t * Only after switching the pte to the new page may\n\t\t\t * we remove the mapcount here. Otherwise another\n\t\t\t * process may come and find the rmap count decremented\n\t\t\t * before the pte is switched to the new page, and\n\t\t\t * \"reuse\" the old page writing into it while our pte\n\t\t\t * here still points into it and can be read by other\n\t\t\t * threads.\n\t\t\t *\n\t\t\t * The critical issue is to order this\n\t\t\t * page_remove_rmap with the ptp_clear_flush above.\n\t\t\t * Those stores are ordered by (if nothing else,)\n\t\t\t * the barrier present in the atomic_add_negative\n\t\t\t * in page_remove_rmap.\n\t\t\t *\n\t\t\t * Then the TLB flush in ptep_clear_flush ensures that\n\t\t\t * no process can access the old page before the\n\t\t\t * decremented mapcount is visible. And the old page\n\t\t\t * cannot be reused until after the decremented\n\t\t\t * mapcount is visible. So transitively, TLBs to\n\t\t\t * old page will be flushed before it can be reused.\n\t\t\t */\n\t\t\tpage_remove_rmap(old_page, false);\n\t\t}\n\n\t\t/* Free the old page.. */\n\t\tnew_page = old_page;\n\t\tpage_copied = 1;\n\t} else {\n\t\tmem_cgroup_cancel_charge(new_page, memcg, false);\n\t}\n\n\tif (new_page)\n\t\tput_page(new_page);\n\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback as\n\t * the above ptep_clear_flush_notify() did already call it.\n\t */\n\tmmu_notifier_invalidate_range_only_end(mm, mmun_start, mmun_end);\n\tif (old_page) {\n\t\t/*\n\t\t * Don't let another task, with possibly unlocked vma,\n\t\t * keep the mlocked page.\n\t\t */\n\t\tif (page_copied && (vma->vm_flags & VM_LOCKED)) {\n\t\t\tlock_page(old_page);\t/* LRU manipulation */\n\t\t\tif (PageMlocked(old_page))\n\t\t\t\tmunlock_vma_page(old_page);\n\t\t\tunlock_page(old_page);\n\t\t}\n\t\tput_page(old_page);\n\t}\n\treturn page_copied ? VM_FAULT_WRITE : 0;\noom_free_new:\n\tput_page(new_page);\noom:\n\tif (old_page)\n\t\tput_page(old_page);\n\treturn VM_FAULT_OOM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "old_page"
          ],
          "line": 2371
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "old_page"
          ],
          "line": 2362
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "munlock_vma_page",
          "args": [
            "old_page"
          ],
          "line": 2361
        },
        "resolved": true,
        "details": {
          "function_name": "munlock_vma_pages_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "292-295",
          "snippet": "static inline void munlock_vma_pages_all(struct vm_area_struct *vma)\n{\n\tmunlock_vma_pages_range(vma, vma->vm_start, vma->vm_end);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void munlock_vma_pages_all(struct vm_area_struct *vma)\n{\n\tmunlock_vma_pages_range(vma, vma->vm_start, vma->vm_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageMlocked",
          "args": [
            "old_page"
          ],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_only_end",
          "args": [
            "mm",
            "mmun_start",
            "mmun_end"
          ],
          "line": 2352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "vmf->pte",
            "vmf->ptl"
          ],
          "line": 2347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_cancel_charge",
          "args": [
            "new_page",
            "memcg",
            "false"
          ],
          "line": 2341
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_cancel_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5972-5988",
          "snippet": "void mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,\n\t\tbool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcancel_charge(memcg, nr_pages);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,\n\t\tbool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcancel_charge(memcg, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_remove_rmap",
          "args": [
            "old_page",
            "false"
          ],
          "line": 2334
        },
        "resolved": true,
        "details": {
          "function_name": "page_remove_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1297-1331",
          "snippet": "void page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_mmu_cache",
          "args": [
            "vma",
            "vmf->address",
            "vmf->pte"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at_notify",
          "args": [
            "mm",
            "vmf->address",
            "vmf->pte",
            "entry"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_cache_add_active_or_unevictable",
          "args": [
            "new_page",
            "vma"
          ],
          "line": 2303
        },
        "resolved": true,
        "details": {
          "function_name": "lru_cache_add_active_or_unevictable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "458-476",
          "snippet": "void lru_cache_add_active_or_unevictable(struct page *page,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\tif (likely((vma->vm_flags & (VM_LOCKED | VM_SPECIAL)) != VM_LOCKED))\n\t\tSetPageActive(page);\n\telse if (!TestSetPageMlocked(page)) {\n\t\t/*\n\t\t * We use the irq-unsafe __mod_zone_page_stat because this\n\t\t * counter is not modified from interrupt context, and the pte\n\t\t * lock is held(spinlock), which implies preemption disabled.\n\t\t */\n\t\t__mod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t}\n\tlru_cache_add(page);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid lru_cache_add_active_or_unevictable(struct page *page,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\tif (likely((vma->vm_flags & (VM_LOCKED | VM_SPECIAL)) != VM_LOCKED))\n\t\tSetPageActive(page);\n\telse if (!TestSetPageMlocked(page)) {\n\t\t/*\n\t\t * We use the irq-unsafe __mod_zone_page_stat because this\n\t\t * counter is not modified from interrupt context, and the pte\n\t\t * lock is held(spinlock), which implies preemption disabled.\n\t\t */\n\t\t__mod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t}\n\tlru_cache_add(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_commit_charge",
          "args": [
            "new_page",
            "memcg",
            "false",
            "false"
          ],
          "line": 2302
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_commit_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5928-5962",
          "snippet": "void mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t      bool lrucare, bool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_PAGE(!page->mapping, page);\n\tVM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcommit_charge(page, memcg, lrucare);\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(memcg, page, compound, nr_pages);\n\tmemcg_check_events(memcg, page);\n\tlocal_irq_enable();\n\n\tif (do_memsw_account() && PageSwapCache(page)) {\n\t\tswp_entry_t entry = { .val = page_private(page) };\n\t\t/*\n\t\t * The swap entry might not get freed for a long time,\n\t\t * let's not wait for it.  The page already received a\n\t\t * memory+swap charge, drop the swap entry duplicate.\n\t\t */\n\t\tmem_cgroup_uncharge_swap(entry, nr_pages);\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t      bool lrucare, bool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_PAGE(!page->mapping, page);\n\tVM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcommit_charge(page, memcg, lrucare);\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(memcg, page, compound, nr_pages);\n\tmemcg_check_events(memcg, page);\n\tlocal_irq_enable();\n\n\tif (do_memsw_account() && PageSwapCache(page)) {\n\t\tswp_entry_t entry = { .val = page_private(page) };\n\t\t/*\n\t\t * The swap entry might not get freed for a long time,\n\t\t * let's not wait for it.  The page already received a\n\t\t * memory+swap charge, drop the swap entry duplicate.\n\t\t */\n\t\tmem_cgroup_uncharge_swap(entry, nr_pages);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_add_new_anon_rmap",
          "args": [
            "new_page",
            "vma",
            "vmf->address",
            "false"
          ],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "page_add_new_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1150-1170",
          "snippet": "void page_add_new_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, bool compound)\n{\n\tint nr = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\t__SetPageSwapBacked(page);\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(compound_mapcount_ptr(page), 0);\n\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t} else {\n\t\t/* Anon THP always mapped first with PMD */\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(&page->_mapcount, 0);\n\t}\n\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t__page_set_anon_rmap(page, vma, address, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_add_new_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, bool compound)\n{\n\tint nr = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\t__SetPageSwapBacked(page);\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(compound_mapcount_ptr(page), 0);\n\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t} else {\n\t\t/* Anon THP always mapped first with PMD */\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(&page->_mapcount, 0);\n\t}\n\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t__page_set_anon_rmap(page, vma, address, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptep_clear_flush_notify",
          "args": [
            "vma",
            "vmf->address",
            "vmf->pte"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "maybe_mkwrite",
          "args": [
            "pte_mkdirty(entry)",
            "vma"
          ],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkdirty",
          "args": [
            "entry"
          ],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mk_pte",
          "args": [
            "new_page",
            "vma->vm_page_prot"
          ],
          "line": 2292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_cache_page",
          "args": [
            "vma",
            "vmf->address",
            "pte_pfn(vmf->orig_pte)"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "vmf->orig_pte"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_mm_counter_fast",
          "args": [
            "mm",
            "MM_ANONPAGES"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_mm_counter_fast",
          "args": [
            "mm",
            "MM_ANONPAGES"
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_mm_counter_fast",
          "args": [
            "mm",
            "mm_counter_file(old_page)"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_counter_file",
          "args": [
            "old_page"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "old_page"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "pte_same(*vmf->pte, vmf->orig_pte)"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_same",
          "args": [
            "*vmf->pte",
            "vmf->orig_pte"
          ],
          "line": 2281
        },
        "resolved": true,
        "details": {
          "function_name": "pte_same_as_swp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1735-1738",
          "snippet": "static inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "mm",
            "vmf->pmd",
            "vmf->address",
            "&vmf->ptl"
          ],
          "line": 2280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "mm",
            "mmun_start",
            "mmun_end"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SetPageUptodate",
          "args": [
            "new_page"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_try_charge_delay",
          "args": [
            "new_page",
            "mm",
            "GFP_KERNEL",
            "&memcg",
            "false"
          ],
          "line": 2270
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_try_charge_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5898-5909",
          "snippet": "int mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\tret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);\n\tmemcg = *memcgp;\n\tmem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nint mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\tret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);\n\tmemcg = *memcgp;\n\tmem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cow_user_page",
          "args": [
            "new_page",
            "old_page",
            "vmf->address",
            "vma"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "cow_user_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2088-2114",
          "snippet": "static inline void cow_user_page(struct page *dst, struct page *src, unsigned long va, struct vm_area_struct *vma)\n{\n\tdebug_dma_assert_idle(src);\n\n\t/*\n\t * If the source page was a PFN mapping, we don't have\n\t * a \"struct page\" for it. We do a best-effort copy by\n\t * just copying from the original user address. If that\n\t * fails, we just zero-fill it. Live with it.\n\t */\n\tif (unlikely(!src)) {\n\t\tvoid *kaddr = kmap_atomic(dst);\n\t\tvoid __user *uaddr = (void __user *)(va & PAGE_MASK);\n\n\t\t/*\n\t\t * This really shouldn't fail, because the page is there\n\t\t * in the page tables. But it might just be unreadable,\n\t\t * in which case we just give up and fill the result with\n\t\t * zeroes.\n\t\t */\n\t\tif (__copy_from_user_inatomic(kaddr, uaddr, PAGE_SIZE))\n\t\t\tclear_page(kaddr);\n\t\tkunmap_atomic(kaddr);\n\t\tflush_dcache_page(dst);\n\t} else\n\t\tcopy_user_highpage(dst, src, va, vma);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void cow_user_page(struct page *dst, struct page *src, unsigned long va, struct vm_area_struct *vma)\n{\n\tdebug_dma_assert_idle(src);\n\n\t/*\n\t * If the source page was a PFN mapping, we don't have\n\t * a \"struct page\" for it. We do a best-effort copy by\n\t * just copying from the original user address. If that\n\t * fails, we just zero-fill it. Live with it.\n\t */\n\tif (unlikely(!src)) {\n\t\tvoid *kaddr = kmap_atomic(dst);\n\t\tvoid __user *uaddr = (void __user *)(va & PAGE_MASK);\n\n\t\t/*\n\t\t * This really shouldn't fail, because the page is there\n\t\t * in the page tables. But it might just be unreadable,\n\t\t * in which case we just give up and fill the result with\n\t\t * zeroes.\n\t\t */\n\t\tif (__copy_from_user_inatomic(kaddr, uaddr, PAGE_SIZE))\n\t\t\tclear_page(kaddr);\n\t\tkunmap_atomic(kaddr);\n\t\tflush_dcache_page(dst);\n\t} else\n\t\tcopy_user_highpage(dst, src, va, vma);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page_vma",
          "args": [
            "GFP_HIGHUSER_MOVABLE",
            "vma",
            "vmf->address"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_zeroed_user_highpage_movable",
          "args": [
            "vma",
            "vmf->address"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_zero_pfn",
          "args": [
            "pte_pfn(vmf->orig_pte)"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "vmf->orig_pte"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "anon_vma_prepare(vma)"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_prepare",
          "args": [
            "vma"
          ],
          "line": 2254
        },
        "resolved": true,
        "details": {
          "function_name": "__anon_vma_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "175-221",
          "snippet": "int __anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct anon_vma *anon_vma, *allocated;\n\tstruct anon_vma_chain *avc;\n\n\tmight_sleep();\n\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_enomem;\n\n\tanon_vma = find_mergeable_anon_vma(vma);\n\tallocated = NULL;\n\tif (!anon_vma) {\n\t\tanon_vma = anon_vma_alloc();\n\t\tif (unlikely(!anon_vma))\n\t\t\tgoto out_enomem_free_avc;\n\t\tallocated = anon_vma;\n\t}\n\n\tanon_vma_lock_write(anon_vma);\n\t/* page_table_lock to protect against threads */\n\tspin_lock(&mm->page_table_lock);\n\tif (likely(!vma->anon_vma)) {\n\t\tvma->anon_vma = anon_vma;\n\t\tanon_vma_chain_link(vma, avc, anon_vma);\n\t\t/* vma reference or self-parent link for new root */\n\t\tanon_vma->degree++;\n\t\tallocated = NULL;\n\t\tavc = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tanon_vma_unlock_write(anon_vma);\n\n\tif (unlikely(allocated))\n\t\tput_anon_vma(allocated);\n\tif (unlikely(avc))\n\t\tanon_vma_chain_free(avc);\n\n\treturn 0;\n\n out_enomem_free_avc:\n\tanon_vma_chain_free(avc);\n out_enomem:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint __anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct anon_vma *anon_vma, *allocated;\n\tstruct anon_vma_chain *avc;\n\n\tmight_sleep();\n\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_enomem;\n\n\tanon_vma = find_mergeable_anon_vma(vma);\n\tallocated = NULL;\n\tif (!anon_vma) {\n\t\tanon_vma = anon_vma_alloc();\n\t\tif (unlikely(!anon_vma))\n\t\t\tgoto out_enomem_free_avc;\n\t\tallocated = anon_vma;\n\t}\n\n\tanon_vma_lock_write(anon_vma);\n\t/* page_table_lock to protect against threads */\n\tspin_lock(&mm->page_table_lock);\n\tif (likely(!vma->anon_vma)) {\n\t\tvma->anon_vma = anon_vma;\n\t\tanon_vma_chain_link(vma, avc, anon_vma);\n\t\t/* vma reference or self-parent link for new root */\n\t\tanon_vma->degree++;\n\t\tallocated = NULL;\n\t\tavc = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tanon_vma_unlock_write(anon_vma);\n\n\tif (unlikely(allocated))\n\t\tput_anon_vma(allocated);\n\tif (unlikely(avc))\n\t\tanon_vma_chain_free(avc);\n\n\treturn 0;\n\n out_enomem_free_avc:\n\tanon_vma_chain_free(avc);\n out_enomem:\n\treturn -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t wp_page_copy(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *old_page = vmf->page;\n\tstruct page *new_page = NULL;\n\tpte_t entry;\n\tint page_copied = 0;\n\tconst unsigned long mmun_start = vmf->address & PAGE_MASK;\n\tconst unsigned long mmun_end = mmun_start + PAGE_SIZE;\n\tstruct mem_cgroup *memcg;\n\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto oom;\n\n\tif (is_zero_pfn(pte_pfn(vmf->orig_pte))) {\n\t\tnew_page = alloc_zeroed_user_highpage_movable(vma,\n\t\t\t\t\t\t\t      vmf->address);\n\t\tif (!new_page)\n\t\t\tgoto oom;\n\t} else {\n\t\tnew_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma,\n\t\t\t\tvmf->address);\n\t\tif (!new_page)\n\t\t\tgoto oom;\n\t\tcow_user_page(new_page, old_page, vmf->address, vma);\n\t}\n\n\tif (mem_cgroup_try_charge_delay(new_page, mm, GFP_KERNEL, &memcg, false))\n\t\tgoto oom_free_new;\n\n\t__SetPageUptodate(new_page);\n\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\n\t/*\n\t * Re-check the pte - we dropped the lock\n\t */\n\tvmf->pte = pte_offset_map_lock(mm, vmf->pmd, vmf->address, &vmf->ptl);\n\tif (likely(pte_same(*vmf->pte, vmf->orig_pte))) {\n\t\tif (old_page) {\n\t\t\tif (!PageAnon(old_page)) {\n\t\t\t\tdec_mm_counter_fast(mm,\n\t\t\t\t\t\tmm_counter_file(old_page));\n\t\t\t\tinc_mm_counter_fast(mm, MM_ANONPAGES);\n\t\t\t}\n\t\t} else {\n\t\t\tinc_mm_counter_fast(mm, MM_ANONPAGES);\n\t\t}\n\t\tflush_cache_page(vma, vmf->address, pte_pfn(vmf->orig_pte));\n\t\tentry = mk_pte(new_page, vma->vm_page_prot);\n\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t\t/*\n\t\t * Clear the pte entry and flush it first, before updating the\n\t\t * pte with the new entry. This will avoid a race condition\n\t\t * seen in the presence of one thread doing SMC and another\n\t\t * thread doing COW.\n\t\t */\n\t\tptep_clear_flush_notify(vma, vmf->address, vmf->pte);\n\t\tpage_add_new_anon_rmap(new_page, vma, vmf->address, false);\n\t\tmem_cgroup_commit_charge(new_page, memcg, false, false);\n\t\tlru_cache_add_active_or_unevictable(new_page, vma);\n\t\t/*\n\t\t * We call the notify macro here because, when using secondary\n\t\t * mmu page tables (such as kvm shadow page tables), we want the\n\t\t * new page to be mapped directly into the secondary page table.\n\t\t */\n\t\tset_pte_at_notify(mm, vmf->address, vmf->pte, entry);\n\t\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\n\t\tif (old_page) {\n\t\t\t/*\n\t\t\t * Only after switching the pte to the new page may\n\t\t\t * we remove the mapcount here. Otherwise another\n\t\t\t * process may come and find the rmap count decremented\n\t\t\t * before the pte is switched to the new page, and\n\t\t\t * \"reuse\" the old page writing into it while our pte\n\t\t\t * here still points into it and can be read by other\n\t\t\t * threads.\n\t\t\t *\n\t\t\t * The critical issue is to order this\n\t\t\t * page_remove_rmap with the ptp_clear_flush above.\n\t\t\t * Those stores are ordered by (if nothing else,)\n\t\t\t * the barrier present in the atomic_add_negative\n\t\t\t * in page_remove_rmap.\n\t\t\t *\n\t\t\t * Then the TLB flush in ptep_clear_flush ensures that\n\t\t\t * no process can access the old page before the\n\t\t\t * decremented mapcount is visible. And the old page\n\t\t\t * cannot be reused until after the decremented\n\t\t\t * mapcount is visible. So transitively, TLBs to\n\t\t\t * old page will be flushed before it can be reused.\n\t\t\t */\n\t\t\tpage_remove_rmap(old_page, false);\n\t\t}\n\n\t\t/* Free the old page.. */\n\t\tnew_page = old_page;\n\t\tpage_copied = 1;\n\t} else {\n\t\tmem_cgroup_cancel_charge(new_page, memcg, false);\n\t}\n\n\tif (new_page)\n\t\tput_page(new_page);\n\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback as\n\t * the above ptep_clear_flush_notify() did already call it.\n\t */\n\tmmu_notifier_invalidate_range_only_end(mm, mmun_start, mmun_end);\n\tif (old_page) {\n\t\t/*\n\t\t * Don't let another task, with possibly unlocked vma,\n\t\t * keep the mlocked page.\n\t\t */\n\t\tif (page_copied && (vma->vm_flags & VM_LOCKED)) {\n\t\t\tlock_page(old_page);\t/* LRU manipulation */\n\t\t\tif (PageMlocked(old_page))\n\t\t\t\tmunlock_vma_page(old_page);\n\t\t\tunlock_page(old_page);\n\t\t}\n\t\tput_page(old_page);\n\t}\n\treturn page_copied ? VM_FAULT_WRITE : 0;\noom_free_new:\n\tput_page(new_page);\noom:\n\tif (old_page)\n\t\tput_page(old_page);\n\treturn VM_FAULT_OOM;\n}"
  },
  {
    "function_name": "wp_page_reuse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "2204-2224",
    "snippet": "static inline void wp_page_reuse(struct vm_fault *vmf)\n\t__releases(vmf->ptl)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page = vmf->page;\n\tpte_t entry;\n\t/*\n\t * Clear the pages cpupid information as the existing\n\t * information potentially belongs to a now completely\n\t * unrelated process.\n\t */\n\tif (page)\n\t\tpage_cpupid_xchg_last(page, (1 << LAST_CPUPID_SHIFT) - 1);\n\n\tflush_cache_page(vma, vmf->address, pte_pfn(vmf->orig_pte));\n\tentry = pte_mkyoung(vmf->orig_pte);\n\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\tif (ptep_set_access_flags(vma, vmf->address, vmf->pte, entry, 1))\n\t\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "vmf->pte",
            "vmf->ptl"
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_mmu_cache",
          "args": [
            "vma",
            "vmf->address",
            "vmf->pte"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptep_set_access_flags",
          "args": [
            "vma",
            "vmf->address",
            "vmf->pte",
            "entry",
            "1"
          ],
          "line": 2221
        },
        "resolved": true,
        "details": {
          "function_name": "ptep_set_access_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "55-65",
          "snippet": "int ptep_set_access_flags(struct vm_area_struct *vma,\n\t\t\t  unsigned long address, pte_t *ptep,\n\t\t\t  pte_t entry, int dirty)\n{\n\tint changed = !pte_same(*ptep, entry);\n\tif (changed) {\n\t\tset_pte_at(vma->vm_mm, address, ptep, entry);\n\t\tflush_tlb_fix_spurious_fault(vma, address);\n\t}\n\treturn changed;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\nint ptep_set_access_flags(struct vm_area_struct *vma,\n\t\t\t  unsigned long address, pte_t *ptep,\n\t\t\t  pte_t entry, int dirty)\n{\n\tint changed = !pte_same(*ptep, entry);\n\tif (changed) {\n\t\tset_pte_at(vma->vm_mm, address, ptep, entry);\n\t\tflush_tlb_fix_spurious_fault(vma, address);\n\t}\n\treturn changed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "maybe_mkwrite",
          "args": [
            "pte_mkdirty(entry)",
            "vma"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkdirty",
          "args": [
            "entry"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkyoung",
          "args": [
            "vmf->orig_pte"
          ],
          "line": 2219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_cache_page",
          "args": [
            "vma",
            "vmf->address",
            "pte_pfn(vmf->orig_pte)"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "vmf->orig_pte"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cpupid_xchg_last",
          "args": [
            "page",
            "(1 << LAST_CPUPID_SHIFT) - 1"
          ],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "page_cpupid_xchg_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmzone.c",
          "lines": "100-114",
          "snippet": "int page_cpupid_xchg_last(struct page *page, int cpupid)\n{\n\tunsigned long old_flags, flags;\n\tint last_cpupid;\n\n\tdo {\n\t\told_flags = flags = page->flags;\n\t\tlast_cpupid = page_cpupid_last(page);\n\n\t\tflags &= ~(LAST_CPUPID_MASK << LAST_CPUPID_PGSHIFT);\n\t\tflags |= (cpupid & LAST_CPUPID_MASK) << LAST_CPUPID_PGSHIFT;\n\t} while (unlikely(cmpxchg(&page->flags, old_flags, flags) != old_flags));\n\n\treturn last_cpupid;\n}",
          "includes": [
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint page_cpupid_xchg_last(struct page *page, int cpupid)\n{\n\tunsigned long old_flags, flags;\n\tint last_cpupid;\n\n\tdo {\n\t\told_flags = flags = page->flags;\n\t\tlast_cpupid = page_cpupid_last(page);\n\n\t\tflags &= ~(LAST_CPUPID_MASK << LAST_CPUPID_PGSHIFT);\n\t\tflags |= (cpupid & LAST_CPUPID_MASK) << LAST_CPUPID_PGSHIFT;\n\t} while (unlikely(cmpxchg(&page->flags, old_flags, flags) != old_flags));\n\n\treturn last_cpupid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "vmf->ptl"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void wp_page_reuse(struct vm_fault *vmf)\n\t__releases(vmf->ptl)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page = vmf->page;\n\tpte_t entry;\n\t/*\n\t * Clear the pages cpupid information as the existing\n\t * information potentially belongs to a now completely\n\t * unrelated process.\n\t */\n\tif (page)\n\t\tpage_cpupid_xchg_last(page, (1 << LAST_CPUPID_SHIFT) - 1);\n\n\tflush_cache_page(vma, vmf->address, pte_pfn(vmf->orig_pte));\n\tentry = pte_mkyoung(vmf->orig_pte);\n\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\tif (ptep_set_access_flags(vma, vmf->address, vmf->pte, entry, 1))\n\t\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\n}"
  },
  {
    "function_name": "fault_dirty_shared_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "2166-2194",
    "snippet": "static void fault_dirty_shared_page(struct vm_area_struct *vma,\n\t\t\t\t    struct page *page)\n{\n\tstruct address_space *mapping;\n\tbool dirtied;\n\tbool page_mkwrite = vma->vm_ops && vma->vm_ops->page_mkwrite;\n\n\tdirtied = set_page_dirty(page);\n\tVM_BUG_ON_PAGE(PageAnon(page), page);\n\t/*\n\t * Take a local copy of the address_space - page.mapping may be zeroed\n\t * by truncate after unlock_page().   The address_space itself remains\n\t * pinned by vma->vm_file's reference.  We rely on unlock_page()'s\n\t * release semantics to prevent the compiler from undoing this copying.\n\t */\n\tmapping = page_rmapping(page);\n\tunlock_page(page);\n\n\tif ((dirtied || page_mkwrite) && mapping) {\n\t\t/*\n\t\t * Some device drivers do not set page.mapping\n\t\t * but still dirty their pages\n\t\t */\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t}\n\n\tif (!page_mkwrite)\n\t\tfile_update_time(vma->vm_file);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_update_time",
          "args": [
            "vma->vm_file"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balance_dirty_pages_ratelimited",
          "args": [
            "mapping"
          ],
          "line": 2189
        },
        "resolved": true,
        "details": {
          "function_name": "balance_dirty_pages_ratelimited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1861-1913",
          "snippet": "void balance_dirty_pages_ratelimited(struct address_space *mapping)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\tstruct bdi_writeback *wb = NULL;\n\tint ratelimit;\n\tint *p;\n\n\tif (!bdi_cap_account_dirty(bdi))\n\t\treturn;\n\n\tif (inode_cgwb_enabled(inode))\n\t\twb = wb_get_create_current(bdi, GFP_KERNEL);\n\tif (!wb)\n\t\twb = &bdi->wb;\n\n\tratelimit = current->nr_dirtied_pause;\n\tif (wb->dirty_exceeded)\n\t\tratelimit = min(ratelimit, 32 >> (PAGE_SHIFT - 10));\n\n\tpreempt_disable();\n\t/*\n\t * This prevents one CPU to accumulate too many dirtied pages without\n\t * calling into balance_dirty_pages(), which can happen when there are\n\t * 1000+ tasks, all of them start dirtying pages at exactly the same\n\t * time, hence all honoured too large initial task->nr_dirtied_pause.\n\t */\n\tp =  this_cpu_ptr(&bdp_ratelimits);\n\tif (unlikely(current->nr_dirtied >= ratelimit))\n\t\t*p = 0;\n\telse if (unlikely(*p >= ratelimit_pages)) {\n\t\t*p = 0;\n\t\tratelimit = 0;\n\t}\n\t/*\n\t * Pick up the dirtied pages by the exited tasks. This avoids lots of\n\t * short-lived tasks (eg. gcc invocations in a kernel build) escaping\n\t * the dirty throttling and livelock other long-run dirtiers.\n\t */\n\tp = this_cpu_ptr(&dirty_throttle_leaks);\n\tif (*p > 0 && current->nr_dirtied < ratelimit) {\n\t\tunsigned long nr_pages_dirtied;\n\t\tnr_pages_dirtied = min(*p, ratelimit - current->nr_dirtied);\n\t\t*p -= nr_pages_dirtied;\n\t\tcurrent->nr_dirtied += nr_pages_dirtied;\n\t}\n\tpreempt_enable();\n\n\tif (unlikely(current->nr_dirtied >= ratelimit))\n\t\tbalance_dirty_pages(wb, current->nr_dirtied);\n\n\twb_put(wb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long ratelimit_pages = 32;",
            "static DEFINE_PER_CPU(int, bdp_ratelimits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long ratelimit_pages = 32;\nstatic DEFINE_PER_CPU(int, bdp_ratelimits);\n\nvoid balance_dirty_pages_ratelimited(struct address_space *mapping)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\tstruct bdi_writeback *wb = NULL;\n\tint ratelimit;\n\tint *p;\n\n\tif (!bdi_cap_account_dirty(bdi))\n\t\treturn;\n\n\tif (inode_cgwb_enabled(inode))\n\t\twb = wb_get_create_current(bdi, GFP_KERNEL);\n\tif (!wb)\n\t\twb = &bdi->wb;\n\n\tratelimit = current->nr_dirtied_pause;\n\tif (wb->dirty_exceeded)\n\t\tratelimit = min(ratelimit, 32 >> (PAGE_SHIFT - 10));\n\n\tpreempt_disable();\n\t/*\n\t * This prevents one CPU to accumulate too many dirtied pages without\n\t * calling into balance_dirty_pages(), which can happen when there are\n\t * 1000+ tasks, all of them start dirtying pages at exactly the same\n\t * time, hence all honoured too large initial task->nr_dirtied_pause.\n\t */\n\tp =  this_cpu_ptr(&bdp_ratelimits);\n\tif (unlikely(current->nr_dirtied >= ratelimit))\n\t\t*p = 0;\n\telse if (unlikely(*p >= ratelimit_pages)) {\n\t\t*p = 0;\n\t\tratelimit = 0;\n\t}\n\t/*\n\t * Pick up the dirtied pages by the exited tasks. This avoids lots of\n\t * short-lived tasks (eg. gcc invocations in a kernel build) escaping\n\t * the dirty throttling and livelock other long-run dirtiers.\n\t */\n\tp = this_cpu_ptr(&dirty_throttle_leaks);\n\tif (*p > 0 && current->nr_dirtied < ratelimit) {\n\t\tunsigned long nr_pages_dirtied;\n\t\tnr_pages_dirtied = min(*p, ratelimit - current->nr_dirtied);\n\t\t*p -= nr_pages_dirtied;\n\t\tcurrent->nr_dirtied += nr_pages_dirtied;\n\t}\n\tpreempt_enable();\n\n\tif (unlikely(current->nr_dirtied >= ratelimit))\n\t\tbalance_dirty_pages(wb, current->nr_dirtied);\n\n\twb_put(wb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_rmapping",
          "args": [
            "page"
          ],
          "line": 2181
        },
        "resolved": true,
        "details": {
          "function_name": "page_rmapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "460-464",
          "snippet": "void *page_rmapping(struct page *page)\n{\n\tpage = compound_head(page);\n\treturn __page_rmapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid *page_rmapping(struct page *page)\n{\n\tpage = compound_head(page);\n\treturn __page_rmapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageAnon(page)",
            "page"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 2173
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_dirty_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2573-2581",
          "snippet": "int set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void fault_dirty_shared_page(struct vm_area_struct *vma,\n\t\t\t\t    struct page *page)\n{\n\tstruct address_space *mapping;\n\tbool dirtied;\n\tbool page_mkwrite = vma->vm_ops && vma->vm_ops->page_mkwrite;\n\n\tdirtied = set_page_dirty(page);\n\tVM_BUG_ON_PAGE(PageAnon(page), page);\n\t/*\n\t * Take a local copy of the address_space - page.mapping may be zeroed\n\t * by truncate after unlock_page().   The address_space itself remains\n\t * pinned by vma->vm_file's reference.  We rely on unlock_page()'s\n\t * release semantics to prevent the compiler from undoing this copying.\n\t */\n\tmapping = page_rmapping(page);\n\tunlock_page(page);\n\n\tif ((dirtied || page_mkwrite) && mapping) {\n\t\t/*\n\t\t * Some device drivers do not set page.mapping\n\t\t * but still dirty their pages\n\t\t */\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t}\n\n\tif (!page_mkwrite)\n\t\tfile_update_time(vma->vm_file);\n}"
  },
  {
    "function_name": "do_page_mkwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "2136-2159",
    "snippet": "static vm_fault_t do_page_mkwrite(struct vm_fault *vmf)\n{\n\tvm_fault_t ret;\n\tstruct page *page = vmf->page;\n\tunsigned int old_flags = vmf->flags;\n\n\tvmf->flags = FAULT_FLAG_WRITE|FAULT_FLAG_MKWRITE;\n\n\tret = vmf->vma->vm_ops->page_mkwrite(vmf);\n\t/* Restore original flags so that caller is not surprised */\n\tvmf->flags = old_flags;\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE)))\n\t\treturn ret;\n\tif (unlikely(!(ret & VM_FAULT_LOCKED))) {\n\t\tlock_page(page);\n\t\tif (!page->mapping) {\n\t\t\tunlock_page(page);\n\t\t\treturn 0; /* retry */\n\t\t}\n\t\tret |= VM_FAULT_LOCKED;\n\t} else\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(ret & VM_FAULT_LOCKED)"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE)"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmf->vma->vm_ops->page_mkwrite",
          "args": [
            "vmf"
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t do_page_mkwrite(struct vm_fault *vmf)\n{\n\tvm_fault_t ret;\n\tstruct page *page = vmf->page;\n\tunsigned int old_flags = vmf->flags;\n\n\tvmf->flags = FAULT_FLAG_WRITE|FAULT_FLAG_MKWRITE;\n\n\tret = vmf->vma->vm_ops->page_mkwrite(vmf);\n\t/* Restore original flags so that caller is not surprised */\n\tvmf->flags = old_flags;\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE)))\n\t\treturn ret;\n\tif (unlikely(!(ret & VM_FAULT_LOCKED))) {\n\t\tlock_page(page);\n\t\tif (!page->mapping) {\n\t\t\tunlock_page(page);\n\t\t\treturn 0; /* retry */\n\t\t}\n\t\tret |= VM_FAULT_LOCKED;\n\t} else\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\treturn ret;\n}"
  },
  {
    "function_name": "__get_fault_gfp_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "2116-2128",
    "snippet": "static gfp_t __get_fault_gfp_mask(struct vm_area_struct *vma)\n{\n\tstruct file *vm_file = vma->vm_file;\n\n\tif (vm_file)\n\t\treturn mapping_gfp_mask(vm_file->f_mapping) | __GFP_FS | __GFP_IO;\n\n\t/*\n\t * Special mappings (e.g. VDSO) do not have any file so fake\n\t * a default GFP_KERNEL for them.\n\t */\n\treturn GFP_KERNEL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapping_gfp_mask",
          "args": [
            "vm_file->f_mapping"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic gfp_t __get_fault_gfp_mask(struct vm_area_struct *vma)\n{\n\tstruct file *vm_file = vma->vm_file;\n\n\tif (vm_file)\n\t\treturn mapping_gfp_mask(vm_file->f_mapping) | __GFP_FS | __GFP_IO;\n\n\t/*\n\t * Special mappings (e.g. VDSO) do not have any file so fake\n\t * a default GFP_KERNEL for them.\n\t */\n\treturn GFP_KERNEL;\n}"
  },
  {
    "function_name": "cow_user_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "2088-2114",
    "snippet": "static inline void cow_user_page(struct page *dst, struct page *src, unsigned long va, struct vm_area_struct *vma)\n{\n\tdebug_dma_assert_idle(src);\n\n\t/*\n\t * If the source page was a PFN mapping, we don't have\n\t * a \"struct page\" for it. We do a best-effort copy by\n\t * just copying from the original user address. If that\n\t * fails, we just zero-fill it. Live with it.\n\t */\n\tif (unlikely(!src)) {\n\t\tvoid *kaddr = kmap_atomic(dst);\n\t\tvoid __user *uaddr = (void __user *)(va & PAGE_MASK);\n\n\t\t/*\n\t\t * This really shouldn't fail, because the page is there\n\t\t * in the page tables. But it might just be unreadable,\n\t\t * in which case we just give up and fill the result with\n\t\t * zeroes.\n\t\t */\n\t\tif (__copy_from_user_inatomic(kaddr, uaddr, PAGE_SIZE))\n\t\t\tclear_page(kaddr);\n\t\tkunmap_atomic(kaddr);\n\t\tflush_dcache_page(dst);\n\t} else\n\t\tcopy_user_highpage(dst, src, va, vma);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_user_highpage",
          "args": [
            "dst",
            "src",
            "va",
            "vma"
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "dst"
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page",
          "args": [
            "kaddr"
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "test_clear_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2695-2743",
          "snippet": "int test_clear_page_writeback(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\tint ret;\n\n\tmemcg = lock_page_memcg(page);\n\tlruvec = mem_cgroup_page_lruvec(page, page_pgdat(page));\n\tif (mapping && mapping_use_writeback_tags(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\t\tunsigned long flags;\n\n\t\txa_lock_irqsave(&mapping->i_pages, flags);\n\t\tret = TestClearPageWriteback(page);\n\t\tif (ret) {\n\t\t\t__xa_clear_mark(&mapping->i_pages, page_index(page),\n\t\t\t\t\t\tPAGECACHE_TAG_WRITEBACK);\n\t\t\tif (bdi_cap_account_writeback(bdi)) {\n\t\t\t\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\t\t\t\tdec_wb_stat(wb, WB_WRITEBACK);\n\t\t\t\t__wb_writeout_inc(wb);\n\t\t\t}\n\t\t}\n\n\t\tif (mapping->host && !mapping_tagged(mapping,\n\t\t\t\t\t\t     PAGECACHE_TAG_WRITEBACK))\n\t\t\tsb_clear_inode_writeback(mapping->host);\n\n\t\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\t} else {\n\t\tret = TestClearPageWriteback(page);\n\t}\n\t/*\n\t * NOTE: Page might be free now! Writeback doesn't hold a page\n\t * reference on its own, it relies on truncation to wait for\n\t * the clearing of PG_writeback. The below can only access\n\t * page state that is static across allocation cycles.\n\t */\n\tif (ret) {\n\t\tdec_lruvec_state(lruvec, NR_WRITEBACK);\n\t\tdec_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t\tinc_node_page_state(page, NR_WRITTEN);\n\t}\n\t__unlock_page_memcg(memcg);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint test_clear_page_writeback(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\tint ret;\n\n\tmemcg = lock_page_memcg(page);\n\tlruvec = mem_cgroup_page_lruvec(page, page_pgdat(page));\n\tif (mapping && mapping_use_writeback_tags(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\t\tunsigned long flags;\n\n\t\txa_lock_irqsave(&mapping->i_pages, flags);\n\t\tret = TestClearPageWriteback(page);\n\t\tif (ret) {\n\t\t\t__xa_clear_mark(&mapping->i_pages, page_index(page),\n\t\t\t\t\t\tPAGECACHE_TAG_WRITEBACK);\n\t\t\tif (bdi_cap_account_writeback(bdi)) {\n\t\t\t\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\t\t\t\tdec_wb_stat(wb, WB_WRITEBACK);\n\t\t\t\t__wb_writeout_inc(wb);\n\t\t\t}\n\t\t}\n\n\t\tif (mapping->host && !mapping_tagged(mapping,\n\t\t\t\t\t\t     PAGECACHE_TAG_WRITEBACK))\n\t\t\tsb_clear_inode_writeback(mapping->host);\n\n\t\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\t} else {\n\t\tret = TestClearPageWriteback(page);\n\t}\n\t/*\n\t * NOTE: Page might be free now! Writeback doesn't hold a page\n\t * reference on its own, it relies on truncation to wait for\n\t * the clearing of PG_writeback. The below can only access\n\t * page state that is static across allocation cycles.\n\t */\n\tif (ret) {\n\t\tdec_lruvec_state(lruvec, NR_WRITEBACK);\n\t\tdec_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t\tinc_node_page_state(page, NR_WRITTEN);\n\t}\n\t__unlock_page_memcg(memcg);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__copy_from_user_inatomic",
          "args": [
            "kaddr",
            "uaddr",
            "PAGE_SIZE"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "dst"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!src"
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_dma_assert_idle",
          "args": [
            "src"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void cow_user_page(struct page *dst, struct page *src, unsigned long va, struct vm_area_struct *vma)\n{\n\tdebug_dma_assert_idle(src);\n\n\t/*\n\t * If the source page was a PFN mapping, we don't have\n\t * a \"struct page\" for it. We do a best-effort copy by\n\t * just copying from the original user address. If that\n\t * fails, we just zero-fill it. Live with it.\n\t */\n\tif (unlikely(!src)) {\n\t\tvoid *kaddr = kmap_atomic(dst);\n\t\tvoid __user *uaddr = (void __user *)(va & PAGE_MASK);\n\n\t\t/*\n\t\t * This really shouldn't fail, because the page is there\n\t\t * in the page tables. But it might just be unreadable,\n\t\t * in which case we just give up and fill the result with\n\t\t * zeroes.\n\t\t */\n\t\tif (__copy_from_user_inatomic(kaddr, uaddr, PAGE_SIZE))\n\t\t\tclear_page(kaddr);\n\t\tkunmap_atomic(kaddr);\n\t\tflush_dcache_page(dst);\n\t} else\n\t\tcopy_user_highpage(dst, src, va, vma);\n}"
  },
  {
    "function_name": "pte_unmap_same",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "2072-2086",
    "snippet": "static inline int pte_unmap_same(struct mm_struct *mm, pmd_t *pmd,\n\t\t\t\tpte_t *page_table, pte_t orig_pte)\n{\n\tint same = 1;\n#if defined(CONFIG_SMP) || defined(CONFIG_PREEMPT)\n\tif (sizeof(pte_t) > sizeof(unsigned long)) {\n\t\tspinlock_t *ptl = pte_lockptr(mm, pmd);\n\t\tspin_lock(ptl);\n\t\tsame = pte_same(*page_table, orig_pte);\n\t\tspin_unlock(ptl);\n\t}\n#endif\n\tpte_unmap(page_table);\n\treturn same;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_unmap",
          "args": [
            "page_table"
          ],
          "line": 2084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_same",
          "args": [
            "*page_table",
            "orig_pte"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "pte_same_as_swp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1735-1738",
          "snippet": "static inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "ptl"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_lockptr",
          "args": [
            "mm",
            "pmd"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline int pte_unmap_same(struct mm_struct *mm, pmd_t *pmd,\n\t\t\t\tpte_t *page_table, pte_t orig_pte)\n{\n\tint same = 1;\n#if defined(CONFIG_SMP) || defined(CONFIG_PREEMPT)\n\tif (sizeof(pte_t) > sizeof(unsigned long)) {\n\t\tspinlock_t *ptl = pte_lockptr(mm, pmd);\n\t\tspin_lock(ptl);\n\t\tsame = pte_same(*page_table, orig_pte);\n\t\tspin_unlock(ptl);\n\t}\n#endif\n\tpte_unmap(page_table);\n\treturn same;\n}"
  },
  {
    "function_name": "apply_to_page_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "2041-2061",
    "snippet": "int apply_to_page_range(struct mm_struct *mm, unsigned long addr,\n\t\t\tunsigned long size, pte_fn_t fn, void *data)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\tunsigned long end = addr + size;\n\tint err;\n\n\tif (WARN_ON(addr >= end))\n\t\treturn -EINVAL;\n\n\tpgd = pgd_offset(mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\terr = apply_to_p4d_range(mm, pgd, addr, next, fn, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pgd++, addr = next, addr != end);\n\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "apply_to_p4d_range",
          "args": [
            "mm",
            "pgd",
            "addr",
            "next",
            "fn",
            "data"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "apply_to_p4d_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2017-2035",
          "snippet": "static int apply_to_p4d_range(struct mm_struct *mm, pgd_t *pgd,\n\t\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t\t     pte_fn_t fn, void *data)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\tint err;\n\n\tp4d = p4d_alloc(mm, pgd, addr);\n\tif (!p4d)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\terr = apply_to_pud_range(mm, p4d, addr, next, fn, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (p4d++, addr = next, addr != end);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int apply_to_p4d_range(struct mm_struct *mm, pgd_t *pgd,\n\t\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t\t     pte_fn_t fn, void *data)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\tint err;\n\n\tp4d = p4d_alloc(mm, pgd, addr);\n\tif (!p4d)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\terr = apply_to_pud_range(mm, p4d, addr, next, fn, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (p4d++, addr = next, addr != end);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgd_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_offset",
          "args": [
            "mm",
            "addr"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "addr >= end"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint apply_to_page_range(struct mm_struct *mm, unsigned long addr,\n\t\t\tunsigned long size, pte_fn_t fn, void *data)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\tunsigned long end = addr + size;\n\tint err;\n\n\tif (WARN_ON(addr >= end))\n\t\treturn -EINVAL;\n\n\tpgd = pgd_offset(mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\terr = apply_to_p4d_range(mm, pgd, addr, next, fn, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pgd++, addr = next, addr != end);\n\n\treturn err;\n}"
  },
  {
    "function_name": "apply_to_p4d_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "2017-2035",
    "snippet": "static int apply_to_p4d_range(struct mm_struct *mm, pgd_t *pgd,\n\t\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t\t     pte_fn_t fn, void *data)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\tint err;\n\n\tp4d = p4d_alloc(mm, pgd, addr);\n\tif (!p4d)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\terr = apply_to_pud_range(mm, p4d, addr, next, fn, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (p4d++, addr = next, addr != end);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "apply_to_pud_range",
          "args": [
            "mm",
            "p4d",
            "addr",
            "next",
            "fn",
            "data"
          ],
          "line": 2030
        },
        "resolved": true,
        "details": {
          "function_name": "apply_to_pud_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1997-2015",
          "snippet": "static int apply_to_pud_range(struct mm_struct *mm, p4d_t *p4d,\n\t\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t\t     pte_fn_t fn, void *data)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tint err;\n\n\tpud = pud_alloc(mm, p4d, addr);\n\tif (!pud)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\terr = apply_to_pmd_range(mm, pud, addr, next, fn, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pud++, addr = next, addr != end);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int apply_to_pud_range(struct mm_struct *mm, p4d_t *p4d,\n\t\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t\t     pte_fn_t fn, void *data)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tint err;\n\n\tpud = pud_alloc(mm, p4d, addr);\n\tif (!pud)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\terr = apply_to_pmd_range(mm, pud, addr, next, fn, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pud++, addr = next, addr != end);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p4d_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_alloc",
          "args": [
            "mm",
            "pgd",
            "addr"
          ],
          "line": 2025
        },
        "resolved": true,
        "details": {
          "function_name": "__p4d_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3949-3964",
          "snippet": "int __p4d_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)\n{\n\tp4d_t *new = p4d_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n\tif (pgd_present(*pgd))\t\t/* Another has populated it */\n\t\tp4d_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pgd, new);\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __p4d_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)\n{\n\tp4d_t *new = p4d_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n\tif (pgd_present(*pgd))\t\t/* Another has populated it */\n\t\tp4d_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pgd, new);\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int apply_to_p4d_range(struct mm_struct *mm, pgd_t *pgd,\n\t\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t\t     pte_fn_t fn, void *data)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\tint err;\n\n\tp4d = p4d_alloc(mm, pgd, addr);\n\tif (!p4d)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\terr = apply_to_pud_range(mm, p4d, addr, next, fn, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (p4d++, addr = next, addr != end);\n\treturn err;\n}"
  },
  {
    "function_name": "apply_to_pud_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1997-2015",
    "snippet": "static int apply_to_pud_range(struct mm_struct *mm, p4d_t *p4d,\n\t\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t\t     pte_fn_t fn, void *data)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tint err;\n\n\tpud = pud_alloc(mm, p4d, addr);\n\tif (!pud)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\terr = apply_to_pmd_range(mm, pud, addr, next, fn, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pud++, addr = next, addr != end);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "apply_to_pmd_range",
          "args": [
            "mm",
            "pud",
            "addr",
            "next",
            "fn",
            "data"
          ],
          "line": 2010
        },
        "resolved": true,
        "details": {
          "function_name": "apply_to_pmd_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1975-1995",
          "snippet": "static int apply_to_pmd_range(struct mm_struct *mm, pud_t *pud,\n\t\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t\t     pte_fn_t fn, void *data)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tint err;\n\n\tBUG_ON(pud_huge(*pud));\n\n\tpmd = pmd_alloc(mm, pud, addr);\n\tif (!pmd)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\terr = apply_to_pte_range(mm, pmd, addr, next, fn, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pmd++, addr = next, addr != end);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int apply_to_pmd_range(struct mm_struct *mm, pud_t *pud,\n\t\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t\t     pte_fn_t fn, void *data)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tint err;\n\n\tBUG_ON(pud_huge(*pud));\n\n\tpmd = pmd_alloc(mm, pud, addr);\n\tif (!pmd)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\terr = apply_to_pte_range(mm, pmd, addr, next, fn, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pmd++, addr = next, addr != end);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pud_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_alloc",
          "args": [
            "mm",
            "p4d",
            "addr"
          ],
          "line": 2005
        },
        "resolved": true,
        "details": {
          "function_name": "__pud_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3972-3996",
          "snippet": "int __pud_alloc(struct mm_struct *mm, p4d_t *p4d, unsigned long address)\n{\n\tpud_t *new = pud_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_5LEVEL_HACK\n\tif (!p4d_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tp4d_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#else\n\tif (!pgd_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tpgd_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#endif /* __ARCH_HAS_5LEVEL_HACK */\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pud_alloc(struct mm_struct *mm, p4d_t *p4d, unsigned long address)\n{\n\tpud_t *new = pud_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_5LEVEL_HACK\n\tif (!p4d_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tp4d_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#else\n\tif (!pgd_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tpgd_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#endif /* __ARCH_HAS_5LEVEL_HACK */\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int apply_to_pud_range(struct mm_struct *mm, p4d_t *p4d,\n\t\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t\t     pte_fn_t fn, void *data)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tint err;\n\n\tpud = pud_alloc(mm, p4d, addr);\n\tif (!pud)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\terr = apply_to_pmd_range(mm, pud, addr, next, fn, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pud++, addr = next, addr != end);\n\treturn err;\n}"
  },
  {
    "function_name": "apply_to_pmd_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1975-1995",
    "snippet": "static int apply_to_pmd_range(struct mm_struct *mm, pud_t *pud,\n\t\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t\t     pte_fn_t fn, void *data)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tint err;\n\n\tBUG_ON(pud_huge(*pud));\n\n\tpmd = pmd_alloc(mm, pud, addr);\n\tif (!pmd)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\terr = apply_to_pte_range(mm, pmd, addr, next, fn, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pmd++, addr = next, addr != end);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "apply_to_pte_range",
          "args": [
            "mm",
            "pmd",
            "addr",
            "next",
            "fn",
            "data"
          ],
          "line": 1990
        },
        "resolved": true,
        "details": {
          "function_name": "apply_to_pte_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1941-1973",
          "snippet": "static int apply_to_pte_range(struct mm_struct *mm, pmd_t *pmd,\n\t\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t\t     pte_fn_t fn, void *data)\n{\n\tpte_t *pte;\n\tint err;\n\tpgtable_t token;\n\tspinlock_t *uninitialized_var(ptl);\n\n\tpte = (mm == &init_mm) ?\n\t\tpte_alloc_kernel(pmd, addr) :\n\t\tpte_alloc_map_lock(mm, pmd, addr, &ptl);\n\tif (!pte)\n\t\treturn -ENOMEM;\n\n\tBUG_ON(pmd_huge(*pmd));\n\n\tarch_enter_lazy_mmu_mode();\n\n\ttoken = pmd_pgtable(*pmd);\n\n\tdo {\n\t\terr = fn(pte++, token, addr, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\tarch_leave_lazy_mmu_mode();\n\n\tif (mm != &init_mm)\n\t\tpte_unmap_unlock(pte-1, ptl);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int apply_to_pte_range(struct mm_struct *mm, pmd_t *pmd,\n\t\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t\t     pte_fn_t fn, void *data)\n{\n\tpte_t *pte;\n\tint err;\n\tpgtable_t token;\n\tspinlock_t *uninitialized_var(ptl);\n\n\tpte = (mm == &init_mm) ?\n\t\tpte_alloc_kernel(pmd, addr) :\n\t\tpte_alloc_map_lock(mm, pmd, addr, &ptl);\n\tif (!pte)\n\t\treturn -ENOMEM;\n\n\tBUG_ON(pmd_huge(*pmd));\n\n\tarch_enter_lazy_mmu_mode();\n\n\ttoken = pmd_pgtable(*pmd);\n\n\tdo {\n\t\terr = fn(pte++, token, addr, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\tarch_leave_lazy_mmu_mode();\n\n\tif (mm != &init_mm)\n\t\tpte_unmap_unlock(pte-1, ptl);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_alloc",
          "args": [
            "mm",
            "pud",
            "addr"
          ],
          "line": 1985
        },
        "resolved": true,
        "details": {
          "function_name": "__pmd_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "4004-4029",
          "snippet": "int __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tptl = pud_lock(mm, pud);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (!pud_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpud_populate(mm, pud, new);\n\t} else\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n#else\n\tif (!pgd_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpgd_populate(mm, pud, new);\n\t} else /* Another has populated it */\n\t\tpmd_free(mm, new);\n#endif /* __ARCH_HAS_4LEVEL_HACK */\n\tspin_unlock(ptl);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tptl = pud_lock(mm, pud);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (!pud_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpud_populate(mm, pud, new);\n\t} else\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n#else\n\tif (!pgd_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpgd_populate(mm, pud, new);\n\t} else /* Another has populated it */\n\t\tpmd_free(mm, new);\n#endif /* __ARCH_HAS_4LEVEL_HACK */\n\tspin_unlock(ptl);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pud_huge(*pud)"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_huge",
          "args": [
            "*pud"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int apply_to_pmd_range(struct mm_struct *mm, pud_t *pud,\n\t\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t\t     pte_fn_t fn, void *data)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tint err;\n\n\tBUG_ON(pud_huge(*pud));\n\n\tpmd = pmd_alloc(mm, pud, addr);\n\tif (!pmd)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\terr = apply_to_pte_range(mm, pmd, addr, next, fn, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pmd++, addr = next, addr != end);\n\treturn err;\n}"
  },
  {
    "function_name": "apply_to_pte_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1941-1973",
    "snippet": "static int apply_to_pte_range(struct mm_struct *mm, pmd_t *pmd,\n\t\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t\t     pte_fn_t fn, void *data)\n{\n\tpte_t *pte;\n\tint err;\n\tpgtable_t token;\n\tspinlock_t *uninitialized_var(ptl);\n\n\tpte = (mm == &init_mm) ?\n\t\tpte_alloc_kernel(pmd, addr) :\n\t\tpte_alloc_map_lock(mm, pmd, addr, &ptl);\n\tif (!pte)\n\t\treturn -ENOMEM;\n\n\tBUG_ON(pmd_huge(*pmd));\n\n\tarch_enter_lazy_mmu_mode();\n\n\ttoken = pmd_pgtable(*pmd);\n\n\tdo {\n\t\terr = fn(pte++, token, addr, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\tarch_leave_lazy_mmu_mode();\n\n\tif (mm != &init_mm)\n\t\tpte_unmap_unlock(pte-1, ptl);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "pte-1",
            "ptl"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_leave_lazy_mmu_mode",
          "args": [],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "pte++",
            "token",
            "addr",
            "data"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "vmf_insert_pfn_prot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1593-1618",
          "snippet": "vm_fault_t vmf_insert_pfn_prot(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tunsigned long pfn, pgprot_t pgprot)\n{\n\t/*\n\t * Technically, architectures with pte_special can avoid all these\n\t * restrictions (same for remap_pfn_range).  However we would like\n\t * consistency in testing and feature parity among all, so we should\n\t * try to keep these invariants in place for everybody.\n\t */\n\tBUG_ON(!(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)));\n\tBUG_ON((vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) ==\n\t\t\t\t\t\t(VM_PFNMAP|VM_MIXEDMAP));\n\tBUG_ON((vma->vm_flags & VM_PFNMAP) && is_cow_mapping(vma->vm_flags));\n\tBUG_ON((vma->vm_flags & VM_MIXEDMAP) && pfn_valid(pfn));\n\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn VM_FAULT_SIGBUS;\n\n\tif (!pfn_modify_allowed(pfn, pgprot))\n\t\treturn VM_FAULT_SIGBUS;\n\n\ttrack_pfn_insert(vma, &pgprot, __pfn_to_pfn_t(pfn, PFN_DEV));\n\n\treturn insert_pfn(vma, addr, __pfn_to_pfn_t(pfn, PFN_DEV), pgprot,\n\t\t\tfalse);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvm_fault_t vmf_insert_pfn_prot(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tunsigned long pfn, pgprot_t pgprot)\n{\n\t/*\n\t * Technically, architectures with pte_special can avoid all these\n\t * restrictions (same for remap_pfn_range).  However we would like\n\t * consistency in testing and feature parity among all, so we should\n\t * try to keep these invariants in place for everybody.\n\t */\n\tBUG_ON(!(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)));\n\tBUG_ON((vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) ==\n\t\t\t\t\t\t(VM_PFNMAP|VM_MIXEDMAP));\n\tBUG_ON((vma->vm_flags & VM_PFNMAP) && is_cow_mapping(vma->vm_flags));\n\tBUG_ON((vma->vm_flags & VM_MIXEDMAP) && pfn_valid(pfn));\n\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn VM_FAULT_SIGBUS;\n\n\tif (!pfn_modify_allowed(pfn, pgprot))\n\t\treturn VM_FAULT_SIGBUS;\n\n\ttrack_pfn_insert(vma, &pgprot, __pfn_to_pfn_t(pfn, PFN_DEV));\n\n\treturn insert_pfn(vma, addr, __pfn_to_pfn_t(pfn, PFN_DEV), pgprot,\n\t\t\tfalse);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_pgtable",
          "args": [
            "*pmd"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_enter_lazy_mmu_mode",
          "args": [],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pmd_huge(*pmd)"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_huge",
          "args": [
            "*pmd"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_alloc_map_lock",
          "args": [
            "mm",
            "pmd",
            "addr",
            "&ptl"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_alloc_kernel",
          "args": [
            "pmd",
            "addr"
          ],
          "line": 1951
        },
        "resolved": true,
        "details": {
          "function_name": "__pte_alloc_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "437-454",
          "snippet": "int __pte_alloc_kernel(pmd_t *pmd, unsigned long address)\n{\n\tpte_t *new = pte_alloc_one_kernel(&init_mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&init_mm.page_table_lock);\n\tif (likely(pmd_none(*pmd))) {\t/* Has another populated it ? */\n\t\tpmd_populate_kernel(&init_mm, pmd, new);\n\t\tnew = NULL;\n\t}\n\tspin_unlock(&init_mm.page_table_lock);\n\tif (new)\n\t\tpte_free_kernel(&init_mm, new);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pte_alloc_kernel(pmd_t *pmd, unsigned long address)\n{\n\tpte_t *new = pte_alloc_one_kernel(&init_mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&init_mm.page_table_lock);\n\tif (likely(pmd_none(*pmd))) {\t/* Has another populated it ? */\n\t\tpmd_populate_kernel(&init_mm, pmd, new);\n\t\tnew = NULL;\n\t}\n\tspin_unlock(&init_mm.page_table_lock);\n\tif (new)\n\t\tpte_free_kernel(&init_mm, new);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int apply_to_pte_range(struct mm_struct *mm, pmd_t *pmd,\n\t\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t\t     pte_fn_t fn, void *data)\n{\n\tpte_t *pte;\n\tint err;\n\tpgtable_t token;\n\tspinlock_t *uninitialized_var(ptl);\n\n\tpte = (mm == &init_mm) ?\n\t\tpte_alloc_kernel(pmd, addr) :\n\t\tpte_alloc_map_lock(mm, pmd, addr, &ptl);\n\tif (!pte)\n\t\treturn -ENOMEM;\n\n\tBUG_ON(pmd_huge(*pmd));\n\n\tarch_enter_lazy_mmu_mode();\n\n\ttoken = pmd_pgtable(*pmd);\n\n\tdo {\n\t\terr = fn(pte++, token, addr, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\tarch_leave_lazy_mmu_mode();\n\n\tif (mm != &init_mm)\n\t\tpte_unmap_unlock(pte-1, ptl);\n\treturn err;\n}"
  },
  {
    "function_name": "vm_iomap_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1907-1938",
    "snippet": "int vm_iomap_memory(struct vm_area_struct *vma, phys_addr_t start, unsigned long len)\n{\n\tunsigned long vm_len, pfn, pages;\n\n\t/* Check that the physical memory area passed in looks valid */\n\tif (start + len < start)\n\t\treturn -EINVAL;\n\t/*\n\t * You *really* shouldn't map things that aren't page-aligned,\n\t * but we've historically allowed it because IO memory might\n\t * just have smaller alignment.\n\t */\n\tlen += start & ~PAGE_MASK;\n\tpfn = start >> PAGE_SHIFT;\n\tpages = (len + ~PAGE_MASK) >> PAGE_SHIFT;\n\tif (pfn + pages < pfn)\n\t\treturn -EINVAL;\n\n\t/* We start the mapping 'vm_pgoff' pages into the area */\n\tif (vma->vm_pgoff > pages)\n\t\treturn -EINVAL;\n\tpfn += vma->vm_pgoff;\n\tpages -= vma->vm_pgoff;\n\n\t/* Can we fit all of the mapping? */\n\tvm_len = vma->vm_end - vma->vm_start;\n\tif (vm_len >> PAGE_SHIFT > pages)\n\t\treturn -EINVAL;\n\n\t/* Ok, let it rip */\n\treturn io_remap_pfn_range(vma, vma->vm_start, pfn, vm_len, vma->vm_page_prot);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "io_remap_pfn_range",
          "args": [
            "vma",
            "vma->vm_start",
            "pfn",
            "vm_len",
            "vma->vm_page_prot"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint vm_iomap_memory(struct vm_area_struct *vma, phys_addr_t start, unsigned long len)\n{\n\tunsigned long vm_len, pfn, pages;\n\n\t/* Check that the physical memory area passed in looks valid */\n\tif (start + len < start)\n\t\treturn -EINVAL;\n\t/*\n\t * You *really* shouldn't map things that aren't page-aligned,\n\t * but we've historically allowed it because IO memory might\n\t * just have smaller alignment.\n\t */\n\tlen += start & ~PAGE_MASK;\n\tpfn = start >> PAGE_SHIFT;\n\tpages = (len + ~PAGE_MASK) >> PAGE_SHIFT;\n\tif (pfn + pages < pfn)\n\t\treturn -EINVAL;\n\n\t/* We start the mapping 'vm_pgoff' pages into the area */\n\tif (vma->vm_pgoff > pages)\n\t\treturn -EINVAL;\n\tpfn += vma->vm_pgoff;\n\tpages -= vma->vm_pgoff;\n\n\t/* Can we fit all of the mapping? */\n\tvm_len = vma->vm_end - vma->vm_start;\n\tif (vm_len >> PAGE_SHIFT > pages)\n\t\treturn -EINVAL;\n\n\t/* Ok, let it rip */\n\treturn io_remap_pfn_range(vma, vma->vm_start, pfn, vm_len, vma->vm_page_prot);\n}"
  },
  {
    "function_name": "remap_pfn_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1835-1891",
    "snippet": "int remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,\n\t\t    unsigned long pfn, unsigned long size, pgprot_t prot)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\tunsigned long end = addr + PAGE_ALIGN(size);\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long remap_pfn = pfn;\n\tint err;\n\n\t/*\n\t * Physically remapped pages are special. Tell the\n\t * rest of the world about it:\n\t *   VM_IO tells people not to look at these pages\n\t *\t(accesses can have side effects).\n\t *   VM_PFNMAP tells the core MM that the base pages are just\n\t *\traw PFN mappings, and do not have a \"struct page\" associated\n\t *\twith them.\n\t *   VM_DONTEXPAND\n\t *      Disable vma merging and expanding with mremap().\n\t *   VM_DONTDUMP\n\t *      Omit vma from core dump, even when VM_IO turned off.\n\t *\n\t * There's a horrible special case to handle copy-on-write\n\t * behaviour that some programs depend on. We mark the \"original\"\n\t * un-COW'ed pages by matching them up with \"vma->vm_pgoff\".\n\t * See vm_normal_page() for details.\n\t */\n\tif (is_cow_mapping(vma->vm_flags)) {\n\t\tif (addr != vma->vm_start || end != vma->vm_end)\n\t\t\treturn -EINVAL;\n\t\tvma->vm_pgoff = pfn;\n\t}\n\n\terr = track_pfn_remap(vma, &prot, remap_pfn, addr, PAGE_ALIGN(size));\n\tif (err)\n\t\treturn -EINVAL;\n\n\tvma->vm_flags |= VM_IO | VM_PFNMAP | VM_DONTEXPAND | VM_DONTDUMP;\n\n\tBUG_ON(addr >= end);\n\tpfn -= addr >> PAGE_SHIFT;\n\tpgd = pgd_offset(mm, addr);\n\tflush_cache_range(vma, addr, end);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\terr = remap_p4d_range(mm, pgd, addr, next,\n\t\t\t\tpfn + (addr >> PAGE_SHIFT), prot);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pgd++, addr = next, addr != end);\n\n\tif (err)\n\t\tuntrack_pfn(vma, remap_pfn, PAGE_ALIGN(size));\n\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "untrack_pfn",
          "args": [
            "vma",
            "remap_pfn",
            "PAGE_ALIGN(size)"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remap_p4d_range",
          "args": [
            "mm",
            "pgd",
            "addr",
            "next",
            "pfn + (addr >> PAGE_SHIFT)",
            "prot"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "remap_p4d_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1803-1823",
          "snippet": "static inline int remap_p4d_range(struct mm_struct *mm, pgd_t *pgd,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\tint err;\n\n\tpfn -= addr >> PAGE_SHIFT;\n\tp4d = p4d_alloc(mm, pgd, addr);\n\tif (!p4d)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\terr = remap_pud_range(mm, p4d, addr, next,\n\t\t\t\tpfn + (addr >> PAGE_SHIFT), prot);\n\t\tif (err)\n\t\t\treturn err;\n\t} while (p4d++, addr = next, addr != end);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline int remap_p4d_range(struct mm_struct *mm, pgd_t *pgd,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\tint err;\n\n\tpfn -= addr >> PAGE_SHIFT;\n\tp4d = p4d_alloc(mm, pgd, addr);\n\tif (!p4d)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\terr = remap_pud_range(mm, p4d, addr, next,\n\t\t\t\tpfn + (addr >> PAGE_SHIFT), prot);\n\t\tif (err)\n\t\t\treturn err;\n\t} while (p4d++, addr = next, addr != end);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgd_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_cache_range",
          "args": [
            "vma",
            "addr",
            "end"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_offset",
          "args": [
            "mm",
            "addr"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "addr >= end"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track_pfn_remap",
          "args": [
            "vma",
            "&prot",
            "remap_pfn",
            "addr",
            "PAGE_ALIGN(size)"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_cow_mapping",
          "args": [
            "vma->vm_flags"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "is_cow_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "247-250",
          "snippet": "static inline bool is_cow_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline bool is_cow_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,\n\t\t    unsigned long pfn, unsigned long size, pgprot_t prot)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\tunsigned long end = addr + PAGE_ALIGN(size);\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long remap_pfn = pfn;\n\tint err;\n\n\t/*\n\t * Physically remapped pages are special. Tell the\n\t * rest of the world about it:\n\t *   VM_IO tells people not to look at these pages\n\t *\t(accesses can have side effects).\n\t *   VM_PFNMAP tells the core MM that the base pages are just\n\t *\traw PFN mappings, and do not have a \"struct page\" associated\n\t *\twith them.\n\t *   VM_DONTEXPAND\n\t *      Disable vma merging and expanding with mremap().\n\t *   VM_DONTDUMP\n\t *      Omit vma from core dump, even when VM_IO turned off.\n\t *\n\t * There's a horrible special case to handle copy-on-write\n\t * behaviour that some programs depend on. We mark the \"original\"\n\t * un-COW'ed pages by matching them up with \"vma->vm_pgoff\".\n\t * See vm_normal_page() for details.\n\t */\n\tif (is_cow_mapping(vma->vm_flags)) {\n\t\tif (addr != vma->vm_start || end != vma->vm_end)\n\t\t\treturn -EINVAL;\n\t\tvma->vm_pgoff = pfn;\n\t}\n\n\terr = track_pfn_remap(vma, &prot, remap_pfn, addr, PAGE_ALIGN(size));\n\tif (err)\n\t\treturn -EINVAL;\n\n\tvma->vm_flags |= VM_IO | VM_PFNMAP | VM_DONTEXPAND | VM_DONTDUMP;\n\n\tBUG_ON(addr >= end);\n\tpfn -= addr >> PAGE_SHIFT;\n\tpgd = pgd_offset(mm, addr);\n\tflush_cache_range(vma, addr, end);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\terr = remap_p4d_range(mm, pgd, addr, next,\n\t\t\t\tpfn + (addr >> PAGE_SHIFT), prot);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pgd++, addr = next, addr != end);\n\n\tif (err)\n\t\tuntrack_pfn(vma, remap_pfn, PAGE_ALIGN(size));\n\n\treturn err;\n}"
  },
  {
    "function_name": "remap_p4d_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1803-1823",
    "snippet": "static inline int remap_p4d_range(struct mm_struct *mm, pgd_t *pgd,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\tint err;\n\n\tpfn -= addr >> PAGE_SHIFT;\n\tp4d = p4d_alloc(mm, pgd, addr);\n\tif (!p4d)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\terr = remap_pud_range(mm, p4d, addr, next,\n\t\t\t\tpfn + (addr >> PAGE_SHIFT), prot);\n\t\tif (err)\n\t\t\treturn err;\n\t} while (p4d++, addr = next, addr != end);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remap_pud_range",
          "args": [
            "mm",
            "p4d",
            "addr",
            "next",
            "pfn + (addr >> PAGE_SHIFT)",
            "prot"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "remap_pud_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1781-1801",
          "snippet": "static inline int remap_pud_range(struct mm_struct *mm, p4d_t *p4d,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tint err;\n\n\tpfn -= addr >> PAGE_SHIFT;\n\tpud = pud_alloc(mm, p4d, addr);\n\tif (!pud)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\terr = remap_pmd_range(mm, pud, addr, next,\n\t\t\t\tpfn + (addr >> PAGE_SHIFT), prot);\n\t\tif (err)\n\t\t\treturn err;\n\t} while (pud++, addr = next, addr != end);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline int remap_pud_range(struct mm_struct *mm, p4d_t *p4d,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tint err;\n\n\tpfn -= addr >> PAGE_SHIFT;\n\tpud = pud_alloc(mm, p4d, addr);\n\tif (!pud)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\terr = remap_pmd_range(mm, pud, addr, next,\n\t\t\t\tpfn + (addr >> PAGE_SHIFT), prot);\n\t\tif (err)\n\t\t\treturn err;\n\t} while (pud++, addr = next, addr != end);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p4d_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_alloc",
          "args": [
            "mm",
            "pgd",
            "addr"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "__p4d_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3949-3964",
          "snippet": "int __p4d_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)\n{\n\tp4d_t *new = p4d_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n\tif (pgd_present(*pgd))\t\t/* Another has populated it */\n\t\tp4d_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pgd, new);\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __p4d_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)\n{\n\tp4d_t *new = p4d_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n\tif (pgd_present(*pgd))\t\t/* Another has populated it */\n\t\tp4d_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pgd, new);\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline int remap_p4d_range(struct mm_struct *mm, pgd_t *pgd,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\tint err;\n\n\tpfn -= addr >> PAGE_SHIFT;\n\tp4d = p4d_alloc(mm, pgd, addr);\n\tif (!p4d)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\terr = remap_pud_range(mm, p4d, addr, next,\n\t\t\t\tpfn + (addr >> PAGE_SHIFT), prot);\n\t\tif (err)\n\t\t\treturn err;\n\t} while (p4d++, addr = next, addr != end);\n\treturn 0;\n}"
  },
  {
    "function_name": "remap_pud_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1781-1801",
    "snippet": "static inline int remap_pud_range(struct mm_struct *mm, p4d_t *p4d,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tint err;\n\n\tpfn -= addr >> PAGE_SHIFT;\n\tpud = pud_alloc(mm, p4d, addr);\n\tif (!pud)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\terr = remap_pmd_range(mm, pud, addr, next,\n\t\t\t\tpfn + (addr >> PAGE_SHIFT), prot);\n\t\tif (err)\n\t\t\treturn err;\n\t} while (pud++, addr = next, addr != end);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remap_pmd_range",
          "args": [
            "mm",
            "pud",
            "addr",
            "next",
            "pfn + (addr >> PAGE_SHIFT)",
            "prot"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "remap_pmd_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1758-1779",
          "snippet": "static inline int remap_pmd_range(struct mm_struct *mm, pud_t *pud,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tint err;\n\n\tpfn -= addr >> PAGE_SHIFT;\n\tpmd = pmd_alloc(mm, pud, addr);\n\tif (!pmd)\n\t\treturn -ENOMEM;\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\terr = remap_pte_range(mm, pmd, addr, next,\n\t\t\t\tpfn + (addr >> PAGE_SHIFT), prot);\n\t\tif (err)\n\t\t\treturn err;\n\t} while (pmd++, addr = next, addr != end);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline int remap_pmd_range(struct mm_struct *mm, pud_t *pud,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tint err;\n\n\tpfn -= addr >> PAGE_SHIFT;\n\tpmd = pmd_alloc(mm, pud, addr);\n\tif (!pmd)\n\t\treturn -ENOMEM;\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\terr = remap_pte_range(mm, pmd, addr, next,\n\t\t\t\tpfn + (addr >> PAGE_SHIFT), prot);\n\t\tif (err)\n\t\t\treturn err;\n\t} while (pmd++, addr = next, addr != end);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pud_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_alloc",
          "args": [
            "mm",
            "p4d",
            "addr"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "__pud_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3972-3996",
          "snippet": "int __pud_alloc(struct mm_struct *mm, p4d_t *p4d, unsigned long address)\n{\n\tpud_t *new = pud_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_5LEVEL_HACK\n\tif (!p4d_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tp4d_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#else\n\tif (!pgd_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tpgd_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#endif /* __ARCH_HAS_5LEVEL_HACK */\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pud_alloc(struct mm_struct *mm, p4d_t *p4d, unsigned long address)\n{\n\tpud_t *new = pud_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_5LEVEL_HACK\n\tif (!p4d_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tp4d_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#else\n\tif (!pgd_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tpgd_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#endif /* __ARCH_HAS_5LEVEL_HACK */\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline int remap_pud_range(struct mm_struct *mm, p4d_t *p4d,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tint err;\n\n\tpfn -= addr >> PAGE_SHIFT;\n\tpud = pud_alloc(mm, p4d, addr);\n\tif (!pud)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\terr = remap_pmd_range(mm, pud, addr, next,\n\t\t\t\tpfn + (addr >> PAGE_SHIFT), prot);\n\t\tif (err)\n\t\t\treturn err;\n\t} while (pud++, addr = next, addr != end);\n\treturn 0;\n}"
  },
  {
    "function_name": "remap_pmd_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1758-1779",
    "snippet": "static inline int remap_pmd_range(struct mm_struct *mm, pud_t *pud,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tint err;\n\n\tpfn -= addr >> PAGE_SHIFT;\n\tpmd = pmd_alloc(mm, pud, addr);\n\tif (!pmd)\n\t\treturn -ENOMEM;\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\terr = remap_pte_range(mm, pmd, addr, next,\n\t\t\t\tpfn + (addr >> PAGE_SHIFT), prot);\n\t\tif (err)\n\t\t\treturn err;\n\t} while (pmd++, addr = next, addr != end);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remap_pte_range",
          "args": [
            "mm",
            "pmd",
            "addr",
            "next",
            "pfn + (addr >> PAGE_SHIFT)",
            "prot"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "remap_pte_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1732-1756",
          "snippet": "static int remap_pte_range(struct mm_struct *mm, pmd_t *pmd,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\tint err = 0;\n\n\tpte = pte_alloc_map_lock(mm, pmd, addr, &ptl);\n\tif (!pte)\n\t\treturn -ENOMEM;\n\tarch_enter_lazy_mmu_mode();\n\tdo {\n\t\tBUG_ON(!pte_none(*pte));\n\t\tif (!pfn_modify_allowed(pfn, prot)) {\n\t\t\terr = -EACCES;\n\t\t\tbreak;\n\t\t}\n\t\tset_pte_at(mm, addr, pte, pte_mkspecial(pfn_pte(pfn, prot)));\n\t\tpfn++;\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\tarch_leave_lazy_mmu_mode();\n\tpte_unmap_unlock(pte - 1, ptl);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int remap_pte_range(struct mm_struct *mm, pmd_t *pmd,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\tint err = 0;\n\n\tpte = pte_alloc_map_lock(mm, pmd, addr, &ptl);\n\tif (!pte)\n\t\treturn -ENOMEM;\n\tarch_enter_lazy_mmu_mode();\n\tdo {\n\t\tBUG_ON(!pte_none(*pte));\n\t\tif (!pfn_modify_allowed(pfn, prot)) {\n\t\t\terr = -EACCES;\n\t\t\tbreak;\n\t\t}\n\t\tset_pte_at(mm, addr, pte, pte_mkspecial(pfn_pte(pfn, prot)));\n\t\tpfn++;\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\tarch_leave_lazy_mmu_mode();\n\tpte_unmap_unlock(pte - 1, ptl);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "pmd_trans_huge(*pmd)"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "*pmd"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_alloc",
          "args": [
            "mm",
            "pud",
            "addr"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "__pmd_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "4004-4029",
          "snippet": "int __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tptl = pud_lock(mm, pud);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (!pud_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpud_populate(mm, pud, new);\n\t} else\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n#else\n\tif (!pgd_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpgd_populate(mm, pud, new);\n\t} else /* Another has populated it */\n\t\tpmd_free(mm, new);\n#endif /* __ARCH_HAS_4LEVEL_HACK */\n\tspin_unlock(ptl);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tptl = pud_lock(mm, pud);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (!pud_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpud_populate(mm, pud, new);\n\t} else\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n#else\n\tif (!pgd_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpgd_populate(mm, pud, new);\n\t} else /* Another has populated it */\n\t\tpmd_free(mm, new);\n#endif /* __ARCH_HAS_4LEVEL_HACK */\n\tspin_unlock(ptl);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline int remap_pmd_range(struct mm_struct *mm, pud_t *pud,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tint err;\n\n\tpfn -= addr >> PAGE_SHIFT;\n\tpmd = pmd_alloc(mm, pud, addr);\n\tif (!pmd)\n\t\treturn -ENOMEM;\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\terr = remap_pte_range(mm, pmd, addr, next,\n\t\t\t\tpfn + (addr >> PAGE_SHIFT), prot);\n\t\tif (err)\n\t\t\treturn err;\n\t} while (pmd++, addr = next, addr != end);\n\treturn 0;\n}"
  },
  {
    "function_name": "remap_pte_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1732-1756",
    "snippet": "static int remap_pte_range(struct mm_struct *mm, pmd_t *pmd,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\tint err = 0;\n\n\tpte = pte_alloc_map_lock(mm, pmd, addr, &ptl);\n\tif (!pte)\n\t\treturn -ENOMEM;\n\tarch_enter_lazy_mmu_mode();\n\tdo {\n\t\tBUG_ON(!pte_none(*pte));\n\t\tif (!pfn_modify_allowed(pfn, prot)) {\n\t\t\terr = -EACCES;\n\t\t\tbreak;\n\t\t}\n\t\tset_pte_at(mm, addr, pte, pte_mkspecial(pfn_pte(pfn, prot)));\n\t\tpfn++;\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\tarch_leave_lazy_mmu_mode();\n\tpte_unmap_unlock(pte - 1, ptl);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "pte - 1",
            "ptl"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_leave_lazy_mmu_mode",
          "args": [],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "mm",
            "addr",
            "pte",
            "pte_mkspecial(pfn_pte(pfn, prot))"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkspecial",
          "args": [
            "pfn_pte(pfn, prot)"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_pte",
          "args": [
            "pfn",
            "prot"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_modify_allowed",
          "args": [
            "pfn",
            "prot"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!pte_none(*pte)"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "*pte"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_enter_lazy_mmu_mode",
          "args": [],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_alloc_map_lock",
          "args": [
            "mm",
            "pmd",
            "addr",
            "&ptl"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int remap_pte_range(struct mm_struct *mm, pmd_t *pmd,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\tint err = 0;\n\n\tpte = pte_alloc_map_lock(mm, pmd, addr, &ptl);\n\tif (!pte)\n\t\treturn -ENOMEM;\n\tarch_enter_lazy_mmu_mode();\n\tdo {\n\t\tBUG_ON(!pte_none(*pte));\n\t\tif (!pfn_modify_allowed(pfn, prot)) {\n\t\t\terr = -EACCES;\n\t\t\tbreak;\n\t\t}\n\t\tset_pte_at(mm, addr, pte, pte_mkspecial(pfn_pte(pfn, prot)));\n\t\tpfn++;\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\tarch_leave_lazy_mmu_mode();\n\tpte_unmap_unlock(pte - 1, ptl);\n\treturn err;\n}"
  },
  {
    "function_name": "vmf_insert_mixed_mkwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1720-1724",
    "snippet": "vm_fault_t vmf_insert_mixed_mkwrite(struct vm_area_struct *vma,\n\t\tunsigned long addr, pfn_t pfn)\n{\n\treturn __vm_insert_mixed(vma, addr, pfn, true);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vm_insert_mixed",
          "args": [
            "vma",
            "addr",
            "pfn",
            "true"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "__vm_insert_mixed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1662-1706",
          "snippet": "static vm_fault_t __vm_insert_mixed(struct vm_area_struct *vma,\n\t\tunsigned long addr, pfn_t pfn, bool mkwrite)\n{\n\tpgprot_t pgprot = vma->vm_page_prot;\n\tint err;\n\n\tBUG_ON(!vm_mixed_ok(vma, pfn));\n\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn VM_FAULT_SIGBUS;\n\n\ttrack_pfn_insert(vma, &pgprot, pfn);\n\n\tif (!pfn_modify_allowed(pfn_t_to_pfn(pfn), pgprot))\n\t\treturn VM_FAULT_SIGBUS;\n\n\t/*\n\t * If we don't have pte special, then we have to use the pfn_valid()\n\t * based VM_MIXEDMAP scheme (see vm_normal_page), and thus we *must*\n\t * refcount the page if pfn_valid is true (hence insert_page rather\n\t * than insert_pfn).  If a zero_pfn were inserted into a VM_MIXEDMAP\n\t * without pte special, it would there be refcounted as a normal page.\n\t */\n\tif (!IS_ENABLED(CONFIG_ARCH_HAS_PTE_SPECIAL) &&\n\t    !pfn_t_devmap(pfn) && pfn_t_valid(pfn)) {\n\t\tstruct page *page;\n\n\t\t/*\n\t\t * At this point we are committed to insert_page()\n\t\t * regardless of whether the caller specified flags that\n\t\t * result in pfn_t_has_page() == false.\n\t\t */\n\t\tpage = pfn_to_page(pfn_t_to_pfn(pfn));\n\t\terr = insert_page(vma, addr, page, pgprot);\n\t} else {\n\t\treturn insert_pfn(vma, addr, pfn, pgprot, mkwrite);\n\t}\n\n\tif (err == -ENOMEM)\n\t\treturn VM_FAULT_OOM;\n\tif (err < 0 && err != -EBUSY)\n\t\treturn VM_FAULT_SIGBUS;\n\n\treturn VM_FAULT_NOPAGE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t __vm_insert_mixed(struct vm_area_struct *vma,\n\t\tunsigned long addr, pfn_t pfn, bool mkwrite)\n{\n\tpgprot_t pgprot = vma->vm_page_prot;\n\tint err;\n\n\tBUG_ON(!vm_mixed_ok(vma, pfn));\n\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn VM_FAULT_SIGBUS;\n\n\ttrack_pfn_insert(vma, &pgprot, pfn);\n\n\tif (!pfn_modify_allowed(pfn_t_to_pfn(pfn), pgprot))\n\t\treturn VM_FAULT_SIGBUS;\n\n\t/*\n\t * If we don't have pte special, then we have to use the pfn_valid()\n\t * based VM_MIXEDMAP scheme (see vm_normal_page), and thus we *must*\n\t * refcount the page if pfn_valid is true (hence insert_page rather\n\t * than insert_pfn).  If a zero_pfn were inserted into a VM_MIXEDMAP\n\t * without pte special, it would there be refcounted as a normal page.\n\t */\n\tif (!IS_ENABLED(CONFIG_ARCH_HAS_PTE_SPECIAL) &&\n\t    !pfn_t_devmap(pfn) && pfn_t_valid(pfn)) {\n\t\tstruct page *page;\n\n\t\t/*\n\t\t * At this point we are committed to insert_page()\n\t\t * regardless of whether the caller specified flags that\n\t\t * result in pfn_t_has_page() == false.\n\t\t */\n\t\tpage = pfn_to_page(pfn_t_to_pfn(pfn));\n\t\terr = insert_page(vma, addr, page, pgprot);\n\t} else {\n\t\treturn insert_pfn(vma, addr, pfn, pgprot, mkwrite);\n\t}\n\n\tif (err == -ENOMEM)\n\t\treturn VM_FAULT_OOM;\n\tif (err < 0 && err != -EBUSY)\n\t\treturn VM_FAULT_SIGBUS;\n\n\treturn VM_FAULT_NOPAGE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvm_fault_t vmf_insert_mixed_mkwrite(struct vm_area_struct *vma,\n\t\tunsigned long addr, pfn_t pfn)\n{\n\treturn __vm_insert_mixed(vma, addr, pfn, true);\n}"
  },
  {
    "function_name": "vmf_insert_mixed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1708-1712",
    "snippet": "vm_fault_t vmf_insert_mixed(struct vm_area_struct *vma, unsigned long addr,\n\t\tpfn_t pfn)\n{\n\treturn __vm_insert_mixed(vma, addr, pfn, false);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vm_insert_mixed",
          "args": [
            "vma",
            "addr",
            "pfn",
            "false"
          ],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "__vm_insert_mixed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1662-1706",
          "snippet": "static vm_fault_t __vm_insert_mixed(struct vm_area_struct *vma,\n\t\tunsigned long addr, pfn_t pfn, bool mkwrite)\n{\n\tpgprot_t pgprot = vma->vm_page_prot;\n\tint err;\n\n\tBUG_ON(!vm_mixed_ok(vma, pfn));\n\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn VM_FAULT_SIGBUS;\n\n\ttrack_pfn_insert(vma, &pgprot, pfn);\n\n\tif (!pfn_modify_allowed(pfn_t_to_pfn(pfn), pgprot))\n\t\treturn VM_FAULT_SIGBUS;\n\n\t/*\n\t * If we don't have pte special, then we have to use the pfn_valid()\n\t * based VM_MIXEDMAP scheme (see vm_normal_page), and thus we *must*\n\t * refcount the page if pfn_valid is true (hence insert_page rather\n\t * than insert_pfn).  If a zero_pfn were inserted into a VM_MIXEDMAP\n\t * without pte special, it would there be refcounted as a normal page.\n\t */\n\tif (!IS_ENABLED(CONFIG_ARCH_HAS_PTE_SPECIAL) &&\n\t    !pfn_t_devmap(pfn) && pfn_t_valid(pfn)) {\n\t\tstruct page *page;\n\n\t\t/*\n\t\t * At this point we are committed to insert_page()\n\t\t * regardless of whether the caller specified flags that\n\t\t * result in pfn_t_has_page() == false.\n\t\t */\n\t\tpage = pfn_to_page(pfn_t_to_pfn(pfn));\n\t\terr = insert_page(vma, addr, page, pgprot);\n\t} else {\n\t\treturn insert_pfn(vma, addr, pfn, pgprot, mkwrite);\n\t}\n\n\tif (err == -ENOMEM)\n\t\treturn VM_FAULT_OOM;\n\tif (err < 0 && err != -EBUSY)\n\t\treturn VM_FAULT_SIGBUS;\n\n\treturn VM_FAULT_NOPAGE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t __vm_insert_mixed(struct vm_area_struct *vma,\n\t\tunsigned long addr, pfn_t pfn, bool mkwrite)\n{\n\tpgprot_t pgprot = vma->vm_page_prot;\n\tint err;\n\n\tBUG_ON(!vm_mixed_ok(vma, pfn));\n\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn VM_FAULT_SIGBUS;\n\n\ttrack_pfn_insert(vma, &pgprot, pfn);\n\n\tif (!pfn_modify_allowed(pfn_t_to_pfn(pfn), pgprot))\n\t\treturn VM_FAULT_SIGBUS;\n\n\t/*\n\t * If we don't have pte special, then we have to use the pfn_valid()\n\t * based VM_MIXEDMAP scheme (see vm_normal_page), and thus we *must*\n\t * refcount the page if pfn_valid is true (hence insert_page rather\n\t * than insert_pfn).  If a zero_pfn were inserted into a VM_MIXEDMAP\n\t * without pte special, it would there be refcounted as a normal page.\n\t */\n\tif (!IS_ENABLED(CONFIG_ARCH_HAS_PTE_SPECIAL) &&\n\t    !pfn_t_devmap(pfn) && pfn_t_valid(pfn)) {\n\t\tstruct page *page;\n\n\t\t/*\n\t\t * At this point we are committed to insert_page()\n\t\t * regardless of whether the caller specified flags that\n\t\t * result in pfn_t_has_page() == false.\n\t\t */\n\t\tpage = pfn_to_page(pfn_t_to_pfn(pfn));\n\t\terr = insert_page(vma, addr, page, pgprot);\n\t} else {\n\t\treturn insert_pfn(vma, addr, pfn, pgprot, mkwrite);\n\t}\n\n\tif (err == -ENOMEM)\n\t\treturn VM_FAULT_OOM;\n\tif (err < 0 && err != -EBUSY)\n\t\treturn VM_FAULT_SIGBUS;\n\n\treturn VM_FAULT_NOPAGE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvm_fault_t vmf_insert_mixed(struct vm_area_struct *vma, unsigned long addr,\n\t\tpfn_t pfn)\n{\n\treturn __vm_insert_mixed(vma, addr, pfn, false);\n}"
  },
  {
    "function_name": "__vm_insert_mixed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1662-1706",
    "snippet": "static vm_fault_t __vm_insert_mixed(struct vm_area_struct *vma,\n\t\tunsigned long addr, pfn_t pfn, bool mkwrite)\n{\n\tpgprot_t pgprot = vma->vm_page_prot;\n\tint err;\n\n\tBUG_ON(!vm_mixed_ok(vma, pfn));\n\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn VM_FAULT_SIGBUS;\n\n\ttrack_pfn_insert(vma, &pgprot, pfn);\n\n\tif (!pfn_modify_allowed(pfn_t_to_pfn(pfn), pgprot))\n\t\treturn VM_FAULT_SIGBUS;\n\n\t/*\n\t * If we don't have pte special, then we have to use the pfn_valid()\n\t * based VM_MIXEDMAP scheme (see vm_normal_page), and thus we *must*\n\t * refcount the page if pfn_valid is true (hence insert_page rather\n\t * than insert_pfn).  If a zero_pfn were inserted into a VM_MIXEDMAP\n\t * without pte special, it would there be refcounted as a normal page.\n\t */\n\tif (!IS_ENABLED(CONFIG_ARCH_HAS_PTE_SPECIAL) &&\n\t    !pfn_t_devmap(pfn) && pfn_t_valid(pfn)) {\n\t\tstruct page *page;\n\n\t\t/*\n\t\t * At this point we are committed to insert_page()\n\t\t * regardless of whether the caller specified flags that\n\t\t * result in pfn_t_has_page() == false.\n\t\t */\n\t\tpage = pfn_to_page(pfn_t_to_pfn(pfn));\n\t\terr = insert_page(vma, addr, page, pgprot);\n\t} else {\n\t\treturn insert_pfn(vma, addr, pfn, pgprot, mkwrite);\n\t}\n\n\tif (err == -ENOMEM)\n\t\treturn VM_FAULT_OOM;\n\tif (err < 0 && err != -EBUSY)\n\t\treturn VM_FAULT_SIGBUS;\n\n\treturn VM_FAULT_NOPAGE;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "insert_pfn",
          "args": [
            "vma",
            "addr",
            "pfn",
            "pgprot",
            "mkwrite"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "insert_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1523-1573",
          "snippet": "static vm_fault_t insert_pfn(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tpfn_t pfn, pgprot_t prot, bool mkwrite)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpte_t *pte, entry;\n\tspinlock_t *ptl;\n\n\tpte = get_locked_pte(mm, addr, &ptl);\n\tif (!pte)\n\t\treturn VM_FAULT_OOM;\n\tif (!pte_none(*pte)) {\n\t\tif (mkwrite) {\n\t\t\t/*\n\t\t\t * For read faults on private mappings the PFN passed\n\t\t\t * in may not match the PFN we have mapped if the\n\t\t\t * mapped PFN is a writeable COW page.  In the mkwrite\n\t\t\t * case we are creating a writable PTE for a shared\n\t\t\t * mapping and we expect the PFNs to match. If they\n\t\t\t * don't match, we are likely racing with block\n\t\t\t * allocation and mapping invalidation so just skip the\n\t\t\t * update.\n\t\t\t */\n\t\t\tif (pte_pfn(*pte) != pfn_t_to_pfn(pfn)) {\n\t\t\t\tWARN_ON_ONCE(!is_zero_pfn(pte_pfn(*pte)));\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tentry = *pte;\n\t\t\tgoto out_mkwrite;\n\t\t} else\n\t\t\tgoto out_unlock;\n\t}\n\n\t/* Ok, finally just insert the thing.. */\n\tif (pfn_t_devmap(pfn))\n\t\tentry = pte_mkdevmap(pfn_t_pte(pfn, prot));\n\telse\n\t\tentry = pte_mkspecial(pfn_t_pte(pfn, prot));\n\nout_mkwrite:\n\tif (mkwrite) {\n\t\tentry = pte_mkyoung(entry);\n\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t}\n\n\tset_pte_at(mm, addr, pte, entry);\n\tupdate_mmu_cache(vma, addr, pte); /* XXX: why not for insert_page? */\n\nout_unlock:\n\tpte_unmap_unlock(pte, ptl);\n\treturn VM_FAULT_NOPAGE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t insert_pfn(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tpfn_t pfn, pgprot_t prot, bool mkwrite)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpte_t *pte, entry;\n\tspinlock_t *ptl;\n\n\tpte = get_locked_pte(mm, addr, &ptl);\n\tif (!pte)\n\t\treturn VM_FAULT_OOM;\n\tif (!pte_none(*pte)) {\n\t\tif (mkwrite) {\n\t\t\t/*\n\t\t\t * For read faults on private mappings the PFN passed\n\t\t\t * in may not match the PFN we have mapped if the\n\t\t\t * mapped PFN is a writeable COW page.  In the mkwrite\n\t\t\t * case we are creating a writable PTE for a shared\n\t\t\t * mapping and we expect the PFNs to match. If they\n\t\t\t * don't match, we are likely racing with block\n\t\t\t * allocation and mapping invalidation so just skip the\n\t\t\t * update.\n\t\t\t */\n\t\t\tif (pte_pfn(*pte) != pfn_t_to_pfn(pfn)) {\n\t\t\t\tWARN_ON_ONCE(!is_zero_pfn(pte_pfn(*pte)));\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tentry = *pte;\n\t\t\tgoto out_mkwrite;\n\t\t} else\n\t\t\tgoto out_unlock;\n\t}\n\n\t/* Ok, finally just insert the thing.. */\n\tif (pfn_t_devmap(pfn))\n\t\tentry = pte_mkdevmap(pfn_t_pte(pfn, prot));\n\telse\n\t\tentry = pte_mkspecial(pfn_t_pte(pfn, prot));\n\nout_mkwrite:\n\tif (mkwrite) {\n\t\tentry = pte_mkyoung(entry);\n\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t}\n\n\tset_pte_at(mm, addr, pte, entry);\n\tupdate_mmu_cache(vma, addr, pte); /* XXX: why not for insert_page? */\n\nout_unlock:\n\tpte_unmap_unlock(pte, ptl);\n\treturn VM_FAULT_NOPAGE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_page",
          "args": [
            "vma",
            "addr",
            "page",
            "pgprot"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "insert_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1445-1478",
          "snippet": "static int insert_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tstruct page *page, pgprot_t prot)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint retval;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tretval = -EINVAL;\n\tif (PageAnon(page))\n\t\tgoto out;\n\tretval = -ENOMEM;\n\tflush_dcache_page(page);\n\tpte = get_locked_pte(mm, addr, &ptl);\n\tif (!pte)\n\t\tgoto out;\n\tretval = -EBUSY;\n\tif (!pte_none(*pte))\n\t\tgoto out_unlock;\n\n\t/* Ok, finally just insert the thing.. */\n\tget_page(page);\n\tinc_mm_counter_fast(mm, mm_counter_file(page));\n\tpage_add_file_rmap(page, false);\n\tset_pte_at(mm, addr, pte, mk_pte(page, prot));\n\n\tretval = 0;\n\tpte_unmap_unlock(pte, ptl);\n\treturn retval;\nout_unlock:\n\tpte_unmap_unlock(pte, ptl);\nout:\n\treturn retval;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int insert_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tstruct page *page, pgprot_t prot)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint retval;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tretval = -EINVAL;\n\tif (PageAnon(page))\n\t\tgoto out;\n\tretval = -ENOMEM;\n\tflush_dcache_page(page);\n\tpte = get_locked_pte(mm, addr, &ptl);\n\tif (!pte)\n\t\tgoto out;\n\tretval = -EBUSY;\n\tif (!pte_none(*pte))\n\t\tgoto out_unlock;\n\n\t/* Ok, finally just insert the thing.. */\n\tget_page(page);\n\tinc_mm_counter_fast(mm, mm_counter_file(page));\n\tpage_add_file_rmap(page, false);\n\tset_pte_at(mm, addr, pte, mk_pte(page, prot));\n\n\tretval = 0;\n\tpte_unmap_unlock(pte, ptl);\n\treturn retval;\nout_unlock:\n\tpte_unmap_unlock(pte, ptl);\nout:\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn_t_to_pfn(pfn)"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_t_to_pfn",
          "args": [
            "pfn"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_t_valid",
          "args": [
            "pfn"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_t_devmap",
          "args": [
            "pfn"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_ARCH_HAS_PTE_SPECIAL"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_modify_allowed",
          "args": [
            "pfn_t_to_pfn(pfn)",
            "pgprot"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_t_to_pfn",
          "args": [
            "pfn"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track_pfn_insert",
          "args": [
            "vma",
            "&pgprot",
            "pfn"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!vm_mixed_ok(vma, pfn)"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_mixed_ok",
          "args": [
            "vma",
            "pfn"
          ],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "vm_mixed_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1648-1660",
          "snippet": "static bool vm_mixed_ok(struct vm_area_struct *vma, pfn_t pfn)\n{\n\t/* these checks mirror the abort conditions in vm_normal_page */\n\tif (vma->vm_flags & VM_MIXEDMAP)\n\t\treturn true;\n\tif (pfn_t_devmap(pfn))\n\t\treturn true;\n\tif (pfn_t_special(pfn))\n\t\treturn true;\n\tif (is_zero_pfn(pfn_t_to_pfn(pfn)))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic bool vm_mixed_ok(struct vm_area_struct *vma, pfn_t pfn)\n{\n\t/* these checks mirror the abort conditions in vm_normal_page */\n\tif (vma->vm_flags & VM_MIXEDMAP)\n\t\treturn true;\n\tif (pfn_t_devmap(pfn))\n\t\treturn true;\n\tif (pfn_t_special(pfn))\n\t\treturn true;\n\tif (is_zero_pfn(pfn_t_to_pfn(pfn)))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t __vm_insert_mixed(struct vm_area_struct *vma,\n\t\tunsigned long addr, pfn_t pfn, bool mkwrite)\n{\n\tpgprot_t pgprot = vma->vm_page_prot;\n\tint err;\n\n\tBUG_ON(!vm_mixed_ok(vma, pfn));\n\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn VM_FAULT_SIGBUS;\n\n\ttrack_pfn_insert(vma, &pgprot, pfn);\n\n\tif (!pfn_modify_allowed(pfn_t_to_pfn(pfn), pgprot))\n\t\treturn VM_FAULT_SIGBUS;\n\n\t/*\n\t * If we don't have pte special, then we have to use the pfn_valid()\n\t * based VM_MIXEDMAP scheme (see vm_normal_page), and thus we *must*\n\t * refcount the page if pfn_valid is true (hence insert_page rather\n\t * than insert_pfn).  If a zero_pfn were inserted into a VM_MIXEDMAP\n\t * without pte special, it would there be refcounted as a normal page.\n\t */\n\tif (!IS_ENABLED(CONFIG_ARCH_HAS_PTE_SPECIAL) &&\n\t    !pfn_t_devmap(pfn) && pfn_t_valid(pfn)) {\n\t\tstruct page *page;\n\n\t\t/*\n\t\t * At this point we are committed to insert_page()\n\t\t * regardless of whether the caller specified flags that\n\t\t * result in pfn_t_has_page() == false.\n\t\t */\n\t\tpage = pfn_to_page(pfn_t_to_pfn(pfn));\n\t\terr = insert_page(vma, addr, page, pgprot);\n\t} else {\n\t\treturn insert_pfn(vma, addr, pfn, pgprot, mkwrite);\n\t}\n\n\tif (err == -ENOMEM)\n\t\treturn VM_FAULT_OOM;\n\tif (err < 0 && err != -EBUSY)\n\t\treturn VM_FAULT_SIGBUS;\n\n\treturn VM_FAULT_NOPAGE;\n}"
  },
  {
    "function_name": "vm_mixed_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1648-1660",
    "snippet": "static bool vm_mixed_ok(struct vm_area_struct *vma, pfn_t pfn)\n{\n\t/* these checks mirror the abort conditions in vm_normal_page */\n\tif (vma->vm_flags & VM_MIXEDMAP)\n\t\treturn true;\n\tif (pfn_t_devmap(pfn))\n\t\treturn true;\n\tif (pfn_t_special(pfn))\n\t\treturn true;\n\tif (is_zero_pfn(pfn_t_to_pfn(pfn)))\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_zero_pfn",
          "args": [
            "pfn_t_to_pfn(pfn)"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_t_to_pfn",
          "args": [
            "pfn"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_t_special",
          "args": [
            "pfn"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_t_devmap",
          "args": [
            "pfn"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic bool vm_mixed_ok(struct vm_area_struct *vma, pfn_t pfn)\n{\n\t/* these checks mirror the abort conditions in vm_normal_page */\n\tif (vma->vm_flags & VM_MIXEDMAP)\n\t\treturn true;\n\tif (pfn_t_devmap(pfn))\n\t\treturn true;\n\tif (pfn_t_special(pfn))\n\t\treturn true;\n\tif (is_zero_pfn(pfn_t_to_pfn(pfn)))\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "vmf_insert_pfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1641-1645",
    "snippet": "vm_fault_t vmf_insert_pfn(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tunsigned long pfn)\n{\n\treturn vmf_insert_pfn_prot(vma, addr, pfn, vma->vm_page_prot);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmf_insert_pfn_prot",
          "args": [
            "vma",
            "addr",
            "pfn",
            "vma->vm_page_prot"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "vmf_insert_pfn_prot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1593-1618",
          "snippet": "vm_fault_t vmf_insert_pfn_prot(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tunsigned long pfn, pgprot_t pgprot)\n{\n\t/*\n\t * Technically, architectures with pte_special can avoid all these\n\t * restrictions (same for remap_pfn_range).  However we would like\n\t * consistency in testing and feature parity among all, so we should\n\t * try to keep these invariants in place for everybody.\n\t */\n\tBUG_ON(!(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)));\n\tBUG_ON((vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) ==\n\t\t\t\t\t\t(VM_PFNMAP|VM_MIXEDMAP));\n\tBUG_ON((vma->vm_flags & VM_PFNMAP) && is_cow_mapping(vma->vm_flags));\n\tBUG_ON((vma->vm_flags & VM_MIXEDMAP) && pfn_valid(pfn));\n\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn VM_FAULT_SIGBUS;\n\n\tif (!pfn_modify_allowed(pfn, pgprot))\n\t\treturn VM_FAULT_SIGBUS;\n\n\ttrack_pfn_insert(vma, &pgprot, __pfn_to_pfn_t(pfn, PFN_DEV));\n\n\treturn insert_pfn(vma, addr, __pfn_to_pfn_t(pfn, PFN_DEV), pgprot,\n\t\t\tfalse);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvm_fault_t vmf_insert_pfn_prot(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tunsigned long pfn, pgprot_t pgprot)\n{\n\t/*\n\t * Technically, architectures with pte_special can avoid all these\n\t * restrictions (same for remap_pfn_range).  However we would like\n\t * consistency in testing and feature parity among all, so we should\n\t * try to keep these invariants in place for everybody.\n\t */\n\tBUG_ON(!(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)));\n\tBUG_ON((vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) ==\n\t\t\t\t\t\t(VM_PFNMAP|VM_MIXEDMAP));\n\tBUG_ON((vma->vm_flags & VM_PFNMAP) && is_cow_mapping(vma->vm_flags));\n\tBUG_ON((vma->vm_flags & VM_MIXEDMAP) && pfn_valid(pfn));\n\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn VM_FAULT_SIGBUS;\n\n\tif (!pfn_modify_allowed(pfn, pgprot))\n\t\treturn VM_FAULT_SIGBUS;\n\n\ttrack_pfn_insert(vma, &pgprot, __pfn_to_pfn_t(pfn, PFN_DEV));\n\n\treturn insert_pfn(vma, addr, __pfn_to_pfn_t(pfn, PFN_DEV), pgprot,\n\t\t\tfalse);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvm_fault_t vmf_insert_pfn(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tunsigned long pfn)\n{\n\treturn vmf_insert_pfn_prot(vma, addr, pfn, vma->vm_page_prot);\n}"
  },
  {
    "function_name": "vmf_insert_pfn_prot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1593-1618",
    "snippet": "vm_fault_t vmf_insert_pfn_prot(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tunsigned long pfn, pgprot_t pgprot)\n{\n\t/*\n\t * Technically, architectures with pte_special can avoid all these\n\t * restrictions (same for remap_pfn_range).  However we would like\n\t * consistency in testing and feature parity among all, so we should\n\t * try to keep these invariants in place for everybody.\n\t */\n\tBUG_ON(!(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)));\n\tBUG_ON((vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) ==\n\t\t\t\t\t\t(VM_PFNMAP|VM_MIXEDMAP));\n\tBUG_ON((vma->vm_flags & VM_PFNMAP) && is_cow_mapping(vma->vm_flags));\n\tBUG_ON((vma->vm_flags & VM_MIXEDMAP) && pfn_valid(pfn));\n\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn VM_FAULT_SIGBUS;\n\n\tif (!pfn_modify_allowed(pfn, pgprot))\n\t\treturn VM_FAULT_SIGBUS;\n\n\ttrack_pfn_insert(vma, &pgprot, __pfn_to_pfn_t(pfn, PFN_DEV));\n\n\treturn insert_pfn(vma, addr, __pfn_to_pfn_t(pfn, PFN_DEV), pgprot,\n\t\t\tfalse);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "insert_pfn",
          "args": [
            "vma",
            "addr",
            "__pfn_to_pfn_t(pfn, PFN_DEV)",
            "pgprot",
            "false"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "insert_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1523-1573",
          "snippet": "static vm_fault_t insert_pfn(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tpfn_t pfn, pgprot_t prot, bool mkwrite)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpte_t *pte, entry;\n\tspinlock_t *ptl;\n\n\tpte = get_locked_pte(mm, addr, &ptl);\n\tif (!pte)\n\t\treturn VM_FAULT_OOM;\n\tif (!pte_none(*pte)) {\n\t\tif (mkwrite) {\n\t\t\t/*\n\t\t\t * For read faults on private mappings the PFN passed\n\t\t\t * in may not match the PFN we have mapped if the\n\t\t\t * mapped PFN is a writeable COW page.  In the mkwrite\n\t\t\t * case we are creating a writable PTE for a shared\n\t\t\t * mapping and we expect the PFNs to match. If they\n\t\t\t * don't match, we are likely racing with block\n\t\t\t * allocation and mapping invalidation so just skip the\n\t\t\t * update.\n\t\t\t */\n\t\t\tif (pte_pfn(*pte) != pfn_t_to_pfn(pfn)) {\n\t\t\t\tWARN_ON_ONCE(!is_zero_pfn(pte_pfn(*pte)));\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tentry = *pte;\n\t\t\tgoto out_mkwrite;\n\t\t} else\n\t\t\tgoto out_unlock;\n\t}\n\n\t/* Ok, finally just insert the thing.. */\n\tif (pfn_t_devmap(pfn))\n\t\tentry = pte_mkdevmap(pfn_t_pte(pfn, prot));\n\telse\n\t\tentry = pte_mkspecial(pfn_t_pte(pfn, prot));\n\nout_mkwrite:\n\tif (mkwrite) {\n\t\tentry = pte_mkyoung(entry);\n\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t}\n\n\tset_pte_at(mm, addr, pte, entry);\n\tupdate_mmu_cache(vma, addr, pte); /* XXX: why not for insert_page? */\n\nout_unlock:\n\tpte_unmap_unlock(pte, ptl);\n\treturn VM_FAULT_NOPAGE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t insert_pfn(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tpfn_t pfn, pgprot_t prot, bool mkwrite)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpte_t *pte, entry;\n\tspinlock_t *ptl;\n\n\tpte = get_locked_pte(mm, addr, &ptl);\n\tif (!pte)\n\t\treturn VM_FAULT_OOM;\n\tif (!pte_none(*pte)) {\n\t\tif (mkwrite) {\n\t\t\t/*\n\t\t\t * For read faults on private mappings the PFN passed\n\t\t\t * in may not match the PFN we have mapped if the\n\t\t\t * mapped PFN is a writeable COW page.  In the mkwrite\n\t\t\t * case we are creating a writable PTE for a shared\n\t\t\t * mapping and we expect the PFNs to match. If they\n\t\t\t * don't match, we are likely racing with block\n\t\t\t * allocation and mapping invalidation so just skip the\n\t\t\t * update.\n\t\t\t */\n\t\t\tif (pte_pfn(*pte) != pfn_t_to_pfn(pfn)) {\n\t\t\t\tWARN_ON_ONCE(!is_zero_pfn(pte_pfn(*pte)));\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tentry = *pte;\n\t\t\tgoto out_mkwrite;\n\t\t} else\n\t\t\tgoto out_unlock;\n\t}\n\n\t/* Ok, finally just insert the thing.. */\n\tif (pfn_t_devmap(pfn))\n\t\tentry = pte_mkdevmap(pfn_t_pte(pfn, prot));\n\telse\n\t\tentry = pte_mkspecial(pfn_t_pte(pfn, prot));\n\nout_mkwrite:\n\tif (mkwrite) {\n\t\tentry = pte_mkyoung(entry);\n\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t}\n\n\tset_pte_at(mm, addr, pte, entry);\n\tupdate_mmu_cache(vma, addr, pte); /* XXX: why not for insert_page? */\n\nout_unlock:\n\tpte_unmap_unlock(pte, ptl);\n\treturn VM_FAULT_NOPAGE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pfn_to_pfn_t",
          "args": [
            "pfn",
            "PFN_DEV"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track_pfn_insert",
          "args": [
            "vma",
            "&pgprot",
            "__pfn_to_pfn_t(pfn, PFN_DEV)"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pfn_to_pfn_t",
          "args": [
            "pfn",
            "PFN_DEV"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_modify_allowed",
          "args": [
            "pfn",
            "pgprot"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(vma->vm_flags & VM_MIXEDMAP) && pfn_valid(pfn)"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(vma->vm_flags & VM_PFNMAP) && is_cow_mapping(vma->vm_flags)"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_cow_mapping",
          "args": [
            "vma->vm_flags"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "is_cow_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "247-250",
          "snippet": "static inline bool is_cow_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline bool is_cow_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) ==\n\t\t\t\t\t\t(VM_PFNMAP|VM_MIXEDMAP)"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvm_fault_t vmf_insert_pfn_prot(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tunsigned long pfn, pgprot_t pgprot)\n{\n\t/*\n\t * Technically, architectures with pte_special can avoid all these\n\t * restrictions (same for remap_pfn_range).  However we would like\n\t * consistency in testing and feature parity among all, so we should\n\t * try to keep these invariants in place for everybody.\n\t */\n\tBUG_ON(!(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)));\n\tBUG_ON((vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) ==\n\t\t\t\t\t\t(VM_PFNMAP|VM_MIXEDMAP));\n\tBUG_ON((vma->vm_flags & VM_PFNMAP) && is_cow_mapping(vma->vm_flags));\n\tBUG_ON((vma->vm_flags & VM_MIXEDMAP) && pfn_valid(pfn));\n\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn VM_FAULT_SIGBUS;\n\n\tif (!pfn_modify_allowed(pfn, pgprot))\n\t\treturn VM_FAULT_SIGBUS;\n\n\ttrack_pfn_insert(vma, &pgprot, __pfn_to_pfn_t(pfn, PFN_DEV));\n\n\treturn insert_pfn(vma, addr, __pfn_to_pfn_t(pfn, PFN_DEV), pgprot,\n\t\t\tfalse);\n}"
  },
  {
    "function_name": "insert_pfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1523-1573",
    "snippet": "static vm_fault_t insert_pfn(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tpfn_t pfn, pgprot_t prot, bool mkwrite)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpte_t *pte, entry;\n\tspinlock_t *ptl;\n\n\tpte = get_locked_pte(mm, addr, &ptl);\n\tif (!pte)\n\t\treturn VM_FAULT_OOM;\n\tif (!pte_none(*pte)) {\n\t\tif (mkwrite) {\n\t\t\t/*\n\t\t\t * For read faults on private mappings the PFN passed\n\t\t\t * in may not match the PFN we have mapped if the\n\t\t\t * mapped PFN is a writeable COW page.  In the mkwrite\n\t\t\t * case we are creating a writable PTE for a shared\n\t\t\t * mapping and we expect the PFNs to match. If they\n\t\t\t * don't match, we are likely racing with block\n\t\t\t * allocation and mapping invalidation so just skip the\n\t\t\t * update.\n\t\t\t */\n\t\t\tif (pte_pfn(*pte) != pfn_t_to_pfn(pfn)) {\n\t\t\t\tWARN_ON_ONCE(!is_zero_pfn(pte_pfn(*pte)));\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tentry = *pte;\n\t\t\tgoto out_mkwrite;\n\t\t} else\n\t\t\tgoto out_unlock;\n\t}\n\n\t/* Ok, finally just insert the thing.. */\n\tif (pfn_t_devmap(pfn))\n\t\tentry = pte_mkdevmap(pfn_t_pte(pfn, prot));\n\telse\n\t\tentry = pte_mkspecial(pfn_t_pte(pfn, prot));\n\nout_mkwrite:\n\tif (mkwrite) {\n\t\tentry = pte_mkyoung(entry);\n\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t}\n\n\tset_pte_at(mm, addr, pte, entry);\n\tupdate_mmu_cache(vma, addr, pte); /* XXX: why not for insert_page? */\n\nout_unlock:\n\tpte_unmap_unlock(pte, ptl);\n\treturn VM_FAULT_NOPAGE;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "pte",
            "ptl"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_mmu_cache",
          "args": [
            "vma",
            "addr",
            "pte"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "mm",
            "addr",
            "pte",
            "entry"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "maybe_mkwrite",
          "args": [
            "pte_mkdirty(entry)",
            "vma"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkdirty",
          "args": [
            "entry"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkyoung",
          "args": [
            "entry"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkspecial",
          "args": [
            "pfn_t_pte(pfn, prot)"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_t_pte",
          "args": [
            "pfn",
            "prot"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkdevmap",
          "args": [
            "pfn_t_pte(pfn, prot)"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_t_pte",
          "args": [
            "pfn",
            "prot"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_t_devmap",
          "args": [
            "pfn"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!is_zero_pfn(pte_pfn(*pte))"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_zero_pfn",
          "args": [
            "pte_pfn(*pte)"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "*pte"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_t_to_pfn",
          "args": [
            "pfn"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "*pte"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "*pte"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_locked_pte",
          "args": [
            "mm",
            "addr",
            "&ptl"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "__get_locked_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1415-1436",
          "snippet": "pte_t *__get_locked_pte(struct mm_struct *mm, unsigned long addr,\n\t\t\tspinlock_t **ptl)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tp4d = p4d_alloc(mm, pgd, addr);\n\tif (!p4d)\n\t\treturn NULL;\n\tpud = pud_alloc(mm, p4d, addr);\n\tif (!pud)\n\t\treturn NULL;\n\tpmd = pmd_alloc(mm, pud, addr);\n\tif (!pmd)\n\t\treturn NULL;\n\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\treturn pte_alloc_map_lock(mm, pmd, addr, ptl);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\npte_t *__get_locked_pte(struct mm_struct *mm, unsigned long addr,\n\t\t\tspinlock_t **ptl)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tp4d = p4d_alloc(mm, pgd, addr);\n\tif (!p4d)\n\t\treturn NULL;\n\tpud = pud_alloc(mm, p4d, addr);\n\tif (!pud)\n\t\treturn NULL;\n\tpmd = pmd_alloc(mm, pud, addr);\n\tif (!pmd)\n\t\treturn NULL;\n\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\treturn pte_alloc_map_lock(mm, pmd, addr, ptl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic vm_fault_t insert_pfn(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tpfn_t pfn, pgprot_t prot, bool mkwrite)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpte_t *pte, entry;\n\tspinlock_t *ptl;\n\n\tpte = get_locked_pte(mm, addr, &ptl);\n\tif (!pte)\n\t\treturn VM_FAULT_OOM;\n\tif (!pte_none(*pte)) {\n\t\tif (mkwrite) {\n\t\t\t/*\n\t\t\t * For read faults on private mappings the PFN passed\n\t\t\t * in may not match the PFN we have mapped if the\n\t\t\t * mapped PFN is a writeable COW page.  In the mkwrite\n\t\t\t * case we are creating a writable PTE for a shared\n\t\t\t * mapping and we expect the PFNs to match. If they\n\t\t\t * don't match, we are likely racing with block\n\t\t\t * allocation and mapping invalidation so just skip the\n\t\t\t * update.\n\t\t\t */\n\t\t\tif (pte_pfn(*pte) != pfn_t_to_pfn(pfn)) {\n\t\t\t\tWARN_ON_ONCE(!is_zero_pfn(pte_pfn(*pte)));\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tentry = *pte;\n\t\t\tgoto out_mkwrite;\n\t\t} else\n\t\t\tgoto out_unlock;\n\t}\n\n\t/* Ok, finally just insert the thing.. */\n\tif (pfn_t_devmap(pfn))\n\t\tentry = pte_mkdevmap(pfn_t_pte(pfn, prot));\n\telse\n\t\tentry = pte_mkspecial(pfn_t_pte(pfn, prot));\n\nout_mkwrite:\n\tif (mkwrite) {\n\t\tentry = pte_mkyoung(entry);\n\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t}\n\n\tset_pte_at(mm, addr, pte, entry);\n\tupdate_mmu_cache(vma, addr, pte); /* XXX: why not for insert_page? */\n\nout_unlock:\n\tpte_unmap_unlock(pte, ptl);\n\treturn VM_FAULT_NOPAGE;\n}"
  },
  {
    "function_name": "vm_insert_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1507-1520",
    "snippet": "int vm_insert_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tstruct page *page)\n{\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn -EFAULT;\n\tif (!page_count(page))\n\t\treturn -EINVAL;\n\tif (!(vma->vm_flags & VM_MIXEDMAP)) {\n\t\tBUG_ON(down_read_trylock(&vma->vm_mm->mmap_sem));\n\t\tBUG_ON(vma->vm_flags & VM_PFNMAP);\n\t\tvma->vm_flags |= VM_MIXEDMAP;\n\t}\n\treturn insert_page(vma, addr, page, vma->vm_page_prot);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "insert_page",
          "args": [
            "vma",
            "addr",
            "page",
            "vma->vm_page_prot"
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "insert_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1445-1478",
          "snippet": "static int insert_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tstruct page *page, pgprot_t prot)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint retval;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tretval = -EINVAL;\n\tif (PageAnon(page))\n\t\tgoto out;\n\tretval = -ENOMEM;\n\tflush_dcache_page(page);\n\tpte = get_locked_pte(mm, addr, &ptl);\n\tif (!pte)\n\t\tgoto out;\n\tretval = -EBUSY;\n\tif (!pte_none(*pte))\n\t\tgoto out_unlock;\n\n\t/* Ok, finally just insert the thing.. */\n\tget_page(page);\n\tinc_mm_counter_fast(mm, mm_counter_file(page));\n\tpage_add_file_rmap(page, false);\n\tset_pte_at(mm, addr, pte, mk_pte(page, prot));\n\n\tretval = 0;\n\tpte_unmap_unlock(pte, ptl);\n\treturn retval;\nout_unlock:\n\tpte_unmap_unlock(pte, ptl);\nout:\n\treturn retval;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int insert_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tstruct page *page, pgprot_t prot)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint retval;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tretval = -EINVAL;\n\tif (PageAnon(page))\n\t\tgoto out;\n\tretval = -ENOMEM;\n\tflush_dcache_page(page);\n\tpte = get_locked_pte(mm, addr, &ptl);\n\tif (!pte)\n\t\tgoto out;\n\tretval = -EBUSY;\n\tif (!pte_none(*pte))\n\t\tgoto out_unlock;\n\n\t/* Ok, finally just insert the thing.. */\n\tget_page(page);\n\tinc_mm_counter_fast(mm, mm_counter_file(page));\n\tpage_add_file_rmap(page, false);\n\tset_pte_at(mm, addr, pte, mk_pte(page, prot));\n\n\tretval = 0;\n\tpte_unmap_unlock(pte, ptl);\n\treturn retval;\nout_unlock:\n\tpte_unmap_unlock(pte, ptl);\nout:\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "vma->vm_flags & VM_PFNMAP"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "down_read_trylock(&vma->vm_mm->mmap_sem)"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read_trylock",
          "args": [
            "&vma->vm_mm->mmap_sem"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint vm_insert_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tstruct page *page)\n{\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn -EFAULT;\n\tif (!page_count(page))\n\t\treturn -EINVAL;\n\tif (!(vma->vm_flags & VM_MIXEDMAP)) {\n\t\tBUG_ON(down_read_trylock(&vma->vm_mm->mmap_sem));\n\t\tBUG_ON(vma->vm_flags & VM_PFNMAP);\n\t\tvma->vm_flags |= VM_MIXEDMAP;\n\t}\n\treturn insert_page(vma, addr, page, vma->vm_page_prot);\n}"
  },
  {
    "function_name": "insert_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1445-1478",
    "snippet": "static int insert_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tstruct page *page, pgprot_t prot)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint retval;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tretval = -EINVAL;\n\tif (PageAnon(page))\n\t\tgoto out;\n\tretval = -ENOMEM;\n\tflush_dcache_page(page);\n\tpte = get_locked_pte(mm, addr, &ptl);\n\tif (!pte)\n\t\tgoto out;\n\tretval = -EBUSY;\n\tif (!pte_none(*pte))\n\t\tgoto out_unlock;\n\n\t/* Ok, finally just insert the thing.. */\n\tget_page(page);\n\tinc_mm_counter_fast(mm, mm_counter_file(page));\n\tpage_add_file_rmap(page, false);\n\tset_pte_at(mm, addr, pte, mk_pte(page, prot));\n\n\tretval = 0;\n\tpte_unmap_unlock(pte, ptl);\n\treturn retval;\nout_unlock:\n\tpte_unmap_unlock(pte, ptl);\nout:\n\treturn retval;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "pte",
            "ptl"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "pte",
            "ptl"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "mm",
            "addr",
            "pte",
            "mk_pte(page, prot)"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mk_pte",
          "args": [
            "page",
            "prot"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_add_file_rmap",
          "args": [
            "page",
            "false"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "page_add_file_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1179-1208",
          "snippet": "void page_add_file_rmap(struct page *page, bool compound)\n{\n\tint i, nr = 1;\n\n\tVM_BUG_ON_PAGE(compound && !PageTransHuge(page), page);\n\tlock_page_memcg(page);\n\tif (compound && PageTransHuge(page)) {\n\t\tfor (i = 0, nr = 0; i < HPAGE_PMD_NR; i++) {\n\t\t\tif (atomic_inc_and_test(&page[i]._mapcount))\n\t\t\t\tnr++;\n\t\t}\n\t\tif (!atomic_inc_and_test(compound_mapcount_ptr(page)))\n\t\t\tgoto out;\n\t\tVM_BUG_ON_PAGE(!PageSwapBacked(page), page);\n\t\t__inc_node_page_state(page, NR_SHMEM_PMDMAPPED);\n\t} else {\n\t\tif (PageTransCompound(page) && page_mapping(page)) {\n\t\t\tVM_WARN_ON_ONCE(!PageLocked(page));\n\n\t\t\tSetPageDoubleMap(compound_head(page));\n\t\t\tif (PageMlocked(page))\n\t\t\t\tclear_page_mlock(compound_head(page));\n\t\t}\n\t\tif (!atomic_inc_and_test(&page->_mapcount))\n\t\t\tgoto out;\n\t}\n\t__mod_lruvec_page_state(page, NR_FILE_MAPPED, nr);\nout:\n\tunlock_page_memcg(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_add_file_rmap(struct page *page, bool compound)\n{\n\tint i, nr = 1;\n\n\tVM_BUG_ON_PAGE(compound && !PageTransHuge(page), page);\n\tlock_page_memcg(page);\n\tif (compound && PageTransHuge(page)) {\n\t\tfor (i = 0, nr = 0; i < HPAGE_PMD_NR; i++) {\n\t\t\tif (atomic_inc_and_test(&page[i]._mapcount))\n\t\t\t\tnr++;\n\t\t}\n\t\tif (!atomic_inc_and_test(compound_mapcount_ptr(page)))\n\t\t\tgoto out;\n\t\tVM_BUG_ON_PAGE(!PageSwapBacked(page), page);\n\t\t__inc_node_page_state(page, NR_SHMEM_PMDMAPPED);\n\t} else {\n\t\tif (PageTransCompound(page) && page_mapping(page)) {\n\t\t\tVM_WARN_ON_ONCE(!PageLocked(page));\n\n\t\t\tSetPageDoubleMap(compound_head(page));\n\t\t\tif (PageMlocked(page))\n\t\t\t\tclear_page_mlock(compound_head(page));\n\t\t}\n\t\tif (!atomic_inc_and_test(&page->_mapcount))\n\t\t\tgoto out;\n\t}\n\t__mod_lruvec_page_state(page, NR_FILE_MAPPED, nr);\nout:\n\tunlock_page_memcg(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_mm_counter_fast",
          "args": [
            "mm",
            "mm_counter_file(page)"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_counter_file",
          "args": [
            "page"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "*pte"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_locked_pte",
          "args": [
            "mm",
            "addr",
            "&ptl"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "__get_locked_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1415-1436",
          "snippet": "pte_t *__get_locked_pte(struct mm_struct *mm, unsigned long addr,\n\t\t\tspinlock_t **ptl)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tp4d = p4d_alloc(mm, pgd, addr);\n\tif (!p4d)\n\t\treturn NULL;\n\tpud = pud_alloc(mm, p4d, addr);\n\tif (!pud)\n\t\treturn NULL;\n\tpmd = pmd_alloc(mm, pud, addr);\n\tif (!pmd)\n\t\treturn NULL;\n\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\treturn pte_alloc_map_lock(mm, pmd, addr, ptl);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\npte_t *__get_locked_pte(struct mm_struct *mm, unsigned long addr,\n\t\t\tspinlock_t **ptl)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tp4d = p4d_alloc(mm, pgd, addr);\n\tif (!p4d)\n\t\treturn NULL;\n\tpud = pud_alloc(mm, p4d, addr);\n\tif (!pud)\n\t\treturn NULL;\n\tpmd = pmd_alloc(mm, pud, addr);\n\tif (!pmd)\n\t\treturn NULL;\n\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\treturn pte_alloc_map_lock(mm, pmd, addr, ptl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int insert_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tstruct page *page, pgprot_t prot)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint retval;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tretval = -EINVAL;\n\tif (PageAnon(page))\n\t\tgoto out;\n\tretval = -ENOMEM;\n\tflush_dcache_page(page);\n\tpte = get_locked_pte(mm, addr, &ptl);\n\tif (!pte)\n\t\tgoto out;\n\tretval = -EBUSY;\n\tif (!pte_none(*pte))\n\t\tgoto out_unlock;\n\n\t/* Ok, finally just insert the thing.. */\n\tget_page(page);\n\tinc_mm_counter_fast(mm, mm_counter_file(page));\n\tpage_add_file_rmap(page, false);\n\tset_pte_at(mm, addr, pte, mk_pte(page, prot));\n\n\tretval = 0;\n\tpte_unmap_unlock(pte, ptl);\n\treturn retval;\nout_unlock:\n\tpte_unmap_unlock(pte, ptl);\nout:\n\treturn retval;\n}"
  },
  {
    "function_name": "__get_locked_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1415-1436",
    "snippet": "pte_t *__get_locked_pte(struct mm_struct *mm, unsigned long addr,\n\t\t\tspinlock_t **ptl)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tp4d = p4d_alloc(mm, pgd, addr);\n\tif (!p4d)\n\t\treturn NULL;\n\tpud = pud_alloc(mm, p4d, addr);\n\tif (!pud)\n\t\treturn NULL;\n\tpmd = pmd_alloc(mm, pud, addr);\n\tif (!pmd)\n\t\treturn NULL;\n\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\treturn pte_alloc_map_lock(mm, pmd, addr, ptl);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_alloc_map_lock",
          "args": [
            "mm",
            "pmd",
            "addr",
            "ptl"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "pmd_trans_huge(*pmd)"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "*pmd"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_alloc",
          "args": [
            "mm",
            "pud",
            "addr"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "__pmd_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "4004-4029",
          "snippet": "int __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tptl = pud_lock(mm, pud);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (!pud_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpud_populate(mm, pud, new);\n\t} else\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n#else\n\tif (!pgd_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpgd_populate(mm, pud, new);\n\t} else /* Another has populated it */\n\t\tpmd_free(mm, new);\n#endif /* __ARCH_HAS_4LEVEL_HACK */\n\tspin_unlock(ptl);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tptl = pud_lock(mm, pud);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (!pud_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpud_populate(mm, pud, new);\n\t} else\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n#else\n\tif (!pgd_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpgd_populate(mm, pud, new);\n\t} else /* Another has populated it */\n\t\tpmd_free(mm, new);\n#endif /* __ARCH_HAS_4LEVEL_HACK */\n\tspin_unlock(ptl);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pud_alloc",
          "args": [
            "mm",
            "p4d",
            "addr"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "__pud_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3972-3996",
          "snippet": "int __pud_alloc(struct mm_struct *mm, p4d_t *p4d, unsigned long address)\n{\n\tpud_t *new = pud_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_5LEVEL_HACK\n\tif (!p4d_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tp4d_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#else\n\tif (!pgd_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tpgd_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#endif /* __ARCH_HAS_5LEVEL_HACK */\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pud_alloc(struct mm_struct *mm, p4d_t *p4d, unsigned long address)\n{\n\tpud_t *new = pud_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_5LEVEL_HACK\n\tif (!p4d_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tp4d_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#else\n\tif (!pgd_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tpgd_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#endif /* __ARCH_HAS_5LEVEL_HACK */\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p4d_alloc",
          "args": [
            "mm",
            "pgd",
            "addr"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "__p4d_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3949-3964",
          "snippet": "int __p4d_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)\n{\n\tp4d_t *new = p4d_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n\tif (pgd_present(*pgd))\t\t/* Another has populated it */\n\t\tp4d_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pgd, new);\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __p4d_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)\n{\n\tp4d_t *new = p4d_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n\tif (pgd_present(*pgd))\t\t/* Another has populated it */\n\t\tp4d_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pgd, new);\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgd_offset",
          "args": [
            "mm",
            "addr"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\npte_t *__get_locked_pte(struct mm_struct *mm, unsigned long addr,\n\t\t\tspinlock_t **ptl)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tp4d = p4d_alloc(mm, pgd, addr);\n\tif (!p4d)\n\t\treturn NULL;\n\tpud = pud_alloc(mm, p4d, addr);\n\tif (!pud)\n\t\treturn NULL;\n\tpmd = pmd_alloc(mm, pud, addr);\n\tif (!pmd)\n\t\treturn NULL;\n\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\treturn pte_alloc_map_lock(mm, pmd, addr, ptl);\n}"
  },
  {
    "function_name": "zap_vma_ptes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1404-1412",
    "snippet": "void zap_vma_ptes(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned long size)\n{\n\tif (address < vma->vm_start || address + size > vma->vm_end ||\n\t    \t\t!(vma->vm_flags & VM_PFNMAP))\n\t\treturn;\n\n\tzap_page_range_single(vma, address, size, NULL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zap_page_range_single",
          "args": [
            "vma",
            "address",
            "size",
            "NULL"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "zap_page_range_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1377-1391",
          "snippet": "static void zap_page_range_single(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned long size, struct zap_details *details)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mmu_gather tlb;\n\tunsigned long end = address + size;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, address, end);\n\tupdate_hiwater_rss(mm);\n\tmmu_notifier_invalidate_range_start(mm, address, end);\n\tunmap_single_vma(&tlb, vma, address, end, details);\n\tmmu_notifier_invalidate_range_end(mm, address, end);\n\ttlb_finish_mmu(&tlb, address, end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void zap_page_range_single(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned long size, struct zap_details *details)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mmu_gather tlb;\n\tunsigned long end = address + size;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, address, end);\n\tupdate_hiwater_rss(mm);\n\tmmu_notifier_invalidate_range_start(mm, address, end);\n\tunmap_single_vma(&tlb, vma, address, end, details);\n\tmmu_notifier_invalidate_range_end(mm, address, end);\n\ttlb_finish_mmu(&tlb, address, end);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid zap_vma_ptes(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned long size)\n{\n\tif (address < vma->vm_start || address + size > vma->vm_end ||\n\t    \t\t!(vma->vm_flags & VM_PFNMAP))\n\t\treturn;\n\n\tzap_page_range_single(vma, address, size, NULL);\n}"
  },
  {
    "function_name": "zap_page_range_single",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1377-1391",
    "snippet": "static void zap_page_range_single(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned long size, struct zap_details *details)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mmu_gather tlb;\n\tunsigned long end = address + size;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, address, end);\n\tupdate_hiwater_rss(mm);\n\tmmu_notifier_invalidate_range_start(mm, address, end);\n\tunmap_single_vma(&tlb, vma, address, end, details);\n\tmmu_notifier_invalidate_range_end(mm, address, end);\n\ttlb_finish_mmu(&tlb, address, end);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tlb_finish_mmu",
          "args": [
            "&tlb",
            "address",
            "end"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "tlb_finish_mmu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
          "lines": "247-261",
          "snippet": "void tlb_finish_mmu(struct mmu_gather *tlb,\n\t\tunsigned long start, unsigned long end)\n{\n\t/*\n\t * If there are parallel threads are doing PTE changes on same range\n\t * under non-exclusive lock(e.g., mmap_sem read-side) but defer TLB\n\t * flush by batching, a thread has stable TLB entry can fail to flush\n\t * the TLB by observing pte_none|!pte_dirty, for example so flush TLB\n\t * forcefully if we detect parallel PTE batching threads.\n\t */\n\tbool force = mm_tlb_flush_nested(tlb->mm);\n\n\tarch_tlb_finish_mmu(tlb, start, end, force);\n\tdec_tlb_flush_pending(tlb->mm);\n}",
          "includes": [
            "#include <asm/tlb.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/smp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid tlb_finish_mmu(struct mmu_gather *tlb,\n\t\tunsigned long start, unsigned long end)\n{\n\t/*\n\t * If there are parallel threads are doing PTE changes on same range\n\t * under non-exclusive lock(e.g., mmap_sem read-side) but defer TLB\n\t * flush by batching, a thread has stable TLB entry can fail to flush\n\t * the TLB by observing pte_none|!pte_dirty, for example so flush TLB\n\t * forcefully if we detect parallel PTE batching threads.\n\t */\n\tbool force = mm_tlb_flush_nested(tlb->mm);\n\n\tarch_tlb_finish_mmu(tlb, start, end, force);\n\tdec_tlb_flush_pending(tlb->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_end",
          "args": [
            "mm",
            "address",
            "end"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_single_vma",
          "args": [
            "&tlb",
            "vma",
            "address",
            "end",
            "details"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_single_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1270-1311",
          "snippet": "static void unmap_single_vma(struct mmu_gather *tlb,\n\t\tstruct vm_area_struct *vma, unsigned long start_addr,\n\t\tunsigned long end_addr,\n\t\tstruct zap_details *details)\n{\n\tunsigned long start = max(vma->vm_start, start_addr);\n\tunsigned long end;\n\n\tif (start >= vma->vm_end)\n\t\treturn;\n\tend = min(vma->vm_end, end_addr);\n\tif (end <= vma->vm_start)\n\t\treturn;\n\n\tif (vma->vm_file)\n\t\tuprobe_munmap(vma, start, end);\n\n\tif (unlikely(vma->vm_flags & VM_PFNMAP))\n\t\tuntrack_pfn(vma, 0, 0);\n\n\tif (start != end) {\n\t\tif (unlikely(is_vm_hugetlb_page(vma))) {\n\t\t\t/*\n\t\t\t * It is undesirable to test vma->vm_file as it\n\t\t\t * should be non-null for valid hugetlb area.\n\t\t\t * However, vm_file will be NULL in the error\n\t\t\t * cleanup path of mmap_region. When\n\t\t\t * hugetlbfs ->mmap method fails,\n\t\t\t * mmap_region() nullifies vma->vm_file\n\t\t\t * before calling this function to clean up.\n\t\t\t * Since no pte has actually been setup, it is\n\t\t\t * safe to do nothing in this case.\n\t\t\t */\n\t\t\tif (vma->vm_file) {\n\t\t\t\ti_mmap_lock_write(vma->vm_file->f_mapping);\n\t\t\t\t__unmap_hugepage_range_final(tlb, vma, start, end, NULL);\n\t\t\t\ti_mmap_unlock_write(vma->vm_file->f_mapping);\n\t\t\t}\n\t\t} else\n\t\t\tunmap_page_range(tlb, vma, start, end, details);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void unmap_single_vma(struct mmu_gather *tlb,\n\t\tstruct vm_area_struct *vma, unsigned long start_addr,\n\t\tunsigned long end_addr,\n\t\tstruct zap_details *details)\n{\n\tunsigned long start = max(vma->vm_start, start_addr);\n\tunsigned long end;\n\n\tif (start >= vma->vm_end)\n\t\treturn;\n\tend = min(vma->vm_end, end_addr);\n\tif (end <= vma->vm_start)\n\t\treturn;\n\n\tif (vma->vm_file)\n\t\tuprobe_munmap(vma, start, end);\n\n\tif (unlikely(vma->vm_flags & VM_PFNMAP))\n\t\tuntrack_pfn(vma, 0, 0);\n\n\tif (start != end) {\n\t\tif (unlikely(is_vm_hugetlb_page(vma))) {\n\t\t\t/*\n\t\t\t * It is undesirable to test vma->vm_file as it\n\t\t\t * should be non-null for valid hugetlb area.\n\t\t\t * However, vm_file will be NULL in the error\n\t\t\t * cleanup path of mmap_region. When\n\t\t\t * hugetlbfs ->mmap method fails,\n\t\t\t * mmap_region() nullifies vma->vm_file\n\t\t\t * before calling this function to clean up.\n\t\t\t * Since no pte has actually been setup, it is\n\t\t\t * safe to do nothing in this case.\n\t\t\t */\n\t\t\tif (vma->vm_file) {\n\t\t\t\ti_mmap_lock_write(vma->vm_file->f_mapping);\n\t\t\t\t__unmap_hugepage_range_final(tlb, vma, start, end, NULL);\n\t\t\t\ti_mmap_unlock_write(vma->vm_file->f_mapping);\n\t\t\t}\n\t\t} else\n\t\t\tunmap_page_range(tlb, vma, start, end, details);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "mm",
            "address",
            "end"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_hiwater_rss",
          "args": [
            "mm"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlb_gather_mmu",
          "args": [
            "&tlb",
            "mm",
            "address",
            "end"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "tlb_gather_mmu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
          "lines": "240-245",
          "snippet": "void tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm,\n\t\t\tunsigned long start, unsigned long end)\n{\n\tarch_tlb_gather_mmu(tlb, mm, start, end);\n\tinc_tlb_flush_pending(tlb->mm);\n}",
          "includes": [
            "#include <asm/tlb.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/smp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm,\n\t\t\tunsigned long start, unsigned long end)\n{\n\tarch_tlb_gather_mmu(tlb, mm, start, end);\n\tinc_tlb_flush_pending(tlb->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_add_drain",
          "args": [],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void zap_page_range_single(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned long size, struct zap_details *details)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mmu_gather tlb;\n\tunsigned long end = address + size;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, address, end);\n\tupdate_hiwater_rss(mm);\n\tmmu_notifier_invalidate_range_start(mm, address, end);\n\tunmap_single_vma(&tlb, vma, address, end, details);\n\tmmu_notifier_invalidate_range_end(mm, address, end);\n\ttlb_finish_mmu(&tlb, address, end);\n}"
  },
  {
    "function_name": "zap_page_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1351-1366",
    "snippet": "void zap_page_range(struct vm_area_struct *vma, unsigned long start,\n\t\tunsigned long size)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mmu_gather tlb;\n\tunsigned long end = start + size;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, start, end);\n\tupdate_hiwater_rss(mm);\n\tmmu_notifier_invalidate_range_start(mm, start, end);\n\tfor ( ; vma && vma->vm_start < end; vma = vma->vm_next)\n\t\tunmap_single_vma(&tlb, vma, start, end, NULL);\n\tmmu_notifier_invalidate_range_end(mm, start, end);\n\ttlb_finish_mmu(&tlb, start, end);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tlb_finish_mmu",
          "args": [
            "&tlb",
            "start",
            "end"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "tlb_finish_mmu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
          "lines": "247-261",
          "snippet": "void tlb_finish_mmu(struct mmu_gather *tlb,\n\t\tunsigned long start, unsigned long end)\n{\n\t/*\n\t * If there are parallel threads are doing PTE changes on same range\n\t * under non-exclusive lock(e.g., mmap_sem read-side) but defer TLB\n\t * flush by batching, a thread has stable TLB entry can fail to flush\n\t * the TLB by observing pte_none|!pte_dirty, for example so flush TLB\n\t * forcefully if we detect parallel PTE batching threads.\n\t */\n\tbool force = mm_tlb_flush_nested(tlb->mm);\n\n\tarch_tlb_finish_mmu(tlb, start, end, force);\n\tdec_tlb_flush_pending(tlb->mm);\n}",
          "includes": [
            "#include <asm/tlb.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/smp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid tlb_finish_mmu(struct mmu_gather *tlb,\n\t\tunsigned long start, unsigned long end)\n{\n\t/*\n\t * If there are parallel threads are doing PTE changes on same range\n\t * under non-exclusive lock(e.g., mmap_sem read-side) but defer TLB\n\t * flush by batching, a thread has stable TLB entry can fail to flush\n\t * the TLB by observing pte_none|!pte_dirty, for example so flush TLB\n\t * forcefully if we detect parallel PTE batching threads.\n\t */\n\tbool force = mm_tlb_flush_nested(tlb->mm);\n\n\tarch_tlb_finish_mmu(tlb, start, end, force);\n\tdec_tlb_flush_pending(tlb->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_end",
          "args": [
            "mm",
            "start",
            "end"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_single_vma",
          "args": [
            "&tlb",
            "vma",
            "start",
            "end",
            "NULL"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_single_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1270-1311",
          "snippet": "static void unmap_single_vma(struct mmu_gather *tlb,\n\t\tstruct vm_area_struct *vma, unsigned long start_addr,\n\t\tunsigned long end_addr,\n\t\tstruct zap_details *details)\n{\n\tunsigned long start = max(vma->vm_start, start_addr);\n\tunsigned long end;\n\n\tif (start >= vma->vm_end)\n\t\treturn;\n\tend = min(vma->vm_end, end_addr);\n\tif (end <= vma->vm_start)\n\t\treturn;\n\n\tif (vma->vm_file)\n\t\tuprobe_munmap(vma, start, end);\n\n\tif (unlikely(vma->vm_flags & VM_PFNMAP))\n\t\tuntrack_pfn(vma, 0, 0);\n\n\tif (start != end) {\n\t\tif (unlikely(is_vm_hugetlb_page(vma))) {\n\t\t\t/*\n\t\t\t * It is undesirable to test vma->vm_file as it\n\t\t\t * should be non-null for valid hugetlb area.\n\t\t\t * However, vm_file will be NULL in the error\n\t\t\t * cleanup path of mmap_region. When\n\t\t\t * hugetlbfs ->mmap method fails,\n\t\t\t * mmap_region() nullifies vma->vm_file\n\t\t\t * before calling this function to clean up.\n\t\t\t * Since no pte has actually been setup, it is\n\t\t\t * safe to do nothing in this case.\n\t\t\t */\n\t\t\tif (vma->vm_file) {\n\t\t\t\ti_mmap_lock_write(vma->vm_file->f_mapping);\n\t\t\t\t__unmap_hugepage_range_final(tlb, vma, start, end, NULL);\n\t\t\t\ti_mmap_unlock_write(vma->vm_file->f_mapping);\n\t\t\t}\n\t\t} else\n\t\t\tunmap_page_range(tlb, vma, start, end, details);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void unmap_single_vma(struct mmu_gather *tlb,\n\t\tstruct vm_area_struct *vma, unsigned long start_addr,\n\t\tunsigned long end_addr,\n\t\tstruct zap_details *details)\n{\n\tunsigned long start = max(vma->vm_start, start_addr);\n\tunsigned long end;\n\n\tif (start >= vma->vm_end)\n\t\treturn;\n\tend = min(vma->vm_end, end_addr);\n\tif (end <= vma->vm_start)\n\t\treturn;\n\n\tif (vma->vm_file)\n\t\tuprobe_munmap(vma, start, end);\n\n\tif (unlikely(vma->vm_flags & VM_PFNMAP))\n\t\tuntrack_pfn(vma, 0, 0);\n\n\tif (start != end) {\n\t\tif (unlikely(is_vm_hugetlb_page(vma))) {\n\t\t\t/*\n\t\t\t * It is undesirable to test vma->vm_file as it\n\t\t\t * should be non-null for valid hugetlb area.\n\t\t\t * However, vm_file will be NULL in the error\n\t\t\t * cleanup path of mmap_region. When\n\t\t\t * hugetlbfs ->mmap method fails,\n\t\t\t * mmap_region() nullifies vma->vm_file\n\t\t\t * before calling this function to clean up.\n\t\t\t * Since no pte has actually been setup, it is\n\t\t\t * safe to do nothing in this case.\n\t\t\t */\n\t\t\tif (vma->vm_file) {\n\t\t\t\ti_mmap_lock_write(vma->vm_file->f_mapping);\n\t\t\t\t__unmap_hugepage_range_final(tlb, vma, start, end, NULL);\n\t\t\t\ti_mmap_unlock_write(vma->vm_file->f_mapping);\n\t\t\t}\n\t\t} else\n\t\t\tunmap_page_range(tlb, vma, start, end, details);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "mm",
            "start",
            "end"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_hiwater_rss",
          "args": [
            "mm"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlb_gather_mmu",
          "args": [
            "&tlb",
            "mm",
            "start",
            "end"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "tlb_gather_mmu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
          "lines": "240-245",
          "snippet": "void tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm,\n\t\t\tunsigned long start, unsigned long end)\n{\n\tarch_tlb_gather_mmu(tlb, mm, start, end);\n\tinc_tlb_flush_pending(tlb->mm);\n}",
          "includes": [
            "#include <asm/tlb.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/smp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm,\n\t\t\tunsigned long start, unsigned long end)\n{\n\tarch_tlb_gather_mmu(tlb, mm, start, end);\n\tinc_tlb_flush_pending(tlb->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_add_drain",
          "args": [],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid zap_page_range(struct vm_area_struct *vma, unsigned long start,\n\t\tunsigned long size)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mmu_gather tlb;\n\tunsigned long end = start + size;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, start, end);\n\tupdate_hiwater_rss(mm);\n\tmmu_notifier_invalidate_range_start(mm, start, end);\n\tfor ( ; vma && vma->vm_start < end; vma = vma->vm_next)\n\t\tunmap_single_vma(&tlb, vma, start, end, NULL);\n\tmmu_notifier_invalidate_range_end(mm, start, end);\n\ttlb_finish_mmu(&tlb, start, end);\n}"
  },
  {
    "function_name": "unmap_vmas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1331-1341",
    "snippet": "void unmap_vmas(struct mmu_gather *tlb,\n\t\tstruct vm_area_struct *vma, unsigned long start_addr,\n\t\tunsigned long end_addr)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tmmu_notifier_invalidate_range_start(mm, start_addr, end_addr);\n\tfor ( ; vma && vma->vm_start < end_addr; vma = vma->vm_next)\n\t\tunmap_single_vma(tlb, vma, start_addr, end_addr, NULL);\n\tmmu_notifier_invalidate_range_end(mm, start_addr, end_addr);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_end",
          "args": [
            "mm",
            "start_addr",
            "end_addr"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_single_vma",
          "args": [
            "tlb",
            "vma",
            "start_addr",
            "end_addr",
            "NULL"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_single_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1270-1311",
          "snippet": "static void unmap_single_vma(struct mmu_gather *tlb,\n\t\tstruct vm_area_struct *vma, unsigned long start_addr,\n\t\tunsigned long end_addr,\n\t\tstruct zap_details *details)\n{\n\tunsigned long start = max(vma->vm_start, start_addr);\n\tunsigned long end;\n\n\tif (start >= vma->vm_end)\n\t\treturn;\n\tend = min(vma->vm_end, end_addr);\n\tif (end <= vma->vm_start)\n\t\treturn;\n\n\tif (vma->vm_file)\n\t\tuprobe_munmap(vma, start, end);\n\n\tif (unlikely(vma->vm_flags & VM_PFNMAP))\n\t\tuntrack_pfn(vma, 0, 0);\n\n\tif (start != end) {\n\t\tif (unlikely(is_vm_hugetlb_page(vma))) {\n\t\t\t/*\n\t\t\t * It is undesirable to test vma->vm_file as it\n\t\t\t * should be non-null for valid hugetlb area.\n\t\t\t * However, vm_file will be NULL in the error\n\t\t\t * cleanup path of mmap_region. When\n\t\t\t * hugetlbfs ->mmap method fails,\n\t\t\t * mmap_region() nullifies vma->vm_file\n\t\t\t * before calling this function to clean up.\n\t\t\t * Since no pte has actually been setup, it is\n\t\t\t * safe to do nothing in this case.\n\t\t\t */\n\t\t\tif (vma->vm_file) {\n\t\t\t\ti_mmap_lock_write(vma->vm_file->f_mapping);\n\t\t\t\t__unmap_hugepage_range_final(tlb, vma, start, end, NULL);\n\t\t\t\ti_mmap_unlock_write(vma->vm_file->f_mapping);\n\t\t\t}\n\t\t} else\n\t\t\tunmap_page_range(tlb, vma, start, end, details);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void unmap_single_vma(struct mmu_gather *tlb,\n\t\tstruct vm_area_struct *vma, unsigned long start_addr,\n\t\tunsigned long end_addr,\n\t\tstruct zap_details *details)\n{\n\tunsigned long start = max(vma->vm_start, start_addr);\n\tunsigned long end;\n\n\tif (start >= vma->vm_end)\n\t\treturn;\n\tend = min(vma->vm_end, end_addr);\n\tif (end <= vma->vm_start)\n\t\treturn;\n\n\tif (vma->vm_file)\n\t\tuprobe_munmap(vma, start, end);\n\n\tif (unlikely(vma->vm_flags & VM_PFNMAP))\n\t\tuntrack_pfn(vma, 0, 0);\n\n\tif (start != end) {\n\t\tif (unlikely(is_vm_hugetlb_page(vma))) {\n\t\t\t/*\n\t\t\t * It is undesirable to test vma->vm_file as it\n\t\t\t * should be non-null for valid hugetlb area.\n\t\t\t * However, vm_file will be NULL in the error\n\t\t\t * cleanup path of mmap_region. When\n\t\t\t * hugetlbfs ->mmap method fails,\n\t\t\t * mmap_region() nullifies vma->vm_file\n\t\t\t * before calling this function to clean up.\n\t\t\t * Since no pte has actually been setup, it is\n\t\t\t * safe to do nothing in this case.\n\t\t\t */\n\t\t\tif (vma->vm_file) {\n\t\t\t\ti_mmap_lock_write(vma->vm_file->f_mapping);\n\t\t\t\t__unmap_hugepage_range_final(tlb, vma, start, end, NULL);\n\t\t\t\ti_mmap_unlock_write(vma->vm_file->f_mapping);\n\t\t\t}\n\t\t} else\n\t\t\tunmap_page_range(tlb, vma, start, end, details);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "mm",
            "start_addr",
            "end_addr"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid unmap_vmas(struct mmu_gather *tlb,\n\t\tstruct vm_area_struct *vma, unsigned long start_addr,\n\t\tunsigned long end_addr)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tmmu_notifier_invalidate_range_start(mm, start_addr, end_addr);\n\tfor ( ; vma && vma->vm_start < end_addr; vma = vma->vm_next)\n\t\tunmap_single_vma(tlb, vma, start_addr, end_addr, NULL);\n\tmmu_notifier_invalidate_range_end(mm, start_addr, end_addr);\n}"
  },
  {
    "function_name": "unmap_single_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1270-1311",
    "snippet": "static void unmap_single_vma(struct mmu_gather *tlb,\n\t\tstruct vm_area_struct *vma, unsigned long start_addr,\n\t\tunsigned long end_addr,\n\t\tstruct zap_details *details)\n{\n\tunsigned long start = max(vma->vm_start, start_addr);\n\tunsigned long end;\n\n\tif (start >= vma->vm_end)\n\t\treturn;\n\tend = min(vma->vm_end, end_addr);\n\tif (end <= vma->vm_start)\n\t\treturn;\n\n\tif (vma->vm_file)\n\t\tuprobe_munmap(vma, start, end);\n\n\tif (unlikely(vma->vm_flags & VM_PFNMAP))\n\t\tuntrack_pfn(vma, 0, 0);\n\n\tif (start != end) {\n\t\tif (unlikely(is_vm_hugetlb_page(vma))) {\n\t\t\t/*\n\t\t\t * It is undesirable to test vma->vm_file as it\n\t\t\t * should be non-null for valid hugetlb area.\n\t\t\t * However, vm_file will be NULL in the error\n\t\t\t * cleanup path of mmap_region. When\n\t\t\t * hugetlbfs ->mmap method fails,\n\t\t\t * mmap_region() nullifies vma->vm_file\n\t\t\t * before calling this function to clean up.\n\t\t\t * Since no pte has actually been setup, it is\n\t\t\t * safe to do nothing in this case.\n\t\t\t */\n\t\t\tif (vma->vm_file) {\n\t\t\t\ti_mmap_lock_write(vma->vm_file->f_mapping);\n\t\t\t\t__unmap_hugepage_range_final(tlb, vma, start, end, NULL);\n\t\t\t\ti_mmap_unlock_write(vma->vm_file->f_mapping);\n\t\t\t}\n\t\t} else\n\t\t\tunmap_page_range(tlb, vma, start, end, details);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unmap_page_range",
          "args": [
            "tlb",
            "vma",
            "start",
            "end",
            "details"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1249-1267",
          "snippet": "void unmap_page_range(struct mmu_gather *tlb,\n\t\t\t     struct vm_area_struct *vma,\n\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t     struct zap_details *details)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\n\tBUG_ON(addr >= end);\n\ttlb_start_vma(tlb, vma);\n\tpgd = pgd_offset(vma->vm_mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tnext = zap_p4d_range(tlb, vma, pgd, addr, next, details);\n\t} while (pgd++, addr = next, addr != end);\n\ttlb_end_vma(tlb, vma);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid unmap_page_range(struct mmu_gather *tlb,\n\t\t\t     struct vm_area_struct *vma,\n\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t     struct zap_details *details)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\n\tBUG_ON(addr >= end);\n\ttlb_start_vma(tlb, vma);\n\tpgd = pgd_offset(vma->vm_mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tnext = zap_p4d_range(tlb, vma, pgd, addr, next, details);\n\t} while (pgd++, addr = next, addr != end);\n\ttlb_end_vma(tlb, vma);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_mmap_unlock_write",
          "args": [
            "vma->vm_file->f_mapping"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__unmap_hugepage_range_final",
          "args": [
            "tlb",
            "vma",
            "start",
            "end",
            "NULL"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "__unmap_hugepage_range_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3434-3451",
          "snippet": "void __unmap_hugepage_range_final(struct mmu_gather *tlb,\n\t\t\t  struct vm_area_struct *vma, unsigned long start,\n\t\t\t  unsigned long end, struct page *ref_page)\n{\n\t__unmap_hugepage_range(tlb, vma, start, end, ref_page);\n\n\t/*\n\t * Clear this flag so that x86's huge_pmd_share page_table_shareable\n\t * test will fail on a vma being torn down, and not grab a page table\n\t * on its way out.  We're lucky that the flag has such an appropriate\n\t * name, and can in fact be safely cleared here. We could clear it\n\t * before the __unmap_hugepage_range above, but all that's necessary\n\t * is to clear it before releasing the i_mmap_rwsem. This works\n\t * because in the context this is called, the VMA is about to be\n\t * destroyed and the i_mmap_rwsem is held.\n\t */\n\tvma->vm_flags &= ~VM_MAYSHARE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nvoid __unmap_hugepage_range_final(struct mmu_gather *tlb,\n\t\t\t  struct vm_area_struct *vma, unsigned long start,\n\t\t\t  unsigned long end, struct page *ref_page)\n{\n\t__unmap_hugepage_range(tlb, vma, start, end, ref_page);\n\n\t/*\n\t * Clear this flag so that x86's huge_pmd_share page_table_shareable\n\t * test will fail on a vma being torn down, and not grab a page table\n\t * on its way out.  We're lucky that the flag has such an appropriate\n\t * name, and can in fact be safely cleared here. We could clear it\n\t * before the __unmap_hugepage_range above, but all that's necessary\n\t * is to clear it before releasing the i_mmap_rwsem. This works\n\t * because in the context this is called, the VMA is about to be\n\t * destroyed and the i_mmap_rwsem is held.\n\t */\n\tvma->vm_flags &= ~VM_MAYSHARE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_mmap_lock_write",
          "args": [
            "vma->vm_file->f_mapping"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_vm_hugetlb_page(vma)"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untrack_pfn",
          "args": [
            "vma",
            "0",
            "0"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vma->vm_flags & VM_PFNMAP"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uprobe_munmap",
          "args": [
            "vma",
            "start",
            "end"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "vma->vm_end",
            "end_addr"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "vma->vm_start",
            "start_addr"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void unmap_single_vma(struct mmu_gather *tlb,\n\t\tstruct vm_area_struct *vma, unsigned long start_addr,\n\t\tunsigned long end_addr,\n\t\tstruct zap_details *details)\n{\n\tunsigned long start = max(vma->vm_start, start_addr);\n\tunsigned long end;\n\n\tif (start >= vma->vm_end)\n\t\treturn;\n\tend = min(vma->vm_end, end_addr);\n\tif (end <= vma->vm_start)\n\t\treturn;\n\n\tif (vma->vm_file)\n\t\tuprobe_munmap(vma, start, end);\n\n\tif (unlikely(vma->vm_flags & VM_PFNMAP))\n\t\tuntrack_pfn(vma, 0, 0);\n\n\tif (start != end) {\n\t\tif (unlikely(is_vm_hugetlb_page(vma))) {\n\t\t\t/*\n\t\t\t * It is undesirable to test vma->vm_file as it\n\t\t\t * should be non-null for valid hugetlb area.\n\t\t\t * However, vm_file will be NULL in the error\n\t\t\t * cleanup path of mmap_region. When\n\t\t\t * hugetlbfs ->mmap method fails,\n\t\t\t * mmap_region() nullifies vma->vm_file\n\t\t\t * before calling this function to clean up.\n\t\t\t * Since no pte has actually been setup, it is\n\t\t\t * safe to do nothing in this case.\n\t\t\t */\n\t\t\tif (vma->vm_file) {\n\t\t\t\ti_mmap_lock_write(vma->vm_file->f_mapping);\n\t\t\t\t__unmap_hugepage_range_final(tlb, vma, start, end, NULL);\n\t\t\t\ti_mmap_unlock_write(vma->vm_file->f_mapping);\n\t\t\t}\n\t\t} else\n\t\t\tunmap_page_range(tlb, vma, start, end, details);\n\t}\n}"
  },
  {
    "function_name": "unmap_page_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1249-1267",
    "snippet": "void unmap_page_range(struct mmu_gather *tlb,\n\t\t\t     struct vm_area_struct *vma,\n\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t     struct zap_details *details)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\n\tBUG_ON(addr >= end);\n\ttlb_start_vma(tlb, vma);\n\tpgd = pgd_offset(vma->vm_mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tnext = zap_p4d_range(tlb, vma, pgd, addr, next, details);\n\t} while (pgd++, addr = next, addr != end);\n\ttlb_end_vma(tlb, vma);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tlb_end_vma",
          "args": [
            "tlb",
            "vma"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zap_p4d_range",
          "args": [
            "tlb",
            "vma",
            "pgd",
            "addr",
            "next",
            "details"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "zap_p4d_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1230-1247",
          "snippet": "static inline unsigned long zap_p4d_range(struct mmu_gather *tlb,\n\t\t\t\tstruct vm_area_struct *vma, pgd_t *pgd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct zap_details *details)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\n\tp4d = p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none_or_clear_bad(p4d))\n\t\t\tcontinue;\n\t\tnext = zap_pud_range(tlb, vma, p4d, addr, next, details);\n\t} while (p4d++, addr = next, addr != end);\n\n\treturn addr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline unsigned long zap_p4d_range(struct mmu_gather *tlb,\n\t\t\t\tstruct vm_area_struct *vma, pgd_t *pgd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct zap_details *details)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\n\tp4d = p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none_or_clear_bad(p4d))\n\t\t\tcontinue;\n\t\tnext = zap_pud_range(tlb, vma, p4d, addr, next, details);\n\t} while (p4d++, addr = next, addr != end);\n\n\treturn addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgd_none_or_clear_bad",
          "args": [
            "pgd"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_offset",
          "args": [
            "vma->vm_mm",
            "addr"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlb_start_vma",
          "args": [
            "tlb",
            "vma"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "addr >= end"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid unmap_page_range(struct mmu_gather *tlb,\n\t\t\t     struct vm_area_struct *vma,\n\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t     struct zap_details *details)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\n\tBUG_ON(addr >= end);\n\ttlb_start_vma(tlb, vma);\n\tpgd = pgd_offset(vma->vm_mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tnext = zap_p4d_range(tlb, vma, pgd, addr, next, details);\n\t} while (pgd++, addr = next, addr != end);\n\ttlb_end_vma(tlb, vma);\n}"
  },
  {
    "function_name": "zap_p4d_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1230-1247",
    "snippet": "static inline unsigned long zap_p4d_range(struct mmu_gather *tlb,\n\t\t\t\tstruct vm_area_struct *vma, pgd_t *pgd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct zap_details *details)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\n\tp4d = p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none_or_clear_bad(p4d))\n\t\t\tcontinue;\n\t\tnext = zap_pud_range(tlb, vma, p4d, addr, next, details);\n\t} while (p4d++, addr = next, addr != end);\n\n\treturn addr;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zap_pud_range",
          "args": [
            "tlb",
            "vma",
            "p4d",
            "addr",
            "next",
            "details"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "zap_pud_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1201-1228",
          "snippet": "static inline unsigned long zap_pud_range(struct mmu_gather *tlb,\n\t\t\t\tstruct vm_area_struct *vma, p4d_t *p4d,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct zap_details *details)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\n\tpud = pud_offset(p4d, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_trans_huge(*pud) || pud_devmap(*pud)) {\n\t\t\tif (next - addr != HPAGE_PUD_SIZE) {\n\t\t\t\tVM_BUG_ON_VMA(!rwsem_is_locked(&tlb->mm->mmap_sem), vma);\n\t\t\t\tsplit_huge_pud(vma, pud, addr);\n\t\t\t} else if (zap_huge_pud(tlb, vma, pud, addr))\n\t\t\t\tgoto next;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pud_none_or_clear_bad(pud))\n\t\t\tcontinue;\n\t\tnext = zap_pmd_range(tlb, vma, pud, addr, next, details);\nnext:\n\t\tcond_resched();\n\t} while (pud++, addr = next, addr != end);\n\n\treturn addr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline unsigned long zap_pud_range(struct mmu_gather *tlb,\n\t\t\t\tstruct vm_area_struct *vma, p4d_t *p4d,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct zap_details *details)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\n\tpud = pud_offset(p4d, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_trans_huge(*pud) || pud_devmap(*pud)) {\n\t\t\tif (next - addr != HPAGE_PUD_SIZE) {\n\t\t\t\tVM_BUG_ON_VMA(!rwsem_is_locked(&tlb->mm->mmap_sem), vma);\n\t\t\t\tsplit_huge_pud(vma, pud, addr);\n\t\t\t} else if (zap_huge_pud(tlb, vma, pud, addr))\n\t\t\t\tgoto next;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pud_none_or_clear_bad(pud))\n\t\t\tcontinue;\n\t\tnext = zap_pmd_range(tlb, vma, pud, addr, next, details);\nnext:\n\t\tcond_resched();\n\t} while (pud++, addr = next, addr != end);\n\n\treturn addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p4d_none_or_clear_bad",
          "args": [
            "p4d"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_offset",
          "args": [
            "pgd",
            "addr"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline unsigned long zap_p4d_range(struct mmu_gather *tlb,\n\t\t\t\tstruct vm_area_struct *vma, pgd_t *pgd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct zap_details *details)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\n\tp4d = p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none_or_clear_bad(p4d))\n\t\t\tcontinue;\n\t\tnext = zap_pud_range(tlb, vma, p4d, addr, next, details);\n\t} while (p4d++, addr = next, addr != end);\n\n\treturn addr;\n}"
  },
  {
    "function_name": "zap_pud_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1201-1228",
    "snippet": "static inline unsigned long zap_pud_range(struct mmu_gather *tlb,\n\t\t\t\tstruct vm_area_struct *vma, p4d_t *p4d,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct zap_details *details)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\n\tpud = pud_offset(p4d, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_trans_huge(*pud) || pud_devmap(*pud)) {\n\t\t\tif (next - addr != HPAGE_PUD_SIZE) {\n\t\t\t\tVM_BUG_ON_VMA(!rwsem_is_locked(&tlb->mm->mmap_sem), vma);\n\t\t\t\tsplit_huge_pud(vma, pud, addr);\n\t\t\t} else if (zap_huge_pud(tlb, vma, pud, addr))\n\t\t\t\tgoto next;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pud_none_or_clear_bad(pud))\n\t\t\tcontinue;\n\t\tnext = zap_pmd_range(tlb, vma, pud, addr, next, details);\nnext:\n\t\tcond_resched();\n\t} while (pud++, addr = next, addr != end);\n\n\treturn addr;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zap_pmd_range",
          "args": [
            "tlb",
            "vma",
            "pud",
            "addr",
            "next",
            "details"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "zap_pmd_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1166-1199",
          "snippet": "static inline unsigned long zap_pmd_range(struct mmu_gather *tlb,\n\t\t\t\tstruct vm_area_struct *vma, pud_t *pud,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct zap_details *details)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) || pmd_devmap(*pmd)) {\n\t\t\tif (next - addr != HPAGE_PMD_SIZE)\n\t\t\t\t__split_huge_pmd(vma, pmd, addr, false, NULL);\n\t\t\telse if (zap_huge_pmd(tlb, vma, pmd, addr))\n\t\t\t\tgoto next;\n\t\t\t/* fall through */\n\t\t}\n\t\t/*\n\t\t * Here there can be other concurrent MADV_DONTNEED or\n\t\t * trans huge page faults running, and if the pmd is\n\t\t * none or trans huge it can change under us. This is\n\t\t * because MADV_DONTNEED holds the mmap_sem in read\n\t\t * mode.\n\t\t */\n\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n\t\t\tgoto next;\n\t\tnext = zap_pte_range(tlb, vma, pmd, addr, next, details);\nnext:\n\t\tcond_resched();\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn addr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline unsigned long zap_pmd_range(struct mmu_gather *tlb,\n\t\t\t\tstruct vm_area_struct *vma, pud_t *pud,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct zap_details *details)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) || pmd_devmap(*pmd)) {\n\t\t\tif (next - addr != HPAGE_PMD_SIZE)\n\t\t\t\t__split_huge_pmd(vma, pmd, addr, false, NULL);\n\t\t\telse if (zap_huge_pmd(tlb, vma, pmd, addr))\n\t\t\t\tgoto next;\n\t\t\t/* fall through */\n\t\t}\n\t\t/*\n\t\t * Here there can be other concurrent MADV_DONTNEED or\n\t\t * trans huge page faults running, and if the pmd is\n\t\t * none or trans huge it can change under us. This is\n\t\t * because MADV_DONTNEED holds the mmap_sem in read\n\t\t * mode.\n\t\t */\n\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n\t\t\tgoto next;\n\t\tnext = zap_pte_range(tlb, vma, pmd, addr, next, details);\nnext:\n\t\tcond_resched();\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pud_none_or_clear_bad",
          "args": [
            "pud"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zap_huge_pud",
          "args": [
            "tlb",
            "vma",
            "pud",
            "addr"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "zap_huge_pud",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1986-2012",
          "snippet": "int zap_huge_pud(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\t pud_t *pud, unsigned long addr)\n{\n\tpud_t orig_pud;\n\tspinlock_t *ptl;\n\n\tptl = __pud_trans_huge_lock(pud, vma);\n\tif (!ptl)\n\t\treturn 0;\n\t/*\n\t * For architectures like ppc64 we look at deposited pgtable\n\t * when calling pudp_huge_get_and_clear. So do the\n\t * pgtable_trans_huge_withdraw after finishing pudp related\n\t * operations.\n\t */\n\torig_pud = pudp_huge_get_and_clear_full(tlb->mm, addr, pud,\n\t\t\ttlb->fullmm);\n\ttlb_remove_pud_tlb_entry(tlb, pud, addr);\n\tif (vma_is_dax(vma)) {\n\t\tspin_unlock(ptl);\n\t\t/* No zero page support yet */\n\t} else {\n\t\t/* No support for anonymous PUD pages yet */\n\t\tBUG();\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint zap_huge_pud(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\t pud_t *pud, unsigned long addr)\n{\n\tpud_t orig_pud;\n\tspinlock_t *ptl;\n\n\tptl = __pud_trans_huge_lock(pud, vma);\n\tif (!ptl)\n\t\treturn 0;\n\t/*\n\t * For architectures like ppc64 we look at deposited pgtable\n\t * when calling pudp_huge_get_and_clear. So do the\n\t * pgtable_trans_huge_withdraw after finishing pudp related\n\t * operations.\n\t */\n\torig_pud = pudp_huge_get_and_clear_full(tlb->mm, addr, pud,\n\t\t\ttlb->fullmm);\n\ttlb_remove_pud_tlb_entry(tlb, pud, addr);\n\tif (vma_is_dax(vma)) {\n\t\tspin_unlock(ptl);\n\t\t/* No zero page support yet */\n\t} else {\n\t\t/* No support for anonymous PUD pages yet */\n\t\tBUG();\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "split_huge_pud",
          "args": [
            "vma",
            "pud",
            "addr"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "__split_huge_pud",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2027-2048",
          "snippet": "void __split_huge_pud(struct vm_area_struct *vma, pud_t *pud,\n\t\tunsigned long address)\n{\n\tspinlock_t *ptl;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long haddr = address & HPAGE_PUD_MASK;\n\n\tmmu_notifier_invalidate_range_start(mm, haddr, haddr + HPAGE_PUD_SIZE);\n\tptl = pud_lock(mm, pud);\n\tif (unlikely(!pud_trans_huge(*pud) && !pud_devmap(*pud)))\n\t\tgoto out;\n\t__split_huge_pud_locked(vma, pud, haddr);\n\nout:\n\tspin_unlock(ptl);\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback as\n\t * the above pudp_huge_clear_flush_notify() did already call it.\n\t */\n\tmmu_notifier_invalidate_range_only_end(mm, haddr, haddr +\n\t\t\t\t\t       HPAGE_PUD_SIZE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid __split_huge_pud(struct vm_area_struct *vma, pud_t *pud,\n\t\tunsigned long address)\n{\n\tspinlock_t *ptl;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long haddr = address & HPAGE_PUD_MASK;\n\n\tmmu_notifier_invalidate_range_start(mm, haddr, haddr + HPAGE_PUD_SIZE);\n\tptl = pud_lock(mm, pud);\n\tif (unlikely(!pud_trans_huge(*pud) && !pud_devmap(*pud)))\n\t\tgoto out;\n\t__split_huge_pud_locked(vma, pud, haddr);\n\nout:\n\tspin_unlock(ptl);\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback as\n\t * the above pudp_huge_clear_flush_notify() did already call it.\n\t */\n\tmmu_notifier_invalidate_range_only_end(mm, haddr, haddr +\n\t\t\t\t\t       HPAGE_PUD_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_VMA",
          "args": [
            "!rwsem_is_locked(&tlb->mm->mmap_sem)",
            "vma"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwsem_is_locked",
          "args": [
            "&tlb->mm->mmap_sem"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_devmap",
          "args": [
            "*pud"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_trans_huge",
          "args": [
            "*pud"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_offset",
          "args": [
            "p4d",
            "addr"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline unsigned long zap_pud_range(struct mmu_gather *tlb,\n\t\t\t\tstruct vm_area_struct *vma, p4d_t *p4d,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct zap_details *details)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\n\tpud = pud_offset(p4d, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_trans_huge(*pud) || pud_devmap(*pud)) {\n\t\t\tif (next - addr != HPAGE_PUD_SIZE) {\n\t\t\t\tVM_BUG_ON_VMA(!rwsem_is_locked(&tlb->mm->mmap_sem), vma);\n\t\t\t\tsplit_huge_pud(vma, pud, addr);\n\t\t\t} else if (zap_huge_pud(tlb, vma, pud, addr))\n\t\t\t\tgoto next;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pud_none_or_clear_bad(pud))\n\t\t\tcontinue;\n\t\tnext = zap_pmd_range(tlb, vma, pud, addr, next, details);\nnext:\n\t\tcond_resched();\n\t} while (pud++, addr = next, addr != end);\n\n\treturn addr;\n}"
  },
  {
    "function_name": "zap_pmd_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1166-1199",
    "snippet": "static inline unsigned long zap_pmd_range(struct mmu_gather *tlb,\n\t\t\t\tstruct vm_area_struct *vma, pud_t *pud,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct zap_details *details)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) || pmd_devmap(*pmd)) {\n\t\t\tif (next - addr != HPAGE_PMD_SIZE)\n\t\t\t\t__split_huge_pmd(vma, pmd, addr, false, NULL);\n\t\t\telse if (zap_huge_pmd(tlb, vma, pmd, addr))\n\t\t\t\tgoto next;\n\t\t\t/* fall through */\n\t\t}\n\t\t/*\n\t\t * Here there can be other concurrent MADV_DONTNEED or\n\t\t * trans huge page faults running, and if the pmd is\n\t\t * none or trans huge it can change under us. This is\n\t\t * because MADV_DONTNEED holds the mmap_sem in read\n\t\t * mode.\n\t\t */\n\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n\t\t\tgoto next;\n\t\tnext = zap_pte_range(tlb, vma, pmd, addr, next, details);\nnext:\n\t\tcond_resched();\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn addr;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zap_pte_range",
          "args": [
            "tlb",
            "vma",
            "pmd",
            "addr",
            "next",
            "details"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "zap_pte_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1036-1164",
          "snippet": "static unsigned long zap_pte_range(struct mmu_gather *tlb,\n\t\t\t\tstruct vm_area_struct *vma, pmd_t *pmd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct zap_details *details)\n{\n\tstruct mm_struct *mm = tlb->mm;\n\tint force_flush = 0;\n\tint rss[NR_MM_COUNTERS];\n\tspinlock_t *ptl;\n\tpte_t *start_pte;\n\tpte_t *pte;\n\tswp_entry_t entry;\n\n\ttlb_remove_check_page_size_change(tlb, PAGE_SIZE);\nagain:\n\tinit_rss_vec(rss);\n\tstart_pte = pte_offset_map_lock(mm, pmd, addr, &ptl);\n\tpte = start_pte;\n\tflush_tlb_batched_pending(mm);\n\tarch_enter_lazy_mmu_mode();\n\tdo {\n\t\tpte_t ptent = *pte;\n\t\tif (pte_none(ptent))\n\t\t\tcontinue;\n\n\t\tif (pte_present(ptent)) {\n\t\t\tstruct page *page;\n\n\t\t\tpage = _vm_normal_page(vma, addr, ptent, true);\n\t\t\tif (unlikely(details) && page) {\n\t\t\t\t/*\n\t\t\t\t * unmap_shared_mapping_pages() wants to\n\t\t\t\t * invalidate cache without truncating:\n\t\t\t\t * unmap shared but keep private pages.\n\t\t\t\t */\n\t\t\t\tif (details->check_mapping &&\n\t\t\t\t    details->check_mapping != page_rmapping(page))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tptent = ptep_get_and_clear_full(mm, addr, pte,\n\t\t\t\t\t\t\ttlb->fullmm);\n\t\t\ttlb_remove_tlb_entry(tlb, pte, addr);\n\t\t\tif (unlikely(!page))\n\t\t\t\tcontinue;\n\n\t\t\tif (!PageAnon(page)) {\n\t\t\t\tif (pte_dirty(ptent)) {\n\t\t\t\t\tforce_flush = 1;\n\t\t\t\t\tset_page_dirty(page);\n\t\t\t\t}\n\t\t\t\tif (pte_young(ptent) &&\n\t\t\t\t    likely(!(vma->vm_flags & VM_SEQ_READ)))\n\t\t\t\t\tmark_page_accessed(page);\n\t\t\t}\n\t\t\trss[mm_counter(page)]--;\n\t\t\tpage_remove_rmap(page, false);\n\t\t\tif (unlikely(page_mapcount(page) < 0))\n\t\t\t\tprint_bad_pte(vma, addr, ptent, page);\n\t\t\tif (unlikely(__tlb_remove_page(tlb, page))) {\n\t\t\t\tforce_flush = 1;\n\t\t\t\taddr += PAGE_SIZE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tentry = pte_to_swp_entry(ptent);\n\t\tif (non_swap_entry(entry) && is_device_private_entry(entry)) {\n\t\t\tstruct page *page = device_private_entry_to_page(entry);\n\n\t\t\tif (unlikely(details && details->check_mapping)) {\n\t\t\t\t/*\n\t\t\t\t * unmap_shared_mapping_pages() wants to\n\t\t\t\t * invalidate cache without truncating:\n\t\t\t\t * unmap shared but keep private pages.\n\t\t\t\t */\n\t\t\t\tif (details->check_mapping !=\n\t\t\t\t    page_rmapping(page))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpte_clear_not_present_full(mm, addr, pte, tlb->fullmm);\n\t\t\trss[mm_counter(page)]--;\n\t\t\tpage_remove_rmap(page, false);\n\t\t\tput_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* If details->check_mapping, we leave swap entries. */\n\t\tif (unlikely(details))\n\t\t\tcontinue;\n\n\t\tentry = pte_to_swp_entry(ptent);\n\t\tif (!non_swap_entry(entry))\n\t\t\trss[MM_SWAPENTS]--;\n\t\telse if (is_migration_entry(entry)) {\n\t\t\tstruct page *page;\n\n\t\t\tpage = migration_entry_to_page(entry);\n\t\t\trss[mm_counter(page)]--;\n\t\t}\n\t\tif (unlikely(!free_swap_and_cache(entry)))\n\t\t\tprint_bad_pte(vma, addr, ptent, NULL);\n\t\tpte_clear_not_present_full(mm, addr, pte, tlb->fullmm);\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\n\tadd_mm_rss_vec(mm, rss);\n\tarch_leave_lazy_mmu_mode();\n\n\t/* Do the actual TLB flush before dropping ptl */\n\tif (force_flush)\n\t\ttlb_flush_mmu_tlbonly(tlb);\n\tpte_unmap_unlock(start_pte, ptl);\n\n\t/*\n\t * If we forced a TLB flush (either due to running out of\n\t * batch buffers or because we needed to flush dirty TLB\n\t * entries before releasing the ptl), free the batched\n\t * memory too. Restart if we didn't do everything.\n\t */\n\tif (force_flush) {\n\t\tforce_flush = 0;\n\t\ttlb_flush_mmu_free(tlb);\n\t\tif (addr != end)\n\t\t\tgoto again;\n\t}\n\n\treturn addr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic unsigned long zap_pte_range(struct mmu_gather *tlb,\n\t\t\t\tstruct vm_area_struct *vma, pmd_t *pmd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct zap_details *details)\n{\n\tstruct mm_struct *mm = tlb->mm;\n\tint force_flush = 0;\n\tint rss[NR_MM_COUNTERS];\n\tspinlock_t *ptl;\n\tpte_t *start_pte;\n\tpte_t *pte;\n\tswp_entry_t entry;\n\n\ttlb_remove_check_page_size_change(tlb, PAGE_SIZE);\nagain:\n\tinit_rss_vec(rss);\n\tstart_pte = pte_offset_map_lock(mm, pmd, addr, &ptl);\n\tpte = start_pte;\n\tflush_tlb_batched_pending(mm);\n\tarch_enter_lazy_mmu_mode();\n\tdo {\n\t\tpte_t ptent = *pte;\n\t\tif (pte_none(ptent))\n\t\t\tcontinue;\n\n\t\tif (pte_present(ptent)) {\n\t\t\tstruct page *page;\n\n\t\t\tpage = _vm_normal_page(vma, addr, ptent, true);\n\t\t\tif (unlikely(details) && page) {\n\t\t\t\t/*\n\t\t\t\t * unmap_shared_mapping_pages() wants to\n\t\t\t\t * invalidate cache without truncating:\n\t\t\t\t * unmap shared but keep private pages.\n\t\t\t\t */\n\t\t\t\tif (details->check_mapping &&\n\t\t\t\t    details->check_mapping != page_rmapping(page))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tptent = ptep_get_and_clear_full(mm, addr, pte,\n\t\t\t\t\t\t\ttlb->fullmm);\n\t\t\ttlb_remove_tlb_entry(tlb, pte, addr);\n\t\t\tif (unlikely(!page))\n\t\t\t\tcontinue;\n\n\t\t\tif (!PageAnon(page)) {\n\t\t\t\tif (pte_dirty(ptent)) {\n\t\t\t\t\tforce_flush = 1;\n\t\t\t\t\tset_page_dirty(page);\n\t\t\t\t}\n\t\t\t\tif (pte_young(ptent) &&\n\t\t\t\t    likely(!(vma->vm_flags & VM_SEQ_READ)))\n\t\t\t\t\tmark_page_accessed(page);\n\t\t\t}\n\t\t\trss[mm_counter(page)]--;\n\t\t\tpage_remove_rmap(page, false);\n\t\t\tif (unlikely(page_mapcount(page) < 0))\n\t\t\t\tprint_bad_pte(vma, addr, ptent, page);\n\t\t\tif (unlikely(__tlb_remove_page(tlb, page))) {\n\t\t\t\tforce_flush = 1;\n\t\t\t\taddr += PAGE_SIZE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tentry = pte_to_swp_entry(ptent);\n\t\tif (non_swap_entry(entry) && is_device_private_entry(entry)) {\n\t\t\tstruct page *page = device_private_entry_to_page(entry);\n\n\t\t\tif (unlikely(details && details->check_mapping)) {\n\t\t\t\t/*\n\t\t\t\t * unmap_shared_mapping_pages() wants to\n\t\t\t\t * invalidate cache without truncating:\n\t\t\t\t * unmap shared but keep private pages.\n\t\t\t\t */\n\t\t\t\tif (details->check_mapping !=\n\t\t\t\t    page_rmapping(page))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpte_clear_not_present_full(mm, addr, pte, tlb->fullmm);\n\t\t\trss[mm_counter(page)]--;\n\t\t\tpage_remove_rmap(page, false);\n\t\t\tput_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* If details->check_mapping, we leave swap entries. */\n\t\tif (unlikely(details))\n\t\t\tcontinue;\n\n\t\tentry = pte_to_swp_entry(ptent);\n\t\tif (!non_swap_entry(entry))\n\t\t\trss[MM_SWAPENTS]--;\n\t\telse if (is_migration_entry(entry)) {\n\t\t\tstruct page *page;\n\n\t\t\tpage = migration_entry_to_page(entry);\n\t\t\trss[mm_counter(page)]--;\n\t\t}\n\t\tif (unlikely(!free_swap_and_cache(entry)))\n\t\t\tprint_bad_pte(vma, addr, ptent, NULL);\n\t\tpte_clear_not_present_full(mm, addr, pte, tlb->fullmm);\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\n\tadd_mm_rss_vec(mm, rss);\n\tarch_leave_lazy_mmu_mode();\n\n\t/* Do the actual TLB flush before dropping ptl */\n\tif (force_flush)\n\t\ttlb_flush_mmu_tlbonly(tlb);\n\tpte_unmap_unlock(start_pte, ptl);\n\n\t/*\n\t * If we forced a TLB flush (either due to running out of\n\t * batch buffers or because we needed to flush dirty TLB\n\t * entries before releasing the ptl), free the batched\n\t * memory too. Restart if we didn't do everything.\n\t */\n\tif (force_flush) {\n\t\tforce_flush = 0;\n\t\ttlb_flush_mmu_free(tlb);\n\t\tif (addr != end)\n\t\t\tgoto again;\n\t}\n\n\treturn addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_none_or_trans_huge_or_clear_bad",
          "args": [
            "pmd"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zap_huge_pmd",
          "args": [
            "tlb",
            "vma",
            "pmd",
            "addr"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "zap_huge_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1718-1781",
          "snippet": "int zap_huge_pmd(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\t pmd_t *pmd, unsigned long addr)\n{\n\tpmd_t orig_pmd;\n\tspinlock_t *ptl;\n\n\ttlb_remove_check_page_size_change(tlb, HPAGE_PMD_SIZE);\n\n\tptl = __pmd_trans_huge_lock(pmd, vma);\n\tif (!ptl)\n\t\treturn 0;\n\t/*\n\t * For architectures like ppc64 we look at deposited pgtable\n\t * when calling pmdp_huge_get_and_clear. So do the\n\t * pgtable_trans_huge_withdraw after finishing pmdp related\n\t * operations.\n\t */\n\torig_pmd = pmdp_huge_get_and_clear_full(tlb->mm, addr, pmd,\n\t\t\ttlb->fullmm);\n\ttlb_remove_pmd_tlb_entry(tlb, pmd, addr);\n\tif (vma_is_dax(vma)) {\n\t\tif (arch_needs_pgtable_deposit())\n\t\t\tzap_deposited_table(tlb->mm, pmd);\n\t\tspin_unlock(ptl);\n\t\tif (is_huge_zero_pmd(orig_pmd))\n\t\t\ttlb_remove_page_size(tlb, pmd_page(orig_pmd), HPAGE_PMD_SIZE);\n\t} else if (is_huge_zero_pmd(orig_pmd)) {\n\t\tzap_deposited_table(tlb->mm, pmd);\n\t\tspin_unlock(ptl);\n\t\ttlb_remove_page_size(tlb, pmd_page(orig_pmd), HPAGE_PMD_SIZE);\n\t} else {\n\t\tstruct page *page = NULL;\n\t\tint flush_needed = 1;\n\n\t\tif (pmd_present(orig_pmd)) {\n\t\t\tpage = pmd_page(orig_pmd);\n\t\t\tpage_remove_rmap(page, true);\n\t\t\tVM_BUG_ON_PAGE(page_mapcount(page) < 0, page);\n\t\t\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\t\t} else if (thp_migration_supported()) {\n\t\t\tswp_entry_t entry;\n\n\t\t\tVM_BUG_ON(!is_pmd_migration_entry(orig_pmd));\n\t\t\tentry = pmd_to_swp_entry(orig_pmd);\n\t\t\tpage = pfn_to_page(swp_offset(entry));\n\t\t\tflush_needed = 0;\n\t\t} else\n\t\t\tWARN_ONCE(1, \"Non present huge pmd without pmd migration enabled!\");\n\n\t\tif (PageAnon(page)) {\n\t\t\tzap_deposited_table(tlb->mm, pmd);\n\t\t\tadd_mm_counter(tlb->mm, MM_ANONPAGES, -HPAGE_PMD_NR);\n\t\t} else {\n\t\t\tif (arch_needs_pgtable_deposit())\n\t\t\t\tzap_deposited_table(tlb->mm, pmd);\n\t\t\tadd_mm_counter(tlb->mm, mm_counter_file(page), -HPAGE_PMD_NR);\n\t\t}\n\n\t\tspin_unlock(ptl);\n\t\tif (flush_needed)\n\t\t\ttlb_remove_page_size(tlb, page, HPAGE_PMD_SIZE);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint zap_huge_pmd(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\t pmd_t *pmd, unsigned long addr)\n{\n\tpmd_t orig_pmd;\n\tspinlock_t *ptl;\n\n\ttlb_remove_check_page_size_change(tlb, HPAGE_PMD_SIZE);\n\n\tptl = __pmd_trans_huge_lock(pmd, vma);\n\tif (!ptl)\n\t\treturn 0;\n\t/*\n\t * For architectures like ppc64 we look at deposited pgtable\n\t * when calling pmdp_huge_get_and_clear. So do the\n\t * pgtable_trans_huge_withdraw after finishing pmdp related\n\t * operations.\n\t */\n\torig_pmd = pmdp_huge_get_and_clear_full(tlb->mm, addr, pmd,\n\t\t\ttlb->fullmm);\n\ttlb_remove_pmd_tlb_entry(tlb, pmd, addr);\n\tif (vma_is_dax(vma)) {\n\t\tif (arch_needs_pgtable_deposit())\n\t\t\tzap_deposited_table(tlb->mm, pmd);\n\t\tspin_unlock(ptl);\n\t\tif (is_huge_zero_pmd(orig_pmd))\n\t\t\ttlb_remove_page_size(tlb, pmd_page(orig_pmd), HPAGE_PMD_SIZE);\n\t} else if (is_huge_zero_pmd(orig_pmd)) {\n\t\tzap_deposited_table(tlb->mm, pmd);\n\t\tspin_unlock(ptl);\n\t\ttlb_remove_page_size(tlb, pmd_page(orig_pmd), HPAGE_PMD_SIZE);\n\t} else {\n\t\tstruct page *page = NULL;\n\t\tint flush_needed = 1;\n\n\t\tif (pmd_present(orig_pmd)) {\n\t\t\tpage = pmd_page(orig_pmd);\n\t\t\tpage_remove_rmap(page, true);\n\t\t\tVM_BUG_ON_PAGE(page_mapcount(page) < 0, page);\n\t\t\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\t\t} else if (thp_migration_supported()) {\n\t\t\tswp_entry_t entry;\n\n\t\t\tVM_BUG_ON(!is_pmd_migration_entry(orig_pmd));\n\t\t\tentry = pmd_to_swp_entry(orig_pmd);\n\t\t\tpage = pfn_to_page(swp_offset(entry));\n\t\t\tflush_needed = 0;\n\t\t} else\n\t\t\tWARN_ONCE(1, \"Non present huge pmd without pmd migration enabled!\");\n\n\t\tif (PageAnon(page)) {\n\t\t\tzap_deposited_table(tlb->mm, pmd);\n\t\t\tadd_mm_counter(tlb->mm, MM_ANONPAGES, -HPAGE_PMD_NR);\n\t\t} else {\n\t\t\tif (arch_needs_pgtable_deposit())\n\t\t\t\tzap_deposited_table(tlb->mm, pmd);\n\t\t\tadd_mm_counter(tlb->mm, mm_counter_file(page), -HPAGE_PMD_NR);\n\t\t}\n\n\t\tspin_unlock(ptl);\n\t\tif (flush_needed)\n\t\t\ttlb_remove_page_size(tlb, page, HPAGE_PMD_SIZE);\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__split_huge_pmd",
          "args": [
            "vma",
            "pmd",
            "addr",
            "false",
            "NULL"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "__split_huge_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2243-2285",
          "snippet": "void __split_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long address, bool freeze, struct page *page)\n{\n\tspinlock_t *ptl;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long haddr = address & HPAGE_PMD_MASK;\n\n\tmmu_notifier_invalidate_range_start(mm, haddr, haddr + HPAGE_PMD_SIZE);\n\tptl = pmd_lock(mm, pmd);\n\n\t/*\n\t * If caller asks to setup a migration entries, we need a page to check\n\t * pmd against. Otherwise we can end up replacing wrong page.\n\t */\n\tVM_BUG_ON(freeze && !page);\n\tif (page && page != pmd_page(*pmd))\n\t        goto out;\n\n\tif (pmd_trans_huge(*pmd)) {\n\t\tpage = pmd_page(*pmd);\n\t\tif (PageMlocked(page))\n\t\t\tclear_page_mlock(page);\n\t} else if (!(pmd_devmap(*pmd) || is_pmd_migration_entry(*pmd)))\n\t\tgoto out;\n\t__split_huge_pmd_locked(vma, pmd, haddr, freeze);\nout:\n\tspin_unlock(ptl);\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback.\n\t * They are 3 cases to consider inside __split_huge_pmd_locked():\n\t *  1) pmdp_huge_clear_flush_notify() call invalidate_range() obvious\n\t *  2) __split_huge_zero_page_pmd() read only zero page and any write\n\t *    fault will trigger a flush_notify before pointing to a new page\n\t *    (it is fine if the secondary mmu keeps pointing to the old zero\n\t *    page in the meantime)\n\t *  3) Split a huge pmd into pte pointing to the same page. No need\n\t *     to invalidate secondary tlb entry they are all still valid.\n\t *     any further changes to individual pte will notify. So no need\n\t *     to call mmu_notifier->invalidate_range()\n\t */\n\tmmu_notifier_invalidate_range_only_end(mm, haddr, haddr +\n\t\t\t\t\t       HPAGE_PMD_SIZE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid __split_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long address, bool freeze, struct page *page)\n{\n\tspinlock_t *ptl;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long haddr = address & HPAGE_PMD_MASK;\n\n\tmmu_notifier_invalidate_range_start(mm, haddr, haddr + HPAGE_PMD_SIZE);\n\tptl = pmd_lock(mm, pmd);\n\n\t/*\n\t * If caller asks to setup a migration entries, we need a page to check\n\t * pmd against. Otherwise we can end up replacing wrong page.\n\t */\n\tVM_BUG_ON(freeze && !page);\n\tif (page && page != pmd_page(*pmd))\n\t        goto out;\n\n\tif (pmd_trans_huge(*pmd)) {\n\t\tpage = pmd_page(*pmd);\n\t\tif (PageMlocked(page))\n\t\t\tclear_page_mlock(page);\n\t} else if (!(pmd_devmap(*pmd) || is_pmd_migration_entry(*pmd)))\n\t\tgoto out;\n\t__split_huge_pmd_locked(vma, pmd, haddr, freeze);\nout:\n\tspin_unlock(ptl);\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback.\n\t * They are 3 cases to consider inside __split_huge_pmd_locked():\n\t *  1) pmdp_huge_clear_flush_notify() call invalidate_range() obvious\n\t *  2) __split_huge_zero_page_pmd() read only zero page and any write\n\t *    fault will trigger a flush_notify before pointing to a new page\n\t *    (it is fine if the secondary mmu keeps pointing to the old zero\n\t *    page in the meantime)\n\t *  3) Split a huge pmd into pte pointing to the same page. No need\n\t *     to invalidate secondary tlb entry they are all still valid.\n\t *     any further changes to individual pte will notify. So no need\n\t *     to call mmu_notifier->invalidate_range()\n\t */\n\tmmu_notifier_invalidate_range_only_end(mm, haddr, haddr +\n\t\t\t\t\t       HPAGE_PMD_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_devmap",
          "args": [
            "*pmd"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "pmd_devmap_trans_unstable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3023-3026",
          "snippet": "static int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "*pmd"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swap_pmd",
          "args": [
            "*pmd"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_offset",
          "args": [
            "pud",
            "addr"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline unsigned long zap_pmd_range(struct mmu_gather *tlb,\n\t\t\t\tstruct vm_area_struct *vma, pud_t *pud,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct zap_details *details)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) || pmd_devmap(*pmd)) {\n\t\t\tif (next - addr != HPAGE_PMD_SIZE)\n\t\t\t\t__split_huge_pmd(vma, pmd, addr, false, NULL);\n\t\t\telse if (zap_huge_pmd(tlb, vma, pmd, addr))\n\t\t\t\tgoto next;\n\t\t\t/* fall through */\n\t\t}\n\t\t/*\n\t\t * Here there can be other concurrent MADV_DONTNEED or\n\t\t * trans huge page faults running, and if the pmd is\n\t\t * none or trans huge it can change under us. This is\n\t\t * because MADV_DONTNEED holds the mmap_sem in read\n\t\t * mode.\n\t\t */\n\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n\t\t\tgoto next;\n\t\tnext = zap_pte_range(tlb, vma, pmd, addr, next, details);\nnext:\n\t\tcond_resched();\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn addr;\n}"
  },
  {
    "function_name": "zap_pte_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "1036-1164",
    "snippet": "static unsigned long zap_pte_range(struct mmu_gather *tlb,\n\t\t\t\tstruct vm_area_struct *vma, pmd_t *pmd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct zap_details *details)\n{\n\tstruct mm_struct *mm = tlb->mm;\n\tint force_flush = 0;\n\tint rss[NR_MM_COUNTERS];\n\tspinlock_t *ptl;\n\tpte_t *start_pte;\n\tpte_t *pte;\n\tswp_entry_t entry;\n\n\ttlb_remove_check_page_size_change(tlb, PAGE_SIZE);\nagain:\n\tinit_rss_vec(rss);\n\tstart_pte = pte_offset_map_lock(mm, pmd, addr, &ptl);\n\tpte = start_pte;\n\tflush_tlb_batched_pending(mm);\n\tarch_enter_lazy_mmu_mode();\n\tdo {\n\t\tpte_t ptent = *pte;\n\t\tif (pte_none(ptent))\n\t\t\tcontinue;\n\n\t\tif (pte_present(ptent)) {\n\t\t\tstruct page *page;\n\n\t\t\tpage = _vm_normal_page(vma, addr, ptent, true);\n\t\t\tif (unlikely(details) && page) {\n\t\t\t\t/*\n\t\t\t\t * unmap_shared_mapping_pages() wants to\n\t\t\t\t * invalidate cache without truncating:\n\t\t\t\t * unmap shared but keep private pages.\n\t\t\t\t */\n\t\t\t\tif (details->check_mapping &&\n\t\t\t\t    details->check_mapping != page_rmapping(page))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tptent = ptep_get_and_clear_full(mm, addr, pte,\n\t\t\t\t\t\t\ttlb->fullmm);\n\t\t\ttlb_remove_tlb_entry(tlb, pte, addr);\n\t\t\tif (unlikely(!page))\n\t\t\t\tcontinue;\n\n\t\t\tif (!PageAnon(page)) {\n\t\t\t\tif (pte_dirty(ptent)) {\n\t\t\t\t\tforce_flush = 1;\n\t\t\t\t\tset_page_dirty(page);\n\t\t\t\t}\n\t\t\t\tif (pte_young(ptent) &&\n\t\t\t\t    likely(!(vma->vm_flags & VM_SEQ_READ)))\n\t\t\t\t\tmark_page_accessed(page);\n\t\t\t}\n\t\t\trss[mm_counter(page)]--;\n\t\t\tpage_remove_rmap(page, false);\n\t\t\tif (unlikely(page_mapcount(page) < 0))\n\t\t\t\tprint_bad_pte(vma, addr, ptent, page);\n\t\t\tif (unlikely(__tlb_remove_page(tlb, page))) {\n\t\t\t\tforce_flush = 1;\n\t\t\t\taddr += PAGE_SIZE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tentry = pte_to_swp_entry(ptent);\n\t\tif (non_swap_entry(entry) && is_device_private_entry(entry)) {\n\t\t\tstruct page *page = device_private_entry_to_page(entry);\n\n\t\t\tif (unlikely(details && details->check_mapping)) {\n\t\t\t\t/*\n\t\t\t\t * unmap_shared_mapping_pages() wants to\n\t\t\t\t * invalidate cache without truncating:\n\t\t\t\t * unmap shared but keep private pages.\n\t\t\t\t */\n\t\t\t\tif (details->check_mapping !=\n\t\t\t\t    page_rmapping(page))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpte_clear_not_present_full(mm, addr, pte, tlb->fullmm);\n\t\t\trss[mm_counter(page)]--;\n\t\t\tpage_remove_rmap(page, false);\n\t\t\tput_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* If details->check_mapping, we leave swap entries. */\n\t\tif (unlikely(details))\n\t\t\tcontinue;\n\n\t\tentry = pte_to_swp_entry(ptent);\n\t\tif (!non_swap_entry(entry))\n\t\t\trss[MM_SWAPENTS]--;\n\t\telse if (is_migration_entry(entry)) {\n\t\t\tstruct page *page;\n\n\t\t\tpage = migration_entry_to_page(entry);\n\t\t\trss[mm_counter(page)]--;\n\t\t}\n\t\tif (unlikely(!free_swap_and_cache(entry)))\n\t\t\tprint_bad_pte(vma, addr, ptent, NULL);\n\t\tpte_clear_not_present_full(mm, addr, pte, tlb->fullmm);\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\n\tadd_mm_rss_vec(mm, rss);\n\tarch_leave_lazy_mmu_mode();\n\n\t/* Do the actual TLB flush before dropping ptl */\n\tif (force_flush)\n\t\ttlb_flush_mmu_tlbonly(tlb);\n\tpte_unmap_unlock(start_pte, ptl);\n\n\t/*\n\t * If we forced a TLB flush (either due to running out of\n\t * batch buffers or because we needed to flush dirty TLB\n\t * entries before releasing the ptl), free the batched\n\t * memory too. Restart if we didn't do everything.\n\t */\n\tif (force_flush) {\n\t\tforce_flush = 0;\n\t\ttlb_flush_mmu_free(tlb);\n\t\tif (addr != end)\n\t\t\tgoto again;\n\t}\n\n\treturn addr;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tlb_flush_mmu_free",
          "args": [
            "tlb"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "tlb_flush_mmu_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
          "lines": "66-78",
          "snippet": "void tlb_flush_mmu_free(struct mmu_gather *tlb)\n{\n\tstruct mmu_gather_batch *batch;\n\n#ifdef CONFIG_HAVE_RCU_TABLE_FREE\n\ttlb_table_flush(tlb);\n#endif\n\tfor (batch = &tlb->local; batch && batch->nr; batch = batch->next) {\n\t\tfree_pages_and_swap_cache(batch->pages, batch->nr);\n\t\tbatch->nr = 0;\n\t}\n\ttlb->active = &tlb->local;\n}",
          "includes": [
            "#include <asm/tlb.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/smp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid tlb_flush_mmu_free(struct mmu_gather *tlb)\n{\n\tstruct mmu_gather_batch *batch;\n\n#ifdef CONFIG_HAVE_RCU_TABLE_FREE\n\ttlb_table_flush(tlb);\n#endif\n\tfor (batch = &tlb->local; batch && batch->nr; batch = batch->next) {\n\t\tfree_pages_and_swap_cache(batch->pages, batch->nr);\n\t\tbatch->nr = 0;\n\t}\n\ttlb->active = &tlb->local;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "start_pte",
            "ptl"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlb_flush_mmu_tlbonly",
          "args": [
            "tlb"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_leave_lazy_mmu_mode",
          "args": [],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_mm_rss_vec",
          "args": [
            "mm",
            "rss"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "add_mm_rss_vec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "461-470",
          "snippet": "static inline void add_mm_rss_vec(struct mm_struct *mm, int *rss)\n{\n\tint i;\n\n\tif (current->mm == mm)\n\t\tsync_mm_rss(mm);\n\tfor (i = 0; i < NR_MM_COUNTERS; i++)\n\t\tif (rss[i])\n\t\t\tadd_mm_counter(mm, i, rss[i]);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void add_mm_rss_vec(struct mm_struct *mm, int *rss)\n{\n\tint i;\n\n\tif (current->mm == mm)\n\t\tsync_mm_rss(mm);\n\tfor (i = 0; i < NR_MM_COUNTERS; i++)\n\t\tif (rss[i])\n\t\t\tadd_mm_counter(mm, i, rss[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_clear_not_present_full",
          "args": [
            "mm",
            "addr",
            "pte",
            "tlb->fullmm"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_bad_pte",
          "args": [
            "vma",
            "addr",
            "ptent",
            "NULL"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "print_bad_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "479-528",
          "snippet": "static void print_bad_pte(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t  pte_t pte, struct page *page)\n{\n\tpgd_t *pgd = pgd_offset(vma->vm_mm, addr);\n\tp4d_t *p4d = p4d_offset(pgd, addr);\n\tpud_t *pud = pud_offset(p4d, addr);\n\tpmd_t *pmd = pmd_offset(pud, addr);\n\tstruct address_space *mapping;\n\tpgoff_t index;\n\tstatic unsigned long resume;\n\tstatic unsigned long nr_shown;\n\tstatic unsigned long nr_unshown;\n\n\t/*\n\t * Allow a burst of 60 reports, then keep quiet for that minute;\n\t * or allow a steady drip of one report per second.\n\t */\n\tif (nr_shown == 60) {\n\t\tif (time_before(jiffies, resume)) {\n\t\t\tnr_unshown++;\n\t\t\treturn;\n\t\t}\n\t\tif (nr_unshown) {\n\t\t\tpr_alert(\"BUG: Bad page map: %lu messages suppressed\\n\",\n\t\t\t\t nr_unshown);\n\t\t\tnr_unshown = 0;\n\t\t}\n\t\tnr_shown = 0;\n\t}\n\tif (nr_shown++ == 0)\n\t\tresume = jiffies + 60 * HZ;\n\n\tmapping = vma->vm_file ? vma->vm_file->f_mapping : NULL;\n\tindex = linear_page_index(vma, addr);\n\n\tpr_alert(\"BUG: Bad page map in process %s  pte:%08llx pmd:%08llx\\n\",\n\t\t current->comm,\n\t\t (long long)pte_val(pte), (long long)pmd_val(*pmd));\n\tif (page)\n\t\tdump_page(page, \"bad pte\");\n\tpr_alert(\"addr:%p vm_flags:%08lx anon_vma:%p mapping:%p index:%lx\\n\",\n\t\t (void *)addr, vma->vm_flags, vma->anon_vma, mapping, index);\n\tpr_alert(\"file:%pD fault:%pf mmap:%pf readpage:%pf\\n\",\n\t\t vma->vm_file,\n\t\t vma->vm_ops ? vma->vm_ops->fault : NULL,\n\t\t vma->vm_file ? vma->vm_file->f_op->mmap : NULL,\n\t\t mapping ? mapping->a_ops->readpage : NULL);\n\tdump_stack();\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void print_bad_pte(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t  pte_t pte, struct page *page)\n{\n\tpgd_t *pgd = pgd_offset(vma->vm_mm, addr);\n\tp4d_t *p4d = p4d_offset(pgd, addr);\n\tpud_t *pud = pud_offset(p4d, addr);\n\tpmd_t *pmd = pmd_offset(pud, addr);\n\tstruct address_space *mapping;\n\tpgoff_t index;\n\tstatic unsigned long resume;\n\tstatic unsigned long nr_shown;\n\tstatic unsigned long nr_unshown;\n\n\t/*\n\t * Allow a burst of 60 reports, then keep quiet for that minute;\n\t * or allow a steady drip of one report per second.\n\t */\n\tif (nr_shown == 60) {\n\t\tif (time_before(jiffies, resume)) {\n\t\t\tnr_unshown++;\n\t\t\treturn;\n\t\t}\n\t\tif (nr_unshown) {\n\t\t\tpr_alert(\"BUG: Bad page map: %lu messages suppressed\\n\",\n\t\t\t\t nr_unshown);\n\t\t\tnr_unshown = 0;\n\t\t}\n\t\tnr_shown = 0;\n\t}\n\tif (nr_shown++ == 0)\n\t\tresume = jiffies + 60 * HZ;\n\n\tmapping = vma->vm_file ? vma->vm_file->f_mapping : NULL;\n\tindex = linear_page_index(vma, addr);\n\n\tpr_alert(\"BUG: Bad page map in process %s  pte:%08llx pmd:%08llx\\n\",\n\t\t current->comm,\n\t\t (long long)pte_val(pte), (long long)pmd_val(*pmd));\n\tif (page)\n\t\tdump_page(page, \"bad pte\");\n\tpr_alert(\"addr:%p vm_flags:%08lx anon_vma:%p mapping:%p index:%lx\\n\",\n\t\t (void *)addr, vma->vm_flags, vma->anon_vma, mapping, index);\n\tpr_alert(\"file:%pD fault:%pf mmap:%pf readpage:%pf\\n\",\n\t\t vma->vm_file,\n\t\t vma->vm_ops ? vma->vm_ops->fault : NULL,\n\t\t vma->vm_file ? vma->vm_file->f_op->mmap : NULL,\n\t\t mapping ? mapping->a_ops->readpage : NULL);\n\tdump_stack();\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!free_swap_and_cache(entry)"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_swap_and_cache",
          "args": [
            "entry"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "free_swap_and_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1623-1640",
          "snippet": "int free_swap_and_cache(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\tunsigned char count;\n\n\tif (non_swap_entry(entry))\n\t\treturn 1;\n\n\tp = _swap_info_get(entry);\n\tif (p) {\n\t\tcount = __swap_entry_free(p, entry, 1);\n\t\tif (count == SWAP_HAS_CACHE &&\n\t\t    !swap_page_trans_huge_swapped(p, entry))\n\t\t\t__try_to_reclaim_swap(p, swp_offset(entry),\n\t\t\t\t\t      TTRS_UNMAPPED | TTRS_FULL);\n\t}\n\treturn p != NULL;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define TTRS_FULL\t\t0x4",
            "#define TTRS_UNMAPPED\t\t0x2"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define TTRS_FULL\t\t0x4\n#define TTRS_UNMAPPED\t\t0x2\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nint free_swap_and_cache(swp_entry_t entry)\n{\n\tstruct swap_info_struct *p;\n\tunsigned char count;\n\n\tif (non_swap_entry(entry))\n\t\treturn 1;\n\n\tp = _swap_info_get(entry);\n\tif (p) {\n\t\tcount = __swap_entry_free(p, entry, 1);\n\t\tif (count == SWAP_HAS_CACHE &&\n\t\t    !swap_page_trans_huge_swapped(p, entry))\n\t\t\t__try_to_reclaim_swap(p, swp_offset(entry),\n\t\t\t\t\t      TTRS_UNMAPPED | TTRS_FULL);\n\t}\n\treturn p != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_counter",
          "args": [
            "page"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migration_entry_to_page",
          "args": [
            "entry"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_migration_entry",
          "args": [
            "entry"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "non_swap_entry",
          "args": [
            "entry"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_to_swp_entry",
          "args": [
            "ptent"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "details"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_remove_rmap",
          "args": [
            "page",
            "false"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "page_remove_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1297-1331",
          "snippet": "void page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_counter",
          "args": [
            "page"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_clear_not_present_full",
          "args": [
            "mm",
            "addr",
            "pte",
            "tlb->fullmm"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_rmapping",
          "args": [
            "page"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "page_rmapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "460-464",
          "snippet": "void *page_rmapping(struct page *page)\n{\n\tpage = compound_head(page);\n\treturn __page_rmapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid *page_rmapping(struct page *page)\n{\n\tpage = compound_head(page);\n\treturn __page_rmapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "details && details->check_mapping"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_private_entry_to_page",
          "args": [
            "entry"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_device_private_entry",
          "args": [
            "entry"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "non_swap_entry",
          "args": [
            "entry"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_to_swp_entry",
          "args": [
            "ptent"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "__tlb_remove_page(tlb, page)"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__tlb_remove_page",
          "args": [
            "tlb",
            "page"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page_mapcount(page) < 0"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "page"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_counter",
          "args": [
            "page"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_page_accessed",
          "args": [
            "page"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "mark_page_accessed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "376-400",
          "snippet": "void mark_page_accessed(struct page *page)\n{\n\tpage = compound_head(page);\n\tif (!PageActive(page) && !PageUnevictable(page) &&\n\t\t\tPageReferenced(page)) {\n\n\t\t/*\n\t\t * If the page is on the LRU, queue it for activation via\n\t\t * activate_page_pvecs. Otherwise, assume the page is on a\n\t\t * pagevec, mark it active and it'll be moved to the active\n\t\t * LRU on the next drain.\n\t\t */\n\t\tif (PageLRU(page))\n\t\t\tactivate_page(page);\n\t\telse\n\t\t\t__lru_cache_activate_page(page);\n\t\tClearPageReferenced(page);\n\t\tif (page_is_file_cache(page))\n\t\t\tworkingset_activation(page);\n\t} else if (!PageReferenced(page)) {\n\t\tSetPageReferenced(page);\n\t}\n\tif (page_is_idle(page))\n\t\tclear_page_idle(page);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid mark_page_accessed(struct page *page)\n{\n\tpage = compound_head(page);\n\tif (!PageActive(page) && !PageUnevictable(page) &&\n\t\t\tPageReferenced(page)) {\n\n\t\t/*\n\t\t * If the page is on the LRU, queue it for activation via\n\t\t * activate_page_pvecs. Otherwise, assume the page is on a\n\t\t * pagevec, mark it active and it'll be moved to the active\n\t\t * LRU on the next drain.\n\t\t */\n\t\tif (PageLRU(page))\n\t\t\tactivate_page(page);\n\t\telse\n\t\t\t__lru_cache_activate_page(page);\n\t\tClearPageReferenced(page);\n\t\tif (page_is_file_cache(page))\n\t\t\tworkingset_activation(page);\n\t} else if (!PageReferenced(page)) {\n\t\tSetPageReferenced(page);\n\t}\n\tif (page_is_idle(page))\n\t\tclear_page_idle(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!(vma->vm_flags & VM_SEQ_READ)"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_young",
          "args": [
            "ptent"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_dirty_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2573-2581",
          "snippet": "int set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_dirty",
          "args": [
            "ptent"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlb_remove_tlb_entry",
          "args": [
            "tlb",
            "pte",
            "addr"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptep_get_and_clear_full",
          "args": [
            "mm",
            "addr",
            "pte",
            "tlb->fullmm"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "details"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_vm_normal_page",
          "args": [
            "vma",
            "addr",
            "ptent",
            "true"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "_vm_normal_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "572-648",
          "snippet": "struct page *_vm_normal_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t     pte_t pte, bool with_public_device)\n{\n\tunsigned long pfn = pte_pfn(pte);\n\n\tif (IS_ENABLED(CONFIG_ARCH_HAS_PTE_SPECIAL)) {\n\t\tif (likely(!pte_special(pte)))\n\t\t\tgoto check_pfn;\n\t\tif (vma->vm_ops && vma->vm_ops->find_special_page)\n\t\t\treturn vma->vm_ops->find_special_page(vma, addr);\n\t\tif (vma->vm_flags & (VM_PFNMAP | VM_MIXEDMAP))\n\t\t\treturn NULL;\n\t\tif (is_zero_pfn(pfn))\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * Device public pages are special pages (they are ZONE_DEVICE\n\t\t * pages but different from persistent memory). They behave\n\t\t * allmost like normal pages. The difference is that they are\n\t\t * not on the lru and thus should never be involve with any-\n\t\t * thing that involve lru manipulation (mlock, numa balancing,\n\t\t * ...).\n\t\t *\n\t\t * This is why we still want to return NULL for such page from\n\t\t * vm_normal_page() so that we do not have to special case all\n\t\t * call site of vm_normal_page().\n\t\t */\n\t\tif (likely(pfn <= highest_memmap_pfn)) {\n\t\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\t\tif (is_device_public_page(page)) {\n\t\t\t\tif (with_public_device)\n\t\t\t\t\treturn page;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (pte_devmap(pte))\n\t\t\treturn NULL;\n\n\t\tprint_bad_pte(vma, addr, pte, NULL);\n\t\treturn NULL;\n\t}\n\n\t/* !CONFIG_ARCH_HAS_PTE_SPECIAL case follows: */\n\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\ncheck_pfn:\n\tif (unlikely(pfn > highest_memmap_pfn)) {\n\t\tprint_bad_pte(vma, addr, pte, NULL);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstruct page *_vm_normal_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t     pte_t pte, bool with_public_device)\n{\n\tunsigned long pfn = pte_pfn(pte);\n\n\tif (IS_ENABLED(CONFIG_ARCH_HAS_PTE_SPECIAL)) {\n\t\tif (likely(!pte_special(pte)))\n\t\t\tgoto check_pfn;\n\t\tif (vma->vm_ops && vma->vm_ops->find_special_page)\n\t\t\treturn vma->vm_ops->find_special_page(vma, addr);\n\t\tif (vma->vm_flags & (VM_PFNMAP | VM_MIXEDMAP))\n\t\t\treturn NULL;\n\t\tif (is_zero_pfn(pfn))\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * Device public pages are special pages (they are ZONE_DEVICE\n\t\t * pages but different from persistent memory). They behave\n\t\t * allmost like normal pages. The difference is that they are\n\t\t * not on the lru and thus should never be involve with any-\n\t\t * thing that involve lru manipulation (mlock, numa balancing,\n\t\t * ...).\n\t\t *\n\t\t * This is why we still want to return NULL for such page from\n\t\t * vm_normal_page() so that we do not have to special case all\n\t\t * call site of vm_normal_page().\n\t\t */\n\t\tif (likely(pfn <= highest_memmap_pfn)) {\n\t\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\t\tif (is_device_public_page(page)) {\n\t\t\t\tif (with_public_device)\n\t\t\t\t\treturn page;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (pte_devmap(pte))\n\t\t\treturn NULL;\n\n\t\tprint_bad_pte(vma, addr, pte, NULL);\n\t\treturn NULL;\n\t}\n\n\t/* !CONFIG_ARCH_HAS_PTE_SPECIAL case follows: */\n\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\ncheck_pfn:\n\tif (unlikely(pfn > highest_memmap_pfn)) {\n\t\tprint_bad_pte(vma, addr, pte, NULL);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "ptent"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "ptent"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_enter_lazy_mmu_mode",
          "args": [],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_tlb_batched_pending",
          "args": [
            "mm"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "flush_tlb_batched_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "509-511",
          "snippet": "static inline void flush_tlb_batched_pending(struct mm_struct *mm)\n{\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void flush_tlb_batched_pending(struct mm_struct *mm)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "mm",
            "pmd",
            "addr",
            "&ptl"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rss_vec",
          "args": [
            "rss"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "init_rss_vec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "456-459",
          "snippet": "static inline void init_rss_vec(int *rss)\n{\n\tmemset(rss, 0, sizeof(int) * NR_MM_COUNTERS);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void init_rss_vec(int *rss)\n{\n\tmemset(rss, 0, sizeof(int) * NR_MM_COUNTERS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlb_remove_check_page_size_change",
          "args": [
            "tlb",
            "PAGE_SIZE"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic unsigned long zap_pte_range(struct mmu_gather *tlb,\n\t\t\t\tstruct vm_area_struct *vma, pmd_t *pmd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct zap_details *details)\n{\n\tstruct mm_struct *mm = tlb->mm;\n\tint force_flush = 0;\n\tint rss[NR_MM_COUNTERS];\n\tspinlock_t *ptl;\n\tpte_t *start_pte;\n\tpte_t *pte;\n\tswp_entry_t entry;\n\n\ttlb_remove_check_page_size_change(tlb, PAGE_SIZE);\nagain:\n\tinit_rss_vec(rss);\n\tstart_pte = pte_offset_map_lock(mm, pmd, addr, &ptl);\n\tpte = start_pte;\n\tflush_tlb_batched_pending(mm);\n\tarch_enter_lazy_mmu_mode();\n\tdo {\n\t\tpte_t ptent = *pte;\n\t\tif (pte_none(ptent))\n\t\t\tcontinue;\n\n\t\tif (pte_present(ptent)) {\n\t\t\tstruct page *page;\n\n\t\t\tpage = _vm_normal_page(vma, addr, ptent, true);\n\t\t\tif (unlikely(details) && page) {\n\t\t\t\t/*\n\t\t\t\t * unmap_shared_mapping_pages() wants to\n\t\t\t\t * invalidate cache without truncating:\n\t\t\t\t * unmap shared but keep private pages.\n\t\t\t\t */\n\t\t\t\tif (details->check_mapping &&\n\t\t\t\t    details->check_mapping != page_rmapping(page))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tptent = ptep_get_and_clear_full(mm, addr, pte,\n\t\t\t\t\t\t\ttlb->fullmm);\n\t\t\ttlb_remove_tlb_entry(tlb, pte, addr);\n\t\t\tif (unlikely(!page))\n\t\t\t\tcontinue;\n\n\t\t\tif (!PageAnon(page)) {\n\t\t\t\tif (pte_dirty(ptent)) {\n\t\t\t\t\tforce_flush = 1;\n\t\t\t\t\tset_page_dirty(page);\n\t\t\t\t}\n\t\t\t\tif (pte_young(ptent) &&\n\t\t\t\t    likely(!(vma->vm_flags & VM_SEQ_READ)))\n\t\t\t\t\tmark_page_accessed(page);\n\t\t\t}\n\t\t\trss[mm_counter(page)]--;\n\t\t\tpage_remove_rmap(page, false);\n\t\t\tif (unlikely(page_mapcount(page) < 0))\n\t\t\t\tprint_bad_pte(vma, addr, ptent, page);\n\t\t\tif (unlikely(__tlb_remove_page(tlb, page))) {\n\t\t\t\tforce_flush = 1;\n\t\t\t\taddr += PAGE_SIZE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tentry = pte_to_swp_entry(ptent);\n\t\tif (non_swap_entry(entry) && is_device_private_entry(entry)) {\n\t\t\tstruct page *page = device_private_entry_to_page(entry);\n\n\t\t\tif (unlikely(details && details->check_mapping)) {\n\t\t\t\t/*\n\t\t\t\t * unmap_shared_mapping_pages() wants to\n\t\t\t\t * invalidate cache without truncating:\n\t\t\t\t * unmap shared but keep private pages.\n\t\t\t\t */\n\t\t\t\tif (details->check_mapping !=\n\t\t\t\t    page_rmapping(page))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpte_clear_not_present_full(mm, addr, pte, tlb->fullmm);\n\t\t\trss[mm_counter(page)]--;\n\t\t\tpage_remove_rmap(page, false);\n\t\t\tput_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* If details->check_mapping, we leave swap entries. */\n\t\tif (unlikely(details))\n\t\t\tcontinue;\n\n\t\tentry = pte_to_swp_entry(ptent);\n\t\tif (!non_swap_entry(entry))\n\t\t\trss[MM_SWAPENTS]--;\n\t\telse if (is_migration_entry(entry)) {\n\t\t\tstruct page *page;\n\n\t\t\tpage = migration_entry_to_page(entry);\n\t\t\trss[mm_counter(page)]--;\n\t\t}\n\t\tif (unlikely(!free_swap_and_cache(entry)))\n\t\t\tprint_bad_pte(vma, addr, ptent, NULL);\n\t\tpte_clear_not_present_full(mm, addr, pte, tlb->fullmm);\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\n\tadd_mm_rss_vec(mm, rss);\n\tarch_leave_lazy_mmu_mode();\n\n\t/* Do the actual TLB flush before dropping ptl */\n\tif (force_flush)\n\t\ttlb_flush_mmu_tlbonly(tlb);\n\tpte_unmap_unlock(start_pte, ptl);\n\n\t/*\n\t * If we forced a TLB flush (either due to running out of\n\t * batch buffers or because we needed to flush dirty TLB\n\t * entries before releasing the ptl), free the batched\n\t * memory too. Restart if we didn't do everything.\n\t */\n\tif (force_flush) {\n\t\tforce_flush = 0;\n\t\ttlb_flush_mmu_free(tlb);\n\t\tif (addr != end)\n\t\t\tgoto again;\n\t}\n\n\treturn addr;\n}"
  },
  {
    "function_name": "copy_page_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "969-1034",
    "snippet": "int copy_page_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tstruct vm_area_struct *vma)\n{\n\tpgd_t *src_pgd, *dst_pgd;\n\tunsigned long next;\n\tunsigned long addr = vma->vm_start;\n\tunsigned long end = vma->vm_end;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\tbool is_cow;\n\tint ret;\n\n\t/*\n\t * Don't copy ptes where a page fault will fill them correctly.\n\t * Fork becomes much lighter when there are big shared or private\n\t * readonly mappings. The tradeoff is that copy_page_range is more\n\t * efficient than faulting.\n\t */\n\tif (!(vma->vm_flags & (VM_HUGETLB | VM_PFNMAP | VM_MIXEDMAP)) &&\n\t\t\t!vma->anon_vma)\n\t\treturn 0;\n\n\tif (is_vm_hugetlb_page(vma))\n\t\treturn copy_hugetlb_page_range(dst_mm, src_mm, vma);\n\n\tif (unlikely(vma->vm_flags & VM_PFNMAP)) {\n\t\t/*\n\t\t * We do not free on error cases below as remove_vma\n\t\t * gets called on error from higher level routine\n\t\t */\n\t\tret = track_pfn_copy(vma);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * We need to invalidate the secondary MMU mappings only when\n\t * there could be a permission downgrade on the ptes of the\n\t * parent mm. And a permission downgrade will only happen if\n\t * is_cow_mapping() returns true.\n\t */\n\tis_cow = is_cow_mapping(vma->vm_flags);\n\tmmun_start = addr;\n\tmmun_end   = end;\n\tif (is_cow)\n\t\tmmu_notifier_invalidate_range_start(src_mm, mmun_start,\n\t\t\t\t\t\t    mmun_end);\n\n\tret = 0;\n\tdst_pgd = pgd_offset(dst_mm, addr);\n\tsrc_pgd = pgd_offset(src_mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(src_pgd))\n\t\t\tcontinue;\n\t\tif (unlikely(copy_p4d_range(dst_mm, src_mm, dst_pgd, src_pgd,\n\t\t\t\t\t    vma, addr, next))) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t} while (dst_pgd++, src_pgd++, addr = next, addr != end);\n\n\tif (is_cow)\n\t\tmmu_notifier_invalidate_range_end(src_mm, mmun_start, mmun_end);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_end",
          "args": [
            "src_mm",
            "mmun_start",
            "mmun_end"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "copy_p4d_range(dst_mm, src_mm, dst_pgd, src_pgd,\n\t\t\t\t\t    vma, addr, next)"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_p4d_range",
          "args": [
            "dst_mm",
            "src_mm",
            "dst_pgd",
            "src_pgd",
            "vma",
            "addr",
            "next"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "copy_p4d_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "947-967",
          "snippet": "static inline int copy_p4d_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tpgd_t *dst_pgd, pgd_t *src_pgd, struct vm_area_struct *vma,\n\t\tunsigned long addr, unsigned long end)\n{\n\tp4d_t *src_p4d, *dst_p4d;\n\tunsigned long next;\n\n\tdst_p4d = p4d_alloc(dst_mm, dst_pgd, addr);\n\tif (!dst_p4d)\n\t\treturn -ENOMEM;\n\tsrc_p4d = p4d_offset(src_pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none_or_clear_bad(src_p4d))\n\t\t\tcontinue;\n\t\tif (copy_pud_range(dst_mm, src_mm, dst_p4d, src_p4d,\n\t\t\t\t\t\tvma, addr, next))\n\t\t\treturn -ENOMEM;\n\t} while (dst_p4d++, src_p4d++, addr = next, addr != end);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline int copy_p4d_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tpgd_t *dst_pgd, pgd_t *src_pgd, struct vm_area_struct *vma,\n\t\tunsigned long addr, unsigned long end)\n{\n\tp4d_t *src_p4d, *dst_p4d;\n\tunsigned long next;\n\n\tdst_p4d = p4d_alloc(dst_mm, dst_pgd, addr);\n\tif (!dst_p4d)\n\t\treturn -ENOMEM;\n\tsrc_p4d = p4d_offset(src_pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none_or_clear_bad(src_p4d))\n\t\t\tcontinue;\n\t\tif (copy_pud_range(dst_mm, src_mm, dst_p4d, src_p4d,\n\t\t\t\t\t\tvma, addr, next))\n\t\t\treturn -ENOMEM;\n\t} while (dst_p4d++, src_p4d++, addr = next, addr != end);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgd_none_or_clear_bad",
          "args": [
            "src_pgd"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_offset",
          "args": [
            "src_mm",
            "addr"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_offset",
          "args": [
            "dst_mm",
            "addr"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "src_mm",
            "mmun_start",
            "mmun_end"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_cow_mapping",
          "args": [
            "vma->vm_flags"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "is_cow_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "247-250",
          "snippet": "static inline bool is_cow_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline bool is_cow_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "track_pfn_copy",
          "args": [
            "vma"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vma->vm_flags & VM_PFNMAP"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_hugetlb_page_range",
          "args": [
            "dst_mm",
            "src_mm",
            "vma"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "copy_hugetlb_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3233-3330",
          "snippet": "int copy_hugetlb_page_range(struct mm_struct *dst, struct mm_struct *src,\n\t\t\t    struct vm_area_struct *vma)\n{\n\tpte_t *src_pte, *dst_pte, entry, dst_entry;\n\tstruct page *ptepage;\n\tunsigned long addr;\n\tint cow;\n\tstruct hstate *h = hstate_vma(vma);\n\tunsigned long sz = huge_page_size(h);\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\tint ret = 0;\n\n\tcow = (vma->vm_flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n\n\tmmun_start = vma->vm_start;\n\tmmun_end = vma->vm_end;\n\tif (cow)\n\t\tmmu_notifier_invalidate_range_start(src, mmun_start, mmun_end);\n\n\tfor (addr = vma->vm_start; addr < vma->vm_end; addr += sz) {\n\t\tspinlock_t *src_ptl, *dst_ptl;\n\t\tsrc_pte = huge_pte_offset(src, addr, sz);\n\t\tif (!src_pte)\n\t\t\tcontinue;\n\t\tdst_pte = huge_pte_alloc(dst, addr, sz);\n\t\tif (!dst_pte) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If the pagetables are shared don't copy or take references.\n\t\t * dst_pte == src_pte is the common case of src/dest sharing.\n\t\t *\n\t\t * However, src could have 'unshared' and dst shares with\n\t\t * another vma.  If dst_pte !none, this implies sharing.\n\t\t * Check here before taking page table lock, and once again\n\t\t * after taking the lock below.\n\t\t */\n\t\tdst_entry = huge_ptep_get(dst_pte);\n\t\tif ((dst_pte == src_pte) || !huge_pte_none(dst_entry))\n\t\t\tcontinue;\n\n\t\tdst_ptl = huge_pte_lock(h, dst, dst_pte);\n\t\tsrc_ptl = huge_pte_lockptr(h, src, src_pte);\n\t\tspin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);\n\t\tentry = huge_ptep_get(src_pte);\n\t\tdst_entry = huge_ptep_get(dst_pte);\n\t\tif (huge_pte_none(entry) || !huge_pte_none(dst_entry)) {\n\t\t\t/*\n\t\t\t * Skip if src entry none.  Also, skip in the\n\t\t\t * unlikely case dst entry !none as this implies\n\t\t\t * sharing with another vma.\n\t\t\t */\n\t\t\t;\n\t\t} else if (unlikely(is_hugetlb_entry_migration(entry) ||\n\t\t\t\t    is_hugetlb_entry_hwpoisoned(entry))) {\n\t\t\tswp_entry_t swp_entry = pte_to_swp_entry(entry);\n\n\t\t\tif (is_write_migration_entry(swp_entry) && cow) {\n\t\t\t\t/*\n\t\t\t\t * COW mappings require pages in both\n\t\t\t\t * parent and child to be set to read.\n\t\t\t\t */\n\t\t\t\tmake_migration_entry_read(&swp_entry);\n\t\t\t\tentry = swp_entry_to_pte(swp_entry);\n\t\t\t\tset_huge_swap_pte_at(src, addr, src_pte,\n\t\t\t\t\t\t     entry, sz);\n\t\t\t}\n\t\t\tset_huge_swap_pte_at(dst, addr, dst_pte, entry, sz);\n\t\t} else {\n\t\t\tif (cow) {\n\t\t\t\t/*\n\t\t\t\t * No need to notify as we are downgrading page\n\t\t\t\t * table protection not changing it to point\n\t\t\t\t * to a new page.\n\t\t\t\t *\n\t\t\t\t * See Documentation/vm/mmu_notifier.rst\n\t\t\t\t */\n\t\t\t\thuge_ptep_set_wrprotect(src, addr, src_pte);\n\t\t\t}\n\t\t\tentry = huge_ptep_get(src_pte);\n\t\t\tptepage = pte_page(entry);\n\t\t\tget_page(ptepage);\n\t\t\tpage_dup_rmap(ptepage, true);\n\t\t\tset_huge_pte_at(dst, addr, dst_pte, entry);\n\t\t\thugetlb_count_add(pages_per_huge_page(h), dst);\n\t\t}\n\t\tspin_unlock(src_ptl);\n\t\tspin_unlock(dst_ptl);\n\t}\n\n\tif (cow)\n\t\tmmu_notifier_invalidate_range_end(src, mmun_start, mmun_end);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint copy_hugetlb_page_range(struct mm_struct *dst, struct mm_struct *src,\n\t\t\t    struct vm_area_struct *vma)\n{\n\tpte_t *src_pte, *dst_pte, entry, dst_entry;\n\tstruct page *ptepage;\n\tunsigned long addr;\n\tint cow;\n\tstruct hstate *h = hstate_vma(vma);\n\tunsigned long sz = huge_page_size(h);\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\tint ret = 0;\n\n\tcow = (vma->vm_flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n\n\tmmun_start = vma->vm_start;\n\tmmun_end = vma->vm_end;\n\tif (cow)\n\t\tmmu_notifier_invalidate_range_start(src, mmun_start, mmun_end);\n\n\tfor (addr = vma->vm_start; addr < vma->vm_end; addr += sz) {\n\t\tspinlock_t *src_ptl, *dst_ptl;\n\t\tsrc_pte = huge_pte_offset(src, addr, sz);\n\t\tif (!src_pte)\n\t\t\tcontinue;\n\t\tdst_pte = huge_pte_alloc(dst, addr, sz);\n\t\tif (!dst_pte) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If the pagetables are shared don't copy or take references.\n\t\t * dst_pte == src_pte is the common case of src/dest sharing.\n\t\t *\n\t\t * However, src could have 'unshared' and dst shares with\n\t\t * another vma.  If dst_pte !none, this implies sharing.\n\t\t * Check here before taking page table lock, and once again\n\t\t * after taking the lock below.\n\t\t */\n\t\tdst_entry = huge_ptep_get(dst_pte);\n\t\tif ((dst_pte == src_pte) || !huge_pte_none(dst_entry))\n\t\t\tcontinue;\n\n\t\tdst_ptl = huge_pte_lock(h, dst, dst_pte);\n\t\tsrc_ptl = huge_pte_lockptr(h, src, src_pte);\n\t\tspin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);\n\t\tentry = huge_ptep_get(src_pte);\n\t\tdst_entry = huge_ptep_get(dst_pte);\n\t\tif (huge_pte_none(entry) || !huge_pte_none(dst_entry)) {\n\t\t\t/*\n\t\t\t * Skip if src entry none.  Also, skip in the\n\t\t\t * unlikely case dst entry !none as this implies\n\t\t\t * sharing with another vma.\n\t\t\t */\n\t\t\t;\n\t\t} else if (unlikely(is_hugetlb_entry_migration(entry) ||\n\t\t\t\t    is_hugetlb_entry_hwpoisoned(entry))) {\n\t\t\tswp_entry_t swp_entry = pte_to_swp_entry(entry);\n\n\t\t\tif (is_write_migration_entry(swp_entry) && cow) {\n\t\t\t\t/*\n\t\t\t\t * COW mappings require pages in both\n\t\t\t\t * parent and child to be set to read.\n\t\t\t\t */\n\t\t\t\tmake_migration_entry_read(&swp_entry);\n\t\t\t\tentry = swp_entry_to_pte(swp_entry);\n\t\t\t\tset_huge_swap_pte_at(src, addr, src_pte,\n\t\t\t\t\t\t     entry, sz);\n\t\t\t}\n\t\t\tset_huge_swap_pte_at(dst, addr, dst_pte, entry, sz);\n\t\t} else {\n\t\t\tif (cow) {\n\t\t\t\t/*\n\t\t\t\t * No need to notify as we are downgrading page\n\t\t\t\t * table protection not changing it to point\n\t\t\t\t * to a new page.\n\t\t\t\t *\n\t\t\t\t * See Documentation/vm/mmu_notifier.rst\n\t\t\t\t */\n\t\t\t\thuge_ptep_set_wrprotect(src, addr, src_pte);\n\t\t\t}\n\t\t\tentry = huge_ptep_get(src_pte);\n\t\t\tptepage = pte_page(entry);\n\t\t\tget_page(ptepage);\n\t\t\tpage_dup_rmap(ptepage, true);\n\t\t\tset_huge_pte_at(dst, addr, dst_pte, entry);\n\t\t\thugetlb_count_add(pages_per_huge_page(h), dst);\n\t\t}\n\t\tspin_unlock(src_ptl);\n\t\tspin_unlock(dst_ptl);\n\t}\n\n\tif (cow)\n\t\tmmu_notifier_invalidate_range_end(src, mmun_start, mmun_end);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint copy_page_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tstruct vm_area_struct *vma)\n{\n\tpgd_t *src_pgd, *dst_pgd;\n\tunsigned long next;\n\tunsigned long addr = vma->vm_start;\n\tunsigned long end = vma->vm_end;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\tbool is_cow;\n\tint ret;\n\n\t/*\n\t * Don't copy ptes where a page fault will fill them correctly.\n\t * Fork becomes much lighter when there are big shared or private\n\t * readonly mappings. The tradeoff is that copy_page_range is more\n\t * efficient than faulting.\n\t */\n\tif (!(vma->vm_flags & (VM_HUGETLB | VM_PFNMAP | VM_MIXEDMAP)) &&\n\t\t\t!vma->anon_vma)\n\t\treturn 0;\n\n\tif (is_vm_hugetlb_page(vma))\n\t\treturn copy_hugetlb_page_range(dst_mm, src_mm, vma);\n\n\tif (unlikely(vma->vm_flags & VM_PFNMAP)) {\n\t\t/*\n\t\t * We do not free on error cases below as remove_vma\n\t\t * gets called on error from higher level routine\n\t\t */\n\t\tret = track_pfn_copy(vma);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * We need to invalidate the secondary MMU mappings only when\n\t * there could be a permission downgrade on the ptes of the\n\t * parent mm. And a permission downgrade will only happen if\n\t * is_cow_mapping() returns true.\n\t */\n\tis_cow = is_cow_mapping(vma->vm_flags);\n\tmmun_start = addr;\n\tmmun_end   = end;\n\tif (is_cow)\n\t\tmmu_notifier_invalidate_range_start(src_mm, mmun_start,\n\t\t\t\t\t\t    mmun_end);\n\n\tret = 0;\n\tdst_pgd = pgd_offset(dst_mm, addr);\n\tsrc_pgd = pgd_offset(src_mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(src_pgd))\n\t\t\tcontinue;\n\t\tif (unlikely(copy_p4d_range(dst_mm, src_mm, dst_pgd, src_pgd,\n\t\t\t\t\t    vma, addr, next))) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t} while (dst_pgd++, src_pgd++, addr = next, addr != end);\n\n\tif (is_cow)\n\t\tmmu_notifier_invalidate_range_end(src_mm, mmun_start, mmun_end);\n\treturn ret;\n}"
  },
  {
    "function_name": "copy_p4d_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "947-967",
    "snippet": "static inline int copy_p4d_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tpgd_t *dst_pgd, pgd_t *src_pgd, struct vm_area_struct *vma,\n\t\tunsigned long addr, unsigned long end)\n{\n\tp4d_t *src_p4d, *dst_p4d;\n\tunsigned long next;\n\n\tdst_p4d = p4d_alloc(dst_mm, dst_pgd, addr);\n\tif (!dst_p4d)\n\t\treturn -ENOMEM;\n\tsrc_p4d = p4d_offset(src_pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none_or_clear_bad(src_p4d))\n\t\t\tcontinue;\n\t\tif (copy_pud_range(dst_mm, src_mm, dst_p4d, src_p4d,\n\t\t\t\t\t\tvma, addr, next))\n\t\t\treturn -ENOMEM;\n\t} while (dst_p4d++, src_p4d++, addr = next, addr != end);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_pud_range",
          "args": [
            "dst_mm",
            "src_mm",
            "dst_p4d",
            "src_p4d",
            "vma",
            "addr",
            "next"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "copy_pud_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "913-945",
          "snippet": "static inline int copy_pud_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tp4d_t *dst_p4d, p4d_t *src_p4d, struct vm_area_struct *vma,\n\t\tunsigned long addr, unsigned long end)\n{\n\tpud_t *src_pud, *dst_pud;\n\tunsigned long next;\n\n\tdst_pud = pud_alloc(dst_mm, dst_p4d, addr);\n\tif (!dst_pud)\n\t\treturn -ENOMEM;\n\tsrc_pud = pud_offset(src_p4d, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_trans_huge(*src_pud) || pud_devmap(*src_pud)) {\n\t\t\tint err;\n\n\t\t\tVM_BUG_ON_VMA(next-addr != HPAGE_PUD_SIZE, vma);\n\t\t\terr = copy_huge_pud(dst_mm, src_mm,\n\t\t\t\t\t    dst_pud, src_pud, addr, vma);\n\t\t\tif (err == -ENOMEM)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (!err)\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pud_none_or_clear_bad(src_pud))\n\t\t\tcontinue;\n\t\tif (copy_pmd_range(dst_mm, src_mm, dst_pud, src_pud,\n\t\t\t\t\t\tvma, addr, next))\n\t\t\treturn -ENOMEM;\n\t} while (dst_pud++, src_pud++, addr = next, addr != end);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline int copy_pud_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tp4d_t *dst_p4d, p4d_t *src_p4d, struct vm_area_struct *vma,\n\t\tunsigned long addr, unsigned long end)\n{\n\tpud_t *src_pud, *dst_pud;\n\tunsigned long next;\n\n\tdst_pud = pud_alloc(dst_mm, dst_p4d, addr);\n\tif (!dst_pud)\n\t\treturn -ENOMEM;\n\tsrc_pud = pud_offset(src_p4d, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_trans_huge(*src_pud) || pud_devmap(*src_pud)) {\n\t\t\tint err;\n\n\t\t\tVM_BUG_ON_VMA(next-addr != HPAGE_PUD_SIZE, vma);\n\t\t\terr = copy_huge_pud(dst_mm, src_mm,\n\t\t\t\t\t    dst_pud, src_pud, addr, vma);\n\t\t\tif (err == -ENOMEM)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (!err)\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pud_none_or_clear_bad(src_pud))\n\t\t\tcontinue;\n\t\tif (copy_pmd_range(dst_mm, src_mm, dst_pud, src_pud,\n\t\t\t\t\t\tvma, addr, next))\n\t\t\treturn -ENOMEM;\n\t} while (dst_pud++, src_pud++, addr = next, addr != end);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p4d_none_or_clear_bad",
          "args": [
            "src_p4d"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_offset",
          "args": [
            "src_pgd",
            "addr"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_alloc",
          "args": [
            "dst_mm",
            "dst_pgd",
            "addr"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "__p4d_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3949-3964",
          "snippet": "int __p4d_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)\n{\n\tp4d_t *new = p4d_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n\tif (pgd_present(*pgd))\t\t/* Another has populated it */\n\t\tp4d_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pgd, new);\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __p4d_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)\n{\n\tp4d_t *new = p4d_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n\tif (pgd_present(*pgd))\t\t/* Another has populated it */\n\t\tp4d_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pgd, new);\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline int copy_p4d_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tpgd_t *dst_pgd, pgd_t *src_pgd, struct vm_area_struct *vma,\n\t\tunsigned long addr, unsigned long end)\n{\n\tp4d_t *src_p4d, *dst_p4d;\n\tunsigned long next;\n\n\tdst_p4d = p4d_alloc(dst_mm, dst_pgd, addr);\n\tif (!dst_p4d)\n\t\treturn -ENOMEM;\n\tsrc_p4d = p4d_offset(src_pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none_or_clear_bad(src_p4d))\n\t\t\tcontinue;\n\t\tif (copy_pud_range(dst_mm, src_mm, dst_p4d, src_p4d,\n\t\t\t\t\t\tvma, addr, next))\n\t\t\treturn -ENOMEM;\n\t} while (dst_p4d++, src_p4d++, addr = next, addr != end);\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_pud_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "913-945",
    "snippet": "static inline int copy_pud_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tp4d_t *dst_p4d, p4d_t *src_p4d, struct vm_area_struct *vma,\n\t\tunsigned long addr, unsigned long end)\n{\n\tpud_t *src_pud, *dst_pud;\n\tunsigned long next;\n\n\tdst_pud = pud_alloc(dst_mm, dst_p4d, addr);\n\tif (!dst_pud)\n\t\treturn -ENOMEM;\n\tsrc_pud = pud_offset(src_p4d, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_trans_huge(*src_pud) || pud_devmap(*src_pud)) {\n\t\t\tint err;\n\n\t\t\tVM_BUG_ON_VMA(next-addr != HPAGE_PUD_SIZE, vma);\n\t\t\terr = copy_huge_pud(dst_mm, src_mm,\n\t\t\t\t\t    dst_pud, src_pud, addr, vma);\n\t\t\tif (err == -ENOMEM)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (!err)\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pud_none_or_clear_bad(src_pud))\n\t\t\tcontinue;\n\t\tif (copy_pmd_range(dst_mm, src_mm, dst_pud, src_pud,\n\t\t\t\t\t\tvma, addr, next))\n\t\t\treturn -ENOMEM;\n\t} while (dst_pud++, src_pud++, addr = next, addr != end);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_pmd_range",
          "args": [
            "dst_mm",
            "src_mm",
            "dst_pud",
            "src_pud",
            "vma",
            "addr",
            "next"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "copy_pmd_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "879-911",
          "snippet": "static inline int copy_pmd_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tpud_t *dst_pud, pud_t *src_pud, struct vm_area_struct *vma,\n\t\tunsigned long addr, unsigned long end)\n{\n\tpmd_t *src_pmd, *dst_pmd;\n\tunsigned long next;\n\n\tdst_pmd = pmd_alloc(dst_mm, dst_pud, addr);\n\tif (!dst_pmd)\n\t\treturn -ENOMEM;\n\tsrc_pmd = pmd_offset(src_pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (is_swap_pmd(*src_pmd) || pmd_trans_huge(*src_pmd)\n\t\t\t|| pmd_devmap(*src_pmd)) {\n\t\t\tint err;\n\t\t\tVM_BUG_ON_VMA(next-addr != HPAGE_PMD_SIZE, vma);\n\t\t\terr = copy_huge_pmd(dst_mm, src_mm,\n\t\t\t\t\t    dst_pmd, src_pmd, addr, vma);\n\t\t\tif (err == -ENOMEM)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (!err)\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pmd_none_or_clear_bad(src_pmd))\n\t\t\tcontinue;\n\t\tif (copy_pte_range(dst_mm, src_mm, dst_pmd, src_pmd,\n\t\t\t\t\t\tvma, addr, next))\n\t\t\treturn -ENOMEM;\n\t} while (dst_pmd++, src_pmd++, addr = next, addr != end);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline int copy_pmd_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tpud_t *dst_pud, pud_t *src_pud, struct vm_area_struct *vma,\n\t\tunsigned long addr, unsigned long end)\n{\n\tpmd_t *src_pmd, *dst_pmd;\n\tunsigned long next;\n\n\tdst_pmd = pmd_alloc(dst_mm, dst_pud, addr);\n\tif (!dst_pmd)\n\t\treturn -ENOMEM;\n\tsrc_pmd = pmd_offset(src_pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (is_swap_pmd(*src_pmd) || pmd_trans_huge(*src_pmd)\n\t\t\t|| pmd_devmap(*src_pmd)) {\n\t\t\tint err;\n\t\t\tVM_BUG_ON_VMA(next-addr != HPAGE_PMD_SIZE, vma);\n\t\t\terr = copy_huge_pmd(dst_mm, src_mm,\n\t\t\t\t\t    dst_pmd, src_pmd, addr, vma);\n\t\t\tif (err == -ENOMEM)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (!err)\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pmd_none_or_clear_bad(src_pmd))\n\t\t\tcontinue;\n\t\tif (copy_pte_range(dst_mm, src_mm, dst_pmd, src_pmd,\n\t\t\t\t\t\tvma, addr, next))\n\t\t\treturn -ENOMEM;\n\t} while (dst_pmd++, src_pmd++, addr = next, addr != end);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pud_none_or_clear_bad",
          "args": [
            "src_pud"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_huge_pud",
          "args": [
            "dst_mm",
            "src_mm",
            "dst_pud",
            "src_pud",
            "addr",
            "vma"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "copy_huge_pud",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1056-1091",
          "snippet": "int copy_huge_pud(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\t  pud_t *dst_pud, pud_t *src_pud, unsigned long addr,\n\t\t  struct vm_area_struct *vma)\n{\n\tspinlock_t *dst_ptl, *src_ptl;\n\tpud_t pud;\n\tint ret;\n\n\tdst_ptl = pud_lock(dst_mm, dst_pud);\n\tsrc_ptl = pud_lockptr(src_mm, src_pud);\n\tspin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);\n\n\tret = -EAGAIN;\n\tpud = *src_pud;\n\tif (unlikely(!pud_trans_huge(pud) && !pud_devmap(pud)))\n\t\tgoto out_unlock;\n\n\t/*\n\t * When page table lock is held, the huge zero pud should not be\n\t * under splitting since we don't split the page itself, only pud to\n\t * a page table.\n\t */\n\tif (is_huge_zero_pud(pud)) {\n\t\t/* No huge zero pud yet */\n\t}\n\n\tpudp_set_wrprotect(src_mm, addr, src_pud);\n\tpud = pud_mkold(pud_wrprotect(pud));\n\tset_pud_at(dst_mm, addr, dst_pud, pud);\n\n\tret = 0;\nout_unlock:\n\tspin_unlock(src_ptl);\n\tspin_unlock(dst_ptl);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint copy_huge_pud(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\t  pud_t *dst_pud, pud_t *src_pud, unsigned long addr,\n\t\t  struct vm_area_struct *vma)\n{\n\tspinlock_t *dst_ptl, *src_ptl;\n\tpud_t pud;\n\tint ret;\n\n\tdst_ptl = pud_lock(dst_mm, dst_pud);\n\tsrc_ptl = pud_lockptr(src_mm, src_pud);\n\tspin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);\n\n\tret = -EAGAIN;\n\tpud = *src_pud;\n\tif (unlikely(!pud_trans_huge(pud) && !pud_devmap(pud)))\n\t\tgoto out_unlock;\n\n\t/*\n\t * When page table lock is held, the huge zero pud should not be\n\t * under splitting since we don't split the page itself, only pud to\n\t * a page table.\n\t */\n\tif (is_huge_zero_pud(pud)) {\n\t\t/* No huge zero pud yet */\n\t}\n\n\tpudp_set_wrprotect(src_mm, addr, src_pud);\n\tpud = pud_mkold(pud_wrprotect(pud));\n\tset_pud_at(dst_mm, addr, dst_pud, pud);\n\n\tret = 0;\nout_unlock:\n\tspin_unlock(src_ptl);\n\tspin_unlock(dst_ptl);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_VMA",
          "args": [
            "next-addr != HPAGE_PUD_SIZE",
            "vma"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_devmap",
          "args": [
            "*src_pud"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_trans_huge",
          "args": [
            "*src_pud"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_offset",
          "args": [
            "src_p4d",
            "addr"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_alloc",
          "args": [
            "dst_mm",
            "dst_p4d",
            "addr"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "__pud_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3972-3996",
          "snippet": "int __pud_alloc(struct mm_struct *mm, p4d_t *p4d, unsigned long address)\n{\n\tpud_t *new = pud_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_5LEVEL_HACK\n\tif (!p4d_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tp4d_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#else\n\tif (!pgd_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tpgd_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#endif /* __ARCH_HAS_5LEVEL_HACK */\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pud_alloc(struct mm_struct *mm, p4d_t *p4d, unsigned long address)\n{\n\tpud_t *new = pud_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_5LEVEL_HACK\n\tif (!p4d_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tp4d_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#else\n\tif (!pgd_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tpgd_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#endif /* __ARCH_HAS_5LEVEL_HACK */\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline int copy_pud_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tp4d_t *dst_p4d, p4d_t *src_p4d, struct vm_area_struct *vma,\n\t\tunsigned long addr, unsigned long end)\n{\n\tpud_t *src_pud, *dst_pud;\n\tunsigned long next;\n\n\tdst_pud = pud_alloc(dst_mm, dst_p4d, addr);\n\tif (!dst_pud)\n\t\treturn -ENOMEM;\n\tsrc_pud = pud_offset(src_p4d, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_trans_huge(*src_pud) || pud_devmap(*src_pud)) {\n\t\t\tint err;\n\n\t\t\tVM_BUG_ON_VMA(next-addr != HPAGE_PUD_SIZE, vma);\n\t\t\terr = copy_huge_pud(dst_mm, src_mm,\n\t\t\t\t\t    dst_pud, src_pud, addr, vma);\n\t\t\tif (err == -ENOMEM)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (!err)\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pud_none_or_clear_bad(src_pud))\n\t\t\tcontinue;\n\t\tif (copy_pmd_range(dst_mm, src_mm, dst_pud, src_pud,\n\t\t\t\t\t\tvma, addr, next))\n\t\t\treturn -ENOMEM;\n\t} while (dst_pud++, src_pud++, addr = next, addr != end);\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_pmd_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "879-911",
    "snippet": "static inline int copy_pmd_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tpud_t *dst_pud, pud_t *src_pud, struct vm_area_struct *vma,\n\t\tunsigned long addr, unsigned long end)\n{\n\tpmd_t *src_pmd, *dst_pmd;\n\tunsigned long next;\n\n\tdst_pmd = pmd_alloc(dst_mm, dst_pud, addr);\n\tif (!dst_pmd)\n\t\treturn -ENOMEM;\n\tsrc_pmd = pmd_offset(src_pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (is_swap_pmd(*src_pmd) || pmd_trans_huge(*src_pmd)\n\t\t\t|| pmd_devmap(*src_pmd)) {\n\t\t\tint err;\n\t\t\tVM_BUG_ON_VMA(next-addr != HPAGE_PMD_SIZE, vma);\n\t\t\terr = copy_huge_pmd(dst_mm, src_mm,\n\t\t\t\t\t    dst_pmd, src_pmd, addr, vma);\n\t\t\tif (err == -ENOMEM)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (!err)\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pmd_none_or_clear_bad(src_pmd))\n\t\t\tcontinue;\n\t\tif (copy_pte_range(dst_mm, src_mm, dst_pmd, src_pmd,\n\t\t\t\t\t\tvma, addr, next))\n\t\t\treturn -ENOMEM;\n\t} while (dst_pmd++, src_pmd++, addr = next, addr != end);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_pte_range",
          "args": [
            "dst_mm",
            "src_mm",
            "dst_pmd",
            "src_pmd",
            "vma",
            "addr",
            "next"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "copy_pte_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "816-877",
          "snippet": "static int copy_pte_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\t   pmd_t *dst_pmd, pmd_t *src_pmd, struct vm_area_struct *vma,\n\t\t   unsigned long addr, unsigned long end)\n{\n\tpte_t *orig_src_pte, *orig_dst_pte;\n\tpte_t *src_pte, *dst_pte;\n\tspinlock_t *src_ptl, *dst_ptl;\n\tint progress = 0;\n\tint rss[NR_MM_COUNTERS];\n\tswp_entry_t entry = (swp_entry_t){0};\n\nagain:\n\tinit_rss_vec(rss);\n\n\tdst_pte = pte_alloc_map_lock(dst_mm, dst_pmd, addr, &dst_ptl);\n\tif (!dst_pte)\n\t\treturn -ENOMEM;\n\tsrc_pte = pte_offset_map(src_pmd, addr);\n\tsrc_ptl = pte_lockptr(src_mm, src_pmd);\n\tspin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);\n\torig_src_pte = src_pte;\n\torig_dst_pte = dst_pte;\n\tarch_enter_lazy_mmu_mode();\n\n\tdo {\n\t\t/*\n\t\t * We are holding two locks at this point - either of them\n\t\t * could generate latencies in another task on another CPU.\n\t\t */\n\t\tif (progress >= 32) {\n\t\t\tprogress = 0;\n\t\t\tif (need_resched() ||\n\t\t\t    spin_needbreak(src_ptl) || spin_needbreak(dst_ptl))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (pte_none(*src_pte)) {\n\t\t\tprogress++;\n\t\t\tcontinue;\n\t\t}\n\t\tentry.val = copy_one_pte(dst_mm, src_mm, dst_pte, src_pte,\n\t\t\t\t\t\t\tvma, addr, rss);\n\t\tif (entry.val)\n\t\t\tbreak;\n\t\tprogress += 8;\n\t} while (dst_pte++, src_pte++, addr += PAGE_SIZE, addr != end);\n\n\tarch_leave_lazy_mmu_mode();\n\tspin_unlock(src_ptl);\n\tpte_unmap(orig_src_pte);\n\tadd_mm_rss_vec(dst_mm, rss);\n\tpte_unmap_unlock(orig_dst_pte, dst_ptl);\n\tcond_resched();\n\n\tif (entry.val) {\n\t\tif (add_swap_count_continuation(entry, GFP_KERNEL) < 0)\n\t\t\treturn -ENOMEM;\n\t\tprogress = 0;\n\t}\n\tif (addr != end)\n\t\tgoto again;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int copy_pte_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\t   pmd_t *dst_pmd, pmd_t *src_pmd, struct vm_area_struct *vma,\n\t\t   unsigned long addr, unsigned long end)\n{\n\tpte_t *orig_src_pte, *orig_dst_pte;\n\tpte_t *src_pte, *dst_pte;\n\tspinlock_t *src_ptl, *dst_ptl;\n\tint progress = 0;\n\tint rss[NR_MM_COUNTERS];\n\tswp_entry_t entry = (swp_entry_t){0};\n\nagain:\n\tinit_rss_vec(rss);\n\n\tdst_pte = pte_alloc_map_lock(dst_mm, dst_pmd, addr, &dst_ptl);\n\tif (!dst_pte)\n\t\treturn -ENOMEM;\n\tsrc_pte = pte_offset_map(src_pmd, addr);\n\tsrc_ptl = pte_lockptr(src_mm, src_pmd);\n\tspin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);\n\torig_src_pte = src_pte;\n\torig_dst_pte = dst_pte;\n\tarch_enter_lazy_mmu_mode();\n\n\tdo {\n\t\t/*\n\t\t * We are holding two locks at this point - either of them\n\t\t * could generate latencies in another task on another CPU.\n\t\t */\n\t\tif (progress >= 32) {\n\t\t\tprogress = 0;\n\t\t\tif (need_resched() ||\n\t\t\t    spin_needbreak(src_ptl) || spin_needbreak(dst_ptl))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (pte_none(*src_pte)) {\n\t\t\tprogress++;\n\t\t\tcontinue;\n\t\t}\n\t\tentry.val = copy_one_pte(dst_mm, src_mm, dst_pte, src_pte,\n\t\t\t\t\t\t\tvma, addr, rss);\n\t\tif (entry.val)\n\t\t\tbreak;\n\t\tprogress += 8;\n\t} while (dst_pte++, src_pte++, addr += PAGE_SIZE, addr != end);\n\n\tarch_leave_lazy_mmu_mode();\n\tspin_unlock(src_ptl);\n\tpte_unmap(orig_src_pte);\n\tadd_mm_rss_vec(dst_mm, rss);\n\tpte_unmap_unlock(orig_dst_pte, dst_ptl);\n\tcond_resched();\n\n\tif (entry.val) {\n\t\tif (add_swap_count_continuation(entry, GFP_KERNEL) < 0)\n\t\t\treturn -ENOMEM;\n\t\tprogress = 0;\n\t}\n\tif (addr != end)\n\t\tgoto again;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_none_or_clear_bad",
          "args": [
            "src_pmd"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_huge_pmd",
          "args": [
            "dst_mm",
            "src_mm",
            "dst_pmd",
            "src_pmd",
            "addr",
            "vma"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "copy_huge_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "916-1003",
          "snippet": "int copy_huge_pmd(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\t  pmd_t *dst_pmd, pmd_t *src_pmd, unsigned long addr,\n\t\t  struct vm_area_struct *vma)\n{\n\tspinlock_t *dst_ptl, *src_ptl;\n\tstruct page *src_page;\n\tpmd_t pmd;\n\tpgtable_t pgtable = NULL;\n\tint ret = -ENOMEM;\n\n\t/* Skip if can be re-fill on fault */\n\tif (!vma_is_anonymous(vma))\n\t\treturn 0;\n\n\tpgtable = pte_alloc_one(dst_mm, addr);\n\tif (unlikely(!pgtable))\n\t\tgoto out;\n\n\tdst_ptl = pmd_lock(dst_mm, dst_pmd);\n\tsrc_ptl = pmd_lockptr(src_mm, src_pmd);\n\tspin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);\n\n\tret = -EAGAIN;\n\tpmd = *src_pmd;\n\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\n\tif (unlikely(is_swap_pmd(pmd))) {\n\t\tswp_entry_t entry = pmd_to_swp_entry(pmd);\n\n\t\tVM_BUG_ON(!is_pmd_migration_entry(pmd));\n\t\tif (is_write_migration_entry(entry)) {\n\t\t\tmake_migration_entry_read(&entry);\n\t\t\tpmd = swp_entry_to_pmd(entry);\n\t\t\tif (pmd_swp_soft_dirty(*src_pmd))\n\t\t\t\tpmd = pmd_swp_mksoft_dirty(pmd);\n\t\t\tset_pmd_at(src_mm, addr, src_pmd, pmd);\n\t\t}\n\t\tadd_mm_counter(dst_mm, MM_ANONPAGES, HPAGE_PMD_NR);\n\t\tmm_inc_nr_ptes(dst_mm);\n\t\tpgtable_trans_huge_deposit(dst_mm, dst_pmd, pgtable);\n\t\tset_pmd_at(dst_mm, addr, dst_pmd, pmd);\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n#endif\n\n\tif (unlikely(!pmd_trans_huge(pmd))) {\n\t\tpte_free(dst_mm, pgtable);\n\t\tgoto out_unlock;\n\t}\n\t/*\n\t * When page table lock is held, the huge zero pmd should not be\n\t * under splitting since we don't split the page itself, only pmd to\n\t * a page table.\n\t */\n\tif (is_huge_zero_pmd(pmd)) {\n\t\tstruct page *zero_page;\n\t\t/*\n\t\t * get_huge_zero_page() will never allocate a new page here,\n\t\t * since we already have a zero page to copy. It just takes a\n\t\t * reference.\n\t\t */\n\t\tzero_page = mm_get_huge_zero_page(dst_mm);\n\t\tset_huge_zero_page(pgtable, dst_mm, vma, addr, dst_pmd,\n\t\t\t\tzero_page);\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tsrc_page = pmd_page(pmd);\n\tVM_BUG_ON_PAGE(!PageHead(src_page), src_page);\n\tget_page(src_page);\n\tpage_dup_rmap(src_page, true);\n\tadd_mm_counter(dst_mm, MM_ANONPAGES, HPAGE_PMD_NR);\n\tmm_inc_nr_ptes(dst_mm);\n\tpgtable_trans_huge_deposit(dst_mm, dst_pmd, pgtable);\n\n\tpmdp_set_wrprotect(src_mm, addr, src_pmd);\n\tpmd = pmd_mkold(pmd_wrprotect(pmd));\n\tset_pmd_at(dst_mm, addr, dst_pmd, pmd);\n\n\tret = 0;\nout_unlock:\n\tspin_unlock(src_ptl);\n\tspin_unlock(dst_ptl);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint copy_huge_pmd(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\t  pmd_t *dst_pmd, pmd_t *src_pmd, unsigned long addr,\n\t\t  struct vm_area_struct *vma)\n{\n\tspinlock_t *dst_ptl, *src_ptl;\n\tstruct page *src_page;\n\tpmd_t pmd;\n\tpgtable_t pgtable = NULL;\n\tint ret = -ENOMEM;\n\n\t/* Skip if can be re-fill on fault */\n\tif (!vma_is_anonymous(vma))\n\t\treturn 0;\n\n\tpgtable = pte_alloc_one(dst_mm, addr);\n\tif (unlikely(!pgtable))\n\t\tgoto out;\n\n\tdst_ptl = pmd_lock(dst_mm, dst_pmd);\n\tsrc_ptl = pmd_lockptr(src_mm, src_pmd);\n\tspin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);\n\n\tret = -EAGAIN;\n\tpmd = *src_pmd;\n\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\n\tif (unlikely(is_swap_pmd(pmd))) {\n\t\tswp_entry_t entry = pmd_to_swp_entry(pmd);\n\n\t\tVM_BUG_ON(!is_pmd_migration_entry(pmd));\n\t\tif (is_write_migration_entry(entry)) {\n\t\t\tmake_migration_entry_read(&entry);\n\t\t\tpmd = swp_entry_to_pmd(entry);\n\t\t\tif (pmd_swp_soft_dirty(*src_pmd))\n\t\t\t\tpmd = pmd_swp_mksoft_dirty(pmd);\n\t\t\tset_pmd_at(src_mm, addr, src_pmd, pmd);\n\t\t}\n\t\tadd_mm_counter(dst_mm, MM_ANONPAGES, HPAGE_PMD_NR);\n\t\tmm_inc_nr_ptes(dst_mm);\n\t\tpgtable_trans_huge_deposit(dst_mm, dst_pmd, pgtable);\n\t\tset_pmd_at(dst_mm, addr, dst_pmd, pmd);\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n#endif\n\n\tif (unlikely(!pmd_trans_huge(pmd))) {\n\t\tpte_free(dst_mm, pgtable);\n\t\tgoto out_unlock;\n\t}\n\t/*\n\t * When page table lock is held, the huge zero pmd should not be\n\t * under splitting since we don't split the page itself, only pmd to\n\t * a page table.\n\t */\n\tif (is_huge_zero_pmd(pmd)) {\n\t\tstruct page *zero_page;\n\t\t/*\n\t\t * get_huge_zero_page() will never allocate a new page here,\n\t\t * since we already have a zero page to copy. It just takes a\n\t\t * reference.\n\t\t */\n\t\tzero_page = mm_get_huge_zero_page(dst_mm);\n\t\tset_huge_zero_page(pgtable, dst_mm, vma, addr, dst_pmd,\n\t\t\t\tzero_page);\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tsrc_page = pmd_page(pmd);\n\tVM_BUG_ON_PAGE(!PageHead(src_page), src_page);\n\tget_page(src_page);\n\tpage_dup_rmap(src_page, true);\n\tadd_mm_counter(dst_mm, MM_ANONPAGES, HPAGE_PMD_NR);\n\tmm_inc_nr_ptes(dst_mm);\n\tpgtable_trans_huge_deposit(dst_mm, dst_pmd, pgtable);\n\n\tpmdp_set_wrprotect(src_mm, addr, src_pmd);\n\tpmd = pmd_mkold(pmd_wrprotect(pmd));\n\tset_pmd_at(dst_mm, addr, dst_pmd, pmd);\n\n\tret = 0;\nout_unlock:\n\tspin_unlock(src_ptl);\n\tspin_unlock(dst_ptl);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_VMA",
          "args": [
            "next-addr != HPAGE_PMD_SIZE",
            "vma"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_devmap",
          "args": [
            "*src_pmd"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "pmd_devmap_trans_unstable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3023-3026",
          "snippet": "static int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "*src_pmd"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swap_pmd",
          "args": [
            "*src_pmd"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_offset",
          "args": [
            "src_pud",
            "addr"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_alloc",
          "args": [
            "dst_mm",
            "dst_pud",
            "addr"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "__pmd_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "4004-4029",
          "snippet": "int __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tptl = pud_lock(mm, pud);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (!pud_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpud_populate(mm, pud, new);\n\t} else\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n#else\n\tif (!pgd_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpgd_populate(mm, pud, new);\n\t} else /* Another has populated it */\n\t\tpmd_free(mm, new);\n#endif /* __ARCH_HAS_4LEVEL_HACK */\n\tspin_unlock(ptl);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tptl = pud_lock(mm, pud);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (!pud_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpud_populate(mm, pud, new);\n\t} else\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n#else\n\tif (!pgd_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpgd_populate(mm, pud, new);\n\t} else /* Another has populated it */\n\t\tpmd_free(mm, new);\n#endif /* __ARCH_HAS_4LEVEL_HACK */\n\tspin_unlock(ptl);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline int copy_pmd_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tpud_t *dst_pud, pud_t *src_pud, struct vm_area_struct *vma,\n\t\tunsigned long addr, unsigned long end)\n{\n\tpmd_t *src_pmd, *dst_pmd;\n\tunsigned long next;\n\n\tdst_pmd = pmd_alloc(dst_mm, dst_pud, addr);\n\tif (!dst_pmd)\n\t\treturn -ENOMEM;\n\tsrc_pmd = pmd_offset(src_pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (is_swap_pmd(*src_pmd) || pmd_trans_huge(*src_pmd)\n\t\t\t|| pmd_devmap(*src_pmd)) {\n\t\t\tint err;\n\t\t\tVM_BUG_ON_VMA(next-addr != HPAGE_PMD_SIZE, vma);\n\t\t\terr = copy_huge_pmd(dst_mm, src_mm,\n\t\t\t\t\t    dst_pmd, src_pmd, addr, vma);\n\t\t\tif (err == -ENOMEM)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (!err)\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pmd_none_or_clear_bad(src_pmd))\n\t\t\tcontinue;\n\t\tif (copy_pte_range(dst_mm, src_mm, dst_pmd, src_pmd,\n\t\t\t\t\t\tvma, addr, next))\n\t\t\treturn -ENOMEM;\n\t} while (dst_pmd++, src_pmd++, addr = next, addr != end);\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_pte_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "816-877",
    "snippet": "static int copy_pte_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\t   pmd_t *dst_pmd, pmd_t *src_pmd, struct vm_area_struct *vma,\n\t\t   unsigned long addr, unsigned long end)\n{\n\tpte_t *orig_src_pte, *orig_dst_pte;\n\tpte_t *src_pte, *dst_pte;\n\tspinlock_t *src_ptl, *dst_ptl;\n\tint progress = 0;\n\tint rss[NR_MM_COUNTERS];\n\tswp_entry_t entry = (swp_entry_t){0};\n\nagain:\n\tinit_rss_vec(rss);\n\n\tdst_pte = pte_alloc_map_lock(dst_mm, dst_pmd, addr, &dst_ptl);\n\tif (!dst_pte)\n\t\treturn -ENOMEM;\n\tsrc_pte = pte_offset_map(src_pmd, addr);\n\tsrc_ptl = pte_lockptr(src_mm, src_pmd);\n\tspin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);\n\torig_src_pte = src_pte;\n\torig_dst_pte = dst_pte;\n\tarch_enter_lazy_mmu_mode();\n\n\tdo {\n\t\t/*\n\t\t * We are holding two locks at this point - either of them\n\t\t * could generate latencies in another task on another CPU.\n\t\t */\n\t\tif (progress >= 32) {\n\t\t\tprogress = 0;\n\t\t\tif (need_resched() ||\n\t\t\t    spin_needbreak(src_ptl) || spin_needbreak(dst_ptl))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (pte_none(*src_pte)) {\n\t\t\tprogress++;\n\t\t\tcontinue;\n\t\t}\n\t\tentry.val = copy_one_pte(dst_mm, src_mm, dst_pte, src_pte,\n\t\t\t\t\t\t\tvma, addr, rss);\n\t\tif (entry.val)\n\t\t\tbreak;\n\t\tprogress += 8;\n\t} while (dst_pte++, src_pte++, addr += PAGE_SIZE, addr != end);\n\n\tarch_leave_lazy_mmu_mode();\n\tspin_unlock(src_ptl);\n\tpte_unmap(orig_src_pte);\n\tadd_mm_rss_vec(dst_mm, rss);\n\tpte_unmap_unlock(orig_dst_pte, dst_ptl);\n\tcond_resched();\n\n\tif (entry.val) {\n\t\tif (add_swap_count_continuation(entry, GFP_KERNEL) < 0)\n\t\t\treturn -ENOMEM;\n\t\tprogress = 0;\n\t}\n\tif (addr != end)\n\t\tgoto again;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_swap_count_continuation",
          "args": [
            "entry",
            "GFP_KERNEL"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "add_swap_count_continuation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3507-3607",
          "snippet": "int add_swap_count_continuation(swp_entry_t entry, gfp_t gfp_mask)\n{\n\tstruct swap_info_struct *si;\n\tstruct swap_cluster_info *ci;\n\tstruct page *head;\n\tstruct page *page;\n\tstruct page *list_page;\n\tpgoff_t offset;\n\tunsigned char count;\n\n\t/*\n\t * When debugging, it's easier to use __GFP_ZERO here; but it's better\n\t * for latency not to zero a page while GFP_ATOMIC and holding locks.\n\t */\n\tpage = alloc_page(gfp_mask | __GFP_HIGHMEM);\n\n\tsi = swap_info_get(entry);\n\tif (!si) {\n\t\t/*\n\t\t * An acceptable race has occurred since the failing\n\t\t * __swap_duplicate(): the swap entry has been freed,\n\t\t * perhaps even the whole swap_map cleared for swapoff.\n\t\t */\n\t\tgoto outer;\n\t}\n\n\toffset = swp_offset(entry);\n\n\tci = lock_cluster(si, offset);\n\n\tcount = si->swap_map[offset] & ~SWAP_HAS_CACHE;\n\n\tif ((count & ~COUNT_CONTINUED) != SWAP_MAP_MAX) {\n\t\t/*\n\t\t * The higher the swap count, the more likely it is that tasks\n\t\t * will race to add swap count continuation: we need to avoid\n\t\t * over-provisioning.\n\t\t */\n\t\tgoto out;\n\t}\n\n\tif (!page) {\n\t\tunlock_cluster(ci);\n\t\tspin_unlock(&si->lock);\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * We are fortunate that although vmalloc_to_page uses pte_offset_map,\n\t * no architecture is using highmem pages for kernel page tables: so it\n\t * will not corrupt the GFP_ATOMIC caller's atomic page table kmaps.\n\t */\n\thead = vmalloc_to_page(si->swap_map + offset);\n\toffset &= ~PAGE_MASK;\n\n\tspin_lock(&si->cont_lock);\n\t/*\n\t * Page allocation does not initialize the page's lru field,\n\t * but it does always reset its private field.\n\t */\n\tif (!page_private(head)) {\n\t\tBUG_ON(count & COUNT_CONTINUED);\n\t\tINIT_LIST_HEAD(&head->lru);\n\t\tset_page_private(head, SWP_CONTINUED);\n\t\tsi->flags |= SWP_CONTINUED;\n\t}\n\n\tlist_for_each_entry(list_page, &head->lru, lru) {\n\t\tunsigned char *map;\n\n\t\t/*\n\t\t * If the previous map said no continuation, but we've found\n\t\t * a continuation page, free our allocation and use this one.\n\t\t */\n\t\tif (!(count & COUNT_CONTINUED))\n\t\t\tgoto out_unlock_cont;\n\n\t\tmap = kmap_atomic(list_page) + offset;\n\t\tcount = *map;\n\t\tkunmap_atomic(map);\n\n\t\t/*\n\t\t * If this continuation count now has some space in it,\n\t\t * free our allocation and use this one.\n\t\t */\n\t\tif ((count & ~COUNT_CONTINUED) != SWAP_CONT_MAX)\n\t\t\tgoto out_unlock_cont;\n\t}\n\n\tlist_add_tail(&page->lru, &head->lru);\n\tpage = NULL;\t\t\t/* now it's attached, don't free it */\nout_unlock_cont:\n\tspin_unlock(&si->cont_lock);\nout:\n\tunlock_cluster(ci);\n\tspin_unlock(&si->lock);\nouter:\n\tif (page)\n\t\t__free_page(page);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);",
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nint add_swap_count_continuation(swp_entry_t entry, gfp_t gfp_mask)\n{\n\tstruct swap_info_struct *si;\n\tstruct swap_cluster_info *ci;\n\tstruct page *head;\n\tstruct page *page;\n\tstruct page *list_page;\n\tpgoff_t offset;\n\tunsigned char count;\n\n\t/*\n\t * When debugging, it's easier to use __GFP_ZERO here; but it's better\n\t * for latency not to zero a page while GFP_ATOMIC and holding locks.\n\t */\n\tpage = alloc_page(gfp_mask | __GFP_HIGHMEM);\n\n\tsi = swap_info_get(entry);\n\tif (!si) {\n\t\t/*\n\t\t * An acceptable race has occurred since the failing\n\t\t * __swap_duplicate(): the swap entry has been freed,\n\t\t * perhaps even the whole swap_map cleared for swapoff.\n\t\t */\n\t\tgoto outer;\n\t}\n\n\toffset = swp_offset(entry);\n\n\tci = lock_cluster(si, offset);\n\n\tcount = si->swap_map[offset] & ~SWAP_HAS_CACHE;\n\n\tif ((count & ~COUNT_CONTINUED) != SWAP_MAP_MAX) {\n\t\t/*\n\t\t * The higher the swap count, the more likely it is that tasks\n\t\t * will race to add swap count continuation: we need to avoid\n\t\t * over-provisioning.\n\t\t */\n\t\tgoto out;\n\t}\n\n\tif (!page) {\n\t\tunlock_cluster(ci);\n\t\tspin_unlock(&si->lock);\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * We are fortunate that although vmalloc_to_page uses pte_offset_map,\n\t * no architecture is using highmem pages for kernel page tables: so it\n\t * will not corrupt the GFP_ATOMIC caller's atomic page table kmaps.\n\t */\n\thead = vmalloc_to_page(si->swap_map + offset);\n\toffset &= ~PAGE_MASK;\n\n\tspin_lock(&si->cont_lock);\n\t/*\n\t * Page allocation does not initialize the page's lru field,\n\t * but it does always reset its private field.\n\t */\n\tif (!page_private(head)) {\n\t\tBUG_ON(count & COUNT_CONTINUED);\n\t\tINIT_LIST_HEAD(&head->lru);\n\t\tset_page_private(head, SWP_CONTINUED);\n\t\tsi->flags |= SWP_CONTINUED;\n\t}\n\n\tlist_for_each_entry(list_page, &head->lru, lru) {\n\t\tunsigned char *map;\n\n\t\t/*\n\t\t * If the previous map said no continuation, but we've found\n\t\t * a continuation page, free our allocation and use this one.\n\t\t */\n\t\tif (!(count & COUNT_CONTINUED))\n\t\t\tgoto out_unlock_cont;\n\n\t\tmap = kmap_atomic(list_page) + offset;\n\t\tcount = *map;\n\t\tkunmap_atomic(map);\n\n\t\t/*\n\t\t * If this continuation count now has some space in it,\n\t\t * free our allocation and use this one.\n\t\t */\n\t\tif ((count & ~COUNT_CONTINUED) != SWAP_CONT_MAX)\n\t\t\tgoto out_unlock_cont;\n\t}\n\n\tlist_add_tail(&page->lru, &head->lru);\n\tpage = NULL;\t\t\t/* now it's attached, don't free it */\nout_unlock_cont:\n\tspin_unlock(&si->cont_lock);\nout:\n\tunlock_cluster(ci);\n\tspin_unlock(&si->lock);\nouter:\n\tif (page)\n\t\t__free_page(page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "orig_dst_pte",
            "dst_ptl"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_mm_rss_vec",
          "args": [
            "dst_mm",
            "rss"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "add_mm_rss_vec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "461-470",
          "snippet": "static inline void add_mm_rss_vec(struct mm_struct *mm, int *rss)\n{\n\tint i;\n\n\tif (current->mm == mm)\n\t\tsync_mm_rss(mm);\n\tfor (i = 0; i < NR_MM_COUNTERS; i++)\n\t\tif (rss[i])\n\t\t\tadd_mm_counter(mm, i, rss[i]);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void add_mm_rss_vec(struct mm_struct *mm, int *rss)\n{\n\tint i;\n\n\tif (current->mm == mm)\n\t\tsync_mm_rss(mm);\n\tfor (i = 0; i < NR_MM_COUNTERS; i++)\n\t\tif (rss[i])\n\t\t\tadd_mm_counter(mm, i, rss[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_unmap",
          "args": [
            "orig_src_pte"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "src_ptl"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_leave_lazy_mmu_mode",
          "args": [],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_one_pte",
          "args": [
            "dst_mm",
            "src_mm",
            "dst_pte",
            "src_pte",
            "vma",
            "addr",
            "rss"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "copy_one_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "698-814",
          "snippet": "static inline unsigned long\ncopy_one_pte(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tpte_t *dst_pte, pte_t *src_pte, struct vm_area_struct *vma,\n\t\tunsigned long addr, int *rss)\n{\n\tunsigned long vm_flags = vma->vm_flags;\n\tpte_t pte = *src_pte;\n\tstruct page *page;\n\n\t/* pte contains position in swap or file, so copy. */\n\tif (unlikely(!pte_present(pte))) {\n\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n\n\t\tif (likely(!non_swap_entry(entry))) {\n\t\t\tif (swap_duplicate(entry) < 0)\n\t\t\t\treturn entry.val;\n\n\t\t\t/* make sure dst_mm is on swapoff's mmlist. */\n\t\t\tif (unlikely(list_empty(&dst_mm->mmlist))) {\n\t\t\t\tspin_lock(&mmlist_lock);\n\t\t\t\tif (list_empty(&dst_mm->mmlist))\n\t\t\t\t\tlist_add(&dst_mm->mmlist,\n\t\t\t\t\t\t\t&src_mm->mmlist);\n\t\t\t\tspin_unlock(&mmlist_lock);\n\t\t\t}\n\t\t\trss[MM_SWAPENTS]++;\n\t\t} else if (is_migration_entry(entry)) {\n\t\t\tpage = migration_entry_to_page(entry);\n\n\t\t\trss[mm_counter(page)]++;\n\n\t\t\tif (is_write_migration_entry(entry) &&\n\t\t\t\t\tis_cow_mapping(vm_flags)) {\n\t\t\t\t/*\n\t\t\t\t * COW mappings require pages in both\n\t\t\t\t * parent and child to be set to read.\n\t\t\t\t */\n\t\t\t\tmake_migration_entry_read(&entry);\n\t\t\t\tpte = swp_entry_to_pte(entry);\n\t\t\t\tif (pte_swp_soft_dirty(*src_pte))\n\t\t\t\t\tpte = pte_swp_mksoft_dirty(pte);\n\t\t\t\tset_pte_at(src_mm, addr, src_pte, pte);\n\t\t\t}\n\t\t} else if (is_device_private_entry(entry)) {\n\t\t\tpage = device_private_entry_to_page(entry);\n\n\t\t\t/*\n\t\t\t * Update rss count even for unaddressable pages, as\n\t\t\t * they should treated just like normal pages in this\n\t\t\t * respect.\n\t\t\t *\n\t\t\t * We will likely want to have some new rss counters\n\t\t\t * for unaddressable pages, at some point. But for now\n\t\t\t * keep things as they are.\n\t\t\t */\n\t\t\tget_page(page);\n\t\t\trss[mm_counter(page)]++;\n\t\t\tpage_dup_rmap(page, false);\n\n\t\t\t/*\n\t\t\t * We do not preserve soft-dirty information, because so\n\t\t\t * far, checkpoint/restore is the only feature that\n\t\t\t * requires that. And checkpoint/restore does not work\n\t\t\t * when a device driver is involved (you cannot easily\n\t\t\t * save and restore device driver state).\n\t\t\t */\n\t\t\tif (is_write_device_private_entry(entry) &&\n\t\t\t    is_cow_mapping(vm_flags)) {\n\t\t\t\tmake_device_private_entry_read(&entry);\n\t\t\t\tpte = swp_entry_to_pte(entry);\n\t\t\t\tset_pte_at(src_mm, addr, src_pte, pte);\n\t\t\t}\n\t\t}\n\t\tgoto out_set_pte;\n\t}\n\n\t/*\n\t * If it's a COW mapping, write protect it both\n\t * in the parent and the child\n\t */\n\tif (is_cow_mapping(vm_flags) && pte_write(pte)) {\n\t\tptep_set_wrprotect(src_mm, addr, src_pte);\n\t\tpte = pte_wrprotect(pte);\n\t}\n\n\t/*\n\t * If it's a shared mapping, mark it clean in\n\t * the child\n\t */\n\tif (vm_flags & VM_SHARED)\n\t\tpte = pte_mkclean(pte);\n\tpte = pte_mkold(pte);\n\n\tpage = vm_normal_page(vma, addr, pte);\n\tif (page) {\n\t\tget_page(page);\n\t\tpage_dup_rmap(page, false);\n\t\trss[mm_counter(page)]++;\n\t} else if (pte_devmap(pte)) {\n\t\tpage = pte_page(pte);\n\n\t\t/*\n\t\t * Cache coherent device memory behave like regular page and\n\t\t * not like persistent memory page. For more informations see\n\t\t * MEMORY_DEVICE_CACHE_COHERENT in memory_hotplug.h\n\t\t */\n\t\tif (is_device_public_page(page)) {\n\t\t\tget_page(page);\n\t\t\tpage_dup_rmap(page, false);\n\t\t\trss[mm_counter(page)]++;\n\t\t}\n\t}\n\nout_set_pte:\n\tset_pte_at(dst_mm, addr, dst_pte, pte);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline unsigned long\ncopy_one_pte(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tpte_t *dst_pte, pte_t *src_pte, struct vm_area_struct *vma,\n\t\tunsigned long addr, int *rss)\n{\n\tunsigned long vm_flags = vma->vm_flags;\n\tpte_t pte = *src_pte;\n\tstruct page *page;\n\n\t/* pte contains position in swap or file, so copy. */\n\tif (unlikely(!pte_present(pte))) {\n\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n\n\t\tif (likely(!non_swap_entry(entry))) {\n\t\t\tif (swap_duplicate(entry) < 0)\n\t\t\t\treturn entry.val;\n\n\t\t\t/* make sure dst_mm is on swapoff's mmlist. */\n\t\t\tif (unlikely(list_empty(&dst_mm->mmlist))) {\n\t\t\t\tspin_lock(&mmlist_lock);\n\t\t\t\tif (list_empty(&dst_mm->mmlist))\n\t\t\t\t\tlist_add(&dst_mm->mmlist,\n\t\t\t\t\t\t\t&src_mm->mmlist);\n\t\t\t\tspin_unlock(&mmlist_lock);\n\t\t\t}\n\t\t\trss[MM_SWAPENTS]++;\n\t\t} else if (is_migration_entry(entry)) {\n\t\t\tpage = migration_entry_to_page(entry);\n\n\t\t\trss[mm_counter(page)]++;\n\n\t\t\tif (is_write_migration_entry(entry) &&\n\t\t\t\t\tis_cow_mapping(vm_flags)) {\n\t\t\t\t/*\n\t\t\t\t * COW mappings require pages in both\n\t\t\t\t * parent and child to be set to read.\n\t\t\t\t */\n\t\t\t\tmake_migration_entry_read(&entry);\n\t\t\t\tpte = swp_entry_to_pte(entry);\n\t\t\t\tif (pte_swp_soft_dirty(*src_pte))\n\t\t\t\t\tpte = pte_swp_mksoft_dirty(pte);\n\t\t\t\tset_pte_at(src_mm, addr, src_pte, pte);\n\t\t\t}\n\t\t} else if (is_device_private_entry(entry)) {\n\t\t\tpage = device_private_entry_to_page(entry);\n\n\t\t\t/*\n\t\t\t * Update rss count even for unaddressable pages, as\n\t\t\t * they should treated just like normal pages in this\n\t\t\t * respect.\n\t\t\t *\n\t\t\t * We will likely want to have some new rss counters\n\t\t\t * for unaddressable pages, at some point. But for now\n\t\t\t * keep things as they are.\n\t\t\t */\n\t\t\tget_page(page);\n\t\t\trss[mm_counter(page)]++;\n\t\t\tpage_dup_rmap(page, false);\n\n\t\t\t/*\n\t\t\t * We do not preserve soft-dirty information, because so\n\t\t\t * far, checkpoint/restore is the only feature that\n\t\t\t * requires that. And checkpoint/restore does not work\n\t\t\t * when a device driver is involved (you cannot easily\n\t\t\t * save and restore device driver state).\n\t\t\t */\n\t\t\tif (is_write_device_private_entry(entry) &&\n\t\t\t    is_cow_mapping(vm_flags)) {\n\t\t\t\tmake_device_private_entry_read(&entry);\n\t\t\t\tpte = swp_entry_to_pte(entry);\n\t\t\t\tset_pte_at(src_mm, addr, src_pte, pte);\n\t\t\t}\n\t\t}\n\t\tgoto out_set_pte;\n\t}\n\n\t/*\n\t * If it's a COW mapping, write protect it both\n\t * in the parent and the child\n\t */\n\tif (is_cow_mapping(vm_flags) && pte_write(pte)) {\n\t\tptep_set_wrprotect(src_mm, addr, src_pte);\n\t\tpte = pte_wrprotect(pte);\n\t}\n\n\t/*\n\t * If it's a shared mapping, mark it clean in\n\t * the child\n\t */\n\tif (vm_flags & VM_SHARED)\n\t\tpte = pte_mkclean(pte);\n\tpte = pte_mkold(pte);\n\n\tpage = vm_normal_page(vma, addr, pte);\n\tif (page) {\n\t\tget_page(page);\n\t\tpage_dup_rmap(page, false);\n\t\trss[mm_counter(page)]++;\n\t} else if (pte_devmap(pte)) {\n\t\tpage = pte_page(pte);\n\n\t\t/*\n\t\t * Cache coherent device memory behave like regular page and\n\t\t * not like persistent memory page. For more informations see\n\t\t * MEMORY_DEVICE_CACHE_COHERENT in memory_hotplug.h\n\t\t */\n\t\tif (is_device_public_page(page)) {\n\t\t\tget_page(page);\n\t\t\tpage_dup_rmap(page, false);\n\t\t\trss[mm_counter(page)]++;\n\t\t}\n\t}\n\nout_set_pte:\n\tset_pte_at(dst_mm, addr, dst_pte, pte);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "*src_pte"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_needbreak",
          "args": [
            "dst_ptl"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_needbreak",
          "args": [
            "src_ptl"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_enter_lazy_mmu_mode",
          "args": [],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "src_ptl",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_lockptr",
          "args": [
            "src_mm",
            "src_pmd"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map",
          "args": [
            "src_pmd",
            "addr"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_alloc_map_lock",
          "args": [
            "dst_mm",
            "dst_pmd",
            "addr",
            "&dst_ptl"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rss_vec",
          "args": [
            "rss"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "init_rss_vec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "456-459",
          "snippet": "static inline void init_rss_vec(int *rss)\n{\n\tmemset(rss, 0, sizeof(int) * NR_MM_COUNTERS);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void init_rss_vec(int *rss)\n{\n\tmemset(rss, 0, sizeof(int) * NR_MM_COUNTERS);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int copy_pte_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\t   pmd_t *dst_pmd, pmd_t *src_pmd, struct vm_area_struct *vma,\n\t\t   unsigned long addr, unsigned long end)\n{\n\tpte_t *orig_src_pte, *orig_dst_pte;\n\tpte_t *src_pte, *dst_pte;\n\tspinlock_t *src_ptl, *dst_ptl;\n\tint progress = 0;\n\tint rss[NR_MM_COUNTERS];\n\tswp_entry_t entry = (swp_entry_t){0};\n\nagain:\n\tinit_rss_vec(rss);\n\n\tdst_pte = pte_alloc_map_lock(dst_mm, dst_pmd, addr, &dst_ptl);\n\tif (!dst_pte)\n\t\treturn -ENOMEM;\n\tsrc_pte = pte_offset_map(src_pmd, addr);\n\tsrc_ptl = pte_lockptr(src_mm, src_pmd);\n\tspin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);\n\torig_src_pte = src_pte;\n\torig_dst_pte = dst_pte;\n\tarch_enter_lazy_mmu_mode();\n\n\tdo {\n\t\t/*\n\t\t * We are holding two locks at this point - either of them\n\t\t * could generate latencies in another task on another CPU.\n\t\t */\n\t\tif (progress >= 32) {\n\t\t\tprogress = 0;\n\t\t\tif (need_resched() ||\n\t\t\t    spin_needbreak(src_ptl) || spin_needbreak(dst_ptl))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (pte_none(*src_pte)) {\n\t\t\tprogress++;\n\t\t\tcontinue;\n\t\t}\n\t\tentry.val = copy_one_pte(dst_mm, src_mm, dst_pte, src_pte,\n\t\t\t\t\t\t\tvma, addr, rss);\n\t\tif (entry.val)\n\t\t\tbreak;\n\t\tprogress += 8;\n\t} while (dst_pte++, src_pte++, addr += PAGE_SIZE, addr != end);\n\n\tarch_leave_lazy_mmu_mode();\n\tspin_unlock(src_ptl);\n\tpte_unmap(orig_src_pte);\n\tadd_mm_rss_vec(dst_mm, rss);\n\tpte_unmap_unlock(orig_dst_pte, dst_ptl);\n\tcond_resched();\n\n\tif (entry.val) {\n\t\tif (add_swap_count_continuation(entry, GFP_KERNEL) < 0)\n\t\t\treturn -ENOMEM;\n\t\tprogress = 0;\n\t}\n\tif (addr != end)\n\t\tgoto again;\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_one_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "698-814",
    "snippet": "static inline unsigned long\ncopy_one_pte(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tpte_t *dst_pte, pte_t *src_pte, struct vm_area_struct *vma,\n\t\tunsigned long addr, int *rss)\n{\n\tunsigned long vm_flags = vma->vm_flags;\n\tpte_t pte = *src_pte;\n\tstruct page *page;\n\n\t/* pte contains position in swap or file, so copy. */\n\tif (unlikely(!pte_present(pte))) {\n\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n\n\t\tif (likely(!non_swap_entry(entry))) {\n\t\t\tif (swap_duplicate(entry) < 0)\n\t\t\t\treturn entry.val;\n\n\t\t\t/* make sure dst_mm is on swapoff's mmlist. */\n\t\t\tif (unlikely(list_empty(&dst_mm->mmlist))) {\n\t\t\t\tspin_lock(&mmlist_lock);\n\t\t\t\tif (list_empty(&dst_mm->mmlist))\n\t\t\t\t\tlist_add(&dst_mm->mmlist,\n\t\t\t\t\t\t\t&src_mm->mmlist);\n\t\t\t\tspin_unlock(&mmlist_lock);\n\t\t\t}\n\t\t\trss[MM_SWAPENTS]++;\n\t\t} else if (is_migration_entry(entry)) {\n\t\t\tpage = migration_entry_to_page(entry);\n\n\t\t\trss[mm_counter(page)]++;\n\n\t\t\tif (is_write_migration_entry(entry) &&\n\t\t\t\t\tis_cow_mapping(vm_flags)) {\n\t\t\t\t/*\n\t\t\t\t * COW mappings require pages in both\n\t\t\t\t * parent and child to be set to read.\n\t\t\t\t */\n\t\t\t\tmake_migration_entry_read(&entry);\n\t\t\t\tpte = swp_entry_to_pte(entry);\n\t\t\t\tif (pte_swp_soft_dirty(*src_pte))\n\t\t\t\t\tpte = pte_swp_mksoft_dirty(pte);\n\t\t\t\tset_pte_at(src_mm, addr, src_pte, pte);\n\t\t\t}\n\t\t} else if (is_device_private_entry(entry)) {\n\t\t\tpage = device_private_entry_to_page(entry);\n\n\t\t\t/*\n\t\t\t * Update rss count even for unaddressable pages, as\n\t\t\t * they should treated just like normal pages in this\n\t\t\t * respect.\n\t\t\t *\n\t\t\t * We will likely want to have some new rss counters\n\t\t\t * for unaddressable pages, at some point. But for now\n\t\t\t * keep things as they are.\n\t\t\t */\n\t\t\tget_page(page);\n\t\t\trss[mm_counter(page)]++;\n\t\t\tpage_dup_rmap(page, false);\n\n\t\t\t/*\n\t\t\t * We do not preserve soft-dirty information, because so\n\t\t\t * far, checkpoint/restore is the only feature that\n\t\t\t * requires that. And checkpoint/restore does not work\n\t\t\t * when a device driver is involved (you cannot easily\n\t\t\t * save and restore device driver state).\n\t\t\t */\n\t\t\tif (is_write_device_private_entry(entry) &&\n\t\t\t    is_cow_mapping(vm_flags)) {\n\t\t\t\tmake_device_private_entry_read(&entry);\n\t\t\t\tpte = swp_entry_to_pte(entry);\n\t\t\t\tset_pte_at(src_mm, addr, src_pte, pte);\n\t\t\t}\n\t\t}\n\t\tgoto out_set_pte;\n\t}\n\n\t/*\n\t * If it's a COW mapping, write protect it both\n\t * in the parent and the child\n\t */\n\tif (is_cow_mapping(vm_flags) && pte_write(pte)) {\n\t\tptep_set_wrprotect(src_mm, addr, src_pte);\n\t\tpte = pte_wrprotect(pte);\n\t}\n\n\t/*\n\t * If it's a shared mapping, mark it clean in\n\t * the child\n\t */\n\tif (vm_flags & VM_SHARED)\n\t\tpte = pte_mkclean(pte);\n\tpte = pte_mkold(pte);\n\n\tpage = vm_normal_page(vma, addr, pte);\n\tif (page) {\n\t\tget_page(page);\n\t\tpage_dup_rmap(page, false);\n\t\trss[mm_counter(page)]++;\n\t} else if (pte_devmap(pte)) {\n\t\tpage = pte_page(pte);\n\n\t\t/*\n\t\t * Cache coherent device memory behave like regular page and\n\t\t * not like persistent memory page. For more informations see\n\t\t * MEMORY_DEVICE_CACHE_COHERENT in memory_hotplug.h\n\t\t */\n\t\tif (is_device_public_page(page)) {\n\t\t\tget_page(page);\n\t\t\tpage_dup_rmap(page, false);\n\t\t\trss[mm_counter(page)]++;\n\t\t}\n\t}\n\nout_set_pte:\n\tset_pte_at(dst_mm, addr, dst_pte, pte);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "dst_mm",
            "addr",
            "dst_pte",
            "pte"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_counter",
          "args": [
            "page"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_dup_rmap",
          "args": [
            "page",
            "false"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_device_public_page",
          "args": [
            "page"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_page",
          "args": [
            "pte"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "release_pte_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "504-509",
          "snippet": "static void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_devmap",
          "args": [
            "pte"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_counter",
          "args": [
            "page"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_dup_rmap",
          "args": [
            "page",
            "false"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_normal_page",
          "args": [
            "vma",
            "addr",
            "pte"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "vm_normal_page_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "651-689",
          "snippet": "struct page *vm_normal_page_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tpmd_t pmd)\n{\n\tunsigned long pfn = pmd_pfn(pmd);\n\n\t/*\n\t * There is no pmd_special() but there may be special pmds, e.g.\n\t * in a direct-access (dax) mapping, so let's just replicate the\n\t * !CONFIG_ARCH_HAS_PTE_SPECIAL case from vm_normal_page() here.\n\t */\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (pmd_devmap(pmd))\n\t\treturn NULL;\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\tif (unlikely(pfn > highest_memmap_pfn))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstruct page *vm_normal_page_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tpmd_t pmd)\n{\n\tunsigned long pfn = pmd_pfn(pmd);\n\n\t/*\n\t * There is no pmd_special() but there may be special pmds, e.g.\n\t * in a direct-access (dax) mapping, so let's just replicate the\n\t * !CONFIG_ARCH_HAS_PTE_SPECIAL case from vm_normal_page() here.\n\t */\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (pmd_devmap(pmd))\n\t\treturn NULL;\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\tif (unlikely(pfn > highest_memmap_pfn))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_mkold",
          "args": [
            "pte"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkclean",
          "args": [
            "pte"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_wrprotect",
          "args": [
            "pte"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptep_set_wrprotect",
          "args": [
            "src_mm",
            "addr",
            "src_pte"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_write",
          "args": [
            "pte"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_cow_mapping",
          "args": [
            "vm_flags"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "is_cow_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "247-250",
          "snippet": "static inline bool is_cow_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline bool is_cow_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "src_mm",
            "addr",
            "src_pte",
            "pte"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_entry_to_pte",
          "args": [
            "entry"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_device_private_entry_read",
          "args": [
            "&entry"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_write_device_private_entry",
          "args": [
            "entry"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_dup_rmap",
          "args": [
            "page",
            "false"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_counter",
          "args": [
            "page"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_private_entry_to_page",
          "args": [
            "entry"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_device_private_entry",
          "args": [
            "entry"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "src_mm",
            "addr",
            "src_pte",
            "pte"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_swp_mksoft_dirty",
          "args": [
            "pte"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_swp_soft_dirty",
          "args": [
            "*src_pte"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_entry_to_pte",
          "args": [
            "entry"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_migration_entry_read",
          "args": [
            "&entry"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_write_migration_entry",
          "args": [
            "entry"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_counter",
          "args": [
            "page"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migration_entry_to_page",
          "args": [
            "entry"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_migration_entry",
          "args": [
            "entry"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mmlist_lock"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&dst_mm->mmlist",
            "&src_mm->mmlist"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&dst_mm->mmlist"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mmlist_lock"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "list_empty(&dst_mm->mmlist)"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_duplicate",
          "args": [
            "entry"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "swap_duplicate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3443-3450",
          "snippet": "int swap_duplicate(swp_entry_t entry)\n{\n\tint err = 0;\n\n\twhile (!err && __swap_duplicate(entry, 1) == -ENOMEM)\n\t\terr = add_swap_count_continuation(entry, GFP_ATOMIC);\n\treturn err;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint swap_duplicate(swp_entry_t entry)\n{\n\tint err = 0;\n\n\twhile (!err && __swap_duplicate(entry, 1) == -ENOMEM)\n\t\terr = add_swap_count_continuation(entry, GFP_ATOMIC);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!non_swap_entry(entry)"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "non_swap_entry",
          "args": [
            "entry"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_to_swp_entry",
          "args": [
            "pte"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pte_present(pte)"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "pte"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline unsigned long\ncopy_one_pte(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tpte_t *dst_pte, pte_t *src_pte, struct vm_area_struct *vma,\n\t\tunsigned long addr, int *rss)\n{\n\tunsigned long vm_flags = vma->vm_flags;\n\tpte_t pte = *src_pte;\n\tstruct page *page;\n\n\t/* pte contains position in swap or file, so copy. */\n\tif (unlikely(!pte_present(pte))) {\n\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n\n\t\tif (likely(!non_swap_entry(entry))) {\n\t\t\tif (swap_duplicate(entry) < 0)\n\t\t\t\treturn entry.val;\n\n\t\t\t/* make sure dst_mm is on swapoff's mmlist. */\n\t\t\tif (unlikely(list_empty(&dst_mm->mmlist))) {\n\t\t\t\tspin_lock(&mmlist_lock);\n\t\t\t\tif (list_empty(&dst_mm->mmlist))\n\t\t\t\t\tlist_add(&dst_mm->mmlist,\n\t\t\t\t\t\t\t&src_mm->mmlist);\n\t\t\t\tspin_unlock(&mmlist_lock);\n\t\t\t}\n\t\t\trss[MM_SWAPENTS]++;\n\t\t} else if (is_migration_entry(entry)) {\n\t\t\tpage = migration_entry_to_page(entry);\n\n\t\t\trss[mm_counter(page)]++;\n\n\t\t\tif (is_write_migration_entry(entry) &&\n\t\t\t\t\tis_cow_mapping(vm_flags)) {\n\t\t\t\t/*\n\t\t\t\t * COW mappings require pages in both\n\t\t\t\t * parent and child to be set to read.\n\t\t\t\t */\n\t\t\t\tmake_migration_entry_read(&entry);\n\t\t\t\tpte = swp_entry_to_pte(entry);\n\t\t\t\tif (pte_swp_soft_dirty(*src_pte))\n\t\t\t\t\tpte = pte_swp_mksoft_dirty(pte);\n\t\t\t\tset_pte_at(src_mm, addr, src_pte, pte);\n\t\t\t}\n\t\t} else if (is_device_private_entry(entry)) {\n\t\t\tpage = device_private_entry_to_page(entry);\n\n\t\t\t/*\n\t\t\t * Update rss count even for unaddressable pages, as\n\t\t\t * they should treated just like normal pages in this\n\t\t\t * respect.\n\t\t\t *\n\t\t\t * We will likely want to have some new rss counters\n\t\t\t * for unaddressable pages, at some point. But for now\n\t\t\t * keep things as they are.\n\t\t\t */\n\t\t\tget_page(page);\n\t\t\trss[mm_counter(page)]++;\n\t\t\tpage_dup_rmap(page, false);\n\n\t\t\t/*\n\t\t\t * We do not preserve soft-dirty information, because so\n\t\t\t * far, checkpoint/restore is the only feature that\n\t\t\t * requires that. And checkpoint/restore does not work\n\t\t\t * when a device driver is involved (you cannot easily\n\t\t\t * save and restore device driver state).\n\t\t\t */\n\t\t\tif (is_write_device_private_entry(entry) &&\n\t\t\t    is_cow_mapping(vm_flags)) {\n\t\t\t\tmake_device_private_entry_read(&entry);\n\t\t\t\tpte = swp_entry_to_pte(entry);\n\t\t\t\tset_pte_at(src_mm, addr, src_pte, pte);\n\t\t\t}\n\t\t}\n\t\tgoto out_set_pte;\n\t}\n\n\t/*\n\t * If it's a COW mapping, write protect it both\n\t * in the parent and the child\n\t */\n\tif (is_cow_mapping(vm_flags) && pte_write(pte)) {\n\t\tptep_set_wrprotect(src_mm, addr, src_pte);\n\t\tpte = pte_wrprotect(pte);\n\t}\n\n\t/*\n\t * If it's a shared mapping, mark it clean in\n\t * the child\n\t */\n\tif (vm_flags & VM_SHARED)\n\t\tpte = pte_mkclean(pte);\n\tpte = pte_mkold(pte);\n\n\tpage = vm_normal_page(vma, addr, pte);\n\tif (page) {\n\t\tget_page(page);\n\t\tpage_dup_rmap(page, false);\n\t\trss[mm_counter(page)]++;\n\t} else if (pte_devmap(pte)) {\n\t\tpage = pte_page(pte);\n\n\t\t/*\n\t\t * Cache coherent device memory behave like regular page and\n\t\t * not like persistent memory page. For more informations see\n\t\t * MEMORY_DEVICE_CACHE_COHERENT in memory_hotplug.h\n\t\t */\n\t\tif (is_device_public_page(page)) {\n\t\t\tget_page(page);\n\t\t\tpage_dup_rmap(page, false);\n\t\t\trss[mm_counter(page)]++;\n\t\t}\n\t}\n\nout_set_pte:\n\tset_pte_at(dst_mm, addr, dst_pte, pte);\n\treturn 0;\n}"
  },
  {
    "function_name": "vm_normal_page_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "651-689",
    "snippet": "struct page *vm_normal_page_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tpmd_t pmd)\n{\n\tunsigned long pfn = pmd_pfn(pmd);\n\n\t/*\n\t * There is no pmd_special() but there may be special pmds, e.g.\n\t * in a direct-access (dax) mapping, so let's just replicate the\n\t * !CONFIG_ARCH_HAS_PTE_SPECIAL case from vm_normal_page() here.\n\t */\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (pmd_devmap(pmd))\n\t\treturn NULL;\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\tif (unlikely(pfn > highest_memmap_pfn))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pfn > highest_memmap_pfn"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_zero_pfn",
          "args": [
            "pfn"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_devmap",
          "args": [
            "pmd"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "pmd_devmap_trans_unstable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3023-3026",
          "snippet": "static int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_cow_mapping",
          "args": [
            "vma->vm_flags"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "is_cow_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "247-250",
          "snippet": "static inline bool is_cow_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline bool is_cow_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_pfn",
          "args": [
            "pmd"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstruct page *vm_normal_page_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tpmd_t pmd)\n{\n\tunsigned long pfn = pmd_pfn(pmd);\n\n\t/*\n\t * There is no pmd_special() but there may be special pmds, e.g.\n\t * in a direct-access (dax) mapping, so let's just replicate the\n\t * !CONFIG_ARCH_HAS_PTE_SPECIAL case from vm_normal_page() here.\n\t */\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (pmd_devmap(pmd))\n\t\treturn NULL;\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\tif (unlikely(pfn > highest_memmap_pfn))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}"
  },
  {
    "function_name": "_vm_normal_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "572-648",
    "snippet": "struct page *_vm_normal_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t     pte_t pte, bool with_public_device)\n{\n\tunsigned long pfn = pte_pfn(pte);\n\n\tif (IS_ENABLED(CONFIG_ARCH_HAS_PTE_SPECIAL)) {\n\t\tif (likely(!pte_special(pte)))\n\t\t\tgoto check_pfn;\n\t\tif (vma->vm_ops && vma->vm_ops->find_special_page)\n\t\t\treturn vma->vm_ops->find_special_page(vma, addr);\n\t\tif (vma->vm_flags & (VM_PFNMAP | VM_MIXEDMAP))\n\t\t\treturn NULL;\n\t\tif (is_zero_pfn(pfn))\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * Device public pages are special pages (they are ZONE_DEVICE\n\t\t * pages but different from persistent memory). They behave\n\t\t * allmost like normal pages. The difference is that they are\n\t\t * not on the lru and thus should never be involve with any-\n\t\t * thing that involve lru manipulation (mlock, numa balancing,\n\t\t * ...).\n\t\t *\n\t\t * This is why we still want to return NULL for such page from\n\t\t * vm_normal_page() so that we do not have to special case all\n\t\t * call site of vm_normal_page().\n\t\t */\n\t\tif (likely(pfn <= highest_memmap_pfn)) {\n\t\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\t\tif (is_device_public_page(page)) {\n\t\t\t\tif (with_public_device)\n\t\t\t\t\treturn page;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (pte_devmap(pte))\n\t\t\treturn NULL;\n\n\t\tprint_bad_pte(vma, addr, pte, NULL);\n\t\treturn NULL;\n\t}\n\n\t/* !CONFIG_ARCH_HAS_PTE_SPECIAL case follows: */\n\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\ncheck_pfn:\n\tif (unlikely(pfn > highest_memmap_pfn)) {\n\t\tprint_bad_pte(vma, addr, pte, NULL);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_bad_pte",
          "args": [
            "vma",
            "addr",
            "pte",
            "NULL"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "print_bad_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "479-528",
          "snippet": "static void print_bad_pte(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t  pte_t pte, struct page *page)\n{\n\tpgd_t *pgd = pgd_offset(vma->vm_mm, addr);\n\tp4d_t *p4d = p4d_offset(pgd, addr);\n\tpud_t *pud = pud_offset(p4d, addr);\n\tpmd_t *pmd = pmd_offset(pud, addr);\n\tstruct address_space *mapping;\n\tpgoff_t index;\n\tstatic unsigned long resume;\n\tstatic unsigned long nr_shown;\n\tstatic unsigned long nr_unshown;\n\n\t/*\n\t * Allow a burst of 60 reports, then keep quiet for that minute;\n\t * or allow a steady drip of one report per second.\n\t */\n\tif (nr_shown == 60) {\n\t\tif (time_before(jiffies, resume)) {\n\t\t\tnr_unshown++;\n\t\t\treturn;\n\t\t}\n\t\tif (nr_unshown) {\n\t\t\tpr_alert(\"BUG: Bad page map: %lu messages suppressed\\n\",\n\t\t\t\t nr_unshown);\n\t\t\tnr_unshown = 0;\n\t\t}\n\t\tnr_shown = 0;\n\t}\n\tif (nr_shown++ == 0)\n\t\tresume = jiffies + 60 * HZ;\n\n\tmapping = vma->vm_file ? vma->vm_file->f_mapping : NULL;\n\tindex = linear_page_index(vma, addr);\n\n\tpr_alert(\"BUG: Bad page map in process %s  pte:%08llx pmd:%08llx\\n\",\n\t\t current->comm,\n\t\t (long long)pte_val(pte), (long long)pmd_val(*pmd));\n\tif (page)\n\t\tdump_page(page, \"bad pte\");\n\tpr_alert(\"addr:%p vm_flags:%08lx anon_vma:%p mapping:%p index:%lx\\n\",\n\t\t (void *)addr, vma->vm_flags, vma->anon_vma, mapping, index);\n\tpr_alert(\"file:%pD fault:%pf mmap:%pf readpage:%pf\\n\",\n\t\t vma->vm_file,\n\t\t vma->vm_ops ? vma->vm_ops->fault : NULL,\n\t\t vma->vm_file ? vma->vm_file->f_op->mmap : NULL,\n\t\t mapping ? mapping->a_ops->readpage : NULL);\n\tdump_stack();\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void print_bad_pte(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t  pte_t pte, struct page *page)\n{\n\tpgd_t *pgd = pgd_offset(vma->vm_mm, addr);\n\tp4d_t *p4d = p4d_offset(pgd, addr);\n\tpud_t *pud = pud_offset(p4d, addr);\n\tpmd_t *pmd = pmd_offset(pud, addr);\n\tstruct address_space *mapping;\n\tpgoff_t index;\n\tstatic unsigned long resume;\n\tstatic unsigned long nr_shown;\n\tstatic unsigned long nr_unshown;\n\n\t/*\n\t * Allow a burst of 60 reports, then keep quiet for that minute;\n\t * or allow a steady drip of one report per second.\n\t */\n\tif (nr_shown == 60) {\n\t\tif (time_before(jiffies, resume)) {\n\t\t\tnr_unshown++;\n\t\t\treturn;\n\t\t}\n\t\tif (nr_unshown) {\n\t\t\tpr_alert(\"BUG: Bad page map: %lu messages suppressed\\n\",\n\t\t\t\t nr_unshown);\n\t\t\tnr_unshown = 0;\n\t\t}\n\t\tnr_shown = 0;\n\t}\n\tif (nr_shown++ == 0)\n\t\tresume = jiffies + 60 * HZ;\n\n\tmapping = vma->vm_file ? vma->vm_file->f_mapping : NULL;\n\tindex = linear_page_index(vma, addr);\n\n\tpr_alert(\"BUG: Bad page map in process %s  pte:%08llx pmd:%08llx\\n\",\n\t\t current->comm,\n\t\t (long long)pte_val(pte), (long long)pmd_val(*pmd));\n\tif (page)\n\t\tdump_page(page, \"bad pte\");\n\tpr_alert(\"addr:%p vm_flags:%08lx anon_vma:%p mapping:%p index:%lx\\n\",\n\t\t (void *)addr, vma->vm_flags, vma->anon_vma, mapping, index);\n\tpr_alert(\"file:%pD fault:%pf mmap:%pf readpage:%pf\\n\",\n\t\t vma->vm_file,\n\t\t vma->vm_ops ? vma->vm_ops->fault : NULL,\n\t\t vma->vm_file ? vma->vm_file->f_op->mmap : NULL,\n\t\t mapping ? mapping->a_ops->readpage : NULL);\n\tdump_stack();\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pfn > highest_memmap_pfn"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_zero_pfn",
          "args": [
            "pfn"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_cow_mapping",
          "args": [
            "vma->vm_flags"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "is_cow_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "247-250",
          "snippet": "static inline bool is_cow_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline bool is_cow_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_devmap",
          "args": [
            "pte"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_device_public_page",
          "args": [
            "page"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "pfn <= highest_memmap_pfn"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_zero_pfn",
          "args": [
            "pfn"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma->vm_ops->find_special_page",
          "args": [
            "vma",
            "addr"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!pte_special(pte)"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_special",
          "args": [
            "pte"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_ARCH_HAS_PTE_SPECIAL"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "pte"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstruct page *_vm_normal_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t     pte_t pte, bool with_public_device)\n{\n\tunsigned long pfn = pte_pfn(pte);\n\n\tif (IS_ENABLED(CONFIG_ARCH_HAS_PTE_SPECIAL)) {\n\t\tif (likely(!pte_special(pte)))\n\t\t\tgoto check_pfn;\n\t\tif (vma->vm_ops && vma->vm_ops->find_special_page)\n\t\t\treturn vma->vm_ops->find_special_page(vma, addr);\n\t\tif (vma->vm_flags & (VM_PFNMAP | VM_MIXEDMAP))\n\t\t\treturn NULL;\n\t\tif (is_zero_pfn(pfn))\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * Device public pages are special pages (they are ZONE_DEVICE\n\t\t * pages but different from persistent memory). They behave\n\t\t * allmost like normal pages. The difference is that they are\n\t\t * not on the lru and thus should never be involve with any-\n\t\t * thing that involve lru manipulation (mlock, numa balancing,\n\t\t * ...).\n\t\t *\n\t\t * This is why we still want to return NULL for such page from\n\t\t * vm_normal_page() so that we do not have to special case all\n\t\t * call site of vm_normal_page().\n\t\t */\n\t\tif (likely(pfn <= highest_memmap_pfn)) {\n\t\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\t\tif (is_device_public_page(page)) {\n\t\t\t\tif (with_public_device)\n\t\t\t\t\treturn page;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (pte_devmap(pte))\n\t\t\treturn NULL;\n\n\t\tprint_bad_pte(vma, addr, pte, NULL);\n\t\treturn NULL;\n\t}\n\n\t/* !CONFIG_ARCH_HAS_PTE_SPECIAL case follows: */\n\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\ncheck_pfn:\n\tif (unlikely(pfn > highest_memmap_pfn)) {\n\t\tprint_bad_pte(vma, addr, pte, NULL);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}"
  },
  {
    "function_name": "print_bad_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "479-528",
    "snippet": "static void print_bad_pte(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t  pte_t pte, struct page *page)\n{\n\tpgd_t *pgd = pgd_offset(vma->vm_mm, addr);\n\tp4d_t *p4d = p4d_offset(pgd, addr);\n\tpud_t *pud = pud_offset(p4d, addr);\n\tpmd_t *pmd = pmd_offset(pud, addr);\n\tstruct address_space *mapping;\n\tpgoff_t index;\n\tstatic unsigned long resume;\n\tstatic unsigned long nr_shown;\n\tstatic unsigned long nr_unshown;\n\n\t/*\n\t * Allow a burst of 60 reports, then keep quiet for that minute;\n\t * or allow a steady drip of one report per second.\n\t */\n\tif (nr_shown == 60) {\n\t\tif (time_before(jiffies, resume)) {\n\t\t\tnr_unshown++;\n\t\t\treturn;\n\t\t}\n\t\tif (nr_unshown) {\n\t\t\tpr_alert(\"BUG: Bad page map: %lu messages suppressed\\n\",\n\t\t\t\t nr_unshown);\n\t\t\tnr_unshown = 0;\n\t\t}\n\t\tnr_shown = 0;\n\t}\n\tif (nr_shown++ == 0)\n\t\tresume = jiffies + 60 * HZ;\n\n\tmapping = vma->vm_file ? vma->vm_file->f_mapping : NULL;\n\tindex = linear_page_index(vma, addr);\n\n\tpr_alert(\"BUG: Bad page map in process %s  pte:%08llx pmd:%08llx\\n\",\n\t\t current->comm,\n\t\t (long long)pte_val(pte), (long long)pmd_val(*pmd));\n\tif (page)\n\t\tdump_page(page, \"bad pte\");\n\tpr_alert(\"addr:%p vm_flags:%08lx anon_vma:%p mapping:%p index:%lx\\n\",\n\t\t (void *)addr, vma->vm_flags, vma->anon_vma, mapping, index);\n\tpr_alert(\"file:%pD fault:%pf mmap:%pf readpage:%pf\\n\",\n\t\t vma->vm_file,\n\t\t vma->vm_ops ? vma->vm_ops->fault : NULL,\n\t\t vma->vm_file ? vma->vm_file->f_op->mmap : NULL,\n\t\t mapping ? mapping->a_ops->readpage : NULL);\n\tdump_stack();\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_taint",
          "args": [
            "TAINT_BAD_PAGE",
            "LOCKDEP_NOW_UNRELIABLE"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"file:%pD fault:%pf mmap:%pf readpage:%pf\\n\"",
            "vma->vm_file",
            "vma->vm_ops ? vma->vm_ops->fault : NULL",
            "vma->vm_file ? vma->vm_file->f_op->mmap : NULL",
            "mapping ? mapping->a_ops->readpage : NULL"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"addr:%p vm_flags:%08lx anon_vma:%p mapping:%p index:%lx\\n\"",
            "(void *)addr",
            "vma->vm_flags",
            "vma->anon_vma",
            "mapping",
            "index"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_page",
          "args": [
            "page",
            "\"bad pte\""
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "dump_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/debug.c",
          "lines": "91-95",
          "snippet": "void dump_page(struct page *page, const char *reason)\n{\n\t__dump_page(page, reason);\n\tdump_page_owner(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/migrate.h>",
            "#include <trace/events/mmflags.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/ctype.h>\n#include <linux/page_owner.h>\n#include <linux/migrate.h>\n#include <trace/events/mmflags.h>\n#include <linux/memcontrol.h>\n#include <linux/trace_events.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid dump_page(struct page *page, const char *reason)\n{\n\t__dump_page(page, reason);\n\tdump_page_owner(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"BUG: Bad page map in process %s  pte:%08llx pmd:%08llx\\n\"",
            "current->comm",
            "(long long)pte_val(pte)",
            "(long long)pmd_val(*pmd)"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_val",
          "args": [
            "*pmd"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_val",
          "args": [
            "pte"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linear_page_index",
          "args": [
            "vma",
            "addr"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"BUG: Bad page map: %lu messages suppressed\\n\"",
            "nr_unshown"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "resume"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_offset",
          "args": [
            "pud",
            "addr"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_offset",
          "args": [
            "p4d",
            "addr"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_offset",
          "args": [
            "pgd",
            "addr"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_offset",
          "args": [
            "vma->vm_mm",
            "addr"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void print_bad_pte(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t  pte_t pte, struct page *page)\n{\n\tpgd_t *pgd = pgd_offset(vma->vm_mm, addr);\n\tp4d_t *p4d = p4d_offset(pgd, addr);\n\tpud_t *pud = pud_offset(p4d, addr);\n\tpmd_t *pmd = pmd_offset(pud, addr);\n\tstruct address_space *mapping;\n\tpgoff_t index;\n\tstatic unsigned long resume;\n\tstatic unsigned long nr_shown;\n\tstatic unsigned long nr_unshown;\n\n\t/*\n\t * Allow a burst of 60 reports, then keep quiet for that minute;\n\t * or allow a steady drip of one report per second.\n\t */\n\tif (nr_shown == 60) {\n\t\tif (time_before(jiffies, resume)) {\n\t\t\tnr_unshown++;\n\t\t\treturn;\n\t\t}\n\t\tif (nr_unshown) {\n\t\t\tpr_alert(\"BUG: Bad page map: %lu messages suppressed\\n\",\n\t\t\t\t nr_unshown);\n\t\t\tnr_unshown = 0;\n\t\t}\n\t\tnr_shown = 0;\n\t}\n\tif (nr_shown++ == 0)\n\t\tresume = jiffies + 60 * HZ;\n\n\tmapping = vma->vm_file ? vma->vm_file->f_mapping : NULL;\n\tindex = linear_page_index(vma, addr);\n\n\tpr_alert(\"BUG: Bad page map in process %s  pte:%08llx pmd:%08llx\\n\",\n\t\t current->comm,\n\t\t (long long)pte_val(pte), (long long)pmd_val(*pmd));\n\tif (page)\n\t\tdump_page(page, \"bad pte\");\n\tpr_alert(\"addr:%p vm_flags:%08lx anon_vma:%p mapping:%p index:%lx\\n\",\n\t\t (void *)addr, vma->vm_flags, vma->anon_vma, mapping, index);\n\tpr_alert(\"file:%pD fault:%pf mmap:%pf readpage:%pf\\n\",\n\t\t vma->vm_file,\n\t\t vma->vm_ops ? vma->vm_ops->fault : NULL,\n\t\t vma->vm_file ? vma->vm_file->f_op->mmap : NULL,\n\t\t mapping ? mapping->a_ops->readpage : NULL);\n\tdump_stack();\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n}"
  },
  {
    "function_name": "add_mm_rss_vec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "461-470",
    "snippet": "static inline void add_mm_rss_vec(struct mm_struct *mm, int *rss)\n{\n\tint i;\n\n\tif (current->mm == mm)\n\t\tsync_mm_rss(mm);\n\tfor (i = 0; i < NR_MM_COUNTERS; i++)\n\t\tif (rss[i])\n\t\t\tadd_mm_counter(mm, i, rss[i]);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_mm_counter",
          "args": [
            "mm",
            "i",
            "rss[i]"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "add_mm_counter_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "157-165",
          "snippet": "static void add_mm_counter_fast(struct mm_struct *mm, int member, int val)\n{\n\tstruct task_struct *task = current;\n\n\tif (likely(task->mm == mm))\n\t\ttask->rss_stat.count[member] += val;\n\telse\n\t\tadd_mm_counter(mm, member, val);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void add_mm_counter_fast(struct mm_struct *mm, int member, int val)\n{\n\tstruct task_struct *task = current;\n\n\tif (likely(task->mm == mm))\n\t\ttask->rss_stat.count[member] += val;\n\telse\n\t\tadd_mm_counter(mm, member, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_mm_rss",
          "args": [
            "mm"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "sync_mm_rss",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "144-155",
          "snippet": "void sync_mm_rss(struct mm_struct *mm)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_MM_COUNTERS; i++) {\n\t\tif (current->rss_stat.count[i]) {\n\t\t\tadd_mm_counter(mm, i, current->rss_stat.count[i]);\n\t\t\tcurrent->rss_stat.count[i] = 0;\n\t\t}\n\t}\n\tcurrent->rss_stat.events = 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid sync_mm_rss(struct mm_struct *mm)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_MM_COUNTERS; i++) {\n\t\tif (current->rss_stat.count[i]) {\n\t\t\tadd_mm_counter(mm, i, current->rss_stat.count[i]);\n\t\t\tcurrent->rss_stat.count[i] = 0;\n\t\t}\n\t}\n\tcurrent->rss_stat.events = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void add_mm_rss_vec(struct mm_struct *mm, int *rss)\n{\n\tint i;\n\n\tif (current->mm == mm)\n\t\tsync_mm_rss(mm);\n\tfor (i = 0; i < NR_MM_COUNTERS; i++)\n\t\tif (rss[i])\n\t\t\tadd_mm_counter(mm, i, rss[i]);\n}"
  },
  {
    "function_name": "init_rss_vec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "456-459",
    "snippet": "static inline void init_rss_vec(int *rss)\n{\n\tmemset(rss, 0, sizeof(int) * NR_MM_COUNTERS);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "rss",
            "0",
            "sizeof(int) * NR_MM_COUNTERS"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void init_rss_vec(int *rss)\n{\n\tmemset(rss, 0, sizeof(int) * NR_MM_COUNTERS);\n}"
  },
  {
    "function_name": "__pte_alloc_kernel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "437-454",
    "snippet": "int __pte_alloc_kernel(pmd_t *pmd, unsigned long address)\n{\n\tpte_t *new = pte_alloc_one_kernel(&init_mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&init_mm.page_table_lock);\n\tif (likely(pmd_none(*pmd))) {\t/* Has another populated it ? */\n\t\tpmd_populate_kernel(&init_mm, pmd, new);\n\t\tnew = NULL;\n\t}\n\tspin_unlock(&init_mm.page_table_lock);\n\tif (new)\n\t\tpte_free_kernel(&init_mm, new);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_free_kernel",
          "args": [
            "&init_mm",
            "new"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&init_mm.page_table_lock"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_populate_kernel",
          "args": [
            "&init_mm",
            "pmd",
            "new"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "pmd_none(*pmd)"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "*pmd"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&init_mm.page_table_lock"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_alloc_one_kernel",
          "args": [
            "&init_mm",
            "address"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pte_alloc_kernel(pmd_t *pmd, unsigned long address)\n{\n\tpte_t *new = pte_alloc_one_kernel(&init_mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&init_mm.page_table_lock);\n\tif (likely(pmd_none(*pmd))) {\t/* Has another populated it ? */\n\t\tpmd_populate_kernel(&init_mm, pmd, new);\n\t\tnew = NULL;\n\t}\n\tspin_unlock(&init_mm.page_table_lock);\n\tif (new)\n\t\tpte_free_kernel(&init_mm, new);\n\treturn 0;\n}"
  },
  {
    "function_name": "__pte_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "403-435",
    "snippet": "int __pte_alloc(struct mm_struct *mm, pmd_t *pmd, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpgtable_t new = pte_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Ensure all pte setup (eg. pte page lock and page clearing) are\n\t * visible before the pte is made visible to other CPUs by being\n\t * put into page tables.\n\t *\n\t * The other side of the story is the pointer chasing in the page\n\t * table walking code (when walking the page table without locking;\n\t * ie. most of the time). Fortunately, these data accesses consist\n\t * of a chain of data-dependent loads, meaning most CPUs (alpha\n\t * being the notable exception) will already guarantee loads are\n\t * seen in-order. See the alpha page table accessors for the\n\t * smp_read_barrier_depends() barriers in page table walking code.\n\t */\n\tsmp_wmb(); /* Could be smp_wmb__xxx(before|after)_spin_lock */\n\n\tptl = pmd_lock(mm, pmd);\n\tif (likely(pmd_none(*pmd))) {\t/* Has another populated it ? */\n\t\tmm_inc_nr_ptes(mm);\n\t\tpmd_populate(mm, pmd, new);\n\t\tnew = NULL;\n\t}\n\tspin_unlock(ptl);\n\tif (new)\n\t\tpte_free(mm, new);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_free",
          "args": [
            "mm",
            "new"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_populate",
          "args": [
            "mm",
            "pmd",
            "new"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "zero_pmd_populate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan_init.c",
          "lines": "105-135",
          "snippet": "static int __ref zero_pmd_populate(pud_t *pud, unsigned long addr,\n\t\t\t\tunsigned long end)\n{\n\tpmd_t *pmd = pmd_offset(pud, addr);\n\tunsigned long next;\n\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\n\t\tif (IS_ALIGNED(addr, PMD_SIZE) && end - addr >= PMD_SIZE) {\n\t\t\tpmd_populate_kernel(&init_mm, pmd, lm_alias(kasan_zero_pte));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pmd_none(*pmd)) {\n\t\t\tpte_t *p;\n\n\t\t\tif (slab_is_available())\n\t\t\t\tp = pte_alloc_one_kernel(&init_mm, addr);\n\t\t\telse\n\t\t\t\tp = early_alloc(PAGE_SIZE, NUMA_NO_NODE);\n\t\t\tif (!p)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tpmd_populate_kernel(&init_mm, pmd, p);\n\t\t}\n\t\tzero_pte_populate(pmd, addr, next);\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kasan.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/page.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/memblock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pte_t kasan_zero_pte[PTRS_PER_PTE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kasan.h\"\n#include <asm/pgalloc.h>\n#include <asm/page.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/memblock.h>\n\npte_t kasan_zero_pte[PTRS_PER_PTE];\n\nstatic int __ref zero_pmd_populate(pud_t *pud, unsigned long addr,\n\t\t\t\tunsigned long end)\n{\n\tpmd_t *pmd = pmd_offset(pud, addr);\n\tunsigned long next;\n\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\n\t\tif (IS_ALIGNED(addr, PMD_SIZE) && end - addr >= PMD_SIZE) {\n\t\t\tpmd_populate_kernel(&init_mm, pmd, lm_alias(kasan_zero_pte));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pmd_none(*pmd)) {\n\t\t\tpte_t *p;\n\n\t\t\tif (slab_is_available())\n\t\t\t\tp = pte_alloc_one_kernel(&init_mm, addr);\n\t\t\telse\n\t\t\t\tp = early_alloc(PAGE_SIZE, NUMA_NO_NODE);\n\t\t\tif (!p)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tpmd_populate_kernel(&init_mm, pmd, p);\n\t\t}\n\t\tzero_pte_populate(pmd, addr, next);\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_inc_nr_ptes",
          "args": [
            "mm"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "pmd_none(*pmd)"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "*pmd"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_lock",
          "args": [
            "mm",
            "pmd"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_alloc_one",
          "args": [
            "mm",
            "address"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pte_alloc(struct mm_struct *mm, pmd_t *pmd, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpgtable_t new = pte_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Ensure all pte setup (eg. pte page lock and page clearing) are\n\t * visible before the pte is made visible to other CPUs by being\n\t * put into page tables.\n\t *\n\t * The other side of the story is the pointer chasing in the page\n\t * table walking code (when walking the page table without locking;\n\t * ie. most of the time). Fortunately, these data accesses consist\n\t * of a chain of data-dependent loads, meaning most CPUs (alpha\n\t * being the notable exception) will already guarantee loads are\n\t * seen in-order. See the alpha page table accessors for the\n\t * smp_read_barrier_depends() barriers in page table walking code.\n\t */\n\tsmp_wmb(); /* Could be smp_wmb__xxx(before|after)_spin_lock */\n\n\tptl = pmd_lock(mm, pmd);\n\tif (likely(pmd_none(*pmd))) {\t/* Has another populated it ? */\n\t\tmm_inc_nr_ptes(mm);\n\t\tpmd_populate(mm, pmd, new);\n\t\tnew = NULL;\n\t}\n\tspin_unlock(ptl);\n\tif (new)\n\t\tpte_free(mm, new);\n\treturn 0;\n}"
  },
  {
    "function_name": "free_pgtables",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "368-401",
    "snippet": "void free_pgtables(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\tunsigned long floor, unsigned long ceiling)\n{\n\twhile (vma) {\n\t\tstruct vm_area_struct *next = vma->vm_next;\n\t\tunsigned long addr = vma->vm_start;\n\n\t\t/*\n\t\t * Hide vma from rmap and truncate_pagecache before freeing\n\t\t * pgtables\n\t\t */\n\t\tunlink_anon_vmas(vma);\n\t\tunlink_file_vma(vma);\n\n\t\tif (is_vm_hugetlb_page(vma)) {\n\t\t\thugetlb_free_pgd_range(tlb, addr, vma->vm_end,\n\t\t\t\tfloor, next ? next->vm_start : ceiling);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Optimization: gather nearby vmas into one call down\n\t\t\t */\n\t\t\twhile (next && next->vm_start <= vma->vm_end + PMD_SIZE\n\t\t\t       && !is_vm_hugetlb_page(next)) {\n\t\t\t\tvma = next;\n\t\t\t\tnext = vma->vm_next;\n\t\t\t\tunlink_anon_vmas(vma);\n\t\t\t\tunlink_file_vma(vma);\n\t\t\t}\n\t\t\tfree_pgd_range(tlb, addr, vma->vm_end,\n\t\t\t\tfloor, next ? next->vm_start : ceiling);\n\t\t}\n\t\tvma = next;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pgd_range",
          "args": [
            "tlb",
            "addr",
            "vma->vm_end",
            "floor",
            "next ? next->vm_start : ceiling"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "free_pgd_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "306-366",
          "snippet": "void free_pgd_range(struct mmu_gather *tlb,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long floor, unsigned long ceiling)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\n\t/*\n\t * The next few lines have given us lots of grief...\n\t *\n\t * Why are we testing PMD* at this top level?  Because often\n\t * there will be no work to do at all, and we'd prefer not to\n\t * go all the way down to the bottom just to discover that.\n\t *\n\t * Why all these \"- 1\"s?  Because 0 represents both the bottom\n\t * of the address space and the top of it (using -1 for the\n\t * top wouldn't help much: the masks would do the wrong thing).\n\t * The rule is that addr 0 and floor 0 refer to the bottom of\n\t * the address space, but end 0 and ceiling 0 refer to the top\n\t * Comparisons need to use \"end - 1\" and \"ceiling - 1\" (though\n\t * that end 0 case should be mythical).\n\t *\n\t * Wherever addr is brought up or ceiling brought down, we must\n\t * be careful to reject \"the opposite 0\" before it confuses the\n\t * subsequent tests.  But what about where end is brought down\n\t * by PMD_SIZE below? no, end can't go down to 0 there.\n\t *\n\t * Whereas we round start (addr) and ceiling down, by different\n\t * masks at different levels, in order to test whether a table\n\t * now has no other vmas using it, so can be freed, we don't\n\t * bother to round floor or end up - the tests don't need that.\n\t */\n\n\taddr &= PMD_MASK;\n\tif (addr < floor) {\n\t\taddr += PMD_SIZE;\n\t\tif (!addr)\n\t\t\treturn;\n\t}\n\tif (ceiling) {\n\t\tceiling &= PMD_MASK;\n\t\tif (!ceiling)\n\t\t\treturn;\n\t}\n\tif (end - 1 > ceiling - 1)\n\t\tend -= PMD_SIZE;\n\tif (addr > end - 1)\n\t\treturn;\n\t/*\n\t * We add page table cache pages with PAGE_SIZE,\n\t * (see pte_free_tlb()), flush the tlb if we need\n\t */\n\ttlb_remove_check_page_size_change(tlb, PAGE_SIZE);\n\tpgd = pgd_offset(tlb->mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tfree_p4d_range(tlb, pgd, addr, next, floor, ceiling);\n\t} while (pgd++, addr = next, addr != end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid free_pgd_range(struct mmu_gather *tlb,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long floor, unsigned long ceiling)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\n\t/*\n\t * The next few lines have given us lots of grief...\n\t *\n\t * Why are we testing PMD* at this top level?  Because often\n\t * there will be no work to do at all, and we'd prefer not to\n\t * go all the way down to the bottom just to discover that.\n\t *\n\t * Why all these \"- 1\"s?  Because 0 represents both the bottom\n\t * of the address space and the top of it (using -1 for the\n\t * top wouldn't help much: the masks would do the wrong thing).\n\t * The rule is that addr 0 and floor 0 refer to the bottom of\n\t * the address space, but end 0 and ceiling 0 refer to the top\n\t * Comparisons need to use \"end - 1\" and \"ceiling - 1\" (though\n\t * that end 0 case should be mythical).\n\t *\n\t * Wherever addr is brought up or ceiling brought down, we must\n\t * be careful to reject \"the opposite 0\" before it confuses the\n\t * subsequent tests.  But what about where end is brought down\n\t * by PMD_SIZE below? no, end can't go down to 0 there.\n\t *\n\t * Whereas we round start (addr) and ceiling down, by different\n\t * masks at different levels, in order to test whether a table\n\t * now has no other vmas using it, so can be freed, we don't\n\t * bother to round floor or end up - the tests don't need that.\n\t */\n\n\taddr &= PMD_MASK;\n\tif (addr < floor) {\n\t\taddr += PMD_SIZE;\n\t\tif (!addr)\n\t\t\treturn;\n\t}\n\tif (ceiling) {\n\t\tceiling &= PMD_MASK;\n\t\tif (!ceiling)\n\t\t\treturn;\n\t}\n\tif (end - 1 > ceiling - 1)\n\t\tend -= PMD_SIZE;\n\tif (addr > end - 1)\n\t\treturn;\n\t/*\n\t * We add page table cache pages with PAGE_SIZE,\n\t * (see pte_free_tlb()), flush the tlb if we need\n\t */\n\ttlb_remove_check_page_size_change(tlb, PAGE_SIZE);\n\tpgd = pgd_offset(tlb->mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tfree_p4d_range(tlb, pgd, addr, next, floor, ceiling);\n\t} while (pgd++, addr = next, addr != end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink_file_vma",
          "args": [
            "vma"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_file_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "160-170",
          "snippet": "void unlink_file_vma(struct vm_area_struct *vma)\n{\n\tstruct file *file = vma->vm_file;\n\n\tif (file) {\n\t\tstruct address_space *mapping = file->f_mapping;\n\t\ti_mmap_lock_write(mapping);\n\t\t__remove_shared_vm_struct(vma, file, mapping);\n\t\ti_mmap_unlock_write(mapping);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid unlink_file_vma(struct vm_area_struct *vma)\n{\n\tstruct file *file = vma->vm_file;\n\n\tif (file) {\n\t\tstruct address_space *mapping = file->f_mapping;\n\t\ti_mmap_lock_write(mapping);\n\t\t__remove_shared_vm_struct(vma, file, mapping);\n\t\ti_mmap_unlock_write(mapping);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink_anon_vmas",
          "args": [
            "vma"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_anon_vmas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "376-421",
          "snippet": "void unlink_anon_vmas(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc, *next;\n\tstruct anon_vma *root = NULL;\n\n\t/*\n\t * Unlink each anon_vma chained to the VMA.  This list is ordered\n\t * from newest to oldest, ensuring the root anon_vma gets freed last.\n\t */\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_interval_tree_remove(avc, &anon_vma->rb_root);\n\n\t\t/*\n\t\t * Leave empty anon_vmas on the list - we'll need\n\t\t * to free them outside the lock.\n\t\t */\n\t\tif (RB_EMPTY_ROOT(&anon_vma->rb_root.rb_root)) {\n\t\t\tanon_vma->parent->degree--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n\tif (vma->anon_vma)\n\t\tvma->anon_vma->degree--;\n\tunlock_anon_vma_root(root);\n\n\t/*\n\t * Iterate the list once more, it now only contains empty and unlinked\n\t * anon_vmas, destroy them. Could not do before due to __put_anon_vma()\n\t * needing to write-acquire the anon_vma->root->rwsem.\n\t */\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\n\t\tVM_WARN_ON(anon_vma->degree);\n\t\tput_anon_vma(anon_vma);\n\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid unlink_anon_vmas(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc, *next;\n\tstruct anon_vma *root = NULL;\n\n\t/*\n\t * Unlink each anon_vma chained to the VMA.  This list is ordered\n\t * from newest to oldest, ensuring the root anon_vma gets freed last.\n\t */\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_interval_tree_remove(avc, &anon_vma->rb_root);\n\n\t\t/*\n\t\t * Leave empty anon_vmas on the list - we'll need\n\t\t * to free them outside the lock.\n\t\t */\n\t\tif (RB_EMPTY_ROOT(&anon_vma->rb_root.rb_root)) {\n\t\t\tanon_vma->parent->degree--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n\tif (vma->anon_vma)\n\t\tvma->anon_vma->degree--;\n\tunlock_anon_vma_root(root);\n\n\t/*\n\t * Iterate the list once more, it now only contains empty and unlinked\n\t * anon_vmas, destroy them. Could not do before due to __put_anon_vma()\n\t * needing to write-acquire the anon_vma->root->rwsem.\n\t */\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\n\t\tVM_WARN_ON(anon_vma->degree);\n\t\tput_anon_vma(anon_vma);\n\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "next"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_free_pgd_range",
          "args": [
            "tlb",
            "addr",
            "vma->vm_end",
            "floor",
            "next ? next->vm_start : ceiling"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid free_pgtables(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\tunsigned long floor, unsigned long ceiling)\n{\n\twhile (vma) {\n\t\tstruct vm_area_struct *next = vma->vm_next;\n\t\tunsigned long addr = vma->vm_start;\n\n\t\t/*\n\t\t * Hide vma from rmap and truncate_pagecache before freeing\n\t\t * pgtables\n\t\t */\n\t\tunlink_anon_vmas(vma);\n\t\tunlink_file_vma(vma);\n\n\t\tif (is_vm_hugetlb_page(vma)) {\n\t\t\thugetlb_free_pgd_range(tlb, addr, vma->vm_end,\n\t\t\t\tfloor, next ? next->vm_start : ceiling);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Optimization: gather nearby vmas into one call down\n\t\t\t */\n\t\t\twhile (next && next->vm_start <= vma->vm_end + PMD_SIZE\n\t\t\t       && !is_vm_hugetlb_page(next)) {\n\t\t\t\tvma = next;\n\t\t\t\tnext = vma->vm_next;\n\t\t\t\tunlink_anon_vmas(vma);\n\t\t\t\tunlink_file_vma(vma);\n\t\t\t}\n\t\t\tfree_pgd_range(tlb, addr, vma->vm_end,\n\t\t\t\tfloor, next ? next->vm_start : ceiling);\n\t\t}\n\t\tvma = next;\n\t}\n}"
  },
  {
    "function_name": "free_pgd_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "306-366",
    "snippet": "void free_pgd_range(struct mmu_gather *tlb,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long floor, unsigned long ceiling)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\n\t/*\n\t * The next few lines have given us lots of grief...\n\t *\n\t * Why are we testing PMD* at this top level?  Because often\n\t * there will be no work to do at all, and we'd prefer not to\n\t * go all the way down to the bottom just to discover that.\n\t *\n\t * Why all these \"- 1\"s?  Because 0 represents both the bottom\n\t * of the address space and the top of it (using -1 for the\n\t * top wouldn't help much: the masks would do the wrong thing).\n\t * The rule is that addr 0 and floor 0 refer to the bottom of\n\t * the address space, but end 0 and ceiling 0 refer to the top\n\t * Comparisons need to use \"end - 1\" and \"ceiling - 1\" (though\n\t * that end 0 case should be mythical).\n\t *\n\t * Wherever addr is brought up or ceiling brought down, we must\n\t * be careful to reject \"the opposite 0\" before it confuses the\n\t * subsequent tests.  But what about where end is brought down\n\t * by PMD_SIZE below? no, end can't go down to 0 there.\n\t *\n\t * Whereas we round start (addr) and ceiling down, by different\n\t * masks at different levels, in order to test whether a table\n\t * now has no other vmas using it, so can be freed, we don't\n\t * bother to round floor or end up - the tests don't need that.\n\t */\n\n\taddr &= PMD_MASK;\n\tif (addr < floor) {\n\t\taddr += PMD_SIZE;\n\t\tif (!addr)\n\t\t\treturn;\n\t}\n\tif (ceiling) {\n\t\tceiling &= PMD_MASK;\n\t\tif (!ceiling)\n\t\t\treturn;\n\t}\n\tif (end - 1 > ceiling - 1)\n\t\tend -= PMD_SIZE;\n\tif (addr > end - 1)\n\t\treturn;\n\t/*\n\t * We add page table cache pages with PAGE_SIZE,\n\t * (see pte_free_tlb()), flush the tlb if we need\n\t */\n\ttlb_remove_check_page_size_change(tlb, PAGE_SIZE);\n\tpgd = pgd_offset(tlb->mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tfree_p4d_range(tlb, pgd, addr, next, floor, ceiling);\n\t} while (pgd++, addr = next, addr != end);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_p4d_range",
          "args": [
            "tlb",
            "pgd",
            "addr",
            "next",
            "floor",
            "ceiling"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "free_p4d_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "270-301",
          "snippet": "static inline void free_p4d_range(struct mmu_gather *tlb, pgd_t *pgd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tunsigned long floor, unsigned long ceiling)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\tunsigned long start;\n\n\tstart = addr;\n\tp4d = p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none_or_clear_bad(p4d))\n\t\t\tcontinue;\n\t\tfree_pud_range(tlb, p4d, addr, next, floor, ceiling);\n\t} while (p4d++, addr = next, addr != end);\n\n\tstart &= PGDIR_MASK;\n\tif (start < floor)\n\t\treturn;\n\tif (ceiling) {\n\t\tceiling &= PGDIR_MASK;\n\t\tif (!ceiling)\n\t\t\treturn;\n\t}\n\tif (end - 1 > ceiling - 1)\n\t\treturn;\n\n\tp4d = p4d_offset(pgd, start);\n\tpgd_clear(pgd);\n\tp4d_free_tlb(tlb, p4d, start);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void free_p4d_range(struct mmu_gather *tlb, pgd_t *pgd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tunsigned long floor, unsigned long ceiling)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\tunsigned long start;\n\n\tstart = addr;\n\tp4d = p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none_or_clear_bad(p4d))\n\t\t\tcontinue;\n\t\tfree_pud_range(tlb, p4d, addr, next, floor, ceiling);\n\t} while (p4d++, addr = next, addr != end);\n\n\tstart &= PGDIR_MASK;\n\tif (start < floor)\n\t\treturn;\n\tif (ceiling) {\n\t\tceiling &= PGDIR_MASK;\n\t\tif (!ceiling)\n\t\t\treturn;\n\t}\n\tif (end - 1 > ceiling - 1)\n\t\treturn;\n\n\tp4d = p4d_offset(pgd, start);\n\tpgd_clear(pgd);\n\tp4d_free_tlb(tlb, p4d, start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgd_none_or_clear_bad",
          "args": [
            "pgd"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_offset",
          "args": [
            "tlb->mm",
            "addr"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlb_remove_check_page_size_change",
          "args": [
            "tlb",
            "PAGE_SIZE"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid free_pgd_range(struct mmu_gather *tlb,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long floor, unsigned long ceiling)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\n\t/*\n\t * The next few lines have given us lots of grief...\n\t *\n\t * Why are we testing PMD* at this top level?  Because often\n\t * there will be no work to do at all, and we'd prefer not to\n\t * go all the way down to the bottom just to discover that.\n\t *\n\t * Why all these \"- 1\"s?  Because 0 represents both the bottom\n\t * of the address space and the top of it (using -1 for the\n\t * top wouldn't help much: the masks would do the wrong thing).\n\t * The rule is that addr 0 and floor 0 refer to the bottom of\n\t * the address space, but end 0 and ceiling 0 refer to the top\n\t * Comparisons need to use \"end - 1\" and \"ceiling - 1\" (though\n\t * that end 0 case should be mythical).\n\t *\n\t * Wherever addr is brought up or ceiling brought down, we must\n\t * be careful to reject \"the opposite 0\" before it confuses the\n\t * subsequent tests.  But what about where end is brought down\n\t * by PMD_SIZE below? no, end can't go down to 0 there.\n\t *\n\t * Whereas we round start (addr) and ceiling down, by different\n\t * masks at different levels, in order to test whether a table\n\t * now has no other vmas using it, so can be freed, we don't\n\t * bother to round floor or end up - the tests don't need that.\n\t */\n\n\taddr &= PMD_MASK;\n\tif (addr < floor) {\n\t\taddr += PMD_SIZE;\n\t\tif (!addr)\n\t\t\treturn;\n\t}\n\tif (ceiling) {\n\t\tceiling &= PMD_MASK;\n\t\tif (!ceiling)\n\t\t\treturn;\n\t}\n\tif (end - 1 > ceiling - 1)\n\t\tend -= PMD_SIZE;\n\tif (addr > end - 1)\n\t\treturn;\n\t/*\n\t * We add page table cache pages with PAGE_SIZE,\n\t * (see pte_free_tlb()), flush the tlb if we need\n\t */\n\ttlb_remove_check_page_size_change(tlb, PAGE_SIZE);\n\tpgd = pgd_offset(tlb->mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tfree_p4d_range(tlb, pgd, addr, next, floor, ceiling);\n\t} while (pgd++, addr = next, addr != end);\n}"
  },
  {
    "function_name": "free_p4d_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "270-301",
    "snippet": "static inline void free_p4d_range(struct mmu_gather *tlb, pgd_t *pgd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tunsigned long floor, unsigned long ceiling)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\tunsigned long start;\n\n\tstart = addr;\n\tp4d = p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none_or_clear_bad(p4d))\n\t\t\tcontinue;\n\t\tfree_pud_range(tlb, p4d, addr, next, floor, ceiling);\n\t} while (p4d++, addr = next, addr != end);\n\n\tstart &= PGDIR_MASK;\n\tif (start < floor)\n\t\treturn;\n\tif (ceiling) {\n\t\tceiling &= PGDIR_MASK;\n\t\tif (!ceiling)\n\t\t\treturn;\n\t}\n\tif (end - 1 > ceiling - 1)\n\t\treturn;\n\n\tp4d = p4d_offset(pgd, start);\n\tpgd_clear(pgd);\n\tp4d_free_tlb(tlb, p4d, start);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p4d_free_tlb",
          "args": [
            "tlb",
            "p4d",
            "start"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_clear",
          "args": [
            "pgd"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "pgd_clear_bad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "21-25",
          "snippet": "void pgd_clear_bad(pgd_t *pgd)\n{\n\tpgd_ERROR(*pgd);\n\tpgd_clear(pgd);\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\nvoid pgd_clear_bad(pgd_t *pgd)\n{\n\tpgd_ERROR(*pgd);\n\tpgd_clear(pgd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p4d_offset",
          "args": [
            "pgd",
            "start"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pud_range",
          "args": [
            "tlb",
            "p4d",
            "addr",
            "next",
            "floor",
            "ceiling"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "free_pud_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "236-268",
          "snippet": "static inline void free_pud_range(struct mmu_gather *tlb, p4d_t *p4d,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tunsigned long floor, unsigned long ceiling)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tunsigned long start;\n\n\tstart = addr;\n\tpud = pud_offset(p4d, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none_or_clear_bad(pud))\n\t\t\tcontinue;\n\t\tfree_pmd_range(tlb, pud, addr, next, floor, ceiling);\n\t} while (pud++, addr = next, addr != end);\n\n\tstart &= P4D_MASK;\n\tif (start < floor)\n\t\treturn;\n\tif (ceiling) {\n\t\tceiling &= P4D_MASK;\n\t\tif (!ceiling)\n\t\t\treturn;\n\t}\n\tif (end - 1 > ceiling - 1)\n\t\treturn;\n\n\tpud = pud_offset(p4d, start);\n\tp4d_clear(p4d);\n\tpud_free_tlb(tlb, pud, start);\n\tmm_dec_nr_puds(tlb->mm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void free_pud_range(struct mmu_gather *tlb, p4d_t *p4d,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tunsigned long floor, unsigned long ceiling)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tunsigned long start;\n\n\tstart = addr;\n\tpud = pud_offset(p4d, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none_or_clear_bad(pud))\n\t\t\tcontinue;\n\t\tfree_pmd_range(tlb, pud, addr, next, floor, ceiling);\n\t} while (pud++, addr = next, addr != end);\n\n\tstart &= P4D_MASK;\n\tif (start < floor)\n\t\treturn;\n\tif (ceiling) {\n\t\tceiling &= P4D_MASK;\n\t\tif (!ceiling)\n\t\t\treturn;\n\t}\n\tif (end - 1 > ceiling - 1)\n\t\treturn;\n\n\tpud = pud_offset(p4d, start);\n\tp4d_clear(p4d);\n\tpud_free_tlb(tlb, pud, start);\n\tmm_dec_nr_puds(tlb->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p4d_none_or_clear_bad",
          "args": [
            "p4d"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_offset",
          "args": [
            "pgd",
            "addr"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void free_p4d_range(struct mmu_gather *tlb, pgd_t *pgd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tunsigned long floor, unsigned long ceiling)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\tunsigned long start;\n\n\tstart = addr;\n\tp4d = p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none_or_clear_bad(p4d))\n\t\t\tcontinue;\n\t\tfree_pud_range(tlb, p4d, addr, next, floor, ceiling);\n\t} while (p4d++, addr = next, addr != end);\n\n\tstart &= PGDIR_MASK;\n\tif (start < floor)\n\t\treturn;\n\tif (ceiling) {\n\t\tceiling &= PGDIR_MASK;\n\t\tif (!ceiling)\n\t\t\treturn;\n\t}\n\tif (end - 1 > ceiling - 1)\n\t\treturn;\n\n\tp4d = p4d_offset(pgd, start);\n\tpgd_clear(pgd);\n\tp4d_free_tlb(tlb, p4d, start);\n}"
  },
  {
    "function_name": "free_pud_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "236-268",
    "snippet": "static inline void free_pud_range(struct mmu_gather *tlb, p4d_t *p4d,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tunsigned long floor, unsigned long ceiling)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tunsigned long start;\n\n\tstart = addr;\n\tpud = pud_offset(p4d, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none_or_clear_bad(pud))\n\t\t\tcontinue;\n\t\tfree_pmd_range(tlb, pud, addr, next, floor, ceiling);\n\t} while (pud++, addr = next, addr != end);\n\n\tstart &= P4D_MASK;\n\tif (start < floor)\n\t\treturn;\n\tif (ceiling) {\n\t\tceiling &= P4D_MASK;\n\t\tif (!ceiling)\n\t\t\treturn;\n\t}\n\tif (end - 1 > ceiling - 1)\n\t\treturn;\n\n\tpud = pud_offset(p4d, start);\n\tp4d_clear(p4d);\n\tpud_free_tlb(tlb, pud, start);\n\tmm_dec_nr_puds(tlb->mm);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mm_dec_nr_puds",
          "args": [
            "tlb->mm"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_free_tlb",
          "args": [
            "tlb",
            "pud",
            "start"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_clear",
          "args": [
            "p4d"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "p4d_clear_bad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "27-31",
          "snippet": "void p4d_clear_bad(p4d_t *p4d)\n{\n\tp4d_ERROR(*p4d);\n\tp4d_clear(p4d);\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\nvoid p4d_clear_bad(p4d_t *p4d)\n{\n\tp4d_ERROR(*p4d);\n\tp4d_clear(p4d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pud_offset",
          "args": [
            "p4d",
            "start"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pmd_range",
          "args": [
            "tlb",
            "pud",
            "addr",
            "next",
            "floor",
            "ceiling"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "free_pmd_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "202-234",
          "snippet": "static inline void free_pmd_range(struct mmu_gather *tlb, pud_t *pud,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tunsigned long floor, unsigned long ceiling)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tunsigned long start;\n\n\tstart = addr;\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_none_or_clear_bad(pmd))\n\t\t\tcontinue;\n\t\tfree_pte_range(tlb, pmd, addr);\n\t} while (pmd++, addr = next, addr != end);\n\n\tstart &= PUD_MASK;\n\tif (start < floor)\n\t\treturn;\n\tif (ceiling) {\n\t\tceiling &= PUD_MASK;\n\t\tif (!ceiling)\n\t\t\treturn;\n\t}\n\tif (end - 1 > ceiling - 1)\n\t\treturn;\n\n\tpmd = pmd_offset(pud, start);\n\tpud_clear(pud);\n\tpmd_free_tlb(tlb, pmd, start);\n\tmm_dec_nr_pmds(tlb->mm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void free_pmd_range(struct mmu_gather *tlb, pud_t *pud,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tunsigned long floor, unsigned long ceiling)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tunsigned long start;\n\n\tstart = addr;\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_none_or_clear_bad(pmd))\n\t\t\tcontinue;\n\t\tfree_pte_range(tlb, pmd, addr);\n\t} while (pmd++, addr = next, addr != end);\n\n\tstart &= PUD_MASK;\n\tif (start < floor)\n\t\treturn;\n\tif (ceiling) {\n\t\tceiling &= PUD_MASK;\n\t\tif (!ceiling)\n\t\t\treturn;\n\t}\n\tif (end - 1 > ceiling - 1)\n\t\treturn;\n\n\tpmd = pmd_offset(pud, start);\n\tpud_clear(pud);\n\tpmd_free_tlb(tlb, pmd, start);\n\tmm_dec_nr_pmds(tlb->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pud_none_or_clear_bad",
          "args": [
            "pud"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_offset",
          "args": [
            "p4d",
            "addr"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void free_pud_range(struct mmu_gather *tlb, p4d_t *p4d,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tunsigned long floor, unsigned long ceiling)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tunsigned long start;\n\n\tstart = addr;\n\tpud = pud_offset(p4d, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none_or_clear_bad(pud))\n\t\t\tcontinue;\n\t\tfree_pmd_range(tlb, pud, addr, next, floor, ceiling);\n\t} while (pud++, addr = next, addr != end);\n\n\tstart &= P4D_MASK;\n\tif (start < floor)\n\t\treturn;\n\tif (ceiling) {\n\t\tceiling &= P4D_MASK;\n\t\tif (!ceiling)\n\t\t\treturn;\n\t}\n\tif (end - 1 > ceiling - 1)\n\t\treturn;\n\n\tpud = pud_offset(p4d, start);\n\tp4d_clear(p4d);\n\tpud_free_tlb(tlb, pud, start);\n\tmm_dec_nr_puds(tlb->mm);\n}"
  },
  {
    "function_name": "free_pmd_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "202-234",
    "snippet": "static inline void free_pmd_range(struct mmu_gather *tlb, pud_t *pud,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tunsigned long floor, unsigned long ceiling)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tunsigned long start;\n\n\tstart = addr;\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_none_or_clear_bad(pmd))\n\t\t\tcontinue;\n\t\tfree_pte_range(tlb, pmd, addr);\n\t} while (pmd++, addr = next, addr != end);\n\n\tstart &= PUD_MASK;\n\tif (start < floor)\n\t\treturn;\n\tif (ceiling) {\n\t\tceiling &= PUD_MASK;\n\t\tif (!ceiling)\n\t\t\treturn;\n\t}\n\tif (end - 1 > ceiling - 1)\n\t\treturn;\n\n\tpmd = pmd_offset(pud, start);\n\tpud_clear(pud);\n\tpmd_free_tlb(tlb, pmd, start);\n\tmm_dec_nr_pmds(tlb->mm);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mm_dec_nr_pmds",
          "args": [
            "tlb->mm"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_free_tlb",
          "args": [
            "tlb",
            "pmd",
            "start"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_clear",
          "args": [
            "pud"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "pud_clear_bad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "33-37",
          "snippet": "void pud_clear_bad(pud_t *pud)\n{\n\tpud_ERROR(*pud);\n\tpud_clear(pud);\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\nvoid pud_clear_bad(pud_t *pud)\n{\n\tpud_ERROR(*pud);\n\tpud_clear(pud);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_offset",
          "args": [
            "pud",
            "start"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pte_range",
          "args": [
            "tlb",
            "pmd",
            "addr"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "free_pte_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "193-200",
          "snippet": "static void free_pte_range(struct mmu_gather *tlb, pmd_t *pmd,\n\t\t\t   unsigned long addr)\n{\n\tpgtable_t token = pmd_pgtable(*pmd);\n\tpmd_clear(pmd);\n\tpte_free_tlb(tlb, token, addr);\n\tmm_dec_nr_ptes(tlb->mm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void free_pte_range(struct mmu_gather *tlb, pmd_t *pmd,\n\t\t\t   unsigned long addr)\n{\n\tpgtable_t token = pmd_pgtable(*pmd);\n\tpmd_clear(pmd);\n\tpte_free_tlb(tlb, token, addr);\n\tmm_dec_nr_ptes(tlb->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_none_or_clear_bad",
          "args": [
            "pmd"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_offset",
          "args": [
            "pud",
            "addr"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void free_pmd_range(struct mmu_gather *tlb, pud_t *pud,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tunsigned long floor, unsigned long ceiling)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tunsigned long start;\n\n\tstart = addr;\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_none_or_clear_bad(pmd))\n\t\t\tcontinue;\n\t\tfree_pte_range(tlb, pmd, addr);\n\t} while (pmd++, addr = next, addr != end);\n\n\tstart &= PUD_MASK;\n\tif (start < floor)\n\t\treturn;\n\tif (ceiling) {\n\t\tceiling &= PUD_MASK;\n\t\tif (!ceiling)\n\t\t\treturn;\n\t}\n\tif (end - 1 > ceiling - 1)\n\t\treturn;\n\n\tpmd = pmd_offset(pud, start);\n\tpud_clear(pud);\n\tpmd_free_tlb(tlb, pmd, start);\n\tmm_dec_nr_pmds(tlb->mm);\n}"
  },
  {
    "function_name": "free_pte_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "193-200",
    "snippet": "static void free_pte_range(struct mmu_gather *tlb, pmd_t *pmd,\n\t\t\t   unsigned long addr)\n{\n\tpgtable_t token = pmd_pgtable(*pmd);\n\tpmd_clear(pmd);\n\tpte_free_tlb(tlb, token, addr);\n\tmm_dec_nr_ptes(tlb->mm);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mm_dec_nr_ptes",
          "args": [
            "tlb->mm"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_free_tlb",
          "args": [
            "tlb",
            "token",
            "addr"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_clear",
          "args": [
            "pmd"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "pmd_clear_bad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "39-43",
          "snippet": "void pmd_clear_bad(pmd_t *pmd)\n{\n\tpmd_ERROR(*pmd);\n\tpmd_clear(pmd);\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\nvoid pmd_clear_bad(pmd_t *pmd)\n{\n\tpmd_ERROR(*pmd);\n\tpmd_clear(pmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_pgtable",
          "args": [
            "*pmd"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void free_pte_range(struct mmu_gather *tlb, pmd_t *pmd,\n\t\t\t   unsigned long addr)\n{\n\tpgtable_t token = pmd_pgtable(*pmd);\n\tpmd_clear(pmd);\n\tpte_free_tlb(tlb, token, addr);\n\tmm_dec_nr_ptes(tlb->mm);\n}"
  },
  {
    "function_name": "check_sync_rss_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "183-185",
    "snippet": "static void check_sync_rss_stat(struct task_struct *task)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void check_sync_rss_stat(struct task_struct *task)\n{\n}"
  },
  {
    "function_name": "check_sync_rss_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "171-177",
    "snippet": "static void check_sync_rss_stat(struct task_struct *task)\n{\n\tif (unlikely(task != current))\n\t\treturn;\n\tif (unlikely(task->rss_stat.events++ > TASK_RSS_EVENTS_THRESH))\n\t\tsync_mm_rss(task->mm);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [
      "#define TASK_RSS_EVENTS_THRESH\t(64)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_mm_rss",
          "args": [
            "task->mm"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "sync_mm_rss",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "144-155",
          "snippet": "void sync_mm_rss(struct mm_struct *mm)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_MM_COUNTERS; i++) {\n\t\tif (current->rss_stat.count[i]) {\n\t\t\tadd_mm_counter(mm, i, current->rss_stat.count[i]);\n\t\t\tcurrent->rss_stat.count[i] = 0;\n\t\t}\n\t}\n\tcurrent->rss_stat.events = 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid sync_mm_rss(struct mm_struct *mm)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_MM_COUNTERS; i++) {\n\t\tif (current->rss_stat.count[i]) {\n\t\t\tadd_mm_counter(mm, i, current->rss_stat.count[i]);\n\t\t\tcurrent->rss_stat.count[i] = 0;\n\t\t}\n\t}\n\tcurrent->rss_stat.events = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "task->rss_stat.events++ > TASK_RSS_EVENTS_THRESH"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "task != current"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\n#define TASK_RSS_EVENTS_THRESH\t(64)\n\nstatic void check_sync_rss_stat(struct task_struct *task)\n{\n\tif (unlikely(task != current))\n\t\treturn;\n\tif (unlikely(task->rss_stat.events++ > TASK_RSS_EVENTS_THRESH))\n\t\tsync_mm_rss(task->mm);\n}"
  },
  {
    "function_name": "add_mm_counter_fast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "157-165",
    "snippet": "static void add_mm_counter_fast(struct mm_struct *mm, int member, int val)\n{\n\tstruct task_struct *task = current;\n\n\tif (likely(task->mm == mm))\n\t\ttask->rss_stat.count[member] += val;\n\telse\n\t\tadd_mm_counter(mm, member, val);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_mm_counter",
          "args": [
            "mm",
            "member",
            "val"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "add_mm_counter_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "157-165",
          "snippet": "static void add_mm_counter_fast(struct mm_struct *mm, int member, int val)\n{\n\tstruct task_struct *task = current;\n\n\tif (likely(task->mm == mm))\n\t\ttask->rss_stat.count[member] += val;\n\telse\n\t\tadd_mm_counter(mm, member, val);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "task->mm == mm"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void add_mm_counter_fast(struct mm_struct *mm, int member, int val)\n{\n\tstruct task_struct *task = current;\n\n\tif (likely(task->mm == mm))\n\t\ttask->rss_stat.count[member] += val;\n\telse\n\t\tadd_mm_counter(mm, member, val);\n}"
  },
  {
    "function_name": "sync_mm_rss",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "144-155",
    "snippet": "void sync_mm_rss(struct mm_struct *mm)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_MM_COUNTERS; i++) {\n\t\tif (current->rss_stat.count[i]) {\n\t\t\tadd_mm_counter(mm, i, current->rss_stat.count[i]);\n\t\t\tcurrent->rss_stat.count[i] = 0;\n\t\t}\n\t}\n\tcurrent->rss_stat.events = 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_mm_counter",
          "args": [
            "mm",
            "i",
            "current->rss_stat.count[i]"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "add_mm_counter_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "157-165",
          "snippet": "static void add_mm_counter_fast(struct mm_struct *mm, int member, int val)\n{\n\tstruct task_struct *task = current;\n\n\tif (likely(task->mm == mm))\n\t\ttask->rss_stat.count[member] += val;\n\telse\n\t\tadd_mm_counter(mm, member, val);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void add_mm_counter_fast(struct mm_struct *mm, int member, int val)\n{\n\tstruct task_struct *task = current;\n\n\tif (likely(task->mm == mm))\n\t\ttask->rss_stat.count[member] += val;\n\telse\n\t\tadd_mm_counter(mm, member, val);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid sync_mm_rss(struct mm_struct *mm)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_MM_COUNTERS; i++) {\n\t\tif (current->rss_stat.count[i]) {\n\t\t\tadd_mm_counter(mm, i, current->rss_stat.count[i]);\n\t\t\tcurrent->rss_stat.count[i] = 0;\n\t\t}\n\t}\n\tcurrent->rss_stat.events = 0;\n}"
  },
  {
    "function_name": "init_zero_pfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "134-138",
    "snippet": "static int __init init_zero_pfn(void)\n{\n\tzero_pfn = page_to_pfn(ZERO_PAGE(0));\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "ZERO_PAGE(0)"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_PAGE",
          "args": [
            "0"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int __init init_zero_pfn(void)\n{\n\tzero_pfn = page_to_pfn(ZERO_PAGE(0));\n\treturn 0;\n}"
  },
  {
    "function_name": "disable_randmaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
    "lines": "119-123",
    "snippet": "static int __init disable_randmaps(char *s)\n{\n\trandomize_va_space = 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/tlb.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/pgalloc.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/io.h>",
      "#include <linux/oom.h>",
      "#include <linux/dax.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/string.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/elf.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/init.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int randomize_va_space"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint randomize_va_space;\n\nstatic int __init disable_randmaps(char *s)\n{\n\trandomize_va_space = 0;\n\treturn 1;\n}"
  }
]