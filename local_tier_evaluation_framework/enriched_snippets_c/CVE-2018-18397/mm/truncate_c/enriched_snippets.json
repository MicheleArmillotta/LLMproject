[
  {
    "function_name": "truncate_pagecache_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
    "lines": "895-917",
    "snippet": "void truncate_pagecache_range(struct inode *inode, loff_t lstart, loff_t lend)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t unmap_start = round_up(lstart, PAGE_SIZE);\n\tloff_t unmap_end = round_down(1 + lend, PAGE_SIZE) - 1;\n\t/*\n\t * This rounding is currently just for example: unmap_mapping_range\n\t * expands its hole outwards, whereas we want it to contract the hole\n\t * inwards.  However, existing callers of truncate_pagecache_range are\n\t * doing their own page rounding first.  Note that unmap_mapping_range\n\t * allows holelen 0 for all, and we allow lend -1 for end of file.\n\t */\n\n\t/*\n\t * Unlike in truncate_pagecache, unmap_mapping_range is called only\n\t * once (before truncating pagecache), and without \"even_cows\" flag:\n\t * hole-punching should not remove private COWed pages from the hole.\n\t */\n\tif ((u64)unmap_end > (u64)unmap_start)\n\t\tunmap_mapping_range(mapping, unmap_start,\n\t\t\t\t    1 + unmap_end - unmap_start, 0);\n\ttruncate_inode_pages_range(mapping, lstart, lend);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/rmap.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truncate_inode_pages_range",
          "args": [
            "mapping",
            "lstart",
            "lend"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_inode_pages_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "290-458",
          "snippet": "void truncate_inode_pages_range(struct address_space *mapping,\n\t\t\t\tloff_t lstart, loff_t lend)\n{\n\tpgoff_t\t\tstart;\t\t/* inclusive */\n\tpgoff_t\t\tend;\t\t/* exclusive */\n\tunsigned int\tpartial_start;\t/* inclusive */\n\tunsigned int\tpartial_end;\t/* exclusive */\n\tstruct pagevec\tpvec;\n\tpgoff_t\t\tindices[PAGEVEC_SIZE];\n\tpgoff_t\t\tindex;\n\tint\t\ti;\n\n\tif (mapping->nrpages == 0 && mapping->nrexceptional == 0)\n\t\tgoto out;\n\n\t/* Offsets within partial pages */\n\tpartial_start = lstart & (PAGE_SIZE - 1);\n\tpartial_end = (lend + 1) & (PAGE_SIZE - 1);\n\n\t/*\n\t * 'start' and 'end' always covers the range of pages to be fully\n\t * truncated. Partial pages are covered with 'partial_start' at the\n\t * start of the range and 'partial_end' at the end of the range.\n\t * Note that 'end' is exclusive while 'lend' is inclusive.\n\t */\n\tstart = (lstart + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (lend == -1)\n\t\t/*\n\t\t * lend == -1 indicates end-of-file so we have to set 'end'\n\t\t * to the highest possible pgoff_t and since the type is\n\t\t * unsigned we're using -1.\n\t\t */\n\t\tend = -1;\n\telse\n\t\tend = (lend + 1) >> PAGE_SHIFT;\n\n\tpagevec_init(&pvec);\n\tindex = start;\n\twhile (index < end && pagevec_lookup_entries(&pvec, mapping, index,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE),\n\t\t\tindices)) {\n\t\t/*\n\t\t * Pagevec array has exceptional entries and we may also fail\n\t\t * to lock some pages. So we store pages that can be deleted\n\t\t * in a new pagevec.\n\t\t */\n\t\tstruct pagevec locked_pvec;\n\n\t\tpagevec_init(&locked_pvec);\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* We rely upon deletion not changing page->index */\n\t\t\tindex = indices[i];\n\t\t\tif (index >= end)\n\t\t\t\tbreak;\n\n\t\t\tif (xa_is_value(page))\n\t\t\t\tcontinue;\n\n\t\t\tif (!trylock_page(page))\n\t\t\t\tcontinue;\n\t\t\tWARN_ON(page_to_index(page) != index);\n\t\t\tif (PageWriteback(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (page->mapping != mapping) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpagevec_add(&locked_pvec, page);\n\t\t}\n\t\tfor (i = 0; i < pagevec_count(&locked_pvec); i++)\n\t\t\ttruncate_cleanup_page(mapping, locked_pvec.pages[i]);\n\t\tdelete_from_page_cache_batch(mapping, &locked_pvec);\n\t\tfor (i = 0; i < pagevec_count(&locked_pvec); i++)\n\t\t\tunlock_page(locked_pvec.pages[i]);\n\t\ttruncate_exceptional_pvec_entries(mapping, &pvec, indices, end);\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t\tindex++;\n\t}\n\tif (partial_start) {\n\t\tstruct page *page = find_lock_page(mapping, start - 1);\n\t\tif (page) {\n\t\t\tunsigned int top = PAGE_SIZE;\n\t\t\tif (start > end) {\n\t\t\t\t/* Truncation within a single page */\n\t\t\t\ttop = partial_end;\n\t\t\t\tpartial_end = 0;\n\t\t\t}\n\t\t\twait_on_page_writeback(page);\n\t\t\tzero_user_segment(page, partial_start, top);\n\t\t\tcleancache_invalidate_page(mapping, page);\n\t\t\tif (page_has_private(page))\n\t\t\t\tdo_invalidatepage(page, partial_start,\n\t\t\t\t\t\t  top - partial_start);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t}\n\t}\n\tif (partial_end) {\n\t\tstruct page *page = find_lock_page(mapping, end);\n\t\tif (page) {\n\t\t\twait_on_page_writeback(page);\n\t\t\tzero_user_segment(page, 0, partial_end);\n\t\t\tcleancache_invalidate_page(mapping, page);\n\t\t\tif (page_has_private(page))\n\t\t\t\tdo_invalidatepage(page, 0,\n\t\t\t\t\t\t  partial_end);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t}\n\t}\n\t/*\n\t * If the truncation happened within a single page no pages\n\t * will be released, just zeroed, so we can bail out now.\n\t */\n\tif (start >= end)\n\t\tgoto out;\n\n\tindex = start;\n\tfor ( ; ; ) {\n\t\tcond_resched();\n\t\tif (!pagevec_lookup_entries(&pvec, mapping, index,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE), indices)) {\n\t\t\t/* If all gone from start onwards, we're done */\n\t\t\tif (index == start)\n\t\t\t\tbreak;\n\t\t\t/* Otherwise restart to make sure all gone */\n\t\t\tindex = start;\n\t\t\tcontinue;\n\t\t}\n\t\tif (index == start && indices[0] >= end) {\n\t\t\t/* All gone out of hole to be punched, we're done */\n\t\t\tpagevec_remove_exceptionals(&pvec);\n\t\t\tpagevec_release(&pvec);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* We rely upon deletion not changing page->index */\n\t\t\tindex = indices[i];\n\t\t\tif (index >= end) {\n\t\t\t\t/* Restart punch to make sure all gone */\n\t\t\t\tindex = start - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (xa_is_value(page))\n\t\t\t\tcontinue;\n\n\t\t\tlock_page(page);\n\t\t\tWARN_ON(page_to_index(page) != index);\n\t\t\twait_on_page_writeback(page);\n\t\t\ttruncate_inode_page(mapping, page);\n\t\t\tunlock_page(page);\n\t\t}\n\t\ttruncate_exceptional_pvec_entries(mapping, &pvec, indices, end);\n\t\tpagevec_release(&pvec);\n\t\tindex++;\n\t}\n\nout:\n\tcleancache_invalidate_inode(mapping);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nvoid truncate_inode_pages_range(struct address_space *mapping,\n\t\t\t\tloff_t lstart, loff_t lend)\n{\n\tpgoff_t\t\tstart;\t\t/* inclusive */\n\tpgoff_t\t\tend;\t\t/* exclusive */\n\tunsigned int\tpartial_start;\t/* inclusive */\n\tunsigned int\tpartial_end;\t/* exclusive */\n\tstruct pagevec\tpvec;\n\tpgoff_t\t\tindices[PAGEVEC_SIZE];\n\tpgoff_t\t\tindex;\n\tint\t\ti;\n\n\tif (mapping->nrpages == 0 && mapping->nrexceptional == 0)\n\t\tgoto out;\n\n\t/* Offsets within partial pages */\n\tpartial_start = lstart & (PAGE_SIZE - 1);\n\tpartial_end = (lend + 1) & (PAGE_SIZE - 1);\n\n\t/*\n\t * 'start' and 'end' always covers the range of pages to be fully\n\t * truncated. Partial pages are covered with 'partial_start' at the\n\t * start of the range and 'partial_end' at the end of the range.\n\t * Note that 'end' is exclusive while 'lend' is inclusive.\n\t */\n\tstart = (lstart + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (lend == -1)\n\t\t/*\n\t\t * lend == -1 indicates end-of-file so we have to set 'end'\n\t\t * to the highest possible pgoff_t and since the type is\n\t\t * unsigned we're using -1.\n\t\t */\n\t\tend = -1;\n\telse\n\t\tend = (lend + 1) >> PAGE_SHIFT;\n\n\tpagevec_init(&pvec);\n\tindex = start;\n\twhile (index < end && pagevec_lookup_entries(&pvec, mapping, index,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE),\n\t\t\tindices)) {\n\t\t/*\n\t\t * Pagevec array has exceptional entries and we may also fail\n\t\t * to lock some pages. So we store pages that can be deleted\n\t\t * in a new pagevec.\n\t\t */\n\t\tstruct pagevec locked_pvec;\n\n\t\tpagevec_init(&locked_pvec);\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* We rely upon deletion not changing page->index */\n\t\t\tindex = indices[i];\n\t\t\tif (index >= end)\n\t\t\t\tbreak;\n\n\t\t\tif (xa_is_value(page))\n\t\t\t\tcontinue;\n\n\t\t\tif (!trylock_page(page))\n\t\t\t\tcontinue;\n\t\t\tWARN_ON(page_to_index(page) != index);\n\t\t\tif (PageWriteback(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (page->mapping != mapping) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpagevec_add(&locked_pvec, page);\n\t\t}\n\t\tfor (i = 0; i < pagevec_count(&locked_pvec); i++)\n\t\t\ttruncate_cleanup_page(mapping, locked_pvec.pages[i]);\n\t\tdelete_from_page_cache_batch(mapping, &locked_pvec);\n\t\tfor (i = 0; i < pagevec_count(&locked_pvec); i++)\n\t\t\tunlock_page(locked_pvec.pages[i]);\n\t\ttruncate_exceptional_pvec_entries(mapping, &pvec, indices, end);\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t\tindex++;\n\t}\n\tif (partial_start) {\n\t\tstruct page *page = find_lock_page(mapping, start - 1);\n\t\tif (page) {\n\t\t\tunsigned int top = PAGE_SIZE;\n\t\t\tif (start > end) {\n\t\t\t\t/* Truncation within a single page */\n\t\t\t\ttop = partial_end;\n\t\t\t\tpartial_end = 0;\n\t\t\t}\n\t\t\twait_on_page_writeback(page);\n\t\t\tzero_user_segment(page, partial_start, top);\n\t\t\tcleancache_invalidate_page(mapping, page);\n\t\t\tif (page_has_private(page))\n\t\t\t\tdo_invalidatepage(page, partial_start,\n\t\t\t\t\t\t  top - partial_start);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t}\n\t}\n\tif (partial_end) {\n\t\tstruct page *page = find_lock_page(mapping, end);\n\t\tif (page) {\n\t\t\twait_on_page_writeback(page);\n\t\t\tzero_user_segment(page, 0, partial_end);\n\t\t\tcleancache_invalidate_page(mapping, page);\n\t\t\tif (page_has_private(page))\n\t\t\t\tdo_invalidatepage(page, 0,\n\t\t\t\t\t\t  partial_end);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t}\n\t}\n\t/*\n\t * If the truncation happened within a single page no pages\n\t * will be released, just zeroed, so we can bail out now.\n\t */\n\tif (start >= end)\n\t\tgoto out;\n\n\tindex = start;\n\tfor ( ; ; ) {\n\t\tcond_resched();\n\t\tif (!pagevec_lookup_entries(&pvec, mapping, index,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE), indices)) {\n\t\t\t/* If all gone from start onwards, we're done */\n\t\t\tif (index == start)\n\t\t\t\tbreak;\n\t\t\t/* Otherwise restart to make sure all gone */\n\t\t\tindex = start;\n\t\t\tcontinue;\n\t\t}\n\t\tif (index == start && indices[0] >= end) {\n\t\t\t/* All gone out of hole to be punched, we're done */\n\t\t\tpagevec_remove_exceptionals(&pvec);\n\t\t\tpagevec_release(&pvec);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* We rely upon deletion not changing page->index */\n\t\t\tindex = indices[i];\n\t\t\tif (index >= end) {\n\t\t\t\t/* Restart punch to make sure all gone */\n\t\t\t\tindex = start - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (xa_is_value(page))\n\t\t\t\tcontinue;\n\n\t\t\tlock_page(page);\n\t\t\tWARN_ON(page_to_index(page) != index);\n\t\t\twait_on_page_writeback(page);\n\t\t\ttruncate_inode_page(mapping, page);\n\t\t\tunlock_page(page);\n\t\t}\n\t\ttruncate_exceptional_pvec_entries(mapping, &pvec, indices, end);\n\t\tpagevec_release(&pvec);\n\t\tindex++;\n\t}\n\nout:\n\tcleancache_invalidate_inode(mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unmap_mapping_range",
          "args": [
            "mapping",
            "unmap_start",
            "1 + unmap_end - unmap_start",
            "0"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mapping_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2630-2645",
          "snippet": "void unmap_mapping_range(struct address_space *mapping,\n\t\tloff_t const holebegin, loff_t const holelen, int even_cows)\n{\n\tpgoff_t hba = holebegin >> PAGE_SHIFT;\n\tpgoff_t hlen = (holelen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\t/* Check for overflow. */\n\tif (sizeof(holelen) > sizeof(hlen)) {\n\t\tlong long holeend =\n\t\t\t(holebegin + holelen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tif (holeend & ~(long long)ULONG_MAX)\n\t\t\thlen = ULONG_MAX - hba + 1;\n\t}\n\n\tunmap_mapping_pages(mapping, hba, hlen, even_cows);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid unmap_mapping_range(struct address_space *mapping,\n\t\tloff_t const holebegin, loff_t const holelen, int even_cows)\n{\n\tpgoff_t hba = holebegin >> PAGE_SHIFT;\n\tpgoff_t hlen = (holelen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\t/* Check for overflow. */\n\tif (sizeof(holelen) > sizeof(hlen)) {\n\t\tlong long holeend =\n\t\t\t(holebegin + holelen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tif (holeend & ~(long long)ULONG_MAX)\n\t\t\thlen = ULONG_MAX - hba + 1;\n\t}\n\n\tunmap_mapping_pages(mapping, hba, hlen, even_cows);\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "1 + lend",
            "PAGE_SIZE"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "lstart",
            "PAGE_SIZE"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nvoid truncate_pagecache_range(struct inode *inode, loff_t lstart, loff_t lend)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t unmap_start = round_up(lstart, PAGE_SIZE);\n\tloff_t unmap_end = round_down(1 + lend, PAGE_SIZE) - 1;\n\t/*\n\t * This rounding is currently just for example: unmap_mapping_range\n\t * expands its hole outwards, whereas we want it to contract the hole\n\t * inwards.  However, existing callers of truncate_pagecache_range are\n\t * doing their own page rounding first.  Note that unmap_mapping_range\n\t * allows holelen 0 for all, and we allow lend -1 for end of file.\n\t */\n\n\t/*\n\t * Unlike in truncate_pagecache, unmap_mapping_range is called only\n\t * once (before truncating pagecache), and without \"even_cows\" flag:\n\t * hole-punching should not remove private COWed pages from the hole.\n\t */\n\tif ((u64)unmap_end > (u64)unmap_start)\n\t\tunmap_mapping_range(mapping, unmap_start,\n\t\t\t\t    1 + unmap_end - unmap_start, 0);\n\ttruncate_inode_pages_range(mapping, lstart, lend);\n}"
  },
  {
    "function_name": "pagecache_isize_extended",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
    "lines": "850-879",
    "snippet": "void pagecache_isize_extended(struct inode *inode, loff_t from, loff_t to)\n{\n\tint bsize = i_blocksize(inode);\n\tloff_t rounded_from;\n\tstruct page *page;\n\tpgoff_t index;\n\n\tWARN_ON(to > inode->i_size);\n\n\tif (from >= to || bsize == PAGE_SIZE)\n\t\treturn;\n\t/* Page straddling @from will not have any hole block created? */\n\trounded_from = round_up(from, bsize);\n\tif (to <= rounded_from || !(rounded_from & (PAGE_SIZE - 1)))\n\t\treturn;\n\n\tindex = from >> PAGE_SHIFT;\n\tpage = find_lock_page(inode->i_mapping, index);\n\t/* Page not cached? Nothing to do */\n\tif (!page)\n\t\treturn;\n\t/*\n\t * See clear_page_dirty_for_io() for details why set_page_dirty()\n\t * is needed.\n\t */\n\tif (page_mkclean(page))\n\t\tset_page_dirty(page);\n\tunlock_page(page);\n\tput_page(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/rmap.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_dirty_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2573-2581",
          "snippet": "int set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mkclean",
          "args": [
            "page"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "page_mkclean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "965-987",
          "snippet": "int page_mkclean(struct page *page)\n{\n\tint cleaned = 0;\n\tstruct address_space *mapping;\n\tstruct rmap_walk_control rwc = {\n\t\t.arg = (void *)&cleaned,\n\t\t.rmap_one = page_mkclean_one,\n\t\t.invalid_vma = invalid_mkclean_vma,\n\t};\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_mapped(page))\n\t\treturn 0;\n\n\tmapping = page_mapping(page);\n\tif (!mapping)\n\t\treturn 0;\n\n\trmap_walk(page, &rwc);\n\n\treturn cleaned;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint page_mkclean(struct page *page)\n{\n\tint cleaned = 0;\n\tstruct address_space *mapping;\n\tstruct rmap_walk_control rwc = {\n\t\t.arg = (void *)&cleaned,\n\t\t.rmap_one = page_mkclean_one,\n\t\t.invalid_vma = invalid_mkclean_vma,\n\t};\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_mapped(page))\n\t\treturn 0;\n\n\tmapping = page_mapping(page);\n\tif (!mapping)\n\t\treturn 0;\n\n\trmap_walk(page, &rwc);\n\n\treturn cleaned;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_lock_page",
          "args": [
            "inode->i_mapping",
            "index"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "from",
            "bsize"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "to > inode->i_size"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_blocksize",
          "args": [
            "inode"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nvoid pagecache_isize_extended(struct inode *inode, loff_t from, loff_t to)\n{\n\tint bsize = i_blocksize(inode);\n\tloff_t rounded_from;\n\tstruct page *page;\n\tpgoff_t index;\n\n\tWARN_ON(to > inode->i_size);\n\n\tif (from >= to || bsize == PAGE_SIZE)\n\t\treturn;\n\t/* Page straddling @from will not have any hole block created? */\n\trounded_from = round_up(from, bsize);\n\tif (to <= rounded_from || !(rounded_from & (PAGE_SIZE - 1)))\n\t\treturn;\n\n\tindex = from >> PAGE_SHIFT;\n\tpage = find_lock_page(inode->i_mapping, index);\n\t/* Page not cached? Nothing to do */\n\tif (!page)\n\t\treturn;\n\t/*\n\t * See clear_page_dirty_for_io() for details why set_page_dirty()\n\t * is needed.\n\t */\n\tif (page_mkclean(page))\n\t\tset_page_dirty(page);\n\tunlock_page(page);\n\tput_page(page);\n}"
  },
  {
    "function_name": "truncate_setsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
    "lines": "820-828",
    "snippet": "void truncate_setsize(struct inode *inode, loff_t newsize)\n{\n\tloff_t oldsize = inode->i_size;\n\n\ti_size_write(inode, newsize);\n\tif (newsize > oldsize)\n\t\tpagecache_isize_extended(inode, oldsize, newsize);\n\ttruncate_pagecache(inode, newsize);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/rmap.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "newsize"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_pagecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "787-804",
          "snippet": "void truncate_pagecache(struct inode *inode, loff_t newsize)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t holebegin = round_up(newsize, PAGE_SIZE);\n\n\t/*\n\t * unmap_mapping_range is called twice, first simply for\n\t * efficiency so that truncate_inode_pages does fewer\n\t * single-page unmaps.  However after this first call, and\n\t * before truncate_inode_pages finishes, it is possible for\n\t * private pages to be COWed, which remain after\n\t * truncate_inode_pages finishes, hence the second\n\t * unmap_mapping_range call must be made for correctness.\n\t */\n\tunmap_mapping_range(mapping, holebegin, 0, 1);\n\ttruncate_inode_pages(mapping, newsize);\n\tunmap_mapping_range(mapping, holebegin, 0, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nvoid truncate_pagecache(struct inode *inode, loff_t newsize)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t holebegin = round_up(newsize, PAGE_SIZE);\n\n\t/*\n\t * unmap_mapping_range is called twice, first simply for\n\t * efficiency so that truncate_inode_pages does fewer\n\t * single-page unmaps.  However after this first call, and\n\t * before truncate_inode_pages finishes, it is possible for\n\t * private pages to be COWed, which remain after\n\t * truncate_inode_pages finishes, hence the second\n\t * unmap_mapping_range call must be made for correctness.\n\t */\n\tunmap_mapping_range(mapping, holebegin, 0, 1);\n\ttruncate_inode_pages(mapping, newsize);\n\tunmap_mapping_range(mapping, holebegin, 0, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagecache_isize_extended",
          "args": [
            "inode",
            "oldsize",
            "newsize"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "pagecache_isize_extended",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "850-879",
          "snippet": "void pagecache_isize_extended(struct inode *inode, loff_t from, loff_t to)\n{\n\tint bsize = i_blocksize(inode);\n\tloff_t rounded_from;\n\tstruct page *page;\n\tpgoff_t index;\n\n\tWARN_ON(to > inode->i_size);\n\n\tif (from >= to || bsize == PAGE_SIZE)\n\t\treturn;\n\t/* Page straddling @from will not have any hole block created? */\n\trounded_from = round_up(from, bsize);\n\tif (to <= rounded_from || !(rounded_from & (PAGE_SIZE - 1)))\n\t\treturn;\n\n\tindex = from >> PAGE_SHIFT;\n\tpage = find_lock_page(inode->i_mapping, index);\n\t/* Page not cached? Nothing to do */\n\tif (!page)\n\t\treturn;\n\t/*\n\t * See clear_page_dirty_for_io() for details why set_page_dirty()\n\t * is needed.\n\t */\n\tif (page_mkclean(page))\n\t\tset_page_dirty(page);\n\tunlock_page(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nvoid pagecache_isize_extended(struct inode *inode, loff_t from, loff_t to)\n{\n\tint bsize = i_blocksize(inode);\n\tloff_t rounded_from;\n\tstruct page *page;\n\tpgoff_t index;\n\n\tWARN_ON(to > inode->i_size);\n\n\tif (from >= to || bsize == PAGE_SIZE)\n\t\treturn;\n\t/* Page straddling @from will not have any hole block created? */\n\trounded_from = round_up(from, bsize);\n\tif (to <= rounded_from || !(rounded_from & (PAGE_SIZE - 1)))\n\t\treturn;\n\n\tindex = from >> PAGE_SHIFT;\n\tpage = find_lock_page(inode->i_mapping, index);\n\t/* Page not cached? Nothing to do */\n\tif (!page)\n\t\treturn;\n\t/*\n\t * See clear_page_dirty_for_io() for details why set_page_dirty()\n\t * is needed.\n\t */\n\tif (page_mkclean(page))\n\t\tset_page_dirty(page);\n\tunlock_page(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "newsize"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nvoid truncate_setsize(struct inode *inode, loff_t newsize)\n{\n\tloff_t oldsize = inode->i_size;\n\n\ti_size_write(inode, newsize);\n\tif (newsize > oldsize)\n\t\tpagecache_isize_extended(inode, oldsize, newsize);\n\ttruncate_pagecache(inode, newsize);\n}"
  },
  {
    "function_name": "truncate_pagecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
    "lines": "787-804",
    "snippet": "void truncate_pagecache(struct inode *inode, loff_t newsize)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t holebegin = round_up(newsize, PAGE_SIZE);\n\n\t/*\n\t * unmap_mapping_range is called twice, first simply for\n\t * efficiency so that truncate_inode_pages does fewer\n\t * single-page unmaps.  However after this first call, and\n\t * before truncate_inode_pages finishes, it is possible for\n\t * private pages to be COWed, which remain after\n\t * truncate_inode_pages finishes, hence the second\n\t * unmap_mapping_range call must be made for correctness.\n\t */\n\tunmap_mapping_range(mapping, holebegin, 0, 1);\n\ttruncate_inode_pages(mapping, newsize);\n\tunmap_mapping_range(mapping, holebegin, 0, 1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/rmap.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unmap_mapping_range",
          "args": [
            "mapping",
            "holebegin",
            "0",
            "1"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mapping_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2630-2645",
          "snippet": "void unmap_mapping_range(struct address_space *mapping,\n\t\tloff_t const holebegin, loff_t const holelen, int even_cows)\n{\n\tpgoff_t hba = holebegin >> PAGE_SHIFT;\n\tpgoff_t hlen = (holelen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\t/* Check for overflow. */\n\tif (sizeof(holelen) > sizeof(hlen)) {\n\t\tlong long holeend =\n\t\t\t(holebegin + holelen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tif (holeend & ~(long long)ULONG_MAX)\n\t\t\thlen = ULONG_MAX - hba + 1;\n\t}\n\n\tunmap_mapping_pages(mapping, hba, hlen, even_cows);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid unmap_mapping_range(struct address_space *mapping,\n\t\tloff_t const holebegin, loff_t const holelen, int even_cows)\n{\n\tpgoff_t hba = holebegin >> PAGE_SHIFT;\n\tpgoff_t hlen = (holelen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\t/* Check for overflow. */\n\tif (sizeof(holelen) > sizeof(hlen)) {\n\t\tlong long holeend =\n\t\t\t(holebegin + holelen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tif (holeend & ~(long long)ULONG_MAX)\n\t\t\thlen = ULONG_MAX - hba + 1;\n\t}\n\n\tunmap_mapping_pages(mapping, hba, hlen, even_cows);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "mapping",
            "newsize"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_inode_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "473-476",
          "snippet": "void truncate_inode_pages(struct address_space *mapping, loff_t lstart)\n{\n\ttruncate_inode_pages_range(mapping, lstart, (loff_t)-1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nvoid truncate_inode_pages(struct address_space *mapping, loff_t lstart)\n{\n\ttruncate_inode_pages_range(mapping, lstart, (loff_t)-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "newsize",
            "PAGE_SIZE"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nvoid truncate_pagecache(struct inode *inode, loff_t newsize)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t holebegin = round_up(newsize, PAGE_SIZE);\n\n\t/*\n\t * unmap_mapping_range is called twice, first simply for\n\t * efficiency so that truncate_inode_pages does fewer\n\t * single-page unmaps.  However after this first call, and\n\t * before truncate_inode_pages finishes, it is possible for\n\t * private pages to be COWed, which remain after\n\t * truncate_inode_pages finishes, hence the second\n\t * unmap_mapping_range call must be made for correctness.\n\t */\n\tunmap_mapping_range(mapping, holebegin, 0, 1);\n\ttruncate_inode_pages(mapping, newsize);\n\tunmap_mapping_range(mapping, holebegin, 0, 1);\n}"
  },
  {
    "function_name": "invalidate_inode_pages2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
    "lines": "766-769",
    "snippet": "int invalidate_inode_pages2(struct address_space *mapping)\n{\n\treturn invalidate_inode_pages2_range(mapping, 0, -1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/rmap.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "invalidate_inode_pages2_range",
          "args": [
            "mapping",
            "0",
            "-1"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_inode_pages2_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "669-754",
          "snippet": "int invalidate_inode_pages2_range(struct address_space *mapping,\n\t\t\t\t  pgoff_t start, pgoff_t end)\n{\n\tpgoff_t indices[PAGEVEC_SIZE];\n\tstruct pagevec pvec;\n\tpgoff_t index;\n\tint i;\n\tint ret = 0;\n\tint ret2 = 0;\n\tint did_range_unmap = 0;\n\n\tif (mapping->nrpages == 0 && mapping->nrexceptional == 0)\n\t\tgoto out;\n\n\tpagevec_init(&pvec);\n\tindex = start;\n\twhile (index <= end && pagevec_lookup_entries(&pvec, mapping, index,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE - 1) + 1,\n\t\t\tindices)) {\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* We rely upon deletion not changing page->index */\n\t\t\tindex = indices[i];\n\t\t\tif (index > end)\n\t\t\t\tbreak;\n\n\t\t\tif (xa_is_value(page)) {\n\t\t\t\tif (!invalidate_exceptional_entry2(mapping,\n\t\t\t\t\t\t\t\t   index, page))\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlock_page(page);\n\t\t\tWARN_ON(page_to_index(page) != index);\n\t\t\tif (page->mapping != mapping) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twait_on_page_writeback(page);\n\t\t\tif (page_mapped(page)) {\n\t\t\t\tif (!did_range_unmap) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Zap the rest of the file in one hit.\n\t\t\t\t\t */\n\t\t\t\t\tunmap_mapping_pages(mapping, index,\n\t\t\t\t\t\t(1 + end - index), false);\n\t\t\t\t\tdid_range_unmap = 1;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Just zap this page\n\t\t\t\t\t */\n\t\t\t\t\tunmap_mapping_pages(mapping, index,\n\t\t\t\t\t\t\t\t1, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tBUG_ON(page_mapped(page));\n\t\t\tret2 = do_launder_page(mapping, page);\n\t\t\tif (ret2 == 0) {\n\t\t\t\tif (!invalidate_complete_page2(mapping, page))\n\t\t\t\t\tret2 = -EBUSY;\n\t\t\t}\n\t\t\tif (ret2 < 0)\n\t\t\t\tret = ret2;\n\t\t\tunlock_page(page);\n\t\t}\n\t\tpagevec_remove_exceptionals(&pvec);\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t\tindex++;\n\t}\n\t/*\n\t * For DAX we invalidate page tables after invalidating page cache.  We\n\t * could invalidate page tables while invalidating each entry however\n\t * that would be expensive. And doing range unmapping before doesn't\n\t * work as we have no cheap way to find whether page cache entry didn't\n\t * get remapped later.\n\t */\n\tif (dax_mapping(mapping)) {\n\t\tunmap_mapping_pages(mapping, start, end - start + 1, false);\n\t}\nout:\n\tcleancache_invalidate_inode(mapping);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nint invalidate_inode_pages2_range(struct address_space *mapping,\n\t\t\t\t  pgoff_t start, pgoff_t end)\n{\n\tpgoff_t indices[PAGEVEC_SIZE];\n\tstruct pagevec pvec;\n\tpgoff_t index;\n\tint i;\n\tint ret = 0;\n\tint ret2 = 0;\n\tint did_range_unmap = 0;\n\n\tif (mapping->nrpages == 0 && mapping->nrexceptional == 0)\n\t\tgoto out;\n\n\tpagevec_init(&pvec);\n\tindex = start;\n\twhile (index <= end && pagevec_lookup_entries(&pvec, mapping, index,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE - 1) + 1,\n\t\t\tindices)) {\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* We rely upon deletion not changing page->index */\n\t\t\tindex = indices[i];\n\t\t\tif (index > end)\n\t\t\t\tbreak;\n\n\t\t\tif (xa_is_value(page)) {\n\t\t\t\tif (!invalidate_exceptional_entry2(mapping,\n\t\t\t\t\t\t\t\t   index, page))\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlock_page(page);\n\t\t\tWARN_ON(page_to_index(page) != index);\n\t\t\tif (page->mapping != mapping) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twait_on_page_writeback(page);\n\t\t\tif (page_mapped(page)) {\n\t\t\t\tif (!did_range_unmap) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Zap the rest of the file in one hit.\n\t\t\t\t\t */\n\t\t\t\t\tunmap_mapping_pages(mapping, index,\n\t\t\t\t\t\t(1 + end - index), false);\n\t\t\t\t\tdid_range_unmap = 1;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Just zap this page\n\t\t\t\t\t */\n\t\t\t\t\tunmap_mapping_pages(mapping, index,\n\t\t\t\t\t\t\t\t1, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tBUG_ON(page_mapped(page));\n\t\t\tret2 = do_launder_page(mapping, page);\n\t\t\tif (ret2 == 0) {\n\t\t\t\tif (!invalidate_complete_page2(mapping, page))\n\t\t\t\t\tret2 = -EBUSY;\n\t\t\t}\n\t\t\tif (ret2 < 0)\n\t\t\t\tret = ret2;\n\t\t\tunlock_page(page);\n\t\t}\n\t\tpagevec_remove_exceptionals(&pvec);\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t\tindex++;\n\t}\n\t/*\n\t * For DAX we invalidate page tables after invalidating page cache.  We\n\t * could invalidate page tables while invalidating each entry however\n\t * that would be expensive. And doing range unmapping before doesn't\n\t * work as we have no cheap way to find whether page cache entry didn't\n\t * get remapped later.\n\t */\n\tif (dax_mapping(mapping)) {\n\t\tunmap_mapping_pages(mapping, start, end - start + 1, false);\n\t}\nout:\n\tcleancache_invalidate_inode(mapping);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nint invalidate_inode_pages2(struct address_space *mapping)\n{\n\treturn invalidate_inode_pages2_range(mapping, 0, -1);\n}"
  },
  {
    "function_name": "invalidate_inode_pages2_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
    "lines": "669-754",
    "snippet": "int invalidate_inode_pages2_range(struct address_space *mapping,\n\t\t\t\t  pgoff_t start, pgoff_t end)\n{\n\tpgoff_t indices[PAGEVEC_SIZE];\n\tstruct pagevec pvec;\n\tpgoff_t index;\n\tint i;\n\tint ret = 0;\n\tint ret2 = 0;\n\tint did_range_unmap = 0;\n\n\tif (mapping->nrpages == 0 && mapping->nrexceptional == 0)\n\t\tgoto out;\n\n\tpagevec_init(&pvec);\n\tindex = start;\n\twhile (index <= end && pagevec_lookup_entries(&pvec, mapping, index,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE - 1) + 1,\n\t\t\tindices)) {\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* We rely upon deletion not changing page->index */\n\t\t\tindex = indices[i];\n\t\t\tif (index > end)\n\t\t\t\tbreak;\n\n\t\t\tif (xa_is_value(page)) {\n\t\t\t\tif (!invalidate_exceptional_entry2(mapping,\n\t\t\t\t\t\t\t\t   index, page))\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlock_page(page);\n\t\t\tWARN_ON(page_to_index(page) != index);\n\t\t\tif (page->mapping != mapping) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twait_on_page_writeback(page);\n\t\t\tif (page_mapped(page)) {\n\t\t\t\tif (!did_range_unmap) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Zap the rest of the file in one hit.\n\t\t\t\t\t */\n\t\t\t\t\tunmap_mapping_pages(mapping, index,\n\t\t\t\t\t\t(1 + end - index), false);\n\t\t\t\t\tdid_range_unmap = 1;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Just zap this page\n\t\t\t\t\t */\n\t\t\t\t\tunmap_mapping_pages(mapping, index,\n\t\t\t\t\t\t\t\t1, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tBUG_ON(page_mapped(page));\n\t\t\tret2 = do_launder_page(mapping, page);\n\t\t\tif (ret2 == 0) {\n\t\t\t\tif (!invalidate_complete_page2(mapping, page))\n\t\t\t\t\tret2 = -EBUSY;\n\t\t\t}\n\t\t\tif (ret2 < 0)\n\t\t\t\tret = ret2;\n\t\t\tunlock_page(page);\n\t\t}\n\t\tpagevec_remove_exceptionals(&pvec);\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t\tindex++;\n\t}\n\t/*\n\t * For DAX we invalidate page tables after invalidating page cache.  We\n\t * could invalidate page tables while invalidating each entry however\n\t * that would be expensive. And doing range unmapping before doesn't\n\t * work as we have no cheap way to find whether page cache entry didn't\n\t * get remapped later.\n\t */\n\tif (dax_mapping(mapping)) {\n\t\tunmap_mapping_pages(mapping, start, end - start + 1, false);\n\t}\nout:\n\tcleancache_invalidate_inode(mapping);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/rmap.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleancache_invalidate_inode",
          "args": [
            "mapping"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "__cleancache_invalidate_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cleancache.c",
          "lines": "274-284",
          "snippet": "void __cleancache_invalidate_inode(struct address_space *mapping)\n{\n\tint pool_id = mapping->host->i_sb->cleancache_poolid;\n\tstruct cleancache_filekey key = { .u.key = { 0 } };\n\n\tif (!cleancache_ops)\n\t\treturn;\n\n\tif (pool_id >= 0 && cleancache_get_key(mapping->host, &key) >= 0)\n\t\tcleancache_ops->invalidate_inode(pool_id, key);\n}",
          "includes": [
            "#include <linux/cleancache.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/mm.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct cleancache_ops *cleancache_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cleancache.h>\n#include <linux/debugfs.h>\n#include <linux/mm.h>\n#include <linux/exportfs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct cleancache_ops *cleancache_ops;\n\nvoid __cleancache_invalidate_inode(struct address_space *mapping)\n{\n\tint pool_id = mapping->host->i_sb->cleancache_poolid;\n\tstruct cleancache_filekey key = { .u.key = { 0 } };\n\n\tif (!cleancache_ops)\n\t\treturn;\n\n\tif (pool_id >= 0 && cleancache_get_key(mapping->host, &key) >= 0)\n\t\tcleancache_ops->invalidate_inode(pool_id, key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unmap_mapping_pages",
          "args": [
            "mapping",
            "start",
            "end - start + 1",
            "false"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mapping_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2596-2611",
          "snippet": "void unmap_mapping_pages(struct address_space *mapping, pgoff_t start,\n\t\tpgoff_t nr, bool even_cows)\n{\n\tstruct zap_details details = { };\n\n\tdetails.check_mapping = even_cows ? NULL : mapping;\n\tdetails.first_index = start;\n\tdetails.last_index = start + nr - 1;\n\tif (details.last_index < details.first_index)\n\t\tdetails.last_index = ULONG_MAX;\n\n\ti_mmap_lock_write(mapping);\n\tif (unlikely(!RB_EMPTY_ROOT(&mapping->i_mmap.rb_root)))\n\t\tunmap_mapping_range_tree(&mapping->i_mmap, &details);\n\ti_mmap_unlock_write(mapping);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid unmap_mapping_pages(struct address_space *mapping, pgoff_t start,\n\t\tpgoff_t nr, bool even_cows)\n{\n\tstruct zap_details details = { };\n\n\tdetails.check_mapping = even_cows ? NULL : mapping;\n\tdetails.first_index = start;\n\tdetails.last_index = start + nr - 1;\n\tif (details.last_index < details.first_index)\n\t\tdetails.last_index = ULONG_MAX;\n\n\ti_mmap_lock_write(mapping);\n\tif (unlikely(!RB_EMPTY_ROOT(&mapping->i_mmap.rb_root)))\n\t\tunmap_mapping_range_tree(&mapping->i_mmap, &details);\n\ti_mmap_unlock_write(mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_mapping",
          "args": [
            "mapping"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "__pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "805-813",
          "snippet": "void __pagevec_release(struct pagevec *pvec)\n{\n\tif (!pvec->percpu_pvec_drained) {\n\t\tlru_add_drain();\n\t\tpvec->percpu_pvec_drained = true;\n\t}\n\trelease_pages(pvec->pages, pagevec_count(pvec));\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid __pagevec_release(struct pagevec *pvec)\n{\n\tif (!pvec->percpu_pvec_drained) {\n\t\tlru_add_drain();\n\t\tpvec->percpu_pvec_drained = true;\n\t}\n\trelease_pages(pvec->pages, pagevec_count(pvec));\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_remove_exceptionals",
          "args": [
            "&pvec"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "pagevec_remove_exceptionals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "961-971",
          "snippet": "void pagevec_remove_exceptionals(struct pagevec *pvec)\n{\n\tint i, j;\n\n\tfor (i = 0, j = 0; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tif (!xa_is_value(page))\n\t\t\tpvec->pages[j++] = page;\n\t}\n\tpvec->nr = j;\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid pagevec_remove_exceptionals(struct pagevec *pvec)\n{\n\tint i, j;\n\n\tfor (i = 0, j = 0; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tif (!xa_is_value(page))\n\t\t\tpvec->pages[j++] = page;\n\t}\n\tpvec->nr = j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_complete_page2",
          "args": [
            "mapping",
            "page"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_complete_page2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "620-647",
          "snippet": "static int\ninvalidate_complete_page2(struct address_space *mapping, struct page *page)\n{\n\tunsigned long flags;\n\n\tif (page->mapping != mapping)\n\t\treturn 0;\n\n\tif (page_has_private(page) && !try_to_release_page(page, GFP_KERNEL))\n\t\treturn 0;\n\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\tif (PageDirty(page))\n\t\tgoto failed;\n\n\tBUG_ON(page_has_private(page));\n\t__delete_from_page_cache(page, NULL);\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\n\tif (mapping->a_ops->freepage)\n\t\tmapping->a_ops->freepage(page);\n\n\tput_page(page);\t/* pagecache ref */\n\treturn 1;\nfailed:\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nstatic int\ninvalidate_complete_page2(struct address_space *mapping, struct page *page)\n{\n\tunsigned long flags;\n\n\tif (page->mapping != mapping)\n\t\treturn 0;\n\n\tif (page_has_private(page) && !try_to_release_page(page, GFP_KERNEL))\n\t\treturn 0;\n\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\tif (PageDirty(page))\n\t\tgoto failed;\n\n\tBUG_ON(page_has_private(page));\n\t__delete_from_page_cache(page, NULL);\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\n\tif (mapping->a_ops->freepage)\n\t\tmapping->a_ops->freepage(page);\n\n\tput_page(page);\t/* pagecache ref */\n\treturn 1;\nfailed:\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_launder_page",
          "args": [
            "mapping",
            "page"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "do_launder_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "649-656",
          "snippet": "static int do_launder_page(struct address_space *mapping, struct page *page)\n{\n\tif (!PageDirty(page))\n\t\treturn 0;\n\tif (page->mapping != mapping || mapping->a_ops->launder_page == NULL)\n\t\treturn 0;\n\treturn mapping->a_ops->launder_page(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nstatic int do_launder_page(struct address_space *mapping, struct page *page)\n{\n\tif (!PageDirty(page))\n\t\treturn 0;\n\tif (page->mapping != mapping || mapping->a_ops->launder_page == NULL)\n\t\treturn 0;\n\treturn mapping->a_ops->launder_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page_mapped(page)"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "page"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "470-486",
          "snippet": "bool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nbool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "page_to_index(page) != index"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_index",
          "args": [
            "page"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_exceptional_entry2",
          "args": [
            "mapping",
            "index",
            "page"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_exceptional_entry2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "124-134",
          "snippet": "static int invalidate_exceptional_entry2(struct address_space *mapping,\n\t\t\t\t\t pgoff_t index, void *entry)\n{\n\t/* Handled by shmem itself */\n\tif (shmem_mapping(mapping))\n\t\treturn 1;\n\tif (dax_mapping(mapping))\n\t\treturn dax_invalidate_mapping_entry_sync(mapping, index);\n\tclear_shadow_entry(mapping, index, entry);\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nstatic int invalidate_exceptional_entry2(struct address_space *mapping,\n\t\t\t\t\t pgoff_t index, void *entry)\n{\n\t/* Handled by shmem itself */\n\tif (shmem_mapping(mapping))\n\t\treturn 1;\n\tif (dax_mapping(mapping))\n\t\treturn dax_invalidate_mapping_entry_sync(mapping, index);\n\tclear_shadow_entry(mapping, index, entry);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "page"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "&pvec"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lookup_entries",
          "args": [
            "&pvec",
            "mapping",
            "index",
            "min(end - index, (pgoff_t)PAGEVEC_SIZE - 1) + 1",
            "indices"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "pagevec_lookup_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "942-950",
          "snippet": "unsigned pagevec_lookup_entries(struct pagevec *pvec,\n\t\t\t\tstruct address_space *mapping,\n\t\t\t\tpgoff_t start, unsigned nr_entries,\n\t\t\t\tpgoff_t *indices)\n{\n\tpvec->nr = find_get_entries(mapping, start, nr_entries,\n\t\t\t\t    pvec->pages, indices);\n\treturn pagevec_count(pvec);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nunsigned pagevec_lookup_entries(struct pagevec *pvec,\n\t\t\t\tstruct address_space *mapping,\n\t\t\t\tpgoff_t start, unsigned nr_entries,\n\t\t\t\tpgoff_t *indices)\n{\n\tpvec->nr = find_get_entries(mapping, start, nr_entries,\n\t\t\t\t    pvec->pages, indices);\n\treturn pagevec_count(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "end - index",
            "(pgoff_t)PAGEVEC_SIZE - 1"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nint invalidate_inode_pages2_range(struct address_space *mapping,\n\t\t\t\t  pgoff_t start, pgoff_t end)\n{\n\tpgoff_t indices[PAGEVEC_SIZE];\n\tstruct pagevec pvec;\n\tpgoff_t index;\n\tint i;\n\tint ret = 0;\n\tint ret2 = 0;\n\tint did_range_unmap = 0;\n\n\tif (mapping->nrpages == 0 && mapping->nrexceptional == 0)\n\t\tgoto out;\n\n\tpagevec_init(&pvec);\n\tindex = start;\n\twhile (index <= end && pagevec_lookup_entries(&pvec, mapping, index,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE - 1) + 1,\n\t\t\tindices)) {\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* We rely upon deletion not changing page->index */\n\t\t\tindex = indices[i];\n\t\t\tif (index > end)\n\t\t\t\tbreak;\n\n\t\t\tif (xa_is_value(page)) {\n\t\t\t\tif (!invalidate_exceptional_entry2(mapping,\n\t\t\t\t\t\t\t\t   index, page))\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlock_page(page);\n\t\t\tWARN_ON(page_to_index(page) != index);\n\t\t\tif (page->mapping != mapping) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twait_on_page_writeback(page);\n\t\t\tif (page_mapped(page)) {\n\t\t\t\tif (!did_range_unmap) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Zap the rest of the file in one hit.\n\t\t\t\t\t */\n\t\t\t\t\tunmap_mapping_pages(mapping, index,\n\t\t\t\t\t\t(1 + end - index), false);\n\t\t\t\t\tdid_range_unmap = 1;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Just zap this page\n\t\t\t\t\t */\n\t\t\t\t\tunmap_mapping_pages(mapping, index,\n\t\t\t\t\t\t\t\t1, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tBUG_ON(page_mapped(page));\n\t\t\tret2 = do_launder_page(mapping, page);\n\t\t\tif (ret2 == 0) {\n\t\t\t\tif (!invalidate_complete_page2(mapping, page))\n\t\t\t\t\tret2 = -EBUSY;\n\t\t\t}\n\t\t\tif (ret2 < 0)\n\t\t\t\tret = ret2;\n\t\t\tunlock_page(page);\n\t\t}\n\t\tpagevec_remove_exceptionals(&pvec);\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t\tindex++;\n\t}\n\t/*\n\t * For DAX we invalidate page tables after invalidating page cache.  We\n\t * could invalidate page tables while invalidating each entry however\n\t * that would be expensive. And doing range unmapping before doesn't\n\t * work as we have no cheap way to find whether page cache entry didn't\n\t * get remapped later.\n\t */\n\tif (dax_mapping(mapping)) {\n\t\tunmap_mapping_pages(mapping, start, end - start + 1, false);\n\t}\nout:\n\tcleancache_invalidate_inode(mapping);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_launder_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
    "lines": "649-656",
    "snippet": "static int do_launder_page(struct address_space *mapping, struct page *page)\n{\n\tif (!PageDirty(page))\n\t\treturn 0;\n\tif (page->mapping != mapping || mapping->a_ops->launder_page == NULL)\n\t\treturn 0;\n\treturn mapping->a_ops->launder_page(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/rmap.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapping->a_ops->launder_page",
          "args": [
            "page"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nstatic int do_launder_page(struct address_space *mapping, struct page *page)\n{\n\tif (!PageDirty(page))\n\t\treturn 0;\n\tif (page->mapping != mapping || mapping->a_ops->launder_page == NULL)\n\t\treturn 0;\n\treturn mapping->a_ops->launder_page(page);\n}"
  },
  {
    "function_name": "invalidate_complete_page2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
    "lines": "620-647",
    "snippet": "static int\ninvalidate_complete_page2(struct address_space *mapping, struct page *page)\n{\n\tunsigned long flags;\n\n\tif (page->mapping != mapping)\n\t\treturn 0;\n\n\tif (page_has_private(page) && !try_to_release_page(page, GFP_KERNEL))\n\t\treturn 0;\n\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\tif (PageDirty(page))\n\t\tgoto failed;\n\n\tBUG_ON(page_has_private(page));\n\t__delete_from_page_cache(page, NULL);\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\n\tif (mapping->a_ops->freepage)\n\t\tmapping->a_ops->freepage(page);\n\n\tput_page(page);\t/* pagecache ref */\n\treturn 1;\nfailed:\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/rmap.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xa_unlock_irqrestore",
          "args": [
            "&mapping->i_pages",
            "flags"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->freepage",
          "args": [
            "page"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_unlock_irqrestore",
          "args": [
            "&mapping->i_pages",
            "flags"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__delete_from_page_cache",
          "args": [
            "page",
            "NULL"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "__delete_from_page_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "227-235",
          "snippet": "void __delete_from_page_cache(struct page *page, void *shadow)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\ttrace_mm_filemap_delete_from_page_cache(page);\n\n\tunaccount_page_cache_page(mapping, page);\n\tpage_cache_delete(mapping, page, shadow);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid __delete_from_page_cache(struct page *page, void *shadow)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\ttrace_mm_filemap_delete_from_page_cache(page);\n\n\tunaccount_page_cache_page(mapping, page);\n\tpage_cache_delete(mapping, page, shadow);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page_has_private(page)"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "page"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_lock_irqsave",
          "args": [
            "&mapping->i_pages",
            "flags"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_release_page",
          "args": [
            "page",
            "GFP_KERNEL"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_release_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "3319-3330",
          "snippet": "int try_to_release_page(struct page *page, gfp_t gfp_mask)\n{\n\tstruct address_space * const mapping = page->mapping;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping && mapping->a_ops->releasepage)\n\t\treturn mapping->a_ops->releasepage(page, gfp_mask);\n\treturn try_to_free_buffers(page);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint try_to_release_page(struct page *page, gfp_t gfp_mask)\n{\n\tstruct address_space * const mapping = page->mapping;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping && mapping->a_ops->releasepage)\n\t\treturn mapping->a_ops->releasepage(page, gfp_mask);\n\treturn try_to_free_buffers(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "page"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nstatic int\ninvalidate_complete_page2(struct address_space *mapping, struct page *page)\n{\n\tunsigned long flags;\n\n\tif (page->mapping != mapping)\n\t\treturn 0;\n\n\tif (page_has_private(page) && !try_to_release_page(page, GFP_KERNEL))\n\t\treturn 0;\n\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\tif (PageDirty(page))\n\t\tgoto failed;\n\n\tBUG_ON(page_has_private(page));\n\t__delete_from_page_cache(page, NULL);\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\n\tif (mapping->a_ops->freepage)\n\t\tmapping->a_ops->freepage(page);\n\n\tput_page(page);\t/* pagecache ref */\n\treturn 1;\nfailed:\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\treturn 0;\n}"
  },
  {
    "function_name": "invalidate_mapping_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
    "lines": "543-610",
    "snippet": "unsigned long invalidate_mapping_pages(struct address_space *mapping,\n\t\tpgoff_t start, pgoff_t end)\n{\n\tpgoff_t indices[PAGEVEC_SIZE];\n\tstruct pagevec pvec;\n\tpgoff_t index = start;\n\tunsigned long ret;\n\tunsigned long count = 0;\n\tint i;\n\n\tpagevec_init(&pvec);\n\twhile (index <= end && pagevec_lookup_entries(&pvec, mapping, index,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE - 1) + 1,\n\t\t\tindices)) {\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* We rely upon deletion not changing page->index */\n\t\t\tindex = indices[i];\n\t\t\tif (index > end)\n\t\t\t\tbreak;\n\n\t\t\tif (xa_is_value(page)) {\n\t\t\t\tinvalidate_exceptional_entry(mapping, index,\n\t\t\t\t\t\t\t     page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!trylock_page(page))\n\t\t\t\tcontinue;\n\n\t\t\tWARN_ON(page_to_index(page) != index);\n\n\t\t\t/* Middle of THP: skip */\n\t\t\tif (PageTransTail(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t} else if (PageTransHuge(page)) {\n\t\t\t\tindex += HPAGE_PMD_NR - 1;\n\t\t\t\ti += HPAGE_PMD_NR - 1;\n\t\t\t\t/*\n\t\t\t\t * 'end' is in the middle of THP. Don't\n\t\t\t\t * invalidate the page as the part outside of\n\t\t\t\t * 'end' could be still useful.\n\t\t\t\t */\n\t\t\t\tif (index > end) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = invalidate_inode_page(page);\n\t\t\tunlock_page(page);\n\t\t\t/*\n\t\t\t * Invalidation is a hint that the page is no longer\n\t\t\t * of interest and try to speed up its reclaim.\n\t\t\t */\n\t\t\tif (!ret)\n\t\t\t\tdeactivate_file_page(page);\n\t\t\tcount += ret;\n\t\t}\n\t\tpagevec_remove_exceptionals(&pvec);\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t\tindex++;\n\t}\n\treturn count;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/rmap.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "__pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "805-813",
          "snippet": "void __pagevec_release(struct pagevec *pvec)\n{\n\tif (!pvec->percpu_pvec_drained) {\n\t\tlru_add_drain();\n\t\tpvec->percpu_pvec_drained = true;\n\t}\n\trelease_pages(pvec->pages, pagevec_count(pvec));\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid __pagevec_release(struct pagevec *pvec)\n{\n\tif (!pvec->percpu_pvec_drained) {\n\t\tlru_add_drain();\n\t\tpvec->percpu_pvec_drained = true;\n\t}\n\trelease_pages(pvec->pages, pagevec_count(pvec));\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_remove_exceptionals",
          "args": [
            "&pvec"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "pagevec_remove_exceptionals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "961-971",
          "snippet": "void pagevec_remove_exceptionals(struct pagevec *pvec)\n{\n\tint i, j;\n\n\tfor (i = 0, j = 0; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tif (!xa_is_value(page))\n\t\t\tpvec->pages[j++] = page;\n\t}\n\tpvec->nr = j;\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid pagevec_remove_exceptionals(struct pagevec *pvec)\n{\n\tint i, j;\n\n\tfor (i = 0, j = 0; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tif (!xa_is_value(page))\n\t\t\tpvec->pages[j++] = page;\n\t}\n\tpvec->nr = j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "deactivate_file_page",
          "args": [
            "page"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "deactivate_file_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "612-628",
          "snippet": "void deactivate_file_page(struct page *page)\n{\n\t/*\n\t * In a workload with many unevictable page such as mprotect,\n\t * unevictable page deactivation for accelerating reclaim is pointless.\n\t */\n\tif (PageUnevictable(page))\n\t\treturn;\n\n\tif (likely(get_page_unless_zero(page))) {\n\t\tstruct pagevec *pvec = &get_cpu_var(lru_deactivate_file_pvecs);\n\n\t\tif (!pagevec_add(pvec, page) || PageCompound(page))\n\t\t\tpagevec_lru_move_fn(pvec, lru_deactivate_file_fn, NULL);\n\t\tput_cpu_var(lru_deactivate_file_pvecs);\n\t}\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\n\nvoid deactivate_file_page(struct page *page)\n{\n\t/*\n\t * In a workload with many unevictable page such as mprotect,\n\t * unevictable page deactivation for accelerating reclaim is pointless.\n\t */\n\tif (PageUnevictable(page))\n\t\treturn;\n\n\tif (likely(get_page_unless_zero(page))) {\n\t\tstruct pagevec *pvec = &get_cpu_var(lru_deactivate_file_pvecs);\n\n\t\tif (!pagevec_add(pvec, page) || PageCompound(page))\n\t\t\tpagevec_lru_move_fn(pvec, lru_deactivate_file_fn, NULL);\n\t\tput_cpu_var(lru_deactivate_file_pvecs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_inode_page",
          "args": [
            "page"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_inode_pages2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "766-769",
          "snippet": "int invalidate_inode_pages2(struct address_space *mapping)\n{\n\treturn invalidate_inode_pages2_range(mapping, 0, -1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nint invalidate_inode_pages2(struct address_space *mapping)\n{\n\treturn invalidate_inode_pages2_range(mapping, 0, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransTail",
          "args": [
            "page"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "page_to_index(page) != index"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_index",
          "args": [
            "page"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_exceptional_entry",
          "args": [
            "mapping",
            "index",
            "page"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_exceptional_entry2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "124-134",
          "snippet": "static int invalidate_exceptional_entry2(struct address_space *mapping,\n\t\t\t\t\t pgoff_t index, void *entry)\n{\n\t/* Handled by shmem itself */\n\tif (shmem_mapping(mapping))\n\t\treturn 1;\n\tif (dax_mapping(mapping))\n\t\treturn dax_invalidate_mapping_entry_sync(mapping, index);\n\tclear_shadow_entry(mapping, index, entry);\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nstatic int invalidate_exceptional_entry2(struct address_space *mapping,\n\t\t\t\t\t pgoff_t index, void *entry)\n{\n\t/* Handled by shmem itself */\n\tif (shmem_mapping(mapping))\n\t\treturn 1;\n\tif (dax_mapping(mapping))\n\t\treturn dax_invalidate_mapping_entry_sync(mapping, index);\n\tclear_shadow_entry(mapping, index, entry);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "page"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "&pvec"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lookup_entries",
          "args": [
            "&pvec",
            "mapping",
            "index",
            "min(end - index, (pgoff_t)PAGEVEC_SIZE - 1) + 1",
            "indices"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "pagevec_lookup_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "942-950",
          "snippet": "unsigned pagevec_lookup_entries(struct pagevec *pvec,\n\t\t\t\tstruct address_space *mapping,\n\t\t\t\tpgoff_t start, unsigned nr_entries,\n\t\t\t\tpgoff_t *indices)\n{\n\tpvec->nr = find_get_entries(mapping, start, nr_entries,\n\t\t\t\t    pvec->pages, indices);\n\treturn pagevec_count(pvec);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nunsigned pagevec_lookup_entries(struct pagevec *pvec,\n\t\t\t\tstruct address_space *mapping,\n\t\t\t\tpgoff_t start, unsigned nr_entries,\n\t\t\t\tpgoff_t *indices)\n{\n\tpvec->nr = find_get_entries(mapping, start, nr_entries,\n\t\t\t\t    pvec->pages, indices);\n\treturn pagevec_count(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "end - index",
            "(pgoff_t)PAGEVEC_SIZE - 1"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nunsigned long invalidate_mapping_pages(struct address_space *mapping,\n\t\tpgoff_t start, pgoff_t end)\n{\n\tpgoff_t indices[PAGEVEC_SIZE];\n\tstruct pagevec pvec;\n\tpgoff_t index = start;\n\tunsigned long ret;\n\tunsigned long count = 0;\n\tint i;\n\n\tpagevec_init(&pvec);\n\twhile (index <= end && pagevec_lookup_entries(&pvec, mapping, index,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE - 1) + 1,\n\t\t\tindices)) {\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* We rely upon deletion not changing page->index */\n\t\t\tindex = indices[i];\n\t\t\tif (index > end)\n\t\t\t\tbreak;\n\n\t\t\tif (xa_is_value(page)) {\n\t\t\t\tinvalidate_exceptional_entry(mapping, index,\n\t\t\t\t\t\t\t     page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!trylock_page(page))\n\t\t\t\tcontinue;\n\n\t\t\tWARN_ON(page_to_index(page) != index);\n\n\t\t\t/* Middle of THP: skip */\n\t\t\tif (PageTransTail(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t} else if (PageTransHuge(page)) {\n\t\t\t\tindex += HPAGE_PMD_NR - 1;\n\t\t\t\ti += HPAGE_PMD_NR - 1;\n\t\t\t\t/*\n\t\t\t\t * 'end' is in the middle of THP. Don't\n\t\t\t\t * invalidate the page as the part outside of\n\t\t\t\t * 'end' could be still useful.\n\t\t\t\t */\n\t\t\t\tif (index > end) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = invalidate_inode_page(page);\n\t\t\tunlock_page(page);\n\t\t\t/*\n\t\t\t * Invalidation is a hint that the page is no longer\n\t\t\t * of interest and try to speed up its reclaim.\n\t\t\t */\n\t\t\tif (!ret)\n\t\t\t\tdeactivate_file_page(page);\n\t\t\tcount += ret;\n\t\t}\n\t\tpagevec_remove_exceptionals(&pvec);\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t\tindex++;\n\t}\n\treturn count;\n}"
  },
  {
    "function_name": "truncate_inode_pages_final",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
    "lines": "488-527",
    "snippet": "void truncate_inode_pages_final(struct address_space *mapping)\n{\n\tunsigned long nrexceptional;\n\tunsigned long nrpages;\n\n\t/*\n\t * Page reclaim can not participate in regular inode lifetime\n\t * management (can't call iput()) and thus can race with the\n\t * inode teardown.  Tell it when the address space is exiting,\n\t * so that it does not install eviction information after the\n\t * final truncate has begun.\n\t */\n\tmapping_set_exiting(mapping);\n\n\t/*\n\t * When reclaim installs eviction entries, it increases\n\t * nrexceptional first, then decreases nrpages.  Make sure we see\n\t * this in the right order or we might miss an entry.\n\t */\n\tnrpages = mapping->nrpages;\n\tsmp_rmb();\n\tnrexceptional = mapping->nrexceptional;\n\n\tif (nrpages || nrexceptional) {\n\t\t/*\n\t\t * As truncation uses a lockless tree lookup, cycle\n\t\t * the tree lock to make sure any ongoing tree\n\t\t * modification that does not see AS_EXITING is\n\t\t * completed before starting the final truncate.\n\t\t */\n\t\txa_lock_irq(&mapping->i_pages);\n\t\txa_unlock_irq(&mapping->i_pages);\n\t}\n\n\t/*\n\t * Cleancache needs notification even if there are no pages or shadow\n\t * entries.\n\t */\n\ttruncate_inode_pages(mapping, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/rmap.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "mapping",
            "0"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_inode_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "473-476",
          "snippet": "void truncate_inode_pages(struct address_space *mapping, loff_t lstart)\n{\n\ttruncate_inode_pages_range(mapping, lstart, (loff_t)-1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nvoid truncate_inode_pages(struct address_space *mapping, loff_t lstart)\n{\n\ttruncate_inode_pages_range(mapping, lstart, (loff_t)-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xa_unlock_irq",
          "args": [
            "&mapping->i_pages"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_lock_irq",
          "args": [
            "&mapping->i_pages"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_exiting",
          "args": [
            "mapping"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nvoid truncate_inode_pages_final(struct address_space *mapping)\n{\n\tunsigned long nrexceptional;\n\tunsigned long nrpages;\n\n\t/*\n\t * Page reclaim can not participate in regular inode lifetime\n\t * management (can't call iput()) and thus can race with the\n\t * inode teardown.  Tell it when the address space is exiting,\n\t * so that it does not install eviction information after the\n\t * final truncate has begun.\n\t */\n\tmapping_set_exiting(mapping);\n\n\t/*\n\t * When reclaim installs eviction entries, it increases\n\t * nrexceptional first, then decreases nrpages.  Make sure we see\n\t * this in the right order or we might miss an entry.\n\t */\n\tnrpages = mapping->nrpages;\n\tsmp_rmb();\n\tnrexceptional = mapping->nrexceptional;\n\n\tif (nrpages || nrexceptional) {\n\t\t/*\n\t\t * As truncation uses a lockless tree lookup, cycle\n\t\t * the tree lock to make sure any ongoing tree\n\t\t * modification that does not see AS_EXITING is\n\t\t * completed before starting the final truncate.\n\t\t */\n\t\txa_lock_irq(&mapping->i_pages);\n\t\txa_unlock_irq(&mapping->i_pages);\n\t}\n\n\t/*\n\t * Cleancache needs notification even if there are no pages or shadow\n\t * entries.\n\t */\n\ttruncate_inode_pages(mapping, 0);\n}"
  },
  {
    "function_name": "truncate_inode_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
    "lines": "473-476",
    "snippet": "void truncate_inode_pages(struct address_space *mapping, loff_t lstart)\n{\n\ttruncate_inode_pages_range(mapping, lstart, (loff_t)-1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/rmap.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truncate_inode_pages_range",
          "args": [
            "mapping",
            "lstart",
            "(loff_t)-1"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_inode_pages_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "290-458",
          "snippet": "void truncate_inode_pages_range(struct address_space *mapping,\n\t\t\t\tloff_t lstart, loff_t lend)\n{\n\tpgoff_t\t\tstart;\t\t/* inclusive */\n\tpgoff_t\t\tend;\t\t/* exclusive */\n\tunsigned int\tpartial_start;\t/* inclusive */\n\tunsigned int\tpartial_end;\t/* exclusive */\n\tstruct pagevec\tpvec;\n\tpgoff_t\t\tindices[PAGEVEC_SIZE];\n\tpgoff_t\t\tindex;\n\tint\t\ti;\n\n\tif (mapping->nrpages == 0 && mapping->nrexceptional == 0)\n\t\tgoto out;\n\n\t/* Offsets within partial pages */\n\tpartial_start = lstart & (PAGE_SIZE - 1);\n\tpartial_end = (lend + 1) & (PAGE_SIZE - 1);\n\n\t/*\n\t * 'start' and 'end' always covers the range of pages to be fully\n\t * truncated. Partial pages are covered with 'partial_start' at the\n\t * start of the range and 'partial_end' at the end of the range.\n\t * Note that 'end' is exclusive while 'lend' is inclusive.\n\t */\n\tstart = (lstart + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (lend == -1)\n\t\t/*\n\t\t * lend == -1 indicates end-of-file so we have to set 'end'\n\t\t * to the highest possible pgoff_t and since the type is\n\t\t * unsigned we're using -1.\n\t\t */\n\t\tend = -1;\n\telse\n\t\tend = (lend + 1) >> PAGE_SHIFT;\n\n\tpagevec_init(&pvec);\n\tindex = start;\n\twhile (index < end && pagevec_lookup_entries(&pvec, mapping, index,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE),\n\t\t\tindices)) {\n\t\t/*\n\t\t * Pagevec array has exceptional entries and we may also fail\n\t\t * to lock some pages. So we store pages that can be deleted\n\t\t * in a new pagevec.\n\t\t */\n\t\tstruct pagevec locked_pvec;\n\n\t\tpagevec_init(&locked_pvec);\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* We rely upon deletion not changing page->index */\n\t\t\tindex = indices[i];\n\t\t\tif (index >= end)\n\t\t\t\tbreak;\n\n\t\t\tif (xa_is_value(page))\n\t\t\t\tcontinue;\n\n\t\t\tif (!trylock_page(page))\n\t\t\t\tcontinue;\n\t\t\tWARN_ON(page_to_index(page) != index);\n\t\t\tif (PageWriteback(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (page->mapping != mapping) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpagevec_add(&locked_pvec, page);\n\t\t}\n\t\tfor (i = 0; i < pagevec_count(&locked_pvec); i++)\n\t\t\ttruncate_cleanup_page(mapping, locked_pvec.pages[i]);\n\t\tdelete_from_page_cache_batch(mapping, &locked_pvec);\n\t\tfor (i = 0; i < pagevec_count(&locked_pvec); i++)\n\t\t\tunlock_page(locked_pvec.pages[i]);\n\t\ttruncate_exceptional_pvec_entries(mapping, &pvec, indices, end);\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t\tindex++;\n\t}\n\tif (partial_start) {\n\t\tstruct page *page = find_lock_page(mapping, start - 1);\n\t\tif (page) {\n\t\t\tunsigned int top = PAGE_SIZE;\n\t\t\tif (start > end) {\n\t\t\t\t/* Truncation within a single page */\n\t\t\t\ttop = partial_end;\n\t\t\t\tpartial_end = 0;\n\t\t\t}\n\t\t\twait_on_page_writeback(page);\n\t\t\tzero_user_segment(page, partial_start, top);\n\t\t\tcleancache_invalidate_page(mapping, page);\n\t\t\tif (page_has_private(page))\n\t\t\t\tdo_invalidatepage(page, partial_start,\n\t\t\t\t\t\t  top - partial_start);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t}\n\t}\n\tif (partial_end) {\n\t\tstruct page *page = find_lock_page(mapping, end);\n\t\tif (page) {\n\t\t\twait_on_page_writeback(page);\n\t\t\tzero_user_segment(page, 0, partial_end);\n\t\t\tcleancache_invalidate_page(mapping, page);\n\t\t\tif (page_has_private(page))\n\t\t\t\tdo_invalidatepage(page, 0,\n\t\t\t\t\t\t  partial_end);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t}\n\t}\n\t/*\n\t * If the truncation happened within a single page no pages\n\t * will be released, just zeroed, so we can bail out now.\n\t */\n\tif (start >= end)\n\t\tgoto out;\n\n\tindex = start;\n\tfor ( ; ; ) {\n\t\tcond_resched();\n\t\tif (!pagevec_lookup_entries(&pvec, mapping, index,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE), indices)) {\n\t\t\t/* If all gone from start onwards, we're done */\n\t\t\tif (index == start)\n\t\t\t\tbreak;\n\t\t\t/* Otherwise restart to make sure all gone */\n\t\t\tindex = start;\n\t\t\tcontinue;\n\t\t}\n\t\tif (index == start && indices[0] >= end) {\n\t\t\t/* All gone out of hole to be punched, we're done */\n\t\t\tpagevec_remove_exceptionals(&pvec);\n\t\t\tpagevec_release(&pvec);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* We rely upon deletion not changing page->index */\n\t\t\tindex = indices[i];\n\t\t\tif (index >= end) {\n\t\t\t\t/* Restart punch to make sure all gone */\n\t\t\t\tindex = start - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (xa_is_value(page))\n\t\t\t\tcontinue;\n\n\t\t\tlock_page(page);\n\t\t\tWARN_ON(page_to_index(page) != index);\n\t\t\twait_on_page_writeback(page);\n\t\t\ttruncate_inode_page(mapping, page);\n\t\t\tunlock_page(page);\n\t\t}\n\t\ttruncate_exceptional_pvec_entries(mapping, &pvec, indices, end);\n\t\tpagevec_release(&pvec);\n\t\tindex++;\n\t}\n\nout:\n\tcleancache_invalidate_inode(mapping);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nvoid truncate_inode_pages_range(struct address_space *mapping,\n\t\t\t\tloff_t lstart, loff_t lend)\n{\n\tpgoff_t\t\tstart;\t\t/* inclusive */\n\tpgoff_t\t\tend;\t\t/* exclusive */\n\tunsigned int\tpartial_start;\t/* inclusive */\n\tunsigned int\tpartial_end;\t/* exclusive */\n\tstruct pagevec\tpvec;\n\tpgoff_t\t\tindices[PAGEVEC_SIZE];\n\tpgoff_t\t\tindex;\n\tint\t\ti;\n\n\tif (mapping->nrpages == 0 && mapping->nrexceptional == 0)\n\t\tgoto out;\n\n\t/* Offsets within partial pages */\n\tpartial_start = lstart & (PAGE_SIZE - 1);\n\tpartial_end = (lend + 1) & (PAGE_SIZE - 1);\n\n\t/*\n\t * 'start' and 'end' always covers the range of pages to be fully\n\t * truncated. Partial pages are covered with 'partial_start' at the\n\t * start of the range and 'partial_end' at the end of the range.\n\t * Note that 'end' is exclusive while 'lend' is inclusive.\n\t */\n\tstart = (lstart + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (lend == -1)\n\t\t/*\n\t\t * lend == -1 indicates end-of-file so we have to set 'end'\n\t\t * to the highest possible pgoff_t and since the type is\n\t\t * unsigned we're using -1.\n\t\t */\n\t\tend = -1;\n\telse\n\t\tend = (lend + 1) >> PAGE_SHIFT;\n\n\tpagevec_init(&pvec);\n\tindex = start;\n\twhile (index < end && pagevec_lookup_entries(&pvec, mapping, index,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE),\n\t\t\tindices)) {\n\t\t/*\n\t\t * Pagevec array has exceptional entries and we may also fail\n\t\t * to lock some pages. So we store pages that can be deleted\n\t\t * in a new pagevec.\n\t\t */\n\t\tstruct pagevec locked_pvec;\n\n\t\tpagevec_init(&locked_pvec);\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* We rely upon deletion not changing page->index */\n\t\t\tindex = indices[i];\n\t\t\tif (index >= end)\n\t\t\t\tbreak;\n\n\t\t\tif (xa_is_value(page))\n\t\t\t\tcontinue;\n\n\t\t\tif (!trylock_page(page))\n\t\t\t\tcontinue;\n\t\t\tWARN_ON(page_to_index(page) != index);\n\t\t\tif (PageWriteback(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (page->mapping != mapping) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpagevec_add(&locked_pvec, page);\n\t\t}\n\t\tfor (i = 0; i < pagevec_count(&locked_pvec); i++)\n\t\t\ttruncate_cleanup_page(mapping, locked_pvec.pages[i]);\n\t\tdelete_from_page_cache_batch(mapping, &locked_pvec);\n\t\tfor (i = 0; i < pagevec_count(&locked_pvec); i++)\n\t\t\tunlock_page(locked_pvec.pages[i]);\n\t\ttruncate_exceptional_pvec_entries(mapping, &pvec, indices, end);\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t\tindex++;\n\t}\n\tif (partial_start) {\n\t\tstruct page *page = find_lock_page(mapping, start - 1);\n\t\tif (page) {\n\t\t\tunsigned int top = PAGE_SIZE;\n\t\t\tif (start > end) {\n\t\t\t\t/* Truncation within a single page */\n\t\t\t\ttop = partial_end;\n\t\t\t\tpartial_end = 0;\n\t\t\t}\n\t\t\twait_on_page_writeback(page);\n\t\t\tzero_user_segment(page, partial_start, top);\n\t\t\tcleancache_invalidate_page(mapping, page);\n\t\t\tif (page_has_private(page))\n\t\t\t\tdo_invalidatepage(page, partial_start,\n\t\t\t\t\t\t  top - partial_start);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t}\n\t}\n\tif (partial_end) {\n\t\tstruct page *page = find_lock_page(mapping, end);\n\t\tif (page) {\n\t\t\twait_on_page_writeback(page);\n\t\t\tzero_user_segment(page, 0, partial_end);\n\t\t\tcleancache_invalidate_page(mapping, page);\n\t\t\tif (page_has_private(page))\n\t\t\t\tdo_invalidatepage(page, 0,\n\t\t\t\t\t\t  partial_end);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t}\n\t}\n\t/*\n\t * If the truncation happened within a single page no pages\n\t * will be released, just zeroed, so we can bail out now.\n\t */\n\tif (start >= end)\n\t\tgoto out;\n\n\tindex = start;\n\tfor ( ; ; ) {\n\t\tcond_resched();\n\t\tif (!pagevec_lookup_entries(&pvec, mapping, index,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE), indices)) {\n\t\t\t/* If all gone from start onwards, we're done */\n\t\t\tif (index == start)\n\t\t\t\tbreak;\n\t\t\t/* Otherwise restart to make sure all gone */\n\t\t\tindex = start;\n\t\t\tcontinue;\n\t\t}\n\t\tif (index == start && indices[0] >= end) {\n\t\t\t/* All gone out of hole to be punched, we're done */\n\t\t\tpagevec_remove_exceptionals(&pvec);\n\t\t\tpagevec_release(&pvec);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* We rely upon deletion not changing page->index */\n\t\t\tindex = indices[i];\n\t\t\tif (index >= end) {\n\t\t\t\t/* Restart punch to make sure all gone */\n\t\t\t\tindex = start - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (xa_is_value(page))\n\t\t\t\tcontinue;\n\n\t\t\tlock_page(page);\n\t\t\tWARN_ON(page_to_index(page) != index);\n\t\t\twait_on_page_writeback(page);\n\t\t\ttruncate_inode_page(mapping, page);\n\t\t\tunlock_page(page);\n\t\t}\n\t\ttruncate_exceptional_pvec_entries(mapping, &pvec, indices, end);\n\t\tpagevec_release(&pvec);\n\t\tindex++;\n\t}\n\nout:\n\tcleancache_invalidate_inode(mapping);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nvoid truncate_inode_pages(struct address_space *mapping, loff_t lstart)\n{\n\ttruncate_inode_pages_range(mapping, lstart, (loff_t)-1);\n}"
  },
  {
    "function_name": "truncate_inode_pages_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
    "lines": "290-458",
    "snippet": "void truncate_inode_pages_range(struct address_space *mapping,\n\t\t\t\tloff_t lstart, loff_t lend)\n{\n\tpgoff_t\t\tstart;\t\t/* inclusive */\n\tpgoff_t\t\tend;\t\t/* exclusive */\n\tunsigned int\tpartial_start;\t/* inclusive */\n\tunsigned int\tpartial_end;\t/* exclusive */\n\tstruct pagevec\tpvec;\n\tpgoff_t\t\tindices[PAGEVEC_SIZE];\n\tpgoff_t\t\tindex;\n\tint\t\ti;\n\n\tif (mapping->nrpages == 0 && mapping->nrexceptional == 0)\n\t\tgoto out;\n\n\t/* Offsets within partial pages */\n\tpartial_start = lstart & (PAGE_SIZE - 1);\n\tpartial_end = (lend + 1) & (PAGE_SIZE - 1);\n\n\t/*\n\t * 'start' and 'end' always covers the range of pages to be fully\n\t * truncated. Partial pages are covered with 'partial_start' at the\n\t * start of the range and 'partial_end' at the end of the range.\n\t * Note that 'end' is exclusive while 'lend' is inclusive.\n\t */\n\tstart = (lstart + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (lend == -1)\n\t\t/*\n\t\t * lend == -1 indicates end-of-file so we have to set 'end'\n\t\t * to the highest possible pgoff_t and since the type is\n\t\t * unsigned we're using -1.\n\t\t */\n\t\tend = -1;\n\telse\n\t\tend = (lend + 1) >> PAGE_SHIFT;\n\n\tpagevec_init(&pvec);\n\tindex = start;\n\twhile (index < end && pagevec_lookup_entries(&pvec, mapping, index,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE),\n\t\t\tindices)) {\n\t\t/*\n\t\t * Pagevec array has exceptional entries and we may also fail\n\t\t * to lock some pages. So we store pages that can be deleted\n\t\t * in a new pagevec.\n\t\t */\n\t\tstruct pagevec locked_pvec;\n\n\t\tpagevec_init(&locked_pvec);\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* We rely upon deletion not changing page->index */\n\t\t\tindex = indices[i];\n\t\t\tif (index >= end)\n\t\t\t\tbreak;\n\n\t\t\tif (xa_is_value(page))\n\t\t\t\tcontinue;\n\n\t\t\tif (!trylock_page(page))\n\t\t\t\tcontinue;\n\t\t\tWARN_ON(page_to_index(page) != index);\n\t\t\tif (PageWriteback(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (page->mapping != mapping) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpagevec_add(&locked_pvec, page);\n\t\t}\n\t\tfor (i = 0; i < pagevec_count(&locked_pvec); i++)\n\t\t\ttruncate_cleanup_page(mapping, locked_pvec.pages[i]);\n\t\tdelete_from_page_cache_batch(mapping, &locked_pvec);\n\t\tfor (i = 0; i < pagevec_count(&locked_pvec); i++)\n\t\t\tunlock_page(locked_pvec.pages[i]);\n\t\ttruncate_exceptional_pvec_entries(mapping, &pvec, indices, end);\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t\tindex++;\n\t}\n\tif (partial_start) {\n\t\tstruct page *page = find_lock_page(mapping, start - 1);\n\t\tif (page) {\n\t\t\tunsigned int top = PAGE_SIZE;\n\t\t\tif (start > end) {\n\t\t\t\t/* Truncation within a single page */\n\t\t\t\ttop = partial_end;\n\t\t\t\tpartial_end = 0;\n\t\t\t}\n\t\t\twait_on_page_writeback(page);\n\t\t\tzero_user_segment(page, partial_start, top);\n\t\t\tcleancache_invalidate_page(mapping, page);\n\t\t\tif (page_has_private(page))\n\t\t\t\tdo_invalidatepage(page, partial_start,\n\t\t\t\t\t\t  top - partial_start);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t}\n\t}\n\tif (partial_end) {\n\t\tstruct page *page = find_lock_page(mapping, end);\n\t\tif (page) {\n\t\t\twait_on_page_writeback(page);\n\t\t\tzero_user_segment(page, 0, partial_end);\n\t\t\tcleancache_invalidate_page(mapping, page);\n\t\t\tif (page_has_private(page))\n\t\t\t\tdo_invalidatepage(page, 0,\n\t\t\t\t\t\t  partial_end);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t}\n\t}\n\t/*\n\t * If the truncation happened within a single page no pages\n\t * will be released, just zeroed, so we can bail out now.\n\t */\n\tif (start >= end)\n\t\tgoto out;\n\n\tindex = start;\n\tfor ( ; ; ) {\n\t\tcond_resched();\n\t\tif (!pagevec_lookup_entries(&pvec, mapping, index,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE), indices)) {\n\t\t\t/* If all gone from start onwards, we're done */\n\t\t\tif (index == start)\n\t\t\t\tbreak;\n\t\t\t/* Otherwise restart to make sure all gone */\n\t\t\tindex = start;\n\t\t\tcontinue;\n\t\t}\n\t\tif (index == start && indices[0] >= end) {\n\t\t\t/* All gone out of hole to be punched, we're done */\n\t\t\tpagevec_remove_exceptionals(&pvec);\n\t\t\tpagevec_release(&pvec);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* We rely upon deletion not changing page->index */\n\t\t\tindex = indices[i];\n\t\t\tif (index >= end) {\n\t\t\t\t/* Restart punch to make sure all gone */\n\t\t\t\tindex = start - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (xa_is_value(page))\n\t\t\t\tcontinue;\n\n\t\t\tlock_page(page);\n\t\t\tWARN_ON(page_to_index(page) != index);\n\t\t\twait_on_page_writeback(page);\n\t\t\ttruncate_inode_page(mapping, page);\n\t\t\tunlock_page(page);\n\t\t}\n\t\ttruncate_exceptional_pvec_entries(mapping, &pvec, indices, end);\n\t\tpagevec_release(&pvec);\n\t\tindex++;\n\t}\n\nout:\n\tcleancache_invalidate_inode(mapping);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/rmap.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleancache_invalidate_inode",
          "args": [
            "mapping"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "__cleancache_invalidate_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cleancache.c",
          "lines": "274-284",
          "snippet": "void __cleancache_invalidate_inode(struct address_space *mapping)\n{\n\tint pool_id = mapping->host->i_sb->cleancache_poolid;\n\tstruct cleancache_filekey key = { .u.key = { 0 } };\n\n\tif (!cleancache_ops)\n\t\treturn;\n\n\tif (pool_id >= 0 && cleancache_get_key(mapping->host, &key) >= 0)\n\t\tcleancache_ops->invalidate_inode(pool_id, key);\n}",
          "includes": [
            "#include <linux/cleancache.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/mm.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct cleancache_ops *cleancache_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cleancache.h>\n#include <linux/debugfs.h>\n#include <linux/mm.h>\n#include <linux/exportfs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct cleancache_ops *cleancache_ops;\n\nvoid __cleancache_invalidate_inode(struct address_space *mapping)\n{\n\tint pool_id = mapping->host->i_sb->cleancache_poolid;\n\tstruct cleancache_filekey key = { .u.key = { 0 } };\n\n\tif (!cleancache_ops)\n\t\treturn;\n\n\tif (pool_id >= 0 && cleancache_get_key(mapping->host, &key) >= 0)\n\t\tcleancache_ops->invalidate_inode(pool_id, key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "__pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "805-813",
          "snippet": "void __pagevec_release(struct pagevec *pvec)\n{\n\tif (!pvec->percpu_pvec_drained) {\n\t\tlru_add_drain();\n\t\tpvec->percpu_pvec_drained = true;\n\t}\n\trelease_pages(pvec->pages, pagevec_count(pvec));\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid __pagevec_release(struct pagevec *pvec)\n{\n\tif (!pvec->percpu_pvec_drained) {\n\t\tlru_add_drain();\n\t\tpvec->percpu_pvec_drained = true;\n\t}\n\trelease_pages(pvec->pages, pagevec_count(pvec));\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_exceptional_pvec_entries",
          "args": [
            "mapping",
            "&pvec",
            "indices",
            "end"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_exceptional_pvec_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "58-104",
          "snippet": "static void truncate_exceptional_pvec_entries(struct address_space *mapping,\n\t\t\t\tstruct pagevec *pvec, pgoff_t *indices,\n\t\t\t\tpgoff_t end)\n{\n\tint i, j;\n\tbool dax, lock;\n\n\t/* Handled by shmem itself */\n\tif (shmem_mapping(mapping))\n\t\treturn;\n\n\tfor (j = 0; j < pagevec_count(pvec); j++)\n\t\tif (xa_is_value(pvec->pages[j]))\n\t\t\tbreak;\n\n\tif (j == pagevec_count(pvec))\n\t\treturn;\n\n\tdax = dax_mapping(mapping);\n\tlock = !dax && indices[j] < end;\n\tif (lock)\n\t\txa_lock_irq(&mapping->i_pages);\n\n\tfor (i = j; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tpgoff_t index = indices[i];\n\n\t\tif (!xa_is_value(page)) {\n\t\t\tpvec->pages[j++] = page;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (index >= end)\n\t\t\tcontinue;\n\n\t\tif (unlikely(dax)) {\n\t\t\tdax_delete_mapping_entry(mapping, index);\n\t\t\tcontinue;\n\t\t}\n\n\t\t__clear_shadow_entry(mapping, index, page);\n\t}\n\n\tif (lock)\n\t\txa_unlock_irq(&mapping->i_pages);\n\tpvec->nr = j;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nstatic void truncate_exceptional_pvec_entries(struct address_space *mapping,\n\t\t\t\tstruct pagevec *pvec, pgoff_t *indices,\n\t\t\t\tpgoff_t end)\n{\n\tint i, j;\n\tbool dax, lock;\n\n\t/* Handled by shmem itself */\n\tif (shmem_mapping(mapping))\n\t\treturn;\n\n\tfor (j = 0; j < pagevec_count(pvec); j++)\n\t\tif (xa_is_value(pvec->pages[j]))\n\t\t\tbreak;\n\n\tif (j == pagevec_count(pvec))\n\t\treturn;\n\n\tdax = dax_mapping(mapping);\n\tlock = !dax && indices[j] < end;\n\tif (lock)\n\t\txa_lock_irq(&mapping->i_pages);\n\n\tfor (i = j; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tpgoff_t index = indices[i];\n\n\t\tif (!xa_is_value(page)) {\n\t\t\tpvec->pages[j++] = page;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (index >= end)\n\t\t\tcontinue;\n\n\t\tif (unlikely(dax)) {\n\t\t\tdax_delete_mapping_entry(mapping, index);\n\t\t\tcontinue;\n\t\t}\n\n\t\t__clear_shadow_entry(mapping, index, page);\n\t}\n\n\tif (lock)\n\t\txa_unlock_irq(&mapping->i_pages);\n\tpvec->nr = j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_page",
          "args": [
            "mapping",
            "page"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_inode_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "473-476",
          "snippet": "void truncate_inode_pages(struct address_space *mapping, loff_t lstart)\n{\n\ttruncate_inode_pages_range(mapping, lstart, (loff_t)-1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nvoid truncate_inode_pages(struct address_space *mapping, loff_t lstart)\n{\n\ttruncate_inode_pages_range(mapping, lstart, (loff_t)-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "page_to_index(page) != index"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_index",
          "args": [
            "page"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "page"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "&pvec"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_remove_exceptionals",
          "args": [
            "&pvec"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "pagevec_remove_exceptionals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "961-971",
          "snippet": "void pagevec_remove_exceptionals(struct pagevec *pvec)\n{\n\tint i, j;\n\n\tfor (i = 0, j = 0; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tif (!xa_is_value(page))\n\t\t\tpvec->pages[j++] = page;\n\t}\n\tpvec->nr = j;\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid pagevec_remove_exceptionals(struct pagevec *pvec)\n{\n\tint i, j;\n\n\tfor (i = 0, j = 0; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tif (!xa_is_value(page))\n\t\t\tpvec->pages[j++] = page;\n\t}\n\tpvec->nr = j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_lookup_entries",
          "args": [
            "&pvec",
            "mapping",
            "index",
            "min(end - index, (pgoff_t)PAGEVEC_SIZE)",
            "indices"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "pagevec_lookup_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "942-950",
          "snippet": "unsigned pagevec_lookup_entries(struct pagevec *pvec,\n\t\t\t\tstruct address_space *mapping,\n\t\t\t\tpgoff_t start, unsigned nr_entries,\n\t\t\t\tpgoff_t *indices)\n{\n\tpvec->nr = find_get_entries(mapping, start, nr_entries,\n\t\t\t\t    pvec->pages, indices);\n\treturn pagevec_count(pvec);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nunsigned pagevec_lookup_entries(struct pagevec *pvec,\n\t\t\t\tstruct address_space *mapping,\n\t\t\t\tpgoff_t start, unsigned nr_entries,\n\t\t\t\tpgoff_t *indices)\n{\n\tpvec->nr = find_get_entries(mapping, start, nr_entries,\n\t\t\t\t    pvec->pages, indices);\n\treturn pagevec_count(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "end - index",
            "(pgoff_t)PAGEVEC_SIZE"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_invalidatepage",
          "args": [
            "page",
            "0",
            "partial_end"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "do_invalidatepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "151-163",
          "snippet": "void do_invalidatepage(struct page *page, unsigned int offset,\n\t\t       unsigned int length)\n{\n\tvoid (*invalidatepage)(struct page *, unsigned int, unsigned int);\n\n\tinvalidatepage = page->mapping->a_ops->invalidatepage;\n#ifdef CONFIG_BLOCK\n\tif (!invalidatepage)\n\t\tinvalidatepage = block_invalidatepage;\n#endif\n\tif (invalidatepage)\n\t\t(*invalidatepage)(page, offset, length);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nvoid do_invalidatepage(struct page *page, unsigned int offset,\n\t\t       unsigned int length)\n{\n\tvoid (*invalidatepage)(struct page *, unsigned int, unsigned int);\n\n\tinvalidatepage = page->mapping->a_ops->invalidatepage;\n#ifdef CONFIG_BLOCK\n\tif (!invalidatepage)\n\t\tinvalidatepage = block_invalidatepage;\n#endif\n\tif (invalidatepage)\n\t\t(*invalidatepage)(page, offset, length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "page"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cleancache_invalidate_page",
          "args": [
            "mapping",
            "page"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "__cleancache_invalidate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cleancache.c",
          "lines": "244-262",
          "snippet": "void __cleancache_invalidate_page(struct address_space *mapping,\n\t\t\t\t\tstruct page *page)\n{\n\t/* careful... page->mapping is NULL sometimes when this is called */\n\tint pool_id = mapping->host->i_sb->cleancache_poolid;\n\tstruct cleancache_filekey key = { .u.key = { 0 } };\n\n\tif (!cleancache_ops)\n\t\treturn;\n\n\tif (pool_id >= 0) {\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tif (cleancache_get_key(mapping->host, &key) >= 0) {\n\t\t\tcleancache_ops->invalidate_page(pool_id,\n\t\t\t\t\tkey, page->index);\n\t\t\tcleancache_invalidates++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/cleancache.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/mm.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct cleancache_ops *cleancache_ops",
            "static u64 cleancache_invalidates;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cleancache.h>\n#include <linux/debugfs.h>\n#include <linux/mm.h>\n#include <linux/exportfs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct cleancache_ops *cleancache_ops;\nstatic u64 cleancache_invalidates;\n\nvoid __cleancache_invalidate_page(struct address_space *mapping,\n\t\t\t\t\tstruct page *page)\n{\n\t/* careful... page->mapping is NULL sometimes when this is called */\n\tint pool_id = mapping->host->i_sb->cleancache_poolid;\n\tstruct cleancache_filekey key = { .u.key = { 0 } };\n\n\tif (!cleancache_ops)\n\t\treturn;\n\n\tif (pool_id >= 0) {\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tif (cleancache_get_key(mapping->host, &key) >= 0) {\n\t\t\tcleancache_ops->invalidate_page(pool_id,\n\t\t\t\t\tkey, page->index);\n\t\t\tcleancache_invalidates++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "0",
            "partial_end"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lock_page",
          "args": [
            "mapping",
            "end"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "page"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "partial_start",
            "top"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lock_page",
          "args": [
            "mapping",
            "start - 1"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "&locked_pvec"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delete_from_page_cache_batch",
          "args": [
            "mapping",
            "&locked_pvec"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "delete_from_page_cache_batch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "335-355",
          "snippet": "void delete_from_page_cache_batch(struct address_space *mapping,\n\t\t\t\t  struct pagevec *pvec)\n{\n\tint i;\n\tunsigned long flags;\n\n\tif (!pagevec_count(pvec))\n\t\treturn;\n\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\tfor (i = 0; i < pagevec_count(pvec); i++) {\n\t\ttrace_mm_filemap_delete_from_page_cache(pvec->pages[i]);\n\n\t\tunaccount_page_cache_page(mapping, pvec->pages[i]);\n\t}\n\tpage_cache_delete_batch(mapping, pvec);\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\n\tfor (i = 0; i < pagevec_count(pvec); i++)\n\t\tpage_cache_free_page(mapping, pvec->pages[i]);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid delete_from_page_cache_batch(struct address_space *mapping,\n\t\t\t\t  struct pagevec *pvec)\n{\n\tint i;\n\tunsigned long flags;\n\n\tif (!pagevec_count(pvec))\n\t\treturn;\n\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\tfor (i = 0; i < pagevec_count(pvec); i++) {\n\t\ttrace_mm_filemap_delete_from_page_cache(pvec->pages[i]);\n\n\t\tunaccount_page_cache_page(mapping, pvec->pages[i]);\n\t}\n\tpage_cache_delete_batch(mapping, pvec);\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\n\tfor (i = 0; i < pagevec_count(pvec); i++)\n\t\tpage_cache_free_page(mapping, pvec->pages[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_cleanup_page",
          "args": [
            "mapping",
            "locked_pvec.pages[i]"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_cleanup_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "175-193",
          "snippet": "static void\ntruncate_cleanup_page(struct address_space *mapping, struct page *page)\n{\n\tif (page_mapped(page)) {\n\t\tpgoff_t nr = PageTransHuge(page) ? HPAGE_PMD_NR : 1;\n\t\tunmap_mapping_pages(mapping, page->index, nr, false);\n\t}\n\n\tif (page_has_private(page))\n\t\tdo_invalidatepage(page, 0, PAGE_SIZE);\n\n\t/*\n\t * Some filesystems seem to re-dirty the page even after\n\t * the VM has canceled the dirty bit (eg ext3 journaling).\n\t * Hence dirty accounting check is placed after invalidation.\n\t */\n\tcancel_dirty_page(page);\n\tClearPageMappedToDisk(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nstatic void\ntruncate_cleanup_page(struct address_space *mapping, struct page *page)\n{\n\tif (page_mapped(page)) {\n\t\tpgoff_t nr = PageTransHuge(page) ? HPAGE_PMD_NR : 1;\n\t\tunmap_mapping_pages(mapping, page->index, nr, false);\n\t}\n\n\tif (page_has_private(page))\n\t\tdo_invalidatepage(page, 0, PAGE_SIZE);\n\n\t/*\n\t * Some filesystems seem to re-dirty the page even after\n\t * the VM has canceled the dirty bit (eg ext3 journaling).\n\t * Hence dirty accounting check is placed after invalidation.\n\t */\n\tcancel_dirty_page(page);\n\tClearPageMappedToDisk(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "&locked_pvec"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_add",
          "args": [
            "&locked_pvec",
            "page"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "page_to_index(page) != index"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_index",
          "args": [
            "page"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "page"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "&pvec"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&locked_pvec"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nvoid truncate_inode_pages_range(struct address_space *mapping,\n\t\t\t\tloff_t lstart, loff_t lend)\n{\n\tpgoff_t\t\tstart;\t\t/* inclusive */\n\tpgoff_t\t\tend;\t\t/* exclusive */\n\tunsigned int\tpartial_start;\t/* inclusive */\n\tunsigned int\tpartial_end;\t/* exclusive */\n\tstruct pagevec\tpvec;\n\tpgoff_t\t\tindices[PAGEVEC_SIZE];\n\tpgoff_t\t\tindex;\n\tint\t\ti;\n\n\tif (mapping->nrpages == 0 && mapping->nrexceptional == 0)\n\t\tgoto out;\n\n\t/* Offsets within partial pages */\n\tpartial_start = lstart & (PAGE_SIZE - 1);\n\tpartial_end = (lend + 1) & (PAGE_SIZE - 1);\n\n\t/*\n\t * 'start' and 'end' always covers the range of pages to be fully\n\t * truncated. Partial pages are covered with 'partial_start' at the\n\t * start of the range and 'partial_end' at the end of the range.\n\t * Note that 'end' is exclusive while 'lend' is inclusive.\n\t */\n\tstart = (lstart + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (lend == -1)\n\t\t/*\n\t\t * lend == -1 indicates end-of-file so we have to set 'end'\n\t\t * to the highest possible pgoff_t and since the type is\n\t\t * unsigned we're using -1.\n\t\t */\n\t\tend = -1;\n\telse\n\t\tend = (lend + 1) >> PAGE_SHIFT;\n\n\tpagevec_init(&pvec);\n\tindex = start;\n\twhile (index < end && pagevec_lookup_entries(&pvec, mapping, index,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE),\n\t\t\tindices)) {\n\t\t/*\n\t\t * Pagevec array has exceptional entries and we may also fail\n\t\t * to lock some pages. So we store pages that can be deleted\n\t\t * in a new pagevec.\n\t\t */\n\t\tstruct pagevec locked_pvec;\n\n\t\tpagevec_init(&locked_pvec);\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* We rely upon deletion not changing page->index */\n\t\t\tindex = indices[i];\n\t\t\tif (index >= end)\n\t\t\t\tbreak;\n\n\t\t\tif (xa_is_value(page))\n\t\t\t\tcontinue;\n\n\t\t\tif (!trylock_page(page))\n\t\t\t\tcontinue;\n\t\t\tWARN_ON(page_to_index(page) != index);\n\t\t\tif (PageWriteback(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (page->mapping != mapping) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpagevec_add(&locked_pvec, page);\n\t\t}\n\t\tfor (i = 0; i < pagevec_count(&locked_pvec); i++)\n\t\t\ttruncate_cleanup_page(mapping, locked_pvec.pages[i]);\n\t\tdelete_from_page_cache_batch(mapping, &locked_pvec);\n\t\tfor (i = 0; i < pagevec_count(&locked_pvec); i++)\n\t\t\tunlock_page(locked_pvec.pages[i]);\n\t\ttruncate_exceptional_pvec_entries(mapping, &pvec, indices, end);\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t\tindex++;\n\t}\n\tif (partial_start) {\n\t\tstruct page *page = find_lock_page(mapping, start - 1);\n\t\tif (page) {\n\t\t\tunsigned int top = PAGE_SIZE;\n\t\t\tif (start > end) {\n\t\t\t\t/* Truncation within a single page */\n\t\t\t\ttop = partial_end;\n\t\t\t\tpartial_end = 0;\n\t\t\t}\n\t\t\twait_on_page_writeback(page);\n\t\t\tzero_user_segment(page, partial_start, top);\n\t\t\tcleancache_invalidate_page(mapping, page);\n\t\t\tif (page_has_private(page))\n\t\t\t\tdo_invalidatepage(page, partial_start,\n\t\t\t\t\t\t  top - partial_start);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t}\n\t}\n\tif (partial_end) {\n\t\tstruct page *page = find_lock_page(mapping, end);\n\t\tif (page) {\n\t\t\twait_on_page_writeback(page);\n\t\t\tzero_user_segment(page, 0, partial_end);\n\t\t\tcleancache_invalidate_page(mapping, page);\n\t\t\tif (page_has_private(page))\n\t\t\t\tdo_invalidatepage(page, 0,\n\t\t\t\t\t\t  partial_end);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t}\n\t}\n\t/*\n\t * If the truncation happened within a single page no pages\n\t * will be released, just zeroed, so we can bail out now.\n\t */\n\tif (start >= end)\n\t\tgoto out;\n\n\tindex = start;\n\tfor ( ; ; ) {\n\t\tcond_resched();\n\t\tif (!pagevec_lookup_entries(&pvec, mapping, index,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE), indices)) {\n\t\t\t/* If all gone from start onwards, we're done */\n\t\t\tif (index == start)\n\t\t\t\tbreak;\n\t\t\t/* Otherwise restart to make sure all gone */\n\t\t\tindex = start;\n\t\t\tcontinue;\n\t\t}\n\t\tif (index == start && indices[0] >= end) {\n\t\t\t/* All gone out of hole to be punched, we're done */\n\t\t\tpagevec_remove_exceptionals(&pvec);\n\t\t\tpagevec_release(&pvec);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* We rely upon deletion not changing page->index */\n\t\t\tindex = indices[i];\n\t\t\tif (index >= end) {\n\t\t\t\t/* Restart punch to make sure all gone */\n\t\t\t\tindex = start - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (xa_is_value(page))\n\t\t\t\tcontinue;\n\n\t\t\tlock_page(page);\n\t\t\tWARN_ON(page_to_index(page) != index);\n\t\t\twait_on_page_writeback(page);\n\t\t\ttruncate_inode_page(mapping, page);\n\t\t\tunlock_page(page);\n\t\t}\n\t\ttruncate_exceptional_pvec_entries(mapping, &pvec, indices, end);\n\t\tpagevec_release(&pvec);\n\t\tindex++;\n\t}\n\nout:\n\tcleancache_invalidate_inode(mapping);\n}"
  },
  {
    "function_name": "invalidate_inode_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
    "lines": "254-264",
    "snippet": "int invalidate_inode_page(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tif (!mapping)\n\t\treturn 0;\n\tif (PageDirty(page) || PageWriteback(page))\n\t\treturn 0;\n\tif (page_mapped(page))\n\t\treturn 0;\n\treturn invalidate_complete_page(mapping, page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/rmap.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "invalidate_complete_page",
          "args": [
            "mapping",
            "page"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_complete_page2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "620-647",
          "snippet": "static int\ninvalidate_complete_page2(struct address_space *mapping, struct page *page)\n{\n\tunsigned long flags;\n\n\tif (page->mapping != mapping)\n\t\treturn 0;\n\n\tif (page_has_private(page) && !try_to_release_page(page, GFP_KERNEL))\n\t\treturn 0;\n\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\tif (PageDirty(page))\n\t\tgoto failed;\n\n\tBUG_ON(page_has_private(page));\n\t__delete_from_page_cache(page, NULL);\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\n\tif (mapping->a_ops->freepage)\n\t\tmapping->a_ops->freepage(page);\n\n\tput_page(page);\t/* pagecache ref */\n\treturn 1;\nfailed:\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nstatic int\ninvalidate_complete_page2(struct address_space *mapping, struct page *page)\n{\n\tunsigned long flags;\n\n\tif (page->mapping != mapping)\n\t\treturn 0;\n\n\tif (page_has_private(page) && !try_to_release_page(page, GFP_KERNEL))\n\t\treturn 0;\n\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\tif (PageDirty(page))\n\t\tgoto failed;\n\n\tBUG_ON(page_has_private(page));\n\t__delete_from_page_cache(page, NULL);\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\n\tif (mapping->a_ops->freepage)\n\t\tmapping->a_ops->freepage(page);\n\n\tput_page(page);\t/* pagecache ref */\n\treturn 1;\nfailed:\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "page"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "470-486",
          "snippet": "bool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nbool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nint invalidate_inode_page(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tif (!mapping)\n\t\treturn 0;\n\tif (PageDirty(page) || PageWriteback(page))\n\t\treturn 0;\n\tif (page_mapped(page))\n\t\treturn 0;\n\treturn invalidate_complete_page(mapping, page);\n}"
  },
  {
    "function_name": "generic_error_remove_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
    "lines": "234-245",
    "snippet": "int generic_error_remove_page(struct address_space *mapping, struct page *page)\n{\n\tif (!mapping)\n\t\treturn -EINVAL;\n\t/*\n\t * Only punch for normal data pages for now.\n\t * Handling other types like directories would need more auditing.\n\t */\n\tif (!S_ISREG(mapping->host->i_mode))\n\t\treturn -EIO;\n\treturn truncate_inode_page(mapping, page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/rmap.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truncate_inode_page",
          "args": [
            "mapping",
            "page"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_inode_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "473-476",
          "snippet": "void truncate_inode_pages(struct address_space *mapping, loff_t lstart)\n{\n\ttruncate_inode_pages_range(mapping, lstart, (loff_t)-1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nvoid truncate_inode_pages(struct address_space *mapping, loff_t lstart)\n{\n\ttruncate_inode_pages_range(mapping, lstart, (loff_t)-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mapping->host->i_mode"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nint generic_error_remove_page(struct address_space *mapping, struct page *page)\n{\n\tif (!mapping)\n\t\treturn -EINVAL;\n\t/*\n\t * Only punch for normal data pages for now.\n\t * Handling other types like directories would need more auditing.\n\t */\n\tif (!S_ISREG(mapping->host->i_mode))\n\t\treturn -EIO;\n\treturn truncate_inode_page(mapping, page);\n}"
  },
  {
    "function_name": "truncate_inode_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
    "lines": "219-229",
    "snippet": "int truncate_inode_page(struct address_space *mapping, struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\n\tif (page->mapping != mapping)\n\t\treturn -EIO;\n\n\ttruncate_cleanup_page(mapping, page);\n\tdelete_from_page_cache(page);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/rmap.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "delete_from_page_cache",
          "args": [
            "page"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "delete_from_page_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "262-273",
          "snippet": "void delete_from_page_cache(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tunsigned long flags;\n\n\tBUG_ON(!PageLocked(page));\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\t__delete_from_page_cache(page, NULL);\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\n\tpage_cache_free_page(mapping, page);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid delete_from_page_cache(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tunsigned long flags;\n\n\tBUG_ON(!PageLocked(page));\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\t__delete_from_page_cache(page, NULL);\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\n\tpage_cache_free_page(mapping, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_cleanup_page",
          "args": [
            "mapping",
            "page"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_cleanup_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "175-193",
          "snippet": "static void\ntruncate_cleanup_page(struct address_space *mapping, struct page *page)\n{\n\tif (page_mapped(page)) {\n\t\tpgoff_t nr = PageTransHuge(page) ? HPAGE_PMD_NR : 1;\n\t\tunmap_mapping_pages(mapping, page->index, nr, false);\n\t}\n\n\tif (page_has_private(page))\n\t\tdo_invalidatepage(page, 0, PAGE_SIZE);\n\n\t/*\n\t * Some filesystems seem to re-dirty the page even after\n\t * the VM has canceled the dirty bit (eg ext3 journaling).\n\t * Hence dirty accounting check is placed after invalidation.\n\t */\n\tcancel_dirty_page(page);\n\tClearPageMappedToDisk(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nstatic void\ntruncate_cleanup_page(struct address_space *mapping, struct page *page)\n{\n\tif (page_mapped(page)) {\n\t\tpgoff_t nr = PageTransHuge(page) ? HPAGE_PMD_NR : 1;\n\t\tunmap_mapping_pages(mapping, page->index, nr, false);\n\t}\n\n\tif (page_has_private(page))\n\t\tdo_invalidatepage(page, 0, PAGE_SIZE);\n\n\t/*\n\t * Some filesystems seem to re-dirty the page even after\n\t * the VM has canceled the dirty bit (eg ext3 journaling).\n\t * Hence dirty accounting check is placed after invalidation.\n\t */\n\tcancel_dirty_page(page);\n\tClearPageMappedToDisk(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageTail(page)",
            "page"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTail",
          "args": [
            "page"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nint truncate_inode_page(struct address_space *mapping, struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\n\tif (page->mapping != mapping)\n\t\treturn -EIO;\n\n\ttruncate_cleanup_page(mapping, page);\n\tdelete_from_page_cache(page);\n\treturn 0;\n}"
  },
  {
    "function_name": "invalidate_complete_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
    "lines": "203-217",
    "snippet": "static int\ninvalidate_complete_page(struct address_space *mapping, struct page *page)\n{\n\tint ret;\n\n\tif (page->mapping != mapping)\n\t\treturn 0;\n\n\tif (page_has_private(page) && !try_to_release_page(page, 0))\n\t\treturn 0;\n\n\tret = remove_mapping(mapping, page);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/rmap.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_mapping",
          "args": [
            "mapping",
            "page"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "remove_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "982-994",
          "snippet": "int remove_mapping(struct address_space *mapping, struct page *page)\n{\n\tif (__remove_mapping(mapping, page, false)) {\n\t\t/*\n\t\t * Unfreezing the refcount with 1 rather than 2 effectively\n\t\t * drops the pagecache ref for us without requiring another\n\t\t * atomic operation.\n\t\t */\n\t\tpage_ref_unfreeze(page, 1);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint remove_mapping(struct address_space *mapping, struct page *page)\n{\n\tif (__remove_mapping(mapping, page, false)) {\n\t\t/*\n\t\t * Unfreezing the refcount with 1 rather than 2 effectively\n\t\t * drops the pagecache ref for us without requiring another\n\t\t * atomic operation.\n\t\t */\n\t\tpage_ref_unfreeze(page, 1);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_release_page",
          "args": [
            "page",
            "0"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_release_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "3319-3330",
          "snippet": "int try_to_release_page(struct page *page, gfp_t gfp_mask)\n{\n\tstruct address_space * const mapping = page->mapping;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping && mapping->a_ops->releasepage)\n\t\treturn mapping->a_ops->releasepage(page, gfp_mask);\n\treturn try_to_free_buffers(page);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint try_to_release_page(struct page *page, gfp_t gfp_mask)\n{\n\tstruct address_space * const mapping = page->mapping;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping && mapping->a_ops->releasepage)\n\t\treturn mapping->a_ops->releasepage(page, gfp_mask);\n\treturn try_to_free_buffers(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "page"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nstatic int\ninvalidate_complete_page(struct address_space *mapping, struct page *page)\n{\n\tint ret;\n\n\tif (page->mapping != mapping)\n\t\treturn 0;\n\n\tif (page_has_private(page) && !try_to_release_page(page, 0))\n\t\treturn 0;\n\n\tret = remove_mapping(mapping, page);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "truncate_cleanup_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
    "lines": "175-193",
    "snippet": "static void\ntruncate_cleanup_page(struct address_space *mapping, struct page *page)\n{\n\tif (page_mapped(page)) {\n\t\tpgoff_t nr = PageTransHuge(page) ? HPAGE_PMD_NR : 1;\n\t\tunmap_mapping_pages(mapping, page->index, nr, false);\n\t}\n\n\tif (page_has_private(page))\n\t\tdo_invalidatepage(page, 0, PAGE_SIZE);\n\n\t/*\n\t * Some filesystems seem to re-dirty the page even after\n\t * the VM has canceled the dirty bit (eg ext3 journaling).\n\t * Hence dirty accounting check is placed after invalidation.\n\t */\n\tcancel_dirty_page(page);\n\tClearPageMappedToDisk(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/rmap.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ClearPageMappedToDisk",
          "args": [
            "page"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_dirty_page",
          "args": [
            "page"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "__cancel_dirty_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2597-2617",
          "snippet": "void __cancel_dirty_page(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\n\tif (mapping_cap_account_dirty(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct bdi_writeback *wb;\n\t\tstruct wb_lock_cookie cookie = {};\n\n\t\tlock_page_memcg(page);\n\t\twb = unlocked_inode_to_wb_begin(inode, &cookie);\n\n\t\tif (TestClearPageDirty(page))\n\t\t\taccount_page_cleaned(page, mapping, wb);\n\n\t\tunlocked_inode_to_wb_end(inode, &cookie);\n\t\tunlock_page_memcg(page);\n\t} else {\n\t\tClearPageDirty(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid __cancel_dirty_page(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\n\tif (mapping_cap_account_dirty(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct bdi_writeback *wb;\n\t\tstruct wb_lock_cookie cookie = {};\n\n\t\tlock_page_memcg(page);\n\t\twb = unlocked_inode_to_wb_begin(inode, &cookie);\n\n\t\tif (TestClearPageDirty(page))\n\t\t\taccount_page_cleaned(page, mapping, wb);\n\n\t\tunlocked_inode_to_wb_end(inode, &cookie);\n\t\tunlock_page_memcg(page);\n\t} else {\n\t\tClearPageDirty(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_invalidatepage",
          "args": [
            "page",
            "0",
            "PAGE_SIZE"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "do_invalidatepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "151-163",
          "snippet": "void do_invalidatepage(struct page *page, unsigned int offset,\n\t\t       unsigned int length)\n{\n\tvoid (*invalidatepage)(struct page *, unsigned int, unsigned int);\n\n\tinvalidatepage = page->mapping->a_ops->invalidatepage;\n#ifdef CONFIG_BLOCK\n\tif (!invalidatepage)\n\t\tinvalidatepage = block_invalidatepage;\n#endif\n\tif (invalidatepage)\n\t\t(*invalidatepage)(page, offset, length);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nvoid do_invalidatepage(struct page *page, unsigned int offset,\n\t\t       unsigned int length)\n{\n\tvoid (*invalidatepage)(struct page *, unsigned int, unsigned int);\n\n\tinvalidatepage = page->mapping->a_ops->invalidatepage;\n#ifdef CONFIG_BLOCK\n\tif (!invalidatepage)\n\t\tinvalidatepage = block_invalidatepage;\n#endif\n\tif (invalidatepage)\n\t\t(*invalidatepage)(page, offset, length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "page"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mapping_pages",
          "args": [
            "mapping",
            "page->index",
            "nr",
            "false"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mapping_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2596-2611",
          "snippet": "void unmap_mapping_pages(struct address_space *mapping, pgoff_t start,\n\t\tpgoff_t nr, bool even_cows)\n{\n\tstruct zap_details details = { };\n\n\tdetails.check_mapping = even_cows ? NULL : mapping;\n\tdetails.first_index = start;\n\tdetails.last_index = start + nr - 1;\n\tif (details.last_index < details.first_index)\n\t\tdetails.last_index = ULONG_MAX;\n\n\ti_mmap_lock_write(mapping);\n\tif (unlikely(!RB_EMPTY_ROOT(&mapping->i_mmap.rb_root)))\n\t\tunmap_mapping_range_tree(&mapping->i_mmap, &details);\n\ti_mmap_unlock_write(mapping);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid unmap_mapping_pages(struct address_space *mapping, pgoff_t start,\n\t\tpgoff_t nr, bool even_cows)\n{\n\tstruct zap_details details = { };\n\n\tdetails.check_mapping = even_cows ? NULL : mapping;\n\tdetails.first_index = start;\n\tdetails.last_index = start + nr - 1;\n\tif (details.last_index < details.first_index)\n\t\tdetails.last_index = ULONG_MAX;\n\n\ti_mmap_lock_write(mapping);\n\tif (unlikely(!RB_EMPTY_ROOT(&mapping->i_mmap.rb_root)))\n\t\tunmap_mapping_range_tree(&mapping->i_mmap, &details);\n\ti_mmap_unlock_write(mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "page"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "470-486",
          "snippet": "bool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nbool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nstatic void\ntruncate_cleanup_page(struct address_space *mapping, struct page *page)\n{\n\tif (page_mapped(page)) {\n\t\tpgoff_t nr = PageTransHuge(page) ? HPAGE_PMD_NR : 1;\n\t\tunmap_mapping_pages(mapping, page->index, nr, false);\n\t}\n\n\tif (page_has_private(page))\n\t\tdo_invalidatepage(page, 0, PAGE_SIZE);\n\n\t/*\n\t * Some filesystems seem to re-dirty the page even after\n\t * the VM has canceled the dirty bit (eg ext3 journaling).\n\t * Hence dirty accounting check is placed after invalidation.\n\t */\n\tcancel_dirty_page(page);\n\tClearPageMappedToDisk(page);\n}"
  },
  {
    "function_name": "do_invalidatepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
    "lines": "151-163",
    "snippet": "void do_invalidatepage(struct page *page, unsigned int offset,\n\t\t       unsigned int length)\n{\n\tvoid (*invalidatepage)(struct page *, unsigned int, unsigned int);\n\n\tinvalidatepage = page->mapping->a_ops->invalidatepage;\n#ifdef CONFIG_BLOCK\n\tif (!invalidatepage)\n\t\tinvalidatepage = block_invalidatepage;\n#endif\n\tif (invalidatepage)\n\t\t(*invalidatepage)(page, offset, length);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/rmap.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "page",
            "offset",
            "length"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nvoid do_invalidatepage(struct page *page, unsigned int offset,\n\t\t       unsigned int length)\n{\n\tvoid (*invalidatepage)(struct page *, unsigned int, unsigned int);\n\n\tinvalidatepage = page->mapping->a_ops->invalidatepage;\n#ifdef CONFIG_BLOCK\n\tif (!invalidatepage)\n\t\tinvalidatepage = block_invalidatepage;\n#endif\n\tif (invalidatepage)\n\t\t(*invalidatepage)(page, offset, length);\n}"
  },
  {
    "function_name": "invalidate_exceptional_entry2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
    "lines": "124-134",
    "snippet": "static int invalidate_exceptional_entry2(struct address_space *mapping,\n\t\t\t\t\t pgoff_t index, void *entry)\n{\n\t/* Handled by shmem itself */\n\tif (shmem_mapping(mapping))\n\t\treturn 1;\n\tif (dax_mapping(mapping))\n\t\treturn dax_invalidate_mapping_entry_sync(mapping, index);\n\tclear_shadow_entry(mapping, index, entry);\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/rmap.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_shadow_entry",
          "args": [
            "mapping",
            "index",
            "entry"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "clear_shadow_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "45-51",
          "snippet": "static void clear_shadow_entry(struct address_space *mapping, pgoff_t index,\n\t\t\t       void *entry)\n{\n\txa_lock_irq(&mapping->i_pages);\n\t__clear_shadow_entry(mapping, index, entry);\n\txa_unlock_irq(&mapping->i_pages);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nstatic void clear_shadow_entry(struct address_space *mapping, pgoff_t index,\n\t\t\t       void *entry)\n{\n\txa_lock_irq(&mapping->i_pages);\n\t__clear_shadow_entry(mapping, index, entry);\n\txa_unlock_irq(&mapping->i_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_invalidate_mapping_entry_sync",
          "args": [
            "mapping",
            "index"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_mapping",
          "args": [
            "mapping"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shmem_mapping",
          "args": [
            "mapping"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "shmem_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/shmem.c",
          "lines": "2195-2198",
          "snippet": "bool shmem_mapping(struct address_space *mapping)\n{\n\treturn mapping->a_ops == &shmem_aops;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/uuid.h>",
            "#include <linux/rmap.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <uapi/linux/memfd.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/magic.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/highmem.h>",
            "#include <linux/migrate.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/swapops.h>",
            "#include <linux/security.h>",
            "#include <linux/splice.h>",
            "#include <linux/falloc.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mman.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/xattr.h>",
            "#include <asm/tlbflush.h> /* for arch/microblaze update_mmu_cache() */",
            "#include <linux/hugetlb.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/random.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/uuid.h>\n#include <linux/rmap.h>\n#include <linux/userfaultfd_k.h>\n#include <uapi/linux/memfd.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/magic.h>\n#include <linux/seq_file.h>\n#include <linux/highmem.h>\n#include <linux/migrate.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/mempolicy.h>\n#include <linux/swapops.h>\n#include <linux/security.h>\n#include <linux/splice.h>\n#include <linux/falloc.h>\n#include <linux/percpu_counter.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/shmem_fs.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mman.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/exportfs.h>\n#include <linux/xattr.h>\n#include <asm/tlbflush.h> /* for arch/microblaze update_mmu_cache() */\n#include <linux/hugetlb.h>\n#include <linux/khugepaged.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/sched/signal.h>\n#include <linux/random.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/ramfs.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nbool shmem_mapping(struct address_space *mapping)\n{\n\treturn mapping->a_ops == &shmem_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nstatic int invalidate_exceptional_entry2(struct address_space *mapping,\n\t\t\t\t\t pgoff_t index, void *entry)\n{\n\t/* Handled by shmem itself */\n\tif (shmem_mapping(mapping))\n\t\treturn 1;\n\tif (dax_mapping(mapping))\n\t\treturn dax_invalidate_mapping_entry_sync(mapping, index);\n\tclear_shadow_entry(mapping, index, entry);\n\treturn 1;\n}"
  },
  {
    "function_name": "invalidate_exceptional_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
    "lines": "110-118",
    "snippet": "static int invalidate_exceptional_entry(struct address_space *mapping,\n\t\t\t\t\tpgoff_t index, void *entry)\n{\n\t/* Handled by shmem itself, or for DAX we do nothing. */\n\tif (shmem_mapping(mapping) || dax_mapping(mapping))\n\t\treturn 1;\n\tclear_shadow_entry(mapping, index, entry);\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/rmap.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_shadow_entry",
          "args": [
            "mapping",
            "index",
            "entry"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "clear_shadow_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "45-51",
          "snippet": "static void clear_shadow_entry(struct address_space *mapping, pgoff_t index,\n\t\t\t       void *entry)\n{\n\txa_lock_irq(&mapping->i_pages);\n\t__clear_shadow_entry(mapping, index, entry);\n\txa_unlock_irq(&mapping->i_pages);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nstatic void clear_shadow_entry(struct address_space *mapping, pgoff_t index,\n\t\t\t       void *entry)\n{\n\txa_lock_irq(&mapping->i_pages);\n\t__clear_shadow_entry(mapping, index, entry);\n\txa_unlock_irq(&mapping->i_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_mapping",
          "args": [
            "mapping"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shmem_mapping",
          "args": [
            "mapping"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "shmem_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/shmem.c",
          "lines": "2195-2198",
          "snippet": "bool shmem_mapping(struct address_space *mapping)\n{\n\treturn mapping->a_ops == &shmem_aops;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/uuid.h>",
            "#include <linux/rmap.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <uapi/linux/memfd.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/magic.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/highmem.h>",
            "#include <linux/migrate.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/swapops.h>",
            "#include <linux/security.h>",
            "#include <linux/splice.h>",
            "#include <linux/falloc.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mman.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/xattr.h>",
            "#include <asm/tlbflush.h> /* for arch/microblaze update_mmu_cache() */",
            "#include <linux/hugetlb.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/random.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/uuid.h>\n#include <linux/rmap.h>\n#include <linux/userfaultfd_k.h>\n#include <uapi/linux/memfd.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/magic.h>\n#include <linux/seq_file.h>\n#include <linux/highmem.h>\n#include <linux/migrate.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/mempolicy.h>\n#include <linux/swapops.h>\n#include <linux/security.h>\n#include <linux/splice.h>\n#include <linux/falloc.h>\n#include <linux/percpu_counter.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/shmem_fs.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mman.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/exportfs.h>\n#include <linux/xattr.h>\n#include <asm/tlbflush.h> /* for arch/microblaze update_mmu_cache() */\n#include <linux/hugetlb.h>\n#include <linux/khugepaged.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/sched/signal.h>\n#include <linux/random.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/ramfs.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nbool shmem_mapping(struct address_space *mapping)\n{\n\treturn mapping->a_ops == &shmem_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nstatic int invalidate_exceptional_entry(struct address_space *mapping,\n\t\t\t\t\tpgoff_t index, void *entry)\n{\n\t/* Handled by shmem itself, or for DAX we do nothing. */\n\tif (shmem_mapping(mapping) || dax_mapping(mapping))\n\t\treturn 1;\n\tclear_shadow_entry(mapping, index, entry);\n\treturn 1;\n}"
  },
  {
    "function_name": "truncate_exceptional_pvec_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
    "lines": "58-104",
    "snippet": "static void truncate_exceptional_pvec_entries(struct address_space *mapping,\n\t\t\t\tstruct pagevec *pvec, pgoff_t *indices,\n\t\t\t\tpgoff_t end)\n{\n\tint i, j;\n\tbool dax, lock;\n\n\t/* Handled by shmem itself */\n\tif (shmem_mapping(mapping))\n\t\treturn;\n\n\tfor (j = 0; j < pagevec_count(pvec); j++)\n\t\tif (xa_is_value(pvec->pages[j]))\n\t\t\tbreak;\n\n\tif (j == pagevec_count(pvec))\n\t\treturn;\n\n\tdax = dax_mapping(mapping);\n\tlock = !dax && indices[j] < end;\n\tif (lock)\n\t\txa_lock_irq(&mapping->i_pages);\n\n\tfor (i = j; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tpgoff_t index = indices[i];\n\n\t\tif (!xa_is_value(page)) {\n\t\t\tpvec->pages[j++] = page;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (index >= end)\n\t\t\tcontinue;\n\n\t\tif (unlikely(dax)) {\n\t\t\tdax_delete_mapping_entry(mapping, index);\n\t\t\tcontinue;\n\t\t}\n\n\t\t__clear_shadow_entry(mapping, index, page);\n\t}\n\n\tif (lock)\n\t\txa_unlock_irq(&mapping->i_pages);\n\tpvec->nr = j;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/rmap.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xa_unlock_irq",
          "args": [
            "&mapping->i_pages"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_shadow_entry",
          "args": [
            "mapping",
            "index",
            "page"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_shadow_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "33-43",
          "snippet": "static inline void __clear_shadow_entry(struct address_space *mapping,\n\t\t\t\tpgoff_t index, void *entry)\n{\n\tXA_STATE(xas, &mapping->i_pages, index);\n\n\txas_set_update(&xas, workingset_update_node);\n\tif (xas_load(&xas) != entry)\n\t\treturn;\n\txas_store(&xas, NULL);\n\tmapping->nrexceptional--;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nstatic inline void __clear_shadow_entry(struct address_space *mapping,\n\t\t\t\tpgoff_t index, void *entry)\n{\n\tXA_STATE(xas, &mapping->i_pages, index);\n\n\txas_set_update(&xas, workingset_update_node);\n\tif (xas_load(&xas) != entry)\n\t\treturn;\n\txas_store(&xas, NULL);\n\tmapping->nrexceptional--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_delete_mapping_entry",
          "args": [
            "mapping",
            "index"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dax"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "page"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "pvec"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_lock_irq",
          "args": [
            "&mapping->i_pages"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_mapping",
          "args": [
            "mapping"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "pvec"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "pvec->pages[j]"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "pvec"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shmem_mapping",
          "args": [
            "mapping"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "shmem_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/shmem.c",
          "lines": "2195-2198",
          "snippet": "bool shmem_mapping(struct address_space *mapping)\n{\n\treturn mapping->a_ops == &shmem_aops;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/uuid.h>",
            "#include <linux/rmap.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <uapi/linux/memfd.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/magic.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/highmem.h>",
            "#include <linux/migrate.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/swapops.h>",
            "#include <linux/security.h>",
            "#include <linux/splice.h>",
            "#include <linux/falloc.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mman.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/xattr.h>",
            "#include <asm/tlbflush.h> /* for arch/microblaze update_mmu_cache() */",
            "#include <linux/hugetlb.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/random.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/uuid.h>\n#include <linux/rmap.h>\n#include <linux/userfaultfd_k.h>\n#include <uapi/linux/memfd.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/magic.h>\n#include <linux/seq_file.h>\n#include <linux/highmem.h>\n#include <linux/migrate.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/mempolicy.h>\n#include <linux/swapops.h>\n#include <linux/security.h>\n#include <linux/splice.h>\n#include <linux/falloc.h>\n#include <linux/percpu_counter.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/shmem_fs.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mman.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/exportfs.h>\n#include <linux/xattr.h>\n#include <asm/tlbflush.h> /* for arch/microblaze update_mmu_cache() */\n#include <linux/hugetlb.h>\n#include <linux/khugepaged.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/sched/signal.h>\n#include <linux/random.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/ramfs.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nbool shmem_mapping(struct address_space *mapping)\n{\n\treturn mapping->a_ops == &shmem_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nstatic void truncate_exceptional_pvec_entries(struct address_space *mapping,\n\t\t\t\tstruct pagevec *pvec, pgoff_t *indices,\n\t\t\t\tpgoff_t end)\n{\n\tint i, j;\n\tbool dax, lock;\n\n\t/* Handled by shmem itself */\n\tif (shmem_mapping(mapping))\n\t\treturn;\n\n\tfor (j = 0; j < pagevec_count(pvec); j++)\n\t\tif (xa_is_value(pvec->pages[j]))\n\t\t\tbreak;\n\n\tif (j == pagevec_count(pvec))\n\t\treturn;\n\n\tdax = dax_mapping(mapping);\n\tlock = !dax && indices[j] < end;\n\tif (lock)\n\t\txa_lock_irq(&mapping->i_pages);\n\n\tfor (i = j; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tpgoff_t index = indices[i];\n\n\t\tif (!xa_is_value(page)) {\n\t\t\tpvec->pages[j++] = page;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (index >= end)\n\t\t\tcontinue;\n\n\t\tif (unlikely(dax)) {\n\t\t\tdax_delete_mapping_entry(mapping, index);\n\t\t\tcontinue;\n\t\t}\n\n\t\t__clear_shadow_entry(mapping, index, page);\n\t}\n\n\tif (lock)\n\t\txa_unlock_irq(&mapping->i_pages);\n\tpvec->nr = j;\n}"
  },
  {
    "function_name": "clear_shadow_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
    "lines": "45-51",
    "snippet": "static void clear_shadow_entry(struct address_space *mapping, pgoff_t index,\n\t\t\t       void *entry)\n{\n\txa_lock_irq(&mapping->i_pages);\n\t__clear_shadow_entry(mapping, index, entry);\n\txa_unlock_irq(&mapping->i_pages);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/rmap.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xa_unlock_irq",
          "args": [
            "&mapping->i_pages"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_shadow_entry",
          "args": [
            "mapping",
            "index",
            "entry"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_shadow_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "33-43",
          "snippet": "static inline void __clear_shadow_entry(struct address_space *mapping,\n\t\t\t\tpgoff_t index, void *entry)\n{\n\tXA_STATE(xas, &mapping->i_pages, index);\n\n\txas_set_update(&xas, workingset_update_node);\n\tif (xas_load(&xas) != entry)\n\t\treturn;\n\txas_store(&xas, NULL);\n\tmapping->nrexceptional--;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nstatic inline void __clear_shadow_entry(struct address_space *mapping,\n\t\t\t\tpgoff_t index, void *entry)\n{\n\tXA_STATE(xas, &mapping->i_pages, index);\n\n\txas_set_update(&xas, workingset_update_node);\n\tif (xas_load(&xas) != entry)\n\t\treturn;\n\txas_store(&xas, NULL);\n\tmapping->nrexceptional--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xa_lock_irq",
          "args": [
            "&mapping->i_pages"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nstatic void clear_shadow_entry(struct address_space *mapping, pgoff_t index,\n\t\t\t       void *entry)\n{\n\txa_lock_irq(&mapping->i_pages);\n\t__clear_shadow_entry(mapping, index, entry);\n\txa_unlock_irq(&mapping->i_pages);\n}"
  },
  {
    "function_name": "__clear_shadow_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
    "lines": "33-43",
    "snippet": "static inline void __clear_shadow_entry(struct address_space *mapping,\n\t\t\t\tpgoff_t index, void *entry)\n{\n\tXA_STATE(xas, &mapping->i_pages, index);\n\n\txas_set_update(&xas, workingset_update_node);\n\tif (xas_load(&xas) != entry)\n\t\treturn;\n\txas_store(&xas, NULL);\n\tmapping->nrexceptional--;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/rmap.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xas_store",
          "args": [
            "&xas",
            "NULL"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_load",
          "args": [
            "&xas"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_set_update",
          "args": [
            "&xas",
            "workingset_update_node"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "index"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nstatic inline void __clear_shadow_entry(struct address_space *mapping,\n\t\t\t\tpgoff_t index, void *entry)\n{\n\tXA_STATE(xas, &mapping->i_pages, index);\n\n\txas_set_update(&xas, workingset_update_node);\n\tif (xas_load(&xas) != entry)\n\t\treturn;\n\txas_store(&xas, NULL);\n\tmapping->nrexceptional--;\n}"
  }
]