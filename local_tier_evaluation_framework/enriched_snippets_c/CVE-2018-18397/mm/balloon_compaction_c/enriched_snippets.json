[
  {
    "function_name": "balloon_page_migrate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/balloon_compaction.c",
    "lines": "150-168",
    "snippet": "int balloon_page_migrate(struct address_space *mapping,\n\t\tstruct page *newpage, struct page *page,\n\t\tenum migrate_mode mode)\n{\n\tstruct balloon_dev_info *balloon = balloon_page_device(page);\n\n\t/*\n\t * We can not easily support the no copy case here so ignore it as it\n\t * is unlikely to be use with ballon pages. See include/linux/hmm.h for\n\t * user of the MIGRATE_SYNC_NO_COPY mode.\n\t */\n\tif (mode == MIGRATE_SYNC_NO_COPY)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageLocked(newpage), newpage);\n\n\treturn balloon->migratepage(balloon, newpage, page, mode);\n}",
    "includes": [
      "#include <linux/balloon_compaction.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "balloon->migratepage",
          "args": [
            "balloon",
            "newpage",
            "page",
            "mode"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(newpage)",
            "newpage"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "newpage"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balloon_page_device",
          "args": [
            "page"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/balloon_compaction.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint balloon_page_migrate(struct address_space *mapping,\n\t\tstruct page *newpage, struct page *page,\n\t\tenum migrate_mode mode)\n{\n\tstruct balloon_dev_info *balloon = balloon_page_device(page);\n\n\t/*\n\t * We can not easily support the no copy case here so ignore it as it\n\t * is unlikely to be use with ballon pages. See include/linux/hmm.h for\n\t * user of the MIGRATE_SYNC_NO_COPY mode.\n\t */\n\tif (mode == MIGRATE_SYNC_NO_COPY)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageLocked(newpage), newpage);\n\n\treturn balloon->migratepage(balloon, newpage, page, mode);\n}"
  },
  {
    "function_name": "balloon_page_putback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/balloon_compaction.c",
    "lines": "137-146",
    "snippet": "void balloon_page_putback(struct page *page)\n{\n\tstruct balloon_dev_info *b_dev_info = balloon_page_device(page);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&b_dev_info->pages_lock, flags);\n\tlist_add(&page->lru, &b_dev_info->pages);\n\tb_dev_info->isolated_pages--;\n\tspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\n}",
    "includes": [
      "#include <linux/balloon_compaction.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&b_dev_info->pages_lock",
            "flags"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->lru",
            "&b_dev_info->pages"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&b_dev_info->pages_lock",
            "flags"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balloon_page_device",
          "args": [
            "page"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/balloon_compaction.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid balloon_page_putback(struct page *page)\n{\n\tstruct balloon_dev_info *b_dev_info = balloon_page_device(page);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&b_dev_info->pages_lock, flags);\n\tlist_add(&page->lru, &b_dev_info->pages);\n\tb_dev_info->isolated_pages--;\n\tspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\n}"
  },
  {
    "function_name": "balloon_page_isolate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/balloon_compaction.c",
    "lines": "123-135",
    "snippet": "bool balloon_page_isolate(struct page *page, isolate_mode_t mode)\n\n{\n\tstruct balloon_dev_info *b_dev_info = balloon_page_device(page);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&b_dev_info->pages_lock, flags);\n\tlist_del(&page->lru);\n\tb_dev_info->isolated_pages++;\n\tspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/balloon_compaction.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&b_dev_info->pages_lock",
            "flags"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&b_dev_info->pages_lock",
            "flags"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balloon_page_device",
          "args": [
            "page"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/balloon_compaction.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nbool balloon_page_isolate(struct page *page, isolate_mode_t mode)\n\n{\n\tstruct balloon_dev_info *b_dev_info = balloon_page_device(page);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&b_dev_info->pages_lock, flags);\n\tlist_del(&page->lru);\n\tb_dev_info->isolated_pages++;\n\tspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\n\n\treturn true;\n}"
  },
  {
    "function_name": "balloon_page_dequeue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/balloon_compaction.c",
    "lines": "71-118",
    "snippet": "struct page *balloon_page_dequeue(struct balloon_dev_info *b_dev_info)\n{\n\tstruct page *page, *tmp;\n\tunsigned long flags;\n\tbool dequeued_page;\n\n\tdequeued_page = false;\n\tspin_lock_irqsave(&b_dev_info->pages_lock, flags);\n\tlist_for_each_entry_safe(page, tmp, &b_dev_info->pages, lru) {\n\t\t/*\n\t\t * Block others from accessing the 'page' while we get around\n\t\t * establishing additional references and preparing the 'page'\n\t\t * to be released by the balloon driver.\n\t\t */\n\t\tif (trylock_page(page)) {\n#ifdef CONFIG_BALLOON_COMPACTION\n\t\t\tif (PageIsolated(page)) {\n\t\t\t\t/* raced with isolation */\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tballoon_page_delete(page);\n\t\t\t__count_vm_event(BALLOON_DEFLATE);\n\t\t\tunlock_page(page);\n\t\t\tdequeued_page = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\n\n\tif (!dequeued_page) {\n\t\t/*\n\t\t * If we are unable to dequeue a balloon page because the page\n\t\t * list is empty and there is no isolated pages, then something\n\t\t * went out of track and some balloon pages are lost.\n\t\t * BUG() here, otherwise the balloon driver may get stuck into\n\t\t * an infinite loop while attempting to release all its pages.\n\t\t */\n\t\tspin_lock_irqsave(&b_dev_info->pages_lock, flags);\n\t\tif (unlikely(list_empty(&b_dev_info->pages) &&\n\t\t\t     !b_dev_info->isolated_pages))\n\t\t\tBUG();\n\t\tspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\n\t\tpage = NULL;\n\t}\n\treturn page;\n}",
    "includes": [
      "#include <linux/balloon_compaction.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&b_dev_info->pages_lock",
            "flags"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "list_empty(&b_dev_info->pages) &&\n\t\t\t     !b_dev_info->isolated_pages"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&b_dev_info->pages"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&b_dev_info->pages_lock",
            "flags"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&b_dev_info->pages_lock",
            "flags"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__count_vm_event",
          "args": [
            "BALLOON_DEFLATE"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balloon_page_delete",
          "args": [
            "page"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageIsolated",
          "args": [
            "page"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "page",
            "tmp",
            "&b_dev_info->pages",
            "lru"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&b_dev_info->pages_lock",
            "flags"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/balloon_compaction.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct page *balloon_page_dequeue(struct balloon_dev_info *b_dev_info)\n{\n\tstruct page *page, *tmp;\n\tunsigned long flags;\n\tbool dequeued_page;\n\n\tdequeued_page = false;\n\tspin_lock_irqsave(&b_dev_info->pages_lock, flags);\n\tlist_for_each_entry_safe(page, tmp, &b_dev_info->pages, lru) {\n\t\t/*\n\t\t * Block others from accessing the 'page' while we get around\n\t\t * establishing additional references and preparing the 'page'\n\t\t * to be released by the balloon driver.\n\t\t */\n\t\tif (trylock_page(page)) {\n#ifdef CONFIG_BALLOON_COMPACTION\n\t\t\tif (PageIsolated(page)) {\n\t\t\t\t/* raced with isolation */\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tballoon_page_delete(page);\n\t\t\t__count_vm_event(BALLOON_DEFLATE);\n\t\t\tunlock_page(page);\n\t\t\tdequeued_page = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\n\n\tif (!dequeued_page) {\n\t\t/*\n\t\t * If we are unable to dequeue a balloon page because the page\n\t\t * list is empty and there is no isolated pages, then something\n\t\t * went out of track and some balloon pages are lost.\n\t\t * BUG() here, otherwise the balloon driver may get stuck into\n\t\t * an infinite loop while attempting to release all its pages.\n\t\t */\n\t\tspin_lock_irqsave(&b_dev_info->pages_lock, flags);\n\t\tif (unlikely(list_empty(&b_dev_info->pages) &&\n\t\t\t     !b_dev_info->isolated_pages))\n\t\t\tBUG();\n\t\tspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\n\t\tpage = NULL;\n\t}\n\treturn page;\n}"
  },
  {
    "function_name": "balloon_page_enqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/balloon_compaction.c",
    "lines": "41-57",
    "snippet": "void balloon_page_enqueue(struct balloon_dev_info *b_dev_info,\n\t\t\t  struct page *page)\n{\n\tunsigned long flags;\n\n\t/*\n\t * Block others from accessing the 'page' when we get around to\n\t * establishing additional references. We should be the only one\n\t * holding a reference to the 'page' at this point.\n\t */\n\tBUG_ON(!trylock_page(page));\n\tspin_lock_irqsave(&b_dev_info->pages_lock, flags);\n\tballoon_page_insert(b_dev_info, page);\n\t__count_vm_event(BALLOON_INFLATE);\n\tspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\n\tunlock_page(page);\n}",
    "includes": [
      "#include <linux/balloon_compaction.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&b_dev_info->pages_lock",
            "flags"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__count_vm_event",
          "args": [
            "BALLOON_INFLATE"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balloon_page_insert",
          "args": [
            "b_dev_info",
            "page"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&b_dev_info->pages_lock",
            "flags"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!trylock_page(page)"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/balloon_compaction.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid balloon_page_enqueue(struct balloon_dev_info *b_dev_info,\n\t\t\t  struct page *page)\n{\n\tunsigned long flags;\n\n\t/*\n\t * Block others from accessing the 'page' when we get around to\n\t * establishing additional references. We should be the only one\n\t * holding a reference to the 'page' at this point.\n\t */\n\tBUG_ON(!trylock_page(page));\n\tspin_lock_irqsave(&b_dev_info->pages_lock, flags);\n\tballoon_page_insert(b_dev_info, page);\n\t__count_vm_event(BALLOON_INFLATE);\n\tspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\n\tunlock_page(page);\n}"
  },
  {
    "function_name": "balloon_page_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/balloon_compaction.c",
    "lines": "22-27",
    "snippet": "struct page *balloon_page_alloc(void)\n{\n\tstruct page *page = alloc_page(balloon_mapping_gfp_mask() |\n\t\t\t\t       __GFP_NOMEMALLOC | __GFP_NORETRY);\n\treturn page;\n}",
    "includes": [
      "#include <linux/balloon_compaction.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "balloon_mapping_gfp_mask() |\n\t\t\t\t       __GFP_NOMEMALLOC | __GFP_NORETRY"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_hstate_alloc_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2163-2184",
          "snippet": "static void __init hugetlb_hstate_alloc_pages(struct hstate *h)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < h->max_huge_pages; ++i) {\n\t\tif (hstate_is_gigantic(h)) {\n\t\t\tif (!alloc_bootmem_huge_page(h))\n\t\t\t\tbreak;\n\t\t} else if (!alloc_pool_huge_page(h,\n\t\t\t\t\t &node_states[N_MEMORY]))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\tif (i < h->max_huge_pages) {\n\t\tchar buf[32];\n\n\t\tstring_get_size(huge_page_size(h), 1, STRING_UNITS_2, buf, 32);\n\t\tpr_warn(\"HugeTLB: allocating %lu of page size %s failed.  Only allocated %lu hugepages.\\n\",\n\t\t\th->max_huge_pages, buf, i);\n\t\th->max_huge_pages = i;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void __init hugetlb_hstate_alloc_pages(struct hstate *h)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < h->max_huge_pages; ++i) {\n\t\tif (hstate_is_gigantic(h)) {\n\t\t\tif (!alloc_bootmem_huge_page(h))\n\t\t\t\tbreak;\n\t\t} else if (!alloc_pool_huge_page(h,\n\t\t\t\t\t &node_states[N_MEMORY]))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\tif (i < h->max_huge_pages) {\n\t\tchar buf[32];\n\n\t\tstring_get_size(huge_page_size(h), 1, STRING_UNITS_2, buf, 32);\n\t\tpr_warn(\"HugeTLB: allocating %lu of page size %s failed.  Only allocated %lu hugepages.\\n\",\n\t\t\th->max_huge_pages, buf, i);\n\t\th->max_huge_pages = i;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "balloon_mapping_gfp_mask",
          "args": [],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/balloon_compaction.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct page *balloon_page_alloc(void)\n{\n\tstruct page *page = alloc_page(balloon_mapping_gfp_mask() |\n\t\t\t\t       __GFP_NOMEMALLOC | __GFP_NORETRY);\n\treturn page;\n}"
  }
]