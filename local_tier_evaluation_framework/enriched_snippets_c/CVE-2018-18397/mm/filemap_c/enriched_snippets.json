[
  {
    "function_name": "try_to_release_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "3319-3330",
    "snippet": "int try_to_release_page(struct page *page, gfp_t gfp_mask)\n{\n\tstruct address_space * const mapping = page->mapping;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping && mapping->a_ops->releasepage)\n\t\treturn mapping->a_ops->releasepage(page, gfp_mask);\n\treturn try_to_free_buffers(page);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_to_free_buffers",
          "args": [
            "page"
          ],
          "line": 3329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->releasepage",
          "args": [
            "page",
            "gfp_mask"
          ],
          "line": 3328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 3324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 3323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 3323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint try_to_release_page(struct page *page, gfp_t gfp_mask)\n{\n\tstruct address_space * const mapping = page->mapping;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping && mapping->a_ops->releasepage)\n\t\treturn mapping->a_ops->releasepage(page, gfp_mask);\n\treturn try_to_free_buffers(page);\n}"
  },
  {
    "function_name": "generic_file_write_iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "3284-3299",
    "snippet": "ssize_t generic_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tssize_t ret;\n\n\tinode_lock(inode);\n\tret = generic_write_checks(iocb, from);\n\tif (ret > 0)\n\t\tret = __generic_file_write_iter(iocb, from);\n\tinode_unlock(inode);\n\n\tif (ret > 0)\n\t\tret = generic_write_sync(iocb, ret);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_write_sync",
          "args": [
            "iocb",
            "ret"
          ],
          "line": 3297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "inode"
          ],
          "line": 3294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__generic_file_write_iter",
          "args": [
            "iocb",
            "from"
          ],
          "line": 3293
        },
        "resolved": true,
        "details": {
          "function_name": "__generic_file_write_iter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "3200-3272",
          "snippet": "ssize_t __generic_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space * mapping = file->f_mapping;\n\tstruct inode \t*inode = mapping->host;\n\tssize_t\t\twritten = 0;\n\tssize_t\t\terr;\n\tssize_t\t\tstatus;\n\n\t/* We can write back this queue in page reclaim */\n\tcurrent->backing_dev_info = inode_to_bdi(inode);\n\terr = file_remove_privs(file);\n\tif (err)\n\t\tgoto out;\n\n\terr = file_update_time(file);\n\tif (err)\n\t\tgoto out;\n\n\tif (iocb->ki_flags & IOCB_DIRECT) {\n\t\tloff_t pos, endbyte;\n\n\t\twritten = generic_file_direct_write(iocb, from);\n\t\t/*\n\t\t * If the write stopped short of completing, fall back to\n\t\t * buffered writes.  Some filesystems do this for writes to\n\t\t * holes, for example.  For DAX files, a buffered write will\n\t\t * not succeed (even if it did, DAX does not handle dirty\n\t\t * page-cache pages correctly).\n\t\t */\n\t\tif (written < 0 || !iov_iter_count(from) || IS_DAX(inode))\n\t\t\tgoto out;\n\n\t\tstatus = generic_perform_write(file, from, pos = iocb->ki_pos);\n\t\t/*\n\t\t * If generic_perform_write() returned a synchronous error\n\t\t * then we want to return the number of bytes which were\n\t\t * direct-written, or the error code if that was zero.  Note\n\t\t * that this differs from normal direct-io semantics, which\n\t\t * will return -EFOO even if some bytes were written.\n\t\t */\n\t\tif (unlikely(status < 0)) {\n\t\t\terr = status;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * We need to ensure that the page cache pages are written to\n\t\t * disk and invalidated to preserve the expected O_DIRECT\n\t\t * semantics.\n\t\t */\n\t\tendbyte = pos + status - 1;\n\t\terr = filemap_write_and_wait_range(mapping, pos, endbyte);\n\t\tif (err == 0) {\n\t\t\tiocb->ki_pos = endbyte + 1;\n\t\t\twritten += status;\n\t\t\tinvalidate_mapping_pages(mapping,\n\t\t\t\t\t\t pos >> PAGE_SHIFT,\n\t\t\t\t\t\t endbyte >> PAGE_SHIFT);\n\t\t} else {\n\t\t\t/*\n\t\t\t * We don't know how much we wrote, so just return\n\t\t\t * the number of bytes which were direct-written\n\t\t\t */\n\t\t}\n\t} else {\n\t\twritten = generic_perform_write(file, from, iocb->ki_pos);\n\t\tif (likely(written > 0))\n\t\t\tiocb->ki_pos += written;\n\t}\nout:\n\tcurrent->backing_dev_info = NULL;\n\treturn written ? written : err;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nssize_t __generic_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space * mapping = file->f_mapping;\n\tstruct inode \t*inode = mapping->host;\n\tssize_t\t\twritten = 0;\n\tssize_t\t\terr;\n\tssize_t\t\tstatus;\n\n\t/* We can write back this queue in page reclaim */\n\tcurrent->backing_dev_info = inode_to_bdi(inode);\n\terr = file_remove_privs(file);\n\tif (err)\n\t\tgoto out;\n\n\terr = file_update_time(file);\n\tif (err)\n\t\tgoto out;\n\n\tif (iocb->ki_flags & IOCB_DIRECT) {\n\t\tloff_t pos, endbyte;\n\n\t\twritten = generic_file_direct_write(iocb, from);\n\t\t/*\n\t\t * If the write stopped short of completing, fall back to\n\t\t * buffered writes.  Some filesystems do this for writes to\n\t\t * holes, for example.  For DAX files, a buffered write will\n\t\t * not succeed (even if it did, DAX does not handle dirty\n\t\t * page-cache pages correctly).\n\t\t */\n\t\tif (written < 0 || !iov_iter_count(from) || IS_DAX(inode))\n\t\t\tgoto out;\n\n\t\tstatus = generic_perform_write(file, from, pos = iocb->ki_pos);\n\t\t/*\n\t\t * If generic_perform_write() returned a synchronous error\n\t\t * then we want to return the number of bytes which were\n\t\t * direct-written, or the error code if that was zero.  Note\n\t\t * that this differs from normal direct-io semantics, which\n\t\t * will return -EFOO even if some bytes were written.\n\t\t */\n\t\tif (unlikely(status < 0)) {\n\t\t\terr = status;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * We need to ensure that the page cache pages are written to\n\t\t * disk and invalidated to preserve the expected O_DIRECT\n\t\t * semantics.\n\t\t */\n\t\tendbyte = pos + status - 1;\n\t\terr = filemap_write_and_wait_range(mapping, pos, endbyte);\n\t\tif (err == 0) {\n\t\t\tiocb->ki_pos = endbyte + 1;\n\t\t\twritten += status;\n\t\t\tinvalidate_mapping_pages(mapping,\n\t\t\t\t\t\t pos >> PAGE_SHIFT,\n\t\t\t\t\t\t endbyte >> PAGE_SHIFT);\n\t\t} else {\n\t\t\t/*\n\t\t\t * We don't know how much we wrote, so just return\n\t\t\t * the number of bytes which were direct-written\n\t\t\t */\n\t\t}\n\t} else {\n\t\twritten = generic_perform_write(file, from, iocb->ki_pos);\n\t\tif (likely(written > 0))\n\t\t\tiocb->ki_pos += written;\n\t}\nout:\n\tcurrent->backing_dev_info = NULL;\n\treturn written ? written : err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_write_checks",
          "args": [
            "iocb",
            "from"
          ],
          "line": 3291
        },
        "resolved": true,
        "details": {
          "function_name": "generic_write_checks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "2870-2894",
          "snippet": "inline ssize_t generic_write_checks(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tloff_t count;\n\tint ret;\n\n\tif (!iov_iter_count(from))\n\t\treturn 0;\n\n\t/* FIXME: this is for backwards compatibility with 2.4 */\n\tif (iocb->ki_flags & IOCB_APPEND)\n\t\tiocb->ki_pos = i_size_read(inode);\n\n\tif ((iocb->ki_flags & IOCB_NOWAIT) && !(iocb->ki_flags & IOCB_DIRECT))\n\t\treturn -EINVAL;\n\n\tcount = iov_iter_count(from);\n\tret = generic_write_check_limits(file, iocb->ki_pos, &count);\n\tif (ret)\n\t\treturn ret;\n\n\tiov_iter_truncate(from, count);\n\treturn iov_iter_count(from);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\ninline ssize_t generic_write_checks(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tloff_t count;\n\tint ret;\n\n\tif (!iov_iter_count(from))\n\t\treturn 0;\n\n\t/* FIXME: this is for backwards compatibility with 2.4 */\n\tif (iocb->ki_flags & IOCB_APPEND)\n\t\tiocb->ki_pos = i_size_read(inode);\n\n\tif ((iocb->ki_flags & IOCB_NOWAIT) && !(iocb->ki_flags & IOCB_DIRECT))\n\t\treturn -EINVAL;\n\n\tcount = iov_iter_count(from);\n\tret = generic_write_check_limits(file, iocb->ki_pos, &count);\n\tif (ret)\n\t\treturn ret;\n\n\tiov_iter_truncate(from, count);\n\treturn iov_iter_count(from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "inode"
          ],
          "line": 3290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nssize_t generic_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tssize_t ret;\n\n\tinode_lock(inode);\n\tret = generic_write_checks(iocb, from);\n\tif (ret > 0)\n\t\tret = __generic_file_write_iter(iocb, from);\n\tinode_unlock(inode);\n\n\tif (ret > 0)\n\t\tret = generic_write_sync(iocb, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "__generic_file_write_iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "3200-3272",
    "snippet": "ssize_t __generic_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space * mapping = file->f_mapping;\n\tstruct inode \t*inode = mapping->host;\n\tssize_t\t\twritten = 0;\n\tssize_t\t\terr;\n\tssize_t\t\tstatus;\n\n\t/* We can write back this queue in page reclaim */\n\tcurrent->backing_dev_info = inode_to_bdi(inode);\n\terr = file_remove_privs(file);\n\tif (err)\n\t\tgoto out;\n\n\terr = file_update_time(file);\n\tif (err)\n\t\tgoto out;\n\n\tif (iocb->ki_flags & IOCB_DIRECT) {\n\t\tloff_t pos, endbyte;\n\n\t\twritten = generic_file_direct_write(iocb, from);\n\t\t/*\n\t\t * If the write stopped short of completing, fall back to\n\t\t * buffered writes.  Some filesystems do this for writes to\n\t\t * holes, for example.  For DAX files, a buffered write will\n\t\t * not succeed (even if it did, DAX does not handle dirty\n\t\t * page-cache pages correctly).\n\t\t */\n\t\tif (written < 0 || !iov_iter_count(from) || IS_DAX(inode))\n\t\t\tgoto out;\n\n\t\tstatus = generic_perform_write(file, from, pos = iocb->ki_pos);\n\t\t/*\n\t\t * If generic_perform_write() returned a synchronous error\n\t\t * then we want to return the number of bytes which were\n\t\t * direct-written, or the error code if that was zero.  Note\n\t\t * that this differs from normal direct-io semantics, which\n\t\t * will return -EFOO even if some bytes were written.\n\t\t */\n\t\tif (unlikely(status < 0)) {\n\t\t\terr = status;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * We need to ensure that the page cache pages are written to\n\t\t * disk and invalidated to preserve the expected O_DIRECT\n\t\t * semantics.\n\t\t */\n\t\tendbyte = pos + status - 1;\n\t\terr = filemap_write_and_wait_range(mapping, pos, endbyte);\n\t\tif (err == 0) {\n\t\t\tiocb->ki_pos = endbyte + 1;\n\t\t\twritten += status;\n\t\t\tinvalidate_mapping_pages(mapping,\n\t\t\t\t\t\t pos >> PAGE_SHIFT,\n\t\t\t\t\t\t endbyte >> PAGE_SHIFT);\n\t\t} else {\n\t\t\t/*\n\t\t\t * We don't know how much we wrote, so just return\n\t\t\t * the number of bytes which were direct-written\n\t\t\t */\n\t\t}\n\t} else {\n\t\twritten = generic_perform_write(file, from, iocb->ki_pos);\n\t\tif (likely(written > 0))\n\t\t\tiocb->ki_pos += written;\n\t}\nout:\n\tcurrent->backing_dev_info = NULL;\n\treturn written ? written : err;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "written > 0"
          ],
          "line": 3266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_perform_write",
          "args": [
            "file",
            "from",
            "iocb->ki_pos"
          ],
          "line": 3265
        },
        "resolved": true,
        "details": {
          "function_name": "generic_perform_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "3099-3180",
          "snippet": "ssize_t generic_perform_write(struct file *file,\n\t\t\t\tstruct iov_iter *i, loff_t pos)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\tconst struct address_space_operations *a_ops = mapping->a_ops;\n\tlong status = 0;\n\tssize_t written = 0;\n\tunsigned int flags = 0;\n\n\tdo {\n\t\tstruct page *page;\n\t\tunsigned long offset;\t/* Offset into pagecache page */\n\t\tunsigned long bytes;\t/* Bytes to write to page */\n\t\tsize_t copied;\t\t/* Bytes copied from user */\n\t\tvoid *fsdata;\n\n\t\toffset = (pos & (PAGE_SIZE - 1));\n\t\tbytes = min_t(unsigned long, PAGE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_count(i));\n\nagain:\n\t\t/*\n\t\t * Bring in the user page that we will copy from _first_.\n\t\t * Otherwise there's a nasty deadlock on copying from the\n\t\t * same page as we're writing to, without it being marked\n\t\t * up-to-date.\n\t\t *\n\t\t * Not only is this an optimisation, but it is also required\n\t\t * to check that the address is actually valid, when atomic\n\t\t * usercopies are used, below.\n\t\t */\n\t\tif (unlikely(iov_iter_fault_in_readable(i, bytes))) {\n\t\t\tstatus = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tstatus = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = a_ops->write_begin(file, mapping, pos, bytes, flags,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (unlikely(status < 0))\n\t\t\tbreak;\n\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\n\t\tcopied = iov_iter_copy_from_user_atomic(page, i, offset, bytes);\n\t\tflush_dcache_page(page);\n\n\t\tstatus = a_ops->write_end(file, mapping, pos, bytes, copied,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (unlikely(status < 0))\n\t\t\tbreak;\n\t\tcopied = status;\n\n\t\tcond_resched();\n\n\t\tiov_iter_advance(i, copied);\n\t\tif (unlikely(copied == 0)) {\n\t\t\t/*\n\t\t\t * If we were unable to copy any data at all, we must\n\t\t\t * fall back to a single segment length write.\n\t\t\t *\n\t\t\t * If we didn't fallback here, we could livelock\n\t\t\t * because not all segments in the iov can be copied at\n\t\t\t * once without a pagefault.\n\t\t\t */\n\t\t\tbytes = min_t(unsigned long, PAGE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_single_seg_count(i));\n\t\t\tgoto again;\n\t\t}\n\t\tpos += copied;\n\t\twritten += copied;\n\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t} while (iov_iter_count(i));\n\n\treturn written ? written : status;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nssize_t generic_perform_write(struct file *file,\n\t\t\t\tstruct iov_iter *i, loff_t pos)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\tconst struct address_space_operations *a_ops = mapping->a_ops;\n\tlong status = 0;\n\tssize_t written = 0;\n\tunsigned int flags = 0;\n\n\tdo {\n\t\tstruct page *page;\n\t\tunsigned long offset;\t/* Offset into pagecache page */\n\t\tunsigned long bytes;\t/* Bytes to write to page */\n\t\tsize_t copied;\t\t/* Bytes copied from user */\n\t\tvoid *fsdata;\n\n\t\toffset = (pos & (PAGE_SIZE - 1));\n\t\tbytes = min_t(unsigned long, PAGE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_count(i));\n\nagain:\n\t\t/*\n\t\t * Bring in the user page that we will copy from _first_.\n\t\t * Otherwise there's a nasty deadlock on copying from the\n\t\t * same page as we're writing to, without it being marked\n\t\t * up-to-date.\n\t\t *\n\t\t * Not only is this an optimisation, but it is also required\n\t\t * to check that the address is actually valid, when atomic\n\t\t * usercopies are used, below.\n\t\t */\n\t\tif (unlikely(iov_iter_fault_in_readable(i, bytes))) {\n\t\t\tstatus = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tstatus = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = a_ops->write_begin(file, mapping, pos, bytes, flags,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (unlikely(status < 0))\n\t\t\tbreak;\n\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\n\t\tcopied = iov_iter_copy_from_user_atomic(page, i, offset, bytes);\n\t\tflush_dcache_page(page);\n\n\t\tstatus = a_ops->write_end(file, mapping, pos, bytes, copied,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (unlikely(status < 0))\n\t\t\tbreak;\n\t\tcopied = status;\n\n\t\tcond_resched();\n\n\t\tiov_iter_advance(i, copied);\n\t\tif (unlikely(copied == 0)) {\n\t\t\t/*\n\t\t\t * If we were unable to copy any data at all, we must\n\t\t\t * fall back to a single segment length write.\n\t\t\t *\n\t\t\t * If we didn't fallback here, we could livelock\n\t\t\t * because not all segments in the iov can be copied at\n\t\t\t * once without a pagefault.\n\t\t\t */\n\t\t\tbytes = min_t(unsigned long, PAGE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_single_seg_count(i));\n\t\t\tgoto again;\n\t\t}\n\t\tpos += copied;\n\t\twritten += copied;\n\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t} while (iov_iter_count(i));\n\n\treturn written ? written : status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_mapping_pages",
          "args": [
            "mapping",
            "pos >> PAGE_SHIFT",
            "endbyte >> PAGE_SHIFT"
          ],
          "line": 3255
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_mapping_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "543-610",
          "snippet": "unsigned long invalidate_mapping_pages(struct address_space *mapping,\n\t\tpgoff_t start, pgoff_t end)\n{\n\tpgoff_t indices[PAGEVEC_SIZE];\n\tstruct pagevec pvec;\n\tpgoff_t index = start;\n\tunsigned long ret;\n\tunsigned long count = 0;\n\tint i;\n\n\tpagevec_init(&pvec);\n\twhile (index <= end && pagevec_lookup_entries(&pvec, mapping, index,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE - 1) + 1,\n\t\t\tindices)) {\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* We rely upon deletion not changing page->index */\n\t\t\tindex = indices[i];\n\t\t\tif (index > end)\n\t\t\t\tbreak;\n\n\t\t\tif (xa_is_value(page)) {\n\t\t\t\tinvalidate_exceptional_entry(mapping, index,\n\t\t\t\t\t\t\t     page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!trylock_page(page))\n\t\t\t\tcontinue;\n\n\t\t\tWARN_ON(page_to_index(page) != index);\n\n\t\t\t/* Middle of THP: skip */\n\t\t\tif (PageTransTail(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t} else if (PageTransHuge(page)) {\n\t\t\t\tindex += HPAGE_PMD_NR - 1;\n\t\t\t\ti += HPAGE_PMD_NR - 1;\n\t\t\t\t/*\n\t\t\t\t * 'end' is in the middle of THP. Don't\n\t\t\t\t * invalidate the page as the part outside of\n\t\t\t\t * 'end' could be still useful.\n\t\t\t\t */\n\t\t\t\tif (index > end) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = invalidate_inode_page(page);\n\t\t\tunlock_page(page);\n\t\t\t/*\n\t\t\t * Invalidation is a hint that the page is no longer\n\t\t\t * of interest and try to speed up its reclaim.\n\t\t\t */\n\t\t\tif (!ret)\n\t\t\t\tdeactivate_file_page(page);\n\t\t\tcount += ret;\n\t\t}\n\t\tpagevec_remove_exceptionals(&pvec);\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t\tindex++;\n\t}\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nunsigned long invalidate_mapping_pages(struct address_space *mapping,\n\t\tpgoff_t start, pgoff_t end)\n{\n\tpgoff_t indices[PAGEVEC_SIZE];\n\tstruct pagevec pvec;\n\tpgoff_t index = start;\n\tunsigned long ret;\n\tunsigned long count = 0;\n\tint i;\n\n\tpagevec_init(&pvec);\n\twhile (index <= end && pagevec_lookup_entries(&pvec, mapping, index,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE - 1) + 1,\n\t\t\tindices)) {\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* We rely upon deletion not changing page->index */\n\t\t\tindex = indices[i];\n\t\t\tif (index > end)\n\t\t\t\tbreak;\n\n\t\t\tif (xa_is_value(page)) {\n\t\t\t\tinvalidate_exceptional_entry(mapping, index,\n\t\t\t\t\t\t\t     page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!trylock_page(page))\n\t\t\t\tcontinue;\n\n\t\t\tWARN_ON(page_to_index(page) != index);\n\n\t\t\t/* Middle of THP: skip */\n\t\t\tif (PageTransTail(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t} else if (PageTransHuge(page)) {\n\t\t\t\tindex += HPAGE_PMD_NR - 1;\n\t\t\t\ti += HPAGE_PMD_NR - 1;\n\t\t\t\t/*\n\t\t\t\t * 'end' is in the middle of THP. Don't\n\t\t\t\t * invalidate the page as the part outside of\n\t\t\t\t * 'end' could be still useful.\n\t\t\t\t */\n\t\t\t\tif (index > end) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = invalidate_inode_page(page);\n\t\t\tunlock_page(page);\n\t\t\t/*\n\t\t\t * Invalidation is a hint that the page is no longer\n\t\t\t * of interest and try to speed up its reclaim.\n\t\t\t */\n\t\t\tif (!ret)\n\t\t\t\tdeactivate_file_page(page);\n\t\t\tcount += ret;\n\t\t}\n\t\tpagevec_remove_exceptionals(&pvec);\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t\tindex++;\n\t}\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "mapping",
            "pos",
            "endbyte"
          ],
          "line": 3251
        },
        "resolved": true,
        "details": {
          "function_name": "filemap_write_and_wait_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "627-649",
          "snippet": "int filemap_write_and_wait_range(struct address_space *mapping,\n\t\t\t\t loff_t lstart, loff_t lend)\n{\n\tint err = 0;\n\n\tif (mapping_needs_writeback(mapping)) {\n\t\terr = __filemap_fdatawrite_range(mapping, lstart, lend,\n\t\t\t\t\t\t WB_SYNC_ALL);\n\t\t/* See comment of filemap_write_and_wait() */\n\t\tif (err != -EIO) {\n\t\t\tint err2 = filemap_fdatawait_range(mapping,\n\t\t\t\t\t\tlstart, lend);\n\t\t\tif (!err)\n\t\t\t\terr = err2;\n\t\t} else {\n\t\t\t/* Clear any previously stored errors */\n\t\t\tfilemap_check_errors(mapping);\n\t\t}\n\t} else {\n\t\terr = filemap_check_errors(mapping);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint filemap_write_and_wait_range(struct address_space *mapping,\n\t\t\t\t loff_t lstart, loff_t lend)\n{\n\tint err = 0;\n\n\tif (mapping_needs_writeback(mapping)) {\n\t\terr = __filemap_fdatawrite_range(mapping, lstart, lend,\n\t\t\t\t\t\t WB_SYNC_ALL);\n\t\t/* See comment of filemap_write_and_wait() */\n\t\tif (err != -EIO) {\n\t\t\tint err2 = filemap_fdatawait_range(mapping,\n\t\t\t\t\t\tlstart, lend);\n\t\t\tif (!err)\n\t\t\t\terr = err2;\n\t\t} else {\n\t\t\t/* Clear any previously stored errors */\n\t\t\tfilemap_check_errors(mapping);\n\t\t}\n\t} else {\n\t\terr = filemap_check_errors(mapping);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status < 0"
          ],
          "line": 3241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DAX",
          "args": [
            "inode"
          ],
          "line": 3230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 3230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_file_direct_write",
          "args": [
            "iocb",
            "from"
          ],
          "line": 3222
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_direct_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "2999-3074",
          "snippet": "ssize_t\ngeneric_file_direct_write(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file\t*file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode\t*inode = mapping->host;\n\tloff_t\t\tpos = iocb->ki_pos;\n\tssize_t\t\twritten;\n\tsize_t\t\twrite_len;\n\tpgoff_t\t\tend;\n\n\twrite_len = iov_iter_count(from);\n\tend = (pos + write_len - 1) >> PAGE_SHIFT;\n\n\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\t/* If there are pages to writeback, return */\n\t\tif (filemap_range_has_page(inode->i_mapping, pos,\n\t\t\t\t\t   pos + write_len))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\twritten = filemap_write_and_wait_range(mapping, pos,\n\t\t\t\t\t\t\tpos + write_len - 1);\n\t\tif (written)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * After a write we want buffered reads to be sure to go to disk to get\n\t * the new data.  We invalidate clean cached page from the region we're\n\t * about to write.  We do this *before* the write so that we can return\n\t * without clobbering -EIOCBQUEUED from ->direct_IO().\n\t */\n\twritten = invalidate_inode_pages2_range(mapping,\n\t\t\t\t\tpos >> PAGE_SHIFT, end);\n\t/*\n\t * If a page can not be invalidated, return 0 to fall back\n\t * to buffered write.\n\t */\n\tif (written) {\n\t\tif (written == -EBUSY)\n\t\t\treturn 0;\n\t\tgoto out;\n\t}\n\n\twritten = mapping->a_ops->direct_IO(iocb, from);\n\n\t/*\n\t * Finally, try again to invalidate clean pages which might have been\n\t * cached by non-direct readahead, or faulted in by get_user_pages()\n\t * if the source of the write was an mmap'ed region of the file\n\t * we're writing.  Either one is a pretty crazy thing to do,\n\t * so we don't support it 100%.  If this invalidation\n\t * fails, tough, the write still worked...\n\t *\n\t * Most of the time we do not need this since dio_complete() will do\n\t * the invalidation for us. However there are some file systems that\n\t * do not end up with dio_complete() being called, so let's not break\n\t * them by removing it completely\n\t */\n\tif (mapping->nrpages)\n\t\tinvalidate_inode_pages2_range(mapping,\n\t\t\t\t\tpos >> PAGE_SHIFT, end);\n\n\tif (written > 0) {\n\t\tpos += written;\n\t\twrite_len -= written;\n\t\tif (pos > i_size_read(inode) && !S_ISBLK(inode->i_mode)) {\n\t\t\ti_size_write(inode, pos);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t\tiocb->ki_pos = pos;\n\t}\n\tiov_iter_revert(from, write_len - iov_iter_count(from));\nout:\n\treturn written;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nssize_t\ngeneric_file_direct_write(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file\t*file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode\t*inode = mapping->host;\n\tloff_t\t\tpos = iocb->ki_pos;\n\tssize_t\t\twritten;\n\tsize_t\t\twrite_len;\n\tpgoff_t\t\tend;\n\n\twrite_len = iov_iter_count(from);\n\tend = (pos + write_len - 1) >> PAGE_SHIFT;\n\n\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\t/* If there are pages to writeback, return */\n\t\tif (filemap_range_has_page(inode->i_mapping, pos,\n\t\t\t\t\t   pos + write_len))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\twritten = filemap_write_and_wait_range(mapping, pos,\n\t\t\t\t\t\t\tpos + write_len - 1);\n\t\tif (written)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * After a write we want buffered reads to be sure to go to disk to get\n\t * the new data.  We invalidate clean cached page from the region we're\n\t * about to write.  We do this *before* the write so that we can return\n\t * without clobbering -EIOCBQUEUED from ->direct_IO().\n\t */\n\twritten = invalidate_inode_pages2_range(mapping,\n\t\t\t\t\tpos >> PAGE_SHIFT, end);\n\t/*\n\t * If a page can not be invalidated, return 0 to fall back\n\t * to buffered write.\n\t */\n\tif (written) {\n\t\tif (written == -EBUSY)\n\t\t\treturn 0;\n\t\tgoto out;\n\t}\n\n\twritten = mapping->a_ops->direct_IO(iocb, from);\n\n\t/*\n\t * Finally, try again to invalidate clean pages which might have been\n\t * cached by non-direct readahead, or faulted in by get_user_pages()\n\t * if the source of the write was an mmap'ed region of the file\n\t * we're writing.  Either one is a pretty crazy thing to do,\n\t * so we don't support it 100%.  If this invalidation\n\t * fails, tough, the write still worked...\n\t *\n\t * Most of the time we do not need this since dio_complete() will do\n\t * the invalidation for us. However there are some file systems that\n\t * do not end up with dio_complete() being called, so let's not break\n\t * them by removing it completely\n\t */\n\tif (mapping->nrpages)\n\t\tinvalidate_inode_pages2_range(mapping,\n\t\t\t\t\tpos >> PAGE_SHIFT, end);\n\n\tif (written > 0) {\n\t\tpos += written;\n\t\twrite_len -= written;\n\t\tif (pos > i_size_read(inode) && !S_ISBLK(inode->i_mode)) {\n\t\t\ti_size_write(inode, pos);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t\tiocb->ki_pos = pos;\n\t}\n\tiov_iter_revert(from, write_len - iov_iter_count(from));\nout:\n\treturn written;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_update_time",
          "args": [
            "file"
          ],
          "line": 3215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_remove_privs",
          "args": [
            "file"
          ],
          "line": 3211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "inode"
          ],
          "line": 3210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nssize_t __generic_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space * mapping = file->f_mapping;\n\tstruct inode \t*inode = mapping->host;\n\tssize_t\t\twritten = 0;\n\tssize_t\t\terr;\n\tssize_t\t\tstatus;\n\n\t/* We can write back this queue in page reclaim */\n\tcurrent->backing_dev_info = inode_to_bdi(inode);\n\terr = file_remove_privs(file);\n\tif (err)\n\t\tgoto out;\n\n\terr = file_update_time(file);\n\tif (err)\n\t\tgoto out;\n\n\tif (iocb->ki_flags & IOCB_DIRECT) {\n\t\tloff_t pos, endbyte;\n\n\t\twritten = generic_file_direct_write(iocb, from);\n\t\t/*\n\t\t * If the write stopped short of completing, fall back to\n\t\t * buffered writes.  Some filesystems do this for writes to\n\t\t * holes, for example.  For DAX files, a buffered write will\n\t\t * not succeed (even if it did, DAX does not handle dirty\n\t\t * page-cache pages correctly).\n\t\t */\n\t\tif (written < 0 || !iov_iter_count(from) || IS_DAX(inode))\n\t\t\tgoto out;\n\n\t\tstatus = generic_perform_write(file, from, pos = iocb->ki_pos);\n\t\t/*\n\t\t * If generic_perform_write() returned a synchronous error\n\t\t * then we want to return the number of bytes which were\n\t\t * direct-written, or the error code if that was zero.  Note\n\t\t * that this differs from normal direct-io semantics, which\n\t\t * will return -EFOO even if some bytes were written.\n\t\t */\n\t\tif (unlikely(status < 0)) {\n\t\t\terr = status;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * We need to ensure that the page cache pages are written to\n\t\t * disk and invalidated to preserve the expected O_DIRECT\n\t\t * semantics.\n\t\t */\n\t\tendbyte = pos + status - 1;\n\t\terr = filemap_write_and_wait_range(mapping, pos, endbyte);\n\t\tif (err == 0) {\n\t\t\tiocb->ki_pos = endbyte + 1;\n\t\t\twritten += status;\n\t\t\tinvalidate_mapping_pages(mapping,\n\t\t\t\t\t\t pos >> PAGE_SHIFT,\n\t\t\t\t\t\t endbyte >> PAGE_SHIFT);\n\t\t} else {\n\t\t\t/*\n\t\t\t * We don't know how much we wrote, so just return\n\t\t\t * the number of bytes which were direct-written\n\t\t\t */\n\t\t}\n\t} else {\n\t\twritten = generic_perform_write(file, from, iocb->ki_pos);\n\t\tif (likely(written > 0))\n\t\t\tiocb->ki_pos += written;\n\t}\nout:\n\tcurrent->backing_dev_info = NULL;\n\treturn written ? written : err;\n}"
  },
  {
    "function_name": "generic_perform_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "3099-3180",
    "snippet": "ssize_t generic_perform_write(struct file *file,\n\t\t\t\tstruct iov_iter *i, loff_t pos)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\tconst struct address_space_operations *a_ops = mapping->a_ops;\n\tlong status = 0;\n\tssize_t written = 0;\n\tunsigned int flags = 0;\n\n\tdo {\n\t\tstruct page *page;\n\t\tunsigned long offset;\t/* Offset into pagecache page */\n\t\tunsigned long bytes;\t/* Bytes to write to page */\n\t\tsize_t copied;\t\t/* Bytes copied from user */\n\t\tvoid *fsdata;\n\n\t\toffset = (pos & (PAGE_SIZE - 1));\n\t\tbytes = min_t(unsigned long, PAGE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_count(i));\n\nagain:\n\t\t/*\n\t\t * Bring in the user page that we will copy from _first_.\n\t\t * Otherwise there's a nasty deadlock on copying from the\n\t\t * same page as we're writing to, without it being marked\n\t\t * up-to-date.\n\t\t *\n\t\t * Not only is this an optimisation, but it is also required\n\t\t * to check that the address is actually valid, when atomic\n\t\t * usercopies are used, below.\n\t\t */\n\t\tif (unlikely(iov_iter_fault_in_readable(i, bytes))) {\n\t\t\tstatus = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tstatus = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = a_ops->write_begin(file, mapping, pos, bytes, flags,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (unlikely(status < 0))\n\t\t\tbreak;\n\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\n\t\tcopied = iov_iter_copy_from_user_atomic(page, i, offset, bytes);\n\t\tflush_dcache_page(page);\n\n\t\tstatus = a_ops->write_end(file, mapping, pos, bytes, copied,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (unlikely(status < 0))\n\t\t\tbreak;\n\t\tcopied = status;\n\n\t\tcond_resched();\n\n\t\tiov_iter_advance(i, copied);\n\t\tif (unlikely(copied == 0)) {\n\t\t\t/*\n\t\t\t * If we were unable to copy any data at all, we must\n\t\t\t * fall back to a single segment length write.\n\t\t\t *\n\t\t\t * If we didn't fallback here, we could livelock\n\t\t\t * because not all segments in the iov can be copied at\n\t\t\t * once without a pagefault.\n\t\t\t */\n\t\t\tbytes = min_t(unsigned long, PAGE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_single_seg_count(i));\n\t\t\tgoto again;\n\t\t}\n\t\tpos += copied;\n\t\twritten += copied;\n\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t} while (iov_iter_count(i));\n\n\treturn written ? written : status;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "i"
          ],
          "line": 3177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balance_dirty_pages_ratelimited",
          "args": [
            "mapping"
          ],
          "line": 3176
        },
        "resolved": true,
        "details": {
          "function_name": "balance_dirty_pages_ratelimited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1861-1913",
          "snippet": "void balance_dirty_pages_ratelimited(struct address_space *mapping)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\tstruct bdi_writeback *wb = NULL;\n\tint ratelimit;\n\tint *p;\n\n\tif (!bdi_cap_account_dirty(bdi))\n\t\treturn;\n\n\tif (inode_cgwb_enabled(inode))\n\t\twb = wb_get_create_current(bdi, GFP_KERNEL);\n\tif (!wb)\n\t\twb = &bdi->wb;\n\n\tratelimit = current->nr_dirtied_pause;\n\tif (wb->dirty_exceeded)\n\t\tratelimit = min(ratelimit, 32 >> (PAGE_SHIFT - 10));\n\n\tpreempt_disable();\n\t/*\n\t * This prevents one CPU to accumulate too many dirtied pages without\n\t * calling into balance_dirty_pages(), which can happen when there are\n\t * 1000+ tasks, all of them start dirtying pages at exactly the same\n\t * time, hence all honoured too large initial task->nr_dirtied_pause.\n\t */\n\tp =  this_cpu_ptr(&bdp_ratelimits);\n\tif (unlikely(current->nr_dirtied >= ratelimit))\n\t\t*p = 0;\n\telse if (unlikely(*p >= ratelimit_pages)) {\n\t\t*p = 0;\n\t\tratelimit = 0;\n\t}\n\t/*\n\t * Pick up the dirtied pages by the exited tasks. This avoids lots of\n\t * short-lived tasks (eg. gcc invocations in a kernel build) escaping\n\t * the dirty throttling and livelock other long-run dirtiers.\n\t */\n\tp = this_cpu_ptr(&dirty_throttle_leaks);\n\tif (*p > 0 && current->nr_dirtied < ratelimit) {\n\t\tunsigned long nr_pages_dirtied;\n\t\tnr_pages_dirtied = min(*p, ratelimit - current->nr_dirtied);\n\t\t*p -= nr_pages_dirtied;\n\t\tcurrent->nr_dirtied += nr_pages_dirtied;\n\t}\n\tpreempt_enable();\n\n\tif (unlikely(current->nr_dirtied >= ratelimit))\n\t\tbalance_dirty_pages(wb, current->nr_dirtied);\n\n\twb_put(wb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long ratelimit_pages = 32;",
            "static DEFINE_PER_CPU(int, bdp_ratelimits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long ratelimit_pages = 32;\nstatic DEFINE_PER_CPU(int, bdp_ratelimits);\n\nvoid balance_dirty_pages_ratelimited(struct address_space *mapping)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\tstruct bdi_writeback *wb = NULL;\n\tint ratelimit;\n\tint *p;\n\n\tif (!bdi_cap_account_dirty(bdi))\n\t\treturn;\n\n\tif (inode_cgwb_enabled(inode))\n\t\twb = wb_get_create_current(bdi, GFP_KERNEL);\n\tif (!wb)\n\t\twb = &bdi->wb;\n\n\tratelimit = current->nr_dirtied_pause;\n\tif (wb->dirty_exceeded)\n\t\tratelimit = min(ratelimit, 32 >> (PAGE_SHIFT - 10));\n\n\tpreempt_disable();\n\t/*\n\t * This prevents one CPU to accumulate too many dirtied pages without\n\t * calling into balance_dirty_pages(), which can happen when there are\n\t * 1000+ tasks, all of them start dirtying pages at exactly the same\n\t * time, hence all honoured too large initial task->nr_dirtied_pause.\n\t */\n\tp =  this_cpu_ptr(&bdp_ratelimits);\n\tif (unlikely(current->nr_dirtied >= ratelimit))\n\t\t*p = 0;\n\telse if (unlikely(*p >= ratelimit_pages)) {\n\t\t*p = 0;\n\t\tratelimit = 0;\n\t}\n\t/*\n\t * Pick up the dirtied pages by the exited tasks. This avoids lots of\n\t * short-lived tasks (eg. gcc invocations in a kernel build) escaping\n\t * the dirty throttling and livelock other long-run dirtiers.\n\t */\n\tp = this_cpu_ptr(&dirty_throttle_leaks);\n\tif (*p > 0 && current->nr_dirtied < ratelimit) {\n\t\tunsigned long nr_pages_dirtied;\n\t\tnr_pages_dirtied = min(*p, ratelimit - current->nr_dirtied);\n\t\t*p -= nr_pages_dirtied;\n\t\tcurrent->nr_dirtied += nr_pages_dirtied;\n\t}\n\tpreempt_enable();\n\n\tif (unlikely(current->nr_dirtied >= ratelimit))\n\t\tbalance_dirty_pages(wb, current->nr_dirtied);\n\n\twb_put(wb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "PAGE_SIZE - offset",
            "iov_iter_single_seg_count(i)"
          ],
          "line": 3169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_single_seg_count",
          "args": [
            "i"
          ],
          "line": 3170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "copied == 0"
          ],
          "line": 3160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_advance",
          "args": [
            "i",
            "copied"
          ],
          "line": 3159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 3157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status < 0"
          ],
          "line": 3153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a_ops->write_end",
          "args": [
            "file",
            "mapping",
            "pos",
            "bytes",
            "copied",
            "page",
            "fsdata"
          ],
          "line": 3151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 3149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_copy_from_user_atomic",
          "args": [
            "page",
            "i",
            "offset",
            "bytes"
          ],
          "line": 3148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 3146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_writably_mapped",
          "args": [
            "mapping"
          ],
          "line": 3145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status < 0"
          ],
          "line": 3142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a_ops->write_begin",
          "args": [
            "file",
            "mapping",
            "pos",
            "bytes",
            "flags",
            "&page",
            "&fsdata"
          ],
          "line": 3140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 3135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "iov_iter_fault_in_readable(i, bytes)"
          ],
          "line": 3130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_fault_in_readable",
          "args": [
            "i",
            "bytes"
          ],
          "line": 3130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "PAGE_SIZE - offset",
            "iov_iter_count(i)"
          ],
          "line": 3116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "i"
          ],
          "line": 3117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nssize_t generic_perform_write(struct file *file,\n\t\t\t\tstruct iov_iter *i, loff_t pos)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\tconst struct address_space_operations *a_ops = mapping->a_ops;\n\tlong status = 0;\n\tssize_t written = 0;\n\tunsigned int flags = 0;\n\n\tdo {\n\t\tstruct page *page;\n\t\tunsigned long offset;\t/* Offset into pagecache page */\n\t\tunsigned long bytes;\t/* Bytes to write to page */\n\t\tsize_t copied;\t\t/* Bytes copied from user */\n\t\tvoid *fsdata;\n\n\t\toffset = (pos & (PAGE_SIZE - 1));\n\t\tbytes = min_t(unsigned long, PAGE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_count(i));\n\nagain:\n\t\t/*\n\t\t * Bring in the user page that we will copy from _first_.\n\t\t * Otherwise there's a nasty deadlock on copying from the\n\t\t * same page as we're writing to, without it being marked\n\t\t * up-to-date.\n\t\t *\n\t\t * Not only is this an optimisation, but it is also required\n\t\t * to check that the address is actually valid, when atomic\n\t\t * usercopies are used, below.\n\t\t */\n\t\tif (unlikely(iov_iter_fault_in_readable(i, bytes))) {\n\t\t\tstatus = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tstatus = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = a_ops->write_begin(file, mapping, pos, bytes, flags,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (unlikely(status < 0))\n\t\t\tbreak;\n\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\n\t\tcopied = iov_iter_copy_from_user_atomic(page, i, offset, bytes);\n\t\tflush_dcache_page(page);\n\n\t\tstatus = a_ops->write_end(file, mapping, pos, bytes, copied,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (unlikely(status < 0))\n\t\t\tbreak;\n\t\tcopied = status;\n\n\t\tcond_resched();\n\n\t\tiov_iter_advance(i, copied);\n\t\tif (unlikely(copied == 0)) {\n\t\t\t/*\n\t\t\t * If we were unable to copy any data at all, we must\n\t\t\t * fall back to a single segment length write.\n\t\t\t *\n\t\t\t * If we didn't fallback here, we could livelock\n\t\t\t * because not all segments in the iov can be copied at\n\t\t\t * once without a pagefault.\n\t\t\t */\n\t\t\tbytes = min_t(unsigned long, PAGE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_single_seg_count(i));\n\t\t\tgoto again;\n\t\t}\n\t\tpos += copied;\n\t\twritten += copied;\n\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t} while (iov_iter_count(i));\n\n\treturn written ? written : status;\n}"
  },
  {
    "function_name": "grab_cache_page_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "3081-3096",
    "snippet": "struct page *grab_cache_page_write_begin(struct address_space *mapping,\n\t\t\t\t\tpgoff_t index, unsigned flags)\n{\n\tstruct page *page;\n\tint fgp_flags = FGP_LOCK|FGP_WRITE|FGP_CREAT;\n\n\tif (flags & AOP_FLAG_NOFS)\n\t\tfgp_flags |= FGP_NOFS;\n\n\tpage = pagecache_get_page(mapping, index, fgp_flags,\n\t\t\tmapping_gfp_mask(mapping));\n\tif (page)\n\t\twait_for_stable_page(page);\n\n\treturn page;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_for_stable_page",
          "args": [
            "page"
          ],
          "line": 3093
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_stable_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2804-2808",
          "snippet": "void wait_for_stable_page(struct page *page)\n{\n\tif (bdi_cap_stable_pages_required(inode_to_bdi(page->mapping->host)))\n\t\twait_on_page_writeback(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid wait_for_stable_page(struct page *page)\n{\n\tif (bdi_cap_stable_pages_required(inode_to_bdi(page->mapping->host)))\n\t\twait_on_page_writeback(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagecache_get_page",
          "args": [
            "mapping",
            "index",
            "fgp_flags",
            "mapping_gfp_mask(mapping)"
          ],
          "line": 3090
        },
        "resolved": true,
        "details": {
          "function_name": "pagecache_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1512-1575",
          "snippet": "struct page *pagecache_get_page(struct address_space *mapping, pgoff_t offset,\n\tint fgp_flags, gfp_t gfp_mask)\n{\n\tstruct page *page;\n\nrepeat:\n\tpage = find_get_entry(mapping, offset);\n\tif (xa_is_value(page))\n\t\tpage = NULL;\n\tif (!page)\n\t\tgoto no_page;\n\n\tif (fgp_flags & FGP_LOCK) {\n\t\tif (fgp_flags & FGP_NOWAIT) {\n\t\t\tif (!trylock_page(page)) {\n\t\t\t\tput_page(page);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tlock_page(page);\n\t\t}\n\n\t\t/* Has the page been truncated? */\n\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto repeat;\n\t\t}\n\t\tVM_BUG_ON_PAGE(page->index != offset, page);\n\t}\n\n\tif (page && (fgp_flags & FGP_ACCESSED))\n\t\tmark_page_accessed(page);\n\nno_page:\n\tif (!page && (fgp_flags & FGP_CREAT)) {\n\t\tint err;\n\t\tif ((fgp_flags & FGP_WRITE) && mapping_cap_account_dirty(mapping))\n\t\t\tgfp_mask |= __GFP_WRITE;\n\t\tif (fgp_flags & FGP_NOFS)\n\t\t\tgfp_mask &= ~__GFP_FS;\n\n\t\tpage = __page_cache_alloc(gfp_mask);\n\t\tif (!page)\n\t\t\treturn NULL;\n\n\t\tif (WARN_ON_ONCE(!(fgp_flags & FGP_LOCK)))\n\t\t\tfgp_flags |= FGP_LOCK;\n\n\t\t/* Init accessed so avoid atomic mark_page_accessed later */\n\t\tif (fgp_flags & FGP_ACCESSED)\n\t\t\t__SetPageReferenced(page);\n\n\t\terr = add_to_page_cache_lru(page, mapping, offset, gfp_mask);\n\t\tif (unlikely(err)) {\n\t\t\tput_page(page);\n\t\t\tpage = NULL;\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t}\n\t}\n\n\treturn page;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstruct page *pagecache_get_page(struct address_space *mapping, pgoff_t offset,\n\tint fgp_flags, gfp_t gfp_mask)\n{\n\tstruct page *page;\n\nrepeat:\n\tpage = find_get_entry(mapping, offset);\n\tif (xa_is_value(page))\n\t\tpage = NULL;\n\tif (!page)\n\t\tgoto no_page;\n\n\tif (fgp_flags & FGP_LOCK) {\n\t\tif (fgp_flags & FGP_NOWAIT) {\n\t\t\tif (!trylock_page(page)) {\n\t\t\t\tput_page(page);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tlock_page(page);\n\t\t}\n\n\t\t/* Has the page been truncated? */\n\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto repeat;\n\t\t}\n\t\tVM_BUG_ON_PAGE(page->index != offset, page);\n\t}\n\n\tif (page && (fgp_flags & FGP_ACCESSED))\n\t\tmark_page_accessed(page);\n\nno_page:\n\tif (!page && (fgp_flags & FGP_CREAT)) {\n\t\tint err;\n\t\tif ((fgp_flags & FGP_WRITE) && mapping_cap_account_dirty(mapping))\n\t\t\tgfp_mask |= __GFP_WRITE;\n\t\tif (fgp_flags & FGP_NOFS)\n\t\t\tgfp_mask &= ~__GFP_FS;\n\n\t\tpage = __page_cache_alloc(gfp_mask);\n\t\tif (!page)\n\t\t\treturn NULL;\n\n\t\tif (WARN_ON_ONCE(!(fgp_flags & FGP_LOCK)))\n\t\t\tfgp_flags |= FGP_LOCK;\n\n\t\t/* Init accessed so avoid atomic mark_page_accessed later */\n\t\tif (fgp_flags & FGP_ACCESSED)\n\t\t\t__SetPageReferenced(page);\n\n\t\terr = add_to_page_cache_lru(page, mapping, offset, gfp_mask);\n\t\tif (unlikely(err)) {\n\t\t\tput_page(page);\n\t\t\tpage = NULL;\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t}\n\t}\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_gfp_mask",
          "args": [
            "mapping"
          ],
          "line": 3091
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstruct page *grab_cache_page_write_begin(struct address_space *mapping,\n\t\t\t\t\tpgoff_t index, unsigned flags)\n{\n\tstruct page *page;\n\tint fgp_flags = FGP_LOCK|FGP_WRITE|FGP_CREAT;\n\n\tif (flags & AOP_FLAG_NOFS)\n\t\tfgp_flags |= FGP_NOFS;\n\n\tpage = pagecache_get_page(mapping, index, fgp_flags,\n\t\t\tmapping_gfp_mask(mapping));\n\tif (page)\n\t\twait_for_stable_page(page);\n\n\treturn page;\n}"
  },
  {
    "function_name": "generic_file_direct_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "2999-3074",
    "snippet": "ssize_t\ngeneric_file_direct_write(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file\t*file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode\t*inode = mapping->host;\n\tloff_t\t\tpos = iocb->ki_pos;\n\tssize_t\t\twritten;\n\tsize_t\t\twrite_len;\n\tpgoff_t\t\tend;\n\n\twrite_len = iov_iter_count(from);\n\tend = (pos + write_len - 1) >> PAGE_SHIFT;\n\n\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\t/* If there are pages to writeback, return */\n\t\tif (filemap_range_has_page(inode->i_mapping, pos,\n\t\t\t\t\t   pos + write_len))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\twritten = filemap_write_and_wait_range(mapping, pos,\n\t\t\t\t\t\t\tpos + write_len - 1);\n\t\tif (written)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * After a write we want buffered reads to be sure to go to disk to get\n\t * the new data.  We invalidate clean cached page from the region we're\n\t * about to write.  We do this *before* the write so that we can return\n\t * without clobbering -EIOCBQUEUED from ->direct_IO().\n\t */\n\twritten = invalidate_inode_pages2_range(mapping,\n\t\t\t\t\tpos >> PAGE_SHIFT, end);\n\t/*\n\t * If a page can not be invalidated, return 0 to fall back\n\t * to buffered write.\n\t */\n\tif (written) {\n\t\tif (written == -EBUSY)\n\t\t\treturn 0;\n\t\tgoto out;\n\t}\n\n\twritten = mapping->a_ops->direct_IO(iocb, from);\n\n\t/*\n\t * Finally, try again to invalidate clean pages which might have been\n\t * cached by non-direct readahead, or faulted in by get_user_pages()\n\t * if the source of the write was an mmap'ed region of the file\n\t * we're writing.  Either one is a pretty crazy thing to do,\n\t * so we don't support it 100%.  If this invalidation\n\t * fails, tough, the write still worked...\n\t *\n\t * Most of the time we do not need this since dio_complete() will do\n\t * the invalidation for us. However there are some file systems that\n\t * do not end up with dio_complete() being called, so let's not break\n\t * them by removing it completely\n\t */\n\tif (mapping->nrpages)\n\t\tinvalidate_inode_pages2_range(mapping,\n\t\t\t\t\tpos >> PAGE_SHIFT, end);\n\n\tif (written > 0) {\n\t\tpos += written;\n\t\twrite_len -= written;\n\t\tif (pos > i_size_read(inode) && !S_ISBLK(inode->i_mode)) {\n\t\t\ti_size_write(inode, pos);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t\tiocb->ki_pos = pos;\n\t}\n\tiov_iter_revert(from, write_len - iov_iter_count(from));\nout:\n\treturn written;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iov_iter_revert",
          "args": [
            "from",
            "write_len - iov_iter_count(from)"
          ],
          "line": 3071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 3071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 3067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "pos"
          ],
          "line": 3066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 3065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 3065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_inode_pages2_range",
          "args": [
            "mapping",
            "pos >> PAGE_SHIFT",
            "end"
          ],
          "line": 3059
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_inode_pages2_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "669-754",
          "snippet": "int invalidate_inode_pages2_range(struct address_space *mapping,\n\t\t\t\t  pgoff_t start, pgoff_t end)\n{\n\tpgoff_t indices[PAGEVEC_SIZE];\n\tstruct pagevec pvec;\n\tpgoff_t index;\n\tint i;\n\tint ret = 0;\n\tint ret2 = 0;\n\tint did_range_unmap = 0;\n\n\tif (mapping->nrpages == 0 && mapping->nrexceptional == 0)\n\t\tgoto out;\n\n\tpagevec_init(&pvec);\n\tindex = start;\n\twhile (index <= end && pagevec_lookup_entries(&pvec, mapping, index,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE - 1) + 1,\n\t\t\tindices)) {\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* We rely upon deletion not changing page->index */\n\t\t\tindex = indices[i];\n\t\t\tif (index > end)\n\t\t\t\tbreak;\n\n\t\t\tif (xa_is_value(page)) {\n\t\t\t\tif (!invalidate_exceptional_entry2(mapping,\n\t\t\t\t\t\t\t\t   index, page))\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlock_page(page);\n\t\t\tWARN_ON(page_to_index(page) != index);\n\t\t\tif (page->mapping != mapping) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twait_on_page_writeback(page);\n\t\t\tif (page_mapped(page)) {\n\t\t\t\tif (!did_range_unmap) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Zap the rest of the file in one hit.\n\t\t\t\t\t */\n\t\t\t\t\tunmap_mapping_pages(mapping, index,\n\t\t\t\t\t\t(1 + end - index), false);\n\t\t\t\t\tdid_range_unmap = 1;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Just zap this page\n\t\t\t\t\t */\n\t\t\t\t\tunmap_mapping_pages(mapping, index,\n\t\t\t\t\t\t\t\t1, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tBUG_ON(page_mapped(page));\n\t\t\tret2 = do_launder_page(mapping, page);\n\t\t\tif (ret2 == 0) {\n\t\t\t\tif (!invalidate_complete_page2(mapping, page))\n\t\t\t\t\tret2 = -EBUSY;\n\t\t\t}\n\t\t\tif (ret2 < 0)\n\t\t\t\tret = ret2;\n\t\t\tunlock_page(page);\n\t\t}\n\t\tpagevec_remove_exceptionals(&pvec);\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t\tindex++;\n\t}\n\t/*\n\t * For DAX we invalidate page tables after invalidating page cache.  We\n\t * could invalidate page tables while invalidating each entry however\n\t * that would be expensive. And doing range unmapping before doesn't\n\t * work as we have no cheap way to find whether page cache entry didn't\n\t * get remapped later.\n\t */\n\tif (dax_mapping(mapping)) {\n\t\tunmap_mapping_pages(mapping, start, end - start + 1, false);\n\t}\nout:\n\tcleancache_invalidate_inode(mapping);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nint invalidate_inode_pages2_range(struct address_space *mapping,\n\t\t\t\t  pgoff_t start, pgoff_t end)\n{\n\tpgoff_t indices[PAGEVEC_SIZE];\n\tstruct pagevec pvec;\n\tpgoff_t index;\n\tint i;\n\tint ret = 0;\n\tint ret2 = 0;\n\tint did_range_unmap = 0;\n\n\tif (mapping->nrpages == 0 && mapping->nrexceptional == 0)\n\t\tgoto out;\n\n\tpagevec_init(&pvec);\n\tindex = start;\n\twhile (index <= end && pagevec_lookup_entries(&pvec, mapping, index,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE - 1) + 1,\n\t\t\tindices)) {\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/* We rely upon deletion not changing page->index */\n\t\t\tindex = indices[i];\n\t\t\tif (index > end)\n\t\t\t\tbreak;\n\n\t\t\tif (xa_is_value(page)) {\n\t\t\t\tif (!invalidate_exceptional_entry2(mapping,\n\t\t\t\t\t\t\t\t   index, page))\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlock_page(page);\n\t\t\tWARN_ON(page_to_index(page) != index);\n\t\t\tif (page->mapping != mapping) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twait_on_page_writeback(page);\n\t\t\tif (page_mapped(page)) {\n\t\t\t\tif (!did_range_unmap) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Zap the rest of the file in one hit.\n\t\t\t\t\t */\n\t\t\t\t\tunmap_mapping_pages(mapping, index,\n\t\t\t\t\t\t(1 + end - index), false);\n\t\t\t\t\tdid_range_unmap = 1;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Just zap this page\n\t\t\t\t\t */\n\t\t\t\t\tunmap_mapping_pages(mapping, index,\n\t\t\t\t\t\t\t\t1, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tBUG_ON(page_mapped(page));\n\t\t\tret2 = do_launder_page(mapping, page);\n\t\t\tif (ret2 == 0) {\n\t\t\t\tif (!invalidate_complete_page2(mapping, page))\n\t\t\t\t\tret2 = -EBUSY;\n\t\t\t}\n\t\t\tif (ret2 < 0)\n\t\t\t\tret = ret2;\n\t\t\tunlock_page(page);\n\t\t}\n\t\tpagevec_remove_exceptionals(&pvec);\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t\tindex++;\n\t}\n\t/*\n\t * For DAX we invalidate page tables after invalidating page cache.  We\n\t * could invalidate page tables while invalidating each entry however\n\t * that would be expensive. And doing range unmapping before doesn't\n\t * work as we have no cheap way to find whether page cache entry didn't\n\t * get remapped later.\n\t */\n\tif (dax_mapping(mapping)) {\n\t\tunmap_mapping_pages(mapping, start, end - start + 1, false);\n\t}\nout:\n\tcleancache_invalidate_inode(mapping);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->direct_IO",
          "args": [
            "iocb",
            "from"
          ],
          "line": 3043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "mapping",
            "pos",
            "pos + write_len - 1"
          ],
          "line": 3019
        },
        "resolved": true,
        "details": {
          "function_name": "filemap_write_and_wait_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "627-649",
          "snippet": "int filemap_write_and_wait_range(struct address_space *mapping,\n\t\t\t\t loff_t lstart, loff_t lend)\n{\n\tint err = 0;\n\n\tif (mapping_needs_writeback(mapping)) {\n\t\terr = __filemap_fdatawrite_range(mapping, lstart, lend,\n\t\t\t\t\t\t WB_SYNC_ALL);\n\t\t/* See comment of filemap_write_and_wait() */\n\t\tif (err != -EIO) {\n\t\t\tint err2 = filemap_fdatawait_range(mapping,\n\t\t\t\t\t\tlstart, lend);\n\t\t\tif (!err)\n\t\t\t\terr = err2;\n\t\t} else {\n\t\t\t/* Clear any previously stored errors */\n\t\t\tfilemap_check_errors(mapping);\n\t\t}\n\t} else {\n\t\terr = filemap_check_errors(mapping);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint filemap_write_and_wait_range(struct address_space *mapping,\n\t\t\t\t loff_t lstart, loff_t lend)\n{\n\tint err = 0;\n\n\tif (mapping_needs_writeback(mapping)) {\n\t\terr = __filemap_fdatawrite_range(mapping, lstart, lend,\n\t\t\t\t\t\t WB_SYNC_ALL);\n\t\t/* See comment of filemap_write_and_wait() */\n\t\tif (err != -EIO) {\n\t\t\tint err2 = filemap_fdatawait_range(mapping,\n\t\t\t\t\t\tlstart, lend);\n\t\t\tif (!err)\n\t\t\t\terr = err2;\n\t\t} else {\n\t\t\t/* Clear any previously stored errors */\n\t\t\tfilemap_check_errors(mapping);\n\t\t}\n\t} else {\n\t\terr = filemap_check_errors(mapping);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_range_has_page",
          "args": [
            "inode->i_mapping",
            "pos",
            "pos + write_len"
          ],
          "line": 3015
        },
        "resolved": true,
        "details": {
          "function_name": "filemap_range_has_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "457-485",
          "snippet": "bool filemap_range_has_page(struct address_space *mapping,\n\t\t\t   loff_t start_byte, loff_t end_byte)\n{\n\tstruct page *page;\n\tXA_STATE(xas, &mapping->i_pages, start_byte >> PAGE_SHIFT);\n\tpgoff_t max = end_byte >> PAGE_SHIFT;\n\n\tif (end_byte < start_byte)\n\t\treturn false;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tpage = xas_find(&xas, max);\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\t\t/* Shadow entries don't count */\n\t\tif (xa_is_value(page))\n\t\t\tcontinue;\n\t\t/*\n\t\t * We don't need to try to pin this page; we're about to\n\t\t * release the RCU lock anyway.  It is enough to know that\n\t\t * there was a page here recently.\n\t\t */\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn page != NULL;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nbool filemap_range_has_page(struct address_space *mapping,\n\t\t\t   loff_t start_byte, loff_t end_byte)\n{\n\tstruct page *page;\n\tXA_STATE(xas, &mapping->i_pages, start_byte >> PAGE_SHIFT);\n\tpgoff_t max = end_byte >> PAGE_SHIFT;\n\n\tif (end_byte < start_byte)\n\t\treturn false;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tpage = xas_find(&xas, max);\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\t\t/* Shadow entries don't count */\n\t\tif (xa_is_value(page))\n\t\t\tcontinue;\n\t\t/*\n\t\t * We don't need to try to pin this page; we're about to\n\t\t * release the RCU lock anyway.  It is enough to know that\n\t\t * there was a page here recently.\n\t\t */\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn page != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 3010
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nssize_t\ngeneric_file_direct_write(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file\t*file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode\t*inode = mapping->host;\n\tloff_t\t\tpos = iocb->ki_pos;\n\tssize_t\t\twritten;\n\tsize_t\t\twrite_len;\n\tpgoff_t\t\tend;\n\n\twrite_len = iov_iter_count(from);\n\tend = (pos + write_len - 1) >> PAGE_SHIFT;\n\n\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\t/* If there are pages to writeback, return */\n\t\tif (filemap_range_has_page(inode->i_mapping, pos,\n\t\t\t\t\t   pos + write_len))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\twritten = filemap_write_and_wait_range(mapping, pos,\n\t\t\t\t\t\t\tpos + write_len - 1);\n\t\tif (written)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * After a write we want buffered reads to be sure to go to disk to get\n\t * the new data.  We invalidate clean cached page from the region we're\n\t * about to write.  We do this *before* the write so that we can return\n\t * without clobbering -EIOCBQUEUED from ->direct_IO().\n\t */\n\twritten = invalidate_inode_pages2_range(mapping,\n\t\t\t\t\tpos >> PAGE_SHIFT, end);\n\t/*\n\t * If a page can not be invalidated, return 0 to fall back\n\t * to buffered write.\n\t */\n\tif (written) {\n\t\tif (written == -EBUSY)\n\t\t\treturn 0;\n\t\tgoto out;\n\t}\n\n\twritten = mapping->a_ops->direct_IO(iocb, from);\n\n\t/*\n\t * Finally, try again to invalidate clean pages which might have been\n\t * cached by non-direct readahead, or faulted in by get_user_pages()\n\t * if the source of the write was an mmap'ed region of the file\n\t * we're writing.  Either one is a pretty crazy thing to do,\n\t * so we don't support it 100%.  If this invalidation\n\t * fails, tough, the write still worked...\n\t *\n\t * Most of the time we do not need this since dio_complete() will do\n\t * the invalidation for us. However there are some file systems that\n\t * do not end up with dio_complete() being called, so let's not break\n\t * them by removing it completely\n\t */\n\tif (mapping->nrpages)\n\t\tinvalidate_inode_pages2_range(mapping,\n\t\t\t\t\tpos >> PAGE_SHIFT, end);\n\n\tif (written > 0) {\n\t\tpos += written;\n\t\twrite_len -= written;\n\t\tif (pos > i_size_read(inode) && !S_ISBLK(inode->i_mode)) {\n\t\t\ti_size_write(inode, pos);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t\tiocb->ki_pos = pos;\n\t}\n\tiov_iter_revert(from, write_len - iov_iter_count(from));\nout:\n\treturn written;\n}"
  },
  {
    "function_name": "pagecache_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "2989-2996",
    "snippet": "int pagecache_write_end(struct file *file, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\t\tstruct page *page, void *fsdata)\n{\n\tconst struct address_space_operations *aops = mapping->a_ops;\n\n\treturn aops->write_end(file, mapping, pos, len, copied, page, fsdata);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aops->write_end",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "copied",
            "page",
            "fsdata"
          ],
          "line": 2995
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint pagecache_write_end(struct file *file, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\t\tstruct page *page, void *fsdata)\n{\n\tconst struct address_space_operations *aops = mapping->a_ops;\n\n\treturn aops->write_end(file, mapping, pos, len, copied, page, fsdata);\n}"
  },
  {
    "function_name": "pagecache_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "2978-2986",
    "snippet": "int pagecache_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\t\tstruct page **pagep, void **fsdata)\n{\n\tconst struct address_space_operations *aops = mapping->a_ops;\n\n\treturn aops->write_begin(file, mapping, pos, len, flags,\n\t\t\t\t\t\t\tpagep, fsdata);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aops->write_begin",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "flags",
            "pagep",
            "fsdata"
          ],
          "line": 2984
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint pagecache_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\t\tstruct page **pagep, void **fsdata)\n{\n\tconst struct address_space_operations *aops = mapping->a_ops;\n\n\treturn aops->write_begin(file, mapping, pos, len, flags,\n\t\t\t\t\t\t\tpagep, fsdata);\n}"
  },
  {
    "function_name": "generic_remap_checks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "2904-2976",
    "snippet": "int generic_remap_checks(struct file *file_in, loff_t pos_in,\n\t\t\t struct file *file_out, loff_t pos_out,\n\t\t\t loff_t *req_count, unsigned int remap_flags)\n{\n\tstruct inode *inode_in = file_in->f_mapping->host;\n\tstruct inode *inode_out = file_out->f_mapping->host;\n\tuint64_t count = *req_count;\n\tuint64_t bcount;\n\tloff_t size_in, size_out;\n\tloff_t bs = inode_out->i_sb->s_blocksize;\n\tint ret;\n\n\t/* The start of both ranges must be aligned to an fs block. */\n\tif (!IS_ALIGNED(pos_in, bs) || !IS_ALIGNED(pos_out, bs))\n\t\treturn -EINVAL;\n\n\t/* Ensure offsets don't wrap. */\n\tif (pos_in + count < pos_in || pos_out + count < pos_out)\n\t\treturn -EINVAL;\n\n\tsize_in = i_size_read(inode_in);\n\tsize_out = i_size_read(inode_out);\n\n\t/* Dedupe requires both ranges to be within EOF. */\n\tif ((remap_flags & REMAP_FILE_DEDUP) &&\n\t    (pos_in >= size_in || pos_in + count > size_in ||\n\t     pos_out >= size_out || pos_out + count > size_out))\n\t\treturn -EINVAL;\n\n\t/* Ensure the infile range is within the infile. */\n\tif (pos_in >= size_in)\n\t\treturn -EINVAL;\n\tcount = min(count, size_in - (uint64_t)pos_in);\n\n\tret = generic_access_check_limits(file_in, pos_in, &count);\n\tif (ret)\n\t\treturn ret;\n\n\tret = generic_write_check_limits(file_out, pos_out, &count);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * If the user wanted us to link to the infile's EOF, round up to the\n\t * next block boundary for this check.\n\t *\n\t * Otherwise, make sure the count is also block-aligned, having\n\t * already confirmed the starting offsets' block alignment.\n\t */\n\tif (pos_in + count == size_in) {\n\t\tbcount = ALIGN(size_in, bs) - pos_in;\n\t} else {\n\t\tif (!IS_ALIGNED(count, bs))\n\t\t\tcount = ALIGN_DOWN(count, bs);\n\t\tbcount = count;\n\t}\n\n\t/* Don't allow overlapped cloning within the same file. */\n\tif (inode_in == inode_out &&\n\t    pos_out + bcount > pos_in &&\n\t    pos_out < pos_in + bcount)\n\t\treturn -EINVAL;\n\n\t/*\n\t * We shortened the request but the caller can't deal with that, so\n\t * bounce the request back to userspace.\n\t */\n\tif (*req_count != count && !(remap_flags & REMAP_FILE_CAN_SHORTEN))\n\t\treturn -EINVAL;\n\n\t*req_count = count;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ALIGN_DOWN",
          "args": [
            "count",
            "bs"
          ],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "count",
            "bs"
          ],
          "line": 2956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "size_in",
            "bs"
          ],
          "line": 2954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_write_check_limits",
          "args": [
            "file_out",
            "pos_out",
            "&count"
          ],
          "line": 2942
        },
        "resolved": true,
        "details": {
          "function_name": "generic_write_check_limits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "2847-2861",
          "snippet": "static int generic_write_check_limits(struct file *file, loff_t pos,\n\t\t\t\t      loff_t *count)\n{\n\tloff_t limit = rlimit(RLIMIT_FSIZE);\n\n\tif (limit != RLIM_INFINITY) {\n\t\tif (pos >= limit) {\n\t\t\tsend_sig(SIGXFSZ, current, 0);\n\t\t\treturn -EFBIG;\n\t\t}\n\t\t*count = min(*count, limit - pos);\n\t}\n\n\treturn generic_access_check_limits(file, pos, count);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic int generic_write_check_limits(struct file *file, loff_t pos,\n\t\t\t\t      loff_t *count)\n{\n\tloff_t limit = rlimit(RLIMIT_FSIZE);\n\n\tif (limit != RLIM_INFINITY) {\n\t\tif (pos >= limit) {\n\t\t\tsend_sig(SIGXFSZ, current, 0);\n\t\t\treturn -EFBIG;\n\t\t}\n\t\t*count = min(*count, limit - pos);\n\t}\n\n\treturn generic_access_check_limits(file, pos, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_access_check_limits",
          "args": [
            "file_in",
            "pos_in",
            "&count"
          ],
          "line": 2938
        },
        "resolved": true,
        "details": {
          "function_name": "generic_access_check_limits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "2832-2845",
          "snippet": "static int generic_access_check_limits(struct file *file, loff_t pos,\n\t\t\t\t       loff_t *count)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tloff_t max_size = inode->i_sb->s_maxbytes;\n\n\tif (!(file->f_flags & O_LARGEFILE))\n\t\tmax_size = MAX_NON_LFS;\n\n\tif (unlikely(pos >= max_size))\n\t\treturn -EFBIG;\n\t*count = min(*count, max_size - pos);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic int generic_access_check_limits(struct file *file, loff_t pos,\n\t\t\t\t       loff_t *count)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tloff_t max_size = inode->i_sb->s_maxbytes;\n\n\tif (!(file->f_flags & O_LARGEFILE))\n\t\tmax_size = MAX_NON_LFS;\n\n\tif (unlikely(pos >= max_size))\n\t\treturn -EFBIG;\n\t*count = min(*count, max_size - pos);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "count",
            "size_in - (uint64_t)pos_in"
          ],
          "line": 2936
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode_out"
          ],
          "line": 2925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode_in"
          ],
          "line": 2924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "pos_out",
            "bs"
          ],
          "line": 2917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "pos_in",
            "bs"
          ],
          "line": 2917
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint generic_remap_checks(struct file *file_in, loff_t pos_in,\n\t\t\t struct file *file_out, loff_t pos_out,\n\t\t\t loff_t *req_count, unsigned int remap_flags)\n{\n\tstruct inode *inode_in = file_in->f_mapping->host;\n\tstruct inode *inode_out = file_out->f_mapping->host;\n\tuint64_t count = *req_count;\n\tuint64_t bcount;\n\tloff_t size_in, size_out;\n\tloff_t bs = inode_out->i_sb->s_blocksize;\n\tint ret;\n\n\t/* The start of both ranges must be aligned to an fs block. */\n\tif (!IS_ALIGNED(pos_in, bs) || !IS_ALIGNED(pos_out, bs))\n\t\treturn -EINVAL;\n\n\t/* Ensure offsets don't wrap. */\n\tif (pos_in + count < pos_in || pos_out + count < pos_out)\n\t\treturn -EINVAL;\n\n\tsize_in = i_size_read(inode_in);\n\tsize_out = i_size_read(inode_out);\n\n\t/* Dedupe requires both ranges to be within EOF. */\n\tif ((remap_flags & REMAP_FILE_DEDUP) &&\n\t    (pos_in >= size_in || pos_in + count > size_in ||\n\t     pos_out >= size_out || pos_out + count > size_out))\n\t\treturn -EINVAL;\n\n\t/* Ensure the infile range is within the infile. */\n\tif (pos_in >= size_in)\n\t\treturn -EINVAL;\n\tcount = min(count, size_in - (uint64_t)pos_in);\n\n\tret = generic_access_check_limits(file_in, pos_in, &count);\n\tif (ret)\n\t\treturn ret;\n\n\tret = generic_write_check_limits(file_out, pos_out, &count);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * If the user wanted us to link to the infile's EOF, round up to the\n\t * next block boundary for this check.\n\t *\n\t * Otherwise, make sure the count is also block-aligned, having\n\t * already confirmed the starting offsets' block alignment.\n\t */\n\tif (pos_in + count == size_in) {\n\t\tbcount = ALIGN(size_in, bs) - pos_in;\n\t} else {\n\t\tif (!IS_ALIGNED(count, bs))\n\t\t\tcount = ALIGN_DOWN(count, bs);\n\t\tbcount = count;\n\t}\n\n\t/* Don't allow overlapped cloning within the same file. */\n\tif (inode_in == inode_out &&\n\t    pos_out + bcount > pos_in &&\n\t    pos_out < pos_in + bcount)\n\t\treturn -EINVAL;\n\n\t/*\n\t * We shortened the request but the caller can't deal with that, so\n\t * bounce the request back to userspace.\n\t */\n\tif (*req_count != count && !(remap_flags & REMAP_FILE_CAN_SHORTEN))\n\t\treturn -EINVAL;\n\n\t*req_count = count;\n\treturn 0;\n}"
  },
  {
    "function_name": "generic_write_checks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "2870-2894",
    "snippet": "inline ssize_t generic_write_checks(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tloff_t count;\n\tint ret;\n\n\tif (!iov_iter_count(from))\n\t\treturn 0;\n\n\t/* FIXME: this is for backwards compatibility with 2.4 */\n\tif (iocb->ki_flags & IOCB_APPEND)\n\t\tiocb->ki_pos = i_size_read(inode);\n\n\tif ((iocb->ki_flags & IOCB_NOWAIT) && !(iocb->ki_flags & IOCB_DIRECT))\n\t\treturn -EINVAL;\n\n\tcount = iov_iter_count(from);\n\tret = generic_write_check_limits(file, iocb->ki_pos, &count);\n\tif (ret)\n\t\treturn ret;\n\n\tiov_iter_truncate(from, count);\n\treturn iov_iter_count(from);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 2893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_truncate",
          "args": [
            "from",
            "count"
          ],
          "line": 2892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_write_check_limits",
          "args": [
            "file",
            "iocb->ki_pos",
            "&count"
          ],
          "line": 2888
        },
        "resolved": true,
        "details": {
          "function_name": "generic_write_check_limits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "2847-2861",
          "snippet": "static int generic_write_check_limits(struct file *file, loff_t pos,\n\t\t\t\t      loff_t *count)\n{\n\tloff_t limit = rlimit(RLIMIT_FSIZE);\n\n\tif (limit != RLIM_INFINITY) {\n\t\tif (pos >= limit) {\n\t\t\tsend_sig(SIGXFSZ, current, 0);\n\t\t\treturn -EFBIG;\n\t\t}\n\t\t*count = min(*count, limit - pos);\n\t}\n\n\treturn generic_access_check_limits(file, pos, count);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic int generic_write_check_limits(struct file *file, loff_t pos,\n\t\t\t\t      loff_t *count)\n{\n\tloff_t limit = rlimit(RLIMIT_FSIZE);\n\n\tif (limit != RLIM_INFINITY) {\n\t\tif (pos >= limit) {\n\t\t\tsend_sig(SIGXFSZ, current, 0);\n\t\t\treturn -EFBIG;\n\t\t}\n\t\t*count = min(*count, limit - pos);\n\t}\n\n\treturn generic_access_check_limits(file, pos, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 2887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 2877
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\ninline ssize_t generic_write_checks(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tloff_t count;\n\tint ret;\n\n\tif (!iov_iter_count(from))\n\t\treturn 0;\n\n\t/* FIXME: this is for backwards compatibility with 2.4 */\n\tif (iocb->ki_flags & IOCB_APPEND)\n\t\tiocb->ki_pos = i_size_read(inode);\n\n\tif ((iocb->ki_flags & IOCB_NOWAIT) && !(iocb->ki_flags & IOCB_DIRECT))\n\t\treturn -EINVAL;\n\n\tcount = iov_iter_count(from);\n\tret = generic_write_check_limits(file, iocb->ki_pos, &count);\n\tif (ret)\n\t\treturn ret;\n\n\tiov_iter_truncate(from, count);\n\treturn iov_iter_count(from);\n}"
  },
  {
    "function_name": "generic_write_check_limits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "2847-2861",
    "snippet": "static int generic_write_check_limits(struct file *file, loff_t pos,\n\t\t\t\t      loff_t *count)\n{\n\tloff_t limit = rlimit(RLIMIT_FSIZE);\n\n\tif (limit != RLIM_INFINITY) {\n\t\tif (pos >= limit) {\n\t\t\tsend_sig(SIGXFSZ, current, 0);\n\t\t\treturn -EFBIG;\n\t\t}\n\t\t*count = min(*count, limit - pos);\n\t}\n\n\treturn generic_access_check_limits(file, pos, count);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_access_check_limits",
          "args": [
            "file",
            "pos",
            "count"
          ],
          "line": 2860
        },
        "resolved": true,
        "details": {
          "function_name": "generic_access_check_limits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "2832-2845",
          "snippet": "static int generic_access_check_limits(struct file *file, loff_t pos,\n\t\t\t\t       loff_t *count)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tloff_t max_size = inode->i_sb->s_maxbytes;\n\n\tif (!(file->f_flags & O_LARGEFILE))\n\t\tmax_size = MAX_NON_LFS;\n\n\tif (unlikely(pos >= max_size))\n\t\treturn -EFBIG;\n\t*count = min(*count, max_size - pos);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic int generic_access_check_limits(struct file *file, loff_t pos,\n\t\t\t\t       loff_t *count)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tloff_t max_size = inode->i_sb->s_maxbytes;\n\n\tif (!(file->f_flags & O_LARGEFILE))\n\t\tmax_size = MAX_NON_LFS;\n\n\tif (unlikely(pos >= max_size))\n\t\treturn -EFBIG;\n\t*count = min(*count, max_size - pos);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "*count",
            "limit - pos"
          ],
          "line": 2857
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_sig",
          "args": [
            "SIGXFSZ",
            "current",
            "0"
          ],
          "line": 2854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_FSIZE"
          ],
          "line": 2850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic int generic_write_check_limits(struct file *file, loff_t pos,\n\t\t\t\t      loff_t *count)\n{\n\tloff_t limit = rlimit(RLIMIT_FSIZE);\n\n\tif (limit != RLIM_INFINITY) {\n\t\tif (pos >= limit) {\n\t\t\tsend_sig(SIGXFSZ, current, 0);\n\t\t\treturn -EFBIG;\n\t\t}\n\t\t*count = min(*count, limit - pos);\n\t}\n\n\treturn generic_access_check_limits(file, pos, count);\n}"
  },
  {
    "function_name": "generic_access_check_limits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "2832-2845",
    "snippet": "static int generic_access_check_limits(struct file *file, loff_t pos,\n\t\t\t\t       loff_t *count)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tloff_t max_size = inode->i_sb->s_maxbytes;\n\n\tif (!(file->f_flags & O_LARGEFILE))\n\t\tmax_size = MAX_NON_LFS;\n\n\tif (unlikely(pos >= max_size))\n\t\treturn -EFBIG;\n\t*count = min(*count, max_size - pos);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "*count",
            "max_size - pos"
          ],
          "line": 2843
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pos >= max_size"
          ],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic int generic_access_check_limits(struct file *file, loff_t pos,\n\t\t\t\t       loff_t *count)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tloff_t max_size = inode->i_sb->s_maxbytes;\n\n\tif (!(file->f_flags & O_LARGEFILE))\n\t\tmax_size = MAX_NON_LFS;\n\n\tif (unlikely(pos >= max_size))\n\t\treturn -EFBIG;\n\t*count = min(*count, max_size - pos);\n\treturn 0;\n}"
  },
  {
    "function_name": "read_cache_page_gfp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "2817-2824",
    "snippet": "struct page *read_cache_page_gfp(struct address_space *mapping,\n\t\t\t\tpgoff_t index,\n\t\t\t\tgfp_t gfp)\n{\n\tfiller_t *filler = (filler_t *)mapping->a_ops->readpage;\n\n\treturn do_read_cache_page(mapping, index, filler, NULL, gfp);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_read_cache_page",
          "args": [
            "mapping",
            "index",
            "filler",
            "NULL",
            "gfp"
          ],
          "line": 2823
        },
        "resolved": true,
        "details": {
          "function_name": "do_read_cache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "2690-2783",
          "snippet": "static struct page *do_read_cache_page(struct address_space *mapping,\n\t\t\t\tpgoff_t index,\n\t\t\t\tint (*filler)(void *, struct page *),\n\t\t\t\tvoid *data,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct page *page;\n\tint err;\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(gfp);\n\t\tif (!page)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\terr = add_to_page_cache_lru(page, mapping, index, gfp);\n\t\tif (unlikely(err)) {\n\t\t\tput_page(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\t/* Presumably ENOMEM for xarray node */\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\nfiller:\n\t\terr = filler(data, page);\n\t\tif (err < 0) {\n\t\t\tput_page(page);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\tpage = wait_on_page_read(page);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\t\tgoto out;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\t/*\n\t * Page is not up to date and may be locked due one of the following\n\t * case a: Page is being filled and the page lock is held\n\t * case b: Read/write error clearing the page uptodate status\n\t * case c: Truncation in progress (page locked)\n\t * case d: Reclaim in progress\n\t *\n\t * Case a, the page will be up to date when the page is unlocked.\n\t *    There is no need to serialise on the page lock here as the page\n\t *    is pinned so the lock gives no additional protection. Even if the\n\t *    the page is truncated, the data is still valid if PageUptodate as\n\t *    it's a race vs truncate race.\n\t * Case b, the page will not be up to date\n\t * Case c, the page may be truncated but in itself, the data may still\n\t *    be valid after IO completes as it's a read vs truncate race. The\n\t *    operation must restart if the page is not uptodate on unlock but\n\t *    otherwise serialising on page lock to stabilise the mapping gives\n\t *    no additional guarantees to the caller as the page lock is\n\t *    released before return.\n\t * Case d, similar to truncation. If reclaim holds the page lock, it\n\t *    will be a race with remove_mapping that determines if the mapping\n\t *    is valid on unlock but otherwise the data is valid and there is\n\t *    no need to serialise with page lock.\n\t *\n\t * As the page lock gives no additional guarantee, we optimistically\n\t * wait on the page to be unlocked and check if it's up to date and\n\t * use the page if it is. Otherwise, the page lock is required to\n\t * distinguish between the different cases. The motivation is that we\n\t * avoid spurious serialisations and wakeups when multiple processes\n\t * wait on the same page for IO to complete.\n\t */\n\twait_on_page_locked(page);\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\t/* Distinguish between all the cases under the safety of the lock */\n\tlock_page(page);\n\n\t/* Case c or d, restart the operation */\n\tif (!page->mapping) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tgoto repeat;\n\t}\n\n\t/* Someone else locked and filled the page in a very small window */\n\tif (PageUptodate(page)) {\n\t\tunlock_page(page);\n\t\tgoto out;\n\t}\n\tgoto filler;\n\nout:\n\tmark_page_accessed(page);\n\treturn page;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic struct page *do_read_cache_page(struct address_space *mapping,\n\t\t\t\tpgoff_t index,\n\t\t\t\tint (*filler)(void *, struct page *),\n\t\t\t\tvoid *data,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct page *page;\n\tint err;\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(gfp);\n\t\tif (!page)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\terr = add_to_page_cache_lru(page, mapping, index, gfp);\n\t\tif (unlikely(err)) {\n\t\t\tput_page(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\t/* Presumably ENOMEM for xarray node */\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\nfiller:\n\t\terr = filler(data, page);\n\t\tif (err < 0) {\n\t\t\tput_page(page);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\tpage = wait_on_page_read(page);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\t\tgoto out;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\t/*\n\t * Page is not up to date and may be locked due one of the following\n\t * case a: Page is being filled and the page lock is held\n\t * case b: Read/write error clearing the page uptodate status\n\t * case c: Truncation in progress (page locked)\n\t * case d: Reclaim in progress\n\t *\n\t * Case a, the page will be up to date when the page is unlocked.\n\t *    There is no need to serialise on the page lock here as the page\n\t *    is pinned so the lock gives no additional protection. Even if the\n\t *    the page is truncated, the data is still valid if PageUptodate as\n\t *    it's a race vs truncate race.\n\t * Case b, the page will not be up to date\n\t * Case c, the page may be truncated but in itself, the data may still\n\t *    be valid after IO completes as it's a read vs truncate race. The\n\t *    operation must restart if the page is not uptodate on unlock but\n\t *    otherwise serialising on page lock to stabilise the mapping gives\n\t *    no additional guarantees to the caller as the page lock is\n\t *    released before return.\n\t * Case d, similar to truncation. If reclaim holds the page lock, it\n\t *    will be a race with remove_mapping that determines if the mapping\n\t *    is valid on unlock but otherwise the data is valid and there is\n\t *    no need to serialise with page lock.\n\t *\n\t * As the page lock gives no additional guarantee, we optimistically\n\t * wait on the page to be unlocked and check if it's up to date and\n\t * use the page if it is. Otherwise, the page lock is required to\n\t * distinguish between the different cases. The motivation is that we\n\t * avoid spurious serialisations and wakeups when multiple processes\n\t * wait on the same page for IO to complete.\n\t */\n\twait_on_page_locked(page);\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\t/* Distinguish between all the cases under the safety of the lock */\n\tlock_page(page);\n\n\t/* Case c or d, restart the operation */\n\tif (!page->mapping) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tgoto repeat;\n\t}\n\n\t/* Someone else locked and filled the page in a very small window */\n\tif (PageUptodate(page)) {\n\t\tunlock_page(page);\n\t\tgoto out;\n\t}\n\tgoto filler;\n\nout:\n\tmark_page_accessed(page);\n\treturn page;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstruct page *read_cache_page_gfp(struct address_space *mapping,\n\t\t\t\tpgoff_t index,\n\t\t\t\tgfp_t gfp)\n{\n\tfiller_t *filler = (filler_t *)mapping->a_ops->readpage;\n\n\treturn do_read_cache_page(mapping, index, filler, NULL, gfp);\n}"
  },
  {
    "function_name": "read_cache_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "2797-2803",
    "snippet": "struct page *read_cache_page(struct address_space *mapping,\n\t\t\t\tpgoff_t index,\n\t\t\t\tint (*filler)(void *, struct page *),\n\t\t\t\tvoid *data)\n{\n\treturn do_read_cache_page(mapping, index, filler, data, mapping_gfp_mask(mapping));\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_read_cache_page",
          "args": [
            "mapping",
            "index",
            "filler",
            "data",
            "mapping_gfp_mask(mapping)"
          ],
          "line": 2802
        },
        "resolved": true,
        "details": {
          "function_name": "do_read_cache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "2690-2783",
          "snippet": "static struct page *do_read_cache_page(struct address_space *mapping,\n\t\t\t\tpgoff_t index,\n\t\t\t\tint (*filler)(void *, struct page *),\n\t\t\t\tvoid *data,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct page *page;\n\tint err;\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(gfp);\n\t\tif (!page)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\terr = add_to_page_cache_lru(page, mapping, index, gfp);\n\t\tif (unlikely(err)) {\n\t\t\tput_page(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\t/* Presumably ENOMEM for xarray node */\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\nfiller:\n\t\terr = filler(data, page);\n\t\tif (err < 0) {\n\t\t\tput_page(page);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\tpage = wait_on_page_read(page);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\t\tgoto out;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\t/*\n\t * Page is not up to date and may be locked due one of the following\n\t * case a: Page is being filled and the page lock is held\n\t * case b: Read/write error clearing the page uptodate status\n\t * case c: Truncation in progress (page locked)\n\t * case d: Reclaim in progress\n\t *\n\t * Case a, the page will be up to date when the page is unlocked.\n\t *    There is no need to serialise on the page lock here as the page\n\t *    is pinned so the lock gives no additional protection. Even if the\n\t *    the page is truncated, the data is still valid if PageUptodate as\n\t *    it's a race vs truncate race.\n\t * Case b, the page will not be up to date\n\t * Case c, the page may be truncated but in itself, the data may still\n\t *    be valid after IO completes as it's a read vs truncate race. The\n\t *    operation must restart if the page is not uptodate on unlock but\n\t *    otherwise serialising on page lock to stabilise the mapping gives\n\t *    no additional guarantees to the caller as the page lock is\n\t *    released before return.\n\t * Case d, similar to truncation. If reclaim holds the page lock, it\n\t *    will be a race with remove_mapping that determines if the mapping\n\t *    is valid on unlock but otherwise the data is valid and there is\n\t *    no need to serialise with page lock.\n\t *\n\t * As the page lock gives no additional guarantee, we optimistically\n\t * wait on the page to be unlocked and check if it's up to date and\n\t * use the page if it is. Otherwise, the page lock is required to\n\t * distinguish between the different cases. The motivation is that we\n\t * avoid spurious serialisations and wakeups when multiple processes\n\t * wait on the same page for IO to complete.\n\t */\n\twait_on_page_locked(page);\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\t/* Distinguish between all the cases under the safety of the lock */\n\tlock_page(page);\n\n\t/* Case c or d, restart the operation */\n\tif (!page->mapping) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tgoto repeat;\n\t}\n\n\t/* Someone else locked and filled the page in a very small window */\n\tif (PageUptodate(page)) {\n\t\tunlock_page(page);\n\t\tgoto out;\n\t}\n\tgoto filler;\n\nout:\n\tmark_page_accessed(page);\n\treturn page;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic struct page *do_read_cache_page(struct address_space *mapping,\n\t\t\t\tpgoff_t index,\n\t\t\t\tint (*filler)(void *, struct page *),\n\t\t\t\tvoid *data,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct page *page;\n\tint err;\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(gfp);\n\t\tif (!page)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\terr = add_to_page_cache_lru(page, mapping, index, gfp);\n\t\tif (unlikely(err)) {\n\t\t\tput_page(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\t/* Presumably ENOMEM for xarray node */\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\nfiller:\n\t\terr = filler(data, page);\n\t\tif (err < 0) {\n\t\t\tput_page(page);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\tpage = wait_on_page_read(page);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\t\tgoto out;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\t/*\n\t * Page is not up to date and may be locked due one of the following\n\t * case a: Page is being filled and the page lock is held\n\t * case b: Read/write error clearing the page uptodate status\n\t * case c: Truncation in progress (page locked)\n\t * case d: Reclaim in progress\n\t *\n\t * Case a, the page will be up to date when the page is unlocked.\n\t *    There is no need to serialise on the page lock here as the page\n\t *    is pinned so the lock gives no additional protection. Even if the\n\t *    the page is truncated, the data is still valid if PageUptodate as\n\t *    it's a race vs truncate race.\n\t * Case b, the page will not be up to date\n\t * Case c, the page may be truncated but in itself, the data may still\n\t *    be valid after IO completes as it's a read vs truncate race. The\n\t *    operation must restart if the page is not uptodate on unlock but\n\t *    otherwise serialising on page lock to stabilise the mapping gives\n\t *    no additional guarantees to the caller as the page lock is\n\t *    released before return.\n\t * Case d, similar to truncation. If reclaim holds the page lock, it\n\t *    will be a race with remove_mapping that determines if the mapping\n\t *    is valid on unlock but otherwise the data is valid and there is\n\t *    no need to serialise with page lock.\n\t *\n\t * As the page lock gives no additional guarantee, we optimistically\n\t * wait on the page to be unlocked and check if it's up to date and\n\t * use the page if it is. Otherwise, the page lock is required to\n\t * distinguish between the different cases. The motivation is that we\n\t * avoid spurious serialisations and wakeups when multiple processes\n\t * wait on the same page for IO to complete.\n\t */\n\twait_on_page_locked(page);\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\t/* Distinguish between all the cases under the safety of the lock */\n\tlock_page(page);\n\n\t/* Case c or d, restart the operation */\n\tif (!page->mapping) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tgoto repeat;\n\t}\n\n\t/* Someone else locked and filled the page in a very small window */\n\tif (PageUptodate(page)) {\n\t\tunlock_page(page);\n\t\tgoto out;\n\t}\n\tgoto filler;\n\nout:\n\tmark_page_accessed(page);\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_gfp_mask",
          "args": [
            "mapping"
          ],
          "line": 2802
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstruct page *read_cache_page(struct address_space *mapping,\n\t\t\t\tpgoff_t index,\n\t\t\t\tint (*filler)(void *, struct page *),\n\t\t\t\tvoid *data)\n{\n\treturn do_read_cache_page(mapping, index, filler, data, mapping_gfp_mask(mapping));\n}"
  },
  {
    "function_name": "do_read_cache_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "2690-2783",
    "snippet": "static struct page *do_read_cache_page(struct address_space *mapping,\n\t\t\t\tpgoff_t index,\n\t\t\t\tint (*filler)(void *, struct page *),\n\t\t\t\tvoid *data,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct page *page;\n\tint err;\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(gfp);\n\t\tif (!page)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\terr = add_to_page_cache_lru(page, mapping, index, gfp);\n\t\tif (unlikely(err)) {\n\t\t\tput_page(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\t/* Presumably ENOMEM for xarray node */\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\nfiller:\n\t\terr = filler(data, page);\n\t\tif (err < 0) {\n\t\t\tput_page(page);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\tpage = wait_on_page_read(page);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\t\tgoto out;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\t/*\n\t * Page is not up to date and may be locked due one of the following\n\t * case a: Page is being filled and the page lock is held\n\t * case b: Read/write error clearing the page uptodate status\n\t * case c: Truncation in progress (page locked)\n\t * case d: Reclaim in progress\n\t *\n\t * Case a, the page will be up to date when the page is unlocked.\n\t *    There is no need to serialise on the page lock here as the page\n\t *    is pinned so the lock gives no additional protection. Even if the\n\t *    the page is truncated, the data is still valid if PageUptodate as\n\t *    it's a race vs truncate race.\n\t * Case b, the page will not be up to date\n\t * Case c, the page may be truncated but in itself, the data may still\n\t *    be valid after IO completes as it's a read vs truncate race. The\n\t *    operation must restart if the page is not uptodate on unlock but\n\t *    otherwise serialising on page lock to stabilise the mapping gives\n\t *    no additional guarantees to the caller as the page lock is\n\t *    released before return.\n\t * Case d, similar to truncation. If reclaim holds the page lock, it\n\t *    will be a race with remove_mapping that determines if the mapping\n\t *    is valid on unlock but otherwise the data is valid and there is\n\t *    no need to serialise with page lock.\n\t *\n\t * As the page lock gives no additional guarantee, we optimistically\n\t * wait on the page to be unlocked and check if it's up to date and\n\t * use the page if it is. Otherwise, the page lock is required to\n\t * distinguish between the different cases. The motivation is that we\n\t * avoid spurious serialisations and wakeups when multiple processes\n\t * wait on the same page for IO to complete.\n\t */\n\twait_on_page_locked(page);\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\t/* Distinguish between all the cases under the safety of the lock */\n\tlock_page(page);\n\n\t/* Case c or d, restart the operation */\n\tif (!page->mapping) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tgoto repeat;\n\t}\n\n\t/* Someone else locked and filled the page in a very small window */\n\tif (PageUptodate(page)) {\n\t\tunlock_page(page);\n\t\tgoto out;\n\t}\n\tgoto filler;\n\nout:\n\tmark_page_accessed(page);\n\treturn page;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_page_accessed",
          "args": [
            "page"
          ],
          "line": 2781
        },
        "resolved": true,
        "details": {
          "function_name": "mark_page_accessed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "376-400",
          "snippet": "void mark_page_accessed(struct page *page)\n{\n\tpage = compound_head(page);\n\tif (!PageActive(page) && !PageUnevictable(page) &&\n\t\t\tPageReferenced(page)) {\n\n\t\t/*\n\t\t * If the page is on the LRU, queue it for activation via\n\t\t * activate_page_pvecs. Otherwise, assume the page is on a\n\t\t * pagevec, mark it active and it'll be moved to the active\n\t\t * LRU on the next drain.\n\t\t */\n\t\tif (PageLRU(page))\n\t\t\tactivate_page(page);\n\t\telse\n\t\t\t__lru_cache_activate_page(page);\n\t\tClearPageReferenced(page);\n\t\tif (page_is_file_cache(page))\n\t\t\tworkingset_activation(page);\n\t} else if (!PageReferenced(page)) {\n\t\tSetPageReferenced(page);\n\t}\n\tif (page_is_idle(page))\n\t\tclear_page_idle(page);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid mark_page_accessed(struct page *page)\n{\n\tpage = compound_head(page);\n\tif (!PageActive(page) && !PageUnevictable(page) &&\n\t\t\tPageReferenced(page)) {\n\n\t\t/*\n\t\t * If the page is on the LRU, queue it for activation via\n\t\t * activate_page_pvecs. Otherwise, assume the page is on a\n\t\t * pagevec, mark it active and it'll be moved to the active\n\t\t * LRU on the next drain.\n\t\t */\n\t\tif (PageLRU(page))\n\t\t\tactivate_page(page);\n\t\telse\n\t\t\t__lru_cache_activate_page(page);\n\t\tClearPageReferenced(page);\n\t\tif (page_is_file_cache(page))\n\t\t\tworkingset_activation(page);\n\t} else if (!PageReferenced(page)) {\n\t\tSetPageReferenced(page);\n\t}\n\tif (page_is_idle(page))\n\t\tclear_page_idle(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2775
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1195-1202",
          "snippet": "void unlock_page(struct page *page)\n{\n\tBUILD_BUG_ON(PG_waiters != 7);\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (clear_bit_unlock_is_negative_byte(PG_locked, &page->flags))\n\t\twake_up_page_bit(page, PG_locked);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid unlock_page(struct page *page)\n{\n\tBUILD_BUG_ON(PG_waiters != 7);\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (clear_bit_unlock_is_negative_byte(PG_locked, &page->flags))\n\t\twake_up_page_bit(page, PG_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 2769
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 2764
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_page_killable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1271-1276",
          "snippet": "int __lock_page_killable(struct page *__page)\n{\n\tstruct page *page = compound_head(__page);\n\twait_queue_head_t *q = page_waitqueue(page);\n\treturn wait_on_page_bit_common(q, page, PG_locked, TASK_KILLABLE, true);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint __lock_page_killable(struct page *__page)\n{\n\tstruct page *page = compound_head(__page);\n\twait_queue_head_t *q = page_waitqueue(page);\n\treturn wait_on_page_bit_common(q, page, PG_locked, TASK_KILLABLE, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_locked",
          "args": [
            "page"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_read",
          "args": [
            "page"
          ],
          "line": 2720
        },
        "resolved": true,
        "details": {
          "function_name": "wait_on_page_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "2678-2688",
          "snippet": "static struct page *wait_on_page_read(struct page *page)\n{\n\tif (!IS_ERR(page)) {\n\t\twait_on_page_locked(page);\n\t\tif (!PageUptodate(page)) {\n\t\t\tput_page(page);\n\t\t\tpage = ERR_PTR(-EIO);\n\t\t}\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic struct page *wait_on_page_read(struct page *page)\n{\n\tif (!IS_ERR(page)) {\n\t\twait_on_page_locked(page);\n\t\tif (!PageUptodate(page)) {\n\t\t\tput_page(page);\n\t\t\tpage = ERR_PTR(-EIO);\n\t\t}\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 2717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filler",
          "args": [
            "data",
            "page"
          ],
          "line": 2714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 2710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_page_cache_lru",
          "args": [
            "page",
            "mapping",
            "index",
            "gfp"
          ],
          "line": 2704
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_page_cache_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "879-905",
          "snippet": "int add_to_page_cache_lru(struct page *page, struct address_space *mapping,\n\t\t\t\tpgoff_t offset, gfp_t gfp_mask)\n{\n\tvoid *shadow = NULL;\n\tint ret;\n\n\t__SetPageLocked(page);\n\tret = __add_to_page_cache_locked(page, mapping, offset,\n\t\t\t\t\t gfp_mask, &shadow);\n\tif (unlikely(ret))\n\t\t__ClearPageLocked(page);\n\telse {\n\t\t/*\n\t\t * The page might have been evicted from cache only\n\t\t * recently, in which case it should be activated like\n\t\t * any other repeatedly accessed page.\n\t\t * The exception is pages getting rewritten; evicting other\n\t\t * data from the working set, only to cache data that will\n\t\t * get overwritten with something else, is a waste of memory.\n\t\t */\n\t\tWARN_ON_ONCE(PageActive(page));\n\t\tif (!(gfp_mask & __GFP_WRITE) && shadow)\n\t\t\tworkingset_refault(page, shadow);\n\t\tlru_cache_add(page);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint add_to_page_cache_lru(struct page *page, struct address_space *mapping,\n\t\t\t\tpgoff_t offset, gfp_t gfp_mask)\n{\n\tvoid *shadow = NULL;\n\tint ret;\n\n\t__SetPageLocked(page);\n\tret = __add_to_page_cache_locked(page, mapping, offset,\n\t\t\t\t\t gfp_mask, &shadow);\n\tif (unlikely(ret))\n\t\t__ClearPageLocked(page);\n\telse {\n\t\t/*\n\t\t * The page might have been evicted from cache only\n\t\t * recently, in which case it should be activated like\n\t\t * any other repeatedly accessed page.\n\t\t * The exception is pages getting rewritten; evicting other\n\t\t * data from the working set, only to cache data that will\n\t\t * get overwritten with something else, is a waste of memory.\n\t\t */\n\t\tWARN_ON_ONCE(PageActive(page));\n\t\tif (!(gfp_mask & __GFP_WRITE) && shadow)\n\t\t\tworkingset_refault(page, shadow);\n\t\tlru_cache_add(page);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 2703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__page_cache_alloc",
          "args": [
            "gfp"
          ],
          "line": 2701
        },
        "resolved": true,
        "details": {
          "function_name": "__page_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "909-925",
          "snippet": "struct page *__page_cache_alloc(gfp_t gfp)\n{\n\tint n;\n\tstruct page *page;\n\n\tif (cpuset_do_page_mem_spread()) {\n\t\tunsigned int cpuset_mems_cookie;\n\t\tdo {\n\t\t\tcpuset_mems_cookie = read_mems_allowed_begin();\n\t\t\tn = cpuset_mem_spread_node();\n\t\t\tpage = __alloc_pages_node(n, gfp, 0);\n\t\t} while (!page && read_mems_allowed_retry(cpuset_mems_cookie));\n\n\t\treturn page;\n\t}\n\treturn alloc_pages(gfp, 0);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstruct page *__page_cache_alloc(gfp_t gfp)\n{\n\tint n;\n\tstruct page *page;\n\n\tif (cpuset_do_page_mem_spread()) {\n\t\tunsigned int cpuset_mems_cookie;\n\t\tdo {\n\t\t\tcpuset_mems_cookie = read_mems_allowed_begin();\n\t\t\tn = cpuset_mem_spread_node();\n\t\t\tpage = __alloc_pages_node(n, gfp, 0);\n\t\t} while (!page && read_mems_allowed_retry(cpuset_mems_cookie));\n\n\t\treturn page;\n\t}\n\treturn alloc_pages(gfp, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "mapping",
            "index"
          ],
          "line": 2699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic struct page *do_read_cache_page(struct address_space *mapping,\n\t\t\t\tpgoff_t index,\n\t\t\t\tint (*filler)(void *, struct page *),\n\t\t\t\tvoid *data,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct page *page;\n\tint err;\nrepeat:\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = __page_cache_alloc(gfp);\n\t\tif (!page)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\terr = add_to_page_cache_lru(page, mapping, index, gfp);\n\t\tif (unlikely(err)) {\n\t\t\tput_page(page);\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t\t/* Presumably ENOMEM for xarray node */\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\nfiller:\n\t\terr = filler(data, page);\n\t\tif (err < 0) {\n\t\t\tput_page(page);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\tpage = wait_on_page_read(page);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\t\tgoto out;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\t/*\n\t * Page is not up to date and may be locked due one of the following\n\t * case a: Page is being filled and the page lock is held\n\t * case b: Read/write error clearing the page uptodate status\n\t * case c: Truncation in progress (page locked)\n\t * case d: Reclaim in progress\n\t *\n\t * Case a, the page will be up to date when the page is unlocked.\n\t *    There is no need to serialise on the page lock here as the page\n\t *    is pinned so the lock gives no additional protection. Even if the\n\t *    the page is truncated, the data is still valid if PageUptodate as\n\t *    it's a race vs truncate race.\n\t * Case b, the page will not be up to date\n\t * Case c, the page may be truncated but in itself, the data may still\n\t *    be valid after IO completes as it's a read vs truncate race. The\n\t *    operation must restart if the page is not uptodate on unlock but\n\t *    otherwise serialising on page lock to stabilise the mapping gives\n\t *    no additional guarantees to the caller as the page lock is\n\t *    released before return.\n\t * Case d, similar to truncation. If reclaim holds the page lock, it\n\t *    will be a race with remove_mapping that determines if the mapping\n\t *    is valid on unlock but otherwise the data is valid and there is\n\t *    no need to serialise with page lock.\n\t *\n\t * As the page lock gives no additional guarantee, we optimistically\n\t * wait on the page to be unlocked and check if it's up to date and\n\t * use the page if it is. Otherwise, the page lock is required to\n\t * distinguish between the different cases. The motivation is that we\n\t * avoid spurious serialisations and wakeups when multiple processes\n\t * wait on the same page for IO to complete.\n\t */\n\twait_on_page_locked(page);\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\t/* Distinguish between all the cases under the safety of the lock */\n\tlock_page(page);\n\n\t/* Case c or d, restart the operation */\n\tif (!page->mapping) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tgoto repeat;\n\t}\n\n\t/* Someone else locked and filled the page in a very small window */\n\tif (PageUptodate(page)) {\n\t\tunlock_page(page);\n\t\tgoto out;\n\t}\n\tgoto filler;\n\nout:\n\tmark_page_accessed(page);\n\treturn page;\n}"
  },
  {
    "function_name": "wait_on_page_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "2678-2688",
    "snippet": "static struct page *wait_on_page_read(struct page *page)\n{\n\tif (!IS_ERR(page)) {\n\t\twait_on_page_locked(page);\n\t\tif (!PageUptodate(page)) {\n\t\t\tput_page(page);\n\t\t\tpage = ERR_PTR(-EIO);\n\t\t}\n\t}\n\treturn page;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 2684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 2683
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_locked",
          "args": [
            "page"
          ],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 2680
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic struct page *wait_on_page_read(struct page *page)\n{\n\tif (!IS_ERR(page)) {\n\t\twait_on_page_locked(page);\n\t\tif (!PageUptodate(page)) {\n\t\t\tput_page(page);\n\t\t\tpage = ERR_PTR(-EIO);\n\t\t}\n\t}\n\treturn page;\n}"
  },
  {
    "function_name": "generic_file_readonly_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "2668-2671",
    "snippet": "int generic_file_readonly_mmap(struct file * file, struct vm_area_struct * vma)\n{\n\treturn -ENOSYS;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint generic_file_readonly_mmap(struct file * file, struct vm_area_struct * vma)\n{\n\treturn -ENOSYS;\n}"
  },
  {
    "function_name": "generic_file_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "2664-2667",
    "snippet": "int generic_file_mmap(struct file * file, struct vm_area_struct * vma)\n{\n\treturn -ENOSYS;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint generic_file_mmap(struct file * file, struct vm_area_struct * vma)\n{\n\treturn -ENOSYS;\n}"
  },
  {
    "function_name": "filemap_page_mkwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "2660-2663",
    "snippet": "vm_fault_t filemap_page_mkwrite(struct vm_fault *vmf)\n{\n\treturn VM_FAULT_SIGBUS;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvm_fault_t filemap_page_mkwrite(struct vm_fault *vmf)\n{\n\treturn VM_FAULT_SIGBUS;\n}"
  },
  {
    "function_name": "generic_file_readonly_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "2653-2658",
    "snippet": "int generic_file_readonly_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tif ((vma->vm_flags & VM_SHARED) && (vma->vm_flags & VM_MAYWRITE))\n\t\treturn -EINVAL;\n\treturn generic_file_mmap(file, vma);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_file_mmap",
          "args": [
            "file",
            "vma"
          ],
          "line": 2657
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_mmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "2664-2667",
          "snippet": "int generic_file_mmap(struct file * file, struct vm_area_struct * vma)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint generic_file_mmap(struct file * file, struct vm_area_struct * vma)\n{\n\treturn -ENOSYS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint generic_file_readonly_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tif ((vma->vm_flags & VM_SHARED) && (vma->vm_flags & VM_MAYWRITE))\n\t\treturn -EINVAL;\n\treturn generic_file_mmap(file, vma);\n}"
  },
  {
    "function_name": "generic_file_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "2639-2648",
    "snippet": "int generic_file_mmap(struct file * file, struct vm_area_struct * vma)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\n\tif (!mapping->a_ops->readpage)\n\t\treturn -ENOEXEC;\n\tfile_accessed(file);\n\tvma->vm_ops = &generic_file_vm_ops;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_accessed",
          "args": [
            "file"
          ],
          "line": 2645
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint generic_file_mmap(struct file * file, struct vm_area_struct * vma)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\n\tif (!mapping->a_ops->readpage)\n\t\treturn -ENOEXEC;\n\tfile_accessed(file);\n\tvma->vm_ops = &generic_file_vm_ops;\n\treturn 0;\n}"
  },
  {
    "function_name": "filemap_page_mkwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "2605-2629",
    "snippet": "vm_fault_t filemap_page_mkwrite(struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vmf->vma->vm_file);\n\tvm_fault_t ret = VM_FAULT_LOCKED;\n\n\tsb_start_pagefault(inode->i_sb);\n\tfile_update_time(vmf->vma->vm_file);\n\tlock_page(page);\n\tif (page->mapping != inode->i_mapping) {\n\t\tunlock_page(page);\n\t\tret = VM_FAULT_NOPAGE;\n\t\tgoto out;\n\t}\n\t/*\n\t * We mark the page dirty already here so that when freeze is in\n\t * progress, we are guaranteed that writeback during freezing will\n\t * see the dirty page and writeprotect it again.\n\t */\n\tset_page_dirty(page);\n\twait_for_stable_page(page);\nout:\n\tsb_end_pagefault(inode->i_sb);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_end_pagefault",
          "args": [
            "inode->i_sb"
          ],
          "line": 2627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_stable_page",
          "args": [
            "page"
          ],
          "line": 2625
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_stable_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2804-2808",
          "snippet": "void wait_for_stable_page(struct page *page)\n{\n\tif (bdi_cap_stable_pages_required(inode_to_bdi(page->mapping->host)))\n\t\twait_on_page_writeback(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid wait_for_stable_page(struct page *page)\n{\n\tif (bdi_cap_stable_pages_required(inode_to_bdi(page->mapping->host)))\n\t\twait_on_page_writeback(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 2624
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_dirty_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2573-2581",
          "snippet": "int set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2615
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1195-1202",
          "snippet": "void unlock_page(struct page *page)\n{\n\tBUILD_BUG_ON(PG_waiters != 7);\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (clear_bit_unlock_is_negative_byte(PG_locked, &page->flags))\n\t\twake_up_page_bit(page, PG_locked);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid unlock_page(struct page *page)\n{\n\tBUILD_BUG_ON(PG_waiters != 7);\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (clear_bit_unlock_is_negative_byte(PG_locked, &page->flags))\n\t\twake_up_page_bit(page, PG_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 2613
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_page_killable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1271-1276",
          "snippet": "int __lock_page_killable(struct page *__page)\n{\n\tstruct page *page = compound_head(__page);\n\twait_queue_head_t *q = page_waitqueue(page);\n\treturn wait_on_page_bit_common(q, page, PG_locked, TASK_KILLABLE, true);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint __lock_page_killable(struct page *__page)\n{\n\tstruct page *page = compound_head(__page);\n\twait_queue_head_t *q = page_waitqueue(page);\n\treturn wait_on_page_bit_common(q, page, PG_locked, TASK_KILLABLE, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_update_time",
          "args": [
            "vmf->vma->vm_file"
          ],
          "line": 2612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_start_pagefault",
          "args": [
            "inode->i_sb"
          ],
          "line": 2611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vmf->vma->vm_file"
          ],
          "line": 2608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvm_fault_t filemap_page_mkwrite(struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vmf->vma->vm_file);\n\tvm_fault_t ret = VM_FAULT_LOCKED;\n\n\tsb_start_pagefault(inode->i_sb);\n\tfile_update_time(vmf->vma->vm_file);\n\tlock_page(page);\n\tif (page->mapping != inode->i_mapping) {\n\t\tunlock_page(page);\n\t\tret = VM_FAULT_NOPAGE;\n\t\tgoto out;\n\t}\n\t/*\n\t * We mark the page dirty already here so that when freeze is in\n\t * progress, we are guaranteed that writeback during freezing will\n\t * see the dirty page and writeprotect it again.\n\t */\n\tset_page_dirty(page);\n\twait_for_stable_page(page);\nout:\n\tsb_end_pagefault(inode->i_sb);\n\treturn ret;\n}"
  },
  {
    "function_name": "filemap_map_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "2538-2602",
    "snippet": "void filemap_map_pages(struct vm_fault *vmf,\n\t\tpgoff_t start_pgoff, pgoff_t end_pgoff)\n{\n\tstruct file *file = vmf->vma->vm_file;\n\tstruct address_space *mapping = file->f_mapping;\n\tpgoff_t last_pgoff = start_pgoff;\n\tunsigned long max_idx;\n\tXA_STATE(xas, &mapping->i_pages, start_pgoff);\n\tstruct page *head, *page;\n\n\trcu_read_lock();\n\txas_for_each(&xas, page, end_pgoff) {\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\t\tif (xa_is_value(page))\n\t\t\tgoto next;\n\n\t\thead = compound_head(page);\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto next;\n\n\t\t/* The page was split under us? */\n\t\tif (compound_head(page) != head)\n\t\t\tgoto skip;\n\n\t\t/* Has the page moved? */\n\t\tif (unlikely(page != xas_reload(&xas)))\n\t\t\tgoto skip;\n\n\t\tif (!PageUptodate(page) ||\n\t\t\t\tPageReadahead(page) ||\n\t\t\t\tPageHWPoison(page))\n\t\t\tgoto skip;\n\t\tif (!trylock_page(page))\n\t\t\tgoto skip;\n\n\t\tif (page->mapping != mapping || !PageUptodate(page))\n\t\t\tgoto unlock;\n\n\t\tmax_idx = DIV_ROUND_UP(i_size_read(mapping->host), PAGE_SIZE);\n\t\tif (page->index >= max_idx)\n\t\t\tgoto unlock;\n\n\t\tif (file->f_ra.mmap_miss > 0)\n\t\t\tfile->f_ra.mmap_miss--;\n\n\t\tvmf->address += (xas.xa_index - last_pgoff) << PAGE_SHIFT;\n\t\tif (vmf->pte)\n\t\t\tvmf->pte += xas.xa_index - last_pgoff;\n\t\tlast_pgoff = xas.xa_index;\n\t\tif (alloc_set_pte(vmf, NULL, page))\n\t\t\tgoto unlock;\n\t\tunlock_page(page);\n\t\tgoto next;\nunlock:\n\t\tunlock_page(page);\nskip:\n\t\tput_page(page);\nnext:\n\t\t/* Huge page is mapped? No need to proceed. */\n\t\tif (pmd_trans_huge(*vmf->pmd))\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "*vmf->pmd"
          ],
          "line": 2598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 2595
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2593
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1195-1202",
          "snippet": "void unlock_page(struct page *page)\n{\n\tBUILD_BUG_ON(PG_waiters != 7);\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (clear_bit_unlock_is_negative_byte(PG_locked, &page->flags))\n\t\twake_up_page_bit(page, PG_locked);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid unlock_page(struct page *page)\n{\n\tBUILD_BUG_ON(PG_waiters != 7);\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (clear_bit_unlock_is_negative_byte(PG_locked, &page->flags))\n\t\twake_up_page_bit(page, PG_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_set_pte",
          "args": [
            "vmf",
            "NULL",
            "page"
          ],
          "line": 2588
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_set_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3182-3230",
          "snippet": "vm_fault_t alloc_set_pte(struct vm_fault *vmf, struct mem_cgroup *memcg,\n\t\tstruct page *page)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\tpte_t entry;\n\tvm_fault_t ret;\n\n\tif (pmd_none(*vmf->pmd) && PageTransCompound(page) &&\n\t\t\tIS_ENABLED(CONFIG_TRANSPARENT_HUGE_PAGECACHE)) {\n\t\t/* THP on COW? */\n\t\tVM_BUG_ON_PAGE(memcg, page);\n\n\t\tret = do_set_pmd(vmf, page);\n\t\tif (ret != VM_FAULT_FALLBACK)\n\t\t\treturn ret;\n\t}\n\n\tif (!vmf->pte) {\n\t\tret = pte_alloc_one_map(vmf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Re-check under ptl */\n\tif (unlikely(!pte_none(*vmf->pte)))\n\t\treturn VM_FAULT_NOPAGE;\n\n\tflush_icache_page(vma, page);\n\tentry = mk_pte(page, vma->vm_page_prot);\n\tif (write)\n\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t/* copy-on-write page */\n\tif (write && !(vma->vm_flags & VM_SHARED)) {\n\t\tinc_mm_counter_fast(vma->vm_mm, MM_ANONPAGES);\n\t\tpage_add_new_anon_rmap(page, vma, vmf->address, false);\n\t\tmem_cgroup_commit_charge(page, memcg, false, false);\n\t\tlru_cache_add_active_or_unevictable(page, vma);\n\t} else {\n\t\tinc_mm_counter_fast(vma->vm_mm, mm_counter_file(page));\n\t\tpage_add_file_rmap(page, false);\n\t}\n\tset_pte_at(vma->vm_mm, vmf->address, vmf->pte, entry);\n\n\t/* no need to invalidate: a not-present page won't be cached */\n\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvm_fault_t alloc_set_pte(struct vm_fault *vmf, struct mem_cgroup *memcg,\n\t\tstruct page *page)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\tpte_t entry;\n\tvm_fault_t ret;\n\n\tif (pmd_none(*vmf->pmd) && PageTransCompound(page) &&\n\t\t\tIS_ENABLED(CONFIG_TRANSPARENT_HUGE_PAGECACHE)) {\n\t\t/* THP on COW? */\n\t\tVM_BUG_ON_PAGE(memcg, page);\n\n\t\tret = do_set_pmd(vmf, page);\n\t\tif (ret != VM_FAULT_FALLBACK)\n\t\t\treturn ret;\n\t}\n\n\tif (!vmf->pte) {\n\t\tret = pte_alloc_one_map(vmf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Re-check under ptl */\n\tif (unlikely(!pte_none(*vmf->pte)))\n\t\treturn VM_FAULT_NOPAGE;\n\n\tflush_icache_page(vma, page);\n\tentry = mk_pte(page, vma->vm_page_prot);\n\tif (write)\n\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t/* copy-on-write page */\n\tif (write && !(vma->vm_flags & VM_SHARED)) {\n\t\tinc_mm_counter_fast(vma->vm_mm, MM_ANONPAGES);\n\t\tpage_add_new_anon_rmap(page, vma, vmf->address, false);\n\t\tmem_cgroup_commit_charge(page, memcg, false, false);\n\t\tlru_cache_add_active_or_unevictable(page, vma);\n\t} else {\n\t\tinc_mm_counter_fast(vma->vm_mm, mm_counter_file(page));\n\t\tpage_add_file_rmap(page, false);\n\t}\n\tset_pte_at(vma->vm_mm, vmf->address, vmf->pte, entry);\n\n\t/* no need to invalidate: a not-present page won't be cached */\n\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "i_size_read(mapping->host)",
            "PAGE_SIZE"
          ],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "mapping->host"
          ],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHWPoison",
          "args": [
            "page"
          ],
          "line": 2569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageReadahead",
          "args": [
            "page"
          ],
          "line": 2568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page != xas_reload(&xas)"
          ],
          "line": 2564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_reload",
          "args": [
            "&xas"
          ],
          "line": 2564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 2560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_get_speculative",
          "args": [
            "head"
          ],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "page"
          ],
          "line": 2552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_retry",
          "args": [
            "&xas",
            "page"
          ],
          "line": 2550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_for_each",
          "args": [
            "&xas",
            "page",
            "end_pgoff"
          ],
          "line": 2549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "start_pgoff"
          ],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid filemap_map_pages(struct vm_fault *vmf,\n\t\tpgoff_t start_pgoff, pgoff_t end_pgoff)\n{\n\tstruct file *file = vmf->vma->vm_file;\n\tstruct address_space *mapping = file->f_mapping;\n\tpgoff_t last_pgoff = start_pgoff;\n\tunsigned long max_idx;\n\tXA_STATE(xas, &mapping->i_pages, start_pgoff);\n\tstruct page *head, *page;\n\n\trcu_read_lock();\n\txas_for_each(&xas, page, end_pgoff) {\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\t\tif (xa_is_value(page))\n\t\t\tgoto next;\n\n\t\thead = compound_head(page);\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto next;\n\n\t\t/* The page was split under us? */\n\t\tif (compound_head(page) != head)\n\t\t\tgoto skip;\n\n\t\t/* Has the page moved? */\n\t\tif (unlikely(page != xas_reload(&xas)))\n\t\t\tgoto skip;\n\n\t\tif (!PageUptodate(page) ||\n\t\t\t\tPageReadahead(page) ||\n\t\t\t\tPageHWPoison(page))\n\t\t\tgoto skip;\n\t\tif (!trylock_page(page))\n\t\t\tgoto skip;\n\n\t\tif (page->mapping != mapping || !PageUptodate(page))\n\t\t\tgoto unlock;\n\n\t\tmax_idx = DIV_ROUND_UP(i_size_read(mapping->host), PAGE_SIZE);\n\t\tif (page->index >= max_idx)\n\t\t\tgoto unlock;\n\n\t\tif (file->f_ra.mmap_miss > 0)\n\t\t\tfile->f_ra.mmap_miss--;\n\n\t\tvmf->address += (xas.xa_index - last_pgoff) << PAGE_SHIFT;\n\t\tif (vmf->pte)\n\t\t\tvmf->pte += xas.xa_index - last_pgoff;\n\t\tlast_pgoff = xas.xa_index;\n\t\tif (alloc_set_pte(vmf, NULL, page))\n\t\t\tgoto unlock;\n\t\tunlock_page(page);\n\t\tgoto next;\nunlock:\n\t\tunlock_page(page);\nskip:\n\t\tput_page(page);\nnext:\n\t\t/* Huge page is mapped? No need to proceed. */\n\t\tif (pmd_trans_huge(*vmf->pmd))\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "filemap_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "2419-2535",
    "snippet": "vm_fault_t filemap_fault(struct vm_fault *vmf)\n{\n\tint error;\n\tstruct file *file = vmf->vma->vm_file;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct file_ra_state *ra = &file->f_ra;\n\tstruct inode *inode = mapping->host;\n\tpgoff_t offset = vmf->pgoff;\n\tpgoff_t max_off;\n\tstruct page *page;\n\tvm_fault_t ret = 0;\n\n\tmax_off = DIV_ROUND_UP(i_size_read(inode), PAGE_SIZE);\n\tif (unlikely(offset >= max_off))\n\t\treturn VM_FAULT_SIGBUS;\n\n\t/*\n\t * Do we have something in the page cache already?\n\t */\n\tpage = find_get_page(mapping, offset);\n\tif (likely(page) && !(vmf->flags & FAULT_FLAG_TRIED)) {\n\t\t/*\n\t\t * We found the page, so try async readahead before\n\t\t * waiting for the lock.\n\t\t */\n\t\tdo_async_mmap_readahead(vmf->vma, ra, file, page, offset);\n\t} else if (!page) {\n\t\t/* No page in the page cache at all */\n\t\tdo_sync_mmap_readahead(vmf->vma, ra, file, offset);\n\t\tcount_vm_event(PGMAJFAULT);\n\t\tcount_memcg_event_mm(vmf->vma->vm_mm, PGMAJFAULT);\n\t\tret = VM_FAULT_MAJOR;\nretry_find:\n\t\tpage = find_get_page(mapping, offset);\n\t\tif (!page)\n\t\t\tgoto no_cached_page;\n\t}\n\n\tif (!lock_page_or_retry(page, vmf->vma->vm_mm, vmf->flags)) {\n\t\tput_page(page);\n\t\treturn ret | VM_FAULT_RETRY;\n\t}\n\n\t/* Did it get truncated? */\n\tif (unlikely(page->mapping != mapping)) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tgoto retry_find;\n\t}\n\tVM_BUG_ON_PAGE(page->index != offset, page);\n\n\t/*\n\t * We have a locked page in the page cache, now we need to check\n\t * that it's up-to-date. If not, it is going to be due to an error.\n\t */\n\tif (unlikely(!PageUptodate(page)))\n\t\tgoto page_not_uptodate;\n\n\t/*\n\t * Found the page and have a reference on it.\n\t * We must recheck i_size under page lock.\n\t */\n\tmax_off = DIV_ROUND_UP(i_size_read(inode), PAGE_SIZE);\n\tif (unlikely(offset >= max_off)) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\treturn VM_FAULT_SIGBUS;\n\t}\n\n\tvmf->page = page;\n\treturn ret | VM_FAULT_LOCKED;\n\nno_cached_page:\n\t/*\n\t * We're only likely to ever get here if MADV_RANDOM is in\n\t * effect.\n\t */\n\terror = page_cache_read(file, offset, vmf->gfp_mask);\n\n\t/*\n\t * The page we want has now been added to the page cache.\n\t * In the unlikely event that someone removed it in the\n\t * meantime, we'll just come back here and read it again.\n\t */\n\tif (error >= 0)\n\t\tgoto retry_find;\n\n\t/*\n\t * An error return from page_cache_read can result if the\n\t * system is low on memory, or a problem occurs while trying\n\t * to schedule I/O.\n\t */\n\treturn vmf_error(error);\n\npage_not_uptodate:\n\t/*\n\t * Umm, take care of errors if the page isn't up-to-date.\n\t * Try to re-read it _once_. We do this synchronously,\n\t * because there really aren't any performance issues here\n\t * and we need to check for errors.\n\t */\n\tClearPageError(page);\n\terror = mapping->a_ops->readpage(file, page);\n\tif (!error) {\n\t\twait_on_page_locked(page);\n\t\tif (!PageUptodate(page))\n\t\t\terror = -EIO;\n\t}\n\tput_page(page);\n\n\tif (!error || error == AOP_TRUNCATED_PAGE)\n\t\tgoto retry_find;\n\n\t/* Things didn't work out. Return zero to tell the mm layer so. */\n\tshrink_readahead_size_eio(file, ra);\n\treturn VM_FAULT_SIGBUS;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "shrink_readahead_size_eio",
          "args": [
            "file",
            "ra"
          ],
          "line": 2533
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_readahead_size_eio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1959-1963",
          "snippet": "static void shrink_readahead_size_eio(struct file *filp,\n\t\t\t\t\tstruct file_ra_state *ra)\n{\n\tra->ra_pages /= 4;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic void shrink_readahead_size_eio(struct file *filp,\n\t\t\t\t\tstruct file_ra_state *ra)\n{\n\tra->ra_pages /= 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 2527
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_locked",
          "args": [
            "page"
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->readpage",
          "args": [
            "file",
            "page"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageError",
          "args": [
            "page"
          ],
          "line": 2520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmf_error",
          "args": [
            "error"
          ],
          "line": 2511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_read",
          "args": [
            "file",
            "offset",
            "vmf->gfp_mask"
          ],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "page_cache_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "2305-2327",
          "snippet": "static int page_cache_read(struct file *file, pgoff_t offset, gfp_t gfp_mask)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct page *page;\n\tint ret;\n\n\tdo {\n\t\tpage = __page_cache_alloc(gfp_mask);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tret = add_to_page_cache_lru(page, mapping, offset, gfp_mask);\n\t\tif (ret == 0)\n\t\t\tret = mapping->a_ops->readpage(file, page);\n\t\telse if (ret == -EEXIST)\n\t\t\tret = 0; /* losing race to add is OK */\n\n\t\tput_page(page);\n\n\t} while (ret == AOP_TRUNCATED_PAGE);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic int page_cache_read(struct file *file, pgoff_t offset, gfp_t gfp_mask)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct page *page;\n\tint ret;\n\n\tdo {\n\t\tpage = __page_cache_alloc(gfp_mask);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tret = add_to_page_cache_lru(page, mapping, offset, gfp_mask);\n\t\tif (ret == 0)\n\t\t\tret = mapping->a_ops->readpage(file, page);\n\t\telse if (ret == -EEXIST)\n\t\t\tret = 0; /* losing race to add is OK */\n\n\t\tput_page(page);\n\n\t} while (ret == AOP_TRUNCATED_PAGE);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2483
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1195-1202",
          "snippet": "void unlock_page(struct page *page)\n{\n\tBUILD_BUG_ON(PG_waiters != 7);\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (clear_bit_unlock_is_negative_byte(PG_locked, &page->flags))\n\t\twake_up_page_bit(page, PG_locked);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid unlock_page(struct page *page)\n{\n\tBUILD_BUG_ON(PG_waiters != 7);\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (clear_bit_unlock_is_negative_byte(PG_locked, &page->flags))\n\t\twake_up_page_bit(page, PG_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "offset >= max_off"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "i_size_read(inode)",
            "PAGE_SIZE"
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "page->index != offset",
            "page"
          ],
          "line": 2468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->mapping != mapping"
          ],
          "line": 2463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_page_or_retry",
          "args": [
            "page",
            "vmf->vma->vm_mm",
            "vmf->flags"
          ],
          "line": 2457
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_page_or_retry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1290-1320",
          "snippet": "int __lock_page_or_retry(struct page *page, struct mm_struct *mm,\n\t\t\t unsigned int flags)\n{\n\tif (flags & FAULT_FLAG_ALLOW_RETRY) {\n\t\t/*\n\t\t * CAUTION! In this case, mmap_sem is not released\n\t\t * even though return 0.\n\t\t */\n\t\tif (flags & FAULT_FLAG_RETRY_NOWAIT)\n\t\t\treturn 0;\n\n\t\tup_read(&mm->mmap_sem);\n\t\tif (flags & FAULT_FLAG_KILLABLE)\n\t\t\twait_on_page_locked_killable(page);\n\t\telse\n\t\t\twait_on_page_locked(page);\n\t\treturn 0;\n\t} else {\n\t\tif (flags & FAULT_FLAG_KILLABLE) {\n\t\t\tint ret;\n\n\t\t\tret = __lock_page_killable(page);\n\t\t\tif (ret) {\n\t\t\t\tup_read(&mm->mmap_sem);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else\n\t\t\t__lock_page(page);\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint __lock_page_or_retry(struct page *page, struct mm_struct *mm,\n\t\t\t unsigned int flags)\n{\n\tif (flags & FAULT_FLAG_ALLOW_RETRY) {\n\t\t/*\n\t\t * CAUTION! In this case, mmap_sem is not released\n\t\t * even though return 0.\n\t\t */\n\t\tif (flags & FAULT_FLAG_RETRY_NOWAIT)\n\t\t\treturn 0;\n\n\t\tup_read(&mm->mmap_sem);\n\t\tif (flags & FAULT_FLAG_KILLABLE)\n\t\t\twait_on_page_locked_killable(page);\n\t\telse\n\t\t\twait_on_page_locked(page);\n\t\treturn 0;\n\t} else {\n\t\tif (flags & FAULT_FLAG_KILLABLE) {\n\t\t\tint ret;\n\n\t\t\tret = __lock_page_killable(page);\n\t\t\tif (ret) {\n\t\t\t\tup_read(&mm->mmap_sem);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else\n\t\t\t__lock_page(page);\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "mapping",
            "offset"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_memcg_event_mm",
          "args": [
            "vmf->vma->vm_mm",
            "PGMAJFAULT"
          ],
          "line": 2449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "PGMAJFAULT"
          ],
          "line": 2448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_sync_mmap_readahead",
          "args": [
            "vmf->vma",
            "ra",
            "file",
            "offset"
          ],
          "line": 2447
        },
        "resolved": true,
        "details": {
          "function_name": "do_sync_mmap_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "2335-2372",
          "snippet": "static void do_sync_mmap_readahead(struct vm_area_struct *vma,\n\t\t\t\t   struct file_ra_state *ra,\n\t\t\t\t   struct file *file,\n\t\t\t\t   pgoff_t offset)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\n\t/* If we don't want any read-ahead, don't bother */\n\tif (vma->vm_flags & VM_RAND_READ)\n\t\treturn;\n\tif (!ra->ra_pages)\n\t\treturn;\n\n\tif (vma->vm_flags & VM_SEQ_READ) {\n\t\tpage_cache_sync_readahead(mapping, ra, file, offset,\n\t\t\t\t\t  ra->ra_pages);\n\t\treturn;\n\t}\n\n\t/* Avoid banging the cache line if not needed */\n\tif (ra->mmap_miss < MMAP_LOTSAMISS * 10)\n\t\tra->mmap_miss++;\n\n\t/*\n\t * Do we miss much more than hit in this file? If so,\n\t * stop bothering with read-ahead. It will only hurt.\n\t */\n\tif (ra->mmap_miss > MMAP_LOTSAMISS)\n\t\treturn;\n\n\t/*\n\t * mmap read-around\n\t */\n\tra->start = max_t(long, 0, offset - ra->ra_pages / 2);\n\tra->size = ra->ra_pages;\n\tra->async_size = ra->ra_pages / 4;\n\tra_submit(ra, mapping, file);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define MMAP_LOTSAMISS  (100)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\n#define MMAP_LOTSAMISS  (100)\n\nstatic void do_sync_mmap_readahead(struct vm_area_struct *vma,\n\t\t\t\t   struct file_ra_state *ra,\n\t\t\t\t   struct file *file,\n\t\t\t\t   pgoff_t offset)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\n\t/* If we don't want any read-ahead, don't bother */\n\tif (vma->vm_flags & VM_RAND_READ)\n\t\treturn;\n\tif (!ra->ra_pages)\n\t\treturn;\n\n\tif (vma->vm_flags & VM_SEQ_READ) {\n\t\tpage_cache_sync_readahead(mapping, ra, file, offset,\n\t\t\t\t\t  ra->ra_pages);\n\t\treturn;\n\t}\n\n\t/* Avoid banging the cache line if not needed */\n\tif (ra->mmap_miss < MMAP_LOTSAMISS * 10)\n\t\tra->mmap_miss++;\n\n\t/*\n\t * Do we miss much more than hit in this file? If so,\n\t * stop bothering with read-ahead. It will only hurt.\n\t */\n\tif (ra->mmap_miss > MMAP_LOTSAMISS)\n\t\treturn;\n\n\t/*\n\t * mmap read-around\n\t */\n\tra->start = max_t(long, 0, offset - ra->ra_pages / 2);\n\tra->size = ra->ra_pages;\n\tra->async_size = ra->ra_pages / 4;\n\tra_submit(ra, mapping, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_async_mmap_readahead",
          "args": [
            "vmf->vma",
            "ra",
            "file",
            "page",
            "offset"
          ],
          "line": 2444
        },
        "resolved": true,
        "details": {
          "function_name": "do_async_mmap_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "2378-2394",
          "snippet": "static void do_async_mmap_readahead(struct vm_area_struct *vma,\n\t\t\t\t    struct file_ra_state *ra,\n\t\t\t\t    struct file *file,\n\t\t\t\t    struct page *page,\n\t\t\t\t    pgoff_t offset)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\n\t/* If we don't want any read-ahead, don't bother */\n\tif (vma->vm_flags & VM_RAND_READ)\n\t\treturn;\n\tif (ra->mmap_miss > 0)\n\t\tra->mmap_miss--;\n\tif (PageReadahead(page))\n\t\tpage_cache_async_readahead(mapping, ra, file,\n\t\t\t\t\t   page, offset, ra->ra_pages);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic void do_async_mmap_readahead(struct vm_area_struct *vma,\n\t\t\t\t    struct file_ra_state *ra,\n\t\t\t\t    struct file *file,\n\t\t\t\t    struct page *page,\n\t\t\t\t    pgoff_t offset)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\n\t/* If we don't want any read-ahead, don't bother */\n\tif (vma->vm_flags & VM_RAND_READ)\n\t\treturn;\n\tif (ra->mmap_miss > 0)\n\t\tra->mmap_miss--;\n\tif (PageReadahead(page))\n\t\tpage_cache_async_readahead(mapping, ra, file,\n\t\t\t\t\t   page, offset, ra->ra_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "page"
          ],
          "line": 2439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "mapping",
            "offset"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "offset >= max_off"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "i_size_read(inode)",
            "PAGE_SIZE"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvm_fault_t filemap_fault(struct vm_fault *vmf)\n{\n\tint error;\n\tstruct file *file = vmf->vma->vm_file;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct file_ra_state *ra = &file->f_ra;\n\tstruct inode *inode = mapping->host;\n\tpgoff_t offset = vmf->pgoff;\n\tpgoff_t max_off;\n\tstruct page *page;\n\tvm_fault_t ret = 0;\n\n\tmax_off = DIV_ROUND_UP(i_size_read(inode), PAGE_SIZE);\n\tif (unlikely(offset >= max_off))\n\t\treturn VM_FAULT_SIGBUS;\n\n\t/*\n\t * Do we have something in the page cache already?\n\t */\n\tpage = find_get_page(mapping, offset);\n\tif (likely(page) && !(vmf->flags & FAULT_FLAG_TRIED)) {\n\t\t/*\n\t\t * We found the page, so try async readahead before\n\t\t * waiting for the lock.\n\t\t */\n\t\tdo_async_mmap_readahead(vmf->vma, ra, file, page, offset);\n\t} else if (!page) {\n\t\t/* No page in the page cache at all */\n\t\tdo_sync_mmap_readahead(vmf->vma, ra, file, offset);\n\t\tcount_vm_event(PGMAJFAULT);\n\t\tcount_memcg_event_mm(vmf->vma->vm_mm, PGMAJFAULT);\n\t\tret = VM_FAULT_MAJOR;\nretry_find:\n\t\tpage = find_get_page(mapping, offset);\n\t\tif (!page)\n\t\t\tgoto no_cached_page;\n\t}\n\n\tif (!lock_page_or_retry(page, vmf->vma->vm_mm, vmf->flags)) {\n\t\tput_page(page);\n\t\treturn ret | VM_FAULT_RETRY;\n\t}\n\n\t/* Did it get truncated? */\n\tif (unlikely(page->mapping != mapping)) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tgoto retry_find;\n\t}\n\tVM_BUG_ON_PAGE(page->index != offset, page);\n\n\t/*\n\t * We have a locked page in the page cache, now we need to check\n\t * that it's up-to-date. If not, it is going to be due to an error.\n\t */\n\tif (unlikely(!PageUptodate(page)))\n\t\tgoto page_not_uptodate;\n\n\t/*\n\t * Found the page and have a reference on it.\n\t * We must recheck i_size under page lock.\n\t */\n\tmax_off = DIV_ROUND_UP(i_size_read(inode), PAGE_SIZE);\n\tif (unlikely(offset >= max_off)) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\treturn VM_FAULT_SIGBUS;\n\t}\n\n\tvmf->page = page;\n\treturn ret | VM_FAULT_LOCKED;\n\nno_cached_page:\n\t/*\n\t * We're only likely to ever get here if MADV_RANDOM is in\n\t * effect.\n\t */\n\terror = page_cache_read(file, offset, vmf->gfp_mask);\n\n\t/*\n\t * The page we want has now been added to the page cache.\n\t * In the unlikely event that someone removed it in the\n\t * meantime, we'll just come back here and read it again.\n\t */\n\tif (error >= 0)\n\t\tgoto retry_find;\n\n\t/*\n\t * An error return from page_cache_read can result if the\n\t * system is low on memory, or a problem occurs while trying\n\t * to schedule I/O.\n\t */\n\treturn vmf_error(error);\n\npage_not_uptodate:\n\t/*\n\t * Umm, take care of errors if the page isn't up-to-date.\n\t * Try to re-read it _once_. We do this synchronously,\n\t * because there really aren't any performance issues here\n\t * and we need to check for errors.\n\t */\n\tClearPageError(page);\n\terror = mapping->a_ops->readpage(file, page);\n\tif (!error) {\n\t\twait_on_page_locked(page);\n\t\tif (!PageUptodate(page))\n\t\t\terror = -EIO;\n\t}\n\tput_page(page);\n\n\tif (!error || error == AOP_TRUNCATED_PAGE)\n\t\tgoto retry_find;\n\n\t/* Things didn't work out. Return zero to tell the mm layer so. */\n\tshrink_readahead_size_eio(file, ra);\n\treturn VM_FAULT_SIGBUS;\n}"
  },
  {
    "function_name": "do_async_mmap_readahead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "2378-2394",
    "snippet": "static void do_async_mmap_readahead(struct vm_area_struct *vma,\n\t\t\t\t    struct file_ra_state *ra,\n\t\t\t\t    struct file *file,\n\t\t\t\t    struct page *page,\n\t\t\t\t    pgoff_t offset)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\n\t/* If we don't want any read-ahead, don't bother */\n\tif (vma->vm_flags & VM_RAND_READ)\n\t\treturn;\n\tif (ra->mmap_miss > 0)\n\t\tra->mmap_miss--;\n\tif (PageReadahead(page))\n\t\tpage_cache_async_readahead(mapping, ra, file,\n\t\t\t\t\t   page, offset, ra->ra_pages);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_async_readahead",
          "args": [
            "mapping",
            "ra",
            "file",
            "page",
            "offset",
            "ra->ra_pages"
          ],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "page_cache_async_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
          "lines": "545-574",
          "snippet": "void\npage_cache_async_readahead(struct address_space *mapping,\n\t\t\t   struct file_ra_state *ra, struct file *filp,\n\t\t\t   struct page *page, pgoff_t offset,\n\t\t\t   unsigned long req_size)\n{\n\t/* no read-ahead */\n\tif (!ra->ra_pages)\n\t\treturn;\n\n\t/*\n\t * Same bit is used for PG_readahead and PG_reclaim.\n\t */\n\tif (PageWriteback(page))\n\t\treturn;\n\n\tClearPageReadahead(page);\n\n\t/*\n\t * Defer asynchronous read-ahead on IO congestion.\n\t */\n\tif (inode_read_congested(mapping->host))\n\t\treturn;\n\n\tif (blk_cgroup_congested())\n\t\treturn;\n\n\t/* do read-ahead */\n\tondemand_readahead(mapping, ra, filp, true, offset, req_size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fadvise.h>",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/export.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nvoid\npage_cache_async_readahead(struct address_space *mapping,\n\t\t\t   struct file_ra_state *ra, struct file *filp,\n\t\t\t   struct page *page, pgoff_t offset,\n\t\t\t   unsigned long req_size)\n{\n\t/* no read-ahead */\n\tif (!ra->ra_pages)\n\t\treturn;\n\n\t/*\n\t * Same bit is used for PG_readahead and PG_reclaim.\n\t */\n\tif (PageWriteback(page))\n\t\treturn;\n\n\tClearPageReadahead(page);\n\n\t/*\n\t * Defer asynchronous read-ahead on IO congestion.\n\t */\n\tif (inode_read_congested(mapping->host))\n\t\treturn;\n\n\tif (blk_cgroup_congested())\n\t\treturn;\n\n\t/* do read-ahead */\n\tondemand_readahead(mapping, ra, filp, true, offset, req_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageReadahead",
          "args": [
            "page"
          ],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic void do_async_mmap_readahead(struct vm_area_struct *vma,\n\t\t\t\t    struct file_ra_state *ra,\n\t\t\t\t    struct file *file,\n\t\t\t\t    struct page *page,\n\t\t\t\t    pgoff_t offset)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\n\t/* If we don't want any read-ahead, don't bother */\n\tif (vma->vm_flags & VM_RAND_READ)\n\t\treturn;\n\tif (ra->mmap_miss > 0)\n\t\tra->mmap_miss--;\n\tif (PageReadahead(page))\n\t\tpage_cache_async_readahead(mapping, ra, file,\n\t\t\t\t\t   page, offset, ra->ra_pages);\n}"
  },
  {
    "function_name": "do_sync_mmap_readahead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "2335-2372",
    "snippet": "static void do_sync_mmap_readahead(struct vm_area_struct *vma,\n\t\t\t\t   struct file_ra_state *ra,\n\t\t\t\t   struct file *file,\n\t\t\t\t   pgoff_t offset)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\n\t/* If we don't want any read-ahead, don't bother */\n\tif (vma->vm_flags & VM_RAND_READ)\n\t\treturn;\n\tif (!ra->ra_pages)\n\t\treturn;\n\n\tif (vma->vm_flags & VM_SEQ_READ) {\n\t\tpage_cache_sync_readahead(mapping, ra, file, offset,\n\t\t\t\t\t  ra->ra_pages);\n\t\treturn;\n\t}\n\n\t/* Avoid banging the cache line if not needed */\n\tif (ra->mmap_miss < MMAP_LOTSAMISS * 10)\n\t\tra->mmap_miss++;\n\n\t/*\n\t * Do we miss much more than hit in this file? If so,\n\t * stop bothering with read-ahead. It will only hurt.\n\t */\n\tif (ra->mmap_miss > MMAP_LOTSAMISS)\n\t\treturn;\n\n\t/*\n\t * mmap read-around\n\t */\n\tra->start = max_t(long, 0, offset - ra->ra_pages / 2);\n\tra->size = ra->ra_pages;\n\tra->async_size = ra->ra_pages / 4;\n\tra_submit(ra, mapping, file);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define MMAP_LOTSAMISS  (100)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ra_submit",
          "args": [
            "ra",
            "mapping",
            "file"
          ],
          "line": 2371
        },
        "resolved": true,
        "details": {
          "function_name": "ra_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "63-68",
          "snippet": "static inline unsigned long ra_submit(struct file_ra_state *ra,\n\t\tstruct address_space *mapping, struct file *filp)\n{\n\treturn __do_page_cache_readahead(mapping, filp,\n\t\t\t\t\tra->start, ra->size, ra->async_size);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline unsigned long ra_submit(struct file_ra_state *ra,\n\t\tstruct address_space *mapping, struct file *filp)\n{\n\treturn __do_page_cache_readahead(mapping, filp,\n\t\t\t\t\tra->start, ra->size, ra->async_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "long",
            "0",
            "offset - ra->ra_pages / 2"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_sync_readahead",
          "args": [
            "mapping",
            "ra",
            "file",
            "offset",
            "ra->ra_pages"
          ],
          "line": 2349
        },
        "resolved": true,
        "details": {
          "function_name": "page_cache_sync_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
          "lines": "508-527",
          "snippet": "void page_cache_sync_readahead(struct address_space *mapping,\n\t\t\t       struct file_ra_state *ra, struct file *filp,\n\t\t\t       pgoff_t offset, unsigned long req_size)\n{\n\t/* no read-ahead */\n\tif (!ra->ra_pages)\n\t\treturn;\n\n\tif (blk_cgroup_congested())\n\t\treturn;\n\n\t/* be dumb */\n\tif (filp && (filp->f_mode & FMODE_RANDOM)) {\n\t\tforce_page_cache_readahead(mapping, filp, offset, req_size);\n\t\treturn;\n\t}\n\n\t/* do read-ahead */\n\tondemand_readahead(mapping, ra, filp, false, offset, req_size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fadvise.h>",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/export.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nvoid page_cache_sync_readahead(struct address_space *mapping,\n\t\t\t       struct file_ra_state *ra, struct file *filp,\n\t\t\t       pgoff_t offset, unsigned long req_size)\n{\n\t/* no read-ahead */\n\tif (!ra->ra_pages)\n\t\treturn;\n\n\tif (blk_cgroup_congested())\n\t\treturn;\n\n\t/* be dumb */\n\tif (filp && (filp->f_mode & FMODE_RANDOM)) {\n\t\tforce_page_cache_readahead(mapping, filp, offset, req_size);\n\t\treturn;\n\t}\n\n\t/* do read-ahead */\n\tondemand_readahead(mapping, ra, filp, false, offset, req_size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\n#define MMAP_LOTSAMISS  (100)\n\nstatic void do_sync_mmap_readahead(struct vm_area_struct *vma,\n\t\t\t\t   struct file_ra_state *ra,\n\t\t\t\t   struct file *file,\n\t\t\t\t   pgoff_t offset)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\n\t/* If we don't want any read-ahead, don't bother */\n\tif (vma->vm_flags & VM_RAND_READ)\n\t\treturn;\n\tif (!ra->ra_pages)\n\t\treturn;\n\n\tif (vma->vm_flags & VM_SEQ_READ) {\n\t\tpage_cache_sync_readahead(mapping, ra, file, offset,\n\t\t\t\t\t  ra->ra_pages);\n\t\treturn;\n\t}\n\n\t/* Avoid banging the cache line if not needed */\n\tif (ra->mmap_miss < MMAP_LOTSAMISS * 10)\n\t\tra->mmap_miss++;\n\n\t/*\n\t * Do we miss much more than hit in this file? If so,\n\t * stop bothering with read-ahead. It will only hurt.\n\t */\n\tif (ra->mmap_miss > MMAP_LOTSAMISS)\n\t\treturn;\n\n\t/*\n\t * mmap read-around\n\t */\n\tra->start = max_t(long, 0, offset - ra->ra_pages / 2);\n\tra->size = ra->ra_pages;\n\tra->async_size = ra->ra_pages / 4;\n\tra_submit(ra, mapping, file);\n}"
  },
  {
    "function_name": "page_cache_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "2305-2327",
    "snippet": "static int page_cache_read(struct file *file, pgoff_t offset, gfp_t gfp_mask)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct page *page;\n\tint ret;\n\n\tdo {\n\t\tpage = __page_cache_alloc(gfp_mask);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tret = add_to_page_cache_lru(page, mapping, offset, gfp_mask);\n\t\tif (ret == 0)\n\t\t\tret = mapping->a_ops->readpage(file, page);\n\t\telse if (ret == -EEXIST)\n\t\t\tret = 0; /* losing race to add is OK */\n\n\t\tput_page(page);\n\n\t} while (ret == AOP_TRUNCATED_PAGE);\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 2322
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->readpage",
          "args": [
            "file",
            "page"
          ],
          "line": 2318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_page_cache_lru",
          "args": [
            "page",
            "mapping",
            "offset",
            "gfp_mask"
          ],
          "line": 2316
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_page_cache_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "879-905",
          "snippet": "int add_to_page_cache_lru(struct page *page, struct address_space *mapping,\n\t\t\t\tpgoff_t offset, gfp_t gfp_mask)\n{\n\tvoid *shadow = NULL;\n\tint ret;\n\n\t__SetPageLocked(page);\n\tret = __add_to_page_cache_locked(page, mapping, offset,\n\t\t\t\t\t gfp_mask, &shadow);\n\tif (unlikely(ret))\n\t\t__ClearPageLocked(page);\n\telse {\n\t\t/*\n\t\t * The page might have been evicted from cache only\n\t\t * recently, in which case it should be activated like\n\t\t * any other repeatedly accessed page.\n\t\t * The exception is pages getting rewritten; evicting other\n\t\t * data from the working set, only to cache data that will\n\t\t * get overwritten with something else, is a waste of memory.\n\t\t */\n\t\tWARN_ON_ONCE(PageActive(page));\n\t\tif (!(gfp_mask & __GFP_WRITE) && shadow)\n\t\t\tworkingset_refault(page, shadow);\n\t\tlru_cache_add(page);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint add_to_page_cache_lru(struct page *page, struct address_space *mapping,\n\t\t\t\tpgoff_t offset, gfp_t gfp_mask)\n{\n\tvoid *shadow = NULL;\n\tint ret;\n\n\t__SetPageLocked(page);\n\tret = __add_to_page_cache_locked(page, mapping, offset,\n\t\t\t\t\t gfp_mask, &shadow);\n\tif (unlikely(ret))\n\t\t__ClearPageLocked(page);\n\telse {\n\t\t/*\n\t\t * The page might have been evicted from cache only\n\t\t * recently, in which case it should be activated like\n\t\t * any other repeatedly accessed page.\n\t\t * The exception is pages getting rewritten; evicting other\n\t\t * data from the working set, only to cache data that will\n\t\t * get overwritten with something else, is a waste of memory.\n\t\t */\n\t\tWARN_ON_ONCE(PageActive(page));\n\t\tif (!(gfp_mask & __GFP_WRITE) && shadow)\n\t\t\tworkingset_refault(page, shadow);\n\t\tlru_cache_add(page);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__page_cache_alloc",
          "args": [
            "gfp_mask"
          ],
          "line": 2312
        },
        "resolved": true,
        "details": {
          "function_name": "__page_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "909-925",
          "snippet": "struct page *__page_cache_alloc(gfp_t gfp)\n{\n\tint n;\n\tstruct page *page;\n\n\tif (cpuset_do_page_mem_spread()) {\n\t\tunsigned int cpuset_mems_cookie;\n\t\tdo {\n\t\t\tcpuset_mems_cookie = read_mems_allowed_begin();\n\t\t\tn = cpuset_mem_spread_node();\n\t\t\tpage = __alloc_pages_node(n, gfp, 0);\n\t\t} while (!page && read_mems_allowed_retry(cpuset_mems_cookie));\n\n\t\treturn page;\n\t}\n\treturn alloc_pages(gfp, 0);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstruct page *__page_cache_alloc(gfp_t gfp)\n{\n\tint n;\n\tstruct page *page;\n\n\tif (cpuset_do_page_mem_spread()) {\n\t\tunsigned int cpuset_mems_cookie;\n\t\tdo {\n\t\t\tcpuset_mems_cookie = read_mems_allowed_begin();\n\t\t\tn = cpuset_mem_spread_node();\n\t\t\tpage = __alloc_pages_node(n, gfp, 0);\n\t\t} while (!page && read_mems_allowed_retry(cpuset_mems_cookie));\n\n\t\treturn page;\n\t}\n\treturn alloc_pages(gfp, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic int page_cache_read(struct file *file, pgoff_t offset, gfp_t gfp_mask)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct page *page;\n\tint ret;\n\n\tdo {\n\t\tpage = __page_cache_alloc(gfp_mask);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tret = add_to_page_cache_lru(page, mapping, offset, gfp_mask);\n\t\tif (ret == 0)\n\t\t\tret = mapping->a_ops->readpage(file, page);\n\t\telse if (ret == -EEXIST)\n\t\t\tret = 0; /* losing race to add is OK */\n\n\t\tput_page(page);\n\n\t} while (ret == AOP_TRUNCATED_PAGE);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "generic_file_read_iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "2238-2292",
    "snippet": "ssize_t\ngeneric_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tsize_t count = iov_iter_count(iter);\n\tssize_t retval = 0;\n\n\tif (!count)\n\t\tgoto out; /* skip atime */\n\n\tif (iocb->ki_flags & IOCB_DIRECT) {\n\t\tstruct file *file = iocb->ki_filp;\n\t\tstruct address_space *mapping = file->f_mapping;\n\t\tstruct inode *inode = mapping->host;\n\t\tloff_t size;\n\n\t\tsize = i_size_read(inode);\n\t\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\t\tif (filemap_range_has_page(mapping, iocb->ki_pos,\n\t\t\t\t\t\t   iocb->ki_pos + count - 1))\n\t\t\t\treturn -EAGAIN;\n\t\t} else {\n\t\t\tretval = filemap_write_and_wait_range(mapping,\n\t\t\t\t\t\tiocb->ki_pos,\n\t\t\t\t\t        iocb->ki_pos + count - 1);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tfile_accessed(file);\n\n\t\tretval = mapping->a_ops->direct_IO(iocb, iter);\n\t\tif (retval >= 0) {\n\t\t\tiocb->ki_pos += retval;\n\t\t\tcount -= retval;\n\t\t}\n\t\tiov_iter_revert(iter, count - iov_iter_count(iter));\n\n\t\t/*\n\t\t * Btrfs can have a short DIO read if we encounter\n\t\t * compressed extents, so if there was an error, or if\n\t\t * we've already read everything we wanted to, or if\n\t\t * there was a short read because we hit EOF, go ahead\n\t\t * and return.  Otherwise fallthrough to buffered io for\n\t\t * the rest of the read.  Buffered reads will not work for\n\t\t * DAX files, so don't bother trying.\n\t\t */\n\t\tif (retval < 0 || !count || iocb->ki_pos >= size ||\n\t\t    IS_DAX(inode))\n\t\t\tgoto out;\n\t}\n\n\tretval = generic_file_buffered_read(iocb, iter, retval);\nout:\n\treturn retval;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_file_buffered_read",
          "args": [
            "iocb",
            "iter",
            "retval"
          ],
          "line": 2289
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_buffered_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1977-2228",
          "snippet": "static ssize_t generic_file_buffered_read(struct kiocb *iocb,\n\t\tstruct iov_iter *iter, ssize_t written)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct address_space *mapping = filp->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct file_ra_state *ra = &filp->f_ra;\n\tloff_t *ppos = &iocb->ki_pos;\n\tpgoff_t index;\n\tpgoff_t last_index;\n\tpgoff_t prev_index;\n\tunsigned long offset;      /* offset into pagecache page */\n\tunsigned int prev_offset;\n\tint error = 0;\n\n\tif (unlikely(*ppos >= inode->i_sb->s_maxbytes))\n\t\treturn 0;\n\tiov_iter_truncate(iter, inode->i_sb->s_maxbytes);\n\n\tindex = *ppos >> PAGE_SHIFT;\n\tprev_index = ra->prev_pos >> PAGE_SHIFT;\n\tprev_offset = ra->prev_pos & (PAGE_SIZE-1);\n\tlast_index = (*ppos + iter->count + PAGE_SIZE-1) >> PAGE_SHIFT;\n\toffset = *ppos & ~PAGE_MASK;\n\n\tfor (;;) {\n\t\tstruct page *page;\n\t\tpgoff_t end_index;\n\t\tloff_t isize;\n\t\tunsigned long nr, ret;\n\n\t\tcond_resched();\nfind_page:\n\t\tif (fatal_signal_pending(current)) {\n\t\t\terror = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpage = find_get_page(mapping, index);\n\t\tif (!page) {\n\t\t\tif (iocb->ki_flags & IOCB_NOWAIT)\n\t\t\t\tgoto would_block;\n\t\t\tpage_cache_sync_readahead(mapping,\n\t\t\t\t\tra, filp,\n\t\t\t\t\tindex, last_index - index);\n\t\t\tpage = find_get_page(mapping, index);\n\t\t\tif (unlikely(page == NULL))\n\t\t\t\tgoto no_cached_page;\n\t\t}\n\t\tif (PageReadahead(page)) {\n\t\t\tpage_cache_async_readahead(mapping,\n\t\t\t\t\tra, filp, page,\n\t\t\t\t\tindex, last_index - index);\n\t\t}\n\t\tif (!PageUptodate(page)) {\n\t\t\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\t\t\tput_page(page);\n\t\t\t\tgoto would_block;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * See comment in do_read_cache_page on why\n\t\t\t * wait_on_page_locked is used to avoid unnecessarily\n\t\t\t * serialisations and why it's safe.\n\t\t\t */\n\t\t\terror = wait_on_page_locked_killable(page);\n\t\t\tif (unlikely(error))\n\t\t\t\tgoto readpage_error;\n\t\t\tif (PageUptodate(page))\n\t\t\t\tgoto page_ok;\n\n\t\t\tif (inode->i_blkbits == PAGE_SHIFT ||\n\t\t\t\t\t!mapping->a_ops->is_partially_uptodate)\n\t\t\t\tgoto page_not_up_to_date;\n\t\t\t/* pipes can't handle partially uptodate pages */\n\t\t\tif (unlikely(iov_iter_is_pipe(iter)))\n\t\t\t\tgoto page_not_up_to_date;\n\t\t\tif (!trylock_page(page))\n\t\t\t\tgoto page_not_up_to_date;\n\t\t\t/* Did it get truncated before we got the lock? */\n\t\t\tif (!page->mapping)\n\t\t\t\tgoto page_not_up_to_date_locked;\n\t\t\tif (!mapping->a_ops->is_partially_uptodate(page,\n\t\t\t\t\t\t\toffset, iter->count))\n\t\t\t\tgoto page_not_up_to_date_locked;\n\t\t\tunlock_page(page);\n\t\t}\npage_ok:\n\t\t/*\n\t\t * i_size must be checked after we know the page is Uptodate.\n\t\t *\n\t\t * Checking i_size after the check allows us to calculate\n\t\t * the correct value for \"nr\", which means the zero-filled\n\t\t * part of the page is not copied back to userspace (unless\n\t\t * another truncate extends the file - this is desired though).\n\t\t */\n\n\t\tisize = i_size_read(inode);\n\t\tend_index = (isize - 1) >> PAGE_SHIFT;\n\t\tif (unlikely(!isize || index > end_index)) {\n\t\t\tput_page(page);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* nr is the maximum number of bytes to copy from this page */\n\t\tnr = PAGE_SIZE;\n\t\tif (index == end_index) {\n\t\t\tnr = ((isize - 1) & ~PAGE_MASK) + 1;\n\t\t\tif (nr <= offset) {\n\t\t\t\tput_page(page);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tnr = nr - offset;\n\n\t\t/* If users can be writing to this page using arbitrary\n\t\t * virtual addresses, take care about potential aliasing\n\t\t * before reading the page on the kernel side.\n\t\t */\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\n\t\t/*\n\t\t * When a sequential read accesses a page several times,\n\t\t * only mark it as accessed the first time.\n\t\t */\n\t\tif (prev_index != index || offset != prev_offset)\n\t\t\tmark_page_accessed(page);\n\t\tprev_index = index;\n\n\t\t/*\n\t\t * Ok, we have the page, and it's up-to-date, so\n\t\t * now we can copy it to user space...\n\t\t */\n\n\t\tret = copy_page_to_iter(page, offset, nr, iter);\n\t\toffset += ret;\n\t\tindex += offset >> PAGE_SHIFT;\n\t\toffset &= ~PAGE_MASK;\n\t\tprev_offset = offset;\n\n\t\tput_page(page);\n\t\twritten += ret;\n\t\tif (!iov_iter_count(iter))\n\t\t\tgoto out;\n\t\tif (ret < nr) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tcontinue;\n\npage_not_up_to_date:\n\t\t/* Get exclusive access to the page ... */\n\t\terror = lock_page_killable(page);\n\t\tif (unlikely(error))\n\t\t\tgoto readpage_error;\n\npage_not_up_to_date_locked:\n\t\t/* Did it get truncated before we got the lock? */\n\t\tif (!page->mapping) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Did somebody else fill it already? */\n\t\tif (PageUptodate(page)) {\n\t\t\tunlock_page(page);\n\t\t\tgoto page_ok;\n\t\t}\n\nreadpage:\n\t\t/*\n\t\t * A previous I/O error may have been due to temporary\n\t\t * failures, eg. multipath errors.\n\t\t * PG_error will be set again if readpage fails.\n\t\t */\n\t\tClearPageError(page);\n\t\t/* Start the actual read. The read will unlock the page. */\n\t\terror = mapping->a_ops->readpage(filp, page);\n\n\t\tif (unlikely(error)) {\n\t\t\tif (error == AOP_TRUNCATED_PAGE) {\n\t\t\t\tput_page(page);\n\t\t\t\terror = 0;\n\t\t\t\tgoto find_page;\n\t\t\t}\n\t\t\tgoto readpage_error;\n\t\t}\n\n\t\tif (!PageUptodate(page)) {\n\t\t\terror = lock_page_killable(page);\n\t\t\tif (unlikely(error))\n\t\t\t\tgoto readpage_error;\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tif (page->mapping == NULL) {\n\t\t\t\t\t/*\n\t\t\t\t\t * invalidate_mapping_pages got it\n\t\t\t\t\t */\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tput_page(page);\n\t\t\t\t\tgoto find_page;\n\t\t\t\t}\n\t\t\t\tunlock_page(page);\n\t\t\t\tshrink_readahead_size_eio(filp, ra);\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto readpage_error;\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\tgoto page_ok;\n\nreadpage_error:\n\t\t/* UHHUH! A synchronous read error occurred. Report it */\n\t\tput_page(page);\n\t\tgoto out;\n\nno_cached_page:\n\t\t/*\n\t\t * Ok, it wasn't cached, so we need to create a new\n\t\t * page..\n\t\t */\n\t\tpage = page_cache_alloc(mapping);\n\t\tif (!page) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terror = add_to_page_cache_lru(page, mapping, index,\n\t\t\t\tmapping_gfp_constraint(mapping, GFP_KERNEL));\n\t\tif (error) {\n\t\t\tput_page(page);\n\t\t\tif (error == -EEXIST) {\n\t\t\t\terror = 0;\n\t\t\t\tgoto find_page;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\tgoto readpage;\n\t}\n\nwould_block:\n\terror = -EAGAIN;\nout:\n\tra->prev_pos = prev_index;\n\tra->prev_pos <<= PAGE_SHIFT;\n\tra->prev_pos |= prev_offset;\n\n\t*ppos = ((loff_t)index << PAGE_SHIFT) + offset;\n\tfile_accessed(filp);\n\treturn written ? written : error;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic ssize_t generic_file_buffered_read(struct kiocb *iocb,\n\t\tstruct iov_iter *iter, ssize_t written)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct address_space *mapping = filp->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct file_ra_state *ra = &filp->f_ra;\n\tloff_t *ppos = &iocb->ki_pos;\n\tpgoff_t index;\n\tpgoff_t last_index;\n\tpgoff_t prev_index;\n\tunsigned long offset;      /* offset into pagecache page */\n\tunsigned int prev_offset;\n\tint error = 0;\n\n\tif (unlikely(*ppos >= inode->i_sb->s_maxbytes))\n\t\treturn 0;\n\tiov_iter_truncate(iter, inode->i_sb->s_maxbytes);\n\n\tindex = *ppos >> PAGE_SHIFT;\n\tprev_index = ra->prev_pos >> PAGE_SHIFT;\n\tprev_offset = ra->prev_pos & (PAGE_SIZE-1);\n\tlast_index = (*ppos + iter->count + PAGE_SIZE-1) >> PAGE_SHIFT;\n\toffset = *ppos & ~PAGE_MASK;\n\n\tfor (;;) {\n\t\tstruct page *page;\n\t\tpgoff_t end_index;\n\t\tloff_t isize;\n\t\tunsigned long nr, ret;\n\n\t\tcond_resched();\nfind_page:\n\t\tif (fatal_signal_pending(current)) {\n\t\t\terror = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpage = find_get_page(mapping, index);\n\t\tif (!page) {\n\t\t\tif (iocb->ki_flags & IOCB_NOWAIT)\n\t\t\t\tgoto would_block;\n\t\t\tpage_cache_sync_readahead(mapping,\n\t\t\t\t\tra, filp,\n\t\t\t\t\tindex, last_index - index);\n\t\t\tpage = find_get_page(mapping, index);\n\t\t\tif (unlikely(page == NULL))\n\t\t\t\tgoto no_cached_page;\n\t\t}\n\t\tif (PageReadahead(page)) {\n\t\t\tpage_cache_async_readahead(mapping,\n\t\t\t\t\tra, filp, page,\n\t\t\t\t\tindex, last_index - index);\n\t\t}\n\t\tif (!PageUptodate(page)) {\n\t\t\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\t\t\tput_page(page);\n\t\t\t\tgoto would_block;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * See comment in do_read_cache_page on why\n\t\t\t * wait_on_page_locked is used to avoid unnecessarily\n\t\t\t * serialisations and why it's safe.\n\t\t\t */\n\t\t\terror = wait_on_page_locked_killable(page);\n\t\t\tif (unlikely(error))\n\t\t\t\tgoto readpage_error;\n\t\t\tif (PageUptodate(page))\n\t\t\t\tgoto page_ok;\n\n\t\t\tif (inode->i_blkbits == PAGE_SHIFT ||\n\t\t\t\t\t!mapping->a_ops->is_partially_uptodate)\n\t\t\t\tgoto page_not_up_to_date;\n\t\t\t/* pipes can't handle partially uptodate pages */\n\t\t\tif (unlikely(iov_iter_is_pipe(iter)))\n\t\t\t\tgoto page_not_up_to_date;\n\t\t\tif (!trylock_page(page))\n\t\t\t\tgoto page_not_up_to_date;\n\t\t\t/* Did it get truncated before we got the lock? */\n\t\t\tif (!page->mapping)\n\t\t\t\tgoto page_not_up_to_date_locked;\n\t\t\tif (!mapping->a_ops->is_partially_uptodate(page,\n\t\t\t\t\t\t\toffset, iter->count))\n\t\t\t\tgoto page_not_up_to_date_locked;\n\t\t\tunlock_page(page);\n\t\t}\npage_ok:\n\t\t/*\n\t\t * i_size must be checked after we know the page is Uptodate.\n\t\t *\n\t\t * Checking i_size after the check allows us to calculate\n\t\t * the correct value for \"nr\", which means the zero-filled\n\t\t * part of the page is not copied back to userspace (unless\n\t\t * another truncate extends the file - this is desired though).\n\t\t */\n\n\t\tisize = i_size_read(inode);\n\t\tend_index = (isize - 1) >> PAGE_SHIFT;\n\t\tif (unlikely(!isize || index > end_index)) {\n\t\t\tput_page(page);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* nr is the maximum number of bytes to copy from this page */\n\t\tnr = PAGE_SIZE;\n\t\tif (index == end_index) {\n\t\t\tnr = ((isize - 1) & ~PAGE_MASK) + 1;\n\t\t\tif (nr <= offset) {\n\t\t\t\tput_page(page);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tnr = nr - offset;\n\n\t\t/* If users can be writing to this page using arbitrary\n\t\t * virtual addresses, take care about potential aliasing\n\t\t * before reading the page on the kernel side.\n\t\t */\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\n\t\t/*\n\t\t * When a sequential read accesses a page several times,\n\t\t * only mark it as accessed the first time.\n\t\t */\n\t\tif (prev_index != index || offset != prev_offset)\n\t\t\tmark_page_accessed(page);\n\t\tprev_index = index;\n\n\t\t/*\n\t\t * Ok, we have the page, and it's up-to-date, so\n\t\t * now we can copy it to user space...\n\t\t */\n\n\t\tret = copy_page_to_iter(page, offset, nr, iter);\n\t\toffset += ret;\n\t\tindex += offset >> PAGE_SHIFT;\n\t\toffset &= ~PAGE_MASK;\n\t\tprev_offset = offset;\n\n\t\tput_page(page);\n\t\twritten += ret;\n\t\tif (!iov_iter_count(iter))\n\t\t\tgoto out;\n\t\tif (ret < nr) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tcontinue;\n\npage_not_up_to_date:\n\t\t/* Get exclusive access to the page ... */\n\t\terror = lock_page_killable(page);\n\t\tif (unlikely(error))\n\t\t\tgoto readpage_error;\n\npage_not_up_to_date_locked:\n\t\t/* Did it get truncated before we got the lock? */\n\t\tif (!page->mapping) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Did somebody else fill it already? */\n\t\tif (PageUptodate(page)) {\n\t\t\tunlock_page(page);\n\t\t\tgoto page_ok;\n\t\t}\n\nreadpage:\n\t\t/*\n\t\t * A previous I/O error may have been due to temporary\n\t\t * failures, eg. multipath errors.\n\t\t * PG_error will be set again if readpage fails.\n\t\t */\n\t\tClearPageError(page);\n\t\t/* Start the actual read. The read will unlock the page. */\n\t\terror = mapping->a_ops->readpage(filp, page);\n\n\t\tif (unlikely(error)) {\n\t\t\tif (error == AOP_TRUNCATED_PAGE) {\n\t\t\t\tput_page(page);\n\t\t\t\terror = 0;\n\t\t\t\tgoto find_page;\n\t\t\t}\n\t\t\tgoto readpage_error;\n\t\t}\n\n\t\tif (!PageUptodate(page)) {\n\t\t\terror = lock_page_killable(page);\n\t\t\tif (unlikely(error))\n\t\t\t\tgoto readpage_error;\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tif (page->mapping == NULL) {\n\t\t\t\t\t/*\n\t\t\t\t\t * invalidate_mapping_pages got it\n\t\t\t\t\t */\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tput_page(page);\n\t\t\t\t\tgoto find_page;\n\t\t\t\t}\n\t\t\t\tunlock_page(page);\n\t\t\t\tshrink_readahead_size_eio(filp, ra);\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto readpage_error;\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\tgoto page_ok;\n\nreadpage_error:\n\t\t/* UHHUH! A synchronous read error occurred. Report it */\n\t\tput_page(page);\n\t\tgoto out;\n\nno_cached_page:\n\t\t/*\n\t\t * Ok, it wasn't cached, so we need to create a new\n\t\t * page..\n\t\t */\n\t\tpage = page_cache_alloc(mapping);\n\t\tif (!page) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terror = add_to_page_cache_lru(page, mapping, index,\n\t\t\t\tmapping_gfp_constraint(mapping, GFP_KERNEL));\n\t\tif (error) {\n\t\t\tput_page(page);\n\t\t\tif (error == -EEXIST) {\n\t\t\t\terror = 0;\n\t\t\t\tgoto find_page;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\tgoto readpage;\n\t}\n\nwould_block:\n\terror = -EAGAIN;\nout:\n\tra->prev_pos = prev_index;\n\tra->prev_pos <<= PAGE_SHIFT;\n\tra->prev_pos |= prev_offset;\n\n\t*ppos = ((loff_t)index << PAGE_SHIFT) + offset;\n\tfile_accessed(filp);\n\treturn written ? written : error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DAX",
          "args": [
            "inode"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_revert",
          "args": [
            "iter",
            "count - iov_iter_count(iter)"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->direct_IO",
          "args": [
            "iocb",
            "iter"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_accessed",
          "args": [
            "file"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "mapping",
            "iocb->ki_pos",
            "iocb->ki_pos + count - 1"
          ],
          "line": 2259
        },
        "resolved": true,
        "details": {
          "function_name": "filemap_write_and_wait_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "627-649",
          "snippet": "int filemap_write_and_wait_range(struct address_space *mapping,\n\t\t\t\t loff_t lstart, loff_t lend)\n{\n\tint err = 0;\n\n\tif (mapping_needs_writeback(mapping)) {\n\t\terr = __filemap_fdatawrite_range(mapping, lstart, lend,\n\t\t\t\t\t\t WB_SYNC_ALL);\n\t\t/* See comment of filemap_write_and_wait() */\n\t\tif (err != -EIO) {\n\t\t\tint err2 = filemap_fdatawait_range(mapping,\n\t\t\t\t\t\tlstart, lend);\n\t\t\tif (!err)\n\t\t\t\terr = err2;\n\t\t} else {\n\t\t\t/* Clear any previously stored errors */\n\t\t\tfilemap_check_errors(mapping);\n\t\t}\n\t} else {\n\t\terr = filemap_check_errors(mapping);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint filemap_write_and_wait_range(struct address_space *mapping,\n\t\t\t\t loff_t lstart, loff_t lend)\n{\n\tint err = 0;\n\n\tif (mapping_needs_writeback(mapping)) {\n\t\terr = __filemap_fdatawrite_range(mapping, lstart, lend,\n\t\t\t\t\t\t WB_SYNC_ALL);\n\t\t/* See comment of filemap_write_and_wait() */\n\t\tif (err != -EIO) {\n\t\t\tint err2 = filemap_fdatawait_range(mapping,\n\t\t\t\t\t\tlstart, lend);\n\t\t\tif (!err)\n\t\t\t\terr = err2;\n\t\t} else {\n\t\t\t/* Clear any previously stored errors */\n\t\t\tfilemap_check_errors(mapping);\n\t\t}\n\t} else {\n\t\terr = filemap_check_errors(mapping);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_range_has_page",
          "args": [
            "mapping",
            "iocb->ki_pos",
            "iocb->ki_pos + count - 1"
          ],
          "line": 2255
        },
        "resolved": true,
        "details": {
          "function_name": "filemap_range_has_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "457-485",
          "snippet": "bool filemap_range_has_page(struct address_space *mapping,\n\t\t\t   loff_t start_byte, loff_t end_byte)\n{\n\tstruct page *page;\n\tXA_STATE(xas, &mapping->i_pages, start_byte >> PAGE_SHIFT);\n\tpgoff_t max = end_byte >> PAGE_SHIFT;\n\n\tif (end_byte < start_byte)\n\t\treturn false;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tpage = xas_find(&xas, max);\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\t\t/* Shadow entries don't count */\n\t\tif (xa_is_value(page))\n\t\t\tcontinue;\n\t\t/*\n\t\t * We don't need to try to pin this page; we're about to\n\t\t * release the RCU lock anyway.  It is enough to know that\n\t\t * there was a page here recently.\n\t\t */\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn page != NULL;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nbool filemap_range_has_page(struct address_space *mapping,\n\t\t\t   loff_t start_byte, loff_t end_byte)\n{\n\tstruct page *page;\n\tXA_STATE(xas, &mapping->i_pages, start_byte >> PAGE_SHIFT);\n\tpgoff_t max = end_byte >> PAGE_SHIFT;\n\n\tif (end_byte < start_byte)\n\t\treturn false;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tpage = xas_find(&xas, max);\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\t\t/* Shadow entries don't count */\n\t\tif (xa_is_value(page))\n\t\t\tcontinue;\n\t\t/*\n\t\t * We don't need to try to pin this page; we're about to\n\t\t * release the RCU lock anyway.  It is enough to know that\n\t\t * there was a page here recently.\n\t\t */\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn page != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nssize_t\ngeneric_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tsize_t count = iov_iter_count(iter);\n\tssize_t retval = 0;\n\n\tif (!count)\n\t\tgoto out; /* skip atime */\n\n\tif (iocb->ki_flags & IOCB_DIRECT) {\n\t\tstruct file *file = iocb->ki_filp;\n\t\tstruct address_space *mapping = file->f_mapping;\n\t\tstruct inode *inode = mapping->host;\n\t\tloff_t size;\n\n\t\tsize = i_size_read(inode);\n\t\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\t\tif (filemap_range_has_page(mapping, iocb->ki_pos,\n\t\t\t\t\t\t   iocb->ki_pos + count - 1))\n\t\t\t\treturn -EAGAIN;\n\t\t} else {\n\t\t\tretval = filemap_write_and_wait_range(mapping,\n\t\t\t\t\t\tiocb->ki_pos,\n\t\t\t\t\t        iocb->ki_pos + count - 1);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tfile_accessed(file);\n\n\t\tretval = mapping->a_ops->direct_IO(iocb, iter);\n\t\tif (retval >= 0) {\n\t\t\tiocb->ki_pos += retval;\n\t\t\tcount -= retval;\n\t\t}\n\t\tiov_iter_revert(iter, count - iov_iter_count(iter));\n\n\t\t/*\n\t\t * Btrfs can have a short DIO read if we encounter\n\t\t * compressed extents, so if there was an error, or if\n\t\t * we've already read everything we wanted to, or if\n\t\t * there was a short read because we hit EOF, go ahead\n\t\t * and return.  Otherwise fallthrough to buffered io for\n\t\t * the rest of the read.  Buffered reads will not work for\n\t\t * DAX files, so don't bother trying.\n\t\t */\n\t\tif (retval < 0 || !count || iocb->ki_pos >= size ||\n\t\t    IS_DAX(inode))\n\t\t\tgoto out;\n\t}\n\n\tretval = generic_file_buffered_read(iocb, iter, retval);\nout:\n\treturn retval;\n}"
  },
  {
    "function_name": "generic_file_buffered_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "1977-2228",
    "snippet": "static ssize_t generic_file_buffered_read(struct kiocb *iocb,\n\t\tstruct iov_iter *iter, ssize_t written)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct address_space *mapping = filp->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct file_ra_state *ra = &filp->f_ra;\n\tloff_t *ppos = &iocb->ki_pos;\n\tpgoff_t index;\n\tpgoff_t last_index;\n\tpgoff_t prev_index;\n\tunsigned long offset;      /* offset into pagecache page */\n\tunsigned int prev_offset;\n\tint error = 0;\n\n\tif (unlikely(*ppos >= inode->i_sb->s_maxbytes))\n\t\treturn 0;\n\tiov_iter_truncate(iter, inode->i_sb->s_maxbytes);\n\n\tindex = *ppos >> PAGE_SHIFT;\n\tprev_index = ra->prev_pos >> PAGE_SHIFT;\n\tprev_offset = ra->prev_pos & (PAGE_SIZE-1);\n\tlast_index = (*ppos + iter->count + PAGE_SIZE-1) >> PAGE_SHIFT;\n\toffset = *ppos & ~PAGE_MASK;\n\n\tfor (;;) {\n\t\tstruct page *page;\n\t\tpgoff_t end_index;\n\t\tloff_t isize;\n\t\tunsigned long nr, ret;\n\n\t\tcond_resched();\nfind_page:\n\t\tif (fatal_signal_pending(current)) {\n\t\t\terror = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpage = find_get_page(mapping, index);\n\t\tif (!page) {\n\t\t\tif (iocb->ki_flags & IOCB_NOWAIT)\n\t\t\t\tgoto would_block;\n\t\t\tpage_cache_sync_readahead(mapping,\n\t\t\t\t\tra, filp,\n\t\t\t\t\tindex, last_index - index);\n\t\t\tpage = find_get_page(mapping, index);\n\t\t\tif (unlikely(page == NULL))\n\t\t\t\tgoto no_cached_page;\n\t\t}\n\t\tif (PageReadahead(page)) {\n\t\t\tpage_cache_async_readahead(mapping,\n\t\t\t\t\tra, filp, page,\n\t\t\t\t\tindex, last_index - index);\n\t\t}\n\t\tif (!PageUptodate(page)) {\n\t\t\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\t\t\tput_page(page);\n\t\t\t\tgoto would_block;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * See comment in do_read_cache_page on why\n\t\t\t * wait_on_page_locked is used to avoid unnecessarily\n\t\t\t * serialisations and why it's safe.\n\t\t\t */\n\t\t\terror = wait_on_page_locked_killable(page);\n\t\t\tif (unlikely(error))\n\t\t\t\tgoto readpage_error;\n\t\t\tif (PageUptodate(page))\n\t\t\t\tgoto page_ok;\n\n\t\t\tif (inode->i_blkbits == PAGE_SHIFT ||\n\t\t\t\t\t!mapping->a_ops->is_partially_uptodate)\n\t\t\t\tgoto page_not_up_to_date;\n\t\t\t/* pipes can't handle partially uptodate pages */\n\t\t\tif (unlikely(iov_iter_is_pipe(iter)))\n\t\t\t\tgoto page_not_up_to_date;\n\t\t\tif (!trylock_page(page))\n\t\t\t\tgoto page_not_up_to_date;\n\t\t\t/* Did it get truncated before we got the lock? */\n\t\t\tif (!page->mapping)\n\t\t\t\tgoto page_not_up_to_date_locked;\n\t\t\tif (!mapping->a_ops->is_partially_uptodate(page,\n\t\t\t\t\t\t\toffset, iter->count))\n\t\t\t\tgoto page_not_up_to_date_locked;\n\t\t\tunlock_page(page);\n\t\t}\npage_ok:\n\t\t/*\n\t\t * i_size must be checked after we know the page is Uptodate.\n\t\t *\n\t\t * Checking i_size after the check allows us to calculate\n\t\t * the correct value for \"nr\", which means the zero-filled\n\t\t * part of the page is not copied back to userspace (unless\n\t\t * another truncate extends the file - this is desired though).\n\t\t */\n\n\t\tisize = i_size_read(inode);\n\t\tend_index = (isize - 1) >> PAGE_SHIFT;\n\t\tif (unlikely(!isize || index > end_index)) {\n\t\t\tput_page(page);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* nr is the maximum number of bytes to copy from this page */\n\t\tnr = PAGE_SIZE;\n\t\tif (index == end_index) {\n\t\t\tnr = ((isize - 1) & ~PAGE_MASK) + 1;\n\t\t\tif (nr <= offset) {\n\t\t\t\tput_page(page);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tnr = nr - offset;\n\n\t\t/* If users can be writing to this page using arbitrary\n\t\t * virtual addresses, take care about potential aliasing\n\t\t * before reading the page on the kernel side.\n\t\t */\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\n\t\t/*\n\t\t * When a sequential read accesses a page several times,\n\t\t * only mark it as accessed the first time.\n\t\t */\n\t\tif (prev_index != index || offset != prev_offset)\n\t\t\tmark_page_accessed(page);\n\t\tprev_index = index;\n\n\t\t/*\n\t\t * Ok, we have the page, and it's up-to-date, so\n\t\t * now we can copy it to user space...\n\t\t */\n\n\t\tret = copy_page_to_iter(page, offset, nr, iter);\n\t\toffset += ret;\n\t\tindex += offset >> PAGE_SHIFT;\n\t\toffset &= ~PAGE_MASK;\n\t\tprev_offset = offset;\n\n\t\tput_page(page);\n\t\twritten += ret;\n\t\tif (!iov_iter_count(iter))\n\t\t\tgoto out;\n\t\tif (ret < nr) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tcontinue;\n\npage_not_up_to_date:\n\t\t/* Get exclusive access to the page ... */\n\t\terror = lock_page_killable(page);\n\t\tif (unlikely(error))\n\t\t\tgoto readpage_error;\n\npage_not_up_to_date_locked:\n\t\t/* Did it get truncated before we got the lock? */\n\t\tif (!page->mapping) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Did somebody else fill it already? */\n\t\tif (PageUptodate(page)) {\n\t\t\tunlock_page(page);\n\t\t\tgoto page_ok;\n\t\t}\n\nreadpage:\n\t\t/*\n\t\t * A previous I/O error may have been due to temporary\n\t\t * failures, eg. multipath errors.\n\t\t * PG_error will be set again if readpage fails.\n\t\t */\n\t\tClearPageError(page);\n\t\t/* Start the actual read. The read will unlock the page. */\n\t\terror = mapping->a_ops->readpage(filp, page);\n\n\t\tif (unlikely(error)) {\n\t\t\tif (error == AOP_TRUNCATED_PAGE) {\n\t\t\t\tput_page(page);\n\t\t\t\terror = 0;\n\t\t\t\tgoto find_page;\n\t\t\t}\n\t\t\tgoto readpage_error;\n\t\t}\n\n\t\tif (!PageUptodate(page)) {\n\t\t\terror = lock_page_killable(page);\n\t\t\tif (unlikely(error))\n\t\t\t\tgoto readpage_error;\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tif (page->mapping == NULL) {\n\t\t\t\t\t/*\n\t\t\t\t\t * invalidate_mapping_pages got it\n\t\t\t\t\t */\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tput_page(page);\n\t\t\t\t\tgoto find_page;\n\t\t\t\t}\n\t\t\t\tunlock_page(page);\n\t\t\t\tshrink_readahead_size_eio(filp, ra);\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto readpage_error;\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\tgoto page_ok;\n\nreadpage_error:\n\t\t/* UHHUH! A synchronous read error occurred. Report it */\n\t\tput_page(page);\n\t\tgoto out;\n\nno_cached_page:\n\t\t/*\n\t\t * Ok, it wasn't cached, so we need to create a new\n\t\t * page..\n\t\t */\n\t\tpage = page_cache_alloc(mapping);\n\t\tif (!page) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terror = add_to_page_cache_lru(page, mapping, index,\n\t\t\t\tmapping_gfp_constraint(mapping, GFP_KERNEL));\n\t\tif (error) {\n\t\t\tput_page(page);\n\t\t\tif (error == -EEXIST) {\n\t\t\t\terror = 0;\n\t\t\t\tgoto find_page;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\tgoto readpage;\n\t}\n\nwould_block:\n\terror = -EAGAIN;\nout:\n\tra->prev_pos = prev_index;\n\tra->prev_pos <<= PAGE_SHIFT;\n\tra->prev_pos |= prev_offset;\n\n\t*ppos = ((loff_t)index << PAGE_SHIFT) + offset;\n\tfile_accessed(filp);\n\treturn written ? written : error;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_accessed",
          "args": [
            "filp"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 2208
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_to_page_cache_lru",
          "args": [
            "page",
            "mapping",
            "index",
            "mapping_gfp_constraint(mapping, GFP_KERNEL)"
          ],
          "line": 2205
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_page_cache_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "879-905",
          "snippet": "int add_to_page_cache_lru(struct page *page, struct address_space *mapping,\n\t\t\t\tpgoff_t offset, gfp_t gfp_mask)\n{\n\tvoid *shadow = NULL;\n\tint ret;\n\n\t__SetPageLocked(page);\n\tret = __add_to_page_cache_locked(page, mapping, offset,\n\t\t\t\t\t gfp_mask, &shadow);\n\tif (unlikely(ret))\n\t\t__ClearPageLocked(page);\n\telse {\n\t\t/*\n\t\t * The page might have been evicted from cache only\n\t\t * recently, in which case it should be activated like\n\t\t * any other repeatedly accessed page.\n\t\t * The exception is pages getting rewritten; evicting other\n\t\t * data from the working set, only to cache data that will\n\t\t * get overwritten with something else, is a waste of memory.\n\t\t */\n\t\tWARN_ON_ONCE(PageActive(page));\n\t\tif (!(gfp_mask & __GFP_WRITE) && shadow)\n\t\t\tworkingset_refault(page, shadow);\n\t\tlru_cache_add(page);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint add_to_page_cache_lru(struct page *page, struct address_space *mapping,\n\t\t\t\tpgoff_t offset, gfp_t gfp_mask)\n{\n\tvoid *shadow = NULL;\n\tint ret;\n\n\t__SetPageLocked(page);\n\tret = __add_to_page_cache_locked(page, mapping, offset,\n\t\t\t\t\t gfp_mask, &shadow);\n\tif (unlikely(ret))\n\t\t__ClearPageLocked(page);\n\telse {\n\t\t/*\n\t\t * The page might have been evicted from cache only\n\t\t * recently, in which case it should be activated like\n\t\t * any other repeatedly accessed page.\n\t\t * The exception is pages getting rewritten; evicting other\n\t\t * data from the working set, only to cache data that will\n\t\t * get overwritten with something else, is a waste of memory.\n\t\t */\n\t\tWARN_ON_ONCE(PageActive(page));\n\t\tif (!(gfp_mask & __GFP_WRITE) && shadow)\n\t\t\tworkingset_refault(page, shadow);\n\t\tlru_cache_add(page);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_gfp_constraint",
          "args": [
            "mapping",
            "GFP_KERNEL"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_alloc",
          "args": [
            "mapping"
          ],
          "line": 2200
        },
        "resolved": true,
        "details": {
          "function_name": "__page_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "909-925",
          "snippet": "struct page *__page_cache_alloc(gfp_t gfp)\n{\n\tint n;\n\tstruct page *page;\n\n\tif (cpuset_do_page_mem_spread()) {\n\t\tunsigned int cpuset_mems_cookie;\n\t\tdo {\n\t\t\tcpuset_mems_cookie = read_mems_allowed_begin();\n\t\t\tn = cpuset_mem_spread_node();\n\t\t\tpage = __alloc_pages_node(n, gfp, 0);\n\t\t} while (!page && read_mems_allowed_retry(cpuset_mems_cookie));\n\n\t\treturn page;\n\t}\n\treturn alloc_pages(gfp, 0);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstruct page *__page_cache_alloc(gfp_t gfp)\n{\n\tint n;\n\tstruct page *page;\n\n\tif (cpuset_do_page_mem_spread()) {\n\t\tunsigned int cpuset_mems_cookie;\n\t\tdo {\n\t\t\tcpuset_mems_cookie = read_mems_allowed_begin();\n\t\t\tn = cpuset_mem_spread_node();\n\t\t\tpage = __alloc_pages_node(n, gfp, 0);\n\t\t} while (!page && read_mems_allowed_retry(cpuset_mems_cookie));\n\n\t\treturn page;\n\t}\n\treturn alloc_pages(gfp, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2185
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1195-1202",
          "snippet": "void unlock_page(struct page *page)\n{\n\tBUILD_BUG_ON(PG_waiters != 7);\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (clear_bit_unlock_is_negative_byte(PG_locked, &page->flags))\n\t\twake_up_page_bit(page, PG_locked);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid unlock_page(struct page *page)\n{\n\tBUILD_BUG_ON(PG_waiters != 7);\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (clear_bit_unlock_is_negative_byte(PG_locked, &page->flags))\n\t\twake_up_page_bit(page, PG_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "shrink_readahead_size_eio",
          "args": [
            "filp",
            "ra"
          ],
          "line": 2181
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_readahead_size_eio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1959-1963",
          "snippet": "static void shrink_readahead_size_eio(struct file *filp,\n\t\t\t\t\tstruct file_ra_state *ra)\n{\n\tra->ra_pages /= 4;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic void shrink_readahead_size_eio(struct file *filp,\n\t\t\t\t\tstruct file_ra_state *ra)\n{\n\tra->ra_pages /= 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 2169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_page_killable",
          "args": [
            "page"
          ],
          "line": 2168
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_page_killable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1271-1276",
          "snippet": "int __lock_page_killable(struct page *__page)\n{\n\tstruct page *page = compound_head(__page);\n\twait_queue_head_t *q = page_waitqueue(page);\n\treturn wait_on_page_bit_common(q, page, PG_locked, TASK_KILLABLE, true);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint __lock_page_killable(struct page *__page)\n{\n\tstruct page *page = compound_head(__page);\n\twait_queue_head_t *q = page_waitqueue(page);\n\treturn wait_on_page_bit_common(q, page, PG_locked, TASK_KILLABLE, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->readpage",
          "args": [
            "filp",
            "page"
          ],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageError",
          "args": [
            "page"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_page_to_iter",
          "args": [
            "page",
            "offset",
            "nr",
            "iter"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_page_accessed",
          "args": [
            "page"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "mark_page_accessed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "376-400",
          "snippet": "void mark_page_accessed(struct page *page)\n{\n\tpage = compound_head(page);\n\tif (!PageActive(page) && !PageUnevictable(page) &&\n\t\t\tPageReferenced(page)) {\n\n\t\t/*\n\t\t * If the page is on the LRU, queue it for activation via\n\t\t * activate_page_pvecs. Otherwise, assume the page is on a\n\t\t * pagevec, mark it active and it'll be moved to the active\n\t\t * LRU on the next drain.\n\t\t */\n\t\tif (PageLRU(page))\n\t\t\tactivate_page(page);\n\t\telse\n\t\t\t__lru_cache_activate_page(page);\n\t\tClearPageReferenced(page);\n\t\tif (page_is_file_cache(page))\n\t\t\tworkingset_activation(page);\n\t} else if (!PageReferenced(page)) {\n\t\tSetPageReferenced(page);\n\t}\n\tif (page_is_idle(page))\n\t\tclear_page_idle(page);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid mark_page_accessed(struct page *page)\n{\n\tpage = compound_head(page);\n\tif (!PageActive(page) && !PageUnevictable(page) &&\n\t\t\tPageReferenced(page)) {\n\n\t\t/*\n\t\t * If the page is on the LRU, queue it for activation via\n\t\t * activate_page_pvecs. Otherwise, assume the page is on a\n\t\t * pagevec, mark it active and it'll be moved to the active\n\t\t * LRU on the next drain.\n\t\t */\n\t\tif (PageLRU(page))\n\t\t\tactivate_page(page);\n\t\telse\n\t\t\t__lru_cache_activate_page(page);\n\t\tClearPageReferenced(page);\n\t\tif (page_is_file_cache(page))\n\t\t\tworkingset_activation(page);\n\t} else if (!PageReferenced(page)) {\n\t\tSetPageReferenced(page);\n\t}\n\tif (page_is_idle(page))\n\t\tclear_page_idle(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_writably_mapped",
          "args": [
            "mapping"
          ],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!isize || index > end_index"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->is_partially_uptodate",
          "args": [
            "page",
            "offset",
            "iter->count"
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "iov_iter_is_pipe(iter)"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_is_pipe",
          "args": [
            "iter"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_locked_killable",
          "args": [
            "page"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_async_readahead",
          "args": [
            "mapping",
            "ra",
            "filp",
            "page",
            "index",
            "last_index - index"
          ],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "page_cache_async_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
          "lines": "545-574",
          "snippet": "void\npage_cache_async_readahead(struct address_space *mapping,\n\t\t\t   struct file_ra_state *ra, struct file *filp,\n\t\t\t   struct page *page, pgoff_t offset,\n\t\t\t   unsigned long req_size)\n{\n\t/* no read-ahead */\n\tif (!ra->ra_pages)\n\t\treturn;\n\n\t/*\n\t * Same bit is used for PG_readahead and PG_reclaim.\n\t */\n\tif (PageWriteback(page))\n\t\treturn;\n\n\tClearPageReadahead(page);\n\n\t/*\n\t * Defer asynchronous read-ahead on IO congestion.\n\t */\n\tif (inode_read_congested(mapping->host))\n\t\treturn;\n\n\tif (blk_cgroup_congested())\n\t\treturn;\n\n\t/* do read-ahead */\n\tondemand_readahead(mapping, ra, filp, true, offset, req_size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fadvise.h>",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/export.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nvoid\npage_cache_async_readahead(struct address_space *mapping,\n\t\t\t   struct file_ra_state *ra, struct file *filp,\n\t\t\t   struct page *page, pgoff_t offset,\n\t\t\t   unsigned long req_size)\n{\n\t/* no read-ahead */\n\tif (!ra->ra_pages)\n\t\treturn;\n\n\t/*\n\t * Same bit is used for PG_readahead and PG_reclaim.\n\t */\n\tif (PageWriteback(page))\n\t\treturn;\n\n\tClearPageReadahead(page);\n\n\t/*\n\t * Defer asynchronous read-ahead on IO congestion.\n\t */\n\tif (inode_read_congested(mapping->host))\n\t\treturn;\n\n\tif (blk_cgroup_congested())\n\t\treturn;\n\n\t/* do read-ahead */\n\tondemand_readahead(mapping, ra, filp, true, offset, req_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageReadahead",
          "args": [
            "page"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page == NULL"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "mapping",
            "index"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_sync_readahead",
          "args": [
            "mapping",
            "ra",
            "filp",
            "index",
            "last_index - index"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "page_cache_sync_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
          "lines": "508-527",
          "snippet": "void page_cache_sync_readahead(struct address_space *mapping,\n\t\t\t       struct file_ra_state *ra, struct file *filp,\n\t\t\t       pgoff_t offset, unsigned long req_size)\n{\n\t/* no read-ahead */\n\tif (!ra->ra_pages)\n\t\treturn;\n\n\tif (blk_cgroup_congested())\n\t\treturn;\n\n\t/* be dumb */\n\tif (filp && (filp->f_mode & FMODE_RANDOM)) {\n\t\tforce_page_cache_readahead(mapping, filp, offset, req_size);\n\t\treturn;\n\t}\n\n\t/* do read-ahead */\n\tondemand_readahead(mapping, ra, filp, false, offset, req_size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fadvise.h>",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/export.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nvoid page_cache_sync_readahead(struct address_space *mapping,\n\t\t\t       struct file_ra_state *ra, struct file *filp,\n\t\t\t       pgoff_t offset, unsigned long req_size)\n{\n\t/* no read-ahead */\n\tif (!ra->ra_pages)\n\t\treturn;\n\n\tif (blk_cgroup_congested())\n\t\treturn;\n\n\t/* be dumb */\n\tif (filp && (filp->f_mode & FMODE_RANDOM)) {\n\t\tforce_page_cache_readahead(mapping, filp, offset, req_size);\n\t\treturn;\n\t}\n\n\t/* do read-ahead */\n\tondemand_readahead(mapping, ra, filp, false, offset, req_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "mapping",
            "index"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_truncate",
          "args": [
            "iter",
            "inode->i_sb->s_maxbytes"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "*ppos >= inode->i_sb->s_maxbytes"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic ssize_t generic_file_buffered_read(struct kiocb *iocb,\n\t\tstruct iov_iter *iter, ssize_t written)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct address_space *mapping = filp->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct file_ra_state *ra = &filp->f_ra;\n\tloff_t *ppos = &iocb->ki_pos;\n\tpgoff_t index;\n\tpgoff_t last_index;\n\tpgoff_t prev_index;\n\tunsigned long offset;      /* offset into pagecache page */\n\tunsigned int prev_offset;\n\tint error = 0;\n\n\tif (unlikely(*ppos >= inode->i_sb->s_maxbytes))\n\t\treturn 0;\n\tiov_iter_truncate(iter, inode->i_sb->s_maxbytes);\n\n\tindex = *ppos >> PAGE_SHIFT;\n\tprev_index = ra->prev_pos >> PAGE_SHIFT;\n\tprev_offset = ra->prev_pos & (PAGE_SIZE-1);\n\tlast_index = (*ppos + iter->count + PAGE_SIZE-1) >> PAGE_SHIFT;\n\toffset = *ppos & ~PAGE_MASK;\n\n\tfor (;;) {\n\t\tstruct page *page;\n\t\tpgoff_t end_index;\n\t\tloff_t isize;\n\t\tunsigned long nr, ret;\n\n\t\tcond_resched();\nfind_page:\n\t\tif (fatal_signal_pending(current)) {\n\t\t\terror = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpage = find_get_page(mapping, index);\n\t\tif (!page) {\n\t\t\tif (iocb->ki_flags & IOCB_NOWAIT)\n\t\t\t\tgoto would_block;\n\t\t\tpage_cache_sync_readahead(mapping,\n\t\t\t\t\tra, filp,\n\t\t\t\t\tindex, last_index - index);\n\t\t\tpage = find_get_page(mapping, index);\n\t\t\tif (unlikely(page == NULL))\n\t\t\t\tgoto no_cached_page;\n\t\t}\n\t\tif (PageReadahead(page)) {\n\t\t\tpage_cache_async_readahead(mapping,\n\t\t\t\t\tra, filp, page,\n\t\t\t\t\tindex, last_index - index);\n\t\t}\n\t\tif (!PageUptodate(page)) {\n\t\t\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\t\t\tput_page(page);\n\t\t\t\tgoto would_block;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * See comment in do_read_cache_page on why\n\t\t\t * wait_on_page_locked is used to avoid unnecessarily\n\t\t\t * serialisations and why it's safe.\n\t\t\t */\n\t\t\terror = wait_on_page_locked_killable(page);\n\t\t\tif (unlikely(error))\n\t\t\t\tgoto readpage_error;\n\t\t\tif (PageUptodate(page))\n\t\t\t\tgoto page_ok;\n\n\t\t\tif (inode->i_blkbits == PAGE_SHIFT ||\n\t\t\t\t\t!mapping->a_ops->is_partially_uptodate)\n\t\t\t\tgoto page_not_up_to_date;\n\t\t\t/* pipes can't handle partially uptodate pages */\n\t\t\tif (unlikely(iov_iter_is_pipe(iter)))\n\t\t\t\tgoto page_not_up_to_date;\n\t\t\tif (!trylock_page(page))\n\t\t\t\tgoto page_not_up_to_date;\n\t\t\t/* Did it get truncated before we got the lock? */\n\t\t\tif (!page->mapping)\n\t\t\t\tgoto page_not_up_to_date_locked;\n\t\t\tif (!mapping->a_ops->is_partially_uptodate(page,\n\t\t\t\t\t\t\toffset, iter->count))\n\t\t\t\tgoto page_not_up_to_date_locked;\n\t\t\tunlock_page(page);\n\t\t}\npage_ok:\n\t\t/*\n\t\t * i_size must be checked after we know the page is Uptodate.\n\t\t *\n\t\t * Checking i_size after the check allows us to calculate\n\t\t * the correct value for \"nr\", which means the zero-filled\n\t\t * part of the page is not copied back to userspace (unless\n\t\t * another truncate extends the file - this is desired though).\n\t\t */\n\n\t\tisize = i_size_read(inode);\n\t\tend_index = (isize - 1) >> PAGE_SHIFT;\n\t\tif (unlikely(!isize || index > end_index)) {\n\t\t\tput_page(page);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* nr is the maximum number of bytes to copy from this page */\n\t\tnr = PAGE_SIZE;\n\t\tif (index == end_index) {\n\t\t\tnr = ((isize - 1) & ~PAGE_MASK) + 1;\n\t\t\tif (nr <= offset) {\n\t\t\t\tput_page(page);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tnr = nr - offset;\n\n\t\t/* If users can be writing to this page using arbitrary\n\t\t * virtual addresses, take care about potential aliasing\n\t\t * before reading the page on the kernel side.\n\t\t */\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\n\t\t/*\n\t\t * When a sequential read accesses a page several times,\n\t\t * only mark it as accessed the first time.\n\t\t */\n\t\tif (prev_index != index || offset != prev_offset)\n\t\t\tmark_page_accessed(page);\n\t\tprev_index = index;\n\n\t\t/*\n\t\t * Ok, we have the page, and it's up-to-date, so\n\t\t * now we can copy it to user space...\n\t\t */\n\n\t\tret = copy_page_to_iter(page, offset, nr, iter);\n\t\toffset += ret;\n\t\tindex += offset >> PAGE_SHIFT;\n\t\toffset &= ~PAGE_MASK;\n\t\tprev_offset = offset;\n\n\t\tput_page(page);\n\t\twritten += ret;\n\t\tif (!iov_iter_count(iter))\n\t\t\tgoto out;\n\t\tif (ret < nr) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tcontinue;\n\npage_not_up_to_date:\n\t\t/* Get exclusive access to the page ... */\n\t\terror = lock_page_killable(page);\n\t\tif (unlikely(error))\n\t\t\tgoto readpage_error;\n\npage_not_up_to_date_locked:\n\t\t/* Did it get truncated before we got the lock? */\n\t\tif (!page->mapping) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Did somebody else fill it already? */\n\t\tif (PageUptodate(page)) {\n\t\t\tunlock_page(page);\n\t\t\tgoto page_ok;\n\t\t}\n\nreadpage:\n\t\t/*\n\t\t * A previous I/O error may have been due to temporary\n\t\t * failures, eg. multipath errors.\n\t\t * PG_error will be set again if readpage fails.\n\t\t */\n\t\tClearPageError(page);\n\t\t/* Start the actual read. The read will unlock the page. */\n\t\terror = mapping->a_ops->readpage(filp, page);\n\n\t\tif (unlikely(error)) {\n\t\t\tif (error == AOP_TRUNCATED_PAGE) {\n\t\t\t\tput_page(page);\n\t\t\t\terror = 0;\n\t\t\t\tgoto find_page;\n\t\t\t}\n\t\t\tgoto readpage_error;\n\t\t}\n\n\t\tif (!PageUptodate(page)) {\n\t\t\terror = lock_page_killable(page);\n\t\t\tif (unlikely(error))\n\t\t\t\tgoto readpage_error;\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tif (page->mapping == NULL) {\n\t\t\t\t\t/*\n\t\t\t\t\t * invalidate_mapping_pages got it\n\t\t\t\t\t */\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tput_page(page);\n\t\t\t\t\tgoto find_page;\n\t\t\t\t}\n\t\t\t\tunlock_page(page);\n\t\t\t\tshrink_readahead_size_eio(filp, ra);\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto readpage_error;\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\tgoto page_ok;\n\nreadpage_error:\n\t\t/* UHHUH! A synchronous read error occurred. Report it */\n\t\tput_page(page);\n\t\tgoto out;\n\nno_cached_page:\n\t\t/*\n\t\t * Ok, it wasn't cached, so we need to create a new\n\t\t * page..\n\t\t */\n\t\tpage = page_cache_alloc(mapping);\n\t\tif (!page) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terror = add_to_page_cache_lru(page, mapping, index,\n\t\t\t\tmapping_gfp_constraint(mapping, GFP_KERNEL));\n\t\tif (error) {\n\t\t\tput_page(page);\n\t\t\tif (error == -EEXIST) {\n\t\t\t\terror = 0;\n\t\t\t\tgoto find_page;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\tgoto readpage;\n\t}\n\nwould_block:\n\terror = -EAGAIN;\nout:\n\tra->prev_pos = prev_index;\n\tra->prev_pos <<= PAGE_SHIFT;\n\tra->prev_pos |= prev_offset;\n\n\t*ppos = ((loff_t)index << PAGE_SHIFT) + offset;\n\tfile_accessed(filp);\n\treturn written ? written : error;\n}"
  },
  {
    "function_name": "shrink_readahead_size_eio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "1959-1963",
    "snippet": "static void shrink_readahead_size_eio(struct file *filp,\n\t\t\t\t\tstruct file_ra_state *ra)\n{\n\tra->ra_pages /= 4;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic void shrink_readahead_size_eio(struct file *filp,\n\t\t\t\t\tstruct file_ra_state *ra)\n{\n\tra->ra_pages /= 4;\n}"
  },
  {
    "function_name": "find_get_entries_tag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "1892-1941",
    "snippet": "unsigned find_get_entries_tag(struct address_space *mapping, pgoff_t start,\n\t\t\txa_mark_t tag, unsigned int nr_entries,\n\t\t\tstruct page **entries, pgoff_t *indices)\n{\n\tXA_STATE(xas, &mapping->i_pages, start);\n\tstruct page *page;\n\tunsigned int ret = 0;\n\n\tif (!nr_entries)\n\t\treturn 0;\n\n\trcu_read_lock();\n\txas_for_each_marked(&xas, page, ULONG_MAX, tag) {\n\t\tstruct page *head;\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\t\t/*\n\t\t * A shadow entry of a recently evicted page, a swap\n\t\t * entry from shmem/tmpfs or a DAX entry.  Return it\n\t\t * without attempting to raise page count.\n\t\t */\n\t\tif (xa_is_value(page))\n\t\t\tgoto export;\n\n\t\thead = compound_head(page);\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto retry;\n\n\t\t/* The page was split under us? */\n\t\tif (compound_head(page) != head)\n\t\t\tgoto put_page;\n\n\t\t/* Has the page moved? */\n\t\tif (unlikely(page != xas_reload(&xas)))\n\t\t\tgoto put_page;\n\nexport:\n\t\tindices[ret] = xas.xa_index;\n\t\tentries[ret] = page;\n\t\tif (++ret == nr_entries)\n\t\t\tbreak;\n\t\tcontinue;\nput_page:\n\t\tput_page(head);\nretry:\n\t\txas_reset(&xas);\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_reset",
          "args": [
            "&xas"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "head"
          ],
          "line": 1935
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page != xas_reload(&xas)"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_reload",
          "args": [
            "&xas"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_get_speculative",
          "args": [
            "head"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "page"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_retry",
          "args": [
            "&xas",
            "page"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_for_each_marked",
          "args": [
            "&xas",
            "page",
            "ULONG_MAX",
            "tag"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "start"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nunsigned find_get_entries_tag(struct address_space *mapping, pgoff_t start,\n\t\t\txa_mark_t tag, unsigned int nr_entries,\n\t\t\tstruct page **entries, pgoff_t *indices)\n{\n\tXA_STATE(xas, &mapping->i_pages, start);\n\tstruct page *page;\n\tunsigned int ret = 0;\n\n\tif (!nr_entries)\n\t\treturn 0;\n\n\trcu_read_lock();\n\txas_for_each_marked(&xas, page, ULONG_MAX, tag) {\n\t\tstruct page *head;\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\t\t/*\n\t\t * A shadow entry of a recently evicted page, a swap\n\t\t * entry from shmem/tmpfs or a DAX entry.  Return it\n\t\t * without attempting to raise page count.\n\t\t */\n\t\tif (xa_is_value(page))\n\t\t\tgoto export;\n\n\t\thead = compound_head(page);\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto retry;\n\n\t\t/* The page was split under us? */\n\t\tif (compound_head(page) != head)\n\t\t\tgoto put_page;\n\n\t\t/* Has the page moved? */\n\t\tif (unlikely(page != xas_reload(&xas)))\n\t\t\tgoto put_page;\n\nexport:\n\t\tindices[ret] = xas.xa_index;\n\t\tentries[ret] = page;\n\t\tif (++ret == nr_entries)\n\t\t\tbreak;\n\t\tcontinue;\nput_page:\n\t\tput_page(head);\nretry:\n\t\txas_reset(&xas);\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "find_get_pages_range_tag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "1815-1877",
    "snippet": "unsigned find_get_pages_range_tag(struct address_space *mapping, pgoff_t *index,\n\t\t\tpgoff_t end, xa_mark_t tag, unsigned int nr_pages,\n\t\t\tstruct page **pages)\n{\n\tXA_STATE(xas, &mapping->i_pages, *index);\n\tstruct page *page;\n\tunsigned ret = 0;\n\n\tif (unlikely(!nr_pages))\n\t\treturn 0;\n\n\trcu_read_lock();\n\txas_for_each_marked(&xas, page, end, tag) {\n\t\tstruct page *head;\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\t\t/*\n\t\t * Shadow entries should never be tagged, but this iteration\n\t\t * is lockless so there is a window for page reclaim to evict\n\t\t * a page we saw tagged.  Skip over it.\n\t\t */\n\t\tif (xa_is_value(page))\n\t\t\tcontinue;\n\n\t\thead = compound_head(page);\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto retry;\n\n\t\t/* The page was split under us? */\n\t\tif (compound_head(page) != head)\n\t\t\tgoto put_page;\n\n\t\t/* Has the page moved? */\n\t\tif (unlikely(page != xas_reload(&xas)))\n\t\t\tgoto put_page;\n\n\t\tpages[ret] = page;\n\t\tif (++ret == nr_pages) {\n\t\t\t*index = page->index + 1;\n\t\t\tgoto out;\n\t\t}\n\t\tcontinue;\nput_page:\n\t\tput_page(head);\nretry:\n\t\txas_reset(&xas);\n\t}\n\n\t/*\n\t * We come here when we got to @end. We take care to not overflow the\n\t * index @index as it confuses some of the callers. This breaks the\n\t * iteration when there is a page at index -1 but that is already\n\t * broken anyway.\n\t */\n\tif (end == (pgoff_t)-1)\n\t\t*index = (pgoff_t)-1;\n\telse\n\t\t*index = end + 1;\nout:\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_reset",
          "args": [
            "&xas"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "head"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page != xas_reload(&xas)"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_reload",
          "args": [
            "&xas"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_get_speculative",
          "args": [
            "head"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "page"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_retry",
          "args": [
            "&xas",
            "page"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_for_each_marked",
          "args": [
            "&xas",
            "page",
            "end",
            "tag"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!nr_pages"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "*index"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nunsigned find_get_pages_range_tag(struct address_space *mapping, pgoff_t *index,\n\t\t\tpgoff_t end, xa_mark_t tag, unsigned int nr_pages,\n\t\t\tstruct page **pages)\n{\n\tXA_STATE(xas, &mapping->i_pages, *index);\n\tstruct page *page;\n\tunsigned ret = 0;\n\n\tif (unlikely(!nr_pages))\n\t\treturn 0;\n\n\trcu_read_lock();\n\txas_for_each_marked(&xas, page, end, tag) {\n\t\tstruct page *head;\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\t\t/*\n\t\t * Shadow entries should never be tagged, but this iteration\n\t\t * is lockless so there is a window for page reclaim to evict\n\t\t * a page we saw tagged.  Skip over it.\n\t\t */\n\t\tif (xa_is_value(page))\n\t\t\tcontinue;\n\n\t\thead = compound_head(page);\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto retry;\n\n\t\t/* The page was split under us? */\n\t\tif (compound_head(page) != head)\n\t\t\tgoto put_page;\n\n\t\t/* Has the page moved? */\n\t\tif (unlikely(page != xas_reload(&xas)))\n\t\t\tgoto put_page;\n\n\t\tpages[ret] = page;\n\t\tif (++ret == nr_pages) {\n\t\t\t*index = page->index + 1;\n\t\t\tgoto out;\n\t\t}\n\t\tcontinue;\nput_page:\n\t\tput_page(head);\nretry:\n\t\txas_reset(&xas);\n\t}\n\n\t/*\n\t * We come here when we got to @end. We take care to not overflow the\n\t * index @index as it confuses some of the callers. This breaks the\n\t * iteration when there is a page at index -1 but that is already\n\t * broken anyway.\n\t */\n\tif (end == (pgoff_t)-1)\n\t\t*index = (pgoff_t)-1;\n\telse\n\t\t*index = end + 1;\nout:\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "find_get_pages_contig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "1745-1800",
    "snippet": "unsigned find_get_pages_contig(struct address_space *mapping, pgoff_t index,\n\t\t\t       unsigned int nr_pages, struct page **pages)\n{\n\tXA_STATE(xas, &mapping->i_pages, index);\n\tstruct page *page;\n\tunsigned int ret = 0;\n\n\tif (unlikely(!nr_pages))\n\t\treturn 0;\n\n\trcu_read_lock();\n\tfor (page = xas_load(&xas); page; page = xas_next(&xas)) {\n\t\tstruct page *head;\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\t\t/*\n\t\t * If the entry has been swapped out, we can stop looking.\n\t\t * No current caller is looking for DAX entries.\n\t\t */\n\t\tif (xa_is_value(page))\n\t\t\tbreak;\n\n\t\thead = compound_head(page);\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto retry;\n\n\t\t/* The page was split under us? */\n\t\tif (compound_head(page) != head)\n\t\t\tgoto put_page;\n\n\t\t/* Has the page moved? */\n\t\tif (unlikely(page != xas_reload(&xas)))\n\t\t\tgoto put_page;\n\n\t\t/*\n\t\t * must check mapping and index after taking the ref.\n\t\t * otherwise we can get both false positives and false\n\t\t * negatives, which is just confusing to the caller.\n\t\t */\n\t\tif (!page->mapping || page_to_pgoff(page) != xas.xa_index) {\n\t\t\tput_page(page);\n\t\t\tbreak;\n\t\t}\n\n\t\tpages[ret] = page;\n\t\tif (++ret == nr_pages)\n\t\t\tbreak;\n\t\tcontinue;\nput_page:\n\t\tput_page(head);\nretry:\n\t\txas_reset(&xas);\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_reset",
          "args": [
            "&xas"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "head"
          ],
          "line": 1794
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_pgoff",
          "args": [
            "page"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page != xas_reload(&xas)"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_reload",
          "args": [
            "&xas"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_get_speculative",
          "args": [
            "head"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "page"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_retry",
          "args": [
            "&xas",
            "page"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_next",
          "args": [
            "&xas"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_load",
          "args": [
            "&xas"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!nr_pages"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "index"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nunsigned find_get_pages_contig(struct address_space *mapping, pgoff_t index,\n\t\t\t       unsigned int nr_pages, struct page **pages)\n{\n\tXA_STATE(xas, &mapping->i_pages, index);\n\tstruct page *page;\n\tunsigned int ret = 0;\n\n\tif (unlikely(!nr_pages))\n\t\treturn 0;\n\n\trcu_read_lock();\n\tfor (page = xas_load(&xas); page; page = xas_next(&xas)) {\n\t\tstruct page *head;\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\t\t/*\n\t\t * If the entry has been swapped out, we can stop looking.\n\t\t * No current caller is looking for DAX entries.\n\t\t */\n\t\tif (xa_is_value(page))\n\t\t\tbreak;\n\n\t\thead = compound_head(page);\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto retry;\n\n\t\t/* The page was split under us? */\n\t\tif (compound_head(page) != head)\n\t\t\tgoto put_page;\n\n\t\t/* Has the page moved? */\n\t\tif (unlikely(page != xas_reload(&xas)))\n\t\t\tgoto put_page;\n\n\t\t/*\n\t\t * must check mapping and index after taking the ref.\n\t\t * otherwise we can get both false positives and false\n\t\t * negatives, which is just confusing to the caller.\n\t\t */\n\t\tif (!page->mapping || page_to_pgoff(page) != xas.xa_index) {\n\t\t\tput_page(page);\n\t\t\tbreak;\n\t\t}\n\n\t\tpages[ret] = page;\n\t\tif (++ret == nr_pages)\n\t\t\tbreak;\n\t\tcontinue;\nput_page:\n\t\tput_page(head);\nretry:\n\t\txas_reset(&xas);\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "find_get_pages_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "1673-1731",
    "snippet": "unsigned find_get_pages_range(struct address_space *mapping, pgoff_t *start,\n\t\t\t      pgoff_t end, unsigned int nr_pages,\n\t\t\t      struct page **pages)\n{\n\tXA_STATE(xas, &mapping->i_pages, *start);\n\tstruct page *page;\n\tunsigned ret = 0;\n\n\tif (unlikely(!nr_pages))\n\t\treturn 0;\n\n\trcu_read_lock();\n\txas_for_each(&xas, page, end) {\n\t\tstruct page *head;\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\t\t/* Skip over shadow, swap and DAX entries */\n\t\tif (xa_is_value(page))\n\t\t\tcontinue;\n\n\t\thead = compound_head(page);\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto retry;\n\n\t\t/* The page was split under us? */\n\t\tif (compound_head(page) != head)\n\t\t\tgoto put_page;\n\n\t\t/* Has the page moved? */\n\t\tif (unlikely(page != xas_reload(&xas)))\n\t\t\tgoto put_page;\n\n\t\tpages[ret] = page;\n\t\tif (++ret == nr_pages) {\n\t\t\t*start = page->index + 1;\n\t\t\tgoto out;\n\t\t}\n\t\tcontinue;\nput_page:\n\t\tput_page(head);\nretry:\n\t\txas_reset(&xas);\n\t}\n\n\t/*\n\t * We come here when there is no page beyond @end. We take care to not\n\t * overflow the index @start as it confuses some of the callers. This\n\t * breaks the iteration when there is a page at index -1 but that is\n\t * already broken anyway.\n\t */\n\tif (end == (pgoff_t)-1)\n\t\t*start = (pgoff_t)-1;\n\telse\n\t\t*start = end + 1;\nout:\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_reset",
          "args": [
            "&xas"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "head"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page != xas_reload(&xas)"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_reload",
          "args": [
            "&xas"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_get_speculative",
          "args": [
            "head"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "page"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_retry",
          "args": [
            "&xas",
            "page"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_for_each",
          "args": [
            "&xas",
            "page",
            "end"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!nr_pages"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "*start"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nunsigned find_get_pages_range(struct address_space *mapping, pgoff_t *start,\n\t\t\t      pgoff_t end, unsigned int nr_pages,\n\t\t\t      struct page **pages)\n{\n\tXA_STATE(xas, &mapping->i_pages, *start);\n\tstruct page *page;\n\tunsigned ret = 0;\n\n\tif (unlikely(!nr_pages))\n\t\treturn 0;\n\n\trcu_read_lock();\n\txas_for_each(&xas, page, end) {\n\t\tstruct page *head;\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\t\t/* Skip over shadow, swap and DAX entries */\n\t\tif (xa_is_value(page))\n\t\t\tcontinue;\n\n\t\thead = compound_head(page);\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto retry;\n\n\t\t/* The page was split under us? */\n\t\tif (compound_head(page) != head)\n\t\t\tgoto put_page;\n\n\t\t/* Has the page moved? */\n\t\tif (unlikely(page != xas_reload(&xas)))\n\t\t\tgoto put_page;\n\n\t\tpages[ret] = page;\n\t\tif (++ret == nr_pages) {\n\t\t\t*start = page->index + 1;\n\t\t\tgoto out;\n\t\t}\n\t\tcontinue;\nput_page:\n\t\tput_page(head);\nretry:\n\t\txas_reset(&xas);\n\t}\n\n\t/*\n\t * We come here when there is no page beyond @end. We take care to not\n\t * overflow the index @start as it confuses some of the callers. This\n\t * breaks the iteration when there is a page at index -1 but that is\n\t * already broken anyway.\n\t */\n\tif (end == (pgoff_t)-1)\n\t\t*start = (pgoff_t)-1;\n\telse\n\t\t*start = end + 1;\nout:\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "find_get_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "1601-1650",
    "snippet": "unsigned find_get_entries(struct address_space *mapping,\n\t\t\t  pgoff_t start, unsigned int nr_entries,\n\t\t\t  struct page **entries, pgoff_t *indices)\n{\n\tXA_STATE(xas, &mapping->i_pages, start);\n\tstruct page *page;\n\tunsigned int ret = 0;\n\n\tif (!nr_entries)\n\t\treturn 0;\n\n\trcu_read_lock();\n\txas_for_each(&xas, page, ULONG_MAX) {\n\t\tstruct page *head;\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\t\t/*\n\t\t * A shadow entry of a recently evicted page, a swap\n\t\t * entry from shmem/tmpfs or a DAX entry.  Return it\n\t\t * without attempting to raise page count.\n\t\t */\n\t\tif (xa_is_value(page))\n\t\t\tgoto export;\n\n\t\thead = compound_head(page);\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto retry;\n\n\t\t/* The page was split under us? */\n\t\tif (compound_head(page) != head)\n\t\t\tgoto put_page;\n\n\t\t/* Has the page moved? */\n\t\tif (unlikely(page != xas_reload(&xas)))\n\t\t\tgoto put_page;\n\nexport:\n\t\tindices[ret] = xas.xa_index;\n\t\tentries[ret] = page;\n\t\tif (++ret == nr_entries)\n\t\t\tbreak;\n\t\tcontinue;\nput_page:\n\t\tput_page(head);\nretry:\n\t\txas_reset(&xas);\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_reset",
          "args": [
            "&xas"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "head"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page != xas_reload(&xas)"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_reload",
          "args": [
            "&xas"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_get_speculative",
          "args": [
            "head"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "page"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_retry",
          "args": [
            "&xas",
            "page"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_for_each",
          "args": [
            "&xas",
            "page",
            "ULONG_MAX"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "start"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nunsigned find_get_entries(struct address_space *mapping,\n\t\t\t  pgoff_t start, unsigned int nr_entries,\n\t\t\t  struct page **entries, pgoff_t *indices)\n{\n\tXA_STATE(xas, &mapping->i_pages, start);\n\tstruct page *page;\n\tunsigned int ret = 0;\n\n\tif (!nr_entries)\n\t\treturn 0;\n\n\trcu_read_lock();\n\txas_for_each(&xas, page, ULONG_MAX) {\n\t\tstruct page *head;\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\t\t/*\n\t\t * A shadow entry of a recently evicted page, a swap\n\t\t * entry from shmem/tmpfs or a DAX entry.  Return it\n\t\t * without attempting to raise page count.\n\t\t */\n\t\tif (xa_is_value(page))\n\t\t\tgoto export;\n\n\t\thead = compound_head(page);\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto retry;\n\n\t\t/* The page was split under us? */\n\t\tif (compound_head(page) != head)\n\t\t\tgoto put_page;\n\n\t\t/* Has the page moved? */\n\t\tif (unlikely(page != xas_reload(&xas)))\n\t\t\tgoto put_page;\n\nexport:\n\t\tindices[ret] = xas.xa_index;\n\t\tentries[ret] = page;\n\t\tif (++ret == nr_entries)\n\t\t\tbreak;\n\t\tcontinue;\nput_page:\n\t\tput_page(head);\nretry:\n\t\txas_reset(&xas);\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "pagecache_get_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "1512-1575",
    "snippet": "struct page *pagecache_get_page(struct address_space *mapping, pgoff_t offset,\n\tint fgp_flags, gfp_t gfp_mask)\n{\n\tstruct page *page;\n\nrepeat:\n\tpage = find_get_entry(mapping, offset);\n\tif (xa_is_value(page))\n\t\tpage = NULL;\n\tif (!page)\n\t\tgoto no_page;\n\n\tif (fgp_flags & FGP_LOCK) {\n\t\tif (fgp_flags & FGP_NOWAIT) {\n\t\t\tif (!trylock_page(page)) {\n\t\t\t\tput_page(page);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tlock_page(page);\n\t\t}\n\n\t\t/* Has the page been truncated? */\n\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto repeat;\n\t\t}\n\t\tVM_BUG_ON_PAGE(page->index != offset, page);\n\t}\n\n\tif (page && (fgp_flags & FGP_ACCESSED))\n\t\tmark_page_accessed(page);\n\nno_page:\n\tif (!page && (fgp_flags & FGP_CREAT)) {\n\t\tint err;\n\t\tif ((fgp_flags & FGP_WRITE) && mapping_cap_account_dirty(mapping))\n\t\t\tgfp_mask |= __GFP_WRITE;\n\t\tif (fgp_flags & FGP_NOFS)\n\t\t\tgfp_mask &= ~__GFP_FS;\n\n\t\tpage = __page_cache_alloc(gfp_mask);\n\t\tif (!page)\n\t\t\treturn NULL;\n\n\t\tif (WARN_ON_ONCE(!(fgp_flags & FGP_LOCK)))\n\t\t\tfgp_flags |= FGP_LOCK;\n\n\t\t/* Init accessed so avoid atomic mark_page_accessed later */\n\t\tif (fgp_flags & FGP_ACCESSED)\n\t\t\t__SetPageReferenced(page);\n\n\t\terr = add_to_page_cache_lru(page, mapping, offset, gfp_mask);\n\t\tif (unlikely(err)) {\n\t\t\tput_page(page);\n\t\t\tpage = NULL;\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t}\n\t}\n\n\treturn page;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_page_cache_lru",
          "args": [
            "page",
            "mapping",
            "offset",
            "gfp_mask"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_page_cache_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "879-905",
          "snippet": "int add_to_page_cache_lru(struct page *page, struct address_space *mapping,\n\t\t\t\tpgoff_t offset, gfp_t gfp_mask)\n{\n\tvoid *shadow = NULL;\n\tint ret;\n\n\t__SetPageLocked(page);\n\tret = __add_to_page_cache_locked(page, mapping, offset,\n\t\t\t\t\t gfp_mask, &shadow);\n\tif (unlikely(ret))\n\t\t__ClearPageLocked(page);\n\telse {\n\t\t/*\n\t\t * The page might have been evicted from cache only\n\t\t * recently, in which case it should be activated like\n\t\t * any other repeatedly accessed page.\n\t\t * The exception is pages getting rewritten; evicting other\n\t\t * data from the working set, only to cache data that will\n\t\t * get overwritten with something else, is a waste of memory.\n\t\t */\n\t\tWARN_ON_ONCE(PageActive(page));\n\t\tif (!(gfp_mask & __GFP_WRITE) && shadow)\n\t\t\tworkingset_refault(page, shadow);\n\t\tlru_cache_add(page);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint add_to_page_cache_lru(struct page *page, struct address_space *mapping,\n\t\t\t\tpgoff_t offset, gfp_t gfp_mask)\n{\n\tvoid *shadow = NULL;\n\tint ret;\n\n\t__SetPageLocked(page);\n\tret = __add_to_page_cache_locked(page, mapping, offset,\n\t\t\t\t\t gfp_mask, &shadow);\n\tif (unlikely(ret))\n\t\t__ClearPageLocked(page);\n\telse {\n\t\t/*\n\t\t * The page might have been evicted from cache only\n\t\t * recently, in which case it should be activated like\n\t\t * any other repeatedly accessed page.\n\t\t * The exception is pages getting rewritten; evicting other\n\t\t * data from the working set, only to cache data that will\n\t\t * get overwritten with something else, is a waste of memory.\n\t\t */\n\t\tWARN_ON_ONCE(PageActive(page));\n\t\tif (!(gfp_mask & __GFP_WRITE) && shadow)\n\t\t\tworkingset_refault(page, shadow);\n\t\tlru_cache_add(page);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__SetPageReferenced",
          "args": [
            "page"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(fgp_flags & FGP_LOCK)"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__page_cache_alloc",
          "args": [
            "gfp_mask"
          ],
          "line": 1554
        },
        "resolved": true,
        "details": {
          "function_name": "__page_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "909-925",
          "snippet": "struct page *__page_cache_alloc(gfp_t gfp)\n{\n\tint n;\n\tstruct page *page;\n\n\tif (cpuset_do_page_mem_spread()) {\n\t\tunsigned int cpuset_mems_cookie;\n\t\tdo {\n\t\t\tcpuset_mems_cookie = read_mems_allowed_begin();\n\t\t\tn = cpuset_mem_spread_node();\n\t\t\tpage = __alloc_pages_node(n, gfp, 0);\n\t\t} while (!page && read_mems_allowed_retry(cpuset_mems_cookie));\n\n\t\treturn page;\n\t}\n\treturn alloc_pages(gfp, 0);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstruct page *__page_cache_alloc(gfp_t gfp)\n{\n\tint n;\n\tstruct page *page;\n\n\tif (cpuset_do_page_mem_spread()) {\n\t\tunsigned int cpuset_mems_cookie;\n\t\tdo {\n\t\t\tcpuset_mems_cookie = read_mems_allowed_begin();\n\t\t\tn = cpuset_mem_spread_node();\n\t\t\tpage = __alloc_pages_node(n, gfp, 0);\n\t\t} while (!page && read_mems_allowed_retry(cpuset_mems_cookie));\n\n\t\treturn page;\n\t}\n\treturn alloc_pages(gfp, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_cap_account_dirty",
          "args": [
            "mapping"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_page_accessed",
          "args": [
            "page"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "mark_page_accessed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "376-400",
          "snippet": "void mark_page_accessed(struct page *page)\n{\n\tpage = compound_head(page);\n\tif (!PageActive(page) && !PageUnevictable(page) &&\n\t\t\tPageReferenced(page)) {\n\n\t\t/*\n\t\t * If the page is on the LRU, queue it for activation via\n\t\t * activate_page_pvecs. Otherwise, assume the page is on a\n\t\t * pagevec, mark it active and it'll be moved to the active\n\t\t * LRU on the next drain.\n\t\t */\n\t\tif (PageLRU(page))\n\t\t\tactivate_page(page);\n\t\telse\n\t\t\t__lru_cache_activate_page(page);\n\t\tClearPageReferenced(page);\n\t\tif (page_is_file_cache(page))\n\t\t\tworkingset_activation(page);\n\t} else if (!PageReferenced(page)) {\n\t\tSetPageReferenced(page);\n\t}\n\tif (page_is_idle(page))\n\t\tclear_page_idle(page);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid mark_page_accessed(struct page *page)\n{\n\tpage = compound_head(page);\n\tif (!PageActive(page) && !PageUnevictable(page) &&\n\t\t\tPageReferenced(page)) {\n\n\t\t/*\n\t\t * If the page is on the LRU, queue it for activation via\n\t\t * activate_page_pvecs. Otherwise, assume the page is on a\n\t\t * pagevec, mark it active and it'll be moved to the active\n\t\t * LRU on the next drain.\n\t\t */\n\t\tif (PageLRU(page))\n\t\t\tactivate_page(page);\n\t\telse\n\t\t\t__lru_cache_activate_page(page);\n\t\tClearPageReferenced(page);\n\t\tif (page_is_file_cache(page))\n\t\t\tworkingset_activation(page);\n\t} else if (!PageReferenced(page)) {\n\t\tSetPageReferenced(page);\n\t}\n\tif (page_is_idle(page))\n\t\tclear_page_idle(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "page->index != offset",
            "page"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1195-1202",
          "snippet": "void unlock_page(struct page *page)\n{\n\tBUILD_BUG_ON(PG_waiters != 7);\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (clear_bit_unlock_is_negative_byte(PG_locked, &page->flags))\n\t\twake_up_page_bit(page, PG_locked);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid unlock_page(struct page *page)\n{\n\tBUILD_BUG_ON(PG_waiters != 7);\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (clear_bit_unlock_is_negative_byte(PG_locked, &page->flags))\n\t\twake_up_page_bit(page, PG_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->mapping != mapping"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_page_killable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1271-1276",
          "snippet": "int __lock_page_killable(struct page *__page)\n{\n\tstruct page *page = compound_head(__page);\n\twait_queue_head_t *q = page_waitqueue(page);\n\treturn wait_on_page_bit_common(q, page, PG_locked, TASK_KILLABLE, true);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint __lock_page_killable(struct page *__page)\n{\n\tstruct page *page = compound_head(__page);\n\twait_queue_head_t *q = page_waitqueue(page);\n\treturn wait_on_page_bit_common(q, page, PG_locked, TASK_KILLABLE, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "page"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_entry",
          "args": [
            "mapping",
            "offset"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "find_get_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1407-1448",
          "snippet": "struct page *find_get_entry(struct address_space *mapping, pgoff_t offset)\n{\n\tXA_STATE(xas, &mapping->i_pages, offset);\n\tstruct page *head, *page;\n\n\trcu_read_lock();\nrepeat:\n\txas_reset(&xas);\n\tpage = xas_load(&xas);\n\tif (xas_retry(&xas, page))\n\t\tgoto repeat;\n\t/*\n\t * A shadow entry of a recently evicted page, or a swap entry from\n\t * shmem/tmpfs.  Return it without attempting to raise page count.\n\t */\n\tif (!page || xa_is_value(page))\n\t\tgoto out;\n\n\thead = compound_head(page);\n\tif (!page_cache_get_speculative(head))\n\t\tgoto repeat;\n\n\t/* The page was split under us? */\n\tif (compound_head(page) != head) {\n\t\tput_page(head);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * Has the page moved?\n\t * This is part of the lockless pagecache protocol. See\n\t * include/linux/pagemap.h for details.\n\t */\n\tif (unlikely(page != xas_reload(&xas))) {\n\t\tput_page(head);\n\t\tgoto repeat;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn page;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstruct page *find_get_entry(struct address_space *mapping, pgoff_t offset)\n{\n\tXA_STATE(xas, &mapping->i_pages, offset);\n\tstruct page *head, *page;\n\n\trcu_read_lock();\nrepeat:\n\txas_reset(&xas);\n\tpage = xas_load(&xas);\n\tif (xas_retry(&xas, page))\n\t\tgoto repeat;\n\t/*\n\t * A shadow entry of a recently evicted page, or a swap entry from\n\t * shmem/tmpfs.  Return it without attempting to raise page count.\n\t */\n\tif (!page || xa_is_value(page))\n\t\tgoto out;\n\n\thead = compound_head(page);\n\tif (!page_cache_get_speculative(head))\n\t\tgoto repeat;\n\n\t/* The page was split under us? */\n\tif (compound_head(page) != head) {\n\t\tput_page(head);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * Has the page moved?\n\t * This is part of the lockless pagecache protocol. See\n\t * include/linux/pagemap.h for details.\n\t */\n\tif (unlikely(page != xas_reload(&xas))) {\n\t\tput_page(head);\n\t\tgoto repeat;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn page;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstruct page *pagecache_get_page(struct address_space *mapping, pgoff_t offset,\n\tint fgp_flags, gfp_t gfp_mask)\n{\n\tstruct page *page;\n\nrepeat:\n\tpage = find_get_entry(mapping, offset);\n\tif (xa_is_value(page))\n\t\tpage = NULL;\n\tif (!page)\n\t\tgoto no_page;\n\n\tif (fgp_flags & FGP_LOCK) {\n\t\tif (fgp_flags & FGP_NOWAIT) {\n\t\t\tif (!trylock_page(page)) {\n\t\t\t\tput_page(page);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tlock_page(page);\n\t\t}\n\n\t\t/* Has the page been truncated? */\n\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto repeat;\n\t\t}\n\t\tVM_BUG_ON_PAGE(page->index != offset, page);\n\t}\n\n\tif (page && (fgp_flags & FGP_ACCESSED))\n\t\tmark_page_accessed(page);\n\nno_page:\n\tif (!page && (fgp_flags & FGP_CREAT)) {\n\t\tint err;\n\t\tif ((fgp_flags & FGP_WRITE) && mapping_cap_account_dirty(mapping))\n\t\t\tgfp_mask |= __GFP_WRITE;\n\t\tif (fgp_flags & FGP_NOFS)\n\t\t\tgfp_mask &= ~__GFP_FS;\n\n\t\tpage = __page_cache_alloc(gfp_mask);\n\t\tif (!page)\n\t\t\treturn NULL;\n\n\t\tif (WARN_ON_ONCE(!(fgp_flags & FGP_LOCK)))\n\t\t\tfgp_flags |= FGP_LOCK;\n\n\t\t/* Init accessed so avoid atomic mark_page_accessed later */\n\t\tif (fgp_flags & FGP_ACCESSED)\n\t\t\t__SetPageReferenced(page);\n\n\t\terr = add_to_page_cache_lru(page, mapping, offset, gfp_mask);\n\t\tif (unlikely(err)) {\n\t\t\tput_page(page);\n\t\t\tpage = NULL;\n\t\t\tif (err == -EEXIST)\n\t\t\t\tgoto repeat;\n\t\t}\n\t}\n\n\treturn page;\n}"
  },
  {
    "function_name": "find_lock_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "1467-1484",
    "snippet": "struct page *find_lock_entry(struct address_space *mapping, pgoff_t offset)\n{\n\tstruct page *page;\n\nrepeat:\n\tpage = find_get_entry(mapping, offset);\n\tif (page && !xa_is_value(page)) {\n\t\tlock_page(page);\n\t\t/* Has the page been truncated? */\n\t\tif (unlikely(page_mapping(page) != mapping)) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto repeat;\n\t\t}\n\t\tVM_BUG_ON_PAGE(page_to_pgoff(page) != offset, page);\n\t}\n\treturn page;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "page_to_pgoff(page) != offset",
            "page"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pgoff",
          "args": [
            "page"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1195-1202",
          "snippet": "void unlock_page(struct page *page)\n{\n\tBUILD_BUG_ON(PG_waiters != 7);\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (clear_bit_unlock_is_negative_byte(PG_locked, &page->flags))\n\t\twake_up_page_bit(page, PG_locked);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid unlock_page(struct page *page)\n{\n\tBUILD_BUG_ON(PG_waiters != 7);\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (clear_bit_unlock_is_negative_byte(PG_locked, &page->flags))\n\t\twake_up_page_bit(page, PG_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page_mapping(page) != mapping"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_page_killable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1271-1276",
          "snippet": "int __lock_page_killable(struct page *__page)\n{\n\tstruct page *page = compound_head(__page);\n\twait_queue_head_t *q = page_waitqueue(page);\n\treturn wait_on_page_bit_common(q, page, PG_locked, TASK_KILLABLE, true);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint __lock_page_killable(struct page *__page)\n{\n\tstruct page *page = compound_head(__page);\n\twait_queue_head_t *q = page_waitqueue(page);\n\treturn wait_on_page_bit_common(q, page, PG_locked, TASK_KILLABLE, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "page"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_entry",
          "args": [
            "mapping",
            "offset"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "find_get_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1407-1448",
          "snippet": "struct page *find_get_entry(struct address_space *mapping, pgoff_t offset)\n{\n\tXA_STATE(xas, &mapping->i_pages, offset);\n\tstruct page *head, *page;\n\n\trcu_read_lock();\nrepeat:\n\txas_reset(&xas);\n\tpage = xas_load(&xas);\n\tif (xas_retry(&xas, page))\n\t\tgoto repeat;\n\t/*\n\t * A shadow entry of a recently evicted page, or a swap entry from\n\t * shmem/tmpfs.  Return it without attempting to raise page count.\n\t */\n\tif (!page || xa_is_value(page))\n\t\tgoto out;\n\n\thead = compound_head(page);\n\tif (!page_cache_get_speculative(head))\n\t\tgoto repeat;\n\n\t/* The page was split under us? */\n\tif (compound_head(page) != head) {\n\t\tput_page(head);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * Has the page moved?\n\t * This is part of the lockless pagecache protocol. See\n\t * include/linux/pagemap.h for details.\n\t */\n\tif (unlikely(page != xas_reload(&xas))) {\n\t\tput_page(head);\n\t\tgoto repeat;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn page;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstruct page *find_get_entry(struct address_space *mapping, pgoff_t offset)\n{\n\tXA_STATE(xas, &mapping->i_pages, offset);\n\tstruct page *head, *page;\n\n\trcu_read_lock();\nrepeat:\n\txas_reset(&xas);\n\tpage = xas_load(&xas);\n\tif (xas_retry(&xas, page))\n\t\tgoto repeat;\n\t/*\n\t * A shadow entry of a recently evicted page, or a swap entry from\n\t * shmem/tmpfs.  Return it without attempting to raise page count.\n\t */\n\tif (!page || xa_is_value(page))\n\t\tgoto out;\n\n\thead = compound_head(page);\n\tif (!page_cache_get_speculative(head))\n\t\tgoto repeat;\n\n\t/* The page was split under us? */\n\tif (compound_head(page) != head) {\n\t\tput_page(head);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * Has the page moved?\n\t * This is part of the lockless pagecache protocol. See\n\t * include/linux/pagemap.h for details.\n\t */\n\tif (unlikely(page != xas_reload(&xas))) {\n\t\tput_page(head);\n\t\tgoto repeat;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn page;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstruct page *find_lock_entry(struct address_space *mapping, pgoff_t offset)\n{\n\tstruct page *page;\n\nrepeat:\n\tpage = find_get_entry(mapping, offset);\n\tif (page && !xa_is_value(page)) {\n\t\tlock_page(page);\n\t\t/* Has the page been truncated? */\n\t\tif (unlikely(page_mapping(page) != mapping)) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto repeat;\n\t\t}\n\t\tVM_BUG_ON_PAGE(page_to_pgoff(page) != offset, page);\n\t}\n\treturn page;\n}"
  },
  {
    "function_name": "find_get_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "1407-1448",
    "snippet": "struct page *find_get_entry(struct address_space *mapping, pgoff_t offset)\n{\n\tXA_STATE(xas, &mapping->i_pages, offset);\n\tstruct page *head, *page;\n\n\trcu_read_lock();\nrepeat:\n\txas_reset(&xas);\n\tpage = xas_load(&xas);\n\tif (xas_retry(&xas, page))\n\t\tgoto repeat;\n\t/*\n\t * A shadow entry of a recently evicted page, or a swap entry from\n\t * shmem/tmpfs.  Return it without attempting to raise page count.\n\t */\n\tif (!page || xa_is_value(page))\n\t\tgoto out;\n\n\thead = compound_head(page);\n\tif (!page_cache_get_speculative(head))\n\t\tgoto repeat;\n\n\t/* The page was split under us? */\n\tif (compound_head(page) != head) {\n\t\tput_page(head);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * Has the page moved?\n\t * This is part of the lockless pagecache protocol. See\n\t * include/linux/pagemap.h for details.\n\t */\n\tif (unlikely(page != xas_reload(&xas))) {\n\t\tput_page(head);\n\t\tgoto repeat;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn page;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "head"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page != xas_reload(&xas)"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_reload",
          "args": [
            "&xas"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_get_speculative",
          "args": [
            "head"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "page"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_retry",
          "args": [
            "&xas",
            "page"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_load",
          "args": [
            "&xas"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_reset",
          "args": [
            "&xas"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "offset"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstruct page *find_get_entry(struct address_space *mapping, pgoff_t offset)\n{\n\tXA_STATE(xas, &mapping->i_pages, offset);\n\tstruct page *head, *page;\n\n\trcu_read_lock();\nrepeat:\n\txas_reset(&xas);\n\tpage = xas_load(&xas);\n\tif (xas_retry(&xas, page))\n\t\tgoto repeat;\n\t/*\n\t * A shadow entry of a recently evicted page, or a swap entry from\n\t * shmem/tmpfs.  Return it without attempting to raise page count.\n\t */\n\tif (!page || xa_is_value(page))\n\t\tgoto out;\n\n\thead = compound_head(page);\n\tif (!page_cache_get_speculative(head))\n\t\tgoto repeat;\n\n\t/* The page was split under us? */\n\tif (compound_head(page) != head) {\n\t\tput_page(head);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * Has the page moved?\n\t * This is part of the lockless pagecache protocol. See\n\t * include/linux/pagemap.h for details.\n\t */\n\tif (unlikely(page != xas_reload(&xas))) {\n\t\tput_page(head);\n\t\tgoto repeat;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn page;\n}"
  },
  {
    "function_name": "page_cache_prev_miss",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "1377-1391",
    "snippet": "pgoff_t page_cache_prev_miss(struct address_space *mapping,\n\t\t\t     pgoff_t index, unsigned long max_scan)\n{\n\tXA_STATE(xas, &mapping->i_pages, index);\n\n\twhile (max_scan--) {\n\t\tvoid *entry = xas_prev(&xas);\n\t\tif (!entry || xa_is_value(entry))\n\t\t\tbreak;\n\t\tif (xas.xa_index == ULONG_MAX)\n\t\t\tbreak;\n\t}\n\n\treturn xas.xa_index;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "entry"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_prev",
          "args": [
            "&xas"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "index"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\npgoff_t page_cache_prev_miss(struct address_space *mapping,\n\t\t\t     pgoff_t index, unsigned long max_scan)\n{\n\tXA_STATE(xas, &mapping->i_pages, index);\n\n\twhile (max_scan--) {\n\t\tvoid *entry = xas_prev(&xas);\n\t\tif (!entry || xa_is_value(entry))\n\t\t\tbreak;\n\t\tif (xas.xa_index == ULONG_MAX)\n\t\t\tbreak;\n\t}\n\n\treturn xas.xa_index;\n}"
  },
  {
    "function_name": "page_cache_next_miss",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "1341-1355",
    "snippet": "pgoff_t page_cache_next_miss(struct address_space *mapping,\n\t\t\t     pgoff_t index, unsigned long max_scan)\n{\n\tXA_STATE(xas, &mapping->i_pages, index);\n\n\twhile (max_scan--) {\n\t\tvoid *entry = xas_next(&xas);\n\t\tif (!entry || xa_is_value(entry))\n\t\t\tbreak;\n\t\tif (xas.xa_index == 0)\n\t\t\tbreak;\n\t}\n\n\treturn xas.xa_index;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "entry"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_next",
          "args": [
            "&xas"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "index"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\npgoff_t page_cache_next_miss(struct address_space *mapping,\n\t\t\t     pgoff_t index, unsigned long max_scan)\n{\n\tXA_STATE(xas, &mapping->i_pages, index);\n\n\twhile (max_scan--) {\n\t\tvoid *entry = xas_next(&xas);\n\t\tif (!entry || xa_is_value(entry))\n\t\t\tbreak;\n\t\tif (xas.xa_index == 0)\n\t\t\tbreak;\n\t}\n\n\treturn xas.xa_index;\n}"
  },
  {
    "function_name": "__lock_page_or_retry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "1290-1320",
    "snippet": "int __lock_page_or_retry(struct page *page, struct mm_struct *mm,\n\t\t\t unsigned int flags)\n{\n\tif (flags & FAULT_FLAG_ALLOW_RETRY) {\n\t\t/*\n\t\t * CAUTION! In this case, mmap_sem is not released\n\t\t * even though return 0.\n\t\t */\n\t\tif (flags & FAULT_FLAG_RETRY_NOWAIT)\n\t\t\treturn 0;\n\n\t\tup_read(&mm->mmap_sem);\n\t\tif (flags & FAULT_FLAG_KILLABLE)\n\t\t\twait_on_page_locked_killable(page);\n\t\telse\n\t\t\twait_on_page_locked(page);\n\t\treturn 0;\n\t} else {\n\t\tif (flags & FAULT_FLAG_KILLABLE) {\n\t\t\tint ret;\n\n\t\t\tret = __lock_page_killable(page);\n\t\t\tif (ret) {\n\t\t\t\tup_read(&mm->mmap_sem);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else\n\t\t\t__lock_page(page);\n\t\treturn 1;\n\t}\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__lock_page",
          "args": [
            "page"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_page_killable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1271-1276",
          "snippet": "int __lock_page_killable(struct page *__page)\n{\n\tstruct page *page = compound_head(__page);\n\twait_queue_head_t *q = page_waitqueue(page);\n\treturn wait_on_page_bit_common(q, page, PG_locked, TASK_KILLABLE, true);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint __lock_page_killable(struct page *__page)\n{\n\tstruct page *page = compound_head(__page);\n\twait_queue_head_t *q = page_waitqueue(page);\n\treturn wait_on_page_bit_common(q, page, PG_locked, TASK_KILLABLE, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_locked",
          "args": [
            "page"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_locked_killable",
          "args": [
            "page"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint __lock_page_or_retry(struct page *page, struct mm_struct *mm,\n\t\t\t unsigned int flags)\n{\n\tif (flags & FAULT_FLAG_ALLOW_RETRY) {\n\t\t/*\n\t\t * CAUTION! In this case, mmap_sem is not released\n\t\t * even though return 0.\n\t\t */\n\t\tif (flags & FAULT_FLAG_RETRY_NOWAIT)\n\t\t\treturn 0;\n\n\t\tup_read(&mm->mmap_sem);\n\t\tif (flags & FAULT_FLAG_KILLABLE)\n\t\t\twait_on_page_locked_killable(page);\n\t\telse\n\t\t\twait_on_page_locked(page);\n\t\treturn 0;\n\t} else {\n\t\tif (flags & FAULT_FLAG_KILLABLE) {\n\t\t\tint ret;\n\n\t\t\tret = __lock_page_killable(page);\n\t\t\tif (ret) {\n\t\t\t\tup_read(&mm->mmap_sem);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else\n\t\t\t__lock_page(page);\n\t\treturn 1;\n\t}\n}"
  },
  {
    "function_name": "__lock_page_killable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "1271-1276",
    "snippet": "int __lock_page_killable(struct page *__page)\n{\n\tstruct page *page = compound_head(__page);\n\twait_queue_head_t *q = page_waitqueue(page);\n\treturn wait_on_page_bit_common(q, page, PG_locked, TASK_KILLABLE, true);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_page_bit_common",
          "args": [
            "q",
            "page",
            "PG_locked",
            "TASK_KILLABLE",
            "true"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "wait_on_page_bit_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1052-1122",
          "snippet": "static inline int wait_on_page_bit_common(wait_queue_head_t *q,\n\t\tstruct page *page, int bit_nr, int state, bool lock)\n{\n\tstruct wait_page_queue wait_page;\n\twait_queue_entry_t *wait = &wait_page.wait;\n\tbool thrashing = false;\n\tunsigned long pflags;\n\tint ret = 0;\n\n\tif (bit_nr == PG_locked &&\n\t    !PageUptodate(page) && PageWorkingset(page)) {\n\t\tif (!PageSwapBacked(page))\n\t\t\tdelayacct_thrashing_start();\n\t\tpsi_memstall_enter(&pflags);\n\t\tthrashing = true;\n\t}\n\n\tinit_wait(wait);\n\twait->flags = lock ? WQ_FLAG_EXCLUSIVE : 0;\n\twait->func = wake_page_function;\n\twait_page.page = page;\n\twait_page.bit_nr = bit_nr;\n\n\tfor (;;) {\n\t\tspin_lock_irq(&q->lock);\n\n\t\tif (likely(list_empty(&wait->entry))) {\n\t\t\t__add_wait_queue_entry_tail(q, wait);\n\t\t\tSetPageWaiters(page);\n\t\t}\n\n\t\tset_current_state(state);\n\n\t\tspin_unlock_irq(&q->lock);\n\n\t\tif (likely(test_bit(bit_nr, &page->flags))) {\n\t\t\tio_schedule();\n\t\t}\n\n\t\tif (lock) {\n\t\t\tif (!test_and_set_bit_lock(bit_nr, &page->flags))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (!test_bit(bit_nr, &page->flags))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(signal_pending_state(state, current))) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfinish_wait(q, wait);\n\n\tif (thrashing) {\n\t\tif (!PageSwapBacked(page))\n\t\t\tdelayacct_thrashing_end();\n\t\tpsi_memstall_leave(&pflags);\n\t}\n\n\t/*\n\t * A signal could leave PageWaiters set. Clearing it here if\n\t * !waitqueue_active would be possible (by open-coding finish_wait),\n\t * but still fail to catch it in the case of wait hash collision. We\n\t * already can fail to clear wait hash collision cases, so don't\n\t * bother with signals either.\n\t */\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline int wait_on_page_bit_common(wait_queue_head_t *q,\n\t\tstruct page *page, int bit_nr, int state, bool lock)\n{\n\tstruct wait_page_queue wait_page;\n\twait_queue_entry_t *wait = &wait_page.wait;\n\tbool thrashing = false;\n\tunsigned long pflags;\n\tint ret = 0;\n\n\tif (bit_nr == PG_locked &&\n\t    !PageUptodate(page) && PageWorkingset(page)) {\n\t\tif (!PageSwapBacked(page))\n\t\t\tdelayacct_thrashing_start();\n\t\tpsi_memstall_enter(&pflags);\n\t\tthrashing = true;\n\t}\n\n\tinit_wait(wait);\n\twait->flags = lock ? WQ_FLAG_EXCLUSIVE : 0;\n\twait->func = wake_page_function;\n\twait_page.page = page;\n\twait_page.bit_nr = bit_nr;\n\n\tfor (;;) {\n\t\tspin_lock_irq(&q->lock);\n\n\t\tif (likely(list_empty(&wait->entry))) {\n\t\t\t__add_wait_queue_entry_tail(q, wait);\n\t\t\tSetPageWaiters(page);\n\t\t}\n\n\t\tset_current_state(state);\n\n\t\tspin_unlock_irq(&q->lock);\n\n\t\tif (likely(test_bit(bit_nr, &page->flags))) {\n\t\t\tio_schedule();\n\t\t}\n\n\t\tif (lock) {\n\t\t\tif (!test_and_set_bit_lock(bit_nr, &page->flags))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (!test_bit(bit_nr, &page->flags))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(signal_pending_state(state, current))) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfinish_wait(q, wait);\n\n\tif (thrashing) {\n\t\tif (!PageSwapBacked(page))\n\t\t\tdelayacct_thrashing_end();\n\t\tpsi_memstall_leave(&pflags);\n\t}\n\n\t/*\n\t * A signal could leave PageWaiters set. Clearing it here if\n\t * !waitqueue_active would be possible (by open-coding finish_wait),\n\t * but still fail to catch it in the case of wait hash collision. We\n\t * already can fail to clear wait hash collision cases, so don't\n\t * bother with signals either.\n\t */\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_waitqueue",
          "args": [
            "page"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "page_waitqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "943-946",
          "snippet": "static wait_queue_head_t *page_waitqueue(struct page *page)\n{\n\treturn &page_wait_table[hash_ptr(page, PAGE_WAIT_TABLE_BITS)];\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define PAGE_WAIT_TABLE_BITS 8"
          ],
          "globals_used": [
            "static wait_queue_head_t page_wait_table[PAGE_WAIT_TABLE_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\n#define PAGE_WAIT_TABLE_BITS 8\n\nstatic wait_queue_head_t page_wait_table[PAGE_WAIT_TABLE_SIZE];\n\nstatic wait_queue_head_t *page_waitqueue(struct page *page)\n{\n\treturn &page_wait_table[hash_ptr(page, PAGE_WAIT_TABLE_BITS)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "__page"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint __lock_page_killable(struct page *__page)\n{\n\tstruct page *page = compound_head(__page);\n\twait_queue_head_t *q = page_waitqueue(page);\n\treturn wait_on_page_bit_common(q, page, PG_locked, TASK_KILLABLE, true);\n}"
  },
  {
    "function_name": "__lock_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "1263-1268",
    "snippet": "void __lock_page(struct page *__page)\n{\n\tstruct page *page = compound_head(__page);\n\twait_queue_head_t *q = page_waitqueue(page);\n\twait_on_page_bit_common(q, page, PG_locked, TASK_UNINTERRUPTIBLE, true);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_page_bit_common",
          "args": [
            "q",
            "page",
            "PG_locked",
            "TASK_UNINTERRUPTIBLE",
            "true"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "wait_on_page_bit_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1052-1122",
          "snippet": "static inline int wait_on_page_bit_common(wait_queue_head_t *q,\n\t\tstruct page *page, int bit_nr, int state, bool lock)\n{\n\tstruct wait_page_queue wait_page;\n\twait_queue_entry_t *wait = &wait_page.wait;\n\tbool thrashing = false;\n\tunsigned long pflags;\n\tint ret = 0;\n\n\tif (bit_nr == PG_locked &&\n\t    !PageUptodate(page) && PageWorkingset(page)) {\n\t\tif (!PageSwapBacked(page))\n\t\t\tdelayacct_thrashing_start();\n\t\tpsi_memstall_enter(&pflags);\n\t\tthrashing = true;\n\t}\n\n\tinit_wait(wait);\n\twait->flags = lock ? WQ_FLAG_EXCLUSIVE : 0;\n\twait->func = wake_page_function;\n\twait_page.page = page;\n\twait_page.bit_nr = bit_nr;\n\n\tfor (;;) {\n\t\tspin_lock_irq(&q->lock);\n\n\t\tif (likely(list_empty(&wait->entry))) {\n\t\t\t__add_wait_queue_entry_tail(q, wait);\n\t\t\tSetPageWaiters(page);\n\t\t}\n\n\t\tset_current_state(state);\n\n\t\tspin_unlock_irq(&q->lock);\n\n\t\tif (likely(test_bit(bit_nr, &page->flags))) {\n\t\t\tio_schedule();\n\t\t}\n\n\t\tif (lock) {\n\t\t\tif (!test_and_set_bit_lock(bit_nr, &page->flags))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (!test_bit(bit_nr, &page->flags))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(signal_pending_state(state, current))) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfinish_wait(q, wait);\n\n\tif (thrashing) {\n\t\tif (!PageSwapBacked(page))\n\t\t\tdelayacct_thrashing_end();\n\t\tpsi_memstall_leave(&pflags);\n\t}\n\n\t/*\n\t * A signal could leave PageWaiters set. Clearing it here if\n\t * !waitqueue_active would be possible (by open-coding finish_wait),\n\t * but still fail to catch it in the case of wait hash collision. We\n\t * already can fail to clear wait hash collision cases, so don't\n\t * bother with signals either.\n\t */\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline int wait_on_page_bit_common(wait_queue_head_t *q,\n\t\tstruct page *page, int bit_nr, int state, bool lock)\n{\n\tstruct wait_page_queue wait_page;\n\twait_queue_entry_t *wait = &wait_page.wait;\n\tbool thrashing = false;\n\tunsigned long pflags;\n\tint ret = 0;\n\n\tif (bit_nr == PG_locked &&\n\t    !PageUptodate(page) && PageWorkingset(page)) {\n\t\tif (!PageSwapBacked(page))\n\t\t\tdelayacct_thrashing_start();\n\t\tpsi_memstall_enter(&pflags);\n\t\tthrashing = true;\n\t}\n\n\tinit_wait(wait);\n\twait->flags = lock ? WQ_FLAG_EXCLUSIVE : 0;\n\twait->func = wake_page_function;\n\twait_page.page = page;\n\twait_page.bit_nr = bit_nr;\n\n\tfor (;;) {\n\t\tspin_lock_irq(&q->lock);\n\n\t\tif (likely(list_empty(&wait->entry))) {\n\t\t\t__add_wait_queue_entry_tail(q, wait);\n\t\t\tSetPageWaiters(page);\n\t\t}\n\n\t\tset_current_state(state);\n\n\t\tspin_unlock_irq(&q->lock);\n\n\t\tif (likely(test_bit(bit_nr, &page->flags))) {\n\t\t\tio_schedule();\n\t\t}\n\n\t\tif (lock) {\n\t\t\tif (!test_and_set_bit_lock(bit_nr, &page->flags))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (!test_bit(bit_nr, &page->flags))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(signal_pending_state(state, current))) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfinish_wait(q, wait);\n\n\tif (thrashing) {\n\t\tif (!PageSwapBacked(page))\n\t\t\tdelayacct_thrashing_end();\n\t\tpsi_memstall_leave(&pflags);\n\t}\n\n\t/*\n\t * A signal could leave PageWaiters set. Clearing it here if\n\t * !waitqueue_active would be possible (by open-coding finish_wait),\n\t * but still fail to catch it in the case of wait hash collision. We\n\t * already can fail to clear wait hash collision cases, so don't\n\t * bother with signals either.\n\t */\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_waitqueue",
          "args": [
            "page"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "page_waitqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "943-946",
          "snippet": "static wait_queue_head_t *page_waitqueue(struct page *page)\n{\n\treturn &page_wait_table[hash_ptr(page, PAGE_WAIT_TABLE_BITS)];\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define PAGE_WAIT_TABLE_BITS 8"
          ],
          "globals_used": [
            "static wait_queue_head_t page_wait_table[PAGE_WAIT_TABLE_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\n#define PAGE_WAIT_TABLE_BITS 8\n\nstatic wait_queue_head_t page_wait_table[PAGE_WAIT_TABLE_SIZE];\n\nstatic wait_queue_head_t *page_waitqueue(struct page *page)\n{\n\treturn &page_wait_table[hash_ptr(page, PAGE_WAIT_TABLE_BITS)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "__page"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid __lock_page(struct page *__page)\n{\n\tstruct page *page = compound_head(__page);\n\twait_queue_head_t *q = page_waitqueue(page);\n\twait_on_page_bit_common(q, page, PG_locked, TASK_UNINTERRUPTIBLE, true);\n}"
  },
  {
    "function_name": "page_endio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "1235-1256",
    "snippet": "void page_endio(struct page *page, bool is_write, int err)\n{\n\tif (!is_write) {\n\t\tif (!err) {\n\t\t\tSetPageUptodate(page);\n\t\t} else {\n\t\t\tClearPageUptodate(page);\n\t\t\tSetPageError(page);\n\t\t}\n\t\tunlock_page(page);\n\t} else {\n\t\tif (err) {\n\t\t\tstruct address_space *mapping;\n\n\t\t\tSetPageError(page);\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\tmapping_set_error(mapping, err);\n\t\t}\n\t\tend_page_writeback(page);\n\t}\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1209-1228",
          "snippet": "void end_page_writeback(struct page *page)\n{\n\t/*\n\t * TestClearPageReclaim could be used here but it is an atomic\n\t * operation and overkill in this particular case. Failing to\n\t * shuffle a page marked for immediate reclaim is too mild to\n\t * justify taking an atomic operation penalty at the end of\n\t * ever page writeback.\n\t */\n\tif (PageReclaim(page)) {\n\t\tClearPageReclaim(page);\n\t\trotate_reclaimable_page(page);\n\t}\n\n\tif (!test_clear_page_writeback(page))\n\t\tBUG();\n\n\tsmp_mb__after_atomic();\n\twake_up_page(page, PG_writeback);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid end_page_writeback(struct page *page)\n{\n\t/*\n\t * TestClearPageReclaim could be used here but it is an atomic\n\t * operation and overkill in this particular case. Failing to\n\t * shuffle a page marked for immediate reclaim is too mild to\n\t * justify taking an atomic operation penalty at the end of\n\t * ever page writeback.\n\t */\n\tif (PageReclaim(page)) {\n\t\tClearPageReclaim(page);\n\t\trotate_reclaimable_page(page);\n\t}\n\n\tif (!test_clear_page_writeback(page))\n\t\tBUG();\n\n\tsmp_mb__after_atomic();\n\twake_up_page(page, PG_writeback);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "mapping",
            "err"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1195-1202",
          "snippet": "void unlock_page(struct page *page)\n{\n\tBUILD_BUG_ON(PG_waiters != 7);\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (clear_bit_unlock_is_negative_byte(PG_locked, &page->flags))\n\t\twake_up_page_bit(page, PG_locked);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid unlock_page(struct page *page)\n{\n\tBUILD_BUG_ON(PG_waiters != 7);\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (clear_bit_unlock_is_negative_byte(PG_locked, &page->flags))\n\t\twake_up_page_bit(page, PG_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid page_endio(struct page *page, bool is_write, int err)\n{\n\tif (!is_write) {\n\t\tif (!err) {\n\t\t\tSetPageUptodate(page);\n\t\t} else {\n\t\t\tClearPageUptodate(page);\n\t\t\tSetPageError(page);\n\t\t}\n\t\tunlock_page(page);\n\t} else {\n\t\tif (err) {\n\t\t\tstruct address_space *mapping;\n\n\t\t\tSetPageError(page);\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\tmapping_set_error(mapping, err);\n\t\t}\n\t\tend_page_writeback(page);\n\t}\n}"
  },
  {
    "function_name": "end_page_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "1209-1228",
    "snippet": "void end_page_writeback(struct page *page)\n{\n\t/*\n\t * TestClearPageReclaim could be used here but it is an atomic\n\t * operation and overkill in this particular case. Failing to\n\t * shuffle a page marked for immediate reclaim is too mild to\n\t * justify taking an atomic operation penalty at the end of\n\t * ever page writeback.\n\t */\n\tif (PageReclaim(page)) {\n\t\tClearPageReclaim(page);\n\t\trotate_reclaimable_page(page);\n\t}\n\n\tif (!test_clear_page_writeback(page))\n\t\tBUG();\n\n\tsmp_mb__after_atomic();\n\twake_up_page(page, PG_writeback);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_page",
          "args": [
            "page",
            "PG_writeback"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1045-1050",
          "snippet": "static void wake_up_page(struct page *page, int bit)\n{\n\tif (!PageWaiters(page))\n\t\treturn;\n\twake_up_page_bit(page, bit);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic void wake_up_page(struct page *page, int bit)\n{\n\tif (!PageWaiters(page))\n\t\treturn;\n\twake_up_page_bit(page, bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_clear_page_writeback",
          "args": [
            "page"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "test_clear_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2695-2743",
          "snippet": "int test_clear_page_writeback(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\tint ret;\n\n\tmemcg = lock_page_memcg(page);\n\tlruvec = mem_cgroup_page_lruvec(page, page_pgdat(page));\n\tif (mapping && mapping_use_writeback_tags(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\t\tunsigned long flags;\n\n\t\txa_lock_irqsave(&mapping->i_pages, flags);\n\t\tret = TestClearPageWriteback(page);\n\t\tif (ret) {\n\t\t\t__xa_clear_mark(&mapping->i_pages, page_index(page),\n\t\t\t\t\t\tPAGECACHE_TAG_WRITEBACK);\n\t\t\tif (bdi_cap_account_writeback(bdi)) {\n\t\t\t\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\t\t\t\tdec_wb_stat(wb, WB_WRITEBACK);\n\t\t\t\t__wb_writeout_inc(wb);\n\t\t\t}\n\t\t}\n\n\t\tif (mapping->host && !mapping_tagged(mapping,\n\t\t\t\t\t\t     PAGECACHE_TAG_WRITEBACK))\n\t\t\tsb_clear_inode_writeback(mapping->host);\n\n\t\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\t} else {\n\t\tret = TestClearPageWriteback(page);\n\t}\n\t/*\n\t * NOTE: Page might be free now! Writeback doesn't hold a page\n\t * reference on its own, it relies on truncation to wait for\n\t * the clearing of PG_writeback. The below can only access\n\t * page state that is static across allocation cycles.\n\t */\n\tif (ret) {\n\t\tdec_lruvec_state(lruvec, NR_WRITEBACK);\n\t\tdec_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t\tinc_node_page_state(page, NR_WRITTEN);\n\t}\n\t__unlock_page_memcg(memcg);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint test_clear_page_writeback(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\tint ret;\n\n\tmemcg = lock_page_memcg(page);\n\tlruvec = mem_cgroup_page_lruvec(page, page_pgdat(page));\n\tif (mapping && mapping_use_writeback_tags(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\t\tunsigned long flags;\n\n\t\txa_lock_irqsave(&mapping->i_pages, flags);\n\t\tret = TestClearPageWriteback(page);\n\t\tif (ret) {\n\t\t\t__xa_clear_mark(&mapping->i_pages, page_index(page),\n\t\t\t\t\t\tPAGECACHE_TAG_WRITEBACK);\n\t\t\tif (bdi_cap_account_writeback(bdi)) {\n\t\t\t\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\t\t\t\tdec_wb_stat(wb, WB_WRITEBACK);\n\t\t\t\t__wb_writeout_inc(wb);\n\t\t\t}\n\t\t}\n\n\t\tif (mapping->host && !mapping_tagged(mapping,\n\t\t\t\t\t\t     PAGECACHE_TAG_WRITEBACK))\n\t\t\tsb_clear_inode_writeback(mapping->host);\n\n\t\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\t} else {\n\t\tret = TestClearPageWriteback(page);\n\t}\n\t/*\n\t * NOTE: Page might be free now! Writeback doesn't hold a page\n\t * reference on its own, it relies on truncation to wait for\n\t * the clearing of PG_writeback. The below can only access\n\t * page state that is static across allocation cycles.\n\t */\n\tif (ret) {\n\t\tdec_lruvec_state(lruvec, NR_WRITEBACK);\n\t\tdec_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t\tinc_node_page_state(page, NR_WRITTEN);\n\t}\n\t__unlock_page_memcg(memcg);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rotate_reclaimable_page",
          "args": [
            "page"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "rotate_reclaimable_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "247-261",
          "snippet": "void rotate_reclaimable_page(struct page *page)\n{\n\tif (!PageLocked(page) && !PageDirty(page) &&\n\t    !PageUnevictable(page) && PageLRU(page)) {\n\t\tstruct pagevec *pvec;\n\t\tunsigned long flags;\n\n\t\tget_page(page);\n\t\tlocal_irq_save(flags);\n\t\tpvec = this_cpu_ptr(&lru_rotate_pvecs);\n\t\tif (!pagevec_add(pvec, page) || PageCompound(page))\n\t\t\tpagevec_move_tail(pvec);\n\t\tlocal_irq_restore(flags);\n\t}\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\n\nvoid rotate_reclaimable_page(struct page *page)\n{\n\tif (!PageLocked(page) && !PageDirty(page) &&\n\t    !PageUnevictable(page) && PageLRU(page)) {\n\t\tstruct pagevec *pvec;\n\t\tunsigned long flags;\n\n\t\tget_page(page);\n\t\tlocal_irq_save(flags);\n\t\tpvec = this_cpu_ptr(&lru_rotate_pvecs);\n\t\tif (!pagevec_add(pvec, page) || PageCompound(page))\n\t\t\tpagevec_move_tail(pvec);\n\t\tlocal_irq_restore(flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageReclaim",
          "args": [
            "page"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageReclaim",
          "args": [
            "page"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid end_page_writeback(struct page *page)\n{\n\t/*\n\t * TestClearPageReclaim could be used here but it is an atomic\n\t * operation and overkill in this particular case. Failing to\n\t * shuffle a page marked for immediate reclaim is too mild to\n\t * justify taking an atomic operation penalty at the end of\n\t * ever page writeback.\n\t */\n\tif (PageReclaim(page)) {\n\t\tClearPageReclaim(page);\n\t\trotate_reclaimable_page(page);\n\t}\n\n\tif (!test_clear_page_writeback(page))\n\t\tBUG();\n\n\tsmp_mb__after_atomic();\n\twake_up_page(page, PG_writeback);\n}"
  },
  {
    "function_name": "unlock_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "1195-1202",
    "snippet": "void unlock_page(struct page *page)\n{\n\tBUILD_BUG_ON(PG_waiters != 7);\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (clear_bit_unlock_is_negative_byte(PG_locked, &page->flags))\n\t\twake_up_page_bit(page, PG_locked);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_page_bit",
          "args": [
            "page",
            "PG_locked"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_page_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "991-1043",
          "snippet": "static void wake_up_page_bit(struct page *page, int bit_nr)\n{\n\twait_queue_head_t *q = page_waitqueue(page);\n\tstruct wait_page_key key;\n\tunsigned long flags;\n\twait_queue_entry_t bookmark;\n\n\tkey.page = page;\n\tkey.bit_nr = bit_nr;\n\tkey.page_match = 0;\n\n\tbookmark.flags = 0;\n\tbookmark.private = NULL;\n\tbookmark.func = NULL;\n\tINIT_LIST_HEAD(&bookmark.entry);\n\n\tspin_lock_irqsave(&q->lock, flags);\n\t__wake_up_locked_key_bookmark(q, TASK_NORMAL, &key, &bookmark);\n\n\twhile (bookmark.flags & WQ_FLAG_BOOKMARK) {\n\t\t/*\n\t\t * Take a breather from holding the lock,\n\t\t * allow pages that finish wake up asynchronously\n\t\t * to acquire the lock and remove themselves\n\t\t * from wait queue\n\t\t */\n\t\tspin_unlock_irqrestore(&q->lock, flags);\n\t\tcpu_relax();\n\t\tspin_lock_irqsave(&q->lock, flags);\n\t\t__wake_up_locked_key_bookmark(q, TASK_NORMAL, &key, &bookmark);\n\t}\n\n\t/*\n\t * It is possible for other pages to have collided on the waitqueue\n\t * hash, so in that case check for a page match. That prevents a long-\n\t * term waiter\n\t *\n\t * It is still possible to miss a case here, when we woke page waiters\n\t * and removed them from the waitqueue, but there are still other\n\t * page waiters.\n\t */\n\tif (!waitqueue_active(q) || !key.page_match) {\n\t\tClearPageWaiters(page);\n\t\t/*\n\t\t * It's possible to miss clearing Waiters here, when we woke\n\t\t * our page waiters, but the hashed waitqueue has waiters for\n\t\t * other pages on it.\n\t\t *\n\t\t * That's okay, it's a rare case. The next waker will clear it.\n\t\t */\n\t}\n\tspin_unlock_irqrestore(&q->lock, flags);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic void wake_up_page_bit(struct page *page, int bit_nr)\n{\n\twait_queue_head_t *q = page_waitqueue(page);\n\tstruct wait_page_key key;\n\tunsigned long flags;\n\twait_queue_entry_t bookmark;\n\n\tkey.page = page;\n\tkey.bit_nr = bit_nr;\n\tkey.page_match = 0;\n\n\tbookmark.flags = 0;\n\tbookmark.private = NULL;\n\tbookmark.func = NULL;\n\tINIT_LIST_HEAD(&bookmark.entry);\n\n\tspin_lock_irqsave(&q->lock, flags);\n\t__wake_up_locked_key_bookmark(q, TASK_NORMAL, &key, &bookmark);\n\n\twhile (bookmark.flags & WQ_FLAG_BOOKMARK) {\n\t\t/*\n\t\t * Take a breather from holding the lock,\n\t\t * allow pages that finish wake up asynchronously\n\t\t * to acquire the lock and remove themselves\n\t\t * from wait queue\n\t\t */\n\t\tspin_unlock_irqrestore(&q->lock, flags);\n\t\tcpu_relax();\n\t\tspin_lock_irqsave(&q->lock, flags);\n\t\t__wake_up_locked_key_bookmark(q, TASK_NORMAL, &key, &bookmark);\n\t}\n\n\t/*\n\t * It is possible for other pages to have collided on the waitqueue\n\t * hash, so in that case check for a page match. That prevents a long-\n\t * term waiter\n\t *\n\t * It is still possible to miss a case here, when we woke page waiters\n\t * and removed them from the waitqueue, but there are still other\n\t * page waiters.\n\t */\n\tif (!waitqueue_active(q) || !key.page_match) {\n\t\tClearPageWaiters(page);\n\t\t/*\n\t\t * It's possible to miss clearing Waiters here, when we woke\n\t\t * our page waiters, but the hashed waitqueue has waiters for\n\t\t * other pages on it.\n\t\t *\n\t\t * That's okay, it's a rare case. The next waker will clear it.\n\t\t */\n\t}\n\tspin_unlock_irqrestore(&q->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock_is_negative_byte",
          "args": [
            "PG_locked",
            "&page->flags"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "clear_bit_unlock_is_negative_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1171-1176",
          "snippet": "static inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "PG_waiters != 7"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid unlock_page(struct page *page)\n{\n\tBUILD_BUG_ON(PG_waiters != 7);\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (clear_bit_unlock_is_negative_byte(PG_locked, &page->flags))\n\t\twake_up_page_bit(page, PG_locked);\n}"
  },
  {
    "function_name": "clear_bit_unlock_is_negative_byte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "1171-1176",
    "snippet": "static inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "PG_waiters",
            "mem"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock",
          "args": [
            "nr",
            "mem"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "clear_bit_unlock_is_negative_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1171-1176",
          "snippet": "static inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}"
  },
  {
    "function_name": "add_page_wait_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "1145-1154",
    "snippet": "void add_page_wait_queue(struct page *page, wait_queue_entry_t *waiter)\n{\n\twait_queue_head_t *q = page_waitqueue(page);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&q->lock, flags);\n\t__add_wait_queue_entry_tail(q, waiter);\n\tSetPageWaiters(page);\n\tspin_unlock_irqrestore(&q->lock, flags);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&q->lock",
            "flags"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageWaiters",
          "args": [
            "page"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_wait_queue_entry_tail",
          "args": [
            "q",
            "waiter"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&q->lock",
            "flags"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_waitqueue",
          "args": [
            "page"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "page_waitqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "943-946",
          "snippet": "static wait_queue_head_t *page_waitqueue(struct page *page)\n{\n\treturn &page_wait_table[hash_ptr(page, PAGE_WAIT_TABLE_BITS)];\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define PAGE_WAIT_TABLE_BITS 8"
          ],
          "globals_used": [
            "static wait_queue_head_t page_wait_table[PAGE_WAIT_TABLE_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\n#define PAGE_WAIT_TABLE_BITS 8\n\nstatic wait_queue_head_t page_wait_table[PAGE_WAIT_TABLE_SIZE];\n\nstatic wait_queue_head_t *page_waitqueue(struct page *page)\n{\n\treturn &page_wait_table[hash_ptr(page, PAGE_WAIT_TABLE_BITS)];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid add_page_wait_queue(struct page *page, wait_queue_entry_t *waiter)\n{\n\twait_queue_head_t *q = page_waitqueue(page);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&q->lock, flags);\n\t__add_wait_queue_entry_tail(q, waiter);\n\tSetPageWaiters(page);\n\tspin_unlock_irqrestore(&q->lock, flags);\n}"
  },
  {
    "function_name": "wait_on_page_bit_killable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "1131-1135",
    "snippet": "int wait_on_page_bit_killable(struct page *page, int bit_nr)\n{\n\twait_queue_head_t *q = page_waitqueue(page);\n\treturn wait_on_page_bit_common(q, page, bit_nr, TASK_KILLABLE, false);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_page_bit_common",
          "args": [
            "q",
            "page",
            "bit_nr",
            "TASK_KILLABLE",
            "false"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "wait_on_page_bit_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1052-1122",
          "snippet": "static inline int wait_on_page_bit_common(wait_queue_head_t *q,\n\t\tstruct page *page, int bit_nr, int state, bool lock)\n{\n\tstruct wait_page_queue wait_page;\n\twait_queue_entry_t *wait = &wait_page.wait;\n\tbool thrashing = false;\n\tunsigned long pflags;\n\tint ret = 0;\n\n\tif (bit_nr == PG_locked &&\n\t    !PageUptodate(page) && PageWorkingset(page)) {\n\t\tif (!PageSwapBacked(page))\n\t\t\tdelayacct_thrashing_start();\n\t\tpsi_memstall_enter(&pflags);\n\t\tthrashing = true;\n\t}\n\n\tinit_wait(wait);\n\twait->flags = lock ? WQ_FLAG_EXCLUSIVE : 0;\n\twait->func = wake_page_function;\n\twait_page.page = page;\n\twait_page.bit_nr = bit_nr;\n\n\tfor (;;) {\n\t\tspin_lock_irq(&q->lock);\n\n\t\tif (likely(list_empty(&wait->entry))) {\n\t\t\t__add_wait_queue_entry_tail(q, wait);\n\t\t\tSetPageWaiters(page);\n\t\t}\n\n\t\tset_current_state(state);\n\n\t\tspin_unlock_irq(&q->lock);\n\n\t\tif (likely(test_bit(bit_nr, &page->flags))) {\n\t\t\tio_schedule();\n\t\t}\n\n\t\tif (lock) {\n\t\t\tif (!test_and_set_bit_lock(bit_nr, &page->flags))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (!test_bit(bit_nr, &page->flags))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(signal_pending_state(state, current))) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfinish_wait(q, wait);\n\n\tif (thrashing) {\n\t\tif (!PageSwapBacked(page))\n\t\t\tdelayacct_thrashing_end();\n\t\tpsi_memstall_leave(&pflags);\n\t}\n\n\t/*\n\t * A signal could leave PageWaiters set. Clearing it here if\n\t * !waitqueue_active would be possible (by open-coding finish_wait),\n\t * but still fail to catch it in the case of wait hash collision. We\n\t * already can fail to clear wait hash collision cases, so don't\n\t * bother with signals either.\n\t */\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline int wait_on_page_bit_common(wait_queue_head_t *q,\n\t\tstruct page *page, int bit_nr, int state, bool lock)\n{\n\tstruct wait_page_queue wait_page;\n\twait_queue_entry_t *wait = &wait_page.wait;\n\tbool thrashing = false;\n\tunsigned long pflags;\n\tint ret = 0;\n\n\tif (bit_nr == PG_locked &&\n\t    !PageUptodate(page) && PageWorkingset(page)) {\n\t\tif (!PageSwapBacked(page))\n\t\t\tdelayacct_thrashing_start();\n\t\tpsi_memstall_enter(&pflags);\n\t\tthrashing = true;\n\t}\n\n\tinit_wait(wait);\n\twait->flags = lock ? WQ_FLAG_EXCLUSIVE : 0;\n\twait->func = wake_page_function;\n\twait_page.page = page;\n\twait_page.bit_nr = bit_nr;\n\n\tfor (;;) {\n\t\tspin_lock_irq(&q->lock);\n\n\t\tif (likely(list_empty(&wait->entry))) {\n\t\t\t__add_wait_queue_entry_tail(q, wait);\n\t\t\tSetPageWaiters(page);\n\t\t}\n\n\t\tset_current_state(state);\n\n\t\tspin_unlock_irq(&q->lock);\n\n\t\tif (likely(test_bit(bit_nr, &page->flags))) {\n\t\t\tio_schedule();\n\t\t}\n\n\t\tif (lock) {\n\t\t\tif (!test_and_set_bit_lock(bit_nr, &page->flags))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (!test_bit(bit_nr, &page->flags))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(signal_pending_state(state, current))) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfinish_wait(q, wait);\n\n\tif (thrashing) {\n\t\tif (!PageSwapBacked(page))\n\t\t\tdelayacct_thrashing_end();\n\t\tpsi_memstall_leave(&pflags);\n\t}\n\n\t/*\n\t * A signal could leave PageWaiters set. Clearing it here if\n\t * !waitqueue_active would be possible (by open-coding finish_wait),\n\t * but still fail to catch it in the case of wait hash collision. We\n\t * already can fail to clear wait hash collision cases, so don't\n\t * bother with signals either.\n\t */\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_waitqueue",
          "args": [
            "page"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "page_waitqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "943-946",
          "snippet": "static wait_queue_head_t *page_waitqueue(struct page *page)\n{\n\treturn &page_wait_table[hash_ptr(page, PAGE_WAIT_TABLE_BITS)];\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define PAGE_WAIT_TABLE_BITS 8"
          ],
          "globals_used": [
            "static wait_queue_head_t page_wait_table[PAGE_WAIT_TABLE_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\n#define PAGE_WAIT_TABLE_BITS 8\n\nstatic wait_queue_head_t page_wait_table[PAGE_WAIT_TABLE_SIZE];\n\nstatic wait_queue_head_t *page_waitqueue(struct page *page)\n{\n\treturn &page_wait_table[hash_ptr(page, PAGE_WAIT_TABLE_BITS)];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint wait_on_page_bit_killable(struct page *page, int bit_nr)\n{\n\twait_queue_head_t *q = page_waitqueue(page);\n\treturn wait_on_page_bit_common(q, page, bit_nr, TASK_KILLABLE, false);\n}"
  },
  {
    "function_name": "wait_on_page_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "1124-1128",
    "snippet": "void wait_on_page_bit(struct page *page, int bit_nr)\n{\n\twait_queue_head_t *q = page_waitqueue(page);\n\twait_on_page_bit_common(q, page, bit_nr, TASK_UNINTERRUPTIBLE, false);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_page_bit_common",
          "args": [
            "q",
            "page",
            "bit_nr",
            "TASK_UNINTERRUPTIBLE",
            "false"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "wait_on_page_bit_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1052-1122",
          "snippet": "static inline int wait_on_page_bit_common(wait_queue_head_t *q,\n\t\tstruct page *page, int bit_nr, int state, bool lock)\n{\n\tstruct wait_page_queue wait_page;\n\twait_queue_entry_t *wait = &wait_page.wait;\n\tbool thrashing = false;\n\tunsigned long pflags;\n\tint ret = 0;\n\n\tif (bit_nr == PG_locked &&\n\t    !PageUptodate(page) && PageWorkingset(page)) {\n\t\tif (!PageSwapBacked(page))\n\t\t\tdelayacct_thrashing_start();\n\t\tpsi_memstall_enter(&pflags);\n\t\tthrashing = true;\n\t}\n\n\tinit_wait(wait);\n\twait->flags = lock ? WQ_FLAG_EXCLUSIVE : 0;\n\twait->func = wake_page_function;\n\twait_page.page = page;\n\twait_page.bit_nr = bit_nr;\n\n\tfor (;;) {\n\t\tspin_lock_irq(&q->lock);\n\n\t\tif (likely(list_empty(&wait->entry))) {\n\t\t\t__add_wait_queue_entry_tail(q, wait);\n\t\t\tSetPageWaiters(page);\n\t\t}\n\n\t\tset_current_state(state);\n\n\t\tspin_unlock_irq(&q->lock);\n\n\t\tif (likely(test_bit(bit_nr, &page->flags))) {\n\t\t\tio_schedule();\n\t\t}\n\n\t\tif (lock) {\n\t\t\tif (!test_and_set_bit_lock(bit_nr, &page->flags))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (!test_bit(bit_nr, &page->flags))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(signal_pending_state(state, current))) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfinish_wait(q, wait);\n\n\tif (thrashing) {\n\t\tif (!PageSwapBacked(page))\n\t\t\tdelayacct_thrashing_end();\n\t\tpsi_memstall_leave(&pflags);\n\t}\n\n\t/*\n\t * A signal could leave PageWaiters set. Clearing it here if\n\t * !waitqueue_active would be possible (by open-coding finish_wait),\n\t * but still fail to catch it in the case of wait hash collision. We\n\t * already can fail to clear wait hash collision cases, so don't\n\t * bother with signals either.\n\t */\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline int wait_on_page_bit_common(wait_queue_head_t *q,\n\t\tstruct page *page, int bit_nr, int state, bool lock)\n{\n\tstruct wait_page_queue wait_page;\n\twait_queue_entry_t *wait = &wait_page.wait;\n\tbool thrashing = false;\n\tunsigned long pflags;\n\tint ret = 0;\n\n\tif (bit_nr == PG_locked &&\n\t    !PageUptodate(page) && PageWorkingset(page)) {\n\t\tif (!PageSwapBacked(page))\n\t\t\tdelayacct_thrashing_start();\n\t\tpsi_memstall_enter(&pflags);\n\t\tthrashing = true;\n\t}\n\n\tinit_wait(wait);\n\twait->flags = lock ? WQ_FLAG_EXCLUSIVE : 0;\n\twait->func = wake_page_function;\n\twait_page.page = page;\n\twait_page.bit_nr = bit_nr;\n\n\tfor (;;) {\n\t\tspin_lock_irq(&q->lock);\n\n\t\tif (likely(list_empty(&wait->entry))) {\n\t\t\t__add_wait_queue_entry_tail(q, wait);\n\t\t\tSetPageWaiters(page);\n\t\t}\n\n\t\tset_current_state(state);\n\n\t\tspin_unlock_irq(&q->lock);\n\n\t\tif (likely(test_bit(bit_nr, &page->flags))) {\n\t\t\tio_schedule();\n\t\t}\n\n\t\tif (lock) {\n\t\t\tif (!test_and_set_bit_lock(bit_nr, &page->flags))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (!test_bit(bit_nr, &page->flags))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(signal_pending_state(state, current))) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfinish_wait(q, wait);\n\n\tif (thrashing) {\n\t\tif (!PageSwapBacked(page))\n\t\t\tdelayacct_thrashing_end();\n\t\tpsi_memstall_leave(&pflags);\n\t}\n\n\t/*\n\t * A signal could leave PageWaiters set. Clearing it here if\n\t * !waitqueue_active would be possible (by open-coding finish_wait),\n\t * but still fail to catch it in the case of wait hash collision. We\n\t * already can fail to clear wait hash collision cases, so don't\n\t * bother with signals either.\n\t */\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_waitqueue",
          "args": [
            "page"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "page_waitqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "943-946",
          "snippet": "static wait_queue_head_t *page_waitqueue(struct page *page)\n{\n\treturn &page_wait_table[hash_ptr(page, PAGE_WAIT_TABLE_BITS)];\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define PAGE_WAIT_TABLE_BITS 8"
          ],
          "globals_used": [
            "static wait_queue_head_t page_wait_table[PAGE_WAIT_TABLE_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\n#define PAGE_WAIT_TABLE_BITS 8\n\nstatic wait_queue_head_t page_wait_table[PAGE_WAIT_TABLE_SIZE];\n\nstatic wait_queue_head_t *page_waitqueue(struct page *page)\n{\n\treturn &page_wait_table[hash_ptr(page, PAGE_WAIT_TABLE_BITS)];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid wait_on_page_bit(struct page *page, int bit_nr)\n{\n\twait_queue_head_t *q = page_waitqueue(page);\n\twait_on_page_bit_common(q, page, bit_nr, TASK_UNINTERRUPTIBLE, false);\n}"
  },
  {
    "function_name": "wait_on_page_bit_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "1052-1122",
    "snippet": "static inline int wait_on_page_bit_common(wait_queue_head_t *q,\n\t\tstruct page *page, int bit_nr, int state, bool lock)\n{\n\tstruct wait_page_queue wait_page;\n\twait_queue_entry_t *wait = &wait_page.wait;\n\tbool thrashing = false;\n\tunsigned long pflags;\n\tint ret = 0;\n\n\tif (bit_nr == PG_locked &&\n\t    !PageUptodate(page) && PageWorkingset(page)) {\n\t\tif (!PageSwapBacked(page))\n\t\t\tdelayacct_thrashing_start();\n\t\tpsi_memstall_enter(&pflags);\n\t\tthrashing = true;\n\t}\n\n\tinit_wait(wait);\n\twait->flags = lock ? WQ_FLAG_EXCLUSIVE : 0;\n\twait->func = wake_page_function;\n\twait_page.page = page;\n\twait_page.bit_nr = bit_nr;\n\n\tfor (;;) {\n\t\tspin_lock_irq(&q->lock);\n\n\t\tif (likely(list_empty(&wait->entry))) {\n\t\t\t__add_wait_queue_entry_tail(q, wait);\n\t\t\tSetPageWaiters(page);\n\t\t}\n\n\t\tset_current_state(state);\n\n\t\tspin_unlock_irq(&q->lock);\n\n\t\tif (likely(test_bit(bit_nr, &page->flags))) {\n\t\t\tio_schedule();\n\t\t}\n\n\t\tif (lock) {\n\t\t\tif (!test_and_set_bit_lock(bit_nr, &page->flags))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (!test_bit(bit_nr, &page->flags))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(signal_pending_state(state, current))) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfinish_wait(q, wait);\n\n\tif (thrashing) {\n\t\tif (!PageSwapBacked(page))\n\t\t\tdelayacct_thrashing_end();\n\t\tpsi_memstall_leave(&pflags);\n\t}\n\n\t/*\n\t * A signal could leave PageWaiters set. Clearing it here if\n\t * !waitqueue_active would be possible (by open-coding finish_wait),\n\t * but still fail to catch it in the case of wait hash collision. We\n\t * already can fail to clear wait hash collision cases, so don't\n\t * bother with signals either.\n\t */\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "psi_memstall_leave",
          "args": [
            "&pflags"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delayacct_thrashing_end",
          "args": [],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapBacked",
          "args": [
            "page"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "q",
            "wait"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "signal_pending_state(state, current)"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending_state",
          "args": [
            "state",
            "current"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "bit_nr",
            "&page->flags"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit_lock",
          "args": [
            "bit_nr",
            "&page->flags"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_schedule",
          "args": [],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "test_bit(bit_nr, &page->flags)"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "bit_nr",
            "&page->flags"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&q->lock"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "state"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageWaiters",
          "args": [
            "page"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_wait_queue_entry_tail",
          "args": [
            "q",
            "wait"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "list_empty(&wait->entry)"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wait->entry"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&q->lock"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_wait",
          "args": [
            "wait"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psi_memstall_enter",
          "args": [
            "&pflags"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delayacct_thrashing_start",
          "args": [],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapBacked",
          "args": [
            "page"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWorkingset",
          "args": [
            "page"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline int wait_on_page_bit_common(wait_queue_head_t *q,\n\t\tstruct page *page, int bit_nr, int state, bool lock)\n{\n\tstruct wait_page_queue wait_page;\n\twait_queue_entry_t *wait = &wait_page.wait;\n\tbool thrashing = false;\n\tunsigned long pflags;\n\tint ret = 0;\n\n\tif (bit_nr == PG_locked &&\n\t    !PageUptodate(page) && PageWorkingset(page)) {\n\t\tif (!PageSwapBacked(page))\n\t\t\tdelayacct_thrashing_start();\n\t\tpsi_memstall_enter(&pflags);\n\t\tthrashing = true;\n\t}\n\n\tinit_wait(wait);\n\twait->flags = lock ? WQ_FLAG_EXCLUSIVE : 0;\n\twait->func = wake_page_function;\n\twait_page.page = page;\n\twait_page.bit_nr = bit_nr;\n\n\tfor (;;) {\n\t\tspin_lock_irq(&q->lock);\n\n\t\tif (likely(list_empty(&wait->entry))) {\n\t\t\t__add_wait_queue_entry_tail(q, wait);\n\t\t\tSetPageWaiters(page);\n\t\t}\n\n\t\tset_current_state(state);\n\n\t\tspin_unlock_irq(&q->lock);\n\n\t\tif (likely(test_bit(bit_nr, &page->flags))) {\n\t\t\tio_schedule();\n\t\t}\n\n\t\tif (lock) {\n\t\t\tif (!test_and_set_bit_lock(bit_nr, &page->flags))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (!test_bit(bit_nr, &page->flags))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(signal_pending_state(state, current))) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfinish_wait(q, wait);\n\n\tif (thrashing) {\n\t\tif (!PageSwapBacked(page))\n\t\t\tdelayacct_thrashing_end();\n\t\tpsi_memstall_leave(&pflags);\n\t}\n\n\t/*\n\t * A signal could leave PageWaiters set. Clearing it here if\n\t * !waitqueue_active would be possible (by open-coding finish_wait),\n\t * but still fail to catch it in the case of wait hash collision. We\n\t * already can fail to clear wait hash collision cases, so don't\n\t * bother with signals either.\n\t */\n\n\treturn ret;\n}"
  },
  {
    "function_name": "wake_up_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "1045-1050",
    "snippet": "static void wake_up_page(struct page *page, int bit)\n{\n\tif (!PageWaiters(page))\n\t\treturn;\n\twake_up_page_bit(page, bit);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_page_bit",
          "args": [
            "page",
            "bit"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_page_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "991-1043",
          "snippet": "static void wake_up_page_bit(struct page *page, int bit_nr)\n{\n\twait_queue_head_t *q = page_waitqueue(page);\n\tstruct wait_page_key key;\n\tunsigned long flags;\n\twait_queue_entry_t bookmark;\n\n\tkey.page = page;\n\tkey.bit_nr = bit_nr;\n\tkey.page_match = 0;\n\n\tbookmark.flags = 0;\n\tbookmark.private = NULL;\n\tbookmark.func = NULL;\n\tINIT_LIST_HEAD(&bookmark.entry);\n\n\tspin_lock_irqsave(&q->lock, flags);\n\t__wake_up_locked_key_bookmark(q, TASK_NORMAL, &key, &bookmark);\n\n\twhile (bookmark.flags & WQ_FLAG_BOOKMARK) {\n\t\t/*\n\t\t * Take a breather from holding the lock,\n\t\t * allow pages that finish wake up asynchronously\n\t\t * to acquire the lock and remove themselves\n\t\t * from wait queue\n\t\t */\n\t\tspin_unlock_irqrestore(&q->lock, flags);\n\t\tcpu_relax();\n\t\tspin_lock_irqsave(&q->lock, flags);\n\t\t__wake_up_locked_key_bookmark(q, TASK_NORMAL, &key, &bookmark);\n\t}\n\n\t/*\n\t * It is possible for other pages to have collided on the waitqueue\n\t * hash, so in that case check for a page match. That prevents a long-\n\t * term waiter\n\t *\n\t * It is still possible to miss a case here, when we woke page waiters\n\t * and removed them from the waitqueue, but there are still other\n\t * page waiters.\n\t */\n\tif (!waitqueue_active(q) || !key.page_match) {\n\t\tClearPageWaiters(page);\n\t\t/*\n\t\t * It's possible to miss clearing Waiters here, when we woke\n\t\t * our page waiters, but the hashed waitqueue has waiters for\n\t\t * other pages on it.\n\t\t *\n\t\t * That's okay, it's a rare case. The next waker will clear it.\n\t\t */\n\t}\n\tspin_unlock_irqrestore(&q->lock, flags);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic void wake_up_page_bit(struct page *page, int bit_nr)\n{\n\twait_queue_head_t *q = page_waitqueue(page);\n\tstruct wait_page_key key;\n\tunsigned long flags;\n\twait_queue_entry_t bookmark;\n\n\tkey.page = page;\n\tkey.bit_nr = bit_nr;\n\tkey.page_match = 0;\n\n\tbookmark.flags = 0;\n\tbookmark.private = NULL;\n\tbookmark.func = NULL;\n\tINIT_LIST_HEAD(&bookmark.entry);\n\n\tspin_lock_irqsave(&q->lock, flags);\n\t__wake_up_locked_key_bookmark(q, TASK_NORMAL, &key, &bookmark);\n\n\twhile (bookmark.flags & WQ_FLAG_BOOKMARK) {\n\t\t/*\n\t\t * Take a breather from holding the lock,\n\t\t * allow pages that finish wake up asynchronously\n\t\t * to acquire the lock and remove themselves\n\t\t * from wait queue\n\t\t */\n\t\tspin_unlock_irqrestore(&q->lock, flags);\n\t\tcpu_relax();\n\t\tspin_lock_irqsave(&q->lock, flags);\n\t\t__wake_up_locked_key_bookmark(q, TASK_NORMAL, &key, &bookmark);\n\t}\n\n\t/*\n\t * It is possible for other pages to have collided on the waitqueue\n\t * hash, so in that case check for a page match. That prevents a long-\n\t * term waiter\n\t *\n\t * It is still possible to miss a case here, when we woke page waiters\n\t * and removed them from the waitqueue, but there are still other\n\t * page waiters.\n\t */\n\tif (!waitqueue_active(q) || !key.page_match) {\n\t\tClearPageWaiters(page);\n\t\t/*\n\t\t * It's possible to miss clearing Waiters here, when we woke\n\t\t * our page waiters, but the hashed waitqueue has waiters for\n\t\t * other pages on it.\n\t\t *\n\t\t * That's okay, it's a rare case. The next waker will clear it.\n\t\t */\n\t}\n\tspin_unlock_irqrestore(&q->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageWaiters",
          "args": [
            "page"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic void wake_up_page(struct page *page, int bit)\n{\n\tif (!PageWaiters(page))\n\t\treturn;\n\twake_up_page_bit(page, bit);\n}"
  },
  {
    "function_name": "wake_up_page_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "991-1043",
    "snippet": "static void wake_up_page_bit(struct page *page, int bit_nr)\n{\n\twait_queue_head_t *q = page_waitqueue(page);\n\tstruct wait_page_key key;\n\tunsigned long flags;\n\twait_queue_entry_t bookmark;\n\n\tkey.page = page;\n\tkey.bit_nr = bit_nr;\n\tkey.page_match = 0;\n\n\tbookmark.flags = 0;\n\tbookmark.private = NULL;\n\tbookmark.func = NULL;\n\tINIT_LIST_HEAD(&bookmark.entry);\n\n\tspin_lock_irqsave(&q->lock, flags);\n\t__wake_up_locked_key_bookmark(q, TASK_NORMAL, &key, &bookmark);\n\n\twhile (bookmark.flags & WQ_FLAG_BOOKMARK) {\n\t\t/*\n\t\t * Take a breather from holding the lock,\n\t\t * allow pages that finish wake up asynchronously\n\t\t * to acquire the lock and remove themselves\n\t\t * from wait queue\n\t\t */\n\t\tspin_unlock_irqrestore(&q->lock, flags);\n\t\tcpu_relax();\n\t\tspin_lock_irqsave(&q->lock, flags);\n\t\t__wake_up_locked_key_bookmark(q, TASK_NORMAL, &key, &bookmark);\n\t}\n\n\t/*\n\t * It is possible for other pages to have collided on the waitqueue\n\t * hash, so in that case check for a page match. That prevents a long-\n\t * term waiter\n\t *\n\t * It is still possible to miss a case here, when we woke page waiters\n\t * and removed them from the waitqueue, but there are still other\n\t * page waiters.\n\t */\n\tif (!waitqueue_active(q) || !key.page_match) {\n\t\tClearPageWaiters(page);\n\t\t/*\n\t\t * It's possible to miss clearing Waiters here, when we woke\n\t\t * our page waiters, but the hashed waitqueue has waiters for\n\t\t * other pages on it.\n\t\t *\n\t\t * That's okay, it's a rare case. The next waker will clear it.\n\t\t */\n\t}\n\tspin_unlock_irqrestore(&q->lock, flags);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&q->lock",
            "flags"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageWaiters",
          "args": [
            "page"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "q"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wake_up_locked_key_bookmark",
          "args": [
            "q",
            "TASK_NORMAL",
            "&key",
            "&bookmark"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&q->lock",
            "flags"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&q->lock",
            "flags"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wake_up_locked_key_bookmark",
          "args": [
            "q",
            "TASK_NORMAL",
            "&key",
            "&bookmark"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&q->lock",
            "flags"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&bookmark.entry"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_waitqueue",
          "args": [
            "page"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "page_waitqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "943-946",
          "snippet": "static wait_queue_head_t *page_waitqueue(struct page *page)\n{\n\treturn &page_wait_table[hash_ptr(page, PAGE_WAIT_TABLE_BITS)];\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define PAGE_WAIT_TABLE_BITS 8"
          ],
          "globals_used": [
            "static wait_queue_head_t page_wait_table[PAGE_WAIT_TABLE_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\n#define PAGE_WAIT_TABLE_BITS 8\n\nstatic wait_queue_head_t page_wait_table[PAGE_WAIT_TABLE_SIZE];\n\nstatic wait_queue_head_t *page_waitqueue(struct page *page)\n{\n\treturn &page_wait_table[hash_ptr(page, PAGE_WAIT_TABLE_BITS)];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic void wake_up_page_bit(struct page *page, int bit_nr)\n{\n\twait_queue_head_t *q = page_waitqueue(page);\n\tstruct wait_page_key key;\n\tunsigned long flags;\n\twait_queue_entry_t bookmark;\n\n\tkey.page = page;\n\tkey.bit_nr = bit_nr;\n\tkey.page_match = 0;\n\n\tbookmark.flags = 0;\n\tbookmark.private = NULL;\n\tbookmark.func = NULL;\n\tINIT_LIST_HEAD(&bookmark.entry);\n\n\tspin_lock_irqsave(&q->lock, flags);\n\t__wake_up_locked_key_bookmark(q, TASK_NORMAL, &key, &bookmark);\n\n\twhile (bookmark.flags & WQ_FLAG_BOOKMARK) {\n\t\t/*\n\t\t * Take a breather from holding the lock,\n\t\t * allow pages that finish wake up asynchronously\n\t\t * to acquire the lock and remove themselves\n\t\t * from wait queue\n\t\t */\n\t\tspin_unlock_irqrestore(&q->lock, flags);\n\t\tcpu_relax();\n\t\tspin_lock_irqsave(&q->lock, flags);\n\t\t__wake_up_locked_key_bookmark(q, TASK_NORMAL, &key, &bookmark);\n\t}\n\n\t/*\n\t * It is possible for other pages to have collided on the waitqueue\n\t * hash, so in that case check for a page match. That prevents a long-\n\t * term waiter\n\t *\n\t * It is still possible to miss a case here, when we woke page waiters\n\t * and removed them from the waitqueue, but there are still other\n\t * page waiters.\n\t */\n\tif (!waitqueue_active(q) || !key.page_match) {\n\t\tClearPageWaiters(page);\n\t\t/*\n\t\t * It's possible to miss clearing Waiters here, when we woke\n\t\t * our page waiters, but the hashed waitqueue has waiters for\n\t\t * other pages on it.\n\t\t *\n\t\t * That's okay, it's a rare case. The next waker will clear it.\n\t\t */\n\t}\n\tspin_unlock_irqrestore(&q->lock, flags);\n}"
  },
  {
    "function_name": "wake_page_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "971-989",
    "snippet": "static int wake_page_function(wait_queue_entry_t *wait, unsigned mode, int sync, void *arg)\n{\n\tstruct wait_page_key *key = arg;\n\tstruct wait_page_queue *wait_page\n\t\t= container_of(wait, struct wait_page_queue, wait);\n\n\tif (wait_page->page != key->page)\n\t       return 0;\n\tkey->page_match = 1;\n\n\tif (wait_page->bit_nr != key->bit_nr)\n\t\treturn 0;\n\n\t/* Stop walking if it's locked */\n\tif (test_bit(key->bit_nr, &key->page->flags))\n\t\treturn -1;\n\n\treturn autoremove_wake_function(wait, mode, sync, key);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "autoremove_wake_function",
          "args": [
            "wait",
            "mode",
            "sync",
            "key"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "key->bit_nr",
            "&key->page->flags"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "wait",
            "structwait_page_queue",
            "wait"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic int wake_page_function(wait_queue_entry_t *wait, unsigned mode, int sync, void *arg)\n{\n\tstruct wait_page_key *key = arg;\n\tstruct wait_page_queue *wait_page\n\t\t= container_of(wait, struct wait_page_queue, wait);\n\n\tif (wait_page->page != key->page)\n\t       return 0;\n\tkey->page_match = 1;\n\n\tif (wait_page->bit_nr != key->bit_nr)\n\t\treturn 0;\n\n\t/* Stop walking if it's locked */\n\tif (test_bit(key->bit_nr, &key->page->flags))\n\t\treturn -1;\n\n\treturn autoremove_wake_function(wait, mode, sync, key);\n}"
  },
  {
    "function_name": "pagecache_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "948-956",
    "snippet": "void __init pagecache_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < PAGE_WAIT_TABLE_SIZE; i++)\n\t\tinit_waitqueue_head(&page_wait_table[i]);\n\n\tpage_writeback_init();\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define PAGE_WAIT_TABLE_SIZE (1 << PAGE_WAIT_TABLE_BITS)"
    ],
    "globals_used": [
      "static wait_queue_head_t page_wait_table[PAGE_WAIT_TABLE_SIZE]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_writeback_init",
          "args": [],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "page_writeback_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2076-2084",
          "snippet": "void __init page_writeback_init(void)\n{\n\tBUG_ON(wb_domain_init(&global_wb_domain, GFP_KERNEL));\n\n\tcpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"mm/writeback:online\",\n\t\t\t  page_writeback_cpu_online, NULL);\n\tcpuhp_setup_state(CPUHP_MM_WRITEBACK_DEAD, \"mm/writeback:dead\", NULL,\n\t\t\t  page_writeback_cpu_online);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct wb_domain global_wb_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct wb_domain global_wb_domain;\n\nvoid __init page_writeback_init(void)\n{\n\tBUG_ON(wb_domain_init(&global_wb_domain, GFP_KERNEL));\n\n\tcpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"mm/writeback:online\",\n\t\t\t  page_writeback_cpu_online, NULL);\n\tcpuhp_setup_state(CPUHP_MM_WRITEBACK_DEAD, \"mm/writeback:dead\", NULL,\n\t\t\t  page_writeback_cpu_online);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&page_wait_table[i]"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\n#define PAGE_WAIT_TABLE_SIZE (1 << PAGE_WAIT_TABLE_BITS)\n\nstatic wait_queue_head_t page_wait_table[PAGE_WAIT_TABLE_SIZE];\n\nvoid __init pagecache_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < PAGE_WAIT_TABLE_SIZE; i++)\n\t\tinit_waitqueue_head(&page_wait_table[i]);\n\n\tpage_writeback_init();\n}"
  },
  {
    "function_name": "page_waitqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "943-946",
    "snippet": "static wait_queue_head_t *page_waitqueue(struct page *page)\n{\n\treturn &page_wait_table[hash_ptr(page, PAGE_WAIT_TABLE_BITS)];\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define PAGE_WAIT_TABLE_BITS 8"
    ],
    "globals_used": [
      "static wait_queue_head_t page_wait_table[PAGE_WAIT_TABLE_SIZE]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_ptr",
          "args": [
            "page",
            "PAGE_WAIT_TABLE_BITS"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\n#define PAGE_WAIT_TABLE_BITS 8\n\nstatic wait_queue_head_t page_wait_table[PAGE_WAIT_TABLE_SIZE];\n\nstatic wait_queue_head_t *page_waitqueue(struct page *page)\n{\n\treturn &page_wait_table[hash_ptr(page, PAGE_WAIT_TABLE_BITS)];\n}"
  },
  {
    "function_name": "__page_cache_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "909-925",
    "snippet": "struct page *__page_cache_alloc(gfp_t gfp)\n{\n\tint n;\n\tstruct page *page;\n\n\tif (cpuset_do_page_mem_spread()) {\n\t\tunsigned int cpuset_mems_cookie;\n\t\tdo {\n\t\t\tcpuset_mems_cookie = read_mems_allowed_begin();\n\t\t\tn = cpuset_mem_spread_node();\n\t\t\tpage = __alloc_pages_node(n, gfp, 0);\n\t\t} while (!page && read_mems_allowed_retry(cpuset_mems_cookie));\n\n\t\treturn page;\n\t}\n\treturn alloc_pages(gfp, 0);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_pages",
          "args": [
            "gfp",
            "0"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_pages_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4594-4601",
          "snippet": "void *alloc_pages_exact(size_t size, gfp_t gfp_mask)\n{\n\tunsigned int order = get_order(size);\n\tunsigned long addr;\n\n\taddr = __get_free_pages(gfp_mask, order);\n\treturn make_alloc_exact(addr, order, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\n\nvoid *alloc_pages_exact(size_t size, gfp_t gfp_mask)\n{\n\tunsigned int order = get_order(size);\n\tunsigned long addr;\n\n\taddr = __get_free_pages(gfp_mask, order);\n\treturn make_alloc_exact(addr, order, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_mems_allowed_retry",
          "args": [
            "cpuset_mems_cookie"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__alloc_pages_node",
          "args": [
            "n",
            "gfp",
            "0"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuset_mem_spread_node",
          "args": [],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mems_allowed_begin",
          "args": [],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuset_do_page_mem_spread",
          "args": [],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstruct page *__page_cache_alloc(gfp_t gfp)\n{\n\tint n;\n\tstruct page *page;\n\n\tif (cpuset_do_page_mem_spread()) {\n\t\tunsigned int cpuset_mems_cookie;\n\t\tdo {\n\t\t\tcpuset_mems_cookie = read_mems_allowed_begin();\n\t\t\tn = cpuset_mem_spread_node();\n\t\t\tpage = __alloc_pages_node(n, gfp, 0);\n\t\t} while (!page && read_mems_allowed_retry(cpuset_mems_cookie));\n\n\t\treturn page;\n\t}\n\treturn alloc_pages(gfp, 0);\n}"
  },
  {
    "function_name": "add_to_page_cache_lru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "879-905",
    "snippet": "int add_to_page_cache_lru(struct page *page, struct address_space *mapping,\n\t\t\t\tpgoff_t offset, gfp_t gfp_mask)\n{\n\tvoid *shadow = NULL;\n\tint ret;\n\n\t__SetPageLocked(page);\n\tret = __add_to_page_cache_locked(page, mapping, offset,\n\t\t\t\t\t gfp_mask, &shadow);\n\tif (unlikely(ret))\n\t\t__ClearPageLocked(page);\n\telse {\n\t\t/*\n\t\t * The page might have been evicted from cache only\n\t\t * recently, in which case it should be activated like\n\t\t * any other repeatedly accessed page.\n\t\t * The exception is pages getting rewritten; evicting other\n\t\t * data from the working set, only to cache data that will\n\t\t * get overwritten with something else, is a waste of memory.\n\t\t */\n\t\tWARN_ON_ONCE(PageActive(page));\n\t\tif (!(gfp_mask & __GFP_WRITE) && shadow)\n\t\t\tworkingset_refault(page, shadow);\n\t\tlru_cache_add(page);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lru_cache_add",
          "args": [
            "page"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "lru_cache_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "441-446",
          "snippet": "void lru_cache_add(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageActive(page) && PageUnevictable(page), page);\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\t__lru_cache_add(page);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid lru_cache_add(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageActive(page) && PageUnevictable(page), page);\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\t__lru_cache_add(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "workingset_refault",
          "args": [
            "page",
            "shadow"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "workingset_refault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/workingset.c",
          "lines": "250-327",
          "snippet": "void workingset_refault(struct page *page, void *shadow)\n{\n\tunsigned long refault_distance;\n\tstruct pglist_data *pgdat;\n\tunsigned long active_file;\n\tstruct mem_cgroup *memcg;\n\tunsigned long eviction;\n\tstruct lruvec *lruvec;\n\tunsigned long refault;\n\tbool workingset;\n\tint memcgid;\n\n\tunpack_shadow(shadow, &memcgid, &pgdat, &eviction, &workingset);\n\n\trcu_read_lock();\n\t/*\n\t * Look up the memcg associated with the stored ID. It might\n\t * have been deleted since the page's eviction.\n\t *\n\t * Note that in rare events the ID could have been recycled\n\t * for a new cgroup that refaults a shared page. This is\n\t * impossible to tell from the available data. However, this\n\t * should be a rare and limited disturbance, and activations\n\t * are always speculative anyway. Ultimately, it's the aging\n\t * algorithm's job to shake out the minimum access frequency\n\t * for the active cache.\n\t *\n\t * XXX: On !CONFIG_MEMCG, this will always return NULL; it\n\t * would be better if the root_mem_cgroup existed in all\n\t * configurations instead.\n\t */\n\tmemcg = mem_cgroup_from_id(memcgid);\n\tif (!mem_cgroup_disabled() && !memcg)\n\t\tgoto out;\n\tlruvec = mem_cgroup_lruvec(pgdat, memcg);\n\trefault = atomic_long_read(&lruvec->inactive_age);\n\tactive_file = lruvec_lru_size(lruvec, LRU_ACTIVE_FILE, MAX_NR_ZONES);\n\n\t/*\n\t * Calculate the refault distance\n\t *\n\t * The unsigned subtraction here gives an accurate distance\n\t * across inactive_age overflows in most cases. There is a\n\t * special case: usually, shadow entries have a short lifetime\n\t * and are either refaulted or reclaimed along with the inode\n\t * before they get too old.  But it is not impossible for the\n\t * inactive_age to lap a shadow entry in the field, which can\n\t * then result in a false small refault distance, leading to a\n\t * false activation should this old entry actually refault\n\t * again.  However, earlier kernels used to deactivate\n\t * unconditionally with *every* reclaim invocation for the\n\t * longest time, so the occasional inappropriate activation\n\t * leading to pressure on the active list is not a problem.\n\t */\n\trefault_distance = (refault - eviction) & EVICTION_MASK;\n\n\tinc_lruvec_state(lruvec, WORKINGSET_REFAULT);\n\n\t/*\n\t * Compare the distance to the existing workingset size. We\n\t * don't act on pages that couldn't stay resident even if all\n\t * the memory was available to the page cache.\n\t */\n\tif (refault_distance > active_file)\n\t\tgoto out;\n\n\tSetPageActive(page);\n\tatomic_long_inc(&lruvec->inactive_age);\n\tinc_lruvec_state(lruvec, WORKINGSET_ACTIVATE);\n\n\t/* Page was active prior to eviction */\n\tif (workingset) {\n\t\tSetPageWorkingset(page);\n\t\tinc_lruvec_state(lruvec, WORKINGSET_RESTORE);\n\t}\nout:\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/memcontrol.h>"
          ],
          "macros_used": [
            "#define EVICTION_MASK\t(~0UL >> EVICTION_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/pagemap.h>\n#include <linux/shmem_fs.h>\n#include <linux/writeback.h>\n#include <linux/memcontrol.h>\n\n#define EVICTION_MASK\t(~0UL >> EVICTION_SHIFT)\n\nvoid workingset_refault(struct page *page, void *shadow)\n{\n\tunsigned long refault_distance;\n\tstruct pglist_data *pgdat;\n\tunsigned long active_file;\n\tstruct mem_cgroup *memcg;\n\tunsigned long eviction;\n\tstruct lruvec *lruvec;\n\tunsigned long refault;\n\tbool workingset;\n\tint memcgid;\n\n\tunpack_shadow(shadow, &memcgid, &pgdat, &eviction, &workingset);\n\n\trcu_read_lock();\n\t/*\n\t * Look up the memcg associated with the stored ID. It might\n\t * have been deleted since the page's eviction.\n\t *\n\t * Note that in rare events the ID could have been recycled\n\t * for a new cgroup that refaults a shared page. This is\n\t * impossible to tell from the available data. However, this\n\t * should be a rare and limited disturbance, and activations\n\t * are always speculative anyway. Ultimately, it's the aging\n\t * algorithm's job to shake out the minimum access frequency\n\t * for the active cache.\n\t *\n\t * XXX: On !CONFIG_MEMCG, this will always return NULL; it\n\t * would be better if the root_mem_cgroup existed in all\n\t * configurations instead.\n\t */\n\tmemcg = mem_cgroup_from_id(memcgid);\n\tif (!mem_cgroup_disabled() && !memcg)\n\t\tgoto out;\n\tlruvec = mem_cgroup_lruvec(pgdat, memcg);\n\trefault = atomic_long_read(&lruvec->inactive_age);\n\tactive_file = lruvec_lru_size(lruvec, LRU_ACTIVE_FILE, MAX_NR_ZONES);\n\n\t/*\n\t * Calculate the refault distance\n\t *\n\t * The unsigned subtraction here gives an accurate distance\n\t * across inactive_age overflows in most cases. There is a\n\t * special case: usually, shadow entries have a short lifetime\n\t * and are either refaulted or reclaimed along with the inode\n\t * before they get too old.  But it is not impossible for the\n\t * inactive_age to lap a shadow entry in the field, which can\n\t * then result in a false small refault distance, leading to a\n\t * false activation should this old entry actually refault\n\t * again.  However, earlier kernels used to deactivate\n\t * unconditionally with *every* reclaim invocation for the\n\t * longest time, so the occasional inappropriate activation\n\t * leading to pressure on the active list is not a problem.\n\t */\n\trefault_distance = (refault - eviction) & EVICTION_MASK;\n\n\tinc_lruvec_state(lruvec, WORKINGSET_REFAULT);\n\n\t/*\n\t * Compare the distance to the existing workingset size. We\n\t * don't act on pages that couldn't stay resident even if all\n\t * the memory was available to the page cache.\n\t */\n\tif (refault_distance > active_file)\n\t\tgoto out;\n\n\tSetPageActive(page);\n\tatomic_long_inc(&lruvec->inactive_age);\n\tinc_lruvec_state(lruvec, WORKINGSET_ACTIVATE);\n\n\t/* Page was active prior to eviction */\n\tif (workingset) {\n\t\tSetPageWorkingset(page);\n\t\tinc_lruvec_state(lruvec, WORKINGSET_RESTORE);\n\t}\nout:\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "PageActive(page)"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageActive",
          "args": [
            "page"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ClearPageLocked",
          "args": [
            "page"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_to_page_cache_locked",
          "args": [
            "page",
            "mapping",
            "offset",
            "gfp_mask",
            "&shadow"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "__add_to_page_cache_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "796-859",
          "snippet": "static int __add_to_page_cache_locked(struct page *page,\n\t\t\t\t      struct address_space *mapping,\n\t\t\t\t      pgoff_t offset, gfp_t gfp_mask,\n\t\t\t\t      void **shadowp)\n{\n\tXA_STATE(xas, &mapping->i_pages, offset);\n\tint huge = PageHuge(page);\n\tstruct mem_cgroup *memcg;\n\tint error;\n\tvoid *old;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(PageSwapBacked(page), page);\n\tmapping_set_update(&xas, mapping);\n\n\tif (!huge) {\n\t\terror = mem_cgroup_try_charge(page, current->mm,\n\t\t\t\t\t      gfp_mask, &memcg, false);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tget_page(page);\n\tpage->mapping = mapping;\n\tpage->index = offset;\n\n\tdo {\n\t\txas_lock_irq(&xas);\n\t\told = xas_load(&xas);\n\t\tif (old && !xa_is_value(old))\n\t\t\txas_set_err(&xas, -EEXIST);\n\t\txas_store(&xas, page);\n\t\tif (xas_error(&xas))\n\t\t\tgoto unlock;\n\n\t\tif (xa_is_value(old)) {\n\t\t\tmapping->nrexceptional--;\n\t\t\tif (shadowp)\n\t\t\t\t*shadowp = old;\n\t\t}\n\t\tmapping->nrpages++;\n\n\t\t/* hugetlb pages do not participate in page cache accounting */\n\t\tif (!huge)\n\t\t\t__inc_node_page_state(page, NR_FILE_PAGES);\nunlock:\n\t\txas_unlock_irq(&xas);\n\t} while (xas_nomem(&xas, gfp_mask & GFP_RECLAIM_MASK));\n\n\tif (xas_error(&xas))\n\t\tgoto error;\n\n\tif (!huge)\n\t\tmem_cgroup_commit_charge(page, memcg, false, false);\n\ttrace_mm_filemap_add_to_page_cache(page);\n\treturn 0;\nerror:\n\tpage->mapping = NULL;\n\t/* Leave page->index set: truncation relies upon it */\n\tif (!huge)\n\t\tmem_cgroup_cancel_charge(page, memcg, false);\n\tput_page(page);\n\treturn xas_error(&xas);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic int __add_to_page_cache_locked(struct page *page,\n\t\t\t\t      struct address_space *mapping,\n\t\t\t\t      pgoff_t offset, gfp_t gfp_mask,\n\t\t\t\t      void **shadowp)\n{\n\tXA_STATE(xas, &mapping->i_pages, offset);\n\tint huge = PageHuge(page);\n\tstruct mem_cgroup *memcg;\n\tint error;\n\tvoid *old;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(PageSwapBacked(page), page);\n\tmapping_set_update(&xas, mapping);\n\n\tif (!huge) {\n\t\terror = mem_cgroup_try_charge(page, current->mm,\n\t\t\t\t\t      gfp_mask, &memcg, false);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tget_page(page);\n\tpage->mapping = mapping;\n\tpage->index = offset;\n\n\tdo {\n\t\txas_lock_irq(&xas);\n\t\told = xas_load(&xas);\n\t\tif (old && !xa_is_value(old))\n\t\t\txas_set_err(&xas, -EEXIST);\n\t\txas_store(&xas, page);\n\t\tif (xas_error(&xas))\n\t\t\tgoto unlock;\n\n\t\tif (xa_is_value(old)) {\n\t\t\tmapping->nrexceptional--;\n\t\t\tif (shadowp)\n\t\t\t\t*shadowp = old;\n\t\t}\n\t\tmapping->nrpages++;\n\n\t\t/* hugetlb pages do not participate in page cache accounting */\n\t\tif (!huge)\n\t\t\t__inc_node_page_state(page, NR_FILE_PAGES);\nunlock:\n\t\txas_unlock_irq(&xas);\n\t} while (xas_nomem(&xas, gfp_mask & GFP_RECLAIM_MASK));\n\n\tif (xas_error(&xas))\n\t\tgoto error;\n\n\tif (!huge)\n\t\tmem_cgroup_commit_charge(page, memcg, false, false);\n\ttrace_mm_filemap_add_to_page_cache(page);\n\treturn 0;\nerror:\n\tpage->mapping = NULL;\n\t/* Leave page->index set: truncation relies upon it */\n\tif (!huge)\n\t\tmem_cgroup_cancel_charge(page, memcg, false);\n\tput_page(page);\n\treturn xas_error(&xas);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__SetPageLocked",
          "args": [
            "page"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint add_to_page_cache_lru(struct page *page, struct address_space *mapping,\n\t\t\t\tpgoff_t offset, gfp_t gfp_mask)\n{\n\tvoid *shadow = NULL;\n\tint ret;\n\n\t__SetPageLocked(page);\n\tret = __add_to_page_cache_locked(page, mapping, offset,\n\t\t\t\t\t gfp_mask, &shadow);\n\tif (unlikely(ret))\n\t\t__ClearPageLocked(page);\n\telse {\n\t\t/*\n\t\t * The page might have been evicted from cache only\n\t\t * recently, in which case it should be activated like\n\t\t * any other repeatedly accessed page.\n\t\t * The exception is pages getting rewritten; evicting other\n\t\t * data from the working set, only to cache data that will\n\t\t * get overwritten with something else, is a waste of memory.\n\t\t */\n\t\tWARN_ON_ONCE(PageActive(page));\n\t\tif (!(gfp_mask & __GFP_WRITE) && shadow)\n\t\t\tworkingset_refault(page, shadow);\n\t\tlru_cache_add(page);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "add_to_page_cache_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "871-876",
    "snippet": "int add_to_page_cache_locked(struct page *page, struct address_space *mapping,\n\t\tpgoff_t offset, gfp_t gfp_mask)\n{\n\treturn __add_to_page_cache_locked(page, mapping, offset,\n\t\t\t\t\t  gfp_mask, NULL);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__add_to_page_cache_locked",
          "args": [
            "page",
            "mapping",
            "offset",
            "gfp_mask",
            "NULL"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "__add_to_page_cache_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "796-859",
          "snippet": "static int __add_to_page_cache_locked(struct page *page,\n\t\t\t\t      struct address_space *mapping,\n\t\t\t\t      pgoff_t offset, gfp_t gfp_mask,\n\t\t\t\t      void **shadowp)\n{\n\tXA_STATE(xas, &mapping->i_pages, offset);\n\tint huge = PageHuge(page);\n\tstruct mem_cgroup *memcg;\n\tint error;\n\tvoid *old;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(PageSwapBacked(page), page);\n\tmapping_set_update(&xas, mapping);\n\n\tif (!huge) {\n\t\terror = mem_cgroup_try_charge(page, current->mm,\n\t\t\t\t\t      gfp_mask, &memcg, false);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tget_page(page);\n\tpage->mapping = mapping;\n\tpage->index = offset;\n\n\tdo {\n\t\txas_lock_irq(&xas);\n\t\told = xas_load(&xas);\n\t\tif (old && !xa_is_value(old))\n\t\t\txas_set_err(&xas, -EEXIST);\n\t\txas_store(&xas, page);\n\t\tif (xas_error(&xas))\n\t\t\tgoto unlock;\n\n\t\tif (xa_is_value(old)) {\n\t\t\tmapping->nrexceptional--;\n\t\t\tif (shadowp)\n\t\t\t\t*shadowp = old;\n\t\t}\n\t\tmapping->nrpages++;\n\n\t\t/* hugetlb pages do not participate in page cache accounting */\n\t\tif (!huge)\n\t\t\t__inc_node_page_state(page, NR_FILE_PAGES);\nunlock:\n\t\txas_unlock_irq(&xas);\n\t} while (xas_nomem(&xas, gfp_mask & GFP_RECLAIM_MASK));\n\n\tif (xas_error(&xas))\n\t\tgoto error;\n\n\tif (!huge)\n\t\tmem_cgroup_commit_charge(page, memcg, false, false);\n\ttrace_mm_filemap_add_to_page_cache(page);\n\treturn 0;\nerror:\n\tpage->mapping = NULL;\n\t/* Leave page->index set: truncation relies upon it */\n\tif (!huge)\n\t\tmem_cgroup_cancel_charge(page, memcg, false);\n\tput_page(page);\n\treturn xas_error(&xas);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic int __add_to_page_cache_locked(struct page *page,\n\t\t\t\t      struct address_space *mapping,\n\t\t\t\t      pgoff_t offset, gfp_t gfp_mask,\n\t\t\t\t      void **shadowp)\n{\n\tXA_STATE(xas, &mapping->i_pages, offset);\n\tint huge = PageHuge(page);\n\tstruct mem_cgroup *memcg;\n\tint error;\n\tvoid *old;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(PageSwapBacked(page), page);\n\tmapping_set_update(&xas, mapping);\n\n\tif (!huge) {\n\t\terror = mem_cgroup_try_charge(page, current->mm,\n\t\t\t\t\t      gfp_mask, &memcg, false);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tget_page(page);\n\tpage->mapping = mapping;\n\tpage->index = offset;\n\n\tdo {\n\t\txas_lock_irq(&xas);\n\t\told = xas_load(&xas);\n\t\tif (old && !xa_is_value(old))\n\t\t\txas_set_err(&xas, -EEXIST);\n\t\txas_store(&xas, page);\n\t\tif (xas_error(&xas))\n\t\t\tgoto unlock;\n\n\t\tif (xa_is_value(old)) {\n\t\t\tmapping->nrexceptional--;\n\t\t\tif (shadowp)\n\t\t\t\t*shadowp = old;\n\t\t}\n\t\tmapping->nrpages++;\n\n\t\t/* hugetlb pages do not participate in page cache accounting */\n\t\tif (!huge)\n\t\t\t__inc_node_page_state(page, NR_FILE_PAGES);\nunlock:\n\t\txas_unlock_irq(&xas);\n\t} while (xas_nomem(&xas, gfp_mask & GFP_RECLAIM_MASK));\n\n\tif (xas_error(&xas))\n\t\tgoto error;\n\n\tif (!huge)\n\t\tmem_cgroup_commit_charge(page, memcg, false, false);\n\ttrace_mm_filemap_add_to_page_cache(page);\n\treturn 0;\nerror:\n\tpage->mapping = NULL;\n\t/* Leave page->index set: truncation relies upon it */\n\tif (!huge)\n\t\tmem_cgroup_cancel_charge(page, memcg, false);\n\tput_page(page);\n\treturn xas_error(&xas);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint add_to_page_cache_locked(struct page *page, struct address_space *mapping,\n\t\tpgoff_t offset, gfp_t gfp_mask)\n{\n\treturn __add_to_page_cache_locked(page, mapping, offset,\n\t\t\t\t\t  gfp_mask, NULL);\n}"
  },
  {
    "function_name": "__add_to_page_cache_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "796-859",
    "snippet": "static int __add_to_page_cache_locked(struct page *page,\n\t\t\t\t      struct address_space *mapping,\n\t\t\t\t      pgoff_t offset, gfp_t gfp_mask,\n\t\t\t\t      void **shadowp)\n{\n\tXA_STATE(xas, &mapping->i_pages, offset);\n\tint huge = PageHuge(page);\n\tstruct mem_cgroup *memcg;\n\tint error;\n\tvoid *old;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(PageSwapBacked(page), page);\n\tmapping_set_update(&xas, mapping);\n\n\tif (!huge) {\n\t\terror = mem_cgroup_try_charge(page, current->mm,\n\t\t\t\t\t      gfp_mask, &memcg, false);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tget_page(page);\n\tpage->mapping = mapping;\n\tpage->index = offset;\n\n\tdo {\n\t\txas_lock_irq(&xas);\n\t\told = xas_load(&xas);\n\t\tif (old && !xa_is_value(old))\n\t\t\txas_set_err(&xas, -EEXIST);\n\t\txas_store(&xas, page);\n\t\tif (xas_error(&xas))\n\t\t\tgoto unlock;\n\n\t\tif (xa_is_value(old)) {\n\t\t\tmapping->nrexceptional--;\n\t\t\tif (shadowp)\n\t\t\t\t*shadowp = old;\n\t\t}\n\t\tmapping->nrpages++;\n\n\t\t/* hugetlb pages do not participate in page cache accounting */\n\t\tif (!huge)\n\t\t\t__inc_node_page_state(page, NR_FILE_PAGES);\nunlock:\n\t\txas_unlock_irq(&xas);\n\t} while (xas_nomem(&xas, gfp_mask & GFP_RECLAIM_MASK));\n\n\tif (xas_error(&xas))\n\t\tgoto error;\n\n\tif (!huge)\n\t\tmem_cgroup_commit_charge(page, memcg, false, false);\n\ttrace_mm_filemap_add_to_page_cache(page);\n\treturn 0;\nerror:\n\tpage->mapping = NULL;\n\t/* Leave page->index set: truncation relies upon it */\n\tif (!huge)\n\t\tmem_cgroup_cancel_charge(page, memcg, false);\n\tput_page(page);\n\treturn xas_error(&xas);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xas_error",
          "args": [
            "&xas"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_cancel_charge",
          "args": [
            "page",
            "memcg",
            "false"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_cancel_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5972-5988",
          "snippet": "void mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,\n\t\tbool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcancel_charge(memcg, nr_pages);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,\n\t\tbool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcancel_charge(memcg, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_mm_filemap_add_to_page_cache",
          "args": [
            "page"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_commit_charge",
          "args": [
            "page",
            "memcg",
            "false",
            "false"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_commit_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5928-5962",
          "snippet": "void mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t      bool lrucare, bool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_PAGE(!page->mapping, page);\n\tVM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcommit_charge(page, memcg, lrucare);\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(memcg, page, compound, nr_pages);\n\tmemcg_check_events(memcg, page);\n\tlocal_irq_enable();\n\n\tif (do_memsw_account() && PageSwapCache(page)) {\n\t\tswp_entry_t entry = { .val = page_private(page) };\n\t\t/*\n\t\t * The swap entry might not get freed for a long time,\n\t\t * let's not wait for it.  The page already received a\n\t\t * memory+swap charge, drop the swap entry duplicate.\n\t\t */\n\t\tmem_cgroup_uncharge_swap(entry, nr_pages);\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t      bool lrucare, bool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_PAGE(!page->mapping, page);\n\tVM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcommit_charge(page, memcg, lrucare);\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(memcg, page, compound, nr_pages);\n\tmemcg_check_events(memcg, page);\n\tlocal_irq_enable();\n\n\tif (do_memsw_account() && PageSwapCache(page)) {\n\t\tswp_entry_t entry = { .val = page_private(page) };\n\t\t/*\n\t\t * The swap entry might not get freed for a long time,\n\t\t * let's not wait for it.  The page already received a\n\t\t * memory+swap charge, drop the swap entry duplicate.\n\t\t */\n\t\tmem_cgroup_uncharge_swap(entry, nr_pages);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_error",
          "args": [
            "&xas"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_nomem",
          "args": [
            "&xas",
            "gfp_mask & GFP_RECLAIM_MASK"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__inc_node_page_state",
          "args": [
            "page",
            "NR_FILE_PAGES"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "__inc_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "416-419",
          "snippet": "void __inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__inc_node_state(page_pgdat(page), item);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__inc_node_state(page_pgdat(page), item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "old"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_error",
          "args": [
            "&xas"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_store",
          "args": [
            "&xas",
            "page"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_set_err",
          "args": [
            "&xas",
            "-EEXIST"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "old"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_load",
          "args": [
            "&xas"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "&xas"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_try_charge",
          "args": [
            "page",
            "current->mm",
            "gfp_mask",
            "&memcg",
            "false"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_try_charge_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5898-5909",
          "snippet": "int mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\tret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);\n\tmemcg = *memcgp;\n\tmem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nint mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\tret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);\n\tmemcg = *memcgp;\n\tmem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_set_update",
          "args": [
            "&xas",
            "mapping"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageSwapBacked(page)",
            "page"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapBacked",
          "args": [
            "page"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "offset"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic int __add_to_page_cache_locked(struct page *page,\n\t\t\t\t      struct address_space *mapping,\n\t\t\t\t      pgoff_t offset, gfp_t gfp_mask,\n\t\t\t\t      void **shadowp)\n{\n\tXA_STATE(xas, &mapping->i_pages, offset);\n\tint huge = PageHuge(page);\n\tstruct mem_cgroup *memcg;\n\tint error;\n\tvoid *old;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(PageSwapBacked(page), page);\n\tmapping_set_update(&xas, mapping);\n\n\tif (!huge) {\n\t\terror = mem_cgroup_try_charge(page, current->mm,\n\t\t\t\t\t      gfp_mask, &memcg, false);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tget_page(page);\n\tpage->mapping = mapping;\n\tpage->index = offset;\n\n\tdo {\n\t\txas_lock_irq(&xas);\n\t\told = xas_load(&xas);\n\t\tif (old && !xa_is_value(old))\n\t\t\txas_set_err(&xas, -EEXIST);\n\t\txas_store(&xas, page);\n\t\tif (xas_error(&xas))\n\t\t\tgoto unlock;\n\n\t\tif (xa_is_value(old)) {\n\t\t\tmapping->nrexceptional--;\n\t\t\tif (shadowp)\n\t\t\t\t*shadowp = old;\n\t\t}\n\t\tmapping->nrpages++;\n\n\t\t/* hugetlb pages do not participate in page cache accounting */\n\t\tif (!huge)\n\t\t\t__inc_node_page_state(page, NR_FILE_PAGES);\nunlock:\n\t\txas_unlock_irq(&xas);\n\t} while (xas_nomem(&xas, gfp_mask & GFP_RECLAIM_MASK));\n\n\tif (xas_error(&xas))\n\t\tgoto error;\n\n\tif (!huge)\n\t\tmem_cgroup_commit_charge(page, memcg, false, false);\n\ttrace_mm_filemap_add_to_page_cache(page);\n\treturn 0;\nerror:\n\tpage->mapping = NULL;\n\t/* Leave page->index set: truncation relies upon it */\n\tif (!huge)\n\t\tmem_cgroup_cancel_charge(page, memcg, false);\n\tput_page(page);\n\treturn xas_error(&xas);\n}"
  },
  {
    "function_name": "replace_page_cache_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "757-793",
    "snippet": "int replace_page_cache_page(struct page *old, struct page *new, gfp_t gfp_mask)\n{\n\tstruct address_space *mapping = old->mapping;\n\tvoid (*freepage)(struct page *) = mapping->a_ops->freepage;\n\tpgoff_t offset = old->index;\n\tXA_STATE(xas, &mapping->i_pages, offset);\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageLocked(old), old);\n\tVM_BUG_ON_PAGE(!PageLocked(new), new);\n\tVM_BUG_ON_PAGE(new->mapping, new);\n\n\tget_page(new);\n\tnew->mapping = mapping;\n\tnew->index = offset;\n\n\txas_lock_irqsave(&xas, flags);\n\txas_store(&xas, new);\n\n\told->mapping = NULL;\n\t/* hugetlb pages do not participate in page cache accounting. */\n\tif (!PageHuge(old))\n\t\t__dec_node_page_state(new, NR_FILE_PAGES);\n\tif (!PageHuge(new))\n\t\t__inc_node_page_state(new, NR_FILE_PAGES);\n\tif (PageSwapBacked(old))\n\t\t__dec_node_page_state(new, NR_SHMEM);\n\tif (PageSwapBacked(new))\n\t\t__inc_node_page_state(new, NR_SHMEM);\n\txas_unlock_irqrestore(&xas, flags);\n\tmem_cgroup_migrate(old, new);\n\tif (freepage)\n\t\tfreepage(old);\n\tput_page(old);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "old"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "freepage",
          "args": [
            "old"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_freepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1067-1163",
          "snippet": "static void isolate_freepages(struct compact_control *cc)\n{\n\tstruct zone *zone = cc->zone;\n\tstruct page *page;\n\tunsigned long block_start_pfn;\t/* start of current pageblock */\n\tunsigned long isolate_start_pfn; /* exact pfn we start at */\n\tunsigned long block_end_pfn;\t/* end of current pageblock */\n\tunsigned long low_pfn;\t     /* lowest pfn scanner is able to scan */\n\tstruct list_head *freelist = &cc->freepages;\n\n\t/*\n\t * Initialise the free scanner. The starting point is where we last\n\t * successfully isolated from, zone-cached value, or the end of the\n\t * zone when isolating for the first time. For looping we also need\n\t * this pfn aligned down to the pageblock boundary, because we do\n\t * block_start_pfn -= pageblock_nr_pages in the for loop.\n\t * For ending point, take care when isolating in last pageblock of a\n\t * a zone which ends in the middle of a pageblock.\n\t * The low boundary is the end of the pageblock the migration scanner\n\t * is using.\n\t */\n\tisolate_start_pfn = cc->free_pfn;\n\tblock_start_pfn = pageblock_start_pfn(cc->free_pfn);\n\tblock_end_pfn = min(block_start_pfn + pageblock_nr_pages,\n\t\t\t\t\t\tzone_end_pfn(zone));\n\tlow_pfn = pageblock_end_pfn(cc->migrate_pfn);\n\n\t/*\n\t * Isolate free pages until enough are available to migrate the\n\t * pages on cc->migratepages. We stop searching if the migrate\n\t * and free page scanners meet or enough free pages are isolated.\n\t */\n\tfor (; block_start_pfn >= low_pfn;\n\t\t\t\tblock_end_pfn = block_start_pfn,\n\t\t\t\tblock_start_pfn -= pageblock_nr_pages,\n\t\t\t\tisolate_start_pfn = block_start_pfn) {\n\t\t/*\n\t\t * This can iterate a massively long zone without finding any\n\t\t * suitable migration targets, so periodically check if we need\n\t\t * to schedule, or even abort async compaction.\n\t\t */\n\t\tif (!(block_start_pfn % (SWAP_CLUSTER_MAX * pageblock_nr_pages))\n\t\t\t\t\t\t&& compact_should_abort(cc))\n\t\t\tbreak;\n\n\t\tpage = pageblock_pfn_to_page(block_start_pfn, block_end_pfn,\n\t\t\t\t\t\t\t\t\tzone);\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\t/* Check the block is suitable for migration */\n\t\tif (!suitable_migration_target(cc, page))\n\t\t\tcontinue;\n\n\t\t/* If isolation recently failed, do not retry */\n\t\tif (!isolation_suitable(cc, page))\n\t\t\tcontinue;\n\n\t\t/* Found a block suitable for isolating free pages from. */\n\t\tisolate_freepages_block(cc, &isolate_start_pfn, block_end_pfn,\n\t\t\t\t\tfreelist, false);\n\n\t\t/*\n\t\t * If we isolated enough freepages, or aborted due to lock\n\t\t * contention, terminate.\n\t\t */\n\t\tif ((cc->nr_freepages >= cc->nr_migratepages)\n\t\t\t\t\t\t\t|| cc->contended) {\n\t\t\tif (isolate_start_pfn >= block_end_pfn) {\n\t\t\t\t/*\n\t\t\t\t * Restart at previous pageblock if more\n\t\t\t\t * freepages can be isolated next time.\n\t\t\t\t */\n\t\t\t\tisolate_start_pfn =\n\t\t\t\t\tblock_start_pfn - pageblock_nr_pages;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (isolate_start_pfn < block_end_pfn) {\n\t\t\t/*\n\t\t\t * If isolation failed early, do not continue\n\t\t\t * needlessly.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* __isolate_free_page() does not map the pages */\n\tmap_pages(freelist);\n\n\t/*\n\t * Record where the free scanner will restart next time. Either we\n\t * broke from the loop and set isolate_start_pfn based on the last\n\t * call to isolate_freepages_block(), or we met the migration scanner\n\t * and the loop terminated due to isolate_start_pfn < low_pfn\n\t */\n\tcc->free_pfn = isolate_start_pfn;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic void isolate_freepages(struct compact_control *cc)\n{\n\tstruct zone *zone = cc->zone;\n\tstruct page *page;\n\tunsigned long block_start_pfn;\t/* start of current pageblock */\n\tunsigned long isolate_start_pfn; /* exact pfn we start at */\n\tunsigned long block_end_pfn;\t/* end of current pageblock */\n\tunsigned long low_pfn;\t     /* lowest pfn scanner is able to scan */\n\tstruct list_head *freelist = &cc->freepages;\n\n\t/*\n\t * Initialise the free scanner. The starting point is where we last\n\t * successfully isolated from, zone-cached value, or the end of the\n\t * zone when isolating for the first time. For looping we also need\n\t * this pfn aligned down to the pageblock boundary, because we do\n\t * block_start_pfn -= pageblock_nr_pages in the for loop.\n\t * For ending point, take care when isolating in last pageblock of a\n\t * a zone which ends in the middle of a pageblock.\n\t * The low boundary is the end of the pageblock the migration scanner\n\t * is using.\n\t */\n\tisolate_start_pfn = cc->free_pfn;\n\tblock_start_pfn = pageblock_start_pfn(cc->free_pfn);\n\tblock_end_pfn = min(block_start_pfn + pageblock_nr_pages,\n\t\t\t\t\t\tzone_end_pfn(zone));\n\tlow_pfn = pageblock_end_pfn(cc->migrate_pfn);\n\n\t/*\n\t * Isolate free pages until enough are available to migrate the\n\t * pages on cc->migratepages. We stop searching if the migrate\n\t * and free page scanners meet or enough free pages are isolated.\n\t */\n\tfor (; block_start_pfn >= low_pfn;\n\t\t\t\tblock_end_pfn = block_start_pfn,\n\t\t\t\tblock_start_pfn -= pageblock_nr_pages,\n\t\t\t\tisolate_start_pfn = block_start_pfn) {\n\t\t/*\n\t\t * This can iterate a massively long zone without finding any\n\t\t * suitable migration targets, so periodically check if we need\n\t\t * to schedule, or even abort async compaction.\n\t\t */\n\t\tif (!(block_start_pfn % (SWAP_CLUSTER_MAX * pageblock_nr_pages))\n\t\t\t\t\t\t&& compact_should_abort(cc))\n\t\t\tbreak;\n\n\t\tpage = pageblock_pfn_to_page(block_start_pfn, block_end_pfn,\n\t\t\t\t\t\t\t\t\tzone);\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\t/* Check the block is suitable for migration */\n\t\tif (!suitable_migration_target(cc, page))\n\t\t\tcontinue;\n\n\t\t/* If isolation recently failed, do not retry */\n\t\tif (!isolation_suitable(cc, page))\n\t\t\tcontinue;\n\n\t\t/* Found a block suitable for isolating free pages from. */\n\t\tisolate_freepages_block(cc, &isolate_start_pfn, block_end_pfn,\n\t\t\t\t\tfreelist, false);\n\n\t\t/*\n\t\t * If we isolated enough freepages, or aborted due to lock\n\t\t * contention, terminate.\n\t\t */\n\t\tif ((cc->nr_freepages >= cc->nr_migratepages)\n\t\t\t\t\t\t\t|| cc->contended) {\n\t\t\tif (isolate_start_pfn >= block_end_pfn) {\n\t\t\t\t/*\n\t\t\t\t * Restart at previous pageblock if more\n\t\t\t\t * freepages can be isolated next time.\n\t\t\t\t */\n\t\t\t\tisolate_start_pfn =\n\t\t\t\t\tblock_start_pfn - pageblock_nr_pages;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (isolate_start_pfn < block_end_pfn) {\n\t\t\t/*\n\t\t\t * If isolation failed early, do not continue\n\t\t\t * needlessly.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* __isolate_free_page() does not map the pages */\n\tmap_pages(freelist);\n\n\t/*\n\t * Record where the free scanner will restart next time. Either we\n\t * broke from the loop and set isolate_start_pfn based on the last\n\t * call to isolate_freepages_block(), or we met the migration scanner\n\t * and the loop terminated due to isolate_start_pfn < low_pfn\n\t */\n\tcc->free_pfn = isolate_start_pfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_migrate",
          "args": [
            "old",
            "new"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_migrate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6155-6195",
          "snippet": "void mem_cgroup_migrate(struct page *oldpage, struct page *newpage)\n{\n\tstruct mem_cgroup *memcg;\n\tunsigned int nr_pages;\n\tbool compound;\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageLocked(oldpage), oldpage);\n\tVM_BUG_ON_PAGE(!PageLocked(newpage), newpage);\n\tVM_BUG_ON_PAGE(PageAnon(oldpage) != PageAnon(newpage), newpage);\n\tVM_BUG_ON_PAGE(PageTransHuge(oldpage) != PageTransHuge(newpage),\n\t\t       newpage);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\t/* Page cache replacement: new page already charged? */\n\tif (newpage->mem_cgroup)\n\t\treturn;\n\n\t/* Swapcache readahead pages can get replaced before being charged */\n\tmemcg = oldpage->mem_cgroup;\n\tif (!memcg)\n\t\treturn;\n\n\t/* Force-charge the new page. The old one will be freed soon */\n\tcompound = PageTransHuge(newpage);\n\tnr_pages = compound ? hpage_nr_pages(newpage) : 1;\n\n\tpage_counter_charge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_charge(&memcg->memsw, nr_pages);\n\tcss_get_many(&memcg->css, nr_pages);\n\n\tcommit_charge(newpage, memcg, false);\n\n\tlocal_irq_save(flags);\n\tmem_cgroup_charge_statistics(memcg, newpage, compound, nr_pages);\n\tmemcg_check_events(memcg, newpage);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_migrate(struct page *oldpage, struct page *newpage)\n{\n\tstruct mem_cgroup *memcg;\n\tunsigned int nr_pages;\n\tbool compound;\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageLocked(oldpage), oldpage);\n\tVM_BUG_ON_PAGE(!PageLocked(newpage), newpage);\n\tVM_BUG_ON_PAGE(PageAnon(oldpage) != PageAnon(newpage), newpage);\n\tVM_BUG_ON_PAGE(PageTransHuge(oldpage) != PageTransHuge(newpage),\n\t\t       newpage);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\t/* Page cache replacement: new page already charged? */\n\tif (newpage->mem_cgroup)\n\t\treturn;\n\n\t/* Swapcache readahead pages can get replaced before being charged */\n\tmemcg = oldpage->mem_cgroup;\n\tif (!memcg)\n\t\treturn;\n\n\t/* Force-charge the new page. The old one will be freed soon */\n\tcompound = PageTransHuge(newpage);\n\tnr_pages = compound ? hpage_nr_pages(newpage) : 1;\n\n\tpage_counter_charge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_charge(&memcg->memsw, nr_pages);\n\tcss_get_many(&memcg->css, nr_pages);\n\n\tcommit_charge(newpage, memcg, false);\n\n\tlocal_irq_save(flags);\n\tmem_cgroup_charge_statistics(memcg, newpage, compound, nr_pages);\n\tmemcg_check_events(memcg, newpage);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_unlock_irqrestore",
          "args": [
            "&xas",
            "flags"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__inc_node_page_state",
          "args": [
            "new",
            "NR_SHMEM"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "__inc_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "416-419",
          "snippet": "void __inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__inc_node_state(page_pgdat(page), item);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__inc_node_state(page_pgdat(page), item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageSwapBacked",
          "args": [
            "new"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dec_node_page_state",
          "args": [
            "new",
            "NR_SHMEM"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "__dec_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "460-463",
          "snippet": "void __dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__dec_node_state(page_pgdat(page), item);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__dec_node_state(page_pgdat(page), item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageSwapBacked",
          "args": [
            "old"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "new"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_store",
          "args": [
            "&xas",
            "new"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_lock_irqsave",
          "args": [
            "&xas",
            "flags"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "new"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "new->mapping",
            "new"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(new)",
            "new"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "new"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(old)",
            "old"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "old"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "offset"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint replace_page_cache_page(struct page *old, struct page *new, gfp_t gfp_mask)\n{\n\tstruct address_space *mapping = old->mapping;\n\tvoid (*freepage)(struct page *) = mapping->a_ops->freepage;\n\tpgoff_t offset = old->index;\n\tXA_STATE(xas, &mapping->i_pages, offset);\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageLocked(old), old);\n\tVM_BUG_ON_PAGE(!PageLocked(new), new);\n\tVM_BUG_ON_PAGE(new->mapping, new);\n\n\tget_page(new);\n\tnew->mapping = mapping;\n\tnew->index = offset;\n\n\txas_lock_irqsave(&xas, flags);\n\txas_store(&xas, new);\n\n\told->mapping = NULL;\n\t/* hugetlb pages do not participate in page cache accounting. */\n\tif (!PageHuge(old))\n\t\t__dec_node_page_state(new, NR_FILE_PAGES);\n\tif (!PageHuge(new))\n\t\t__inc_node_page_state(new, NR_FILE_PAGES);\n\tif (PageSwapBacked(old))\n\t\t__dec_node_page_state(new, NR_SHMEM);\n\tif (PageSwapBacked(new))\n\t\t__inc_node_page_state(new, NR_SHMEM);\n\txas_unlock_irqrestore(&xas, flags);\n\tmem_cgroup_migrate(old, new);\n\tif (freepage)\n\t\tfreepage(old);\n\tput_page(old);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "file_write_and_wait_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "724-740",
    "snippet": "int file_write_and_wait_range(struct file *file, loff_t lstart, loff_t lend)\n{\n\tint err = 0, err2;\n\tstruct address_space *mapping = file->f_mapping;\n\n\tif (mapping_needs_writeback(mapping)) {\n\t\terr = __filemap_fdatawrite_range(mapping, lstart, lend,\n\t\t\t\t\t\t WB_SYNC_ALL);\n\t\t/* See comment of filemap_write_and_wait() */\n\t\tif (err != -EIO)\n\t\t\t__filemap_fdatawait_range(mapping, lstart, lend);\n\t}\n\terr2 = file_check_and_advance_wb_err(file);\n\tif (!err)\n\t\terr = err2;\n\treturn err;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_check_and_advance_wb_err",
          "args": [
            "file"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "file_check_and_advance_wb_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "682-707",
          "snippet": "int file_check_and_advance_wb_err(struct file *file)\n{\n\tint err = 0;\n\terrseq_t old = READ_ONCE(file->f_wb_err);\n\tstruct address_space *mapping = file->f_mapping;\n\n\t/* Locklessly handle the common case where nothing has changed */\n\tif (errseq_check(&mapping->wb_err, old)) {\n\t\t/* Something changed, must use slow path */\n\t\tspin_lock(&file->f_lock);\n\t\told = file->f_wb_err;\n\t\terr = errseq_check_and_advance(&mapping->wb_err,\n\t\t\t\t\t\t&file->f_wb_err);\n\t\ttrace_file_check_and_advance_wb_err(file, old);\n\t\tspin_unlock(&file->f_lock);\n\t}\n\n\t/*\n\t * We're mostly using this function as a drop in replacement for\n\t * filemap_check_errors. Clear AS_EIO/AS_ENOSPC to emulate the effect\n\t * that the legacy code would have had on these flags.\n\t */\n\tclear_bit(AS_EIO, &mapping->flags);\n\tclear_bit(AS_ENOSPC, &mapping->flags);\n\treturn err;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint file_check_and_advance_wb_err(struct file *file)\n{\n\tint err = 0;\n\terrseq_t old = READ_ONCE(file->f_wb_err);\n\tstruct address_space *mapping = file->f_mapping;\n\n\t/* Locklessly handle the common case where nothing has changed */\n\tif (errseq_check(&mapping->wb_err, old)) {\n\t\t/* Something changed, must use slow path */\n\t\tspin_lock(&file->f_lock);\n\t\told = file->f_wb_err;\n\t\terr = errseq_check_and_advance(&mapping->wb_err,\n\t\t\t\t\t\t&file->f_wb_err);\n\t\ttrace_file_check_and_advance_wb_err(file, old);\n\t\tspin_unlock(&file->f_lock);\n\t}\n\n\t/*\n\t * We're mostly using this function as a drop in replacement for\n\t * filemap_check_errors. Clear AS_EIO/AS_ENOSPC to emulate the effect\n\t * that the legacy code would have had on these flags.\n\t */\n\tclear_bit(AS_EIO, &mapping->flags);\n\tclear_bit(AS_ENOSPC, &mapping->flags);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__filemap_fdatawait_range",
          "args": [
            "mapping",
            "lstart",
            "lend"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "__filemap_fdatawait_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "488-517",
          "snippet": "static void __filemap_fdatawait_range(struct address_space *mapping,\n\t\t\t\t     loff_t start_byte, loff_t end_byte)\n{\n\tpgoff_t index = start_byte >> PAGE_SHIFT;\n\tpgoff_t end = end_byte >> PAGE_SHIFT;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\n\tif (end_byte < start_byte)\n\t\treturn;\n\n\tpagevec_init(&pvec);\n\twhile (index <= end) {\n\t\tunsigned i;\n\n\t\tnr_pages = pagevec_lookup_range_tag(&pvec, mapping, &index,\n\t\t\t\tend, PAGECACHE_TAG_WRITEBACK);\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\twait_on_page_writeback(page);\n\t\t\tClearPageError(page);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic void __filemap_fdatawait_range(struct address_space *mapping,\n\t\t\t\t     loff_t start_byte, loff_t end_byte)\n{\n\tpgoff_t index = start_byte >> PAGE_SHIFT;\n\tpgoff_t end = end_byte >> PAGE_SHIFT;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\n\tif (end_byte < start_byte)\n\t\treturn;\n\n\tpagevec_init(&pvec);\n\twhile (index <= end) {\n\t\tunsigned i;\n\n\t\tnr_pages = pagevec_lookup_range_tag(&pvec, mapping, &index,\n\t\t\t\tend, PAGECACHE_TAG_WRITEBACK);\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\twait_on_page_writeback(page);\n\t\t\tClearPageError(page);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__filemap_fdatawrite_range",
          "args": [
            "mapping",
            "lstart",
            "lend",
            "WB_SYNC_ALL"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "__filemap_fdatawrite_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "396-414",
          "snippet": "int __filemap_fdatawrite_range(struct address_space *mapping, loff_t start,\n\t\t\t\tloff_t end, int sync_mode)\n{\n\tint ret;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = sync_mode,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.range_start = start,\n\t\t.range_end = end,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(mapping))\n\t\treturn 0;\n\n\twbc_attach_fdatawrite_inode(&wbc, mapping->host);\n\tret = do_writepages(mapping, &wbc);\n\twbc_detach_inode(&wbc);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint __filemap_fdatawrite_range(struct address_space *mapping, loff_t start,\n\t\t\t\tloff_t end, int sync_mode)\n{\n\tint ret;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = sync_mode,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.range_start = start,\n\t\t.range_end = end,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(mapping))\n\t\treturn 0;\n\n\twbc_attach_fdatawrite_inode(&wbc, mapping->host);\n\tret = do_writepages(mapping, &wbc);\n\twbc_detach_inode(&wbc);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_needs_writeback",
          "args": [
            "mapping"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "mapping_needs_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "583-587",
          "snippet": "static bool mapping_needs_writeback(struct address_space *mapping)\n{\n\treturn (!dax_mapping(mapping) && mapping->nrpages) ||\n\t    (dax_mapping(mapping) && mapping->nrexceptional);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic bool mapping_needs_writeback(struct address_space *mapping)\n{\n\treturn (!dax_mapping(mapping) && mapping->nrpages) ||\n\t    (dax_mapping(mapping) && mapping->nrexceptional);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint file_write_and_wait_range(struct file *file, loff_t lstart, loff_t lend)\n{\n\tint err = 0, err2;\n\tstruct address_space *mapping = file->f_mapping;\n\n\tif (mapping_needs_writeback(mapping)) {\n\t\terr = __filemap_fdatawrite_range(mapping, lstart, lend,\n\t\t\t\t\t\t WB_SYNC_ALL);\n\t\t/* See comment of filemap_write_and_wait() */\n\t\tif (err != -EIO)\n\t\t\t__filemap_fdatawait_range(mapping, lstart, lend);\n\t}\n\terr2 = file_check_and_advance_wb_err(file);\n\tif (!err)\n\t\terr = err2;\n\treturn err;\n}"
  },
  {
    "function_name": "file_check_and_advance_wb_err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "682-707",
    "snippet": "int file_check_and_advance_wb_err(struct file *file)\n{\n\tint err = 0;\n\terrseq_t old = READ_ONCE(file->f_wb_err);\n\tstruct address_space *mapping = file->f_mapping;\n\n\t/* Locklessly handle the common case where nothing has changed */\n\tif (errseq_check(&mapping->wb_err, old)) {\n\t\t/* Something changed, must use slow path */\n\t\tspin_lock(&file->f_lock);\n\t\told = file->f_wb_err;\n\t\terr = errseq_check_and_advance(&mapping->wb_err,\n\t\t\t\t\t\t&file->f_wb_err);\n\t\ttrace_file_check_and_advance_wb_err(file, old);\n\t\tspin_unlock(&file->f_lock);\n\t}\n\n\t/*\n\t * We're mostly using this function as a drop in replacement for\n\t * filemap_check_errors. Clear AS_EIO/AS_ENOSPC to emulate the effect\n\t * that the legacy code would have had on these flags.\n\t */\n\tclear_bit(AS_EIO, &mapping->flags);\n\tclear_bit(AS_ENOSPC, &mapping->flags);\n\treturn err;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "AS_ENOSPC",
            "&mapping->flags"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "clear_bit_unlock_is_negative_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1171-1176",
          "snippet": "static inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&file->f_lock"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_file_check_and_advance_wb_err",
          "args": [
            "file",
            "old"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errseq_check_and_advance",
          "args": [
            "&mapping->wb_err",
            "&file->f_wb_err"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&file->f_lock"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errseq_check",
          "args": [
            "&mapping->wb_err",
            "old"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "file->f_wb_err"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint file_check_and_advance_wb_err(struct file *file)\n{\n\tint err = 0;\n\terrseq_t old = READ_ONCE(file->f_wb_err);\n\tstruct address_space *mapping = file->f_mapping;\n\n\t/* Locklessly handle the common case where nothing has changed */\n\tif (errseq_check(&mapping->wb_err, old)) {\n\t\t/* Something changed, must use slow path */\n\t\tspin_lock(&file->f_lock);\n\t\told = file->f_wb_err;\n\t\terr = errseq_check_and_advance(&mapping->wb_err,\n\t\t\t\t\t\t&file->f_wb_err);\n\t\ttrace_file_check_and_advance_wb_err(file, old);\n\t\tspin_unlock(&file->f_lock);\n\t}\n\n\t/*\n\t * We're mostly using this function as a drop in replacement for\n\t * filemap_check_errors. Clear AS_EIO/AS_ENOSPC to emulate the effect\n\t * that the legacy code would have had on these flags.\n\t */\n\tclear_bit(AS_EIO, &mapping->flags);\n\tclear_bit(AS_ENOSPC, &mapping->flags);\n\treturn err;\n}"
  },
  {
    "function_name": "__filemap_set_wb_err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "652-657",
    "snippet": "void __filemap_set_wb_err(struct address_space *mapping, int err)\n{\n\terrseq_t eseq = errseq_set(&mapping->wb_err, err);\n\n\ttrace_filemap_set_wb_err(mapping, eseq);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_filemap_set_wb_err",
          "args": [
            "mapping",
            "eseq"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errseq_set",
          "args": [
            "&mapping->wb_err",
            "err"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid __filemap_set_wb_err(struct address_space *mapping, int err)\n{\n\terrseq_t eseq = errseq_set(&mapping->wb_err, err);\n\n\ttrace_filemap_set_wb_err(mapping, eseq);\n}"
  },
  {
    "function_name": "filemap_write_and_wait_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "627-649",
    "snippet": "int filemap_write_and_wait_range(struct address_space *mapping,\n\t\t\t\t loff_t lstart, loff_t lend)\n{\n\tint err = 0;\n\n\tif (mapping_needs_writeback(mapping)) {\n\t\terr = __filemap_fdatawrite_range(mapping, lstart, lend,\n\t\t\t\t\t\t WB_SYNC_ALL);\n\t\t/* See comment of filemap_write_and_wait() */\n\t\tif (err != -EIO) {\n\t\t\tint err2 = filemap_fdatawait_range(mapping,\n\t\t\t\t\t\tlstart, lend);\n\t\t\tif (!err)\n\t\t\t\terr = err2;\n\t\t} else {\n\t\t\t/* Clear any previously stored errors */\n\t\t\tfilemap_check_errors(mapping);\n\t\t}\n\t} else {\n\t\terr = filemap_check_errors(mapping);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filemap_check_errors",
          "args": [
            "mapping"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "filemap_check_errors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "357-368",
          "snippet": "int filemap_check_errors(struct address_space *mapping)\n{\n\tint ret = 0;\n\t/* Check for outstanding write errors */\n\tif (test_bit(AS_ENOSPC, &mapping->flags) &&\n\t    test_and_clear_bit(AS_ENOSPC, &mapping->flags))\n\t\tret = -ENOSPC;\n\tif (test_bit(AS_EIO, &mapping->flags) &&\n\t    test_and_clear_bit(AS_EIO, &mapping->flags))\n\t\tret = -EIO;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint filemap_check_errors(struct address_space *mapping)\n{\n\tint ret = 0;\n\t/* Check for outstanding write errors */\n\tif (test_bit(AS_ENOSPC, &mapping->flags) &&\n\t    test_and_clear_bit(AS_ENOSPC, &mapping->flags))\n\t\tret = -ENOSPC;\n\tif (test_bit(AS_EIO, &mapping->flags) &&\n\t    test_and_clear_bit(AS_EIO, &mapping->flags))\n\t\tret = -EIO;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fdatawait_range",
          "args": [
            "mapping",
            "lstart",
            "lend"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "filemap_fdatawait_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "533-538",
          "snippet": "int filemap_fdatawait_range(struct address_space *mapping, loff_t start_byte,\n\t\t\t    loff_t end_byte)\n{\n\t__filemap_fdatawait_range(mapping, start_byte, end_byte);\n\treturn filemap_check_errors(mapping);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint filemap_fdatawait_range(struct address_space *mapping, loff_t start_byte,\n\t\t\t    loff_t end_byte)\n{\n\t__filemap_fdatawait_range(mapping, start_byte, end_byte);\n\treturn filemap_check_errors(mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__filemap_fdatawrite_range",
          "args": [
            "mapping",
            "lstart",
            "lend",
            "WB_SYNC_ALL"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "__filemap_fdatawrite_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "396-414",
          "snippet": "int __filemap_fdatawrite_range(struct address_space *mapping, loff_t start,\n\t\t\t\tloff_t end, int sync_mode)\n{\n\tint ret;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = sync_mode,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.range_start = start,\n\t\t.range_end = end,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(mapping))\n\t\treturn 0;\n\n\twbc_attach_fdatawrite_inode(&wbc, mapping->host);\n\tret = do_writepages(mapping, &wbc);\n\twbc_detach_inode(&wbc);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint __filemap_fdatawrite_range(struct address_space *mapping, loff_t start,\n\t\t\t\tloff_t end, int sync_mode)\n{\n\tint ret;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = sync_mode,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.range_start = start,\n\t\t.range_end = end,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(mapping))\n\t\treturn 0;\n\n\twbc_attach_fdatawrite_inode(&wbc, mapping->host);\n\tret = do_writepages(mapping, &wbc);\n\twbc_detach_inode(&wbc);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_needs_writeback",
          "args": [
            "mapping"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "mapping_needs_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "583-587",
          "snippet": "static bool mapping_needs_writeback(struct address_space *mapping)\n{\n\treturn (!dax_mapping(mapping) && mapping->nrpages) ||\n\t    (dax_mapping(mapping) && mapping->nrexceptional);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic bool mapping_needs_writeback(struct address_space *mapping)\n{\n\treturn (!dax_mapping(mapping) && mapping->nrpages) ||\n\t    (dax_mapping(mapping) && mapping->nrexceptional);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint filemap_write_and_wait_range(struct address_space *mapping,\n\t\t\t\t loff_t lstart, loff_t lend)\n{\n\tint err = 0;\n\n\tif (mapping_needs_writeback(mapping)) {\n\t\terr = __filemap_fdatawrite_range(mapping, lstart, lend,\n\t\t\t\t\t\t WB_SYNC_ALL);\n\t\t/* See comment of filemap_write_and_wait() */\n\t\tif (err != -EIO) {\n\t\t\tint err2 = filemap_fdatawait_range(mapping,\n\t\t\t\t\t\tlstart, lend);\n\t\t\tif (!err)\n\t\t\t\terr = err2;\n\t\t} else {\n\t\t\t/* Clear any previously stored errors */\n\t\t\tfilemap_check_errors(mapping);\n\t\t}\n\t} else {\n\t\terr = filemap_check_errors(mapping);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "filemap_write_and_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "589-613",
    "snippet": "int filemap_write_and_wait(struct address_space *mapping)\n{\n\tint err = 0;\n\n\tif (mapping_needs_writeback(mapping)) {\n\t\terr = filemap_fdatawrite(mapping);\n\t\t/*\n\t\t * Even if the above returned error, the pages may be\n\t\t * written partially (e.g. -ENOSPC), so we wait for it.\n\t\t * But the -EIO is special case, it may indicate the worst\n\t\t * thing (e.g. bug) happened, so we avoid waiting for it.\n\t\t */\n\t\tif (err != -EIO) {\n\t\t\tint err2 = filemap_fdatawait(mapping);\n\t\t\tif (!err)\n\t\t\t\terr = err2;\n\t\t} else {\n\t\t\t/* Clear any previously stored errors */\n\t\t\tfilemap_check_errors(mapping);\n\t\t}\n\t} else {\n\t\terr = filemap_check_errors(mapping);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filemap_check_errors",
          "args": [
            "mapping"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "filemap_check_errors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "357-368",
          "snippet": "int filemap_check_errors(struct address_space *mapping)\n{\n\tint ret = 0;\n\t/* Check for outstanding write errors */\n\tif (test_bit(AS_ENOSPC, &mapping->flags) &&\n\t    test_and_clear_bit(AS_ENOSPC, &mapping->flags))\n\t\tret = -ENOSPC;\n\tif (test_bit(AS_EIO, &mapping->flags) &&\n\t    test_and_clear_bit(AS_EIO, &mapping->flags))\n\t\tret = -EIO;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint filemap_check_errors(struct address_space *mapping)\n{\n\tint ret = 0;\n\t/* Check for outstanding write errors */\n\tif (test_bit(AS_ENOSPC, &mapping->flags) &&\n\t    test_and_clear_bit(AS_ENOSPC, &mapping->flags))\n\t\tret = -ENOSPC;\n\tif (test_bit(AS_EIO, &mapping->flags) &&\n\t    test_and_clear_bit(AS_EIO, &mapping->flags))\n\t\tret = -EIO;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fdatawait",
          "args": [
            "mapping"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "filemap_fdatawait_keep_errors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "576-580",
          "snippet": "int filemap_fdatawait_keep_errors(struct address_space *mapping)\n{\n\t__filemap_fdatawait_range(mapping, 0, LLONG_MAX);\n\treturn filemap_check_and_keep_errors(mapping);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint filemap_fdatawait_keep_errors(struct address_space *mapping)\n{\n\t__filemap_fdatawait_range(mapping, 0, LLONG_MAX);\n\treturn filemap_check_and_keep_errors(mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fdatawrite",
          "args": [
            "mapping"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "filemap_fdatawrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "422-425",
          "snippet": "int filemap_fdatawrite(struct address_space *mapping)\n{\n\treturn __filemap_fdatawrite(mapping, WB_SYNC_ALL);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint filemap_fdatawrite(struct address_space *mapping)\n{\n\treturn __filemap_fdatawrite(mapping, WB_SYNC_ALL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_needs_writeback",
          "args": [
            "mapping"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "mapping_needs_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "583-587",
          "snippet": "static bool mapping_needs_writeback(struct address_space *mapping)\n{\n\treturn (!dax_mapping(mapping) && mapping->nrpages) ||\n\t    (dax_mapping(mapping) && mapping->nrexceptional);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic bool mapping_needs_writeback(struct address_space *mapping)\n{\n\treturn (!dax_mapping(mapping) && mapping->nrpages) ||\n\t    (dax_mapping(mapping) && mapping->nrexceptional);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint filemap_write_and_wait(struct address_space *mapping)\n{\n\tint err = 0;\n\n\tif (mapping_needs_writeback(mapping)) {\n\t\terr = filemap_fdatawrite(mapping);\n\t\t/*\n\t\t * Even if the above returned error, the pages may be\n\t\t * written partially (e.g. -ENOSPC), so we wait for it.\n\t\t * But the -EIO is special case, it may indicate the worst\n\t\t * thing (e.g. bug) happened, so we avoid waiting for it.\n\t\t */\n\t\tif (err != -EIO) {\n\t\t\tint err2 = filemap_fdatawait(mapping);\n\t\t\tif (!err)\n\t\t\t\terr = err2;\n\t\t} else {\n\t\t\t/* Clear any previously stored errors */\n\t\t\tfilemap_check_errors(mapping);\n\t\t}\n\t} else {\n\t\terr = filemap_check_errors(mapping);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "mapping_needs_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "583-587",
    "snippet": "static bool mapping_needs_writeback(struct address_space *mapping)\n{\n\treturn (!dax_mapping(mapping) && mapping->nrpages) ||\n\t    (dax_mapping(mapping) && mapping->nrexceptional);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dax_mapping",
          "args": [
            "mapping"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_mapping",
          "args": [
            "mapping"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic bool mapping_needs_writeback(struct address_space *mapping)\n{\n\treturn (!dax_mapping(mapping) && mapping->nrpages) ||\n\t    (dax_mapping(mapping) && mapping->nrexceptional);\n}"
  },
  {
    "function_name": "filemap_fdatawait_keep_errors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "576-580",
    "snippet": "int filemap_fdatawait_keep_errors(struct address_space *mapping)\n{\n\t__filemap_fdatawait_range(mapping, 0, LLONG_MAX);\n\treturn filemap_check_and_keep_errors(mapping);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filemap_check_and_keep_errors",
          "args": [
            "mapping"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "filemap_check_and_keep_errors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "371-379",
          "snippet": "static int filemap_check_and_keep_errors(struct address_space *mapping)\n{\n\t/* Check for outstanding write errors */\n\tif (test_bit(AS_EIO, &mapping->flags))\n\t\treturn -EIO;\n\tif (test_bit(AS_ENOSPC, &mapping->flags))\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic int filemap_check_and_keep_errors(struct address_space *mapping)\n{\n\t/* Check for outstanding write errors */\n\tif (test_bit(AS_EIO, &mapping->flags))\n\t\treturn -EIO;\n\tif (test_bit(AS_ENOSPC, &mapping->flags))\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__filemap_fdatawait_range",
          "args": [
            "mapping",
            "0",
            "LLONG_MAX"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "__filemap_fdatawait_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "488-517",
          "snippet": "static void __filemap_fdatawait_range(struct address_space *mapping,\n\t\t\t\t     loff_t start_byte, loff_t end_byte)\n{\n\tpgoff_t index = start_byte >> PAGE_SHIFT;\n\tpgoff_t end = end_byte >> PAGE_SHIFT;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\n\tif (end_byte < start_byte)\n\t\treturn;\n\n\tpagevec_init(&pvec);\n\twhile (index <= end) {\n\t\tunsigned i;\n\n\t\tnr_pages = pagevec_lookup_range_tag(&pvec, mapping, &index,\n\t\t\t\tend, PAGECACHE_TAG_WRITEBACK);\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\twait_on_page_writeback(page);\n\t\t\tClearPageError(page);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic void __filemap_fdatawait_range(struct address_space *mapping,\n\t\t\t\t     loff_t start_byte, loff_t end_byte)\n{\n\tpgoff_t index = start_byte >> PAGE_SHIFT;\n\tpgoff_t end = end_byte >> PAGE_SHIFT;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\n\tif (end_byte < start_byte)\n\t\treturn;\n\n\tpagevec_init(&pvec);\n\twhile (index <= end) {\n\t\tunsigned i;\n\n\t\tnr_pages = pagevec_lookup_range_tag(&pvec, mapping, &index,\n\t\t\t\tend, PAGECACHE_TAG_WRITEBACK);\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\twait_on_page_writeback(page);\n\t\t\tClearPageError(page);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint filemap_fdatawait_keep_errors(struct address_space *mapping)\n{\n\t__filemap_fdatawait_range(mapping, 0, LLONG_MAX);\n\treturn filemap_check_and_keep_errors(mapping);\n}"
  },
  {
    "function_name": "file_fdatawait_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "555-561",
    "snippet": "int file_fdatawait_range(struct file *file, loff_t start_byte, loff_t end_byte)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\n\t__filemap_fdatawait_range(mapping, start_byte, end_byte);\n\treturn file_check_and_advance_wb_err(file);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_check_and_advance_wb_err",
          "args": [
            "file"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "file_check_and_advance_wb_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "682-707",
          "snippet": "int file_check_and_advance_wb_err(struct file *file)\n{\n\tint err = 0;\n\terrseq_t old = READ_ONCE(file->f_wb_err);\n\tstruct address_space *mapping = file->f_mapping;\n\n\t/* Locklessly handle the common case where nothing has changed */\n\tif (errseq_check(&mapping->wb_err, old)) {\n\t\t/* Something changed, must use slow path */\n\t\tspin_lock(&file->f_lock);\n\t\told = file->f_wb_err;\n\t\terr = errseq_check_and_advance(&mapping->wb_err,\n\t\t\t\t\t\t&file->f_wb_err);\n\t\ttrace_file_check_and_advance_wb_err(file, old);\n\t\tspin_unlock(&file->f_lock);\n\t}\n\n\t/*\n\t * We're mostly using this function as a drop in replacement for\n\t * filemap_check_errors. Clear AS_EIO/AS_ENOSPC to emulate the effect\n\t * that the legacy code would have had on these flags.\n\t */\n\tclear_bit(AS_EIO, &mapping->flags);\n\tclear_bit(AS_ENOSPC, &mapping->flags);\n\treturn err;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint file_check_and_advance_wb_err(struct file *file)\n{\n\tint err = 0;\n\terrseq_t old = READ_ONCE(file->f_wb_err);\n\tstruct address_space *mapping = file->f_mapping;\n\n\t/* Locklessly handle the common case where nothing has changed */\n\tif (errseq_check(&mapping->wb_err, old)) {\n\t\t/* Something changed, must use slow path */\n\t\tspin_lock(&file->f_lock);\n\t\told = file->f_wb_err;\n\t\terr = errseq_check_and_advance(&mapping->wb_err,\n\t\t\t\t\t\t&file->f_wb_err);\n\t\ttrace_file_check_and_advance_wb_err(file, old);\n\t\tspin_unlock(&file->f_lock);\n\t}\n\n\t/*\n\t * We're mostly using this function as a drop in replacement for\n\t * filemap_check_errors. Clear AS_EIO/AS_ENOSPC to emulate the effect\n\t * that the legacy code would have had on these flags.\n\t */\n\tclear_bit(AS_EIO, &mapping->flags);\n\tclear_bit(AS_ENOSPC, &mapping->flags);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__filemap_fdatawait_range",
          "args": [
            "mapping",
            "start_byte",
            "end_byte"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "__filemap_fdatawait_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "488-517",
          "snippet": "static void __filemap_fdatawait_range(struct address_space *mapping,\n\t\t\t\t     loff_t start_byte, loff_t end_byte)\n{\n\tpgoff_t index = start_byte >> PAGE_SHIFT;\n\tpgoff_t end = end_byte >> PAGE_SHIFT;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\n\tif (end_byte < start_byte)\n\t\treturn;\n\n\tpagevec_init(&pvec);\n\twhile (index <= end) {\n\t\tunsigned i;\n\n\t\tnr_pages = pagevec_lookup_range_tag(&pvec, mapping, &index,\n\t\t\t\tend, PAGECACHE_TAG_WRITEBACK);\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\twait_on_page_writeback(page);\n\t\t\tClearPageError(page);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic void __filemap_fdatawait_range(struct address_space *mapping,\n\t\t\t\t     loff_t start_byte, loff_t end_byte)\n{\n\tpgoff_t index = start_byte >> PAGE_SHIFT;\n\tpgoff_t end = end_byte >> PAGE_SHIFT;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\n\tif (end_byte < start_byte)\n\t\treturn;\n\n\tpagevec_init(&pvec);\n\twhile (index <= end) {\n\t\tunsigned i;\n\n\t\tnr_pages = pagevec_lookup_range_tag(&pvec, mapping, &index,\n\t\t\t\tend, PAGECACHE_TAG_WRITEBACK);\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\twait_on_page_writeback(page);\n\t\t\tClearPageError(page);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint file_fdatawait_range(struct file *file, loff_t start_byte, loff_t end_byte)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\n\t__filemap_fdatawait_range(mapping, start_byte, end_byte);\n\treturn file_check_and_advance_wb_err(file);\n}"
  },
  {
    "function_name": "filemap_fdatawait_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "533-538",
    "snippet": "int filemap_fdatawait_range(struct address_space *mapping, loff_t start_byte,\n\t\t\t    loff_t end_byte)\n{\n\t__filemap_fdatawait_range(mapping, start_byte, end_byte);\n\treturn filemap_check_errors(mapping);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filemap_check_errors",
          "args": [
            "mapping"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "filemap_check_errors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "357-368",
          "snippet": "int filemap_check_errors(struct address_space *mapping)\n{\n\tint ret = 0;\n\t/* Check for outstanding write errors */\n\tif (test_bit(AS_ENOSPC, &mapping->flags) &&\n\t    test_and_clear_bit(AS_ENOSPC, &mapping->flags))\n\t\tret = -ENOSPC;\n\tif (test_bit(AS_EIO, &mapping->flags) &&\n\t    test_and_clear_bit(AS_EIO, &mapping->flags))\n\t\tret = -EIO;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint filemap_check_errors(struct address_space *mapping)\n{\n\tint ret = 0;\n\t/* Check for outstanding write errors */\n\tif (test_bit(AS_ENOSPC, &mapping->flags) &&\n\t    test_and_clear_bit(AS_ENOSPC, &mapping->flags))\n\t\tret = -ENOSPC;\n\tif (test_bit(AS_EIO, &mapping->flags) &&\n\t    test_and_clear_bit(AS_EIO, &mapping->flags))\n\t\tret = -EIO;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__filemap_fdatawait_range",
          "args": [
            "mapping",
            "start_byte",
            "end_byte"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "__filemap_fdatawait_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "488-517",
          "snippet": "static void __filemap_fdatawait_range(struct address_space *mapping,\n\t\t\t\t     loff_t start_byte, loff_t end_byte)\n{\n\tpgoff_t index = start_byte >> PAGE_SHIFT;\n\tpgoff_t end = end_byte >> PAGE_SHIFT;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\n\tif (end_byte < start_byte)\n\t\treturn;\n\n\tpagevec_init(&pvec);\n\twhile (index <= end) {\n\t\tunsigned i;\n\n\t\tnr_pages = pagevec_lookup_range_tag(&pvec, mapping, &index,\n\t\t\t\tend, PAGECACHE_TAG_WRITEBACK);\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\twait_on_page_writeback(page);\n\t\t\tClearPageError(page);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic void __filemap_fdatawait_range(struct address_space *mapping,\n\t\t\t\t     loff_t start_byte, loff_t end_byte)\n{\n\tpgoff_t index = start_byte >> PAGE_SHIFT;\n\tpgoff_t end = end_byte >> PAGE_SHIFT;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\n\tif (end_byte < start_byte)\n\t\treturn;\n\n\tpagevec_init(&pvec);\n\twhile (index <= end) {\n\t\tunsigned i;\n\n\t\tnr_pages = pagevec_lookup_range_tag(&pvec, mapping, &index,\n\t\t\t\tend, PAGECACHE_TAG_WRITEBACK);\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\twait_on_page_writeback(page);\n\t\t\tClearPageError(page);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint filemap_fdatawait_range(struct address_space *mapping, loff_t start_byte,\n\t\t\t    loff_t end_byte)\n{\n\t__filemap_fdatawait_range(mapping, start_byte, end_byte);\n\treturn filemap_check_errors(mapping);\n}"
  },
  {
    "function_name": "__filemap_fdatawait_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "488-517",
    "snippet": "static void __filemap_fdatawait_range(struct address_space *mapping,\n\t\t\t\t     loff_t start_byte, loff_t end_byte)\n{\n\tpgoff_t index = start_byte >> PAGE_SHIFT;\n\tpgoff_t end = end_byte >> PAGE_SHIFT;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\n\tif (end_byte < start_byte)\n\t\treturn;\n\n\tpagevec_init(&pvec);\n\twhile (index <= end) {\n\t\tunsigned i;\n\n\t\tnr_pages = pagevec_lookup_range_tag(&pvec, mapping, &index,\n\t\t\t\tend, PAGECACHE_TAG_WRITEBACK);\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\twait_on_page_writeback(page);\n\t\t\tClearPageError(page);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "__pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "805-813",
          "snippet": "void __pagevec_release(struct pagevec *pvec)\n{\n\tif (!pvec->percpu_pvec_drained) {\n\t\tlru_add_drain();\n\t\tpvec->percpu_pvec_drained = true;\n\t}\n\trelease_pages(pvec->pages, pagevec_count(pvec));\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid __pagevec_release(struct pagevec *pvec)\n{\n\tif (!pvec->percpu_pvec_drained) {\n\t\tlru_add_drain();\n\t\tpvec->percpu_pvec_drained = true;\n\t}\n\trelease_pages(pvec->pages, pagevec_count(pvec));\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageError",
          "args": [
            "page"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lookup_range_tag",
          "args": [
            "&pvec",
            "mapping",
            "&index",
            "end",
            "PAGECACHE_TAG_WRITEBACK"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "pagevec_lookup_range_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "1002-1009",
          "snippet": "unsigned pagevec_lookup_range_tag(struct pagevec *pvec,\n\t\tstruct address_space *mapping, pgoff_t *index, pgoff_t end,\n\t\txa_mark_t tag)\n{\n\tpvec->nr = find_get_pages_range_tag(mapping, index, end, tag,\n\t\t\t\t\tPAGEVEC_SIZE, pvec->pages);\n\treturn pagevec_count(pvec);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nunsigned pagevec_lookup_range_tag(struct pagevec *pvec,\n\t\tstruct address_space *mapping, pgoff_t *index, pgoff_t end,\n\t\txa_mark_t tag)\n{\n\tpvec->nr = find_get_pages_range_tag(mapping, index, end, tag,\n\t\t\t\t\tPAGEVEC_SIZE, pvec->pages);\n\treturn pagevec_count(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic void __filemap_fdatawait_range(struct address_space *mapping,\n\t\t\t\t     loff_t start_byte, loff_t end_byte)\n{\n\tpgoff_t index = start_byte >> PAGE_SHIFT;\n\tpgoff_t end = end_byte >> PAGE_SHIFT;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\n\tif (end_byte < start_byte)\n\t\treturn;\n\n\tpagevec_init(&pvec);\n\twhile (index <= end) {\n\t\tunsigned i;\n\n\t\tnr_pages = pagevec_lookup_range_tag(&pvec, mapping, &index,\n\t\t\t\tend, PAGECACHE_TAG_WRITEBACK);\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\twait_on_page_writeback(page);\n\t\t\tClearPageError(page);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}"
  },
  {
    "function_name": "filemap_range_has_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "457-485",
    "snippet": "bool filemap_range_has_page(struct address_space *mapping,\n\t\t\t   loff_t start_byte, loff_t end_byte)\n{\n\tstruct page *page;\n\tXA_STATE(xas, &mapping->i_pages, start_byte >> PAGE_SHIFT);\n\tpgoff_t max = end_byte >> PAGE_SHIFT;\n\n\tif (end_byte < start_byte)\n\t\treturn false;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tpage = xas_find(&xas, max);\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\t\t/* Shadow entries don't count */\n\t\tif (xa_is_value(page))\n\t\t\tcontinue;\n\t\t/*\n\t\t * We don't need to try to pin this page; we're about to\n\t\t * release the RCU lock anyway.  It is enough to know that\n\t\t * there was a page here recently.\n\t\t */\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn page != NULL;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "page"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_retry",
          "args": [
            "&xas",
            "page"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_find",
          "args": [
            "&xas",
            "max"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "start_byte >> PAGE_SHIFT"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nbool filemap_range_has_page(struct address_space *mapping,\n\t\t\t   loff_t start_byte, loff_t end_byte)\n{\n\tstruct page *page;\n\tXA_STATE(xas, &mapping->i_pages, start_byte >> PAGE_SHIFT);\n\tpgoff_t max = end_byte >> PAGE_SHIFT;\n\n\tif (end_byte < start_byte)\n\t\treturn false;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tpage = xas_find(&xas, max);\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\t\t/* Shadow entries don't count */\n\t\tif (xa_is_value(page))\n\t\t\tcontinue;\n\t\t/*\n\t\t * We don't need to try to pin this page; we're about to\n\t\t * release the RCU lock anyway.  It is enough to know that\n\t\t * there was a page here recently.\n\t\t */\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn page != NULL;\n}"
  },
  {
    "function_name": "filemap_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "442-445",
    "snippet": "int filemap_flush(struct address_space *mapping)\n{\n\treturn __filemap_fdatawrite(mapping, WB_SYNC_NONE);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__filemap_fdatawrite",
          "args": [
            "mapping",
            "WB_SYNC_NONE"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "__filemap_fdatawrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "416-420",
          "snippet": "static inline int __filemap_fdatawrite(struct address_space *mapping,\n\tint sync_mode)\n{\n\treturn __filemap_fdatawrite_range(mapping, 0, LLONG_MAX, sync_mode);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline int __filemap_fdatawrite(struct address_space *mapping,\n\tint sync_mode)\n{\n\treturn __filemap_fdatawrite_range(mapping, 0, LLONG_MAX, sync_mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint filemap_flush(struct address_space *mapping)\n{\n\treturn __filemap_fdatawrite(mapping, WB_SYNC_NONE);\n}"
  },
  {
    "function_name": "filemap_fdatawrite_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "428-432",
    "snippet": "int filemap_fdatawrite_range(struct address_space *mapping, loff_t start,\n\t\t\t\tloff_t end)\n{\n\treturn __filemap_fdatawrite_range(mapping, start, end, WB_SYNC_ALL);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__filemap_fdatawrite_range",
          "args": [
            "mapping",
            "start",
            "end",
            "WB_SYNC_ALL"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "__filemap_fdatawrite_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "396-414",
          "snippet": "int __filemap_fdatawrite_range(struct address_space *mapping, loff_t start,\n\t\t\t\tloff_t end, int sync_mode)\n{\n\tint ret;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = sync_mode,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.range_start = start,\n\t\t.range_end = end,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(mapping))\n\t\treturn 0;\n\n\twbc_attach_fdatawrite_inode(&wbc, mapping->host);\n\tret = do_writepages(mapping, &wbc);\n\twbc_detach_inode(&wbc);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint __filemap_fdatawrite_range(struct address_space *mapping, loff_t start,\n\t\t\t\tloff_t end, int sync_mode)\n{\n\tint ret;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = sync_mode,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.range_start = start,\n\t\t.range_end = end,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(mapping))\n\t\treturn 0;\n\n\twbc_attach_fdatawrite_inode(&wbc, mapping->host);\n\tret = do_writepages(mapping, &wbc);\n\twbc_detach_inode(&wbc);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint filemap_fdatawrite_range(struct address_space *mapping, loff_t start,\n\t\t\t\tloff_t end)\n{\n\treturn __filemap_fdatawrite_range(mapping, start, end, WB_SYNC_ALL);\n}"
  },
  {
    "function_name": "filemap_fdatawrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "422-425",
    "snippet": "int filemap_fdatawrite(struct address_space *mapping)\n{\n\treturn __filemap_fdatawrite(mapping, WB_SYNC_ALL);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__filemap_fdatawrite",
          "args": [
            "mapping",
            "WB_SYNC_ALL"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "__filemap_fdatawrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "416-420",
          "snippet": "static inline int __filemap_fdatawrite(struct address_space *mapping,\n\tint sync_mode)\n{\n\treturn __filemap_fdatawrite_range(mapping, 0, LLONG_MAX, sync_mode);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline int __filemap_fdatawrite(struct address_space *mapping,\n\tint sync_mode)\n{\n\treturn __filemap_fdatawrite_range(mapping, 0, LLONG_MAX, sync_mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint filemap_fdatawrite(struct address_space *mapping)\n{\n\treturn __filemap_fdatawrite(mapping, WB_SYNC_ALL);\n}"
  },
  {
    "function_name": "__filemap_fdatawrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "416-420",
    "snippet": "static inline int __filemap_fdatawrite(struct address_space *mapping,\n\tint sync_mode)\n{\n\treturn __filemap_fdatawrite_range(mapping, 0, LLONG_MAX, sync_mode);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__filemap_fdatawrite_range",
          "args": [
            "mapping",
            "0",
            "LLONG_MAX",
            "sync_mode"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "__filemap_fdatawrite_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "396-414",
          "snippet": "int __filemap_fdatawrite_range(struct address_space *mapping, loff_t start,\n\t\t\t\tloff_t end, int sync_mode)\n{\n\tint ret;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = sync_mode,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.range_start = start,\n\t\t.range_end = end,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(mapping))\n\t\treturn 0;\n\n\twbc_attach_fdatawrite_inode(&wbc, mapping->host);\n\tret = do_writepages(mapping, &wbc);\n\twbc_detach_inode(&wbc);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint __filemap_fdatawrite_range(struct address_space *mapping, loff_t start,\n\t\t\t\tloff_t end, int sync_mode)\n{\n\tint ret;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = sync_mode,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.range_start = start,\n\t\t.range_end = end,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(mapping))\n\t\treturn 0;\n\n\twbc_attach_fdatawrite_inode(&wbc, mapping->host);\n\tret = do_writepages(mapping, &wbc);\n\twbc_detach_inode(&wbc);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline int __filemap_fdatawrite(struct address_space *mapping,\n\tint sync_mode)\n{\n\treturn __filemap_fdatawrite_range(mapping, 0, LLONG_MAX, sync_mode);\n}"
  },
  {
    "function_name": "__filemap_fdatawrite_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "396-414",
    "snippet": "int __filemap_fdatawrite_range(struct address_space *mapping, loff_t start,\n\t\t\t\tloff_t end, int sync_mode)\n{\n\tint ret;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = sync_mode,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.range_start = start,\n\t\t.range_end = end,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(mapping))\n\t\treturn 0;\n\n\twbc_attach_fdatawrite_inode(&wbc, mapping->host);\n\tret = do_writepages(mapping, &wbc);\n\twbc_detach_inode(&wbc);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wbc_detach_inode",
          "args": [
            "&wbc"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_writepages",
          "args": [
            "mapping",
            "&wbc"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "do_writepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2320-2337",
          "snippet": "int do_writepages(struct address_space *mapping, struct writeback_control *wbc)\n{\n\tint ret;\n\n\tif (wbc->nr_to_write <= 0)\n\t\treturn 0;\n\twhile (1) {\n\t\tif (mapping->a_ops->writepages)\n\t\t\tret = mapping->a_ops->writepages(mapping, wbc);\n\t\telse\n\t\t\tret = generic_writepages(mapping, wbc);\n\t\tif ((ret != -ENOMEM) || (wbc->sync_mode != WB_SYNC_ALL))\n\t\t\tbreak;\n\t\tcond_resched();\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint do_writepages(struct address_space *mapping, struct writeback_control *wbc)\n{\n\tint ret;\n\n\tif (wbc->nr_to_write <= 0)\n\t\treturn 0;\n\twhile (1) {\n\t\tif (mapping->a_ops->writepages)\n\t\t\tret = mapping->a_ops->writepages(mapping, wbc);\n\t\telse\n\t\t\tret = generic_writepages(mapping, wbc);\n\t\tif ((ret != -ENOMEM) || (wbc->sync_mode != WB_SYNC_ALL))\n\t\t\tbreak;\n\t\tcond_resched();\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wbc_attach_fdatawrite_inode",
          "args": [
            "&wbc",
            "mapping->host"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_cap_writeback_dirty",
          "args": [
            "mapping"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint __filemap_fdatawrite_range(struct address_space *mapping, loff_t start,\n\t\t\t\tloff_t end, int sync_mode)\n{\n\tint ret;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = sync_mode,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.range_start = start,\n\t\t.range_end = end,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(mapping))\n\t\treturn 0;\n\n\twbc_attach_fdatawrite_inode(&wbc, mapping->host);\n\tret = do_writepages(mapping, &wbc);\n\twbc_detach_inode(&wbc);\n\treturn ret;\n}"
  },
  {
    "function_name": "filemap_check_and_keep_errors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "371-379",
    "snippet": "static int filemap_check_and_keep_errors(struct address_space *mapping)\n{\n\t/* Check for outstanding write errors */\n\tif (test_bit(AS_EIO, &mapping->flags))\n\t\treturn -EIO;\n\tif (test_bit(AS_ENOSPC, &mapping->flags))\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "AS_ENOSPC",
            "&mapping->flags"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "AS_EIO",
            "&mapping->flags"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic int filemap_check_and_keep_errors(struct address_space *mapping)\n{\n\t/* Check for outstanding write errors */\n\tif (test_bit(AS_EIO, &mapping->flags))\n\t\treturn -EIO;\n\tif (test_bit(AS_ENOSPC, &mapping->flags))\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
  },
  {
    "function_name": "filemap_check_errors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "357-368",
    "snippet": "int filemap_check_errors(struct address_space *mapping)\n{\n\tint ret = 0;\n\t/* Check for outstanding write errors */\n\tif (test_bit(AS_ENOSPC, &mapping->flags) &&\n\t    test_and_clear_bit(AS_ENOSPC, &mapping->flags))\n\t\tret = -ENOSPC;\n\tif (test_bit(AS_EIO, &mapping->flags) &&\n\t    test_and_clear_bit(AS_EIO, &mapping->flags))\n\t\tret = -EIO;\n\treturn ret;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "AS_EIO",
            "&mapping->flags"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "AS_EIO",
            "&mapping->flags"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "AS_ENOSPC",
            "&mapping->flags"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "AS_ENOSPC",
            "&mapping->flags"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint filemap_check_errors(struct address_space *mapping)\n{\n\tint ret = 0;\n\t/* Check for outstanding write errors */\n\tif (test_bit(AS_ENOSPC, &mapping->flags) &&\n\t    test_and_clear_bit(AS_ENOSPC, &mapping->flags))\n\t\tret = -ENOSPC;\n\tif (test_bit(AS_EIO, &mapping->flags) &&\n\t    test_and_clear_bit(AS_EIO, &mapping->flags))\n\t\tret = -EIO;\n\treturn ret;\n}"
  },
  {
    "function_name": "delete_from_page_cache_batch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "335-355",
    "snippet": "void delete_from_page_cache_batch(struct address_space *mapping,\n\t\t\t\t  struct pagevec *pvec)\n{\n\tint i;\n\tunsigned long flags;\n\n\tif (!pagevec_count(pvec))\n\t\treturn;\n\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\tfor (i = 0; i < pagevec_count(pvec); i++) {\n\t\ttrace_mm_filemap_delete_from_page_cache(pvec->pages[i]);\n\n\t\tunaccount_page_cache_page(mapping, pvec->pages[i]);\n\t}\n\tpage_cache_delete_batch(mapping, pvec);\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\n\tfor (i = 0; i < pagevec_count(pvec); i++)\n\t\tpage_cache_free_page(mapping, pvec->pages[i]);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_free_page",
          "args": [
            "mapping",
            "pvec->pages[i]"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "page_cache_free_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "237-252",
          "snippet": "static void page_cache_free_page(struct address_space *mapping,\n\t\t\t\tstruct page *page)\n{\n\tvoid (*freepage)(struct page *);\n\n\tfreepage = mapping->a_ops->freepage;\n\tif (freepage)\n\t\tfreepage(page);\n\n\tif (PageTransHuge(page) && !PageHuge(page)) {\n\t\tpage_ref_sub(page, HPAGE_PMD_NR);\n\t\tVM_BUG_ON_PAGE(page_count(page) <= 0, page);\n\t} else {\n\t\tput_page(page);\n\t}\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic void page_cache_free_page(struct address_space *mapping,\n\t\t\t\tstruct page *page)\n{\n\tvoid (*freepage)(struct page *);\n\n\tfreepage = mapping->a_ops->freepage;\n\tif (freepage)\n\t\tfreepage(page);\n\n\tif (PageTransHuge(page) && !PageHuge(page)) {\n\t\tpage_ref_sub(page, HPAGE_PMD_NR);\n\t\tVM_BUG_ON_PAGE(page_count(page) <= 0, page);\n\t} else {\n\t\tput_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "pvec"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_unlock_irqrestore",
          "args": [
            "&mapping->i_pages",
            "flags"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_delete_batch",
          "args": [
            "mapping",
            "pvec"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "page_cache_delete_batch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "290-333",
          "snippet": "static void page_cache_delete_batch(struct address_space *mapping,\n\t\t\t     struct pagevec *pvec)\n{\n\tXA_STATE(xas, &mapping->i_pages, pvec->pages[0]->index);\n\tint total_pages = 0;\n\tint i = 0, tail_pages = 0;\n\tstruct page *page;\n\n\tmapping_set_update(&xas, mapping);\n\txas_for_each(&xas, page, ULONG_MAX) {\n\t\tif (i >= pagevec_count(pvec) && !tail_pages)\n\t\t\tbreak;\n\t\tif (xa_is_value(page))\n\t\t\tcontinue;\n\t\tif (!tail_pages) {\n\t\t\t/*\n\t\t\t * Some page got inserted in our range? Skip it. We\n\t\t\t * have our pages locked so they are protected from\n\t\t\t * being removed.\n\t\t\t */\n\t\t\tif (page != pvec->pages[i]) {\n\t\t\t\tVM_BUG_ON_PAGE(page->index >\n\t\t\t\t\t\tpvec->pages[i]->index, page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tWARN_ON_ONCE(!PageLocked(page));\n\t\t\tif (PageTransHuge(page) && !PageHuge(page))\n\t\t\t\ttail_pages = HPAGE_PMD_NR - 1;\n\t\t\tpage->mapping = NULL;\n\t\t\t/*\n\t\t\t * Leave page->index set: truncation lookup relies\n\t\t\t * upon it\n\t\t\t */\n\t\t\ti++;\n\t\t} else {\n\t\t\tVM_BUG_ON_PAGE(page->index + HPAGE_PMD_NR - tail_pages\n\t\t\t\t\t!= pvec->pages[i]->index, page);\n\t\t\ttail_pages--;\n\t\t}\n\t\txas_store(&xas, NULL);\n\t\ttotal_pages++;\n\t}\n\tmapping->nrpages -= total_pages;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic void page_cache_delete_batch(struct address_space *mapping,\n\t\t\t     struct pagevec *pvec)\n{\n\tXA_STATE(xas, &mapping->i_pages, pvec->pages[0]->index);\n\tint total_pages = 0;\n\tint i = 0, tail_pages = 0;\n\tstruct page *page;\n\n\tmapping_set_update(&xas, mapping);\n\txas_for_each(&xas, page, ULONG_MAX) {\n\t\tif (i >= pagevec_count(pvec) && !tail_pages)\n\t\t\tbreak;\n\t\tif (xa_is_value(page))\n\t\t\tcontinue;\n\t\tif (!tail_pages) {\n\t\t\t/*\n\t\t\t * Some page got inserted in our range? Skip it. We\n\t\t\t * have our pages locked so they are protected from\n\t\t\t * being removed.\n\t\t\t */\n\t\t\tif (page != pvec->pages[i]) {\n\t\t\t\tVM_BUG_ON_PAGE(page->index >\n\t\t\t\t\t\tpvec->pages[i]->index, page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tWARN_ON_ONCE(!PageLocked(page));\n\t\t\tif (PageTransHuge(page) && !PageHuge(page))\n\t\t\t\ttail_pages = HPAGE_PMD_NR - 1;\n\t\t\tpage->mapping = NULL;\n\t\t\t/*\n\t\t\t * Leave page->index set: truncation lookup relies\n\t\t\t * upon it\n\t\t\t */\n\t\t\ti++;\n\t\t} else {\n\t\t\tVM_BUG_ON_PAGE(page->index + HPAGE_PMD_NR - tail_pages\n\t\t\t\t\t!= pvec->pages[i]->index, page);\n\t\t\ttail_pages--;\n\t\t}\n\t\txas_store(&xas, NULL);\n\t\ttotal_pages++;\n\t}\n\tmapping->nrpages -= total_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unaccount_page_cache_page",
          "args": [
            "mapping",
            "pvec->pages[i]"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "unaccount_page_cache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "153-220",
          "snippet": "static void unaccount_page_cache_page(struct address_space *mapping,\n\t\t\t\t      struct page *page)\n{\n\tint nr;\n\n\t/*\n\t * if we're uptodate, flush out into the cleancache, otherwise\n\t * invalidate any existing cleancache entries.  We can't leave\n\t * stale data around in the cleancache once our page is gone\n\t */\n\tif (PageUptodate(page) && PageMappedToDisk(page))\n\t\tcleancache_put_page(page);\n\telse\n\t\tcleancache_invalidate_page(mapping, page);\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(page_mapped(page), page);\n\tif (!IS_ENABLED(CONFIG_DEBUG_VM) && unlikely(page_mapped(page))) {\n\t\tint mapcount;\n\n\t\tpr_alert(\"BUG: Bad page cache in process %s  pfn:%05lx\\n\",\n\t\t\t current->comm, page_to_pfn(page));\n\t\tdump_page(page, \"still mapped when deleted\");\n\t\tdump_stack();\n\t\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n\n\t\tmapcount = page_mapcount(page);\n\t\tif (mapping_exiting(mapping) &&\n\t\t    page_count(page) >= mapcount + 2) {\n\t\t\t/*\n\t\t\t * All vmas have already been torn down, so it's\n\t\t\t * a good bet that actually the page is unmapped,\n\t\t\t * and we'd prefer not to leak it: if we're wrong,\n\t\t\t * some other bad page check should catch it later.\n\t\t\t */\n\t\t\tpage_mapcount_reset(page);\n\t\t\tpage_ref_sub(page, mapcount);\n\t\t}\n\t}\n\n\t/* hugetlb pages do not participate in page cache accounting. */\n\tif (PageHuge(page))\n\t\treturn;\n\n\tnr = hpage_nr_pages(page);\n\n\t__mod_node_page_state(page_pgdat(page), NR_FILE_PAGES, -nr);\n\tif (PageSwapBacked(page)) {\n\t\t__mod_node_page_state(page_pgdat(page), NR_SHMEM, -nr);\n\t\tif (PageTransHuge(page))\n\t\t\t__dec_node_page_state(page, NR_SHMEM_THPS);\n\t} else {\n\t\tVM_BUG_ON_PAGE(PageTransHuge(page), page);\n\t}\n\n\t/*\n\t * At this point page must be either written or cleaned by\n\t * truncate.  Dirty page here signals a bug and loss of\n\t * unwritten data.\n\t *\n\t * This fixes dirty accounting after removing the page entirely\n\t * but leaves PageDirty set: it has no effect for truncated\n\t * page and anyway will be cleared before returning page into\n\t * buddy allocator.\n\t */\n\tif (WARN_ON_ONCE(PageDirty(page)))\n\t\taccount_page_cleaned(page, mapping, inode_to_wb(mapping->host));\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic void unaccount_page_cache_page(struct address_space *mapping,\n\t\t\t\t      struct page *page)\n{\n\tint nr;\n\n\t/*\n\t * if we're uptodate, flush out into the cleancache, otherwise\n\t * invalidate any existing cleancache entries.  We can't leave\n\t * stale data around in the cleancache once our page is gone\n\t */\n\tif (PageUptodate(page) && PageMappedToDisk(page))\n\t\tcleancache_put_page(page);\n\telse\n\t\tcleancache_invalidate_page(mapping, page);\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(page_mapped(page), page);\n\tif (!IS_ENABLED(CONFIG_DEBUG_VM) && unlikely(page_mapped(page))) {\n\t\tint mapcount;\n\n\t\tpr_alert(\"BUG: Bad page cache in process %s  pfn:%05lx\\n\",\n\t\t\t current->comm, page_to_pfn(page));\n\t\tdump_page(page, \"still mapped when deleted\");\n\t\tdump_stack();\n\t\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n\n\t\tmapcount = page_mapcount(page);\n\t\tif (mapping_exiting(mapping) &&\n\t\t    page_count(page) >= mapcount + 2) {\n\t\t\t/*\n\t\t\t * All vmas have already been torn down, so it's\n\t\t\t * a good bet that actually the page is unmapped,\n\t\t\t * and we'd prefer not to leak it: if we're wrong,\n\t\t\t * some other bad page check should catch it later.\n\t\t\t */\n\t\t\tpage_mapcount_reset(page);\n\t\t\tpage_ref_sub(page, mapcount);\n\t\t}\n\t}\n\n\t/* hugetlb pages do not participate in page cache accounting. */\n\tif (PageHuge(page))\n\t\treturn;\n\n\tnr = hpage_nr_pages(page);\n\n\t__mod_node_page_state(page_pgdat(page), NR_FILE_PAGES, -nr);\n\tif (PageSwapBacked(page)) {\n\t\t__mod_node_page_state(page_pgdat(page), NR_SHMEM, -nr);\n\t\tif (PageTransHuge(page))\n\t\t\t__dec_node_page_state(page, NR_SHMEM_THPS);\n\t} else {\n\t\tVM_BUG_ON_PAGE(PageTransHuge(page), page);\n\t}\n\n\t/*\n\t * At this point page must be either written or cleaned by\n\t * truncate.  Dirty page here signals a bug and loss of\n\t * unwritten data.\n\t *\n\t * This fixes dirty accounting after removing the page entirely\n\t * but leaves PageDirty set: it has no effect for truncated\n\t * page and anyway will be cleared before returning page into\n\t * buddy allocator.\n\t */\n\tif (WARN_ON_ONCE(PageDirty(page)))\n\t\taccount_page_cleaned(page, mapping, inode_to_wb(mapping->host));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_mm_filemap_delete_from_page_cache",
          "args": [
            "pvec->pages[i]"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "pvec"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_lock_irqsave",
          "args": [
            "&mapping->i_pages",
            "flags"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "pvec"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid delete_from_page_cache_batch(struct address_space *mapping,\n\t\t\t\t  struct pagevec *pvec)\n{\n\tint i;\n\tunsigned long flags;\n\n\tif (!pagevec_count(pvec))\n\t\treturn;\n\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\tfor (i = 0; i < pagevec_count(pvec); i++) {\n\t\ttrace_mm_filemap_delete_from_page_cache(pvec->pages[i]);\n\n\t\tunaccount_page_cache_page(mapping, pvec->pages[i]);\n\t}\n\tpage_cache_delete_batch(mapping, pvec);\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\n\tfor (i = 0; i < pagevec_count(pvec); i++)\n\t\tpage_cache_free_page(mapping, pvec->pages[i]);\n}"
  },
  {
    "function_name": "page_cache_delete_batch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "290-333",
    "snippet": "static void page_cache_delete_batch(struct address_space *mapping,\n\t\t\t     struct pagevec *pvec)\n{\n\tXA_STATE(xas, &mapping->i_pages, pvec->pages[0]->index);\n\tint total_pages = 0;\n\tint i = 0, tail_pages = 0;\n\tstruct page *page;\n\n\tmapping_set_update(&xas, mapping);\n\txas_for_each(&xas, page, ULONG_MAX) {\n\t\tif (i >= pagevec_count(pvec) && !tail_pages)\n\t\t\tbreak;\n\t\tif (xa_is_value(page))\n\t\t\tcontinue;\n\t\tif (!tail_pages) {\n\t\t\t/*\n\t\t\t * Some page got inserted in our range? Skip it. We\n\t\t\t * have our pages locked so they are protected from\n\t\t\t * being removed.\n\t\t\t */\n\t\t\tif (page != pvec->pages[i]) {\n\t\t\t\tVM_BUG_ON_PAGE(page->index >\n\t\t\t\t\t\tpvec->pages[i]->index, page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tWARN_ON_ONCE(!PageLocked(page));\n\t\t\tif (PageTransHuge(page) && !PageHuge(page))\n\t\t\t\ttail_pages = HPAGE_PMD_NR - 1;\n\t\t\tpage->mapping = NULL;\n\t\t\t/*\n\t\t\t * Leave page->index set: truncation lookup relies\n\t\t\t * upon it\n\t\t\t */\n\t\t\ti++;\n\t\t} else {\n\t\t\tVM_BUG_ON_PAGE(page->index + HPAGE_PMD_NR - tail_pages\n\t\t\t\t\t!= pvec->pages[i]->index, page);\n\t\t\ttail_pages--;\n\t\t}\n\t\txas_store(&xas, NULL);\n\t\ttotal_pages++;\n\t}\n\tmapping->nrpages -= total_pages;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xas_store",
          "args": [
            "&xas",
            "NULL"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "page->index + HPAGE_PMD_NR - tail_pages\n\t\t\t\t\t!= pvec->pages[i]->index",
            "page"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "page->index >\n\t\t\t\t\t\tpvec->pages[i]->index",
            "page"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "page"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "pvec"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_for_each",
          "args": [
            "&xas",
            "page",
            "ULONG_MAX"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_update",
          "args": [
            "&xas",
            "mapping"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "pvec->pages[0]->index"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic void page_cache_delete_batch(struct address_space *mapping,\n\t\t\t     struct pagevec *pvec)\n{\n\tXA_STATE(xas, &mapping->i_pages, pvec->pages[0]->index);\n\tint total_pages = 0;\n\tint i = 0, tail_pages = 0;\n\tstruct page *page;\n\n\tmapping_set_update(&xas, mapping);\n\txas_for_each(&xas, page, ULONG_MAX) {\n\t\tif (i >= pagevec_count(pvec) && !tail_pages)\n\t\t\tbreak;\n\t\tif (xa_is_value(page))\n\t\t\tcontinue;\n\t\tif (!tail_pages) {\n\t\t\t/*\n\t\t\t * Some page got inserted in our range? Skip it. We\n\t\t\t * have our pages locked so they are protected from\n\t\t\t * being removed.\n\t\t\t */\n\t\t\tif (page != pvec->pages[i]) {\n\t\t\t\tVM_BUG_ON_PAGE(page->index >\n\t\t\t\t\t\tpvec->pages[i]->index, page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tWARN_ON_ONCE(!PageLocked(page));\n\t\t\tif (PageTransHuge(page) && !PageHuge(page))\n\t\t\t\ttail_pages = HPAGE_PMD_NR - 1;\n\t\t\tpage->mapping = NULL;\n\t\t\t/*\n\t\t\t * Leave page->index set: truncation lookup relies\n\t\t\t * upon it\n\t\t\t */\n\t\t\ti++;\n\t\t} else {\n\t\t\tVM_BUG_ON_PAGE(page->index + HPAGE_PMD_NR - tail_pages\n\t\t\t\t\t!= pvec->pages[i]->index, page);\n\t\t\ttail_pages--;\n\t\t}\n\t\txas_store(&xas, NULL);\n\t\ttotal_pages++;\n\t}\n\tmapping->nrpages -= total_pages;\n}"
  },
  {
    "function_name": "delete_from_page_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "262-273",
    "snippet": "void delete_from_page_cache(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tunsigned long flags;\n\n\tBUG_ON(!PageLocked(page));\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\t__delete_from_page_cache(page, NULL);\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\n\tpage_cache_free_page(mapping, page);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_free_page",
          "args": [
            "mapping",
            "page"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "page_cache_free_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "237-252",
          "snippet": "static void page_cache_free_page(struct address_space *mapping,\n\t\t\t\tstruct page *page)\n{\n\tvoid (*freepage)(struct page *);\n\n\tfreepage = mapping->a_ops->freepage;\n\tif (freepage)\n\t\tfreepage(page);\n\n\tif (PageTransHuge(page) && !PageHuge(page)) {\n\t\tpage_ref_sub(page, HPAGE_PMD_NR);\n\t\tVM_BUG_ON_PAGE(page_count(page) <= 0, page);\n\t} else {\n\t\tput_page(page);\n\t}\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic void page_cache_free_page(struct address_space *mapping,\n\t\t\t\tstruct page *page)\n{\n\tvoid (*freepage)(struct page *);\n\n\tfreepage = mapping->a_ops->freepage;\n\tif (freepage)\n\t\tfreepage(page);\n\n\tif (PageTransHuge(page) && !PageHuge(page)) {\n\t\tpage_ref_sub(page, HPAGE_PMD_NR);\n\t\tVM_BUG_ON_PAGE(page_count(page) <= 0, page);\n\t} else {\n\t\tput_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xa_unlock_irqrestore",
          "args": [
            "&mapping->i_pages",
            "flags"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__delete_from_page_cache",
          "args": [
            "page",
            "NULL"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "__delete_from_page_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "227-235",
          "snippet": "void __delete_from_page_cache(struct page *page, void *shadow)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\ttrace_mm_filemap_delete_from_page_cache(page);\n\n\tunaccount_page_cache_page(mapping, page);\n\tpage_cache_delete(mapping, page, shadow);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid __delete_from_page_cache(struct page *page, void *shadow)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\ttrace_mm_filemap_delete_from_page_cache(page);\n\n\tunaccount_page_cache_page(mapping, page);\n\tpage_cache_delete(mapping, page, shadow);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xa_lock_irqsave",
          "args": [
            "&mapping->i_pages",
            "flags"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid delete_from_page_cache(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tunsigned long flags;\n\n\tBUG_ON(!PageLocked(page));\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\t__delete_from_page_cache(page, NULL);\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n\n\tpage_cache_free_page(mapping, page);\n}"
  },
  {
    "function_name": "page_cache_free_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "237-252",
    "snippet": "static void page_cache_free_page(struct address_space *mapping,\n\t\t\t\tstruct page *page)\n{\n\tvoid (*freepage)(struct page *);\n\n\tfreepage = mapping->a_ops->freepage;\n\tif (freepage)\n\t\tfreepage(page);\n\n\tif (PageTransHuge(page) && !PageHuge(page)) {\n\t\tpage_ref_sub(page, HPAGE_PMD_NR);\n\t\tVM_BUG_ON_PAGE(page_count(page) <= 0, page);\n\t} else {\n\t\tput_page(page);\n\t}\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "page_count(page) <= 0",
            "page"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_sub",
          "args": [
            "page",
            "HPAGE_PMD_NR"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freepage",
          "args": [
            "page"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_freepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1067-1163",
          "snippet": "static void isolate_freepages(struct compact_control *cc)\n{\n\tstruct zone *zone = cc->zone;\n\tstruct page *page;\n\tunsigned long block_start_pfn;\t/* start of current pageblock */\n\tunsigned long isolate_start_pfn; /* exact pfn we start at */\n\tunsigned long block_end_pfn;\t/* end of current pageblock */\n\tunsigned long low_pfn;\t     /* lowest pfn scanner is able to scan */\n\tstruct list_head *freelist = &cc->freepages;\n\n\t/*\n\t * Initialise the free scanner. The starting point is where we last\n\t * successfully isolated from, zone-cached value, or the end of the\n\t * zone when isolating for the first time. For looping we also need\n\t * this pfn aligned down to the pageblock boundary, because we do\n\t * block_start_pfn -= pageblock_nr_pages in the for loop.\n\t * For ending point, take care when isolating in last pageblock of a\n\t * a zone which ends in the middle of a pageblock.\n\t * The low boundary is the end of the pageblock the migration scanner\n\t * is using.\n\t */\n\tisolate_start_pfn = cc->free_pfn;\n\tblock_start_pfn = pageblock_start_pfn(cc->free_pfn);\n\tblock_end_pfn = min(block_start_pfn + pageblock_nr_pages,\n\t\t\t\t\t\tzone_end_pfn(zone));\n\tlow_pfn = pageblock_end_pfn(cc->migrate_pfn);\n\n\t/*\n\t * Isolate free pages until enough are available to migrate the\n\t * pages on cc->migratepages. We stop searching if the migrate\n\t * and free page scanners meet or enough free pages are isolated.\n\t */\n\tfor (; block_start_pfn >= low_pfn;\n\t\t\t\tblock_end_pfn = block_start_pfn,\n\t\t\t\tblock_start_pfn -= pageblock_nr_pages,\n\t\t\t\tisolate_start_pfn = block_start_pfn) {\n\t\t/*\n\t\t * This can iterate a massively long zone without finding any\n\t\t * suitable migration targets, so periodically check if we need\n\t\t * to schedule, or even abort async compaction.\n\t\t */\n\t\tif (!(block_start_pfn % (SWAP_CLUSTER_MAX * pageblock_nr_pages))\n\t\t\t\t\t\t&& compact_should_abort(cc))\n\t\t\tbreak;\n\n\t\tpage = pageblock_pfn_to_page(block_start_pfn, block_end_pfn,\n\t\t\t\t\t\t\t\t\tzone);\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\t/* Check the block is suitable for migration */\n\t\tif (!suitable_migration_target(cc, page))\n\t\t\tcontinue;\n\n\t\t/* If isolation recently failed, do not retry */\n\t\tif (!isolation_suitable(cc, page))\n\t\t\tcontinue;\n\n\t\t/* Found a block suitable for isolating free pages from. */\n\t\tisolate_freepages_block(cc, &isolate_start_pfn, block_end_pfn,\n\t\t\t\t\tfreelist, false);\n\n\t\t/*\n\t\t * If we isolated enough freepages, or aborted due to lock\n\t\t * contention, terminate.\n\t\t */\n\t\tif ((cc->nr_freepages >= cc->nr_migratepages)\n\t\t\t\t\t\t\t|| cc->contended) {\n\t\t\tif (isolate_start_pfn >= block_end_pfn) {\n\t\t\t\t/*\n\t\t\t\t * Restart at previous pageblock if more\n\t\t\t\t * freepages can be isolated next time.\n\t\t\t\t */\n\t\t\t\tisolate_start_pfn =\n\t\t\t\t\tblock_start_pfn - pageblock_nr_pages;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (isolate_start_pfn < block_end_pfn) {\n\t\t\t/*\n\t\t\t * If isolation failed early, do not continue\n\t\t\t * needlessly.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* __isolate_free_page() does not map the pages */\n\tmap_pages(freelist);\n\n\t/*\n\t * Record where the free scanner will restart next time. Either we\n\t * broke from the loop and set isolate_start_pfn based on the last\n\t * call to isolate_freepages_block(), or we met the migration scanner\n\t * and the loop terminated due to isolate_start_pfn < low_pfn\n\t */\n\tcc->free_pfn = isolate_start_pfn;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nstatic void isolate_freepages(struct compact_control *cc)\n{\n\tstruct zone *zone = cc->zone;\n\tstruct page *page;\n\tunsigned long block_start_pfn;\t/* start of current pageblock */\n\tunsigned long isolate_start_pfn; /* exact pfn we start at */\n\tunsigned long block_end_pfn;\t/* end of current pageblock */\n\tunsigned long low_pfn;\t     /* lowest pfn scanner is able to scan */\n\tstruct list_head *freelist = &cc->freepages;\n\n\t/*\n\t * Initialise the free scanner. The starting point is where we last\n\t * successfully isolated from, zone-cached value, or the end of the\n\t * zone when isolating for the first time. For looping we also need\n\t * this pfn aligned down to the pageblock boundary, because we do\n\t * block_start_pfn -= pageblock_nr_pages in the for loop.\n\t * For ending point, take care when isolating in last pageblock of a\n\t * a zone which ends in the middle of a pageblock.\n\t * The low boundary is the end of the pageblock the migration scanner\n\t * is using.\n\t */\n\tisolate_start_pfn = cc->free_pfn;\n\tblock_start_pfn = pageblock_start_pfn(cc->free_pfn);\n\tblock_end_pfn = min(block_start_pfn + pageblock_nr_pages,\n\t\t\t\t\t\tzone_end_pfn(zone));\n\tlow_pfn = pageblock_end_pfn(cc->migrate_pfn);\n\n\t/*\n\t * Isolate free pages until enough are available to migrate the\n\t * pages on cc->migratepages. We stop searching if the migrate\n\t * and free page scanners meet or enough free pages are isolated.\n\t */\n\tfor (; block_start_pfn >= low_pfn;\n\t\t\t\tblock_end_pfn = block_start_pfn,\n\t\t\t\tblock_start_pfn -= pageblock_nr_pages,\n\t\t\t\tisolate_start_pfn = block_start_pfn) {\n\t\t/*\n\t\t * This can iterate a massively long zone without finding any\n\t\t * suitable migration targets, so periodically check if we need\n\t\t * to schedule, or even abort async compaction.\n\t\t */\n\t\tif (!(block_start_pfn % (SWAP_CLUSTER_MAX * pageblock_nr_pages))\n\t\t\t\t\t\t&& compact_should_abort(cc))\n\t\t\tbreak;\n\n\t\tpage = pageblock_pfn_to_page(block_start_pfn, block_end_pfn,\n\t\t\t\t\t\t\t\t\tzone);\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\t/* Check the block is suitable for migration */\n\t\tif (!suitable_migration_target(cc, page))\n\t\t\tcontinue;\n\n\t\t/* If isolation recently failed, do not retry */\n\t\tif (!isolation_suitable(cc, page))\n\t\t\tcontinue;\n\n\t\t/* Found a block suitable for isolating free pages from. */\n\t\tisolate_freepages_block(cc, &isolate_start_pfn, block_end_pfn,\n\t\t\t\t\tfreelist, false);\n\n\t\t/*\n\t\t * If we isolated enough freepages, or aborted due to lock\n\t\t * contention, terminate.\n\t\t */\n\t\tif ((cc->nr_freepages >= cc->nr_migratepages)\n\t\t\t\t\t\t\t|| cc->contended) {\n\t\t\tif (isolate_start_pfn >= block_end_pfn) {\n\t\t\t\t/*\n\t\t\t\t * Restart at previous pageblock if more\n\t\t\t\t * freepages can be isolated next time.\n\t\t\t\t */\n\t\t\t\tisolate_start_pfn =\n\t\t\t\t\tblock_start_pfn - pageblock_nr_pages;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (isolate_start_pfn < block_end_pfn) {\n\t\t\t/*\n\t\t\t * If isolation failed early, do not continue\n\t\t\t * needlessly.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* __isolate_free_page() does not map the pages */\n\tmap_pages(freelist);\n\n\t/*\n\t * Record where the free scanner will restart next time. Either we\n\t * broke from the loop and set isolate_start_pfn based on the last\n\t * call to isolate_freepages_block(), or we met the migration scanner\n\t * and the loop terminated due to isolate_start_pfn < low_pfn\n\t */\n\tcc->free_pfn = isolate_start_pfn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic void page_cache_free_page(struct address_space *mapping,\n\t\t\t\tstruct page *page)\n{\n\tvoid (*freepage)(struct page *);\n\n\tfreepage = mapping->a_ops->freepage;\n\tif (freepage)\n\t\tfreepage(page);\n\n\tif (PageTransHuge(page) && !PageHuge(page)) {\n\t\tpage_ref_sub(page, HPAGE_PMD_NR);\n\t\tVM_BUG_ON_PAGE(page_count(page) <= 0, page);\n\t} else {\n\t\tput_page(page);\n\t}\n}"
  },
  {
    "function_name": "__delete_from_page_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "227-235",
    "snippet": "void __delete_from_page_cache(struct page *page, void *shadow)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\ttrace_mm_filemap_delete_from_page_cache(page);\n\n\tunaccount_page_cache_page(mapping, page);\n\tpage_cache_delete(mapping, page, shadow);\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_delete",
          "args": [
            "mapping",
            "page",
            "shadow"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "page_cache_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "116-151",
          "snippet": "static void page_cache_delete(struct address_space *mapping,\n\t\t\t\t   struct page *page, void *shadow)\n{\n\tXA_STATE(xas, &mapping->i_pages, page->index);\n\tunsigned int nr = 1;\n\n\tmapping_set_update(&xas, mapping);\n\n\t/* hugetlb pages are represented by a single entry in the xarray */\n\tif (!PageHuge(page)) {\n\t\txas_set_order(&xas, page->index, compound_order(page));\n\t\tnr = 1U << compound_order(page);\n\t}\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(nr != 1 && shadow, page);\n\n\txas_store(&xas, shadow);\n\txas_init_marks(&xas);\n\n\tpage->mapping = NULL;\n\t/* Leave page->index set: truncation lookup relies upon it */\n\n\tif (shadow) {\n\t\tmapping->nrexceptional += nr;\n\t\t/*\n\t\t * Make sure the nrexceptional update is committed before\n\t\t * the nrpages update so that final truncate racing\n\t\t * with reclaim does not see both counters 0 at the\n\t\t * same time and miss a shadow entry.\n\t\t */\n\t\tsmp_wmb();\n\t}\n\tmapping->nrpages -= nr;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic void page_cache_delete(struct address_space *mapping,\n\t\t\t\t   struct page *page, void *shadow)\n{\n\tXA_STATE(xas, &mapping->i_pages, page->index);\n\tunsigned int nr = 1;\n\n\tmapping_set_update(&xas, mapping);\n\n\t/* hugetlb pages are represented by a single entry in the xarray */\n\tif (!PageHuge(page)) {\n\t\txas_set_order(&xas, page->index, compound_order(page));\n\t\tnr = 1U << compound_order(page);\n\t}\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(nr != 1 && shadow, page);\n\n\txas_store(&xas, shadow);\n\txas_init_marks(&xas);\n\n\tpage->mapping = NULL;\n\t/* Leave page->index set: truncation lookup relies upon it */\n\n\tif (shadow) {\n\t\tmapping->nrexceptional += nr;\n\t\t/*\n\t\t * Make sure the nrexceptional update is committed before\n\t\t * the nrpages update so that final truncate racing\n\t\t * with reclaim does not see both counters 0 at the\n\t\t * same time and miss a shadow entry.\n\t\t */\n\t\tsmp_wmb();\n\t}\n\tmapping->nrpages -= nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unaccount_page_cache_page",
          "args": [
            "mapping",
            "page"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "unaccount_page_cache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "153-220",
          "snippet": "static void unaccount_page_cache_page(struct address_space *mapping,\n\t\t\t\t      struct page *page)\n{\n\tint nr;\n\n\t/*\n\t * if we're uptodate, flush out into the cleancache, otherwise\n\t * invalidate any existing cleancache entries.  We can't leave\n\t * stale data around in the cleancache once our page is gone\n\t */\n\tif (PageUptodate(page) && PageMappedToDisk(page))\n\t\tcleancache_put_page(page);\n\telse\n\t\tcleancache_invalidate_page(mapping, page);\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(page_mapped(page), page);\n\tif (!IS_ENABLED(CONFIG_DEBUG_VM) && unlikely(page_mapped(page))) {\n\t\tint mapcount;\n\n\t\tpr_alert(\"BUG: Bad page cache in process %s  pfn:%05lx\\n\",\n\t\t\t current->comm, page_to_pfn(page));\n\t\tdump_page(page, \"still mapped when deleted\");\n\t\tdump_stack();\n\t\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n\n\t\tmapcount = page_mapcount(page);\n\t\tif (mapping_exiting(mapping) &&\n\t\t    page_count(page) >= mapcount + 2) {\n\t\t\t/*\n\t\t\t * All vmas have already been torn down, so it's\n\t\t\t * a good bet that actually the page is unmapped,\n\t\t\t * and we'd prefer not to leak it: if we're wrong,\n\t\t\t * some other bad page check should catch it later.\n\t\t\t */\n\t\t\tpage_mapcount_reset(page);\n\t\t\tpage_ref_sub(page, mapcount);\n\t\t}\n\t}\n\n\t/* hugetlb pages do not participate in page cache accounting. */\n\tif (PageHuge(page))\n\t\treturn;\n\n\tnr = hpage_nr_pages(page);\n\n\t__mod_node_page_state(page_pgdat(page), NR_FILE_PAGES, -nr);\n\tif (PageSwapBacked(page)) {\n\t\t__mod_node_page_state(page_pgdat(page), NR_SHMEM, -nr);\n\t\tif (PageTransHuge(page))\n\t\t\t__dec_node_page_state(page, NR_SHMEM_THPS);\n\t} else {\n\t\tVM_BUG_ON_PAGE(PageTransHuge(page), page);\n\t}\n\n\t/*\n\t * At this point page must be either written or cleaned by\n\t * truncate.  Dirty page here signals a bug and loss of\n\t * unwritten data.\n\t *\n\t * This fixes dirty accounting after removing the page entirely\n\t * but leaves PageDirty set: it has no effect for truncated\n\t * page and anyway will be cleared before returning page into\n\t * buddy allocator.\n\t */\n\tif (WARN_ON_ONCE(PageDirty(page)))\n\t\taccount_page_cleaned(page, mapping, inode_to_wb(mapping->host));\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic void unaccount_page_cache_page(struct address_space *mapping,\n\t\t\t\t      struct page *page)\n{\n\tint nr;\n\n\t/*\n\t * if we're uptodate, flush out into the cleancache, otherwise\n\t * invalidate any existing cleancache entries.  We can't leave\n\t * stale data around in the cleancache once our page is gone\n\t */\n\tif (PageUptodate(page) && PageMappedToDisk(page))\n\t\tcleancache_put_page(page);\n\telse\n\t\tcleancache_invalidate_page(mapping, page);\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(page_mapped(page), page);\n\tif (!IS_ENABLED(CONFIG_DEBUG_VM) && unlikely(page_mapped(page))) {\n\t\tint mapcount;\n\n\t\tpr_alert(\"BUG: Bad page cache in process %s  pfn:%05lx\\n\",\n\t\t\t current->comm, page_to_pfn(page));\n\t\tdump_page(page, \"still mapped when deleted\");\n\t\tdump_stack();\n\t\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n\n\t\tmapcount = page_mapcount(page);\n\t\tif (mapping_exiting(mapping) &&\n\t\t    page_count(page) >= mapcount + 2) {\n\t\t\t/*\n\t\t\t * All vmas have already been torn down, so it's\n\t\t\t * a good bet that actually the page is unmapped,\n\t\t\t * and we'd prefer not to leak it: if we're wrong,\n\t\t\t * some other bad page check should catch it later.\n\t\t\t */\n\t\t\tpage_mapcount_reset(page);\n\t\t\tpage_ref_sub(page, mapcount);\n\t\t}\n\t}\n\n\t/* hugetlb pages do not participate in page cache accounting. */\n\tif (PageHuge(page))\n\t\treturn;\n\n\tnr = hpage_nr_pages(page);\n\n\t__mod_node_page_state(page_pgdat(page), NR_FILE_PAGES, -nr);\n\tif (PageSwapBacked(page)) {\n\t\t__mod_node_page_state(page_pgdat(page), NR_SHMEM, -nr);\n\t\tif (PageTransHuge(page))\n\t\t\t__dec_node_page_state(page, NR_SHMEM_THPS);\n\t} else {\n\t\tVM_BUG_ON_PAGE(PageTransHuge(page), page);\n\t}\n\n\t/*\n\t * At this point page must be either written or cleaned by\n\t * truncate.  Dirty page here signals a bug and loss of\n\t * unwritten data.\n\t *\n\t * This fixes dirty accounting after removing the page entirely\n\t * but leaves PageDirty set: it has no effect for truncated\n\t * page and anyway will be cleared before returning page into\n\t * buddy allocator.\n\t */\n\tif (WARN_ON_ONCE(PageDirty(page)))\n\t\taccount_page_cleaned(page, mapping, inode_to_wb(mapping->host));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_mm_filemap_delete_from_page_cache",
          "args": [
            "page"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid __delete_from_page_cache(struct page *page, void *shadow)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\ttrace_mm_filemap_delete_from_page_cache(page);\n\n\tunaccount_page_cache_page(mapping, page);\n\tpage_cache_delete(mapping, page, shadow);\n}"
  },
  {
    "function_name": "unaccount_page_cache_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "153-220",
    "snippet": "static void unaccount_page_cache_page(struct address_space *mapping,\n\t\t\t\t      struct page *page)\n{\n\tint nr;\n\n\t/*\n\t * if we're uptodate, flush out into the cleancache, otherwise\n\t * invalidate any existing cleancache entries.  We can't leave\n\t * stale data around in the cleancache once our page is gone\n\t */\n\tif (PageUptodate(page) && PageMappedToDisk(page))\n\t\tcleancache_put_page(page);\n\telse\n\t\tcleancache_invalidate_page(mapping, page);\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(page_mapped(page), page);\n\tif (!IS_ENABLED(CONFIG_DEBUG_VM) && unlikely(page_mapped(page))) {\n\t\tint mapcount;\n\n\t\tpr_alert(\"BUG: Bad page cache in process %s  pfn:%05lx\\n\",\n\t\t\t current->comm, page_to_pfn(page));\n\t\tdump_page(page, \"still mapped when deleted\");\n\t\tdump_stack();\n\t\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n\n\t\tmapcount = page_mapcount(page);\n\t\tif (mapping_exiting(mapping) &&\n\t\t    page_count(page) >= mapcount + 2) {\n\t\t\t/*\n\t\t\t * All vmas have already been torn down, so it's\n\t\t\t * a good bet that actually the page is unmapped,\n\t\t\t * and we'd prefer not to leak it: if we're wrong,\n\t\t\t * some other bad page check should catch it later.\n\t\t\t */\n\t\t\tpage_mapcount_reset(page);\n\t\t\tpage_ref_sub(page, mapcount);\n\t\t}\n\t}\n\n\t/* hugetlb pages do not participate in page cache accounting. */\n\tif (PageHuge(page))\n\t\treturn;\n\n\tnr = hpage_nr_pages(page);\n\n\t__mod_node_page_state(page_pgdat(page), NR_FILE_PAGES, -nr);\n\tif (PageSwapBacked(page)) {\n\t\t__mod_node_page_state(page_pgdat(page), NR_SHMEM, -nr);\n\t\tif (PageTransHuge(page))\n\t\t\t__dec_node_page_state(page, NR_SHMEM_THPS);\n\t} else {\n\t\tVM_BUG_ON_PAGE(PageTransHuge(page), page);\n\t}\n\n\t/*\n\t * At this point page must be either written or cleaned by\n\t * truncate.  Dirty page here signals a bug and loss of\n\t * unwritten data.\n\t *\n\t * This fixes dirty accounting after removing the page entirely\n\t * but leaves PageDirty set: it has no effect for truncated\n\t * page and anyway will be cleared before returning page into\n\t * buddy allocator.\n\t */\n\tif (WARN_ON_ONCE(PageDirty(page)))\n\t\taccount_page_cleaned(page, mapping, inode_to_wb(mapping->host));\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "account_page_cleaned",
          "args": [
            "page",
            "mapping",
            "inode_to_wb(mapping->host)"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "account_page_cleaned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2423-2432",
          "snippet": "void account_page_cleaned(struct page *page, struct address_space *mapping,\n\t\t\t  struct bdi_writeback *wb)\n{\n\tif (mapping_cap_account_dirty(mapping)) {\n\t\tdec_lruvec_page_state(page, NR_FILE_DIRTY);\n\t\tdec_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t\tdec_wb_stat(wb, WB_RECLAIMABLE);\n\t\ttask_io_account_cancelled_write(PAGE_SIZE);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid account_page_cleaned(struct page *page, struct address_space *mapping,\n\t\t\t  struct bdi_writeback *wb)\n{\n\tif (mapping_cap_account_dirty(mapping)) {\n\t\tdec_lruvec_page_state(page, NR_FILE_DIRTY);\n\t\tdec_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t\tdec_wb_stat(wb, WB_RECLAIMABLE);\n\t\ttask_io_account_cancelled_write(PAGE_SIZE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_to_wb",
          "args": [
            "mapping->host"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "PageDirty(page)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageTransHuge(page)",
            "page"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dec_node_page_state",
          "args": [
            "page",
            "NR_SHMEM_THPS"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "__dec_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "460-463",
          "snippet": "void __dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__dec_node_state(page_pgdat(page), item);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__dec_node_state(page_pgdat(page), item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_node_page_state",
          "args": [
            "page_pgdat(page)",
            "NR_SHMEM",
            "-nr"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "__mod_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "335-352",
          "snippet": "void __mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\tlong delta)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tnode_page_state_add(x, pgdat, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\tlong delta)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tnode_page_state_add(x, pgdat, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_pgdat",
          "args": [
            "page"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapBacked",
          "args": [
            "page"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_pgdat",
          "args": [
            "page"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_ref_sub",
          "args": [
            "page",
            "mapcount"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapcount_reset",
          "args": [
            "page"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_exiting",
          "args": [
            "mapping"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "page"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_taint",
          "args": [
            "TAINT_BAD_PAGE",
            "LOCKDEP_NOW_UNRELIABLE"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_page",
          "args": [
            "page",
            "\"still mapped when deleted\""
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "dump_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/debug.c",
          "lines": "91-95",
          "snippet": "void dump_page(struct page *page, const char *reason)\n{\n\t__dump_page(page, reason);\n\tdump_page_owner(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/migrate.h>",
            "#include <trace/events/mmflags.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/ctype.h>\n#include <linux/page_owner.h>\n#include <linux/migrate.h>\n#include <trace/events/mmflags.h>\n#include <linux/memcontrol.h>\n#include <linux/trace_events.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid dump_page(struct page *page, const char *reason)\n{\n\t__dump_page(page, reason);\n\tdump_page_owner(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"BUG: Bad page cache in process %s  pfn:%05lx\\n\"",
            "current->comm",
            "page_to_pfn(page)"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page_mapped(page)"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "page"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "470-486",
          "snippet": "bool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nbool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_DEBUG_VM"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "page_mapped(page)",
            "page"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageTail(page)",
            "page"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTail",
          "args": [
            "page"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cleancache_invalidate_page",
          "args": [
            "mapping",
            "page"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "__cleancache_invalidate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cleancache.c",
          "lines": "244-262",
          "snippet": "void __cleancache_invalidate_page(struct address_space *mapping,\n\t\t\t\t\tstruct page *page)\n{\n\t/* careful... page->mapping is NULL sometimes when this is called */\n\tint pool_id = mapping->host->i_sb->cleancache_poolid;\n\tstruct cleancache_filekey key = { .u.key = { 0 } };\n\n\tif (!cleancache_ops)\n\t\treturn;\n\n\tif (pool_id >= 0) {\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tif (cleancache_get_key(mapping->host, &key) >= 0) {\n\t\t\tcleancache_ops->invalidate_page(pool_id,\n\t\t\t\t\tkey, page->index);\n\t\t\tcleancache_invalidates++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/cleancache.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/mm.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct cleancache_ops *cleancache_ops",
            "static u64 cleancache_invalidates;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cleancache.h>\n#include <linux/debugfs.h>\n#include <linux/mm.h>\n#include <linux/exportfs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct cleancache_ops *cleancache_ops;\nstatic u64 cleancache_invalidates;\n\nvoid __cleancache_invalidate_page(struct address_space *mapping,\n\t\t\t\t\tstruct page *page)\n{\n\t/* careful... page->mapping is NULL sometimes when this is called */\n\tint pool_id = mapping->host->i_sb->cleancache_poolid;\n\tstruct cleancache_filekey key = { .u.key = { 0 } };\n\n\tif (!cleancache_ops)\n\t\treturn;\n\n\tif (pool_id >= 0) {\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tif (cleancache_get_key(mapping->host, &key) >= 0) {\n\t\t\tcleancache_ops->invalidate_page(pool_id,\n\t\t\t\t\tkey, page->index);\n\t\t\tcleancache_invalidates++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleancache_put_page",
          "args": [
            "page"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "__cleancache_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cleancache.c",
          "lines": "216-233",
          "snippet": "void __cleancache_put_page(struct page *page)\n{\n\tint pool_id;\n\tstruct cleancache_filekey key = { .u.key = { 0 } };\n\n\tif (!cleancache_ops) {\n\t\tcleancache_puts++;\n\t\treturn;\n\t}\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tpool_id = page->mapping->host->i_sb->cleancache_poolid;\n\tif (pool_id >= 0 &&\n\t\tcleancache_get_key(page->mapping->host, &key) >= 0) {\n\t\tcleancache_ops->put_page(pool_id, key, page->index, page);\n\t\tcleancache_puts++;\n\t}\n}",
          "includes": [
            "#include <linux/cleancache.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/mm.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct cleancache_ops *cleancache_ops",
            "static u64 cleancache_puts;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cleancache.h>\n#include <linux/debugfs.h>\n#include <linux/mm.h>\n#include <linux/exportfs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct cleancache_ops *cleancache_ops;\nstatic u64 cleancache_puts;\n\nvoid __cleancache_put_page(struct page *page)\n{\n\tint pool_id;\n\tstruct cleancache_filekey key = { .u.key = { 0 } };\n\n\tif (!cleancache_ops) {\n\t\tcleancache_puts++;\n\t\treturn;\n\t}\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tpool_id = page->mapping->host->i_sb->cleancache_poolid;\n\tif (pool_id >= 0 &&\n\t\tcleancache_get_key(page->mapping->host, &key) >= 0) {\n\t\tcleancache_ops->put_page(pool_id, key, page->index, page);\n\t\tcleancache_puts++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageMappedToDisk",
          "args": [
            "page"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic void unaccount_page_cache_page(struct address_space *mapping,\n\t\t\t\t      struct page *page)\n{\n\tint nr;\n\n\t/*\n\t * if we're uptodate, flush out into the cleancache, otherwise\n\t * invalidate any existing cleancache entries.  We can't leave\n\t * stale data around in the cleancache once our page is gone\n\t */\n\tif (PageUptodate(page) && PageMappedToDisk(page))\n\t\tcleancache_put_page(page);\n\telse\n\t\tcleancache_invalidate_page(mapping, page);\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(page_mapped(page), page);\n\tif (!IS_ENABLED(CONFIG_DEBUG_VM) && unlikely(page_mapped(page))) {\n\t\tint mapcount;\n\n\t\tpr_alert(\"BUG: Bad page cache in process %s  pfn:%05lx\\n\",\n\t\t\t current->comm, page_to_pfn(page));\n\t\tdump_page(page, \"still mapped when deleted\");\n\t\tdump_stack();\n\t\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n\n\t\tmapcount = page_mapcount(page);\n\t\tif (mapping_exiting(mapping) &&\n\t\t    page_count(page) >= mapcount + 2) {\n\t\t\t/*\n\t\t\t * All vmas have already been torn down, so it's\n\t\t\t * a good bet that actually the page is unmapped,\n\t\t\t * and we'd prefer not to leak it: if we're wrong,\n\t\t\t * some other bad page check should catch it later.\n\t\t\t */\n\t\t\tpage_mapcount_reset(page);\n\t\t\tpage_ref_sub(page, mapcount);\n\t\t}\n\t}\n\n\t/* hugetlb pages do not participate in page cache accounting. */\n\tif (PageHuge(page))\n\t\treturn;\n\n\tnr = hpage_nr_pages(page);\n\n\t__mod_node_page_state(page_pgdat(page), NR_FILE_PAGES, -nr);\n\tif (PageSwapBacked(page)) {\n\t\t__mod_node_page_state(page_pgdat(page), NR_SHMEM, -nr);\n\t\tif (PageTransHuge(page))\n\t\t\t__dec_node_page_state(page, NR_SHMEM_THPS);\n\t} else {\n\t\tVM_BUG_ON_PAGE(PageTransHuge(page), page);\n\t}\n\n\t/*\n\t * At this point page must be either written or cleaned by\n\t * truncate.  Dirty page here signals a bug and loss of\n\t * unwritten data.\n\t *\n\t * This fixes dirty accounting after removing the page entirely\n\t * but leaves PageDirty set: it has no effect for truncated\n\t * page and anyway will be cleared before returning page into\n\t * buddy allocator.\n\t */\n\tif (WARN_ON_ONCE(PageDirty(page)))\n\t\taccount_page_cleaned(page, mapping, inode_to_wb(mapping->host));\n}"
  },
  {
    "function_name": "page_cache_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
    "lines": "116-151",
    "snippet": "static void page_cache_delete(struct address_space *mapping,\n\t\t\t\t   struct page *page, void *shadow)\n{\n\tXA_STATE(xas, &mapping->i_pages, page->index);\n\tunsigned int nr = 1;\n\n\tmapping_set_update(&xas, mapping);\n\n\t/* hugetlb pages are represented by a single entry in the xarray */\n\tif (!PageHuge(page)) {\n\t\txas_set_order(&xas, page->index, compound_order(page));\n\t\tnr = 1U << compound_order(page);\n\t}\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(nr != 1 && shadow, page);\n\n\txas_store(&xas, shadow);\n\txas_init_marks(&xas);\n\n\tpage->mapping = NULL;\n\t/* Leave page->index set: truncation lookup relies upon it */\n\n\tif (shadow) {\n\t\tmapping->nrexceptional += nr;\n\t\t/*\n\t\t * Make sure the nrexceptional update is committed before\n\t\t * the nrpages update so that final truncate racing\n\t\t * with reclaim does not see both counters 0 at the\n\t\t * same time and miss a shadow entry.\n\t\t */\n\t\tsmp_wmb();\n\t}\n\tmapping->nrpages -= nr;\n}",
    "includes": [
      "#include <asm/mman.h>",
      "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
      "#include <trace/events/filemap.h>",
      "#include \"internal.h\"",
      "#include <linux/psi.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/rmap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/security.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/hash.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/capability.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/compiler.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_init_marks",
          "args": [
            "&xas"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_store",
          "args": [
            "&xas",
            "shadow"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "nr != 1 && shadow",
            "page"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageTail(page)",
            "page"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTail",
          "args": [
            "page"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_set_order",
          "args": [
            "&xas",
            "page->index",
            "compound_order(page)"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_set_update",
          "args": [
            "&xas",
            "mapping"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "page->index"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic void page_cache_delete(struct address_space *mapping,\n\t\t\t\t   struct page *page, void *shadow)\n{\n\tXA_STATE(xas, &mapping->i_pages, page->index);\n\tunsigned int nr = 1;\n\n\tmapping_set_update(&xas, mapping);\n\n\t/* hugetlb pages are represented by a single entry in the xarray */\n\tif (!PageHuge(page)) {\n\t\txas_set_order(&xas, page->index, compound_order(page));\n\t\tnr = 1U << compound_order(page);\n\t}\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(nr != 1 && shadow, page);\n\n\txas_store(&xas, shadow);\n\txas_init_marks(&xas);\n\n\tpage->mapping = NULL;\n\t/* Leave page->index set: truncation lookup relies upon it */\n\n\tif (shadow) {\n\t\tmapping->nrexceptional += nr;\n\t\t/*\n\t\t * Make sure the nrexceptional update is committed before\n\t\t * the nrpages update so that final truncate racing\n\t\t * with reclaim does not see both counters 0 at the\n\t\t * same time and miss a shadow entry.\n\t\t */\n\t\tsmp_wmb();\n\t}\n\tmapping->nrpages -= nr;\n}"
  }
]