[
  {
    "function_name": "tlb_finish_mmu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
    "lines": "247-261",
    "snippet": "void tlb_finish_mmu(struct mmu_gather *tlb,\n\t\tunsigned long start, unsigned long end)\n{\n\t/*\n\t * If there are parallel threads are doing PTE changes on same range\n\t * under non-exclusive lock(e.g., mmap_sem read-side) but defer TLB\n\t * flush by batching, a thread has stable TLB entry can fail to flush\n\t * the TLB by observing pte_none|!pte_dirty, for example so flush TLB\n\t * forcefully if we detect parallel PTE batching threads.\n\t */\n\tbool force = mm_tlb_flush_nested(tlb->mm);\n\n\tarch_tlb_finish_mmu(tlb, start, end, force);\n\tdec_tlb_flush_pending(tlb->mm);\n}",
    "includes": [
      "#include <asm/tlb.h>",
      "#include <asm/pgalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/smp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm_types.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/kernel.h>",
      "#include <linux/highmem.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dec_tlb_flush_pending",
          "args": [
            "tlb->mm"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_tlb_finish_mmu",
          "args": [
            "tlb",
            "start",
            "end",
            "force"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "arch_tlb_finish_mmu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
          "lines": "90-110",
          "snippet": "void arch_tlb_finish_mmu(struct mmu_gather *tlb,\n\t\tunsigned long start, unsigned long end, bool force)\n{\n\tstruct mmu_gather_batch *batch, *next;\n\n\tif (force) {\n\t\t__tlb_reset_range(tlb);\n\t\t__tlb_adjust_range(tlb, start, end - start);\n\t}\n\n\ttlb_flush_mmu(tlb);\n\n\t/* keep the page table cache within bounds */\n\tcheck_pgt_cache();\n\n\tfor (batch = tlb->local.next; batch; batch = next) {\n\t\tnext = batch->next;\n\t\tfree_pages((unsigned long)batch, 0);\n\t}\n\ttlb->local.next = NULL;\n}",
          "includes": [
            "#include <asm/tlb.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/smp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid arch_tlb_finish_mmu(struct mmu_gather *tlb,\n\t\tunsigned long start, unsigned long end, bool force)\n{\n\tstruct mmu_gather_batch *batch, *next;\n\n\tif (force) {\n\t\t__tlb_reset_range(tlb);\n\t\t__tlb_adjust_range(tlb, start, end - start);\n\t}\n\n\ttlb_flush_mmu(tlb);\n\n\t/* keep the page table cache within bounds */\n\tcheck_pgt_cache();\n\n\tfor (batch = tlb->local.next; batch; batch = next) {\n\t\tnext = batch->next;\n\t\tfree_pages((unsigned long)batch, 0);\n\t}\n\ttlb->local.next = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_tlb_flush_nested",
          "args": [
            "tlb->mm"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid tlb_finish_mmu(struct mmu_gather *tlb,\n\t\tunsigned long start, unsigned long end)\n{\n\t/*\n\t * If there are parallel threads are doing PTE changes on same range\n\t * under non-exclusive lock(e.g., mmap_sem read-side) but defer TLB\n\t * flush by batching, a thread has stable TLB entry can fail to flush\n\t * the TLB by observing pte_none|!pte_dirty, for example so flush TLB\n\t * forcefully if we detect parallel PTE batching threads.\n\t */\n\tbool force = mm_tlb_flush_nested(tlb->mm);\n\n\tarch_tlb_finish_mmu(tlb, start, end, force);\n\tdec_tlb_flush_pending(tlb->mm);\n}"
  },
  {
    "function_name": "tlb_gather_mmu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
    "lines": "240-245",
    "snippet": "void tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm,\n\t\t\tunsigned long start, unsigned long end)\n{\n\tarch_tlb_gather_mmu(tlb, mm, start, end);\n\tinc_tlb_flush_pending(tlb->mm);\n}",
    "includes": [
      "#include <asm/tlb.h>",
      "#include <asm/pgalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/smp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm_types.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/kernel.h>",
      "#include <linux/highmem.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_tlb_flush_pending",
          "args": [
            "tlb->mm"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_tlb_gather_mmu",
          "args": [
            "tlb",
            "mm",
            "start",
            "end"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "arch_tlb_gather_mmu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
          "lines": "44-64",
          "snippet": "void arch_tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm,\n\t\t\t\tunsigned long start, unsigned long end)\n{\n\ttlb->mm = mm;\n\n\t/* Is it from 0 to ~0? */\n\ttlb->fullmm     = !(start | (end+1));\n\ttlb->need_flush_all = 0;\n\ttlb->local.next = NULL;\n\ttlb->local.nr   = 0;\n\ttlb->local.max  = ARRAY_SIZE(tlb->__pages);\n\ttlb->active     = &tlb->local;\n\ttlb->batch_count = 0;\n\n#ifdef CONFIG_HAVE_RCU_TABLE_FREE\n\ttlb->batch = NULL;\n#endif\n\ttlb->page_size = 0;\n\n\t__tlb_reset_range(tlb);\n}",
          "includes": [
            "#include <asm/tlb.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/smp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid arch_tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm,\n\t\t\t\tunsigned long start, unsigned long end)\n{\n\ttlb->mm = mm;\n\n\t/* Is it from 0 to ~0? */\n\ttlb->fullmm     = !(start | (end+1));\n\ttlb->need_flush_all = 0;\n\ttlb->local.next = NULL;\n\ttlb->local.nr   = 0;\n\ttlb->local.max  = ARRAY_SIZE(tlb->__pages);\n\ttlb->active     = &tlb->local;\n\ttlb->batch_count = 0;\n\n#ifdef CONFIG_HAVE_RCU_TABLE_FREE\n\ttlb->batch = NULL;\n#endif\n\ttlb->page_size = 0;\n\n\t__tlb_reset_range(tlb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm,\n\t\t\tunsigned long start, unsigned long end)\n{\n\tarch_tlb_gather_mmu(tlb, mm, start, end);\n\tinc_tlb_flush_pending(tlb->mm);\n}"
  },
  {
    "function_name": "tlb_remove_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
    "lines": "207-224",
    "snippet": "void tlb_remove_table(struct mmu_gather *tlb, void *table)\n{\n\tstruct mmu_table_batch **batch = &tlb->batch;\n\n\tif (*batch == NULL) {\n\t\t*batch = (struct mmu_table_batch *)__get_free_page(GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (*batch == NULL) {\n\t\t\ttlb_table_invalidate(tlb);\n\t\t\ttlb_remove_table_one(table);\n\t\t\treturn;\n\t\t}\n\t\t(*batch)->nr = 0;\n\t}\n\n\t(*batch)->tables[(*batch)->nr++] = table;\n\tif ((*batch)->nr == MAX_TABLE_BATCH)\n\t\ttlb_table_flush(tlb);\n}",
    "includes": [
      "#include <asm/tlb.h>",
      "#include <asm/pgalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/smp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm_types.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/kernel.h>",
      "#include <linux/highmem.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tlb_table_flush",
          "args": [
            "tlb"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "tlb_table_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
          "lines": "196-205",
          "snippet": "void tlb_table_flush(struct mmu_gather *tlb)\n{\n\tstruct mmu_table_batch **batch = &tlb->batch;\n\n\tif (*batch) {\n\t\ttlb_table_invalidate(tlb);\n\t\tcall_rcu_sched(&(*batch)->rcu, tlb_remove_table_rcu);\n\t\t*batch = NULL;\n\t}\n}",
          "includes": [
            "#include <asm/tlb.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/smp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid tlb_table_flush(struct mmu_gather *tlb)\n{\n\tstruct mmu_table_batch **batch = &tlb->batch;\n\n\tif (*batch) {\n\t\ttlb_table_invalidate(tlb);\n\t\tcall_rcu_sched(&(*batch)->rcu, tlb_remove_table_rcu);\n\t\t*batch = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlb_remove_table_one",
          "args": [
            "table"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "tlb_remove_table_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
          "lines": "170-181",
          "snippet": "static void tlb_remove_table_one(void *table)\n{\n\t/*\n\t * This isn't an RCU grace period and hence the page-tables cannot be\n\t * assumed to be actually RCU-freed.\n\t *\n\t * It is however sufficient for software page-table walkers that rely on\n\t * IRQ disabling. See the comment near struct mmu_table_batch.\n\t */\n\tsmp_call_function(tlb_remove_table_smp_sync, NULL, 1);\n\t__tlb_remove_table(table);\n}",
          "includes": [
            "#include <asm/tlb.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/smp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nstatic void tlb_remove_table_one(void *table)\n{\n\t/*\n\t * This isn't an RCU grace period and hence the page-tables cannot be\n\t * assumed to be actually RCU-freed.\n\t *\n\t * It is however sufficient for software page-table walkers that rely on\n\t * IRQ disabling. See the comment near struct mmu_table_batch.\n\t */\n\tsmp_call_function(tlb_remove_table_smp_sync, NULL, 1);\n\t__tlb_remove_table(table);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlb_table_invalidate",
          "args": [
            "tlb"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "tlb_table_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
          "lines": "153-163",
          "snippet": "static inline void tlb_table_invalidate(struct mmu_gather *tlb)\n{\n#ifdef CONFIG_HAVE_RCU_TABLE_INVALIDATE\n\t/*\n\t * Invalidate page-table caches used by hardware walkers. Then we still\n\t * need to RCU-sched wait while freeing the pages because software\n\t * walkers can still be in-flight.\n\t */\n\ttlb_flush_mmu_tlbonly(tlb);\n#endif\n}",
          "includes": [
            "#include <asm/tlb.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/smp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nstatic inline void tlb_table_invalidate(struct mmu_gather *tlb)\n{\n#ifdef CONFIG_HAVE_RCU_TABLE_INVALIDATE\n\t/*\n\t * Invalidate page-table caches used by hardware walkers. Then we still\n\t * need to RCU-sched wait while freeing the pages because software\n\t * walkers can still be in-flight.\n\t */\n\ttlb_flush_mmu_tlbonly(tlb);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_NOWAIT | __GFP_NOWARN"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid tlb_remove_table(struct mmu_gather *tlb, void *table)\n{\n\tstruct mmu_table_batch **batch = &tlb->batch;\n\n\tif (*batch == NULL) {\n\t\t*batch = (struct mmu_table_batch *)__get_free_page(GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (*batch == NULL) {\n\t\t\ttlb_table_invalidate(tlb);\n\t\t\ttlb_remove_table_one(table);\n\t\t\treturn;\n\t\t}\n\t\t(*batch)->nr = 0;\n\t}\n\n\t(*batch)->tables[(*batch)->nr++] = table;\n\tif ((*batch)->nr == MAX_TABLE_BATCH)\n\t\ttlb_table_flush(tlb);\n}"
  },
  {
    "function_name": "tlb_table_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
    "lines": "196-205",
    "snippet": "void tlb_table_flush(struct mmu_gather *tlb)\n{\n\tstruct mmu_table_batch **batch = &tlb->batch;\n\n\tif (*batch) {\n\t\ttlb_table_invalidate(tlb);\n\t\tcall_rcu_sched(&(*batch)->rcu, tlb_remove_table_rcu);\n\t\t*batch = NULL;\n\t}\n}",
    "includes": [
      "#include <asm/tlb.h>",
      "#include <asm/pgalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/smp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm_types.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/kernel.h>",
      "#include <linux/highmem.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu_sched",
          "args": [
            "&(*batch)->rcu",
            "tlb_remove_table_rcu"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlb_table_invalidate",
          "args": [
            "tlb"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "tlb_table_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
          "lines": "153-163",
          "snippet": "static inline void tlb_table_invalidate(struct mmu_gather *tlb)\n{\n#ifdef CONFIG_HAVE_RCU_TABLE_INVALIDATE\n\t/*\n\t * Invalidate page-table caches used by hardware walkers. Then we still\n\t * need to RCU-sched wait while freeing the pages because software\n\t * walkers can still be in-flight.\n\t */\n\ttlb_flush_mmu_tlbonly(tlb);\n#endif\n}",
          "includes": [
            "#include <asm/tlb.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/smp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nstatic inline void tlb_table_invalidate(struct mmu_gather *tlb)\n{\n#ifdef CONFIG_HAVE_RCU_TABLE_INVALIDATE\n\t/*\n\t * Invalidate page-table caches used by hardware walkers. Then we still\n\t * need to RCU-sched wait while freeing the pages because software\n\t * walkers can still be in-flight.\n\t */\n\ttlb_flush_mmu_tlbonly(tlb);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid tlb_table_flush(struct mmu_gather *tlb)\n{\n\tstruct mmu_table_batch **batch = &tlb->batch;\n\n\tif (*batch) {\n\t\ttlb_table_invalidate(tlb);\n\t\tcall_rcu_sched(&(*batch)->rcu, tlb_remove_table_rcu);\n\t\t*batch = NULL;\n\t}\n}"
  },
  {
    "function_name": "tlb_remove_table_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
    "lines": "183-194",
    "snippet": "static void tlb_remove_table_rcu(struct rcu_head *head)\n{\n\tstruct mmu_table_batch *batch;\n\tint i;\n\n\tbatch = container_of(head, struct mmu_table_batch, rcu);\n\n\tfor (i = 0; i < batch->nr; i++)\n\t\t__tlb_remove_table(batch->tables[i]);\n\n\tfree_page((unsigned long)batch);\n}",
    "includes": [
      "#include <asm/tlb.h>",
      "#include <asm/pgalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/smp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm_types.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/kernel.h>",
      "#include <linux/highmem.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)batch"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "soft_offline_free_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "1857-1871",
          "snippet": "static int soft_offline_free_page(struct page *page)\n{\n\tint rc = 0;\n\tstruct page *head = compound_head(page);\n\n\tif (PageHuge(head))\n\t\trc = dissolve_free_huge_page(page);\n\tif (!rc) {\n\t\tif (set_hwpoison_free_buddy_page(page))\n\t\t\tnum_poisoned_pages_inc();\n\t\telse\n\t\t\trc = -EBUSY;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define head\t\t(1UL << PG_head)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define head\t\t(1UL << PG_head)\n\nstatic int soft_offline_free_page(struct page *page)\n{\n\tint rc = 0;\n\tstruct page *head = compound_head(page);\n\n\tif (PageHuge(head))\n\t\trc = dissolve_free_huge_page(page);\n\tif (!rc) {\n\t\tif (set_hwpoison_free_buddy_page(page))\n\t\t\tnum_poisoned_pages_inc();\n\t\telse\n\t\t\trc = -EBUSY;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__tlb_remove_table",
          "args": [
            "batch->tables[i]"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structmmu_table_batch",
            "rcu"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nstatic void tlb_remove_table_rcu(struct rcu_head *head)\n{\n\tstruct mmu_table_batch *batch;\n\tint i;\n\n\tbatch = container_of(head, struct mmu_table_batch, rcu);\n\n\tfor (i = 0; i < batch->nr; i++)\n\t\t__tlb_remove_table(batch->tables[i]);\n\n\tfree_page((unsigned long)batch);\n}"
  },
  {
    "function_name": "tlb_remove_table_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
    "lines": "170-181",
    "snippet": "static void tlb_remove_table_one(void *table)\n{\n\t/*\n\t * This isn't an RCU grace period and hence the page-tables cannot be\n\t * assumed to be actually RCU-freed.\n\t *\n\t * It is however sufficient for software page-table walkers that rely on\n\t * IRQ disabling. See the comment near struct mmu_table_batch.\n\t */\n\tsmp_call_function(tlb_remove_table_smp_sync, NULL, 1);\n\t__tlb_remove_table(table);\n}",
    "includes": [
      "#include <asm/tlb.h>",
      "#include <asm/pgalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/smp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm_types.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/kernel.h>",
      "#include <linux/highmem.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__tlb_remove_table",
          "args": [
            "table"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function",
          "args": [
            "tlb_remove_table_smp_sync",
            "NULL",
            "1"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nstatic void tlb_remove_table_one(void *table)\n{\n\t/*\n\t * This isn't an RCU grace period and hence the page-tables cannot be\n\t * assumed to be actually RCU-freed.\n\t *\n\t * It is however sufficient for software page-table walkers that rely on\n\t * IRQ disabling. See the comment near struct mmu_table_batch.\n\t */\n\tsmp_call_function(tlb_remove_table_smp_sync, NULL, 1);\n\t__tlb_remove_table(table);\n}"
  },
  {
    "function_name": "tlb_remove_table_smp_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
    "lines": "165-168",
    "snippet": "static void tlb_remove_table_smp_sync(void *arg)\n{\n\t/* Simply deliver the interrupt */\n}",
    "includes": [
      "#include <asm/tlb.h>",
      "#include <asm/pgalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/smp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm_types.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/kernel.h>",
      "#include <linux/highmem.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nstatic void tlb_remove_table_smp_sync(void *arg)\n{\n\t/* Simply deliver the interrupt */\n}"
  },
  {
    "function_name": "tlb_table_invalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
    "lines": "153-163",
    "snippet": "static inline void tlb_table_invalidate(struct mmu_gather *tlb)\n{\n#ifdef CONFIG_HAVE_RCU_TABLE_INVALIDATE\n\t/*\n\t * Invalidate page-table caches used by hardware walkers. Then we still\n\t * need to RCU-sched wait while freeing the pages because software\n\t * walkers can still be in-flight.\n\t */\n\ttlb_flush_mmu_tlbonly(tlb);\n#endif\n}",
    "includes": [
      "#include <asm/tlb.h>",
      "#include <asm/pgalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/smp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm_types.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/kernel.h>",
      "#include <linux/highmem.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tlb_flush_mmu_tlbonly",
          "args": [
            "tlb"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nstatic inline void tlb_table_invalidate(struct mmu_gather *tlb)\n{\n#ifdef CONFIG_HAVE_RCU_TABLE_INVALIDATE\n\t/*\n\t * Invalidate page-table caches used by hardware walkers. Then we still\n\t * need to RCU-sched wait while freeing the pages because software\n\t * walkers can still be in-flight.\n\t */\n\ttlb_flush_mmu_tlbonly(tlb);\n#endif\n}"
  },
  {
    "function_name": "__tlb_remove_page_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
    "lines": "119-140",
    "snippet": "bool __tlb_remove_page_size(struct mmu_gather *tlb, struct page *page, int page_size)\n{\n\tstruct mmu_gather_batch *batch;\n\n\tVM_BUG_ON(!tlb->end);\n\tVM_WARN_ON(tlb->page_size != page_size);\n\n\tbatch = tlb->active;\n\t/*\n\t * Add the page and check if we are full. If so\n\t * force a flush.\n\t */\n\tbatch->pages[batch->nr++] = page;\n\tif (batch->nr == batch->max) {\n\t\tif (!tlb_next_batch(tlb))\n\t\t\treturn true;\n\t\tbatch = tlb->active;\n\t}\n\tVM_BUG_ON_PAGE(batch->nr > batch->max, page);\n\n\treturn false;\n}",
    "includes": [
      "#include <asm/tlb.h>",
      "#include <asm/pgalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/smp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm_types.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/kernel.h>",
      "#include <linux/highmem.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "batch->nr > batch->max",
            "page"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlb_next_batch",
          "args": [
            "tlb"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "tlb_next_batch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
          "lines": "16-42",
          "snippet": "static bool tlb_next_batch(struct mmu_gather *tlb)\n{\n\tstruct mmu_gather_batch *batch;\n\n\tbatch = tlb->active;\n\tif (batch->next) {\n\t\ttlb->active = batch->next;\n\t\treturn true;\n\t}\n\n\tif (tlb->batch_count == MAX_GATHER_BATCH_COUNT)\n\t\treturn false;\n\n\tbatch = (void *)__get_free_pages(GFP_NOWAIT | __GFP_NOWARN, 0);\n\tif (!batch)\n\t\treturn false;\n\n\ttlb->batch_count++;\n\tbatch->next = NULL;\n\tbatch->nr   = 0;\n\tbatch->max  = MAX_GATHER_BATCH;\n\n\ttlb->active->next = batch;\n\ttlb->active = batch;\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/tlb.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/smp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nstatic bool tlb_next_batch(struct mmu_gather *tlb)\n{\n\tstruct mmu_gather_batch *batch;\n\n\tbatch = tlb->active;\n\tif (batch->next) {\n\t\ttlb->active = batch->next;\n\t\treturn true;\n\t}\n\n\tif (tlb->batch_count == MAX_GATHER_BATCH_COUNT)\n\t\treturn false;\n\n\tbatch = (void *)__get_free_pages(GFP_NOWAIT | __GFP_NOWARN, 0);\n\tif (!batch)\n\t\treturn false;\n\n\ttlb->batch_count++;\n\tbatch->next = NULL;\n\tbatch->nr   = 0;\n\tbatch->max  = MAX_GATHER_BATCH;\n\n\ttlb->active->next = batch;\n\ttlb->active = batch;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_WARN_ON",
          "args": [
            "tlb->page_size != page_size"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!tlb->end"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nbool __tlb_remove_page_size(struct mmu_gather *tlb, struct page *page, int page_size)\n{\n\tstruct mmu_gather_batch *batch;\n\n\tVM_BUG_ON(!tlb->end);\n\tVM_WARN_ON(tlb->page_size != page_size);\n\n\tbatch = tlb->active;\n\t/*\n\t * Add the page and check if we are full. If so\n\t * force a flush.\n\t */\n\tbatch->pages[batch->nr++] = page;\n\tif (batch->nr == batch->max) {\n\t\tif (!tlb_next_batch(tlb))\n\t\t\treturn true;\n\t\tbatch = tlb->active;\n\t}\n\tVM_BUG_ON_PAGE(batch->nr > batch->max, page);\n\n\treturn false;\n}"
  },
  {
    "function_name": "arch_tlb_finish_mmu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
    "lines": "90-110",
    "snippet": "void arch_tlb_finish_mmu(struct mmu_gather *tlb,\n\t\tunsigned long start, unsigned long end, bool force)\n{\n\tstruct mmu_gather_batch *batch, *next;\n\n\tif (force) {\n\t\t__tlb_reset_range(tlb);\n\t\t__tlb_adjust_range(tlb, start, end - start);\n\t}\n\n\ttlb_flush_mmu(tlb);\n\n\t/* keep the page table cache within bounds */\n\tcheck_pgt_cache();\n\n\tfor (batch = tlb->local.next; batch; batch = next) {\n\t\tnext = batch->next;\n\t\tfree_pages((unsigned long)batch, 0);\n\t}\n\ttlb->local.next = NULL;\n}",
    "includes": [
      "#include <asm/tlb.h>",
      "#include <asm/pgalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/smp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm_types.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/kernel.h>",
      "#include <linux/highmem.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)batch",
            "0"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "free_pages_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4630-4639",
          "snippet": "void free_pages_exact(void *virt, size_t size)\n{\n\tunsigned long addr = (unsigned long)virt;\n\tunsigned long end = addr + PAGE_ALIGN(size);\n\n\twhile (addr < end) {\n\t\tfree_page(addr);\n\t\taddr += PAGE_SIZE;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid free_pages_exact(void *virt, size_t size)\n{\n\tunsigned long addr = (unsigned long)virt;\n\tunsigned long end = addr + PAGE_ALIGN(size);\n\n\twhile (addr < end) {\n\t\tfree_page(addr);\n\t\taddr += PAGE_SIZE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_pgt_cache",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlb_flush_mmu",
          "args": [
            "tlb"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "tlb_flush_mmu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
          "lines": "80-84",
          "snippet": "void tlb_flush_mmu(struct mmu_gather *tlb)\n{\n\ttlb_flush_mmu_tlbonly(tlb);\n\ttlb_flush_mmu_free(tlb);\n}",
          "includes": [
            "#include <asm/tlb.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/smp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid tlb_flush_mmu(struct mmu_gather *tlb)\n{\n\ttlb_flush_mmu_tlbonly(tlb);\n\ttlb_flush_mmu_free(tlb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__tlb_adjust_range",
          "args": [
            "tlb",
            "start",
            "end - start"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__tlb_reset_range",
          "args": [
            "tlb"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid arch_tlb_finish_mmu(struct mmu_gather *tlb,\n\t\tunsigned long start, unsigned long end, bool force)\n{\n\tstruct mmu_gather_batch *batch, *next;\n\n\tif (force) {\n\t\t__tlb_reset_range(tlb);\n\t\t__tlb_adjust_range(tlb, start, end - start);\n\t}\n\n\ttlb_flush_mmu(tlb);\n\n\t/* keep the page table cache within bounds */\n\tcheck_pgt_cache();\n\n\tfor (batch = tlb->local.next; batch; batch = next) {\n\t\tnext = batch->next;\n\t\tfree_pages((unsigned long)batch, 0);\n\t}\n\ttlb->local.next = NULL;\n}"
  },
  {
    "function_name": "tlb_flush_mmu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
    "lines": "80-84",
    "snippet": "void tlb_flush_mmu(struct mmu_gather *tlb)\n{\n\ttlb_flush_mmu_tlbonly(tlb);\n\ttlb_flush_mmu_free(tlb);\n}",
    "includes": [
      "#include <asm/tlb.h>",
      "#include <asm/pgalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/smp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm_types.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/kernel.h>",
      "#include <linux/highmem.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tlb_flush_mmu_free",
          "args": [
            "tlb"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "tlb_flush_mmu_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
          "lines": "66-78",
          "snippet": "void tlb_flush_mmu_free(struct mmu_gather *tlb)\n{\n\tstruct mmu_gather_batch *batch;\n\n#ifdef CONFIG_HAVE_RCU_TABLE_FREE\n\ttlb_table_flush(tlb);\n#endif\n\tfor (batch = &tlb->local; batch && batch->nr; batch = batch->next) {\n\t\tfree_pages_and_swap_cache(batch->pages, batch->nr);\n\t\tbatch->nr = 0;\n\t}\n\ttlb->active = &tlb->local;\n}",
          "includes": [
            "#include <asm/tlb.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/smp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid tlb_flush_mmu_free(struct mmu_gather *tlb)\n{\n\tstruct mmu_gather_batch *batch;\n\n#ifdef CONFIG_HAVE_RCU_TABLE_FREE\n\ttlb_table_flush(tlb);\n#endif\n\tfor (batch = &tlb->local; batch && batch->nr; batch = batch->next) {\n\t\tfree_pages_and_swap_cache(batch->pages, batch->nr);\n\t\tbatch->nr = 0;\n\t}\n\ttlb->active = &tlb->local;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlb_flush_mmu_tlbonly",
          "args": [
            "tlb"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid tlb_flush_mmu(struct mmu_gather *tlb)\n{\n\ttlb_flush_mmu_tlbonly(tlb);\n\ttlb_flush_mmu_free(tlb);\n}"
  },
  {
    "function_name": "tlb_flush_mmu_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
    "lines": "66-78",
    "snippet": "void tlb_flush_mmu_free(struct mmu_gather *tlb)\n{\n\tstruct mmu_gather_batch *batch;\n\n#ifdef CONFIG_HAVE_RCU_TABLE_FREE\n\ttlb_table_flush(tlb);\n#endif\n\tfor (batch = &tlb->local; batch && batch->nr; batch = batch->next) {\n\t\tfree_pages_and_swap_cache(batch->pages, batch->nr);\n\t\tbatch->nr = 0;\n\t}\n\ttlb->active = &tlb->local;\n}",
    "includes": [
      "#include <asm/tlb.h>",
      "#include <asm/pgalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/smp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm_types.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/kernel.h>",
      "#include <linux/highmem.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pages_and_swap_cache",
          "args": [
            "batch->pages",
            "batch->nr"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "free_pages_and_swap_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "287-296",
          "snippet": "void free_pages_and_swap_cache(struct page **pages, int nr)\n{\n\tstruct page **pagep = pages;\n\tint i;\n\n\tlru_add_drain();\n\tfor (i = 0; i < nr; i++)\n\t\tfree_swap_cache(pagep[i]);\n\trelease_pages(pagep, nr);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nvoid free_pages_and_swap_cache(struct page **pages, int nr)\n{\n\tstruct page **pagep = pages;\n\tint i;\n\n\tlru_add_drain();\n\tfor (i = 0; i < nr; i++)\n\t\tfree_swap_cache(pagep[i]);\n\trelease_pages(pagep, nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlb_table_flush",
          "args": [
            "tlb"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "tlb_table_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
          "lines": "196-205",
          "snippet": "void tlb_table_flush(struct mmu_gather *tlb)\n{\n\tstruct mmu_table_batch **batch = &tlb->batch;\n\n\tif (*batch) {\n\t\ttlb_table_invalidate(tlb);\n\t\tcall_rcu_sched(&(*batch)->rcu, tlb_remove_table_rcu);\n\t\t*batch = NULL;\n\t}\n}",
          "includes": [
            "#include <asm/tlb.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/smp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid tlb_table_flush(struct mmu_gather *tlb)\n{\n\tstruct mmu_table_batch **batch = &tlb->batch;\n\n\tif (*batch) {\n\t\ttlb_table_invalidate(tlb);\n\t\tcall_rcu_sched(&(*batch)->rcu, tlb_remove_table_rcu);\n\t\t*batch = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid tlb_flush_mmu_free(struct mmu_gather *tlb)\n{\n\tstruct mmu_gather_batch *batch;\n\n#ifdef CONFIG_HAVE_RCU_TABLE_FREE\n\ttlb_table_flush(tlb);\n#endif\n\tfor (batch = &tlb->local; batch && batch->nr; batch = batch->next) {\n\t\tfree_pages_and_swap_cache(batch->pages, batch->nr);\n\t\tbatch->nr = 0;\n\t}\n\ttlb->active = &tlb->local;\n}"
  },
  {
    "function_name": "arch_tlb_gather_mmu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
    "lines": "44-64",
    "snippet": "void arch_tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm,\n\t\t\t\tunsigned long start, unsigned long end)\n{\n\ttlb->mm = mm;\n\n\t/* Is it from 0 to ~0? */\n\ttlb->fullmm     = !(start | (end+1));\n\ttlb->need_flush_all = 0;\n\ttlb->local.next = NULL;\n\ttlb->local.nr   = 0;\n\ttlb->local.max  = ARRAY_SIZE(tlb->__pages);\n\ttlb->active     = &tlb->local;\n\ttlb->batch_count = 0;\n\n#ifdef CONFIG_HAVE_RCU_TABLE_FREE\n\ttlb->batch = NULL;\n#endif\n\ttlb->page_size = 0;\n\n\t__tlb_reset_range(tlb);\n}",
    "includes": [
      "#include <asm/tlb.h>",
      "#include <asm/pgalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/smp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm_types.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/kernel.h>",
      "#include <linux/highmem.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__tlb_reset_range",
          "args": [
            "tlb"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "tlb->__pages"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid arch_tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm,\n\t\t\t\tunsigned long start, unsigned long end)\n{\n\ttlb->mm = mm;\n\n\t/* Is it from 0 to ~0? */\n\ttlb->fullmm     = !(start | (end+1));\n\ttlb->need_flush_all = 0;\n\ttlb->local.next = NULL;\n\ttlb->local.nr   = 0;\n\ttlb->local.max  = ARRAY_SIZE(tlb->__pages);\n\ttlb->active     = &tlb->local;\n\ttlb->batch_count = 0;\n\n#ifdef CONFIG_HAVE_RCU_TABLE_FREE\n\ttlb->batch = NULL;\n#endif\n\ttlb->page_size = 0;\n\n\t__tlb_reset_range(tlb);\n}"
  },
  {
    "function_name": "tlb_next_batch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
    "lines": "16-42",
    "snippet": "static bool tlb_next_batch(struct mmu_gather *tlb)\n{\n\tstruct mmu_gather_batch *batch;\n\n\tbatch = tlb->active;\n\tif (batch->next) {\n\t\ttlb->active = batch->next;\n\t\treturn true;\n\t}\n\n\tif (tlb->batch_count == MAX_GATHER_BATCH_COUNT)\n\t\treturn false;\n\n\tbatch = (void *)__get_free_pages(GFP_NOWAIT | __GFP_NOWARN, 0);\n\tif (!batch)\n\t\treturn false;\n\n\ttlb->batch_count++;\n\tbatch->next = NULL;\n\tbatch->nr   = 0;\n\tbatch->max  = MAX_GATHER_BATCH;\n\n\ttlb->active->next = batch;\n\ttlb->active = batch;\n\n\treturn true;\n}",
    "includes": [
      "#include <asm/tlb.h>",
      "#include <asm/pgalloc.h>",
      "#include <linux/swap.h>",
      "#include <linux/smp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm_types.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/kernel.h>",
      "#include <linux/highmem.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_free_pages",
          "args": [
            "GFP_NOWAIT | __GFP_NOWARN",
            "0"
          ],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "__get_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4413-4421",
          "snippet": "unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order)\n{\n\tstruct page *page;\n\n\tpage = alloc_pages(gfp_mask & ~__GFP_HIGHMEM, order);\n\tif (!page)\n\t\treturn 0;\n\treturn (unsigned long) page_address(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nunsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order)\n{\n\tstruct page *page;\n\n\tpage = alloc_pages(gfp_mask & ~__GFP_HIGHMEM, order);\n\tif (!page)\n\t\treturn 0;\n\treturn (unsigned long) page_address(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nstatic bool tlb_next_batch(struct mmu_gather *tlb)\n{\n\tstruct mmu_gather_batch *batch;\n\n\tbatch = tlb->active;\n\tif (batch->next) {\n\t\ttlb->active = batch->next;\n\t\treturn true;\n\t}\n\n\tif (tlb->batch_count == MAX_GATHER_BATCH_COUNT)\n\t\treturn false;\n\n\tbatch = (void *)__get_free_pages(GFP_NOWAIT | __GFP_NOWARN, 0);\n\tif (!batch)\n\t\treturn false;\n\n\ttlb->batch_count++;\n\tbatch->next = NULL;\n\tbatch->nr   = 0;\n\tbatch->max  = MAX_GATHER_BATCH;\n\n\ttlb->active->next = batch;\n\ttlb->active = batch;\n\n\treturn true;\n}"
  }
]