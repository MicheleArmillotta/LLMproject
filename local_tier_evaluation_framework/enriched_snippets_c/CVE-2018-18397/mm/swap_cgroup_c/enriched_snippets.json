[
  {
    "function_name": "swap_cgroup_swapoff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_cgroup.c",
    "lines": "206-233",
    "snippet": "void swap_cgroup_swapoff(int type)\n{\n\tstruct page **map;\n\tunsigned long i, length;\n\tstruct swap_cgroup_ctrl *ctrl;\n\n\tif (!do_swap_account)\n\t\treturn;\n\n\tmutex_lock(&swap_cgroup_mutex);\n\tctrl = &swap_cgroup_ctrl[type];\n\tmap = ctrl->map;\n\tlength = ctrl->length;\n\tctrl->map = NULL;\n\tctrl->length = 0;\n\tmutex_unlock(&swap_cgroup_mutex);\n\n\tif (map) {\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tstruct page *page = map[i];\n\t\t\tif (page)\n\t\t\t\t__free_page(page);\n\t\t\tif (!(i % SWAP_CLUSTER_MAX))\n\t\t\t\tcond_resched();\n\t\t}\n\t\tvfree(map);\n\t}\n}",
    "includes": [
      "#include <linux/swapops.h> /* depends on mm.h include */",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(swap_cgroup_mutex);",
      "static struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "map"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "vfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "224-227",
          "snippet": "void vfree(const void *addr)\n{\n\tkfree(addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid vfree(const void *addr)\n{\n\tkfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "__free_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "280-291",
          "snippet": "static void __free_page_ext(unsigned long pfn)\n{\n\tstruct mem_section *ms;\n\tstruct page_ext *base;\n\n\tms = __pfn_to_section(pfn);\n\tif (!ms || !ms->page_ext)\n\t\treturn;\n\tbase = get_entry(ms->page_ext, pfn);\n\tfree_page_ext(base);\n\tms->page_ext = NULL;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic void __free_page_ext(unsigned long pfn)\n{\n\tstruct mem_section *ms;\n\tstruct page_ext *base;\n\n\tms = __pfn_to_section(pfn);\n\tif (!ms || !ms->page_ext)\n\t\treturn;\n\tbase = get_entry(ms->page_ext, pfn);\n\tfree_page_ext(base);\n\tms->page_ext = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&swap_cgroup_mutex"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&swap_cgroup_mutex"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swapops.h> /* depends on mm.h include */\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/swap_cgroup.h>\n\nstatic DEFINE_MUTEX(swap_cgroup_mutex);\nstatic struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];\n\nvoid swap_cgroup_swapoff(int type)\n{\n\tstruct page **map;\n\tunsigned long i, length;\n\tstruct swap_cgroup_ctrl *ctrl;\n\n\tif (!do_swap_account)\n\t\treturn;\n\n\tmutex_lock(&swap_cgroup_mutex);\n\tctrl = &swap_cgroup_ctrl[type];\n\tmap = ctrl->map;\n\tlength = ctrl->length;\n\tctrl->map = NULL;\n\tctrl->length = 0;\n\tmutex_unlock(&swap_cgroup_mutex);\n\n\tif (map) {\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tstruct page *page = map[i];\n\t\t\tif (page)\n\t\t\t\t__free_page(page);\n\t\t\tif (!(i % SWAP_CLUSTER_MAX))\n\t\t\t\tcond_resched();\n\t\t}\n\t\tvfree(map);\n\t}\n}"
  },
  {
    "function_name": "swap_cgroup_swapon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_cgroup.c",
    "lines": "167-204",
    "snippet": "int swap_cgroup_swapon(int type, unsigned long max_pages)\n{\n\tvoid *array;\n\tunsigned long array_size;\n\tunsigned long length;\n\tstruct swap_cgroup_ctrl *ctrl;\n\n\tif (!do_swap_account)\n\t\treturn 0;\n\n\tlength = DIV_ROUND_UP(max_pages, SC_PER_PAGE);\n\tarray_size = length * sizeof(void *);\n\n\tarray = vzalloc(array_size);\n\tif (!array)\n\t\tgoto nomem;\n\n\tctrl = &swap_cgroup_ctrl[type];\n\tmutex_lock(&swap_cgroup_mutex);\n\tctrl->length = length;\n\tctrl->map = array;\n\tspin_lock_init(&ctrl->lock);\n\tif (swap_cgroup_prepare(type)) {\n\t\t/* memory shortage */\n\t\tctrl->map = NULL;\n\t\tctrl->length = 0;\n\t\tmutex_unlock(&swap_cgroup_mutex);\n\t\tvfree(array);\n\t\tgoto nomem;\n\t}\n\tmutex_unlock(&swap_cgroup_mutex);\n\n\treturn 0;\nnomem:\n\tpr_info(\"couldn't allocate enough memory for swap_cgroup\\n\");\n\tpr_info(\"swap_cgroup can be disabled by swapaccount=0 boot option\\n\");\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/swapops.h> /* depends on mm.h include */",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap_cgroup.h>"
    ],
    "macros_used": [
      "#define SC_PER_PAGE\t(PAGE_SIZE/sizeof(struct swap_cgroup))"
    ],
    "globals_used": [
      "static DEFINE_MUTEX(swap_cgroup_mutex);",
      "static struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"swap_cgroup can be disabled by swapaccount=0 boot option\\n\""
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"couldn't allocate enough memory for swap_cgroup\\n\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&swap_cgroup_mutex"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "array"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "vfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "224-227",
          "snippet": "void vfree(const void *addr)\n{\n\tkfree(addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid vfree(const void *addr)\n{\n\tkfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&swap_cgroup_mutex"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_cgroup_prepare",
          "args": [
            "type"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "swap_cgroup_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_cgroup.c",
          "lines": "39-63",
          "snippet": "static int swap_cgroup_prepare(int type)\n{\n\tstruct page *page;\n\tstruct swap_cgroup_ctrl *ctrl;\n\tunsigned long idx, max;\n\n\tctrl = &swap_cgroup_ctrl[type];\n\n\tfor (idx = 0; idx < ctrl->length; idx++) {\n\t\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\t\tif (!page)\n\t\t\tgoto not_enough_page;\n\t\tctrl->map[idx] = page;\n\n\t\tif (!(idx % SWAP_CLUSTER_MAX))\n\t\t\tcond_resched();\n\t}\n\treturn 0;\nnot_enough_page:\n\tmax = idx;\n\tfor (idx = 0; idx < max; idx++)\n\t\t__free_page(ctrl->map[idx]);\n\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/swapops.h> /* depends on mm.h include */",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapops.h> /* depends on mm.h include */\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/swap_cgroup.h>\n\nstatic struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];\n\nstatic int swap_cgroup_prepare(int type)\n{\n\tstruct page *page;\n\tstruct swap_cgroup_ctrl *ctrl;\n\tunsigned long idx, max;\n\n\tctrl = &swap_cgroup_ctrl[type];\n\n\tfor (idx = 0; idx < ctrl->length; idx++) {\n\t\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\t\tif (!page)\n\t\t\tgoto not_enough_page;\n\t\tctrl->map[idx] = page;\n\n\t\tif (!(idx % SWAP_CLUSTER_MAX))\n\t\t\tcond_resched();\n\t}\n\treturn 0;\nnot_enough_page:\n\tmax = idx;\n\tfor (idx = 0; idx < max; idx++)\n\t\t__free_page(ctrl->map[idx]);\n\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ctrl->lock"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&swap_cgroup_mutex"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vzalloc",
          "args": [
            "array_size"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "vzalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "325-329",
          "snippet": "void *vzalloc(unsigned long size)\n{\n\treturn __vmalloc(size, GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO,\n\t\t\tPAGE_KERNEL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid *vzalloc(unsigned long size)\n{\n\treturn __vmalloc(size, GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO,\n\t\t\tPAGE_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "max_pages",
            "SC_PER_PAGE"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swapops.h> /* depends on mm.h include */\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/swap_cgroup.h>\n\n#define SC_PER_PAGE\t(PAGE_SIZE/sizeof(struct swap_cgroup))\n\nstatic DEFINE_MUTEX(swap_cgroup_mutex);\nstatic struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];\n\nint swap_cgroup_swapon(int type, unsigned long max_pages)\n{\n\tvoid *array;\n\tunsigned long array_size;\n\tunsigned long length;\n\tstruct swap_cgroup_ctrl *ctrl;\n\n\tif (!do_swap_account)\n\t\treturn 0;\n\n\tlength = DIV_ROUND_UP(max_pages, SC_PER_PAGE);\n\tarray_size = length * sizeof(void *);\n\n\tarray = vzalloc(array_size);\n\tif (!array)\n\t\tgoto nomem;\n\n\tctrl = &swap_cgroup_ctrl[type];\n\tmutex_lock(&swap_cgroup_mutex);\n\tctrl->length = length;\n\tctrl->map = array;\n\tspin_lock_init(&ctrl->lock);\n\tif (swap_cgroup_prepare(type)) {\n\t\t/* memory shortage */\n\t\tctrl->map = NULL;\n\t\tctrl->length = 0;\n\t\tmutex_unlock(&swap_cgroup_mutex);\n\t\tvfree(array);\n\t\tgoto nomem;\n\t}\n\tmutex_unlock(&swap_cgroup_mutex);\n\n\treturn 0;\nnomem:\n\tpr_info(\"couldn't allocate enough memory for swap_cgroup\\n\");\n\tpr_info(\"swap_cgroup can be disabled by swapaccount=0 boot option\\n\");\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "lookup_swap_cgroup_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_cgroup.c",
    "lines": "162-165",
    "snippet": "unsigned short lookup_swap_cgroup_id(swp_entry_t ent)\n{\n\treturn lookup_swap_cgroup(ent, NULL)->id;\n}",
    "includes": [
      "#include <linux/swapops.h> /* depends on mm.h include */",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lookup_swap_cgroup",
          "args": [
            "ent",
            "NULL"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_swap_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_cgroup.c",
          "lines": "76-86",
          "snippet": "static struct swap_cgroup *lookup_swap_cgroup(swp_entry_t ent,\n\t\t\t\t\tstruct swap_cgroup_ctrl **ctrlp)\n{\n\tpgoff_t offset = swp_offset(ent);\n\tstruct swap_cgroup_ctrl *ctrl;\n\n\tctrl = &swap_cgroup_ctrl[swp_type(ent)];\n\tif (ctrlp)\n\t\t*ctrlp = ctrl;\n\treturn __lookup_swap_cgroup(ctrl, offset);\n}",
          "includes": [
            "#include <linux/swapops.h> /* depends on mm.h include */",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapops.h> /* depends on mm.h include */\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/swap_cgroup.h>\n\nstatic struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];\n\nstatic struct swap_cgroup *lookup_swap_cgroup(swp_entry_t ent,\n\t\t\t\t\tstruct swap_cgroup_ctrl **ctrlp)\n{\n\tpgoff_t offset = swp_offset(ent);\n\tstruct swap_cgroup_ctrl *ctrl;\n\n\tctrl = &swap_cgroup_ctrl[swp_type(ent)];\n\tif (ctrlp)\n\t\t*ctrlp = ctrl;\n\treturn __lookup_swap_cgroup(ctrl, offset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swapops.h> /* depends on mm.h include */\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/swap_cgroup.h>\n\nunsigned short lookup_swap_cgroup_id(swp_entry_t ent)\n{\n\treturn lookup_swap_cgroup(ent, NULL)->id;\n}"
  },
  {
    "function_name": "swap_cgroup_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_cgroup.c",
    "lines": "126-154",
    "snippet": "unsigned short swap_cgroup_record(swp_entry_t ent, unsigned short id,\n\t\t\t\t  unsigned int nr_ents)\n{\n\tstruct swap_cgroup_ctrl *ctrl;\n\tstruct swap_cgroup *sc;\n\tunsigned short old;\n\tunsigned long flags;\n\tpgoff_t offset = swp_offset(ent);\n\tpgoff_t end = offset + nr_ents;\n\n\tsc = lookup_swap_cgroup(ent, &ctrl);\n\n\tspin_lock_irqsave(&ctrl->lock, flags);\n\told = sc->id;\n\tfor (;;) {\n\t\tVM_BUG_ON(sc->id != old);\n\t\tsc->id = id;\n\t\toffset++;\n\t\tif (offset == end)\n\t\t\tbreak;\n\t\tif (offset % SC_PER_PAGE)\n\t\t\tsc++;\n\t\telse\n\t\t\tsc = __lookup_swap_cgroup(ctrl, offset);\n\t}\n\tspin_unlock_irqrestore(&ctrl->lock, flags);\n\n\treturn old;\n}",
    "includes": [
      "#include <linux/swapops.h> /* depends on mm.h include */",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap_cgroup.h>"
    ],
    "macros_used": [
      "#define SC_PER_PAGE\t(PAGE_SIZE/sizeof(struct swap_cgroup))"
    ],
    "globals_used": [
      "static struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ctrl->lock",
            "flags"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__lookup_swap_cgroup",
          "args": [
            "ctrl",
            "offset"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_swap_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_cgroup.c",
          "lines": "65-74",
          "snippet": "static struct swap_cgroup *__lookup_swap_cgroup(struct swap_cgroup_ctrl *ctrl,\n\t\t\t\t\t\tpgoff_t offset)\n{\n\tstruct page *mappage;\n\tstruct swap_cgroup *sc;\n\n\tmappage = ctrl->map[offset / SC_PER_PAGE];\n\tsc = page_address(mappage);\n\treturn sc + offset % SC_PER_PAGE;\n}",
          "includes": [
            "#include <linux/swapops.h> /* depends on mm.h include */",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap_cgroup.h>"
          ],
          "macros_used": [
            "#define SC_PER_PAGE\t(PAGE_SIZE/sizeof(struct swap_cgroup))"
          ],
          "globals_used": [
            "static struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapops.h> /* depends on mm.h include */\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/swap_cgroup.h>\n\n#define SC_PER_PAGE\t(PAGE_SIZE/sizeof(struct swap_cgroup))\n\nstatic struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];\n\nstatic struct swap_cgroup *__lookup_swap_cgroup(struct swap_cgroup_ctrl *ctrl,\n\t\t\t\t\t\tpgoff_t offset)\n{\n\tstruct page *mappage;\n\tstruct swap_cgroup *sc;\n\n\tmappage = ctrl->map[offset / SC_PER_PAGE];\n\tsc = page_address(mappage);\n\treturn sc + offset % SC_PER_PAGE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "sc->id != old"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ctrl->lock",
            "flags"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_swap_cgroup",
          "args": [
            "ent",
            "&ctrl"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_swap_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_cgroup.c",
          "lines": "76-86",
          "snippet": "static struct swap_cgroup *lookup_swap_cgroup(swp_entry_t ent,\n\t\t\t\t\tstruct swap_cgroup_ctrl **ctrlp)\n{\n\tpgoff_t offset = swp_offset(ent);\n\tstruct swap_cgroup_ctrl *ctrl;\n\n\tctrl = &swap_cgroup_ctrl[swp_type(ent)];\n\tif (ctrlp)\n\t\t*ctrlp = ctrl;\n\treturn __lookup_swap_cgroup(ctrl, offset);\n}",
          "includes": [
            "#include <linux/swapops.h> /* depends on mm.h include */",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapops.h> /* depends on mm.h include */\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/swap_cgroup.h>\n\nstatic struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];\n\nstatic struct swap_cgroup *lookup_swap_cgroup(swp_entry_t ent,\n\t\t\t\t\tstruct swap_cgroup_ctrl **ctrlp)\n{\n\tpgoff_t offset = swp_offset(ent);\n\tstruct swap_cgroup_ctrl *ctrl;\n\n\tctrl = &swap_cgroup_ctrl[swp_type(ent)];\n\tif (ctrlp)\n\t\t*ctrlp = ctrl;\n\treturn __lookup_swap_cgroup(ctrl, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "ent"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swapops.h> /* depends on mm.h include */\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/swap_cgroup.h>\n\n#define SC_PER_PAGE\t(PAGE_SIZE/sizeof(struct swap_cgroup))\n\nstatic struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];\n\nunsigned short swap_cgroup_record(swp_entry_t ent, unsigned short id,\n\t\t\t\t  unsigned int nr_ents)\n{\n\tstruct swap_cgroup_ctrl *ctrl;\n\tstruct swap_cgroup *sc;\n\tunsigned short old;\n\tunsigned long flags;\n\tpgoff_t offset = swp_offset(ent);\n\tpgoff_t end = offset + nr_ents;\n\n\tsc = lookup_swap_cgroup(ent, &ctrl);\n\n\tspin_lock_irqsave(&ctrl->lock, flags);\n\told = sc->id;\n\tfor (;;) {\n\t\tVM_BUG_ON(sc->id != old);\n\t\tsc->id = id;\n\t\toffset++;\n\t\tif (offset == end)\n\t\t\tbreak;\n\t\tif (offset % SC_PER_PAGE)\n\t\t\tsc++;\n\t\telse\n\t\t\tsc = __lookup_swap_cgroup(ctrl, offset);\n\t}\n\tspin_unlock_irqrestore(&ctrl->lock, flags);\n\n\treturn old;\n}"
  },
  {
    "function_name": "swap_cgroup_cmpxchg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_cgroup.c",
    "lines": "97-115",
    "snippet": "unsigned short swap_cgroup_cmpxchg(swp_entry_t ent,\n\t\t\t\t\tunsigned short old, unsigned short new)\n{\n\tstruct swap_cgroup_ctrl *ctrl;\n\tstruct swap_cgroup *sc;\n\tunsigned long flags;\n\tunsigned short retval;\n\n\tsc = lookup_swap_cgroup(ent, &ctrl);\n\n\tspin_lock_irqsave(&ctrl->lock, flags);\n\tretval = sc->id;\n\tif (retval == old)\n\t\tsc->id = new;\n\telse\n\t\tretval = 0;\n\tspin_unlock_irqrestore(&ctrl->lock, flags);\n\treturn retval;\n}",
    "includes": [
      "#include <linux/swapops.h> /* depends on mm.h include */",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ctrl->lock",
            "flags"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ctrl->lock",
            "flags"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_swap_cgroup",
          "args": [
            "ent",
            "&ctrl"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_swap_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_cgroup.c",
          "lines": "76-86",
          "snippet": "static struct swap_cgroup *lookup_swap_cgroup(swp_entry_t ent,\n\t\t\t\t\tstruct swap_cgroup_ctrl **ctrlp)\n{\n\tpgoff_t offset = swp_offset(ent);\n\tstruct swap_cgroup_ctrl *ctrl;\n\n\tctrl = &swap_cgroup_ctrl[swp_type(ent)];\n\tif (ctrlp)\n\t\t*ctrlp = ctrl;\n\treturn __lookup_swap_cgroup(ctrl, offset);\n}",
          "includes": [
            "#include <linux/swapops.h> /* depends on mm.h include */",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapops.h> /* depends on mm.h include */\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/swap_cgroup.h>\n\nstatic struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];\n\nstatic struct swap_cgroup *lookup_swap_cgroup(swp_entry_t ent,\n\t\t\t\t\tstruct swap_cgroup_ctrl **ctrlp)\n{\n\tpgoff_t offset = swp_offset(ent);\n\tstruct swap_cgroup_ctrl *ctrl;\n\n\tctrl = &swap_cgroup_ctrl[swp_type(ent)];\n\tif (ctrlp)\n\t\t*ctrlp = ctrl;\n\treturn __lookup_swap_cgroup(ctrl, offset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swapops.h> /* depends on mm.h include */\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/swap_cgroup.h>\n\nstatic struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];\n\nunsigned short swap_cgroup_cmpxchg(swp_entry_t ent,\n\t\t\t\t\tunsigned short old, unsigned short new)\n{\n\tstruct swap_cgroup_ctrl *ctrl;\n\tstruct swap_cgroup *sc;\n\tunsigned long flags;\n\tunsigned short retval;\n\n\tsc = lookup_swap_cgroup(ent, &ctrl);\n\n\tspin_lock_irqsave(&ctrl->lock, flags);\n\tretval = sc->id;\n\tif (retval == old)\n\t\tsc->id = new;\n\telse\n\t\tretval = 0;\n\tspin_unlock_irqrestore(&ctrl->lock, flags);\n\treturn retval;\n}"
  },
  {
    "function_name": "lookup_swap_cgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_cgroup.c",
    "lines": "76-86",
    "snippet": "static struct swap_cgroup *lookup_swap_cgroup(swp_entry_t ent,\n\t\t\t\t\tstruct swap_cgroup_ctrl **ctrlp)\n{\n\tpgoff_t offset = swp_offset(ent);\n\tstruct swap_cgroup_ctrl *ctrl;\n\n\tctrl = &swap_cgroup_ctrl[swp_type(ent)];\n\tif (ctrlp)\n\t\t*ctrlp = ctrl;\n\treturn __lookup_swap_cgroup(ctrl, offset);\n}",
    "includes": [
      "#include <linux/swapops.h> /* depends on mm.h include */",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__lookup_swap_cgroup",
          "args": [
            "ctrl",
            "offset"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_swap_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_cgroup.c",
          "lines": "65-74",
          "snippet": "static struct swap_cgroup *__lookup_swap_cgroup(struct swap_cgroup_ctrl *ctrl,\n\t\t\t\t\t\tpgoff_t offset)\n{\n\tstruct page *mappage;\n\tstruct swap_cgroup *sc;\n\n\tmappage = ctrl->map[offset / SC_PER_PAGE];\n\tsc = page_address(mappage);\n\treturn sc + offset % SC_PER_PAGE;\n}",
          "includes": [
            "#include <linux/swapops.h> /* depends on mm.h include */",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap_cgroup.h>"
          ],
          "macros_used": [
            "#define SC_PER_PAGE\t(PAGE_SIZE/sizeof(struct swap_cgroup))"
          ],
          "globals_used": [
            "static struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapops.h> /* depends on mm.h include */\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/swap_cgroup.h>\n\n#define SC_PER_PAGE\t(PAGE_SIZE/sizeof(struct swap_cgroup))\n\nstatic struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];\n\nstatic struct swap_cgroup *__lookup_swap_cgroup(struct swap_cgroup_ctrl *ctrl,\n\t\t\t\t\t\tpgoff_t offset)\n{\n\tstruct page *mappage;\n\tstruct swap_cgroup *sc;\n\n\tmappage = ctrl->map[offset / SC_PER_PAGE];\n\tsc = page_address(mappage);\n\treturn sc + offset % SC_PER_PAGE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swp_type",
          "args": [
            "ent"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "ent"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swapops.h> /* depends on mm.h include */\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/swap_cgroup.h>\n\nstatic struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];\n\nstatic struct swap_cgroup *lookup_swap_cgroup(swp_entry_t ent,\n\t\t\t\t\tstruct swap_cgroup_ctrl **ctrlp)\n{\n\tpgoff_t offset = swp_offset(ent);\n\tstruct swap_cgroup_ctrl *ctrl;\n\n\tctrl = &swap_cgroup_ctrl[swp_type(ent)];\n\tif (ctrlp)\n\t\t*ctrlp = ctrl;\n\treturn __lookup_swap_cgroup(ctrl, offset);\n}"
  },
  {
    "function_name": "__lookup_swap_cgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_cgroup.c",
    "lines": "65-74",
    "snippet": "static struct swap_cgroup *__lookup_swap_cgroup(struct swap_cgroup_ctrl *ctrl,\n\t\t\t\t\t\tpgoff_t offset)\n{\n\tstruct page *mappage;\n\tstruct swap_cgroup *sc;\n\n\tmappage = ctrl->map[offset / SC_PER_PAGE];\n\tsc = page_address(mappage);\n\treturn sc + offset % SC_PER_PAGE;\n}",
    "includes": [
      "#include <linux/swapops.h> /* depends on mm.h include */",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap_cgroup.h>"
    ],
    "macros_used": [
      "#define SC_PER_PAGE\t(PAGE_SIZE/sizeof(struct swap_cgroup))"
    ],
    "globals_used": [
      "static struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "mappage"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swapops.h> /* depends on mm.h include */\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/swap_cgroup.h>\n\n#define SC_PER_PAGE\t(PAGE_SIZE/sizeof(struct swap_cgroup))\n\nstatic struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];\n\nstatic struct swap_cgroup *__lookup_swap_cgroup(struct swap_cgroup_ctrl *ctrl,\n\t\t\t\t\t\tpgoff_t offset)\n{\n\tstruct page *mappage;\n\tstruct swap_cgroup *sc;\n\n\tmappage = ctrl->map[offset / SC_PER_PAGE];\n\tsc = page_address(mappage);\n\treturn sc + offset % SC_PER_PAGE;\n}"
  },
  {
    "function_name": "swap_cgroup_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_cgroup.c",
    "lines": "39-63",
    "snippet": "static int swap_cgroup_prepare(int type)\n{\n\tstruct page *page;\n\tstruct swap_cgroup_ctrl *ctrl;\n\tunsigned long idx, max;\n\n\tctrl = &swap_cgroup_ctrl[type];\n\n\tfor (idx = 0; idx < ctrl->length; idx++) {\n\t\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\t\tif (!page)\n\t\t\tgoto not_enough_page;\n\t\tctrl->map[idx] = page;\n\n\t\tif (!(idx % SWAP_CLUSTER_MAX))\n\t\t\tcond_resched();\n\t}\n\treturn 0;\nnot_enough_page:\n\tmax = idx;\n\tfor (idx = 0; idx < max; idx++)\n\t\t__free_page(ctrl->map[idx]);\n\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/swapops.h> /* depends on mm.h include */",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/swap_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "ctrl->map[idx]"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "__free_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "280-291",
          "snippet": "static void __free_page_ext(unsigned long pfn)\n{\n\tstruct mem_section *ms;\n\tstruct page_ext *base;\n\n\tms = __pfn_to_section(pfn);\n\tif (!ms || !ms->page_ext)\n\t\treturn;\n\tbase = get_entry(ms->page_ext, pfn);\n\tfree_page_ext(base);\n\tms->page_ext = NULL;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic void __free_page_ext(unsigned long pfn)\n{\n\tstruct mem_section *ms;\n\tstruct page_ext *base;\n\n\tms = __pfn_to_section(pfn);\n\tif (!ms || !ms->page_ext)\n\t\treturn;\n\tbase = get_entry(ms->page_ext, pfn);\n\tfree_page_ext(base);\n\tms->page_ext = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL | __GFP_ZERO"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_hstate_alloc_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2163-2184",
          "snippet": "static void __init hugetlb_hstate_alloc_pages(struct hstate *h)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < h->max_huge_pages; ++i) {\n\t\tif (hstate_is_gigantic(h)) {\n\t\t\tif (!alloc_bootmem_huge_page(h))\n\t\t\t\tbreak;\n\t\t} else if (!alloc_pool_huge_page(h,\n\t\t\t\t\t &node_states[N_MEMORY]))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\tif (i < h->max_huge_pages) {\n\t\tchar buf[32];\n\n\t\tstring_get_size(huge_page_size(h), 1, STRING_UNITS_2, buf, 32);\n\t\tpr_warn(\"HugeTLB: allocating %lu of page size %s failed.  Only allocated %lu hugepages.\\n\",\n\t\t\th->max_huge_pages, buf, i);\n\t\th->max_huge_pages = i;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void __init hugetlb_hstate_alloc_pages(struct hstate *h)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < h->max_huge_pages; ++i) {\n\t\tif (hstate_is_gigantic(h)) {\n\t\t\tif (!alloc_bootmem_huge_page(h))\n\t\t\t\tbreak;\n\t\t} else if (!alloc_pool_huge_page(h,\n\t\t\t\t\t &node_states[N_MEMORY]))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\tif (i < h->max_huge_pages) {\n\t\tchar buf[32];\n\n\t\tstring_get_size(huge_page_size(h), 1, STRING_UNITS_2, buf, 32);\n\t\tpr_warn(\"HugeTLB: allocating %lu of page size %s failed.  Only allocated %lu hugepages.\\n\",\n\t\t\th->max_huge_pages, buf, i);\n\t\th->max_huge_pages = i;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swapops.h> /* depends on mm.h include */\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/swap_cgroup.h>\n\nstatic struct swap_cgroup_ctrl swap_cgroup_ctrl[MAX_SWAPFILES];\n\nstatic int swap_cgroup_prepare(int type)\n{\n\tstruct page *page;\n\tstruct swap_cgroup_ctrl *ctrl;\n\tunsigned long idx, max;\n\n\tctrl = &swap_cgroup_ctrl[type];\n\n\tfor (idx = 0; idx < ctrl->length; idx++) {\n\t\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\t\tif (!page)\n\t\t\tgoto not_enough_page;\n\t\tctrl->map[idx] = page;\n\n\t\tif (!(idx % SWAP_CLUSTER_MAX))\n\t\t\tcond_resched();\n\t}\n\treturn 0;\nnot_enough_page:\n\tmax = idx;\n\tfor (idx = 0; idx < max; idx++)\n\t\t__free_page(ctrl->map[idx]);\n\n\treturn -ENOMEM;\n}"
  }
]