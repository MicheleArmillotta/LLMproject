[
  {
    "function_name": "cache_random_seq_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
    "lines": "528-528",
    "snippet": "static inline void cache_random_seq_destroy(struct kmem_cache *cachep) { }",
    "includes": [
      "#include <linux/sched/mm.h>",
      "#include <linux/random.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/slub_def.h>",
      "#include <linux/slab_def.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline void cache_random_seq_destroy(struct kmem_cache *cachep) { }"
  },
  {
    "function_name": "cache_random_seq_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
    "lines": "523-527",
    "snippet": "static inline int cache_random_seq_create(struct kmem_cache *cachep,\n\t\t\t\t\tunsigned int count, gfp_t gfp)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sched/mm.h>",
      "#include <linux/random.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/slub_def.h>",
      "#include <linux/slab_def.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline int cache_random_seq_create(struct kmem_cache *cachep,\n\t\t\t\t\tunsigned int count, gfp_t gfp)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "dump_unreclaimable_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
    "lines": "511-513",
    "snippet": "static inline void dump_unreclaimable_slab(void)\n{\n}",
    "includes": [
      "#include <linux/sched/mm.h>",
      "#include <linux/random.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/slub_def.h>",
      "#include <linux/slab_def.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline void dump_unreclaimable_slab(void)\n{\n}"
  },
  {
    "function_name": "get_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
    "lines": "485-488",
    "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
    "includes": [
      "#include <linux/sched/mm.h>",
      "#include <linux/random.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/slub_def.h>",
      "#include <linux/slab_def.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
  },
  {
    "function_name": "slab_post_alloc_hook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
    "lines": "433-449",
    "snippet": "static inline void slab_post_alloc_hook(struct kmem_cache *s, gfp_t flags,\n\t\t\t\t\tsize_t size, void **p)\n{\n\tsize_t i;\n\n\tflags &= gfp_allowed_mask;\n\tfor (i = 0; i < size; i++) {\n\t\tvoid *object = p[i];\n\n\t\tkmemleak_alloc_recursive(object, s->object_size, 1,\n\t\t\t\t\t s->flags, flags);\n\t\tkasan_slab_alloc(s, object, flags);\n\t}\n\n\tif (memcg_kmem_enabled())\n\t\tmemcg_kmem_put_cache(s);\n}",
    "includes": [
      "#include <linux/sched/mm.h>",
      "#include <linux/random.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/slub_def.h>",
      "#include <linux/slab_def.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcg_kmem_put_cache",
          "args": [
            "s"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_kmem_put_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2546-2550",
          "snippet": "void memcg_kmem_put_cache(struct kmem_cache *cachep)\n{\n\tif (!is_root_cache(cachep))\n\t\tcss_put(&cachep->memcg_params.memcg->css);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid memcg_kmem_put_cache(struct kmem_cache *cachep)\n{\n\tif (!is_root_cache(cachep))\n\t\tcss_put(&cachep->memcg_params.memcg->css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_kmem_enabled",
          "args": [],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasan_slab_alloc",
          "args": [
            "s",
            "object",
            "flags"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_slab_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "488-491",
          "snippet": "void kasan_slab_alloc(struct kmem_cache *cache, void *object, gfp_t flags)\n{\n\tkasan_kmalloc(cache, object, cache->object_size, flags);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_slab_alloc(struct kmem_cache *cache, void *object, gfp_t flags)\n{\n\tkasan_kmalloc(cache, object, cache->object_size, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_alloc_recursive",
          "args": [
            "object",
            "s->object_size",
            "1",
            "s->flags",
            "flags"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline void slab_post_alloc_hook(struct kmem_cache *s, gfp_t flags,\n\t\t\t\t\tsize_t size, void **p)\n{\n\tsize_t i;\n\n\tflags &= gfp_allowed_mask;\n\tfor (i = 0; i < size; i++) {\n\t\tvoid *object = p[i];\n\n\t\tkmemleak_alloc_recursive(object, s->object_size, 1,\n\t\t\t\t\t s->flags, flags);\n\t\tkasan_slab_alloc(s, object, flags);\n\t}\n\n\tif (memcg_kmem_enabled())\n\t\tmemcg_kmem_put_cache(s);\n}"
  },
  {
    "function_name": "slab_pre_alloc_hook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
    "lines": "413-431",
    "snippet": "static inline struct kmem_cache *slab_pre_alloc_hook(struct kmem_cache *s,\n\t\t\t\t\t\t     gfp_t flags)\n{\n\tflags &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(flags);\n\tfs_reclaim_release(flags);\n\n\tmight_sleep_if(gfpflags_allow_blocking(flags));\n\n\tif (should_failslab(s, flags))\n\t\treturn NULL;\n\n\tif (memcg_kmem_enabled() &&\n\t    ((flags & __GFP_ACCOUNT) || (s->flags & SLAB_ACCOUNT)))\n\t\treturn memcg_kmem_get_cache(s);\n\n\treturn s;\n}",
    "includes": [
      "#include <linux/sched/mm.h>",
      "#include <linux/random.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/slub_def.h>",
      "#include <linux/slab_def.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcg_kmem_get_cache",
          "args": [
            "s"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_kmem_get_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2504-2540",
          "snippet": "struct kmem_cache *memcg_kmem_get_cache(struct kmem_cache *cachep)\n{\n\tstruct mem_cgroup *memcg;\n\tstruct kmem_cache *memcg_cachep;\n\tint kmemcg_id;\n\n\tVM_BUG_ON(!is_root_cache(cachep));\n\n\tif (memcg_kmem_bypass())\n\t\treturn cachep;\n\n\tmemcg = get_mem_cgroup_from_current();\n\tkmemcg_id = READ_ONCE(memcg->kmemcg_id);\n\tif (kmemcg_id < 0)\n\t\tgoto out;\n\n\tmemcg_cachep = cache_from_memcg_idx(cachep, kmemcg_id);\n\tif (likely(memcg_cachep))\n\t\treturn memcg_cachep;\n\n\t/*\n\t * If we are in a safe context (can wait, and not in interrupt\n\t * context), we could be be predictable and return right away.\n\t * This would guarantee that the allocation being performed\n\t * already belongs in the new cache.\n\t *\n\t * However, there are some clashes that can arrive from locking.\n\t * For instance, because we acquire the slab_mutex while doing\n\t * memcg_create_kmem_cache, this means no further allocation\n\t * could happen with the slab_mutex held. So it's better to\n\t * defer everything.\n\t */\n\tmemcg_schedule_kmem_cache_create(memcg, cachep);\nout:\n\tcss_put(&memcg->css);\n\treturn cachep;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct kmem_cache *memcg_kmem_get_cache(struct kmem_cache *cachep)\n{\n\tstruct mem_cgroup *memcg;\n\tstruct kmem_cache *memcg_cachep;\n\tint kmemcg_id;\n\n\tVM_BUG_ON(!is_root_cache(cachep));\n\n\tif (memcg_kmem_bypass())\n\t\treturn cachep;\n\n\tmemcg = get_mem_cgroup_from_current();\n\tkmemcg_id = READ_ONCE(memcg->kmemcg_id);\n\tif (kmemcg_id < 0)\n\t\tgoto out;\n\n\tmemcg_cachep = cache_from_memcg_idx(cachep, kmemcg_id);\n\tif (likely(memcg_cachep))\n\t\treturn memcg_cachep;\n\n\t/*\n\t * If we are in a safe context (can wait, and not in interrupt\n\t * context), we could be be predictable and return right away.\n\t * This would guarantee that the allocation being performed\n\t * already belongs in the new cache.\n\t *\n\t * However, there are some clashes that can arrive from locking.\n\t * For instance, because we acquire the slab_mutex while doing\n\t * memcg_create_kmem_cache, this means no further allocation\n\t * could happen with the slab_mutex held. So it's better to\n\t * defer everything.\n\t */\n\tmemcg_schedule_kmem_cache_create(memcg, cachep);\nout:\n\tcss_put(&memcg->css);\n\treturn cachep;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_kmem_enabled",
          "args": [],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "should_failslab",
          "args": [
            "s",
            "flags"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "__should_failslab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/failslab.c",
          "lines": "17-33",
          "snippet": "bool __should_failslab(struct kmem_cache *s, gfp_t gfpflags)\n{\n\t/* No fault-injection for bootstrap cache */\n\tif (unlikely(s == kmem_cache))\n\t\treturn false;\n\n\tif (gfpflags & __GFP_NOFAIL)\n\t\treturn false;\n\n\tif (failslab.ignore_gfp_reclaim && (gfpflags & __GFP_RECLAIM))\n\t\treturn false;\n\n\tif (failslab.cache_filter && !(s->flags & SLAB_FAILSLAB))\n\t\treturn false;\n\n\treturn should_fail(&failslab.attr, s->object_size);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/fault-inject.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tstruct fault_attr attr;\n\tbool ignore_gfp_reclaim;\n\tbool cache_filter;\n} failslab = {\n\t.attr = FAULT_ATTR_INITIALIZER,\n\t.ignore_gfp_reclaim = true,\n\t.cache_filter = false,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/fault-inject.h>\n\nstatic struct {\n\tstruct fault_attr attr;\n\tbool ignore_gfp_reclaim;\n\tbool cache_filter;\n} failslab = {\n\t.attr = FAULT_ATTR_INITIALIZER,\n\t.ignore_gfp_reclaim = true,\n\t.cache_filter = false,\n};\n\nbool __should_failslab(struct kmem_cache *s, gfp_t gfpflags)\n{\n\t/* No fault-injection for bootstrap cache */\n\tif (unlikely(s == kmem_cache))\n\t\treturn false;\n\n\tif (gfpflags & __GFP_NOFAIL)\n\t\treturn false;\n\n\tif (failslab.ignore_gfp_reclaim && (gfpflags & __GFP_RECLAIM))\n\t\treturn false;\n\n\tif (failslab.cache_filter && !(s->flags & SLAB_FAILSLAB))\n\t\treturn false;\n\n\treturn should_fail(&failslab.attr, s->object_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep_if",
          "args": [
            "gfpflags_allow_blocking(flags)"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfpflags_allow_blocking",
          "args": [
            "flags"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_reclaim_release",
          "args": [
            "flags"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "fs_reclaim_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3745-3749",
          "snippet": "void fs_reclaim_release(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_release();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid fs_reclaim_release(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_release();\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_reclaim_acquire",
          "args": [
            "flags"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "fs_reclaim_acquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3738-3742",
          "snippet": "void fs_reclaim_acquire(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_acquire();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid fs_reclaim_acquire(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_acquire();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache *slab_pre_alloc_hook(struct kmem_cache *s,\n\t\t\t\t\t\t     gfp_t flags)\n{\n\tflags &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(flags);\n\tfs_reclaim_release(flags);\n\n\tmight_sleep_if(gfpflags_allow_blocking(flags));\n\n\tif (should_failslab(s, flags))\n\t\treturn NULL;\n\n\tif (memcg_kmem_enabled() &&\n\t    ((flags & __GFP_ACCOUNT) || (s->flags & SLAB_ACCOUNT)))\n\t\treturn memcg_kmem_get_cache(s);\n\n\treturn s;\n}"
  },
  {
    "function_name": "slab_ksize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
    "lines": "383-411",
    "snippet": "static inline size_t slab_ksize(const struct kmem_cache *s)\n{\n#ifndef CONFIG_SLUB\n\treturn s->object_size;\n\n#else /* CONFIG_SLUB */\n# ifdef CONFIG_SLUB_DEBUG\n\t/*\n\t * Debugging requires use of the padding between object\n\t * and whatever may come after it.\n\t */\n\tif (s->flags & (SLAB_RED_ZONE | SLAB_POISON))\n\t\treturn s->object_size;\n# endif\n\tif (s->flags & SLAB_KASAN)\n\t\treturn s->object_size;\n\t/*\n\t * If we have the need to store the freelist pointer\n\t * back there or track user information then we can\n\t * only use the space before that information.\n\t */\n\tif (s->flags & (SLAB_TYPESAFE_BY_RCU | SLAB_STORE_USER))\n\t\treturn s->inuse;\n\t/*\n\t * Else we can use all the padding etc for the allocation\n\t */\n\treturn s->size;\n#endif\n}",
    "includes": [
      "#include <linux/sched/mm.h>",
      "#include <linux/random.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/slub_def.h>",
      "#include <linux/slab_def.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline size_t slab_ksize(const struct kmem_cache *s)\n{\n#ifndef CONFIG_SLUB\n\treturn s->object_size;\n\n#else /* CONFIG_SLUB */\n# ifdef CONFIG_SLUB_DEBUG\n\t/*\n\t * Debugging requires use of the padding between object\n\t * and whatever may come after it.\n\t */\n\tif (s->flags & (SLAB_RED_ZONE | SLAB_POISON))\n\t\treturn s->object_size;\n# endif\n\tif (s->flags & SLAB_KASAN)\n\t\treturn s->object_size;\n\t/*\n\t * If we have the need to store the freelist pointer\n\t * back there or track user information then we can\n\t * only use the space before that information.\n\t */\n\tif (s->flags & (SLAB_TYPESAFE_BY_RCU | SLAB_STORE_USER))\n\t\treturn s->inuse;\n\t/*\n\t * Else we can use all the padding etc for the allocation\n\t */\n\treturn s->size;\n#endif\n}"
  },
  {
    "function_name": "cache_from_obj",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
    "lines": "356-381",
    "snippet": "static inline struct kmem_cache *cache_from_obj(struct kmem_cache *s, void *x)\n{\n\tstruct kmem_cache *cachep;\n\tstruct page *page;\n\n\t/*\n\t * When kmemcg is not being used, both assignments should return the\n\t * same value. but we don't want to pay the assignment price in that\n\t * case. If it is not compiled in, the compiler should be smart enough\n\t * to not do even the assignment. In that case, slab_equal_or_root\n\t * will also be a constant.\n\t */\n\tif (!memcg_kmem_enabled() &&\n\t    !unlikely(s->flags & SLAB_CONSISTENCY_CHECKS))\n\t\treturn s;\n\n\tpage = virt_to_head_page(x);\n\tcachep = page->slab_cache;\n\tif (slab_equal_or_root(cachep, s))\n\t\treturn cachep;\n\n\tpr_err(\"%s: Wrong slab cache. %s but object is from %s\\n\",\n\t       __func__, s->name, cachep->name);\n\tWARN_ON_ONCE(1);\n\treturn s;\n}",
    "includes": [
      "#include <linux/sched/mm.h>",
      "#include <linux/random.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/slub_def.h>",
      "#include <linux/slab_def.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Wrong slab cache. %s but object is from %s\\n\"",
            "__func__",
            "s->name",
            "cachep->name"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_equal_or_root",
          "args": [
            "cachep",
            "s"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "slab_equal_or_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "313-317",
          "snippet": "static inline bool slab_equal_or_root(struct kmem_cache *s,\n\t\t\t\t      struct kmem_cache *p)\n{\n\treturn true;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline bool slab_equal_or_root(struct kmem_cache *s,\n\t\t\t\t      struct kmem_cache *p)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_head_page",
          "args": [
            "x"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "s->flags & SLAB_CONSISTENCY_CHECKS"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_kmem_enabled",
          "args": [],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache *cache_from_obj(struct kmem_cache *s, void *x)\n{\n\tstruct kmem_cache *cachep;\n\tstruct page *page;\n\n\t/*\n\t * When kmemcg is not being used, both assignments should return the\n\t * same value. but we don't want to pay the assignment price in that\n\t * case. If it is not compiled in, the compiler should be smart enough\n\t * to not do even the assignment. In that case, slab_equal_or_root\n\t * will also be a constant.\n\t */\n\tif (!memcg_kmem_enabled() &&\n\t    !unlikely(s->flags & SLAB_CONSISTENCY_CHECKS))\n\t\treturn s;\n\n\tpage = virt_to_head_page(x);\n\tcachep = page->slab_cache;\n\tif (slab_equal_or_root(cachep, s))\n\t\treturn cachep;\n\n\tpr_err(\"%s: Wrong slab cache. %s but object is from %s\\n\",\n\t       __func__, s->name, cachep->name);\n\tWARN_ON_ONCE(1);\n\treturn s;\n}"
  },
  {
    "function_name": "memcg_link_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
    "lines": "350-352",
    "snippet": "static inline void memcg_link_cache(struct kmem_cache *s)\n{\n}",
    "includes": [
      "#include <linux/sched/mm.h>",
      "#include <linux/random.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/slub_def.h>",
      "#include <linux/slab_def.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline void memcg_link_cache(struct kmem_cache *s)\n{\n}"
  },
  {
    "function_name": "slab_init_memcg_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
    "lines": "346-348",
    "snippet": "static inline void slab_init_memcg_params(struct kmem_cache *s)\n{\n}",
    "includes": [
      "#include <linux/sched/mm.h>",
      "#include <linux/random.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/slub_def.h>",
      "#include <linux/slab_def.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline void slab_init_memcg_params(struct kmem_cache *s)\n{\n}"
  },
  {
    "function_name": "memcg_uncharge_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
    "lines": "341-344",
    "snippet": "static inline void memcg_uncharge_slab(struct page *page, int order,\n\t\t\t\t       struct kmem_cache *s)\n{\n}",
    "includes": [
      "#include <linux/sched/mm.h>",
      "#include <linux/random.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/slub_def.h>",
      "#include <linux/slab_def.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline void memcg_uncharge_slab(struct page *page, int order,\n\t\t\t\t       struct kmem_cache *s)\n{\n}"
  },
  {
    "function_name": "memcg_charge_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
    "lines": "335-339",
    "snippet": "static inline int memcg_charge_slab(struct page *page, gfp_t gfp, int order,\n\t\t\t\t    struct kmem_cache *s)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sched/mm.h>",
      "#include <linux/random.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/slub_def.h>",
      "#include <linux/slab_def.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline int memcg_charge_slab(struct page *page, gfp_t gfp, int order,\n\t\t\t\t    struct kmem_cache *s)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "memcg_root_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
    "lines": "330-333",
    "snippet": "static inline struct kmem_cache *memcg_root_cache(struct kmem_cache *s)\n{\n\treturn s;\n}",
    "includes": [
      "#include <linux/sched/mm.h>",
      "#include <linux/random.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/slub_def.h>",
      "#include <linux/slab_def.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache *memcg_root_cache(struct kmem_cache *s)\n{\n\treturn s;\n}"
  },
  {
    "function_name": "cache_from_memcg_idx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
    "lines": "324-328",
    "snippet": "static inline struct kmem_cache *\ncache_from_memcg_idx(struct kmem_cache *s, int idx)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/sched/mm.h>",
      "#include <linux/random.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/slub_def.h>",
      "#include <linux/slab_def.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache *\ncache_from_memcg_idx(struct kmem_cache *s, int idx)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "cache_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
    "lines": "319-322",
    "snippet": "static inline const char *cache_name(struct kmem_cache *s)\n{\n\treturn s->name;\n}",
    "includes": [
      "#include <linux/sched/mm.h>",
      "#include <linux/random.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/slub_def.h>",
      "#include <linux/slab_def.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline const char *cache_name(struct kmem_cache *s)\n{\n\treturn s->name;\n}"
  },
  {
    "function_name": "slab_equal_or_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
    "lines": "313-317",
    "snippet": "static inline bool slab_equal_or_root(struct kmem_cache *s,\n\t\t\t\t      struct kmem_cache *p)\n{\n\treturn true;\n}",
    "includes": [
      "#include <linux/sched/mm.h>",
      "#include <linux/random.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/slub_def.h>",
      "#include <linux/slab_def.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline bool slab_equal_or_root(struct kmem_cache *s,\n\t\t\t\t      struct kmem_cache *p)\n{\n\treturn true;\n}"
  },
  {
    "function_name": "is_root_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
    "lines": "308-311",
    "snippet": "static inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}",
    "includes": [
      "#include <linux/sched/mm.h>",
      "#include <linux/random.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/slub_def.h>",
      "#include <linux/slab_def.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}"
  },
  {
    "function_name": "memcg_uncharge_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
    "lines": "286-292",
    "snippet": "static __always_inline void memcg_uncharge_slab(struct page *page, int order,\n\t\t\t\t\t\tstruct kmem_cache *s)\n{\n\tif (!memcg_kmem_enabled())\n\t\treturn;\n\tmemcg_kmem_uncharge(page, order);\n}",
    "includes": [
      "#include <linux/sched/mm.h>",
      "#include <linux/random.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/slub_def.h>",
      "#include <linux/slab_def.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcg_kmem_uncharge",
          "args": [
            "page",
            "order"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_kmem_uncharge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2613-2637",
          "snippet": "void memcg_kmem_uncharge(struct page *page, int order)\n{\n\tstruct mem_cgroup *memcg = page->mem_cgroup;\n\tunsigned int nr_pages = 1 << order;\n\n\tif (!memcg)\n\t\treturn;\n\n\tVM_BUG_ON_PAGE(mem_cgroup_is_root(memcg), page);\n\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\tpage_counter_uncharge(&memcg->kmem, nr_pages);\n\n\tpage_counter_uncharge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_uncharge(&memcg->memsw, nr_pages);\n\n\tpage->mem_cgroup = NULL;\n\n\t/* slab pages do not have PageKmemcg flag set */\n\tif (PageKmemcg(page))\n\t\t__ClearPageKmemcg(page);\n\n\tcss_put_many(&memcg->css, nr_pages);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nvoid memcg_kmem_uncharge(struct page *page, int order)\n{\n\tstruct mem_cgroup *memcg = page->mem_cgroup;\n\tunsigned int nr_pages = 1 << order;\n\n\tif (!memcg)\n\t\treturn;\n\n\tVM_BUG_ON_PAGE(mem_cgroup_is_root(memcg), page);\n\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\tpage_counter_uncharge(&memcg->kmem, nr_pages);\n\n\tpage_counter_uncharge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_uncharge(&memcg->memsw, nr_pages);\n\n\tpage->mem_cgroup = NULL;\n\n\t/* slab pages do not have PageKmemcg flag set */\n\tif (PageKmemcg(page))\n\t\t__ClearPageKmemcg(page);\n\n\tcss_put_many(&memcg->css, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_kmem_enabled",
          "args": [],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic __always_inline void memcg_uncharge_slab(struct page *page, int order,\n\t\t\t\t\t\tstruct kmem_cache *s)\n{\n\tif (!memcg_kmem_enabled())\n\t\treturn;\n\tmemcg_kmem_uncharge(page, order);\n}"
  },
  {
    "function_name": "memcg_charge_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
    "lines": "275-284",
    "snippet": "static __always_inline int memcg_charge_slab(struct page *page,\n\t\t\t\t\t     gfp_t gfp, int order,\n\t\t\t\t\t     struct kmem_cache *s)\n{\n\tif (!memcg_kmem_enabled())\n\t\treturn 0;\n\tif (is_root_cache(s))\n\t\treturn 0;\n\treturn memcg_kmem_charge_memcg(page, gfp, order, s->memcg_params.memcg);\n}",
    "includes": [
      "#include <linux/sched/mm.h>",
      "#include <linux/random.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/slub_def.h>",
      "#include <linux/slab_def.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcg_kmem_charge_memcg",
          "args": [
            "page",
            "gfp",
            "order",
            "s->memcg_params.memcg"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_kmem_charge_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2561-2581",
          "snippet": "int memcg_kmem_charge_memcg(struct page *page, gfp_t gfp, int order,\n\t\t\t    struct mem_cgroup *memcg)\n{\n\tunsigned int nr_pages = 1 << order;\n\tstruct page_counter *counter;\n\tint ret;\n\n\tret = try_charge(memcg, gfp, nr_pages);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys) &&\n\t    !page_counter_try_charge(&memcg->kmem, nr_pages, &counter)) {\n\t\tcancel_charge(memcg, nr_pages);\n\t\treturn -ENOMEM;\n\t}\n\n\tpage->mem_cgroup = memcg;\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nint memcg_kmem_charge_memcg(struct page *page, gfp_t gfp, int order,\n\t\t\t    struct mem_cgroup *memcg)\n{\n\tunsigned int nr_pages = 1 << order;\n\tstruct page_counter *counter;\n\tint ret;\n\n\tret = try_charge(memcg, gfp, nr_pages);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys) &&\n\t    !page_counter_try_charge(&memcg->kmem, nr_pages, &counter)) {\n\t\tcancel_charge(memcg, nr_pages);\n\t\treturn -ENOMEM;\n\t}\n\n\tpage->mem_cgroup = memcg;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_root_cache",
          "args": [
            "s"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "is_root_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "308-311",
          "snippet": "static inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_kmem_enabled",
          "args": [],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic __always_inline int memcg_charge_slab(struct page *page,\n\t\t\t\t\t     gfp_t gfp, int order,\n\t\t\t\t\t     struct kmem_cache *s)\n{\n\tif (!memcg_kmem_enabled())\n\t\treturn 0;\n\tif (is_root_cache(s))\n\t\treturn 0;\n\treturn memcg_kmem_charge_memcg(page, gfp, order, s->memcg_params.memcg);\n}"
  },
  {
    "function_name": "memcg_root_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
    "lines": "268-273",
    "snippet": "static inline struct kmem_cache *memcg_root_cache(struct kmem_cache *s)\n{\n\tif (is_root_cache(s))\n\t\treturn s;\n\treturn s->memcg_params.root_cache;\n}",
    "includes": [
      "#include <linux/sched/mm.h>",
      "#include <linux/random.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/slub_def.h>",
      "#include <linux/slab_def.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_root_cache",
          "args": [
            "s"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "is_root_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "308-311",
          "snippet": "static inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache *memcg_root_cache(struct kmem_cache *s)\n{\n\tif (is_root_cache(s))\n\t\treturn s;\n\treturn s->memcg_params.root_cache;\n}"
  },
  {
    "function_name": "cache_from_memcg_idx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
    "lines": "248-266",
    "snippet": "static inline struct kmem_cache *\ncache_from_memcg_idx(struct kmem_cache *s, int idx)\n{\n\tstruct kmem_cache *cachep;\n\tstruct memcg_cache_array *arr;\n\n\trcu_read_lock();\n\tarr = rcu_dereference(s->memcg_params.memcg_caches);\n\n\t/*\n\t * Make sure we will access the up-to-date value. The code updating\n\t * memcg_caches issues a write barrier to match this (see\n\t * memcg_create_kmem_cache()).\n\t */\n\tcachep = READ_ONCE(arr->entries[idx]);\n\trcu_read_unlock();\n\n\treturn cachep;\n}",
    "includes": [
      "#include <linux/sched/mm.h>",
      "#include <linux/random.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/slub_def.h>",
      "#include <linux/slab_def.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "arr->entries[idx]"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "s->memcg_params.memcg_caches"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache *\ncache_from_memcg_idx(struct kmem_cache *s, int idx)\n{\n\tstruct kmem_cache *cachep;\n\tstruct memcg_cache_array *arr;\n\n\trcu_read_lock();\n\tarr = rcu_dereference(s->memcg_params.memcg_caches);\n\n\t/*\n\t * Make sure we will access the up-to-date value. The code updating\n\t * memcg_caches issues a write barrier to match this (see\n\t * memcg_create_kmem_cache()).\n\t */\n\tcachep = READ_ONCE(arr->entries[idx]);\n\trcu_read_unlock();\n\n\treturn cachep;\n}"
  },
  {
    "function_name": "cache_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
    "lines": "236-241",
    "snippet": "static inline const char *cache_name(struct kmem_cache *s)\n{\n\tif (!is_root_cache(s))\n\t\ts = s->memcg_params.root_cache;\n\treturn s->name;\n}",
    "includes": [
      "#include <linux/sched/mm.h>",
      "#include <linux/random.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/slub_def.h>",
      "#include <linux/slab_def.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_root_cache",
          "args": [
            "s"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "is_root_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "308-311",
          "snippet": "static inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline const char *cache_name(struct kmem_cache *s)\n{\n\tif (!is_root_cache(s))\n\t\ts = s->memcg_params.root_cache;\n\treturn s->name;\n}"
  },
  {
    "function_name": "slab_equal_or_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
    "lines": "225-229",
    "snippet": "static inline bool slab_equal_or_root(struct kmem_cache *s,\n\t\t\t\t      struct kmem_cache *p)\n{\n\treturn p == s || p == s->memcg_params.root_cache;\n}",
    "includes": [
      "#include <linux/sched/mm.h>",
      "#include <linux/random.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/slub_def.h>",
      "#include <linux/slab_def.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline bool slab_equal_or_root(struct kmem_cache *s,\n\t\t\t\t      struct kmem_cache *p)\n{\n\treturn p == s || p == s->memcg_params.root_cache;\n}"
  },
  {
    "function_name": "is_root_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
    "lines": "220-223",
    "snippet": "static inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn !s->memcg_params.root_cache;\n}",
    "includes": [
      "#include <linux/sched/mm.h>",
      "#include <linux/random.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/slub_def.h>",
      "#include <linux/slab_def.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn !s->memcg_params.root_cache;\n}"
  },
  {
    "function_name": "kmem_cache_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
    "lines": "120-125",
    "snippet": "static inline slab_flags_t kmem_cache_flags(unsigned int object_size,\n\tslab_flags_t flags, const char *name,\n\tvoid (*ctor)(void *))\n{\n\treturn flags;\n}",
    "includes": [
      "#include <linux/sched/mm.h>",
      "#include <linux/random.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/slub_def.h>",
      "#include <linux/slab_def.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline slab_flags_t kmem_cache_flags(unsigned int object_size,\n\tslab_flags_t flags, const char *name,\n\tvoid (*ctor)(void *))\n{\n\treturn flags;\n}"
  },
  {
    "function_name": "__kmem_cache_alias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
    "lines": "115-118",
    "snippet": "static inline struct kmem_cache *\n__kmem_cache_alias(const char *name, unsigned int size, unsigned int align,\n\t\t   slab_flags_t flags, void (*ctor)(void *))\n{ return NULL; }",
    "includes": [
      "#include <linux/sched/mm.h>",
      "#include <linux/random.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/kasan.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/slub_def.h>",
      "#include <linux/slab_def.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache *\n__kmem_cache_alias(const char *name, unsigned int size, unsigned int align,\n\t\t   slab_flags_t flags, void (*ctor)(void *))\n{ return NULL; }"
  }
]