[
  {
    "function_name": "ksm_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "3135-3178",
    "snippet": "static int __init ksm_init(void)\n{\n\tstruct task_struct *ksm_thread;\n\tint err;\n\n\t/* The correct value depends on page size and endianness */\n\tzero_checksum = calc_checksum(ZERO_PAGE(0));\n\t/* Default to false for backwards compatibility */\n\tksm_use_zero_pages = false;\n\n\terr = ksm_slab_init();\n\tif (err)\n\t\tgoto out;\n\n\tksm_thread = kthread_run(ksm_scan_thread, NULL, \"ksmd\");\n\tif (IS_ERR(ksm_thread)) {\n\t\tpr_err(\"ksm: creating kthread failed\\n\");\n\t\terr = PTR_ERR(ksm_thread);\n\t\tgoto out_free;\n\t}\n\n#ifdef CONFIG_SYSFS\n\terr = sysfs_create_group(mm_kobj, &ksm_attr_group);\n\tif (err) {\n\t\tpr_err(\"ksm: register sysfs failed\\n\");\n\t\tkthread_stop(ksm_thread);\n\t\tgoto out_free;\n\t}\n#else\n\tksm_run = KSM_RUN_MERGE;\t/* no way for user to start it */\n\n#endif /* CONFIG_SYSFS */\n\n#ifdef CONFIG_MEMORY_HOTREMOVE\n\t/* There is no significance to this priority 100 */\n\thotplug_memory_notifier(ksm_memory_callback, 100);\n#endif\n\treturn 0;\n\nout_free:\n\tksm_slab_free();\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define KSM_RUN_MERGE\t1"
    ],
    "globals_used": [
      "static unsigned int zero_checksum",
      "static bool ksm_use_zero_pages",
      "static unsigned long ksm_run = KSM_RUN_STOP;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ksm_slab_free",
          "args": [],
          "line": 3175
        },
        "resolved": true,
        "details": {
          "function_name": "ksm_slab_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "330-336",
          "snippet": "static void __init ksm_slab_free(void)\n{\n\tkmem_cache_destroy(mm_slot_cache);\n\tkmem_cache_destroy(stable_node_cache);\n\tkmem_cache_destroy(rmap_item_cache);\n\tmm_slot_cache = NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *rmap_item_cache;",
            "static struct kmem_cache *stable_node_cache;",
            "static struct kmem_cache *mm_slot_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct kmem_cache *rmap_item_cache;\nstatic struct kmem_cache *stable_node_cache;\nstatic struct kmem_cache *mm_slot_cache;\n\nstatic void __init ksm_slab_free(void)\n{\n\tkmem_cache_destroy(mm_slot_cache);\n\tkmem_cache_destroy(stable_node_cache);\n\tkmem_cache_destroy(rmap_item_cache);\n\tmm_slot_cache = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hotplug_memory_notifier",
          "args": [
            "ksm_memory_callback",
            "100"
          ],
          "line": 3170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "ksm_thread"
          ],
          "line": 3160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"ksm: register sysfs failed\\n\""
          ],
          "line": 3159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_create_group",
          "args": [
            "mm_kobj",
            "&ksm_attr_group"
          ],
          "line": 3157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ksm_thread"
          ],
          "line": 3152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"ksm: creating kthread failed\\n\""
          ],
          "line": 3151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ksm_thread"
          ],
          "line": 3150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "ksm_scan_thread",
            "NULL",
            "\"ksmd\""
          ],
          "line": 3149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ksm_slab_init",
          "args": [],
          "line": 3145
        },
        "resolved": true,
        "details": {
          "function_name": "ksm_slab_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "306-328",
          "snippet": "static int __init ksm_slab_init(void)\n{\n\trmap_item_cache = KSM_KMEM_CACHE(rmap_item, 0);\n\tif (!rmap_item_cache)\n\t\tgoto out;\n\n\tstable_node_cache = KSM_KMEM_CACHE(stable_node, 0);\n\tif (!stable_node_cache)\n\t\tgoto out_free1;\n\n\tmm_slot_cache = KSM_KMEM_CACHE(mm_slot, 0);\n\tif (!mm_slot_cache)\n\t\tgoto out_free2;\n\n\treturn 0;\n\nout_free2:\n\tkmem_cache_destroy(stable_node_cache);\nout_free1:\n\tkmem_cache_destroy(rmap_item_cache);\nout:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *rmap_item_cache;",
            "static struct kmem_cache *stable_node_cache;",
            "static struct kmem_cache *mm_slot_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct kmem_cache *rmap_item_cache;\nstatic struct kmem_cache *stable_node_cache;\nstatic struct kmem_cache *mm_slot_cache;\n\nstatic int __init ksm_slab_init(void)\n{\n\trmap_item_cache = KSM_KMEM_CACHE(rmap_item, 0);\n\tif (!rmap_item_cache)\n\t\tgoto out;\n\n\tstable_node_cache = KSM_KMEM_CACHE(stable_node, 0);\n\tif (!stable_node_cache)\n\t\tgoto out_free1;\n\n\tmm_slot_cache = KSM_KMEM_CACHE(mm_slot, 0);\n\tif (!mm_slot_cache)\n\t\tgoto out_free2;\n\n\treturn 0;\n\nout_free2:\n\tkmem_cache_destroy(stable_node_cache);\nout_free1:\n\tkmem_cache_destroy(rmap_item_cache);\nout:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_checksum",
          "args": [
            "ZERO_PAGE(0)"
          ],
          "line": 3141
        },
        "resolved": true,
        "details": {
          "function_name": "calc_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1008-1015",
          "snippet": "static u32 calc_checksum(struct page *page)\n{\n\tu32 checksum;\n\tvoid *addr = kmap_atomic(page);\n\tchecksum = jhash2(addr, PAGE_SIZE / 4, 17);\n\tkunmap_atomic(addr);\n\treturn checksum;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic u32 calc_checksum(struct page *page)\n{\n\tu32 checksum;\n\tvoid *addr = kmap_atomic(page);\n\tchecksum = jhash2(addr, PAGE_SIZE / 4, 17);\n\tkunmap_atomic(addr);\n\treturn checksum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ZERO_PAGE",
          "args": [
            "0"
          ],
          "line": 3141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define KSM_RUN_MERGE\t1\n\nstatic unsigned int zero_checksum;\nstatic bool ksm_use_zero_pages;\nstatic unsigned long ksm_run = KSM_RUN_STOP;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int __init ksm_init(void)\n{\n\tstruct task_struct *ksm_thread;\n\tint err;\n\n\t/* The correct value depends on page size and endianness */\n\tzero_checksum = calc_checksum(ZERO_PAGE(0));\n\t/* Default to false for backwards compatibility */\n\tksm_use_zero_pages = false;\n\n\terr = ksm_slab_init();\n\tif (err)\n\t\tgoto out;\n\n\tksm_thread = kthread_run(ksm_scan_thread, NULL, \"ksmd\");\n\tif (IS_ERR(ksm_thread)) {\n\t\tpr_err(\"ksm: creating kthread failed\\n\");\n\t\terr = PTR_ERR(ksm_thread);\n\t\tgoto out_free;\n\t}\n\n#ifdef CONFIG_SYSFS\n\terr = sysfs_create_group(mm_kobj, &ksm_attr_group);\n\tif (err) {\n\t\tpr_err(\"ksm: register sysfs failed\\n\");\n\t\tkthread_stop(ksm_thread);\n\t\tgoto out_free;\n\t}\n#else\n\tksm_run = KSM_RUN_MERGE;\t/* no way for user to start it */\n\n#endif /* CONFIG_SYSFS */\n\n#ifdef CONFIG_MEMORY_HOTREMOVE\n\t/* There is no significance to this priority 100 */\n\thotplug_memory_notifier(ksm_memory_callback, 100);\n#endif\n\treturn 0;\n\nout_free:\n\tksm_slab_free();\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "full_scans_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "3102-3106",
    "snippet": "static ssize_t full_scans_show(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", ksm_scan.seqnr);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%lu\\n\"",
            "ksm_scan.seqnr"
          ],
          "line": 3105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic ssize_t full_scans_show(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", ksm_scan.seqnr);\n}"
  },
  {
    "function_name": "stable_node_chains_prune_millisecs_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "3084-3099",
    "snippet": "static ssize_t\nstable_node_chains_prune_millisecs_store(struct kobject *kobj,\n\t\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tunsigned long msecs;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &msecs);\n\tif (err || msecs > UINT_MAX)\n\t\treturn -EINVAL;\n\n\tksm_stable_node_chains_prune_millisecs = msecs;\n\n\treturn count;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ksm_stable_node_chains_prune_millisecs = 2000;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "buf",
            "10",
            "&msecs"
          ],
          "line": 3092
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic int ksm_stable_node_chains_prune_millisecs = 2000;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic ssize_t\nstable_node_chains_prune_millisecs_store(struct kobject *kobj,\n\t\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tunsigned long msecs;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &msecs);\n\tif (err || msecs > UINT_MAX)\n\t\treturn -EINVAL;\n\n\tksm_stable_node_chains_prune_millisecs = msecs;\n\n\treturn count;\n}"
  },
  {
    "function_name": "stable_node_chains_prune_millisecs_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "3076-3082",
    "snippet": "static ssize_t\nstable_node_chains_prune_millisecs_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", ksm_stable_node_chains_prune_millisecs);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ksm_stable_node_chains_prune_millisecs = 2000;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "ksm_stable_node_chains_prune_millisecs"
          ],
          "line": 3081
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic int ksm_stable_node_chains_prune_millisecs = 2000;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic ssize_t\nstable_node_chains_prune_millisecs_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", ksm_stable_node_chains_prune_millisecs);\n}"
  },
  {
    "function_name": "stable_node_chains_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "3069-3073",
    "snippet": "static ssize_t stable_node_chains_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", ksm_stable_node_chains);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long ksm_stable_node_chains;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%lu\\n\"",
            "ksm_stable_node_chains"
          ],
          "line": 3072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic unsigned long ksm_stable_node_chains;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic ssize_t stable_node_chains_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", ksm_stable_node_chains);\n}"
  },
  {
    "function_name": "stable_node_dups_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "3062-3066",
    "snippet": "static ssize_t stable_node_dups_show(struct kobject *kobj,\n\t\t\t\t     struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", ksm_stable_node_dups);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long ksm_stable_node_dups;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%lu\\n\"",
            "ksm_stable_node_dups"
          ],
          "line": 3065
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic unsigned long ksm_stable_node_dups;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic ssize_t stable_node_dups_show(struct kobject *kobj,\n\t\t\t\t     struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", ksm_stable_node_dups);\n}"
  },
  {
    "function_name": "pages_volatile_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "3045-3059",
    "snippet": "static ssize_t pages_volatile_show(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr, char *buf)\n{\n\tlong ksm_pages_volatile;\n\n\tksm_pages_volatile = ksm_rmap_items - ksm_pages_shared\n\t\t\t\t- ksm_pages_sharing - ksm_pages_unshared;\n\t/*\n\t * It was not worth any locking to calculate that statistic,\n\t * but it might therefore sometimes be negative: conceal that.\n\t */\n\tif (ksm_pages_volatile < 0)\n\t\tksm_pages_volatile = 0;\n\treturn sprintf(buf, \"%ld\\n\", ksm_pages_volatile);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long ksm_pages_shared;",
      "static unsigned long ksm_pages_sharing;",
      "static unsigned long ksm_pages_unshared;",
      "static unsigned long ksm_rmap_items;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%ld\\n\"",
            "ksm_pages_volatile"
          ],
          "line": 3058
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic unsigned long ksm_pages_shared;\nstatic unsigned long ksm_pages_sharing;\nstatic unsigned long ksm_pages_unshared;\nstatic unsigned long ksm_rmap_items;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic ssize_t pages_volatile_show(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr, char *buf)\n{\n\tlong ksm_pages_volatile;\n\n\tksm_pages_volatile = ksm_rmap_items - ksm_pages_shared\n\t\t\t\t- ksm_pages_sharing - ksm_pages_unshared;\n\t/*\n\t * It was not worth any locking to calculate that statistic,\n\t * but it might therefore sometimes be negative: conceal that.\n\t */\n\tif (ksm_pages_volatile < 0)\n\t\tksm_pages_volatile = 0;\n\treturn sprintf(buf, \"%ld\\n\", ksm_pages_volatile);\n}"
  },
  {
    "function_name": "pages_unshared_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "3038-3042",
    "snippet": "static ssize_t pages_unshared_show(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", ksm_pages_unshared);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long ksm_pages_unshared;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%lu\\n\"",
            "ksm_pages_unshared"
          ],
          "line": 3041
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic unsigned long ksm_pages_unshared;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic ssize_t pages_unshared_show(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", ksm_pages_unshared);\n}"
  },
  {
    "function_name": "pages_sharing_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "3031-3035",
    "snippet": "static ssize_t pages_sharing_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", ksm_pages_sharing);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long ksm_pages_sharing;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%lu\\n\"",
            "ksm_pages_sharing"
          ],
          "line": 3034
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic unsigned long ksm_pages_sharing;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic ssize_t pages_sharing_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", ksm_pages_sharing);\n}"
  },
  {
    "function_name": "pages_shared_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "3024-3028",
    "snippet": "static ssize_t pages_shared_show(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", ksm_pages_shared);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long ksm_pages_shared;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%lu\\n\"",
            "ksm_pages_shared"
          ],
          "line": 3027
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic unsigned long ksm_pages_shared;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic ssize_t pages_shared_show(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", ksm_pages_shared);\n}"
  },
  {
    "function_name": "max_page_sharing_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2989-3021",
    "snippet": "static ssize_t max_page_sharing_store(struct kobject *kobj,\n\t\t\t\t      struct kobj_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tint err;\n\tint knob;\n\n\terr = kstrtoint(buf, 10, &knob);\n\tif (err)\n\t\treturn err;\n\t/*\n\t * When a KSM page is created it is shared by 2 mappings. This\n\t * being a signed comparison, it implicitly verifies it's not\n\t * negative.\n\t */\n\tif (knob < 2)\n\t\treturn -EINVAL;\n\n\tif (READ_ONCE(ksm_max_page_sharing) == knob)\n\t\treturn count;\n\n\tmutex_lock(&ksm_thread_mutex);\n\twait_while_offlining();\n\tif (ksm_max_page_sharing != knob) {\n\t\tif (ksm_pages_shared || remove_all_stable_nodes())\n\t\t\terr = -EBUSY;\n\t\telse\n\t\t\tksm_max_page_sharing = knob;\n\t}\n\tmutex_unlock(&ksm_thread_mutex);\n\n\treturn err ? err : count;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long ksm_pages_shared;",
      "static int ksm_max_page_sharing = 256;",
      "static void wait_while_offlining(void);",
      "static DEFINE_MUTEX(ksm_thread_mutex);",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ksm_thread_mutex"
          ],
          "line": 3018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_all_stable_nodes",
          "args": [],
          "line": 3013
        },
        "resolved": true,
        "details": {
          "function_name": "remove_all_stable_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "923-947",
          "snippet": "static int remove_all_stable_nodes(void)\n{\n\tstruct stable_node *stable_node, *next;\n\tint nid;\n\tint err = 0;\n\n\tfor (nid = 0; nid < ksm_nr_node_ids; nid++) {\n\t\twhile (root_stable_tree[nid].rb_node) {\n\t\t\tstable_node = rb_entry(root_stable_tree[nid].rb_node,\n\t\t\t\t\t\tstruct stable_node, node);\n\t\t\tif (remove_stable_node_chain(stable_node,\n\t\t\t\t\t\t     root_stable_tree + nid)) {\n\t\t\t\terr = -EBUSY;\n\t\t\t\tbreak;\t/* proceed to next nid */\n\t\t\t}\n\t\t\tcond_resched();\n\t\t}\n\t}\n\tlist_for_each_entry_safe(stable_node, next, &migrate_nodes, list) {\n\t\tif (remove_stable_node(stable_node))\n\t\t\terr = -EBUSY;\n\t\tcond_resched();\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define ksm_nr_node_ids\t\t1"
          ],
          "globals_used": [
            "static struct rb_root *root_stable_tree = one_stable_tree;",
            "static LIST_HEAD(migrate_nodes);",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define ksm_nr_node_ids\t\t1\n\nstatic struct rb_root *root_stable_tree = one_stable_tree;\nstatic LIST_HEAD(migrate_nodes);\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int remove_all_stable_nodes(void)\n{\n\tstruct stable_node *stable_node, *next;\n\tint nid;\n\tint err = 0;\n\n\tfor (nid = 0; nid < ksm_nr_node_ids; nid++) {\n\t\twhile (root_stable_tree[nid].rb_node) {\n\t\t\tstable_node = rb_entry(root_stable_tree[nid].rb_node,\n\t\t\t\t\t\tstruct stable_node, node);\n\t\t\tif (remove_stable_node_chain(stable_node,\n\t\t\t\t\t\t     root_stable_tree + nid)) {\n\t\t\t\terr = -EBUSY;\n\t\t\t\tbreak;\t/* proceed to next nid */\n\t\t\t}\n\t\t\tcond_resched();\n\t\t}\n\t}\n\tlist_for_each_entry_safe(stable_node, next, &migrate_nodes, list) {\n\t\tif (remove_stable_node(stable_node))\n\t\t\terr = -EBUSY;\n\t\tcond_resched();\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_while_offlining",
          "args": [],
          "line": 3011
        },
        "resolved": true,
        "details": {
          "function_name": "wait_while_offlining",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "2793-2795",
          "snippet": "static void wait_while_offlining(void)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wait_while_offlining(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic void wait_while_offlining(void);\n\nstatic void wait_while_offlining(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ksm_thread_mutex"
          ],
          "line": 3010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "ksm_max_page_sharing"
          ],
          "line": 3007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "buf",
            "10",
            "&knob"
          ],
          "line": 2996
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic unsigned long ksm_pages_shared;\nstatic int ksm_max_page_sharing = 256;\nstatic void wait_while_offlining(void);\nstatic DEFINE_MUTEX(ksm_thread_mutex);\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic ssize_t max_page_sharing_store(struct kobject *kobj,\n\t\t\t\t      struct kobj_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tint err;\n\tint knob;\n\n\terr = kstrtoint(buf, 10, &knob);\n\tif (err)\n\t\treturn err;\n\t/*\n\t * When a KSM page is created it is shared by 2 mappings. This\n\t * being a signed comparison, it implicitly verifies it's not\n\t * negative.\n\t */\n\tif (knob < 2)\n\t\treturn -EINVAL;\n\n\tif (READ_ONCE(ksm_max_page_sharing) == knob)\n\t\treturn count;\n\n\tmutex_lock(&ksm_thread_mutex);\n\twait_while_offlining();\n\tif (ksm_max_page_sharing != knob) {\n\t\tif (ksm_pages_shared || remove_all_stable_nodes())\n\t\t\terr = -EBUSY;\n\t\telse\n\t\t\tksm_max_page_sharing = knob;\n\t}\n\tmutex_unlock(&ksm_thread_mutex);\n\n\treturn err ? err : count;\n}"
  },
  {
    "function_name": "max_page_sharing_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2983-2987",
    "snippet": "static ssize_t max_page_sharing_show(struct kobject *kobj,\n\t\t\t\t     struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", ksm_max_page_sharing);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ksm_max_page_sharing = 256;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "ksm_max_page_sharing"
          ],
          "line": 2986
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic int ksm_max_page_sharing = 256;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic ssize_t max_page_sharing_show(struct kobject *kobj,\n\t\t\t\t     struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", ksm_max_page_sharing);\n}"
  },
  {
    "function_name": "use_zero_pages_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2966-2980",
    "snippet": "static ssize_t use_zero_pages_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tint err;\n\tbool value;\n\n\terr = kstrtobool(buf, &value);\n\tif (err)\n\t\treturn -EINVAL;\n\n\tksm_use_zero_pages = value;\n\n\treturn count;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool ksm_use_zero_pages",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtobool",
          "args": [
            "buf",
            "&value"
          ],
          "line": 2973
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic bool ksm_use_zero_pages;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic ssize_t use_zero_pages_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tint err;\n\tbool value;\n\n\terr = kstrtobool(buf, &value);\n\tif (err)\n\t\treturn -EINVAL;\n\n\tksm_use_zero_pages = value;\n\n\treturn count;\n}"
  },
  {
    "function_name": "use_zero_pages_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2961-2965",
    "snippet": "static ssize_t use_zero_pages_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", ksm_use_zero_pages);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool ksm_use_zero_pages",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "ksm_use_zero_pages"
          ],
          "line": 2964
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic bool ksm_use_zero_pages;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic ssize_t use_zero_pages_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", ksm_use_zero_pages);\n}"
  },
  {
    "function_name": "merge_across_nodes_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2910-2957",
    "snippet": "static ssize_t merge_across_nodes_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tint err;\n\tunsigned long knob;\n\n\terr = kstrtoul(buf, 10, &knob);\n\tif (err)\n\t\treturn err;\n\tif (knob > 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ksm_thread_mutex);\n\twait_while_offlining();\n\tif (ksm_merge_across_nodes != knob) {\n\t\tif (ksm_pages_shared || remove_all_stable_nodes())\n\t\t\terr = -EBUSY;\n\t\telse if (root_stable_tree == one_stable_tree) {\n\t\t\tstruct rb_root *buf;\n\t\t\t/*\n\t\t\t * This is the first time that we switch away from the\n\t\t\t * default of merging across nodes: must now allocate\n\t\t\t * a buffer to hold as many roots as may be needed.\n\t\t\t * Allocate stable and unstable together:\n\t\t\t * MAXSMP NODES_SHIFT 10 will use 16kB.\n\t\t\t */\n\t\t\tbuf = kcalloc(nr_node_ids + nr_node_ids, sizeof(*buf),\n\t\t\t\t      GFP_KERNEL);\n\t\t\t/* Let us assume that RB_ROOT is NULL is zero */\n\t\t\tif (!buf)\n\t\t\t\terr = -ENOMEM;\n\t\t\telse {\n\t\t\t\troot_stable_tree = buf;\n\t\t\t\troot_unstable_tree = buf + nr_node_ids;\n\t\t\t\t/* Stable tree is empty but not the unstable */\n\t\t\t\troot_unstable_tree[0] = one_unstable_tree[0];\n\t\t\t}\n\t\t}\n\t\tif (!err) {\n\t\t\tksm_merge_across_nodes = knob;\n\t\t\tksm_nr_node_ids = knob ? 1 : nr_node_ids;\n\t\t}\n\t}\n\tmutex_unlock(&ksm_thread_mutex);\n\n\treturn err ? err : count;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define ksm_nr_node_ids\t\t1",
      "#define ksm_merge_across_nodes\t1U"
    ],
    "globals_used": [
      "static struct rb_root one_stable_tree[1] = { RB_ROOT };",
      "static struct rb_root one_unstable_tree[1] = { RB_ROOT };",
      "static struct rb_root *root_stable_tree = one_stable_tree;",
      "static struct rb_root *root_unstable_tree = one_unstable_tree;",
      "static unsigned long ksm_pages_shared;",
      "static void wait_while_offlining(void);",
      "static DEFINE_MUTEX(ksm_thread_mutex);",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ksm_thread_mutex"
          ],
          "line": 2954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nr_node_ids + nr_node_ids",
            "sizeof(*buf)",
            "GFP_KERNEL"
          ],
          "line": 2937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_all_stable_nodes",
          "args": [],
          "line": 2926
        },
        "resolved": true,
        "details": {
          "function_name": "remove_all_stable_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "923-947",
          "snippet": "static int remove_all_stable_nodes(void)\n{\n\tstruct stable_node *stable_node, *next;\n\tint nid;\n\tint err = 0;\n\n\tfor (nid = 0; nid < ksm_nr_node_ids; nid++) {\n\t\twhile (root_stable_tree[nid].rb_node) {\n\t\t\tstable_node = rb_entry(root_stable_tree[nid].rb_node,\n\t\t\t\t\t\tstruct stable_node, node);\n\t\t\tif (remove_stable_node_chain(stable_node,\n\t\t\t\t\t\t     root_stable_tree + nid)) {\n\t\t\t\terr = -EBUSY;\n\t\t\t\tbreak;\t/* proceed to next nid */\n\t\t\t}\n\t\t\tcond_resched();\n\t\t}\n\t}\n\tlist_for_each_entry_safe(stable_node, next, &migrate_nodes, list) {\n\t\tif (remove_stable_node(stable_node))\n\t\t\terr = -EBUSY;\n\t\tcond_resched();\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define ksm_nr_node_ids\t\t1"
          ],
          "globals_used": [
            "static struct rb_root *root_stable_tree = one_stable_tree;",
            "static LIST_HEAD(migrate_nodes);",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define ksm_nr_node_ids\t\t1\n\nstatic struct rb_root *root_stable_tree = one_stable_tree;\nstatic LIST_HEAD(migrate_nodes);\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int remove_all_stable_nodes(void)\n{\n\tstruct stable_node *stable_node, *next;\n\tint nid;\n\tint err = 0;\n\n\tfor (nid = 0; nid < ksm_nr_node_ids; nid++) {\n\t\twhile (root_stable_tree[nid].rb_node) {\n\t\t\tstable_node = rb_entry(root_stable_tree[nid].rb_node,\n\t\t\t\t\t\tstruct stable_node, node);\n\t\t\tif (remove_stable_node_chain(stable_node,\n\t\t\t\t\t\t     root_stable_tree + nid)) {\n\t\t\t\terr = -EBUSY;\n\t\t\t\tbreak;\t/* proceed to next nid */\n\t\t\t}\n\t\t\tcond_resched();\n\t\t}\n\t}\n\tlist_for_each_entry_safe(stable_node, next, &migrate_nodes, list) {\n\t\tif (remove_stable_node(stable_node))\n\t\t\terr = -EBUSY;\n\t\tcond_resched();\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_while_offlining",
          "args": [],
          "line": 2924
        },
        "resolved": true,
        "details": {
          "function_name": "wait_while_offlining",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "2793-2795",
          "snippet": "static void wait_while_offlining(void)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wait_while_offlining(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic void wait_while_offlining(void);\n\nstatic void wait_while_offlining(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ksm_thread_mutex"
          ],
          "line": 2923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "buf",
            "10",
            "&knob"
          ],
          "line": 2917
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define ksm_nr_node_ids\t\t1\n#define ksm_merge_across_nodes\t1U\n\nstatic struct rb_root one_stable_tree[1] = { RB_ROOT };\nstatic struct rb_root one_unstable_tree[1] = { RB_ROOT };\nstatic struct rb_root *root_stable_tree = one_stable_tree;\nstatic struct rb_root *root_unstable_tree = one_unstable_tree;\nstatic unsigned long ksm_pages_shared;\nstatic void wait_while_offlining(void);\nstatic DEFINE_MUTEX(ksm_thread_mutex);\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic ssize_t merge_across_nodes_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tint err;\n\tunsigned long knob;\n\n\terr = kstrtoul(buf, 10, &knob);\n\tif (err)\n\t\treturn err;\n\tif (knob > 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ksm_thread_mutex);\n\twait_while_offlining();\n\tif (ksm_merge_across_nodes != knob) {\n\t\tif (ksm_pages_shared || remove_all_stable_nodes())\n\t\t\terr = -EBUSY;\n\t\telse if (root_stable_tree == one_stable_tree) {\n\t\t\tstruct rb_root *buf;\n\t\t\t/*\n\t\t\t * This is the first time that we switch away from the\n\t\t\t * default of merging across nodes: must now allocate\n\t\t\t * a buffer to hold as many roots as may be needed.\n\t\t\t * Allocate stable and unstable together:\n\t\t\t * MAXSMP NODES_SHIFT 10 will use 16kB.\n\t\t\t */\n\t\t\tbuf = kcalloc(nr_node_ids + nr_node_ids, sizeof(*buf),\n\t\t\t\t      GFP_KERNEL);\n\t\t\t/* Let us assume that RB_ROOT is NULL is zero */\n\t\t\tif (!buf)\n\t\t\t\terr = -ENOMEM;\n\t\t\telse {\n\t\t\t\troot_stable_tree = buf;\n\t\t\t\troot_unstable_tree = buf + nr_node_ids;\n\t\t\t\t/* Stable tree is empty but not the unstable */\n\t\t\t\troot_unstable_tree[0] = one_unstable_tree[0];\n\t\t\t}\n\t\t}\n\t\tif (!err) {\n\t\t\tksm_merge_across_nodes = knob;\n\t\t\tksm_nr_node_ids = knob ? 1 : nr_node_ids;\n\t\t}\n\t}\n\tmutex_unlock(&ksm_thread_mutex);\n\n\treturn err ? err : count;\n}"
  },
  {
    "function_name": "merge_across_nodes_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2904-2908",
    "snippet": "static ssize_t merge_across_nodes_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", ksm_merge_across_nodes);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define ksm_merge_across_nodes\t1U"
    ],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "ksm_merge_across_nodes"
          ],
          "line": 2907
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define ksm_merge_across_nodes\t1U\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic ssize_t merge_across_nodes_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", ksm_merge_across_nodes);\n}"
  },
  {
    "function_name": "run_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2861-2900",
    "snippet": "static ssize_t run_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tint err;\n\tunsigned long flags;\n\n\terr = kstrtoul(buf, 10, &flags);\n\tif (err || flags > UINT_MAX)\n\t\treturn -EINVAL;\n\tif (flags > KSM_RUN_UNMERGE)\n\t\treturn -EINVAL;\n\n\t/*\n\t * KSM_RUN_MERGE sets ksmd running, and 0 stops it running.\n\t * KSM_RUN_UNMERGE stops it running and unmerges all rmap_items,\n\t * breaking COW to free the pages_shared (but leaves mm_slots\n\t * on the list for when ksmd may be set running again).\n\t */\n\n\tmutex_lock(&ksm_thread_mutex);\n\twait_while_offlining();\n\tif (ksm_run != flags) {\n\t\tksm_run = flags;\n\t\tif (flags & KSM_RUN_UNMERGE) {\n\t\t\tset_current_oom_origin();\n\t\t\terr = unmerge_and_remove_all_rmap_items();\n\t\t\tclear_current_oom_origin();\n\t\t\tif (err) {\n\t\t\t\tksm_run = KSM_RUN_STOP;\n\t\t\t\tcount = err;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&ksm_thread_mutex);\n\n\tif (flags & KSM_RUN_MERGE)\n\t\twake_up_interruptible(&ksm_thread_wait);\n\n\treturn count;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define KSM_RUN_UNMERGE\t2",
      "#define KSM_RUN_MERGE\t1",
      "#define KSM_RUN_STOP\t0"
    ],
    "globals_used": [
      "static unsigned long ksm_run = KSM_RUN_STOP;",
      "static void wait_while_offlining(void);",
      "static DECLARE_WAIT_QUEUE_HEAD(ksm_thread_wait);",
      "static DEFINE_MUTEX(ksm_thread_mutex);",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&ksm_thread_wait"
          ],
          "line": 2897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ksm_thread_mutex"
          ],
          "line": 2894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_current_oom_origin",
          "args": [],
          "line": 2887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmerge_and_remove_all_rmap_items",
          "args": [],
          "line": 2886
        },
        "resolved": true,
        "details": {
          "function_name": "unmerge_and_remove_all_rmap_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "949-1005",
          "snippet": "static int unmerge_and_remove_all_rmap_items(void)\n{\n\tstruct mm_slot *mm_slot;\n\tstruct mm_struct *mm;\n\tstruct vm_area_struct *vma;\n\tint err = 0;\n\n\tspin_lock(&ksm_mmlist_lock);\n\tksm_scan.mm_slot = list_entry(ksm_mm_head.mm_list.next,\n\t\t\t\t\t\tstruct mm_slot, mm_list);\n\tspin_unlock(&ksm_mmlist_lock);\n\n\tfor (mm_slot = ksm_scan.mm_slot;\n\t\t\tmm_slot != &ksm_mm_head; mm_slot = ksm_scan.mm_slot) {\n\t\tmm = mm_slot->mm;\n\t\tdown_read(&mm->mmap_sem);\n\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\t\tif (ksm_test_exit(mm))\n\t\t\t\tbreak;\n\t\t\tif (!(vma->vm_flags & VM_MERGEABLE) || !vma->anon_vma)\n\t\t\t\tcontinue;\n\t\t\terr = unmerge_ksm_pages(vma,\n\t\t\t\t\t\tvma->vm_start, vma->vm_end);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tremove_trailing_rmap_items(mm_slot, &mm_slot->rmap_list);\n\t\tup_read(&mm->mmap_sem);\n\n\t\tspin_lock(&ksm_mmlist_lock);\n\t\tksm_scan.mm_slot = list_entry(mm_slot->mm_list.next,\n\t\t\t\t\t\tstruct mm_slot, mm_list);\n\t\tif (ksm_test_exit(mm)) {\n\t\t\thash_del(&mm_slot->link);\n\t\t\tlist_del(&mm_slot->mm_list);\n\t\t\tspin_unlock(&ksm_mmlist_lock);\n\n\t\t\tfree_mm_slot(mm_slot);\n\t\t\tclear_bit(MMF_VM_MERGEABLE, &mm->flags);\n\t\t\tmmdrop(mm);\n\t\t} else\n\t\t\tspin_unlock(&ksm_mmlist_lock);\n\t}\n\n\t/* Clean up stable nodes, but don't worry if some are still busy */\n\tremove_all_stable_nodes();\n\tksm_scan.seqnr = 0;\n\treturn 0;\n\nerror:\n\tup_read(&mm->mmap_sem);\n\tspin_lock(&ksm_mmlist_lock);\n\tksm_scan.mm_slot = &ksm_mm_head;\n\tspin_unlock(&ksm_mmlist_lock);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct mm_slot ksm_mm_head = {\n\t.mm_list = LIST_HEAD_INIT(ksm_mm_head.mm_list),\n};",
            "static struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};",
            "static DEFINE_SPINLOCK(ksm_mmlist_lock);",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct mm_slot ksm_mm_head = {\n\t.mm_list = LIST_HEAD_INIT(ksm_mm_head.mm_list),\n};\nstatic struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};\nstatic DEFINE_SPINLOCK(ksm_mmlist_lock);\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int unmerge_and_remove_all_rmap_items(void)\n{\n\tstruct mm_slot *mm_slot;\n\tstruct mm_struct *mm;\n\tstruct vm_area_struct *vma;\n\tint err = 0;\n\n\tspin_lock(&ksm_mmlist_lock);\n\tksm_scan.mm_slot = list_entry(ksm_mm_head.mm_list.next,\n\t\t\t\t\t\tstruct mm_slot, mm_list);\n\tspin_unlock(&ksm_mmlist_lock);\n\n\tfor (mm_slot = ksm_scan.mm_slot;\n\t\t\tmm_slot != &ksm_mm_head; mm_slot = ksm_scan.mm_slot) {\n\t\tmm = mm_slot->mm;\n\t\tdown_read(&mm->mmap_sem);\n\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\t\tif (ksm_test_exit(mm))\n\t\t\t\tbreak;\n\t\t\tif (!(vma->vm_flags & VM_MERGEABLE) || !vma->anon_vma)\n\t\t\t\tcontinue;\n\t\t\terr = unmerge_ksm_pages(vma,\n\t\t\t\t\t\tvma->vm_start, vma->vm_end);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tremove_trailing_rmap_items(mm_slot, &mm_slot->rmap_list);\n\t\tup_read(&mm->mmap_sem);\n\n\t\tspin_lock(&ksm_mmlist_lock);\n\t\tksm_scan.mm_slot = list_entry(mm_slot->mm_list.next,\n\t\t\t\t\t\tstruct mm_slot, mm_list);\n\t\tif (ksm_test_exit(mm)) {\n\t\t\thash_del(&mm_slot->link);\n\t\t\tlist_del(&mm_slot->mm_list);\n\t\t\tspin_unlock(&ksm_mmlist_lock);\n\n\t\t\tfree_mm_slot(mm_slot);\n\t\t\tclear_bit(MMF_VM_MERGEABLE, &mm->flags);\n\t\t\tmmdrop(mm);\n\t\t} else\n\t\t\tspin_unlock(&ksm_mmlist_lock);\n\t}\n\n\t/* Clean up stable nodes, but don't worry if some are still busy */\n\tremove_all_stable_nodes();\n\tksm_scan.seqnr = 0;\n\treturn 0;\n\nerror:\n\tup_read(&mm->mmap_sem);\n\tspin_lock(&ksm_mmlist_lock);\n\tksm_scan.mm_slot = &ksm_mm_head;\n\tspin_unlock(&ksm_mmlist_lock);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_oom_origin",
          "args": [],
          "line": 2885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_while_offlining",
          "args": [],
          "line": 2881
        },
        "resolved": true,
        "details": {
          "function_name": "wait_while_offlining",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "2793-2795",
          "snippet": "static void wait_while_offlining(void)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wait_while_offlining(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic void wait_while_offlining(void);\n\nstatic void wait_while_offlining(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ksm_thread_mutex"
          ],
          "line": 2880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "buf",
            "10",
            "&flags"
          ],
          "line": 2867
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define KSM_RUN_UNMERGE\t2\n#define KSM_RUN_MERGE\t1\n#define KSM_RUN_STOP\t0\n\nstatic unsigned long ksm_run = KSM_RUN_STOP;\nstatic void wait_while_offlining(void);\nstatic DECLARE_WAIT_QUEUE_HEAD(ksm_thread_wait);\nstatic DEFINE_MUTEX(ksm_thread_mutex);\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic ssize_t run_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tint err;\n\tunsigned long flags;\n\n\terr = kstrtoul(buf, 10, &flags);\n\tif (err || flags > UINT_MAX)\n\t\treturn -EINVAL;\n\tif (flags > KSM_RUN_UNMERGE)\n\t\treturn -EINVAL;\n\n\t/*\n\t * KSM_RUN_MERGE sets ksmd running, and 0 stops it running.\n\t * KSM_RUN_UNMERGE stops it running and unmerges all rmap_items,\n\t * breaking COW to free the pages_shared (but leaves mm_slots\n\t * on the list for when ksmd may be set running again).\n\t */\n\n\tmutex_lock(&ksm_thread_mutex);\n\twait_while_offlining();\n\tif (ksm_run != flags) {\n\t\tksm_run = flags;\n\t\tif (flags & KSM_RUN_UNMERGE) {\n\t\t\tset_current_oom_origin();\n\t\t\terr = unmerge_and_remove_all_rmap_items();\n\t\t\tclear_current_oom_origin();\n\t\t\tif (err) {\n\t\t\t\tksm_run = KSM_RUN_STOP;\n\t\t\t\tcount = err;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&ksm_thread_mutex);\n\n\tif (flags & KSM_RUN_MERGE)\n\t\twake_up_interruptible(&ksm_thread_wait);\n\n\treturn count;\n}"
  },
  {
    "function_name": "run_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2855-2859",
    "snippet": "static ssize_t run_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\tchar *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", ksm_run);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long ksm_run = KSM_RUN_STOP;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%lu\\n\"",
            "ksm_run"
          ],
          "line": 2858
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic unsigned long ksm_run = KSM_RUN_STOP;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic ssize_t run_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\tchar *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", ksm_run);\n}"
  },
  {
    "function_name": "pages_to_scan_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2838-2852",
    "snippet": "static ssize_t pages_to_scan_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tint err;\n\tunsigned long nr_pages;\n\n\terr = kstrtoul(buf, 10, &nr_pages);\n\tif (err || nr_pages > UINT_MAX)\n\t\treturn -EINVAL;\n\n\tksm_thread_pages_to_scan = nr_pages;\n\n\treturn count;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int ksm_thread_pages_to_scan = 100;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "buf",
            "10",
            "&nr_pages"
          ],
          "line": 2845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic unsigned int ksm_thread_pages_to_scan = 100;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic ssize_t pages_to_scan_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tint err;\n\tunsigned long nr_pages;\n\n\terr = kstrtoul(buf, 10, &nr_pages);\n\tif (err || nr_pages > UINT_MAX)\n\t\treturn -EINVAL;\n\n\tksm_thread_pages_to_scan = nr_pages;\n\n\treturn count;\n}"
  },
  {
    "function_name": "pages_to_scan_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2832-2836",
    "snippet": "static ssize_t pages_to_scan_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", ksm_thread_pages_to_scan);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int ksm_thread_pages_to_scan = 100;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "ksm_thread_pages_to_scan"
          ],
          "line": 2835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic unsigned int ksm_thread_pages_to_scan = 100;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic ssize_t pages_to_scan_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", ksm_thread_pages_to_scan);\n}"
  },
  {
    "function_name": "sleep_millisecs_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2815-2829",
    "snippet": "static ssize_t sleep_millisecs_store(struct kobject *kobj,\n\t\t\t\t     struct kobj_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tunsigned long msecs;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &msecs);\n\tif (err || msecs > UINT_MAX)\n\t\treturn -EINVAL;\n\n\tksm_thread_sleep_millisecs = msecs;\n\n\treturn count;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int ksm_thread_sleep_millisecs = 20;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "buf",
            "10",
            "&msecs"
          ],
          "line": 2822
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic unsigned int ksm_thread_sleep_millisecs = 20;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic ssize_t sleep_millisecs_store(struct kobject *kobj,\n\t\t\t\t     struct kobj_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tunsigned long msecs;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &msecs);\n\tif (err || msecs > UINT_MAX)\n\t\treturn -EINVAL;\n\n\tksm_thread_sleep_millisecs = msecs;\n\n\treturn count;\n}"
  },
  {
    "function_name": "sleep_millisecs_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2809-2813",
    "snippet": "static ssize_t sleep_millisecs_show(struct kobject *kobj,\n\t\t\t\t    struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", ksm_thread_sleep_millisecs);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int ksm_thread_sleep_millisecs = 20;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "ksm_thread_sleep_millisecs"
          ],
          "line": 2812
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic unsigned int ksm_thread_sleep_millisecs = 20;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic ssize_t sleep_millisecs_show(struct kobject *kobj,\n\t\t\t\t    struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", ksm_thread_sleep_millisecs);\n}"
  },
  {
    "function_name": "wait_while_offlining",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2793-2795",
    "snippet": "static void wait_while_offlining(void)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wait_while_offlining(void);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic void wait_while_offlining(void);\n\nstatic void wait_while_offlining(void)\n{\n}"
  },
  {
    "function_name": "ksm_memory_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2750-2791",
    "snippet": "static int ksm_memory_callback(struct notifier_block *self,\n\t\t\t       unsigned long action, void *arg)\n{\n\tstruct memory_notify *mn = arg;\n\n\tswitch (action) {\n\tcase MEM_GOING_OFFLINE:\n\t\t/*\n\t\t * Prevent ksm_do_scan(), unmerge_and_remove_all_rmap_items()\n\t\t * and remove_all_stable_nodes() while memory is going offline:\n\t\t * it is unsafe for them to touch the stable tree at this time.\n\t\t * But unmerge_ksm_pages(), rmap lookups and other entry points\n\t\t * which do not need the ksm_thread_mutex are all safe.\n\t\t */\n\t\tmutex_lock(&ksm_thread_mutex);\n\t\tksm_run |= KSM_RUN_OFFLINE;\n\t\tmutex_unlock(&ksm_thread_mutex);\n\t\tbreak;\n\n\tcase MEM_OFFLINE:\n\t\t/*\n\t\t * Most of the work is done by page migration; but there might\n\t\t * be a few stable_nodes left over, still pointing to struct\n\t\t * pages which have been offlined: prune those from the tree,\n\t\t * otherwise get_ksm_page() might later try to access a\n\t\t * non-existent struct page.\n\t\t */\n\t\tksm_check_stable_tree(mn->start_pfn,\n\t\t\t\t      mn->start_pfn + mn->nr_pages);\n\t\t/* fallthrough */\n\n\tcase MEM_CANCEL_OFFLINE:\n\t\tmutex_lock(&ksm_thread_mutex);\n\t\tksm_run &= ~KSM_RUN_OFFLINE;\n\t\tmutex_unlock(&ksm_thread_mutex);\n\n\t\tsmp_mb();\t/* wake_up_bit advises this */\n\t\twake_up_bit(&ksm_run, ilog2(KSM_RUN_OFFLINE));\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define KSM_RUN_OFFLINE\t4"
    ],
    "globals_used": [
      "static unsigned long ksm_run = KSM_RUN_STOP;",
      "static DEFINE_MUTEX(ksm_thread_mutex);",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&ksm_run",
            "ilog2(KSM_RUN_OFFLINE)"
          ],
          "line": 2787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "KSM_RUN_OFFLINE"
          ],
          "line": 2787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 2786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ksm_thread_mutex"
          ],
          "line": 2784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ksm_thread_mutex"
          ],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ksm_check_stable_tree",
          "args": [
            "mn->start_pfn",
            "mn->start_pfn + mn->nr_pages"
          ],
          "line": 2777
        },
        "resolved": true,
        "details": {
          "function_name": "ksm_check_stable_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "2721-2748",
          "snippet": "static void ksm_check_stable_tree(unsigned long start_pfn,\n\t\t\t\t  unsigned long end_pfn)\n{\n\tstruct stable_node *stable_node, *next;\n\tstruct rb_node *node;\n\tint nid;\n\n\tfor (nid = 0; nid < ksm_nr_node_ids; nid++) {\n\t\tnode = rb_first(root_stable_tree + nid);\n\t\twhile (node) {\n\t\t\tstable_node = rb_entry(node, struct stable_node, node);\n\t\t\tif (stable_node_chain_remove_range(stable_node,\n\t\t\t\t\t\t\t   start_pfn, end_pfn,\n\t\t\t\t\t\t\t   root_stable_tree +\n\t\t\t\t\t\t\t   nid))\n\t\t\t\tnode = rb_first(root_stable_tree + nid);\n\t\t\telse\n\t\t\t\tnode = rb_next(node);\n\t\t\tcond_resched();\n\t\t}\n\t}\n\tlist_for_each_entry_safe(stable_node, next, &migrate_nodes, list) {\n\t\tif (stable_node->kpfn >= start_pfn &&\n\t\t    stable_node->kpfn < end_pfn)\n\t\t\tremove_node_from_stable_tree(stable_node);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define ksm_nr_node_ids\t\t1"
          ],
          "globals_used": [
            "static struct rb_root *root_stable_tree = one_stable_tree;",
            "static LIST_HEAD(migrate_nodes);",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define ksm_nr_node_ids\t\t1\n\nstatic struct rb_root *root_stable_tree = one_stable_tree;\nstatic LIST_HEAD(migrate_nodes);\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic void ksm_check_stable_tree(unsigned long start_pfn,\n\t\t\t\t  unsigned long end_pfn)\n{\n\tstruct stable_node *stable_node, *next;\n\tstruct rb_node *node;\n\tint nid;\n\n\tfor (nid = 0; nid < ksm_nr_node_ids; nid++) {\n\t\tnode = rb_first(root_stable_tree + nid);\n\t\twhile (node) {\n\t\t\tstable_node = rb_entry(node, struct stable_node, node);\n\t\t\tif (stable_node_chain_remove_range(stable_node,\n\t\t\t\t\t\t\t   start_pfn, end_pfn,\n\t\t\t\t\t\t\t   root_stable_tree +\n\t\t\t\t\t\t\t   nid))\n\t\t\t\tnode = rb_first(root_stable_tree + nid);\n\t\t\telse\n\t\t\t\tnode = rb_next(node);\n\t\t\tcond_resched();\n\t\t}\n\t}\n\tlist_for_each_entry_safe(stable_node, next, &migrate_nodes, list) {\n\t\tif (stable_node->kpfn >= start_pfn &&\n\t\t    stable_node->kpfn < end_pfn)\n\t\t\tremove_node_from_stable_tree(stable_node);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ksm_thread_mutex"
          ],
          "line": 2766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ksm_thread_mutex"
          ],
          "line": 2764
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define KSM_RUN_OFFLINE\t4\n\nstatic unsigned long ksm_run = KSM_RUN_STOP;\nstatic DEFINE_MUTEX(ksm_thread_mutex);\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int ksm_memory_callback(struct notifier_block *self,\n\t\t\t       unsigned long action, void *arg)\n{\n\tstruct memory_notify *mn = arg;\n\n\tswitch (action) {\n\tcase MEM_GOING_OFFLINE:\n\t\t/*\n\t\t * Prevent ksm_do_scan(), unmerge_and_remove_all_rmap_items()\n\t\t * and remove_all_stable_nodes() while memory is going offline:\n\t\t * it is unsafe for them to touch the stable tree at this time.\n\t\t * But unmerge_ksm_pages(), rmap lookups and other entry points\n\t\t * which do not need the ksm_thread_mutex are all safe.\n\t\t */\n\t\tmutex_lock(&ksm_thread_mutex);\n\t\tksm_run |= KSM_RUN_OFFLINE;\n\t\tmutex_unlock(&ksm_thread_mutex);\n\t\tbreak;\n\n\tcase MEM_OFFLINE:\n\t\t/*\n\t\t * Most of the work is done by page migration; but there might\n\t\t * be a few stable_nodes left over, still pointing to struct\n\t\t * pages which have been offlined: prune those from the tree,\n\t\t * otherwise get_ksm_page() might later try to access a\n\t\t * non-existent struct page.\n\t\t */\n\t\tksm_check_stable_tree(mn->start_pfn,\n\t\t\t\t      mn->start_pfn + mn->nr_pages);\n\t\t/* fallthrough */\n\n\tcase MEM_CANCEL_OFFLINE:\n\t\tmutex_lock(&ksm_thread_mutex);\n\t\tksm_run &= ~KSM_RUN_OFFLINE;\n\t\tmutex_unlock(&ksm_thread_mutex);\n\n\t\tsmp_mb();\t/* wake_up_bit advises this */\n\t\twake_up_bit(&ksm_run, ilog2(KSM_RUN_OFFLINE));\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}"
  },
  {
    "function_name": "ksm_check_stable_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2721-2748",
    "snippet": "static void ksm_check_stable_tree(unsigned long start_pfn,\n\t\t\t\t  unsigned long end_pfn)\n{\n\tstruct stable_node *stable_node, *next;\n\tstruct rb_node *node;\n\tint nid;\n\n\tfor (nid = 0; nid < ksm_nr_node_ids; nid++) {\n\t\tnode = rb_first(root_stable_tree + nid);\n\t\twhile (node) {\n\t\t\tstable_node = rb_entry(node, struct stable_node, node);\n\t\t\tif (stable_node_chain_remove_range(stable_node,\n\t\t\t\t\t\t\t   start_pfn, end_pfn,\n\t\t\t\t\t\t\t   root_stable_tree +\n\t\t\t\t\t\t\t   nid))\n\t\t\t\tnode = rb_first(root_stable_tree + nid);\n\t\t\telse\n\t\t\t\tnode = rb_next(node);\n\t\t\tcond_resched();\n\t\t}\n\t}\n\tlist_for_each_entry_safe(stable_node, next, &migrate_nodes, list) {\n\t\tif (stable_node->kpfn >= start_pfn &&\n\t\t    stable_node->kpfn < end_pfn)\n\t\t\tremove_node_from_stable_tree(stable_node);\n\t\tcond_resched();\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define ksm_nr_node_ids\t\t1"
    ],
    "globals_used": [
      "static struct rb_root *root_stable_tree = one_stable_tree;",
      "static LIST_HEAD(migrate_nodes);",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_node_from_stable_tree",
          "args": [
            "stable_node"
          ],
          "line": 2745
        },
        "resolved": true,
        "details": {
          "function_name": "remove_node_from_stable_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "631-667",
          "snippet": "static void remove_node_from_stable_tree(struct stable_node *stable_node)\n{\n\tstruct rmap_item *rmap_item;\n\n\t/* check it's not STABLE_NODE_CHAIN or negative */\n\tBUG_ON(stable_node->rmap_hlist_len < 0);\n\n\thlist_for_each_entry(rmap_item, &stable_node->hlist, hlist) {\n\t\tif (rmap_item->hlist.next)\n\t\t\tksm_pages_sharing--;\n\t\telse\n\t\t\tksm_pages_shared--;\n\t\tVM_BUG_ON(stable_node->rmap_hlist_len <= 0);\n\t\tstable_node->rmap_hlist_len--;\n\t\tput_anon_vma(rmap_item->anon_vma);\n\t\trmap_item->address &= PAGE_MASK;\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * We need the second aligned pointer of the migrate_nodes\n\t * list_head to stay clear from the rb_parent_color union\n\t * (aligned and different than any node) and also different\n\t * from &migrate_nodes. This will verify that future list.h changes\n\t * don't break STABLE_NODE_DUP_HEAD. Only recent gcc can handle it.\n\t */\n#if defined(GCC_VERSION) && GCC_VERSION >= 40903\n\tBUILD_BUG_ON(STABLE_NODE_DUP_HEAD <= &migrate_nodes);\n\tBUILD_BUG_ON(STABLE_NODE_DUP_HEAD >= &migrate_nodes + 1);\n#endif\n\n\tif (stable_node->head == &migrate_nodes)\n\t\tlist_del(&stable_node->list);\n\telse\n\t\tstable_node_dup_del(stable_node);\n\tfree_stable_node(stable_node);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)",
            "#define STABLE_NODE_CHAIN -1024"
          ],
          "globals_used": [
            "static LIST_HEAD(migrate_nodes);",
            "static unsigned long ksm_pages_shared;",
            "static unsigned long ksm_pages_sharing;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)\n#define STABLE_NODE_CHAIN -1024\n\nstatic LIST_HEAD(migrate_nodes);\nstatic unsigned long ksm_pages_shared;\nstatic unsigned long ksm_pages_sharing;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic void remove_node_from_stable_tree(struct stable_node *stable_node)\n{\n\tstruct rmap_item *rmap_item;\n\n\t/* check it's not STABLE_NODE_CHAIN or negative */\n\tBUG_ON(stable_node->rmap_hlist_len < 0);\n\n\thlist_for_each_entry(rmap_item, &stable_node->hlist, hlist) {\n\t\tif (rmap_item->hlist.next)\n\t\t\tksm_pages_sharing--;\n\t\telse\n\t\t\tksm_pages_shared--;\n\t\tVM_BUG_ON(stable_node->rmap_hlist_len <= 0);\n\t\tstable_node->rmap_hlist_len--;\n\t\tput_anon_vma(rmap_item->anon_vma);\n\t\trmap_item->address &= PAGE_MASK;\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * We need the second aligned pointer of the migrate_nodes\n\t * list_head to stay clear from the rb_parent_color union\n\t * (aligned and different than any node) and also different\n\t * from &migrate_nodes. This will verify that future list.h changes\n\t * don't break STABLE_NODE_DUP_HEAD. Only recent gcc can handle it.\n\t */\n#if defined(GCC_VERSION) && GCC_VERSION >= 40903\n\tBUILD_BUG_ON(STABLE_NODE_DUP_HEAD <= &migrate_nodes);\n\tBUILD_BUG_ON(STABLE_NODE_DUP_HEAD >= &migrate_nodes + 1);\n#endif\n\n\tif (stable_node->head == &migrate_nodes)\n\t\tlist_del(&stable_node->list);\n\telse\n\t\tstable_node_dup_del(stable_node);\n\tfree_stable_node(stable_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "stable_node",
            "next",
            "&migrate_nodes",
            "list"
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "node"
          ],
          "line": 2738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "root_stable_tree + nid"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stable_node_chain_remove_range",
          "args": [
            "stable_node",
            "start_pfn",
            "end_pfn",
            "root_stable_tree +\n\t\t\t\t\t\t\t   nid"
          ],
          "line": 2732
        },
        "resolved": true,
        "details": {
          "function_name": "stable_node_chain_remove_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "2695-2719",
          "snippet": "static bool stable_node_chain_remove_range(struct stable_node *stable_node,\n\t\t\t\t\t   unsigned long start_pfn,\n\t\t\t\t\t   unsigned long end_pfn,\n\t\t\t\t\t   struct rb_root *root)\n{\n\tstruct stable_node *dup;\n\tstruct hlist_node *hlist_safe;\n\n\tif (!is_stable_node_chain(stable_node)) {\n\t\tVM_BUG_ON(is_stable_node_dup(stable_node));\n\t\treturn stable_node_dup_remove_range(stable_node, start_pfn,\n\t\t\t\t\t\t    end_pfn);\n\t}\n\n\thlist_for_each_entry_safe(dup, hlist_safe,\n\t\t\t\t  &stable_node->hlist, hlist_dup) {\n\t\tVM_BUG_ON(!is_stable_node_dup(dup));\n\t\tstable_node_dup_remove_range(dup, start_pfn, end_pfn);\n\t}\n\tif (hlist_empty(&stable_node->hlist)) {\n\t\tfree_stable_node_chain(stable_node, root);\n\t\treturn true; /* notify caller that tree was rebalanced */\n\t} else\n\t\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic bool stable_node_chain_remove_range(struct stable_node *stable_node,\n\t\t\t\t\t   unsigned long start_pfn,\n\t\t\t\t\t   unsigned long end_pfn,\n\t\t\t\t\t   struct rb_root *root)\n{\n\tstruct stable_node *dup;\n\tstruct hlist_node *hlist_safe;\n\n\tif (!is_stable_node_chain(stable_node)) {\n\t\tVM_BUG_ON(is_stable_node_dup(stable_node));\n\t\treturn stable_node_dup_remove_range(stable_node, start_pfn,\n\t\t\t\t\t\t    end_pfn);\n\t}\n\n\thlist_for_each_entry_safe(dup, hlist_safe,\n\t\t\t\t  &stable_node->hlist, hlist_dup) {\n\t\tVM_BUG_ON(!is_stable_node_dup(dup));\n\t\tstable_node_dup_remove_range(dup, start_pfn, end_pfn);\n\t}\n\tif (hlist_empty(&stable_node->hlist)) {\n\t\tfree_stable_node_chain(stable_node, root);\n\t\treturn true; /* notify caller that tree was rebalanced */\n\t} else\n\t\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structstable_node",
            "node"
          ],
          "line": 2731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "root_stable_tree + nid"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define ksm_nr_node_ids\t\t1\n\nstatic struct rb_root *root_stable_tree = one_stable_tree;\nstatic LIST_HEAD(migrate_nodes);\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic void ksm_check_stable_tree(unsigned long start_pfn,\n\t\t\t\t  unsigned long end_pfn)\n{\n\tstruct stable_node *stable_node, *next;\n\tstruct rb_node *node;\n\tint nid;\n\n\tfor (nid = 0; nid < ksm_nr_node_ids; nid++) {\n\t\tnode = rb_first(root_stable_tree + nid);\n\t\twhile (node) {\n\t\t\tstable_node = rb_entry(node, struct stable_node, node);\n\t\t\tif (stable_node_chain_remove_range(stable_node,\n\t\t\t\t\t\t\t   start_pfn, end_pfn,\n\t\t\t\t\t\t\t   root_stable_tree +\n\t\t\t\t\t\t\t   nid))\n\t\t\t\tnode = rb_first(root_stable_tree + nid);\n\t\t\telse\n\t\t\t\tnode = rb_next(node);\n\t\t\tcond_resched();\n\t\t}\n\t}\n\tlist_for_each_entry_safe(stable_node, next, &migrate_nodes, list) {\n\t\tif (stable_node->kpfn >= start_pfn &&\n\t\t    stable_node->kpfn < end_pfn)\n\t\t\tremove_node_from_stable_tree(stable_node);\n\t\tcond_resched();\n\t}\n}"
  },
  {
    "function_name": "stable_node_chain_remove_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2695-2719",
    "snippet": "static bool stable_node_chain_remove_range(struct stable_node *stable_node,\n\t\t\t\t\t   unsigned long start_pfn,\n\t\t\t\t\t   unsigned long end_pfn,\n\t\t\t\t\t   struct rb_root *root)\n{\n\tstruct stable_node *dup;\n\tstruct hlist_node *hlist_safe;\n\n\tif (!is_stable_node_chain(stable_node)) {\n\t\tVM_BUG_ON(is_stable_node_dup(stable_node));\n\t\treturn stable_node_dup_remove_range(stable_node, start_pfn,\n\t\t\t\t\t\t    end_pfn);\n\t}\n\n\thlist_for_each_entry_safe(dup, hlist_safe,\n\t\t\t\t  &stable_node->hlist, hlist_dup) {\n\t\tVM_BUG_ON(!is_stable_node_dup(dup));\n\t\tstable_node_dup_remove_range(dup, start_pfn, end_pfn);\n\t}\n\tif (hlist_empty(&stable_node->hlist)) {\n\t\tfree_stable_node_chain(stable_node, root);\n\t\treturn true; /* notify caller that tree was rebalanced */\n\t} else\n\t\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_stable_node_chain",
          "args": [
            "stable_node",
            "root"
          ],
          "line": 2715
        },
        "resolved": true,
        "details": {
          "function_name": "free_stable_node_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "623-629",
          "snippet": "static inline void free_stable_node_chain(struct stable_node *chain,\n\t\t\t\t\t  struct rb_root *root)\n{\n\trb_erase(&chain->node, root);\n\tfree_stable_node(chain);\n\tksm_stable_node_chains--;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long ksm_stable_node_chains;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic unsigned long ksm_stable_node_chains;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void free_stable_node_chain(struct stable_node *chain,\n\t\t\t\t\t  struct rb_root *root)\n{\n\trb_erase(&chain->node, root);\n\tfree_stable_node(chain);\n\tksm_stable_node_chains--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&stable_node->hlist"
          ],
          "line": 2714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stable_node_dup_remove_range",
          "args": [
            "dup",
            "start_pfn",
            "end_pfn"
          ],
          "line": 2712
        },
        "resolved": true,
        "details": {
          "function_name": "stable_node_dup_remove_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "2679-2693",
          "snippet": "static bool stable_node_dup_remove_range(struct stable_node *stable_node,\n\t\t\t\t\t unsigned long start_pfn,\n\t\t\t\t\t unsigned long end_pfn)\n{\n\tif (stable_node->kpfn >= start_pfn &&\n\t    stable_node->kpfn < end_pfn) {\n\t\t/*\n\t\t * Don't get_ksm_page, page has already gone:\n\t\t * which is why we keep kpfn instead of page*\n\t\t */\n\t\tremove_node_from_stable_tree(stable_node);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic bool stable_node_dup_remove_range(struct stable_node *stable_node,\n\t\t\t\t\t unsigned long start_pfn,\n\t\t\t\t\t unsigned long end_pfn)\n{\n\tif (stable_node->kpfn >= start_pfn &&\n\t    stable_node->kpfn < end_pfn) {\n\t\t/*\n\t\t * Don't get_ksm_page, page has already gone:\n\t\t * which is why we keep kpfn instead of page*\n\t\t */\n\t\tremove_node_from_stable_tree(stable_node);\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!is_stable_node_dup(dup)"
          ],
          "line": 2711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_stable_node_dup",
          "args": [
            "dup"
          ],
          "line": 2711
        },
        "resolved": true,
        "details": {
          "function_name": "is_stable_node_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "343-346",
          "snippet": "static __always_inline bool is_stable_node_dup(struct stable_node *dup)\n{\n\treturn dup->head == STABLE_NODE_DUP_HEAD;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)"
          ],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic __always_inline bool is_stable_node_dup(struct stable_node *dup)\n{\n\treturn dup->head == STABLE_NODE_DUP_HEAD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "dup",
            "hlist_safe",
            "&stable_node->hlist",
            "hlist_dup"
          ],
          "line": 2709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "is_stable_node_dup(stable_node)"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_stable_node_chain",
          "args": [
            "stable_node"
          ],
          "line": 2703
        },
        "resolved": true,
        "details": {
          "function_name": "is_stable_node_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "338-341",
          "snippet": "static __always_inline bool is_stable_node_chain(struct stable_node *chain)\n{\n\treturn chain->rmap_hlist_len == STABLE_NODE_CHAIN;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_NODE_CHAIN -1024"
          ],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_CHAIN -1024\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic __always_inline bool is_stable_node_chain(struct stable_node *chain)\n{\n\treturn chain->rmap_hlist_len == STABLE_NODE_CHAIN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic bool stable_node_chain_remove_range(struct stable_node *stable_node,\n\t\t\t\t\t   unsigned long start_pfn,\n\t\t\t\t\t   unsigned long end_pfn,\n\t\t\t\t\t   struct rb_root *root)\n{\n\tstruct stable_node *dup;\n\tstruct hlist_node *hlist_safe;\n\n\tif (!is_stable_node_chain(stable_node)) {\n\t\tVM_BUG_ON(is_stable_node_dup(stable_node));\n\t\treturn stable_node_dup_remove_range(stable_node, start_pfn,\n\t\t\t\t\t\t    end_pfn);\n\t}\n\n\thlist_for_each_entry_safe(dup, hlist_safe,\n\t\t\t\t  &stable_node->hlist, hlist_dup) {\n\t\tVM_BUG_ON(!is_stable_node_dup(dup));\n\t\tstable_node_dup_remove_range(dup, start_pfn, end_pfn);\n\t}\n\tif (hlist_empty(&stable_node->hlist)) {\n\t\tfree_stable_node_chain(stable_node, root);\n\t\treturn true; /* notify caller that tree was rebalanced */\n\t} else\n\t\treturn false;\n}"
  },
  {
    "function_name": "stable_node_dup_remove_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2679-2693",
    "snippet": "static bool stable_node_dup_remove_range(struct stable_node *stable_node,\n\t\t\t\t\t unsigned long start_pfn,\n\t\t\t\t\t unsigned long end_pfn)\n{\n\tif (stable_node->kpfn >= start_pfn &&\n\t    stable_node->kpfn < end_pfn) {\n\t\t/*\n\t\t * Don't get_ksm_page, page has already gone:\n\t\t * which is why we keep kpfn instead of page*\n\t\t */\n\t\tremove_node_from_stable_tree(stable_node);\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_node_from_stable_tree",
          "args": [
            "stable_node"
          ],
          "line": 2689
        },
        "resolved": true,
        "details": {
          "function_name": "remove_node_from_stable_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "631-667",
          "snippet": "static void remove_node_from_stable_tree(struct stable_node *stable_node)\n{\n\tstruct rmap_item *rmap_item;\n\n\t/* check it's not STABLE_NODE_CHAIN or negative */\n\tBUG_ON(stable_node->rmap_hlist_len < 0);\n\n\thlist_for_each_entry(rmap_item, &stable_node->hlist, hlist) {\n\t\tif (rmap_item->hlist.next)\n\t\t\tksm_pages_sharing--;\n\t\telse\n\t\t\tksm_pages_shared--;\n\t\tVM_BUG_ON(stable_node->rmap_hlist_len <= 0);\n\t\tstable_node->rmap_hlist_len--;\n\t\tput_anon_vma(rmap_item->anon_vma);\n\t\trmap_item->address &= PAGE_MASK;\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * We need the second aligned pointer of the migrate_nodes\n\t * list_head to stay clear from the rb_parent_color union\n\t * (aligned and different than any node) and also different\n\t * from &migrate_nodes. This will verify that future list.h changes\n\t * don't break STABLE_NODE_DUP_HEAD. Only recent gcc can handle it.\n\t */\n#if defined(GCC_VERSION) && GCC_VERSION >= 40903\n\tBUILD_BUG_ON(STABLE_NODE_DUP_HEAD <= &migrate_nodes);\n\tBUILD_BUG_ON(STABLE_NODE_DUP_HEAD >= &migrate_nodes + 1);\n#endif\n\n\tif (stable_node->head == &migrate_nodes)\n\t\tlist_del(&stable_node->list);\n\telse\n\t\tstable_node_dup_del(stable_node);\n\tfree_stable_node(stable_node);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)",
            "#define STABLE_NODE_CHAIN -1024"
          ],
          "globals_used": [
            "static LIST_HEAD(migrate_nodes);",
            "static unsigned long ksm_pages_shared;",
            "static unsigned long ksm_pages_sharing;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)\n#define STABLE_NODE_CHAIN -1024\n\nstatic LIST_HEAD(migrate_nodes);\nstatic unsigned long ksm_pages_shared;\nstatic unsigned long ksm_pages_sharing;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic void remove_node_from_stable_tree(struct stable_node *stable_node)\n{\n\tstruct rmap_item *rmap_item;\n\n\t/* check it's not STABLE_NODE_CHAIN or negative */\n\tBUG_ON(stable_node->rmap_hlist_len < 0);\n\n\thlist_for_each_entry(rmap_item, &stable_node->hlist, hlist) {\n\t\tif (rmap_item->hlist.next)\n\t\t\tksm_pages_sharing--;\n\t\telse\n\t\t\tksm_pages_shared--;\n\t\tVM_BUG_ON(stable_node->rmap_hlist_len <= 0);\n\t\tstable_node->rmap_hlist_len--;\n\t\tput_anon_vma(rmap_item->anon_vma);\n\t\trmap_item->address &= PAGE_MASK;\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * We need the second aligned pointer of the migrate_nodes\n\t * list_head to stay clear from the rb_parent_color union\n\t * (aligned and different than any node) and also different\n\t * from &migrate_nodes. This will verify that future list.h changes\n\t * don't break STABLE_NODE_DUP_HEAD. Only recent gcc can handle it.\n\t */\n#if defined(GCC_VERSION) && GCC_VERSION >= 40903\n\tBUILD_BUG_ON(STABLE_NODE_DUP_HEAD <= &migrate_nodes);\n\tBUILD_BUG_ON(STABLE_NODE_DUP_HEAD >= &migrate_nodes + 1);\n#endif\n\n\tif (stable_node->head == &migrate_nodes)\n\t\tlist_del(&stable_node->list);\n\telse\n\t\tstable_node_dup_del(stable_node);\n\tfree_stable_node(stable_node);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic bool stable_node_dup_remove_range(struct stable_node *stable_node,\n\t\t\t\t\t unsigned long start_pfn,\n\t\t\t\t\t unsigned long end_pfn)\n{\n\tif (stable_node->kpfn >= start_pfn &&\n\t    stable_node->kpfn < end_pfn) {\n\t\t/*\n\t\t * Don't get_ksm_page, page has already gone:\n\t\t * which is why we keep kpfn instead of page*\n\t\t */\n\t\tremove_node_from_stable_tree(stable_node);\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "wait_while_offlining",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2669-2677",
    "snippet": "static void wait_while_offlining(void)\n{\n\twhile (ksm_run & KSM_RUN_OFFLINE) {\n\t\tmutex_unlock(&ksm_thread_mutex);\n\t\twait_on_bit(&ksm_run, ilog2(KSM_RUN_OFFLINE),\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\tmutex_lock(&ksm_thread_mutex);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define KSM_RUN_OFFLINE\t4"
    ],
    "globals_used": [
      "static unsigned long ksm_run = KSM_RUN_STOP;",
      "static void wait_while_offlining(void);",
      "static DEFINE_MUTEX(ksm_thread_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ksm_thread_mutex"
          ],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_bit",
          "args": [
            "&ksm_run",
            "ilog2(KSM_RUN_OFFLINE)",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 2673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "KSM_RUN_OFFLINE"
          ],
          "line": 2673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ksm_thread_mutex"
          ],
          "line": 2672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define KSM_RUN_OFFLINE\t4\n\nstatic unsigned long ksm_run = KSM_RUN_STOP;\nstatic void wait_while_offlining(void);\nstatic DEFINE_MUTEX(ksm_thread_mutex);\n\nstatic void wait_while_offlining(void)\n{\n\twhile (ksm_run & KSM_RUN_OFFLINE) {\n\t\tmutex_unlock(&ksm_thread_mutex);\n\t\twait_on_bit(&ksm_run, ilog2(KSM_RUN_OFFLINE),\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\tmutex_lock(&ksm_thread_mutex);\n\t}\n}"
  },
  {
    "function_name": "ksm_migrate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2644-2665",
    "snippet": "void ksm_migrate_page(struct page *newpage, struct page *oldpage)\n{\n\tstruct stable_node *stable_node;\n\n\tVM_BUG_ON_PAGE(!PageLocked(oldpage), oldpage);\n\tVM_BUG_ON_PAGE(!PageLocked(newpage), newpage);\n\tVM_BUG_ON_PAGE(newpage->mapping != oldpage->mapping, newpage);\n\n\tstable_node = page_stable_node(newpage);\n\tif (stable_node) {\n\t\tVM_BUG_ON_PAGE(stable_node->kpfn != page_to_pfn(oldpage), oldpage);\n\t\tstable_node->kpfn = page_to_pfn(newpage);\n\t\t/*\n\t\t * newpage->mapping was set in advance; now we need smp_wmb()\n\t\t * to make sure that the new stable_node->kpfn is visible\n\t\t * to get_ksm_page() before it can see that oldpage->mapping\n\t\t * has gone stale (or that PageSwapCache has been cleared).\n\t\t */\n\t\tsmp_wmb();\n\t\tset_page_stable_node(oldpage, NULL);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_page_stable_node",
          "args": [
            "oldpage",
            "NULL"
          ],
          "line": 2663
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_stable_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "850-854",
          "snippet": "static inline void set_page_stable_node(struct page *page,\n\t\t\t\t\tstruct stable_node *stable_node)\n{\n\tpage->mapping = (void *)((unsigned long)stable_node | PAGE_MAPPING_KSM);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void set_page_stable_node(struct page *page,\n\t\t\t\t\tstruct stable_node *stable_node)\n{\n\tpage->mapping = (void *)((unsigned long)stable_node | PAGE_MAPPING_KSM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 2662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "newpage"
          ],
          "line": 2655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "stable_node->kpfn != page_to_pfn(oldpage)",
            "oldpage"
          ],
          "line": 2654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "oldpage"
          ],
          "line": 2654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_stable_node",
          "args": [
            "newpage"
          ],
          "line": 2652
        },
        "resolved": true,
        "details": {
          "function_name": "page_stable_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "845-848",
          "snippet": "static inline struct stable_node *page_stable_node(struct page *page)\n{\n\treturn PageKsm(page) ? page_rmapping(page) : NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline struct stable_node *page_stable_node(struct page *page)\n{\n\treturn PageKsm(page) ? page_rmapping(page) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "newpage->mapping != oldpage->mapping",
            "newpage"
          ],
          "line": 2650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(newpage)",
            "newpage"
          ],
          "line": 2649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "newpage"
          ],
          "line": 2649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(oldpage)",
            "oldpage"
          ],
          "line": 2648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "oldpage"
          ],
          "line": 2648
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nvoid ksm_migrate_page(struct page *newpage, struct page *oldpage)\n{\n\tstruct stable_node *stable_node;\n\n\tVM_BUG_ON_PAGE(!PageLocked(oldpage), oldpage);\n\tVM_BUG_ON_PAGE(!PageLocked(newpage), newpage);\n\tVM_BUG_ON_PAGE(newpage->mapping != oldpage->mapping, newpage);\n\n\tstable_node = page_stable_node(newpage);\n\tif (stable_node) {\n\t\tVM_BUG_ON_PAGE(stable_node->kpfn != page_to_pfn(oldpage), oldpage);\n\t\tstable_node->kpfn = page_to_pfn(newpage);\n\t\t/*\n\t\t * newpage->mapping was set in advance; now we need smp_wmb()\n\t\t * to make sure that the new stable_node->kpfn is visible\n\t\t * to get_ksm_page() before it can see that oldpage->mapping\n\t\t * has gone stale (or that PageSwapCache has been cleared).\n\t\t */\n\t\tsmp_wmb();\n\t\tset_page_stable_node(oldpage, NULL);\n\t}\n}"
  },
  {
    "function_name": "rmap_walk_ksm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2579-2641",
    "snippet": "void rmap_walk_ksm(struct page *page, struct rmap_walk_control *rwc)\n{\n\tstruct stable_node *stable_node;\n\tstruct rmap_item *rmap_item;\n\tint search_new_forks = 0;\n\n\tVM_BUG_ON_PAGE(!PageKsm(page), page);\n\n\t/*\n\t * Rely on the page lock to protect against concurrent modifications\n\t * to that page's node of the stable tree.\n\t */\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tstable_node = page_stable_node(page);\n\tif (!stable_node)\n\t\treturn;\nagain:\n\thlist_for_each_entry(rmap_item, &stable_node->hlist, hlist) {\n\t\tstruct anon_vma *anon_vma = rmap_item->anon_vma;\n\t\tstruct anon_vma_chain *vmac;\n\t\tstruct vm_area_struct *vma;\n\n\t\tcond_resched();\n\t\tanon_vma_lock_read(anon_vma);\n\t\tanon_vma_interval_tree_foreach(vmac, &anon_vma->rb_root,\n\t\t\t\t\t       0, ULONG_MAX) {\n\t\t\tunsigned long addr;\n\n\t\t\tcond_resched();\n\t\t\tvma = vmac->vma;\n\n\t\t\t/* Ignore the stable/unstable/sqnr flags */\n\t\t\taddr = rmap_item->address & ~KSM_FLAG_MASK;\n\n\t\t\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Initially we examine only the vma which covers this\n\t\t\t * rmap_item; but later, if there is still work to do,\n\t\t\t * we examine covering vmas in other mms: in case they\n\t\t\t * were forked from the original since ksmd passed.\n\t\t\t */\n\t\t\tif ((rmap_item->mm == vma->vm_mm) == search_new_forks)\n\t\t\t\tcontinue;\n\n\t\t\tif (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))\n\t\t\t\tcontinue;\n\n\t\t\tif (!rwc->rmap_one(page, vma, addr, rwc->arg)) {\n\t\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (rwc->done && rwc->done(page)) {\n\t\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tanon_vma_unlock_read(anon_vma);\n\t}\n\tif (!search_new_forks++)\n\t\tgoto again;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define KSM_FLAG_MASK\t(SEQNR_MASK|UNSTABLE_FLAG|STABLE_FLAG)"
    ],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "anon_vma_unlock_read",
          "args": [
            "anon_vma"
          ],
          "line": 2637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_unlock_read",
          "args": [
            "anon_vma"
          ],
          "line": 2633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwc->done",
          "args": [
            "page"
          ],
          "line": 2632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_unlock_read",
          "args": [
            "anon_vma"
          ],
          "line": 2629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwc->rmap_one",
          "args": [
            "page",
            "vma",
            "addr",
            "rwc->arg"
          ],
          "line": 2628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwc->invalid_vma",
          "args": [
            "vma",
            "rwc->arg"
          ],
          "line": 2625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_interval_tree_foreach",
          "args": [
            "vmac",
            "&anon_vma->rb_root",
            "0",
            "ULONG_MAX"
          ],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_lock_read",
          "args": [
            "anon_vma"
          ],
          "line": 2603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "rmap_item",
            "&stable_node->hlist",
            "hlist"
          ],
          "line": 2597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_stable_node",
          "args": [
            "page"
          ],
          "line": 2593
        },
        "resolved": true,
        "details": {
          "function_name": "page_stable_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "845-848",
          "snippet": "static inline struct stable_node *page_stable_node(struct page *page)\n{\n\treturn PageKsm(page) ? page_rmapping(page) : NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline struct stable_node *page_stable_node(struct page *page)\n{\n\treturn PageKsm(page) ? page_rmapping(page) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 2591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 2591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageKsm(page)",
            "page"
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageKsm",
          "args": [
            "page"
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define KSM_FLAG_MASK\t(SEQNR_MASK|UNSTABLE_FLAG|STABLE_FLAG)\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nvoid rmap_walk_ksm(struct page *page, struct rmap_walk_control *rwc)\n{\n\tstruct stable_node *stable_node;\n\tstruct rmap_item *rmap_item;\n\tint search_new_forks = 0;\n\n\tVM_BUG_ON_PAGE(!PageKsm(page), page);\n\n\t/*\n\t * Rely on the page lock to protect against concurrent modifications\n\t * to that page's node of the stable tree.\n\t */\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tstable_node = page_stable_node(page);\n\tif (!stable_node)\n\t\treturn;\nagain:\n\thlist_for_each_entry(rmap_item, &stable_node->hlist, hlist) {\n\t\tstruct anon_vma *anon_vma = rmap_item->anon_vma;\n\t\tstruct anon_vma_chain *vmac;\n\t\tstruct vm_area_struct *vma;\n\n\t\tcond_resched();\n\t\tanon_vma_lock_read(anon_vma);\n\t\tanon_vma_interval_tree_foreach(vmac, &anon_vma->rb_root,\n\t\t\t\t\t       0, ULONG_MAX) {\n\t\t\tunsigned long addr;\n\n\t\t\tcond_resched();\n\t\t\tvma = vmac->vma;\n\n\t\t\t/* Ignore the stable/unstable/sqnr flags */\n\t\t\taddr = rmap_item->address & ~KSM_FLAG_MASK;\n\n\t\t\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Initially we examine only the vma which covers this\n\t\t\t * rmap_item; but later, if there is still work to do,\n\t\t\t * we examine covering vmas in other mms: in case they\n\t\t\t * were forked from the original since ksmd passed.\n\t\t\t */\n\t\t\tif ((rmap_item->mm == vma->vm_mm) == search_new_forks)\n\t\t\t\tcontinue;\n\n\t\t\tif (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))\n\t\t\t\tcontinue;\n\n\t\t\tif (!rwc->rmap_one(page, vma, addr, rwc->arg)) {\n\t\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (rwc->done && rwc->done(page)) {\n\t\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tanon_vma_unlock_read(anon_vma);\n\t}\n\tif (!search_new_forks++)\n\t\tgoto again;\n}"
  },
  {
    "function_name": "ksm_might_need_to_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2548-2577",
    "snippet": "struct page *ksm_might_need_to_copy(struct page *page,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tstruct anon_vma *anon_vma = page_anon_vma(page);\n\tstruct page *new_page;\n\n\tif (PageKsm(page)) {\n\t\tif (page_stable_node(page) &&\n\t\t    !(ksm_run & KSM_RUN_UNMERGE))\n\t\t\treturn page;\t/* no need to copy it */\n\t} else if (!anon_vma) {\n\t\treturn page;\t\t/* no need to copy it */\n\t} else if (anon_vma->root == vma->anon_vma->root &&\n\t\t page->index == linear_page_index(vma, address)) {\n\t\treturn page;\t\t/* still no need to copy it */\n\t}\n\tif (!PageUptodate(page))\n\t\treturn page;\t\t/* let do_swap_page report the error */\n\n\tnew_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);\n\tif (new_page) {\n\t\tcopy_user_highpage(new_page, page, address, vma);\n\n\t\tSetPageDirty(new_page);\n\t\t__SetPageUptodate(new_page);\n\t\t__SetPageLocked(new_page);\n\t}\n\n\treturn new_page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define KSM_RUN_UNMERGE\t2"
    ],
    "globals_used": [
      "static unsigned long ksm_run = KSM_RUN_STOP;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__SetPageLocked",
          "args": [
            "new_page"
          ],
          "line": 2573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SetPageUptodate",
          "args": [
            "new_page"
          ],
          "line": 2572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageDirty",
          "args": [
            "new_page"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_user_highpage",
          "args": [
            "new_page",
            "page",
            "address",
            "vma"
          ],
          "line": 2569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page_vma",
          "args": [
            "GFP_HIGHUSER_MOVABLE",
            "vma",
            "address"
          ],
          "line": 2567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linear_page_index",
          "args": [
            "vma",
            "address"
          ],
          "line": 2561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_stable_node",
          "args": [
            "page"
          ],
          "line": 2555
        },
        "resolved": true,
        "details": {
          "function_name": "page_stable_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "845-848",
          "snippet": "static inline struct stable_node *page_stable_node(struct page *page)\n{\n\treturn PageKsm(page) ? page_rmapping(page) : NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline struct stable_node *page_stable_node(struct page *page)\n{\n\treturn PageKsm(page) ? page_rmapping(page) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageKsm",
          "args": [
            "page"
          ],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_anon_vma",
          "args": [
            "page"
          ],
          "line": 2551
        },
        "resolved": true,
        "details": {
          "function_name": "page_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "489-498",
          "snippet": "struct anon_vma *page_anon_vma(struct page *page)\n{\n\tunsigned long mapping;\n\n\tpage = compound_head(page);\n\tmapping = (unsigned long)page->mapping;\n\tif ((mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\treturn NULL;\n\treturn __page_rmapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct anon_vma *page_anon_vma(struct page *page)\n{\n\tunsigned long mapping;\n\n\tpage = compound_head(page);\n\tmapping = (unsigned long)page->mapping;\n\tif ((mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\treturn NULL;\n\treturn __page_rmapping(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define KSM_RUN_UNMERGE\t2\n\nstatic unsigned long ksm_run = KSM_RUN_STOP;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstruct page *ksm_might_need_to_copy(struct page *page,\n\t\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tstruct anon_vma *anon_vma = page_anon_vma(page);\n\tstruct page *new_page;\n\n\tif (PageKsm(page)) {\n\t\tif (page_stable_node(page) &&\n\t\t    !(ksm_run & KSM_RUN_UNMERGE))\n\t\t\treturn page;\t/* no need to copy it */\n\t} else if (!anon_vma) {\n\t\treturn page;\t\t/* no need to copy it */\n\t} else if (anon_vma->root == vma->anon_vma->root &&\n\t\t page->index == linear_page_index(vma, address)) {\n\t\treturn page;\t\t/* still no need to copy it */\n\t}\n\tif (!PageUptodate(page))\n\t\treturn page;\t\t/* let do_swap_page report the error */\n\n\tnew_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);\n\tif (new_page) {\n\t\tcopy_user_highpage(new_page, page, address, vma);\n\n\t\tSetPageDirty(new_page);\n\t\t__SetPageUptodate(new_page);\n\t\t__SetPageLocked(new_page);\n\t}\n\n\treturn new_page;\n}"
  },
  {
    "function_name": "__ksm_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2510-2546",
    "snippet": "void __ksm_exit(struct mm_struct *mm)\n{\n\tstruct mm_slot *mm_slot;\n\tint easy_to_free = 0;\n\n\t/*\n\t * This process is exiting: if it's straightforward (as is the\n\t * case when ksmd was never running), free mm_slot immediately.\n\t * But if it's at the cursor or has rmap_items linked to it, use\n\t * mmap_sem to synchronize with any break_cows before pagetables\n\t * are freed, and leave the mm_slot on the list for ksmd to free.\n\t * Beware: ksm may already have noticed it exiting and freed the slot.\n\t */\n\n\tspin_lock(&ksm_mmlist_lock);\n\tmm_slot = get_mm_slot(mm);\n\tif (mm_slot && ksm_scan.mm_slot != mm_slot) {\n\t\tif (!mm_slot->rmap_list) {\n\t\t\thash_del(&mm_slot->link);\n\t\t\tlist_del(&mm_slot->mm_list);\n\t\t\teasy_to_free = 1;\n\t\t} else {\n\t\t\tlist_move(&mm_slot->mm_list,\n\t\t\t\t  &ksm_scan.mm_slot->mm_list);\n\t\t}\n\t}\n\tspin_unlock(&ksm_mmlist_lock);\n\n\tif (easy_to_free) {\n\t\tfree_mm_slot(mm_slot);\n\t\tclear_bit(MMF_VM_MERGEABLE, &mm->flags);\n\t\tmmdrop(mm);\n\t} else if (mm_slot) {\n\t\tdown_write(&mm->mmap_sem);\n\t\tup_write(&mm->mmap_sem);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};",
      "static DEFINE_SPINLOCK(ksm_mmlist_lock);",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 2544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 2543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmdrop",
          "args": [
            "mm"
          ],
          "line": 2541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "MMF_VM_MERGEABLE",
            "&mm->flags"
          ],
          "line": 2540
        },
        "resolved": true,
        "details": {
          "function_name": "clear_bit_unlock_is_negative_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1171-1176",
          "snippet": "static inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_mm_slot",
          "args": [
            "mm_slot"
          ],
          "line": 2539
        },
        "resolved": true,
        "details": {
          "function_name": "free_mm_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "419-422",
          "snippet": "static inline void free_mm_slot(struct mm_slot *mm_slot)\n{\n\tkmem_cache_free(mm_slot_cache, mm_slot);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *mm_slot_cache;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct kmem_cache *mm_slot_cache;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void free_mm_slot(struct mm_slot *mm_slot)\n{\n\tkmem_cache_free(mm_slot_cache, mm_slot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ksm_mmlist_lock"
          ],
          "line": 2536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&mm_slot->mm_list",
            "&ksm_scan.mm_slot->mm_list"
          ],
          "line": 2532
        },
        "resolved": true,
        "details": {
          "function_name": "qlist_move_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/quarantine.c",
          "lines": "72-88",
          "snippet": "static void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}",
          "includes": [
            "#include \"kasan.h\"",
            "#include \"../slab.h\"",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/printk.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hash.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kasan.h\"\n#include \"../slab.h\"\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/shrinker.h>\n#include <linux/printk.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/hash.h>\n#include <linux/gfp.h>\n\nstatic void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&mm_slot->mm_list"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_del",
          "args": [
            "&mm_slot->link"
          ],
          "line": 2528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mm_slot",
          "args": [
            "mm"
          ],
          "line": 2525
        },
        "resolved": true,
        "details": {
          "function_name": "get_mm_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "424-433",
          "snippet": "static struct mm_slot *get_mm_slot(struct mm_struct *mm)\n{\n\tstruct mm_slot *slot;\n\n\thash_for_each_possible(mm_slots_hash, slot, link, (unsigned long)mm)\n\t\tif (slot->mm == mm)\n\t\t\treturn slot;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct mm_slot *get_mm_slot(struct mm_struct *mm)\n{\n\tstruct mm_slot *slot;\n\n\thash_for_each_possible(mm_slots_hash, slot, link, (unsigned long)mm)\n\t\tif (slot->mm == mm)\n\t\t\treturn slot;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ksm_mmlist_lock"
          ],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};\nstatic DEFINE_SPINLOCK(ksm_mmlist_lock);\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nvoid __ksm_exit(struct mm_struct *mm)\n{\n\tstruct mm_slot *mm_slot;\n\tint easy_to_free = 0;\n\n\t/*\n\t * This process is exiting: if it's straightforward (as is the\n\t * case when ksmd was never running), free mm_slot immediately.\n\t * But if it's at the cursor or has rmap_items linked to it, use\n\t * mmap_sem to synchronize with any break_cows before pagetables\n\t * are freed, and leave the mm_slot on the list for ksmd to free.\n\t * Beware: ksm may already have noticed it exiting and freed the slot.\n\t */\n\n\tspin_lock(&ksm_mmlist_lock);\n\tmm_slot = get_mm_slot(mm);\n\tif (mm_slot && ksm_scan.mm_slot != mm_slot) {\n\t\tif (!mm_slot->rmap_list) {\n\t\t\thash_del(&mm_slot->link);\n\t\t\tlist_del(&mm_slot->mm_list);\n\t\t\teasy_to_free = 1;\n\t\t} else {\n\t\t\tlist_move(&mm_slot->mm_list,\n\t\t\t\t  &ksm_scan.mm_slot->mm_list);\n\t\t}\n\t}\n\tspin_unlock(&ksm_mmlist_lock);\n\n\tif (easy_to_free) {\n\t\tfree_mm_slot(mm_slot);\n\t\tclear_bit(MMF_VM_MERGEABLE, &mm->flags);\n\t\tmmdrop(mm);\n\t} else if (mm_slot) {\n\t\tdown_write(&mm->mmap_sem);\n\t\tup_write(&mm->mmap_sem);\n\t}\n}"
  },
  {
    "function_name": "__ksm_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2471-2508",
    "snippet": "int __ksm_enter(struct mm_struct *mm)\n{\n\tstruct mm_slot *mm_slot;\n\tint needs_wakeup;\n\n\tmm_slot = alloc_mm_slot();\n\tif (!mm_slot)\n\t\treturn -ENOMEM;\n\n\t/* Check ksm_run too?  Would need tighter locking */\n\tneeds_wakeup = list_empty(&ksm_mm_head.mm_list);\n\n\tspin_lock(&ksm_mmlist_lock);\n\tinsert_to_mm_slots_hash(mm, mm_slot);\n\t/*\n\t * When KSM_RUN_MERGE (or KSM_RUN_STOP),\n\t * insert just behind the scanning cursor, to let the area settle\n\t * down a little; when fork is followed by immediate exec, we don't\n\t * want ksmd to waste time setting up and tearing down an rmap_list.\n\t *\n\t * But when KSM_RUN_UNMERGE, it's important to insert ahead of its\n\t * scanning cursor, otherwise KSM pages in newly forked mms will be\n\t * missed: then we might as well insert at the end of the list.\n\t */\n\tif (ksm_run & KSM_RUN_UNMERGE)\n\t\tlist_add_tail(&mm_slot->mm_list, &ksm_mm_head.mm_list);\n\telse\n\t\tlist_add_tail(&mm_slot->mm_list, &ksm_scan.mm_slot->mm_list);\n\tspin_unlock(&ksm_mmlist_lock);\n\n\tset_bit(MMF_VM_MERGEABLE, &mm->flags);\n\tmmgrab(mm);\n\n\tif (needs_wakeup)\n\t\twake_up_interruptible(&ksm_thread_wait);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define KSM_RUN_UNMERGE\t2",
      "#define KSM_RUN_MERGE\t1",
      "#define KSM_RUN_STOP\t0"
    ],
    "globals_used": [
      "static struct mm_slot ksm_mm_head = {\n\t.mm_list = LIST_HEAD_INIT(ksm_mm_head.mm_list),\n};",
      "static struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};",
      "static unsigned long ksm_run = KSM_RUN_STOP;",
      "static DECLARE_WAIT_QUEUE_HEAD(ksm_thread_wait);",
      "static DEFINE_SPINLOCK(ksm_mmlist_lock);",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&ksm_thread_wait"
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmgrab",
          "args": [
            "mm"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "MMF_VM_MERGEABLE",
            "&mm->flags"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ksm_mmlist_lock"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&mm_slot->mm_list",
            "&ksm_scan.mm_slot->mm_list"
          ],
          "line": 2498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&mm_slot->mm_list",
            "&ksm_mm_head.mm_list"
          ],
          "line": 2496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_to_mm_slots_hash",
          "args": [
            "mm",
            "mm_slot"
          ],
          "line": 2484
        },
        "resolved": true,
        "details": {
          "function_name": "insert_to_mm_slots_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "435-440",
          "snippet": "static void insert_to_mm_slots_hash(struct mm_struct *mm,\n\t\t\t\t    struct mm_slot *mm_slot)\n{\n\tmm_slot->mm = mm;\n\thash_add(mm_slots_hash, &mm_slot->link, (unsigned long)mm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic void insert_to_mm_slots_hash(struct mm_struct *mm,\n\t\t\t\t    struct mm_slot *mm_slot)\n{\n\tmm_slot->mm = mm;\n\thash_add(mm_slots_hash, &mm_slot->link, (unsigned long)mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ksm_mmlist_lock"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ksm_mm_head.mm_list"
          ],
          "line": 2481
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_mm_slot",
          "args": [],
          "line": 2476
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_mm_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "412-417",
          "snippet": "static inline struct mm_slot *alloc_mm_slot(void)\n{\n\tif (!mm_slot_cache)\t/* initialization failed */\n\t\treturn NULL;\n\treturn kmem_cache_zalloc(mm_slot_cache, GFP_KERNEL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *mm_slot_cache;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct kmem_cache *mm_slot_cache;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline struct mm_slot *alloc_mm_slot(void)\n{\n\tif (!mm_slot_cache)\t/* initialization failed */\n\t\treturn NULL;\n\treturn kmem_cache_zalloc(mm_slot_cache, GFP_KERNEL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define KSM_RUN_UNMERGE\t2\n#define KSM_RUN_MERGE\t1\n#define KSM_RUN_STOP\t0\n\nstatic struct mm_slot ksm_mm_head = {\n\t.mm_list = LIST_HEAD_INIT(ksm_mm_head.mm_list),\n};\nstatic struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};\nstatic unsigned long ksm_run = KSM_RUN_STOP;\nstatic DECLARE_WAIT_QUEUE_HEAD(ksm_thread_wait);\nstatic DEFINE_SPINLOCK(ksm_mmlist_lock);\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nint __ksm_enter(struct mm_struct *mm)\n{\n\tstruct mm_slot *mm_slot;\n\tint needs_wakeup;\n\n\tmm_slot = alloc_mm_slot();\n\tif (!mm_slot)\n\t\treturn -ENOMEM;\n\n\t/* Check ksm_run too?  Would need tighter locking */\n\tneeds_wakeup = list_empty(&ksm_mm_head.mm_list);\n\n\tspin_lock(&ksm_mmlist_lock);\n\tinsert_to_mm_slots_hash(mm, mm_slot);\n\t/*\n\t * When KSM_RUN_MERGE (or KSM_RUN_STOP),\n\t * insert just behind the scanning cursor, to let the area settle\n\t * down a little; when fork is followed by immediate exec, we don't\n\t * want ksmd to waste time setting up and tearing down an rmap_list.\n\t *\n\t * But when KSM_RUN_UNMERGE, it's important to insert ahead of its\n\t * scanning cursor, otherwise KSM pages in newly forked mms will be\n\t * missed: then we might as well insert at the end of the list.\n\t */\n\tif (ksm_run & KSM_RUN_UNMERGE)\n\t\tlist_add_tail(&mm_slot->mm_list, &ksm_mm_head.mm_list);\n\telse\n\t\tlist_add_tail(&mm_slot->mm_list, &ksm_scan.mm_slot->mm_list);\n\tspin_unlock(&ksm_mmlist_lock);\n\n\tset_bit(MMF_VM_MERGEABLE, &mm->flags);\n\tmmgrab(mm);\n\n\tif (needs_wakeup)\n\t\twake_up_interruptible(&ksm_thread_wait);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ksm_madvise",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2417-2469",
    "snippet": "int ksm_madvise(struct vm_area_struct *vma, unsigned long start,\n\t\tunsigned long end, int advice, unsigned long *vm_flags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint err;\n\n\tswitch (advice) {\n\tcase MADV_MERGEABLE:\n\t\t/*\n\t\t * Be somewhat over-protective for now!\n\t\t */\n\t\tif (*vm_flags & (VM_MERGEABLE | VM_SHARED  | VM_MAYSHARE   |\n\t\t\t\t VM_PFNMAP    | VM_IO      | VM_DONTEXPAND |\n\t\t\t\t VM_HUGETLB | VM_MIXEDMAP))\n\t\t\treturn 0;\t\t/* just ignore the advice */\n\n\t\tif (vma_is_dax(vma))\n\t\t\treturn 0;\n\n#ifdef VM_SAO\n\t\tif (*vm_flags & VM_SAO)\n\t\t\treturn 0;\n#endif\n#ifdef VM_SPARC_ADI\n\t\tif (*vm_flags & VM_SPARC_ADI)\n\t\t\treturn 0;\n#endif\n\n\t\tif (!test_bit(MMF_VM_MERGEABLE, &mm->flags)) {\n\t\t\terr = __ksm_enter(mm);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t*vm_flags |= VM_MERGEABLE;\n\t\tbreak;\n\n\tcase MADV_UNMERGEABLE:\n\t\tif (!(*vm_flags & VM_MERGEABLE))\n\t\t\treturn 0;\t\t/* just ignore the advice */\n\n\t\tif (vma->anon_vma) {\n\t\t\terr = unmerge_ksm_pages(vma, start, end);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t*vm_flags &= ~VM_MERGEABLE;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unmerge_ksm_pages",
          "args": [
            "vma",
            "start",
            "end"
          ],
          "line": 2459
        },
        "resolved": true,
        "details": {
          "function_name": "unmerge_ksm_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "828-843",
          "snippet": "static int unmerge_ksm_pages(struct vm_area_struct *vma,\n\t\t\t     unsigned long start, unsigned long end)\n{\n\tunsigned long addr;\n\tint err = 0;\n\n\tfor (addr = start; addr < end && !err; addr += PAGE_SIZE) {\n\t\tif (ksm_test_exit(vma->vm_mm))\n\t\t\tbreak;\n\t\tif (signal_pending(current))\n\t\t\terr = -ERESTARTSYS;\n\t\telse\n\t\t\terr = break_ksm(vma, addr);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int unmerge_ksm_pages(struct vm_area_struct *vma,\n\t\t\t     unsigned long start, unsigned long end)\n{\n\tunsigned long addr;\n\tint err = 0;\n\n\tfor (addr = start; addr < end && !err; addr += PAGE_SIZE) {\n\t\tif (ksm_test_exit(vma->vm_mm))\n\t\t\tbreak;\n\t\tif (signal_pending(current))\n\t\t\terr = -ERESTARTSYS;\n\t\telse\n\t\t\terr = break_ksm(vma, addr);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ksm_enter",
          "args": [
            "mm"
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "__ksm_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "2471-2508",
          "snippet": "int __ksm_enter(struct mm_struct *mm)\n{\n\tstruct mm_slot *mm_slot;\n\tint needs_wakeup;\n\n\tmm_slot = alloc_mm_slot();\n\tif (!mm_slot)\n\t\treturn -ENOMEM;\n\n\t/* Check ksm_run too?  Would need tighter locking */\n\tneeds_wakeup = list_empty(&ksm_mm_head.mm_list);\n\n\tspin_lock(&ksm_mmlist_lock);\n\tinsert_to_mm_slots_hash(mm, mm_slot);\n\t/*\n\t * When KSM_RUN_MERGE (or KSM_RUN_STOP),\n\t * insert just behind the scanning cursor, to let the area settle\n\t * down a little; when fork is followed by immediate exec, we don't\n\t * want ksmd to waste time setting up and tearing down an rmap_list.\n\t *\n\t * But when KSM_RUN_UNMERGE, it's important to insert ahead of its\n\t * scanning cursor, otherwise KSM pages in newly forked mms will be\n\t * missed: then we might as well insert at the end of the list.\n\t */\n\tif (ksm_run & KSM_RUN_UNMERGE)\n\t\tlist_add_tail(&mm_slot->mm_list, &ksm_mm_head.mm_list);\n\telse\n\t\tlist_add_tail(&mm_slot->mm_list, &ksm_scan.mm_slot->mm_list);\n\tspin_unlock(&ksm_mmlist_lock);\n\n\tset_bit(MMF_VM_MERGEABLE, &mm->flags);\n\tmmgrab(mm);\n\n\tif (needs_wakeup)\n\t\twake_up_interruptible(&ksm_thread_wait);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define KSM_RUN_UNMERGE\t2",
            "#define KSM_RUN_MERGE\t1",
            "#define KSM_RUN_STOP\t0"
          ],
          "globals_used": [
            "static struct mm_slot ksm_mm_head = {\n\t.mm_list = LIST_HEAD_INIT(ksm_mm_head.mm_list),\n};",
            "static struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};",
            "static unsigned long ksm_run = KSM_RUN_STOP;",
            "static DECLARE_WAIT_QUEUE_HEAD(ksm_thread_wait);",
            "static DEFINE_SPINLOCK(ksm_mmlist_lock);",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define KSM_RUN_UNMERGE\t2\n#define KSM_RUN_MERGE\t1\n#define KSM_RUN_STOP\t0\n\nstatic struct mm_slot ksm_mm_head = {\n\t.mm_list = LIST_HEAD_INIT(ksm_mm_head.mm_list),\n};\nstatic struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};\nstatic unsigned long ksm_run = KSM_RUN_STOP;\nstatic DECLARE_WAIT_QUEUE_HEAD(ksm_thread_wait);\nstatic DEFINE_SPINLOCK(ksm_mmlist_lock);\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nint __ksm_enter(struct mm_struct *mm)\n{\n\tstruct mm_slot *mm_slot;\n\tint needs_wakeup;\n\n\tmm_slot = alloc_mm_slot();\n\tif (!mm_slot)\n\t\treturn -ENOMEM;\n\n\t/* Check ksm_run too?  Would need tighter locking */\n\tneeds_wakeup = list_empty(&ksm_mm_head.mm_list);\n\n\tspin_lock(&ksm_mmlist_lock);\n\tinsert_to_mm_slots_hash(mm, mm_slot);\n\t/*\n\t * When KSM_RUN_MERGE (or KSM_RUN_STOP),\n\t * insert just behind the scanning cursor, to let the area settle\n\t * down a little; when fork is followed by immediate exec, we don't\n\t * want ksmd to waste time setting up and tearing down an rmap_list.\n\t *\n\t * But when KSM_RUN_UNMERGE, it's important to insert ahead of its\n\t * scanning cursor, otherwise KSM pages in newly forked mms will be\n\t * missed: then we might as well insert at the end of the list.\n\t */\n\tif (ksm_run & KSM_RUN_UNMERGE)\n\t\tlist_add_tail(&mm_slot->mm_list, &ksm_mm_head.mm_list);\n\telse\n\t\tlist_add_tail(&mm_slot->mm_list, &ksm_scan.mm_slot->mm_list);\n\tspin_unlock(&ksm_mmlist_lock);\n\n\tset_bit(MMF_VM_MERGEABLE, &mm->flags);\n\tmmgrab(mm);\n\n\tif (needs_wakeup)\n\t\twake_up_interruptible(&ksm_thread_wait);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "MMF_VM_MERGEABLE",
            "&mm->flags"
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_is_dax",
          "args": [
            "vma"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nint ksm_madvise(struct vm_area_struct *vma, unsigned long start,\n\t\tunsigned long end, int advice, unsigned long *vm_flags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint err;\n\n\tswitch (advice) {\n\tcase MADV_MERGEABLE:\n\t\t/*\n\t\t * Be somewhat over-protective for now!\n\t\t */\n\t\tif (*vm_flags & (VM_MERGEABLE | VM_SHARED  | VM_MAYSHARE   |\n\t\t\t\t VM_PFNMAP    | VM_IO      | VM_DONTEXPAND |\n\t\t\t\t VM_HUGETLB | VM_MIXEDMAP))\n\t\t\treturn 0;\t\t/* just ignore the advice */\n\n\t\tif (vma_is_dax(vma))\n\t\t\treturn 0;\n\n#ifdef VM_SAO\n\t\tif (*vm_flags & VM_SAO)\n\t\t\treturn 0;\n#endif\n#ifdef VM_SPARC_ADI\n\t\tif (*vm_flags & VM_SPARC_ADI)\n\t\t\treturn 0;\n#endif\n\n\t\tif (!test_bit(MMF_VM_MERGEABLE, &mm->flags)) {\n\t\t\terr = __ksm_enter(mm);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t*vm_flags |= VM_MERGEABLE;\n\t\tbreak;\n\n\tcase MADV_UNMERGEABLE:\n\t\tif (!(*vm_flags & VM_MERGEABLE))\n\t\t\treturn 0;\t\t/* just ignore the advice */\n\n\t\tif (vma->anon_vma) {\n\t\t\terr = unmerge_ksm_pages(vma, start, end);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t*vm_flags &= ~VM_MERGEABLE;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ksm_scan_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2392-2415",
    "snippet": "static int ksm_scan_thread(void *nothing)\n{\n\tset_freezable();\n\tset_user_nice(current, 5);\n\n\twhile (!kthread_should_stop()) {\n\t\tmutex_lock(&ksm_thread_mutex);\n\t\twait_while_offlining();\n\t\tif (ksmd_should_run())\n\t\t\tksm_do_scan(ksm_thread_pages_to_scan);\n\t\tmutex_unlock(&ksm_thread_mutex);\n\n\t\ttry_to_freeze();\n\n\t\tif (ksmd_should_run()) {\n\t\t\tschedule_timeout_interruptible(\n\t\t\t\tmsecs_to_jiffies(ksm_thread_sleep_millisecs));\n\t\t} else {\n\t\t\twait_event_freezable(ksm_thread_wait,\n\t\t\t\tksmd_should_run() || kthread_should_stop());\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int ksm_thread_pages_to_scan = 100;",
      "static unsigned int ksm_thread_sleep_millisecs = 20;",
      "static void wait_while_offlining(void);",
      "static DECLARE_WAIT_QUEUE_HEAD(ksm_thread_wait);",
      "static DEFINE_MUTEX(ksm_thread_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event_freezable",
          "args": [
            "ksm_thread_wait",
            "ksmd_should_run() || kthread_should_stop()"
          ],
          "line": 2410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ksmd_should_run",
          "args": [],
          "line": 2411
        },
        "resolved": true,
        "details": {
          "function_name": "ksmd_should_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "2387-2390",
          "snippet": "static int ksmd_should_run(void)\n{\n\treturn (ksm_run & KSM_RUN_MERGE) && !list_empty(&ksm_mm_head.mm_list);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define KSM_RUN_MERGE\t1"
          ],
          "globals_used": [
            "static struct mm_slot ksm_mm_head = {\n\t.mm_list = LIST_HEAD_INIT(ksm_mm_head.mm_list),\n};",
            "static unsigned long ksm_run = KSM_RUN_STOP;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define KSM_RUN_MERGE\t1\n\nstatic struct mm_slot ksm_mm_head = {\n\t.mm_list = LIST_HEAD_INIT(ksm_mm_head.mm_list),\n};\nstatic unsigned long ksm_run = KSM_RUN_STOP;\n\nstatic int ksmd_should_run(void)\n{\n\treturn (ksm_run & KSM_RUN_MERGE) && !list_empty(&ksm_mm_head.mm_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "msecs_to_jiffies(ksm_thread_sleep_millisecs)"
          ],
          "line": 2407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "ksm_thread_sleep_millisecs"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_freeze",
          "args": [],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ksm_thread_mutex"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ksm_do_scan",
          "args": [
            "ksm_thread_pages_to_scan"
          ],
          "line": 2401
        },
        "resolved": true,
        "details": {
          "function_name": "ksm_do_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "2372-2385",
          "snippet": "static void ksm_do_scan(unsigned int scan_npages)\n{\n\tstruct rmap_item *rmap_item;\n\tstruct page *uninitialized_var(page);\n\n\twhile (scan_npages-- && likely(!freezing(current))) {\n\t\tcond_resched();\n\t\trmap_item = scan_get_next_rmap_item(&page);\n\t\tif (!rmap_item)\n\t\t\treturn;\n\t\tcmp_and_merge_page(page, rmap_item);\n\t\tput_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic void ksm_do_scan(unsigned int scan_npages)\n{\n\tstruct rmap_item *rmap_item;\n\tstruct page *uninitialized_var(page);\n\n\twhile (scan_npages-- && likely(!freezing(current))) {\n\t\tcond_resched();\n\t\trmap_item = scan_get_next_rmap_item(&page);\n\t\tif (!rmap_item)\n\t\t\treturn;\n\t\tcmp_and_merge_page(page, rmap_item);\n\t\tput_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_while_offlining",
          "args": [],
          "line": 2399
        },
        "resolved": true,
        "details": {
          "function_name": "wait_while_offlining",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "2793-2795",
          "snippet": "static void wait_while_offlining(void)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wait_while_offlining(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic void wait_while_offlining(void);\n\nstatic void wait_while_offlining(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ksm_thread_mutex"
          ],
          "line": 2398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "5"
          ],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_freezable",
          "args": [],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic unsigned int ksm_thread_pages_to_scan = 100;\nstatic unsigned int ksm_thread_sleep_millisecs = 20;\nstatic void wait_while_offlining(void);\nstatic DECLARE_WAIT_QUEUE_HEAD(ksm_thread_wait);\nstatic DEFINE_MUTEX(ksm_thread_mutex);\n\nstatic int ksm_scan_thread(void *nothing)\n{\n\tset_freezable();\n\tset_user_nice(current, 5);\n\n\twhile (!kthread_should_stop()) {\n\t\tmutex_lock(&ksm_thread_mutex);\n\t\twait_while_offlining();\n\t\tif (ksmd_should_run())\n\t\t\tksm_do_scan(ksm_thread_pages_to_scan);\n\t\tmutex_unlock(&ksm_thread_mutex);\n\n\t\ttry_to_freeze();\n\n\t\tif (ksmd_should_run()) {\n\t\t\tschedule_timeout_interruptible(\n\t\t\t\tmsecs_to_jiffies(ksm_thread_sleep_millisecs));\n\t\t} else {\n\t\t\twait_event_freezable(ksm_thread_wait,\n\t\t\t\tksmd_should_run() || kthread_should_stop());\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ksmd_should_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2387-2390",
    "snippet": "static int ksmd_should_run(void)\n{\n\treturn (ksm_run & KSM_RUN_MERGE) && !list_empty(&ksm_mm_head.mm_list);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define KSM_RUN_MERGE\t1"
    ],
    "globals_used": [
      "static struct mm_slot ksm_mm_head = {\n\t.mm_list = LIST_HEAD_INIT(ksm_mm_head.mm_list),\n};",
      "static unsigned long ksm_run = KSM_RUN_STOP;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ksm_mm_head.mm_list"
          ],
          "line": 2389
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define KSM_RUN_MERGE\t1\n\nstatic struct mm_slot ksm_mm_head = {\n\t.mm_list = LIST_HEAD_INIT(ksm_mm_head.mm_list),\n};\nstatic unsigned long ksm_run = KSM_RUN_STOP;\n\nstatic int ksmd_should_run(void)\n{\n\treturn (ksm_run & KSM_RUN_MERGE) && !list_empty(&ksm_mm_head.mm_list);\n}"
  },
  {
    "function_name": "ksm_do_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2372-2385",
    "snippet": "static void ksm_do_scan(unsigned int scan_npages)\n{\n\tstruct rmap_item *rmap_item;\n\tstruct page *uninitialized_var(page);\n\n\twhile (scan_npages-- && likely(!freezing(current))) {\n\t\tcond_resched();\n\t\trmap_item = scan_get_next_rmap_item(&page);\n\t\tif (!rmap_item)\n\t\t\treturn;\n\t\tcmp_and_merge_page(page, rmap_item);\n\t\tput_page(page);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 2383
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmp_and_merge_page",
          "args": [
            "page",
            "rmap_item"
          ],
          "line": 2382
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_and_merge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "2032-2180",
          "snippet": "static void cmp_and_merge_page(struct page *page, struct rmap_item *rmap_item)\n{\n\tstruct mm_struct *mm = rmap_item->mm;\n\tstruct rmap_item *tree_rmap_item;\n\tstruct page *tree_page = NULL;\n\tstruct stable_node *stable_node;\n\tstruct page *kpage;\n\tunsigned int checksum;\n\tint err;\n\tbool max_page_sharing_bypass = false;\n\n\tstable_node = page_stable_node(page);\n\tif (stable_node) {\n\t\tif (stable_node->head != &migrate_nodes &&\n\t\t    get_kpfn_nid(READ_ONCE(stable_node->kpfn)) !=\n\t\t    NUMA(stable_node->nid)) {\n\t\t\tstable_node_dup_del(stable_node);\n\t\t\tstable_node->head = &migrate_nodes;\n\t\t\tlist_add(&stable_node->list, stable_node->head);\n\t\t}\n\t\tif (stable_node->head != &migrate_nodes &&\n\t\t    rmap_item->head == stable_node)\n\t\t\treturn;\n\t\t/*\n\t\t * If it's a KSM fork, allow it to go over the sharing limit\n\t\t * without warnings.\n\t\t */\n\t\tif (!is_page_sharing_candidate(stable_node))\n\t\t\tmax_page_sharing_bypass = true;\n\t}\n\n\t/* We first start with searching the page inside the stable tree */\n\tkpage = stable_tree_search(page);\n\tif (kpage == page && rmap_item->head == stable_node) {\n\t\tput_page(kpage);\n\t\treturn;\n\t}\n\n\tremove_rmap_item_from_tree(rmap_item);\n\n\tif (kpage) {\n\t\terr = try_to_merge_with_ksm_page(rmap_item, page, kpage);\n\t\tif (!err) {\n\t\t\t/*\n\t\t\t * The page was successfully merged:\n\t\t\t * add its rmap_item to the stable tree.\n\t\t\t */\n\t\t\tlock_page(kpage);\n\t\t\tstable_tree_append(rmap_item, page_stable_node(kpage),\n\t\t\t\t\t   max_page_sharing_bypass);\n\t\t\tunlock_page(kpage);\n\t\t}\n\t\tput_page(kpage);\n\t\treturn;\n\t}\n\n\t/*\n\t * If the hash value of the page has changed from the last time\n\t * we calculated it, this page is changing frequently: therefore we\n\t * don't want to insert it in the unstable tree, and we don't want\n\t * to waste our time searching for something identical to it there.\n\t */\n\tchecksum = calc_checksum(page);\n\tif (rmap_item->oldchecksum != checksum) {\n\t\trmap_item->oldchecksum = checksum;\n\t\treturn;\n\t}\n\n\t/*\n\t * Same checksum as an empty page. We attempt to merge it with the\n\t * appropriate zero page if the user enabled this via sysfs.\n\t */\n\tif (ksm_use_zero_pages && (checksum == zero_checksum)) {\n\t\tstruct vm_area_struct *vma;\n\n\t\tdown_read(&mm->mmap_sem);\n\t\tvma = find_mergeable_vma(mm, rmap_item->address);\n\t\terr = try_to_merge_one_page(vma, page,\n\t\t\t\t\t    ZERO_PAGE(rmap_item->address));\n\t\tup_read(&mm->mmap_sem);\n\t\t/*\n\t\t * In case of failure, the page was not really empty, so we\n\t\t * need to continue. Otherwise we're done.\n\t\t */\n\t\tif (!err)\n\t\t\treturn;\n\t}\n\ttree_rmap_item =\n\t\tunstable_tree_search_insert(rmap_item, page, &tree_page);\n\tif (tree_rmap_item) {\n\t\tbool split;\n\n\t\tkpage = try_to_merge_two_pages(rmap_item, page,\n\t\t\t\t\t\ttree_rmap_item, tree_page);\n\t\t/*\n\t\t * If both pages we tried to merge belong to the same compound\n\t\t * page, then we actually ended up increasing the reference\n\t\t * count of the same compound page twice, and split_huge_page\n\t\t * failed.\n\t\t * Here we set a flag if that happened, and we use it later to\n\t\t * try split_huge_page again. Since we call put_page right\n\t\t * afterwards, the reference count will be correct and\n\t\t * split_huge_page should succeed.\n\t\t */\n\t\tsplit = PageTransCompound(page)\n\t\t\t&& compound_head(page) == compound_head(tree_page);\n\t\tput_page(tree_page);\n\t\tif (kpage) {\n\t\t\t/*\n\t\t\t * The pages were successfully merged: insert new\n\t\t\t * node in the stable tree and add both rmap_items.\n\t\t\t */\n\t\t\tlock_page(kpage);\n\t\t\tstable_node = stable_tree_insert(kpage);\n\t\t\tif (stable_node) {\n\t\t\t\tstable_tree_append(tree_rmap_item, stable_node,\n\t\t\t\t\t\t   false);\n\t\t\t\tstable_tree_append(rmap_item, stable_node,\n\t\t\t\t\t\t   false);\n\t\t\t}\n\t\t\tunlock_page(kpage);\n\n\t\t\t/*\n\t\t\t * If we fail to insert the page into the stable tree,\n\t\t\t * we will have 2 virtual addresses that are pointing\n\t\t\t * to a ksm page left outside the stable tree,\n\t\t\t * in which case we need to break_cow on both.\n\t\t\t */\n\t\t\tif (!stable_node) {\n\t\t\t\tbreak_cow(tree_rmap_item);\n\t\t\t\tbreak_cow(rmap_item);\n\t\t\t}\n\t\t} else if (split) {\n\t\t\t/*\n\t\t\t * We are here if we tried to merge two pages and\n\t\t\t * failed because they both belonged to the same\n\t\t\t * compound page. We will split the page now, but no\n\t\t\t * merging will take place.\n\t\t\t * We do not want to add the cost of a full lock; if\n\t\t\t * the page is locked, it is better to skip it and\n\t\t\t * perhaps try again later.\n\t\t\t */\n\t\t\tif (!trylock_page(page))\n\t\t\t\treturn;\n\t\t\tsplit_huge_page(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(migrate_nodes);",
            "static unsigned int zero_checksum",
            "static bool ksm_use_zero_pages",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic LIST_HEAD(migrate_nodes);\nstatic unsigned int zero_checksum;\nstatic bool ksm_use_zero_pages;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic void cmp_and_merge_page(struct page *page, struct rmap_item *rmap_item)\n{\n\tstruct mm_struct *mm = rmap_item->mm;\n\tstruct rmap_item *tree_rmap_item;\n\tstruct page *tree_page = NULL;\n\tstruct stable_node *stable_node;\n\tstruct page *kpage;\n\tunsigned int checksum;\n\tint err;\n\tbool max_page_sharing_bypass = false;\n\n\tstable_node = page_stable_node(page);\n\tif (stable_node) {\n\t\tif (stable_node->head != &migrate_nodes &&\n\t\t    get_kpfn_nid(READ_ONCE(stable_node->kpfn)) !=\n\t\t    NUMA(stable_node->nid)) {\n\t\t\tstable_node_dup_del(stable_node);\n\t\t\tstable_node->head = &migrate_nodes;\n\t\t\tlist_add(&stable_node->list, stable_node->head);\n\t\t}\n\t\tif (stable_node->head != &migrate_nodes &&\n\t\t    rmap_item->head == stable_node)\n\t\t\treturn;\n\t\t/*\n\t\t * If it's a KSM fork, allow it to go over the sharing limit\n\t\t * without warnings.\n\t\t */\n\t\tif (!is_page_sharing_candidate(stable_node))\n\t\t\tmax_page_sharing_bypass = true;\n\t}\n\n\t/* We first start with searching the page inside the stable tree */\n\tkpage = stable_tree_search(page);\n\tif (kpage == page && rmap_item->head == stable_node) {\n\t\tput_page(kpage);\n\t\treturn;\n\t}\n\n\tremove_rmap_item_from_tree(rmap_item);\n\n\tif (kpage) {\n\t\terr = try_to_merge_with_ksm_page(rmap_item, page, kpage);\n\t\tif (!err) {\n\t\t\t/*\n\t\t\t * The page was successfully merged:\n\t\t\t * add its rmap_item to the stable tree.\n\t\t\t */\n\t\t\tlock_page(kpage);\n\t\t\tstable_tree_append(rmap_item, page_stable_node(kpage),\n\t\t\t\t\t   max_page_sharing_bypass);\n\t\t\tunlock_page(kpage);\n\t\t}\n\t\tput_page(kpage);\n\t\treturn;\n\t}\n\n\t/*\n\t * If the hash value of the page has changed from the last time\n\t * we calculated it, this page is changing frequently: therefore we\n\t * don't want to insert it in the unstable tree, and we don't want\n\t * to waste our time searching for something identical to it there.\n\t */\n\tchecksum = calc_checksum(page);\n\tif (rmap_item->oldchecksum != checksum) {\n\t\trmap_item->oldchecksum = checksum;\n\t\treturn;\n\t}\n\n\t/*\n\t * Same checksum as an empty page. We attempt to merge it with the\n\t * appropriate zero page if the user enabled this via sysfs.\n\t */\n\tif (ksm_use_zero_pages && (checksum == zero_checksum)) {\n\t\tstruct vm_area_struct *vma;\n\n\t\tdown_read(&mm->mmap_sem);\n\t\tvma = find_mergeable_vma(mm, rmap_item->address);\n\t\terr = try_to_merge_one_page(vma, page,\n\t\t\t\t\t    ZERO_PAGE(rmap_item->address));\n\t\tup_read(&mm->mmap_sem);\n\t\t/*\n\t\t * In case of failure, the page was not really empty, so we\n\t\t * need to continue. Otherwise we're done.\n\t\t */\n\t\tif (!err)\n\t\t\treturn;\n\t}\n\ttree_rmap_item =\n\t\tunstable_tree_search_insert(rmap_item, page, &tree_page);\n\tif (tree_rmap_item) {\n\t\tbool split;\n\n\t\tkpage = try_to_merge_two_pages(rmap_item, page,\n\t\t\t\t\t\ttree_rmap_item, tree_page);\n\t\t/*\n\t\t * If both pages we tried to merge belong to the same compound\n\t\t * page, then we actually ended up increasing the reference\n\t\t * count of the same compound page twice, and split_huge_page\n\t\t * failed.\n\t\t * Here we set a flag if that happened, and we use it later to\n\t\t * try split_huge_page again. Since we call put_page right\n\t\t * afterwards, the reference count will be correct and\n\t\t * split_huge_page should succeed.\n\t\t */\n\t\tsplit = PageTransCompound(page)\n\t\t\t&& compound_head(page) == compound_head(tree_page);\n\t\tput_page(tree_page);\n\t\tif (kpage) {\n\t\t\t/*\n\t\t\t * The pages were successfully merged: insert new\n\t\t\t * node in the stable tree and add both rmap_items.\n\t\t\t */\n\t\t\tlock_page(kpage);\n\t\t\tstable_node = stable_tree_insert(kpage);\n\t\t\tif (stable_node) {\n\t\t\t\tstable_tree_append(tree_rmap_item, stable_node,\n\t\t\t\t\t\t   false);\n\t\t\t\tstable_tree_append(rmap_item, stable_node,\n\t\t\t\t\t\t   false);\n\t\t\t}\n\t\t\tunlock_page(kpage);\n\n\t\t\t/*\n\t\t\t * If we fail to insert the page into the stable tree,\n\t\t\t * we will have 2 virtual addresses that are pointing\n\t\t\t * to a ksm page left outside the stable tree,\n\t\t\t * in which case we need to break_cow on both.\n\t\t\t */\n\t\t\tif (!stable_node) {\n\t\t\t\tbreak_cow(tree_rmap_item);\n\t\t\t\tbreak_cow(rmap_item);\n\t\t\t}\n\t\t} else if (split) {\n\t\t\t/*\n\t\t\t * We are here if we tried to merge two pages and\n\t\t\t * failed because they both belonged to the same\n\t\t\t * compound page. We will split the page now, but no\n\t\t\t * merging will take place.\n\t\t\t * We do not want to add the cost of a full lock; if\n\t\t\t * the page is locked, it is better to skip it and\n\t\t\t * perhaps try again later.\n\t\t\t */\n\t\t\tif (!trylock_page(page))\n\t\t\t\treturn;\n\t\t\tsplit_huge_page(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "scan_get_next_rmap_item",
          "args": [
            "&page"
          ],
          "line": 2379
        },
        "resolved": true,
        "details": {
          "function_name": "scan_get_next_rmap_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "2210-2366",
          "snippet": "static struct rmap_item *scan_get_next_rmap_item(struct page **page)\n{\n\tstruct mm_struct *mm;\n\tstruct mm_slot *slot;\n\tstruct vm_area_struct *vma;\n\tstruct rmap_item *rmap_item;\n\tint nid;\n\n\tif (list_empty(&ksm_mm_head.mm_list))\n\t\treturn NULL;\n\n\tslot = ksm_scan.mm_slot;\n\tif (slot == &ksm_mm_head) {\n\t\t/*\n\t\t * A number of pages can hang around indefinitely on per-cpu\n\t\t * pagevecs, raised page count preventing write_protect_page\n\t\t * from merging them.  Though it doesn't really matter much,\n\t\t * it is puzzling to see some stuck in pages_volatile until\n\t\t * other activity jostles them out, and they also prevented\n\t\t * LTP's KSM test from succeeding deterministically; so drain\n\t\t * them here (here rather than on entry to ksm_do_scan(),\n\t\t * so we don't IPI too often when pages_to_scan is set low).\n\t\t */\n\t\tlru_add_drain_all();\n\n\t\t/*\n\t\t * Whereas stale stable_nodes on the stable_tree itself\n\t\t * get pruned in the regular course of stable_tree_search(),\n\t\t * those moved out to the migrate_nodes list can accumulate:\n\t\t * so prune them once before each full scan.\n\t\t */\n\t\tif (!ksm_merge_across_nodes) {\n\t\t\tstruct stable_node *stable_node, *next;\n\t\t\tstruct page *page;\n\n\t\t\tlist_for_each_entry_safe(stable_node, next,\n\t\t\t\t\t\t &migrate_nodes, list) {\n\t\t\t\tpage = get_ksm_page(stable_node, false);\n\t\t\t\tif (page)\n\t\t\t\t\tput_page(page);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t}\n\n\t\tfor (nid = 0; nid < ksm_nr_node_ids; nid++)\n\t\t\troot_unstable_tree[nid] = RB_ROOT;\n\n\t\tspin_lock(&ksm_mmlist_lock);\n\t\tslot = list_entry(slot->mm_list.next, struct mm_slot, mm_list);\n\t\tksm_scan.mm_slot = slot;\n\t\tspin_unlock(&ksm_mmlist_lock);\n\t\t/*\n\t\t * Although we tested list_empty() above, a racing __ksm_exit\n\t\t * of the last mm on the list may have removed it since then.\n\t\t */\n\t\tif (slot == &ksm_mm_head)\n\t\t\treturn NULL;\nnext_mm:\n\t\tksm_scan.address = 0;\n\t\tksm_scan.rmap_list = &slot->rmap_list;\n\t}\n\n\tmm = slot->mm;\n\tdown_read(&mm->mmap_sem);\n\tif (ksm_test_exit(mm))\n\t\tvma = NULL;\n\telse\n\t\tvma = find_vma(mm, ksm_scan.address);\n\n\tfor (; vma; vma = vma->vm_next) {\n\t\tif (!(vma->vm_flags & VM_MERGEABLE))\n\t\t\tcontinue;\n\t\tif (ksm_scan.address < vma->vm_start)\n\t\t\tksm_scan.address = vma->vm_start;\n\t\tif (!vma->anon_vma)\n\t\t\tksm_scan.address = vma->vm_end;\n\n\t\twhile (ksm_scan.address < vma->vm_end) {\n\t\t\tif (ksm_test_exit(mm))\n\t\t\t\tbreak;\n\t\t\t*page = follow_page(vma, ksm_scan.address, FOLL_GET);\n\t\t\tif (IS_ERR_OR_NULL(*page)) {\n\t\t\t\tksm_scan.address += PAGE_SIZE;\n\t\t\t\tcond_resched();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (PageAnon(*page)) {\n\t\t\t\tflush_anon_page(vma, *page, ksm_scan.address);\n\t\t\t\tflush_dcache_page(*page);\n\t\t\t\trmap_item = get_next_rmap_item(slot,\n\t\t\t\t\tksm_scan.rmap_list, ksm_scan.address);\n\t\t\t\tif (rmap_item) {\n\t\t\t\t\tksm_scan.rmap_list =\n\t\t\t\t\t\t\t&rmap_item->rmap_list;\n\t\t\t\t\tksm_scan.address += PAGE_SIZE;\n\t\t\t\t} else\n\t\t\t\t\tput_page(*page);\n\t\t\t\tup_read(&mm->mmap_sem);\n\t\t\t\treturn rmap_item;\n\t\t\t}\n\t\t\tput_page(*page);\n\t\t\tksm_scan.address += PAGE_SIZE;\n\t\t\tcond_resched();\n\t\t}\n\t}\n\n\tif (ksm_test_exit(mm)) {\n\t\tksm_scan.address = 0;\n\t\tksm_scan.rmap_list = &slot->rmap_list;\n\t}\n\t/*\n\t * Nuke all the rmap_items that are above this current rmap:\n\t * because there were no VM_MERGEABLE vmas with such addresses.\n\t */\n\tremove_trailing_rmap_items(slot, ksm_scan.rmap_list);\n\n\tspin_lock(&ksm_mmlist_lock);\n\tksm_scan.mm_slot = list_entry(slot->mm_list.next,\n\t\t\t\t\t\tstruct mm_slot, mm_list);\n\tif (ksm_scan.address == 0) {\n\t\t/*\n\t\t * We've completed a full scan of all vmas, holding mmap_sem\n\t\t * throughout, and found no VM_MERGEABLE: so do the same as\n\t\t * __ksm_exit does to remove this mm from all our lists now.\n\t\t * This applies either when cleaning up after __ksm_exit\n\t\t * (but beware: we can reach here even before __ksm_exit),\n\t\t * or when all VM_MERGEABLE areas have been unmapped (and\n\t\t * mmap_sem then protects against race with MADV_MERGEABLE).\n\t\t */\n\t\thash_del(&slot->link);\n\t\tlist_del(&slot->mm_list);\n\t\tspin_unlock(&ksm_mmlist_lock);\n\n\t\tfree_mm_slot(slot);\n\t\tclear_bit(MMF_VM_MERGEABLE, &mm->flags);\n\t\tup_read(&mm->mmap_sem);\n\t\tmmdrop(mm);\n\t} else {\n\t\tup_read(&mm->mmap_sem);\n\t\t/*\n\t\t * up_read(&mm->mmap_sem) first because after\n\t\t * spin_unlock(&ksm_mmlist_lock) run, the \"mm\" may\n\t\t * already have been freed under us by __ksm_exit()\n\t\t * because the \"mm_slot\" is still hashed and\n\t\t * ksm_scan.mm_slot doesn't point to it anymore.\n\t\t */\n\t\tspin_unlock(&ksm_mmlist_lock);\n\t}\n\n\t/* Repeat until we've completed scanning the whole list */\n\tslot = ksm_scan.mm_slot;\n\tif (slot != &ksm_mm_head)\n\t\tgoto next_mm;\n\n\tksm_scan.seqnr++;\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define ksm_nr_node_ids\t\t1",
            "#define ksm_merge_across_nodes\t1U"
          ],
          "globals_used": [
            "static struct rb_root *root_unstable_tree = one_unstable_tree;",
            "static LIST_HEAD(migrate_nodes);",
            "static struct mm_slot ksm_mm_head = {\n\t.mm_list = LIST_HEAD_INIT(ksm_mm_head.mm_list),\n};",
            "static struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};",
            "static DEFINE_SPINLOCK(ksm_mmlist_lock);",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define ksm_nr_node_ids\t\t1\n#define ksm_merge_across_nodes\t1U\n\nstatic struct rb_root *root_unstable_tree = one_unstable_tree;\nstatic LIST_HEAD(migrate_nodes);\nstatic struct mm_slot ksm_mm_head = {\n\t.mm_list = LIST_HEAD_INIT(ksm_mm_head.mm_list),\n};\nstatic struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};\nstatic DEFINE_SPINLOCK(ksm_mmlist_lock);\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct rmap_item *scan_get_next_rmap_item(struct page **page)\n{\n\tstruct mm_struct *mm;\n\tstruct mm_slot *slot;\n\tstruct vm_area_struct *vma;\n\tstruct rmap_item *rmap_item;\n\tint nid;\n\n\tif (list_empty(&ksm_mm_head.mm_list))\n\t\treturn NULL;\n\n\tslot = ksm_scan.mm_slot;\n\tif (slot == &ksm_mm_head) {\n\t\t/*\n\t\t * A number of pages can hang around indefinitely on per-cpu\n\t\t * pagevecs, raised page count preventing write_protect_page\n\t\t * from merging them.  Though it doesn't really matter much,\n\t\t * it is puzzling to see some stuck in pages_volatile until\n\t\t * other activity jostles them out, and they also prevented\n\t\t * LTP's KSM test from succeeding deterministically; so drain\n\t\t * them here (here rather than on entry to ksm_do_scan(),\n\t\t * so we don't IPI too often when pages_to_scan is set low).\n\t\t */\n\t\tlru_add_drain_all();\n\n\t\t/*\n\t\t * Whereas stale stable_nodes on the stable_tree itself\n\t\t * get pruned in the regular course of stable_tree_search(),\n\t\t * those moved out to the migrate_nodes list can accumulate:\n\t\t * so prune them once before each full scan.\n\t\t */\n\t\tif (!ksm_merge_across_nodes) {\n\t\t\tstruct stable_node *stable_node, *next;\n\t\t\tstruct page *page;\n\n\t\t\tlist_for_each_entry_safe(stable_node, next,\n\t\t\t\t\t\t &migrate_nodes, list) {\n\t\t\t\tpage = get_ksm_page(stable_node, false);\n\t\t\t\tif (page)\n\t\t\t\t\tput_page(page);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t}\n\n\t\tfor (nid = 0; nid < ksm_nr_node_ids; nid++)\n\t\t\troot_unstable_tree[nid] = RB_ROOT;\n\n\t\tspin_lock(&ksm_mmlist_lock);\n\t\tslot = list_entry(slot->mm_list.next, struct mm_slot, mm_list);\n\t\tksm_scan.mm_slot = slot;\n\t\tspin_unlock(&ksm_mmlist_lock);\n\t\t/*\n\t\t * Although we tested list_empty() above, a racing __ksm_exit\n\t\t * of the last mm on the list may have removed it since then.\n\t\t */\n\t\tif (slot == &ksm_mm_head)\n\t\t\treturn NULL;\nnext_mm:\n\t\tksm_scan.address = 0;\n\t\tksm_scan.rmap_list = &slot->rmap_list;\n\t}\n\n\tmm = slot->mm;\n\tdown_read(&mm->mmap_sem);\n\tif (ksm_test_exit(mm))\n\t\tvma = NULL;\n\telse\n\t\tvma = find_vma(mm, ksm_scan.address);\n\n\tfor (; vma; vma = vma->vm_next) {\n\t\tif (!(vma->vm_flags & VM_MERGEABLE))\n\t\t\tcontinue;\n\t\tif (ksm_scan.address < vma->vm_start)\n\t\t\tksm_scan.address = vma->vm_start;\n\t\tif (!vma->anon_vma)\n\t\t\tksm_scan.address = vma->vm_end;\n\n\t\twhile (ksm_scan.address < vma->vm_end) {\n\t\t\tif (ksm_test_exit(mm))\n\t\t\t\tbreak;\n\t\t\t*page = follow_page(vma, ksm_scan.address, FOLL_GET);\n\t\t\tif (IS_ERR_OR_NULL(*page)) {\n\t\t\t\tksm_scan.address += PAGE_SIZE;\n\t\t\t\tcond_resched();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (PageAnon(*page)) {\n\t\t\t\tflush_anon_page(vma, *page, ksm_scan.address);\n\t\t\t\tflush_dcache_page(*page);\n\t\t\t\trmap_item = get_next_rmap_item(slot,\n\t\t\t\t\tksm_scan.rmap_list, ksm_scan.address);\n\t\t\t\tif (rmap_item) {\n\t\t\t\t\tksm_scan.rmap_list =\n\t\t\t\t\t\t\t&rmap_item->rmap_list;\n\t\t\t\t\tksm_scan.address += PAGE_SIZE;\n\t\t\t\t} else\n\t\t\t\t\tput_page(*page);\n\t\t\t\tup_read(&mm->mmap_sem);\n\t\t\t\treturn rmap_item;\n\t\t\t}\n\t\t\tput_page(*page);\n\t\t\tksm_scan.address += PAGE_SIZE;\n\t\t\tcond_resched();\n\t\t}\n\t}\n\n\tif (ksm_test_exit(mm)) {\n\t\tksm_scan.address = 0;\n\t\tksm_scan.rmap_list = &slot->rmap_list;\n\t}\n\t/*\n\t * Nuke all the rmap_items that are above this current rmap:\n\t * because there were no VM_MERGEABLE vmas with such addresses.\n\t */\n\tremove_trailing_rmap_items(slot, ksm_scan.rmap_list);\n\n\tspin_lock(&ksm_mmlist_lock);\n\tksm_scan.mm_slot = list_entry(slot->mm_list.next,\n\t\t\t\t\t\tstruct mm_slot, mm_list);\n\tif (ksm_scan.address == 0) {\n\t\t/*\n\t\t * We've completed a full scan of all vmas, holding mmap_sem\n\t\t * throughout, and found no VM_MERGEABLE: so do the same as\n\t\t * __ksm_exit does to remove this mm from all our lists now.\n\t\t * This applies either when cleaning up after __ksm_exit\n\t\t * (but beware: we can reach here even before __ksm_exit),\n\t\t * or when all VM_MERGEABLE areas have been unmapped (and\n\t\t * mmap_sem then protects against race with MADV_MERGEABLE).\n\t\t */\n\t\thash_del(&slot->link);\n\t\tlist_del(&slot->mm_list);\n\t\tspin_unlock(&ksm_mmlist_lock);\n\n\t\tfree_mm_slot(slot);\n\t\tclear_bit(MMF_VM_MERGEABLE, &mm->flags);\n\t\tup_read(&mm->mmap_sem);\n\t\tmmdrop(mm);\n\t} else {\n\t\tup_read(&mm->mmap_sem);\n\t\t/*\n\t\t * up_read(&mm->mmap_sem) first because after\n\t\t * spin_unlock(&ksm_mmlist_lock) run, the \"mm\" may\n\t\t * already have been freed under us by __ksm_exit()\n\t\t * because the \"mm_slot\" is still hashed and\n\t\t * ksm_scan.mm_slot doesn't point to it anymore.\n\t\t */\n\t\tspin_unlock(&ksm_mmlist_lock);\n\t}\n\n\t/* Repeat until we've completed scanning the whole list */\n\tslot = ksm_scan.mm_slot;\n\tif (slot != &ksm_mm_head)\n\t\tgoto next_mm;\n\n\tksm_scan.seqnr++;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!freezing(current)"
          ],
          "line": 2377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freezing",
          "args": [
            "current"
          ],
          "line": 2377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic void ksm_do_scan(unsigned int scan_npages)\n{\n\tstruct rmap_item *rmap_item;\n\tstruct page *uninitialized_var(page);\n\n\twhile (scan_npages-- && likely(!freezing(current))) {\n\t\tcond_resched();\n\t\trmap_item = scan_get_next_rmap_item(&page);\n\t\tif (!rmap_item)\n\t\t\treturn;\n\t\tcmp_and_merge_page(page, rmap_item);\n\t\tput_page(page);\n\t}\n}"
  },
  {
    "function_name": "scan_get_next_rmap_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2210-2366",
    "snippet": "static struct rmap_item *scan_get_next_rmap_item(struct page **page)\n{\n\tstruct mm_struct *mm;\n\tstruct mm_slot *slot;\n\tstruct vm_area_struct *vma;\n\tstruct rmap_item *rmap_item;\n\tint nid;\n\n\tif (list_empty(&ksm_mm_head.mm_list))\n\t\treturn NULL;\n\n\tslot = ksm_scan.mm_slot;\n\tif (slot == &ksm_mm_head) {\n\t\t/*\n\t\t * A number of pages can hang around indefinitely on per-cpu\n\t\t * pagevecs, raised page count preventing write_protect_page\n\t\t * from merging them.  Though it doesn't really matter much,\n\t\t * it is puzzling to see some stuck in pages_volatile until\n\t\t * other activity jostles them out, and they also prevented\n\t\t * LTP's KSM test from succeeding deterministically; so drain\n\t\t * them here (here rather than on entry to ksm_do_scan(),\n\t\t * so we don't IPI too often when pages_to_scan is set low).\n\t\t */\n\t\tlru_add_drain_all();\n\n\t\t/*\n\t\t * Whereas stale stable_nodes on the stable_tree itself\n\t\t * get pruned in the regular course of stable_tree_search(),\n\t\t * those moved out to the migrate_nodes list can accumulate:\n\t\t * so prune them once before each full scan.\n\t\t */\n\t\tif (!ksm_merge_across_nodes) {\n\t\t\tstruct stable_node *stable_node, *next;\n\t\t\tstruct page *page;\n\n\t\t\tlist_for_each_entry_safe(stable_node, next,\n\t\t\t\t\t\t &migrate_nodes, list) {\n\t\t\t\tpage = get_ksm_page(stable_node, false);\n\t\t\t\tif (page)\n\t\t\t\t\tput_page(page);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t}\n\n\t\tfor (nid = 0; nid < ksm_nr_node_ids; nid++)\n\t\t\troot_unstable_tree[nid] = RB_ROOT;\n\n\t\tspin_lock(&ksm_mmlist_lock);\n\t\tslot = list_entry(slot->mm_list.next, struct mm_slot, mm_list);\n\t\tksm_scan.mm_slot = slot;\n\t\tspin_unlock(&ksm_mmlist_lock);\n\t\t/*\n\t\t * Although we tested list_empty() above, a racing __ksm_exit\n\t\t * of the last mm on the list may have removed it since then.\n\t\t */\n\t\tif (slot == &ksm_mm_head)\n\t\t\treturn NULL;\nnext_mm:\n\t\tksm_scan.address = 0;\n\t\tksm_scan.rmap_list = &slot->rmap_list;\n\t}\n\n\tmm = slot->mm;\n\tdown_read(&mm->mmap_sem);\n\tif (ksm_test_exit(mm))\n\t\tvma = NULL;\n\telse\n\t\tvma = find_vma(mm, ksm_scan.address);\n\n\tfor (; vma; vma = vma->vm_next) {\n\t\tif (!(vma->vm_flags & VM_MERGEABLE))\n\t\t\tcontinue;\n\t\tif (ksm_scan.address < vma->vm_start)\n\t\t\tksm_scan.address = vma->vm_start;\n\t\tif (!vma->anon_vma)\n\t\t\tksm_scan.address = vma->vm_end;\n\n\t\twhile (ksm_scan.address < vma->vm_end) {\n\t\t\tif (ksm_test_exit(mm))\n\t\t\t\tbreak;\n\t\t\t*page = follow_page(vma, ksm_scan.address, FOLL_GET);\n\t\t\tif (IS_ERR_OR_NULL(*page)) {\n\t\t\t\tksm_scan.address += PAGE_SIZE;\n\t\t\t\tcond_resched();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (PageAnon(*page)) {\n\t\t\t\tflush_anon_page(vma, *page, ksm_scan.address);\n\t\t\t\tflush_dcache_page(*page);\n\t\t\t\trmap_item = get_next_rmap_item(slot,\n\t\t\t\t\tksm_scan.rmap_list, ksm_scan.address);\n\t\t\t\tif (rmap_item) {\n\t\t\t\t\tksm_scan.rmap_list =\n\t\t\t\t\t\t\t&rmap_item->rmap_list;\n\t\t\t\t\tksm_scan.address += PAGE_SIZE;\n\t\t\t\t} else\n\t\t\t\t\tput_page(*page);\n\t\t\t\tup_read(&mm->mmap_sem);\n\t\t\t\treturn rmap_item;\n\t\t\t}\n\t\t\tput_page(*page);\n\t\t\tksm_scan.address += PAGE_SIZE;\n\t\t\tcond_resched();\n\t\t}\n\t}\n\n\tif (ksm_test_exit(mm)) {\n\t\tksm_scan.address = 0;\n\t\tksm_scan.rmap_list = &slot->rmap_list;\n\t}\n\t/*\n\t * Nuke all the rmap_items that are above this current rmap:\n\t * because there were no VM_MERGEABLE vmas with such addresses.\n\t */\n\tremove_trailing_rmap_items(slot, ksm_scan.rmap_list);\n\n\tspin_lock(&ksm_mmlist_lock);\n\tksm_scan.mm_slot = list_entry(slot->mm_list.next,\n\t\t\t\t\t\tstruct mm_slot, mm_list);\n\tif (ksm_scan.address == 0) {\n\t\t/*\n\t\t * We've completed a full scan of all vmas, holding mmap_sem\n\t\t * throughout, and found no VM_MERGEABLE: so do the same as\n\t\t * __ksm_exit does to remove this mm from all our lists now.\n\t\t * This applies either when cleaning up after __ksm_exit\n\t\t * (but beware: we can reach here even before __ksm_exit),\n\t\t * or when all VM_MERGEABLE areas have been unmapped (and\n\t\t * mmap_sem then protects against race with MADV_MERGEABLE).\n\t\t */\n\t\thash_del(&slot->link);\n\t\tlist_del(&slot->mm_list);\n\t\tspin_unlock(&ksm_mmlist_lock);\n\n\t\tfree_mm_slot(slot);\n\t\tclear_bit(MMF_VM_MERGEABLE, &mm->flags);\n\t\tup_read(&mm->mmap_sem);\n\t\tmmdrop(mm);\n\t} else {\n\t\tup_read(&mm->mmap_sem);\n\t\t/*\n\t\t * up_read(&mm->mmap_sem) first because after\n\t\t * spin_unlock(&ksm_mmlist_lock) run, the \"mm\" may\n\t\t * already have been freed under us by __ksm_exit()\n\t\t * because the \"mm_slot\" is still hashed and\n\t\t * ksm_scan.mm_slot doesn't point to it anymore.\n\t\t */\n\t\tspin_unlock(&ksm_mmlist_lock);\n\t}\n\n\t/* Repeat until we've completed scanning the whole list */\n\tslot = ksm_scan.mm_slot;\n\tif (slot != &ksm_mm_head)\n\t\tgoto next_mm;\n\n\tksm_scan.seqnr++;\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define ksm_nr_node_ids\t\t1",
      "#define ksm_merge_across_nodes\t1U"
    ],
    "globals_used": [
      "static struct rb_root *root_unstable_tree = one_unstable_tree;",
      "static LIST_HEAD(migrate_nodes);",
      "static struct mm_slot ksm_mm_head = {\n\t.mm_list = LIST_HEAD_INIT(ksm_mm_head.mm_list),\n};",
      "static struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};",
      "static DEFINE_SPINLOCK(ksm_mmlist_lock);",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ksm_mmlist_lock"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmdrop",
          "args": [
            "mm"
          ],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "MMF_VM_MERGEABLE",
            "&mm->flags"
          ],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "clear_bit_unlock_is_negative_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1171-1176",
          "snippet": "static inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_mm_slot",
          "args": [
            "slot"
          ],
          "line": 2343
        },
        "resolved": true,
        "details": {
          "function_name": "free_mm_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "419-422",
          "snippet": "static inline void free_mm_slot(struct mm_slot *mm_slot)\n{\n\tkmem_cache_free(mm_slot_cache, mm_slot);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *mm_slot_cache;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct kmem_cache *mm_slot_cache;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void free_mm_slot(struct mm_slot *mm_slot)\n{\n\tkmem_cache_free(mm_slot_cache, mm_slot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ksm_mmlist_lock"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&slot->mm_list"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_del",
          "args": [
            "&slot->link"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "slot->mm_list.next",
            "structmm_slot",
            "mm_list"
          ],
          "line": 2327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ksm_mmlist_lock"
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_trailing_rmap_items",
          "args": [
            "slot",
            "ksm_scan.rmap_list"
          ],
          "line": 2324
        },
        "resolved": true,
        "details": {
          "function_name": "remove_trailing_rmap_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "804-813",
          "snippet": "static void remove_trailing_rmap_items(struct mm_slot *mm_slot,\n\t\t\t\t       struct rmap_item **rmap_list)\n{\n\twhile (*rmap_list) {\n\t\tstruct rmap_item *rmap_item = *rmap_list;\n\t\t*rmap_list = rmap_item->rmap_list;\n\t\tremove_rmap_item_from_tree(rmap_item);\n\t\tfree_rmap_item(rmap_item);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic void remove_trailing_rmap_items(struct mm_slot *mm_slot,\n\t\t\t\t       struct rmap_item **rmap_list)\n{\n\twhile (*rmap_list) {\n\t\tstruct rmap_item *rmap_item = *rmap_list;\n\t\t*rmap_list = rmap_item->rmap_list;\n\t\tremove_rmap_item_from_tree(rmap_item);\n\t\tfree_rmap_item(rmap_item);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ksm_test_exit",
          "args": [
            "mm"
          ],
          "line": 2316
        },
        "resolved": true,
        "details": {
          "function_name": "ksm_test_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "450-453",
          "snippet": "static inline bool ksm_test_exit(struct mm_struct *mm)\n{\n\treturn atomic_read(&mm->mm_users) == 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline bool ksm_test_exit(struct mm_struct *mm)\n{\n\treturn atomic_read(&mm->mm_users) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "*page"
          ],
          "line": 2310
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_next_rmap_item",
          "args": [
            "slot",
            "ksm_scan.rmap_list",
            "ksm_scan.address"
          ],
          "line": 2299
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_rmap_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "2182-2208",
          "snippet": "static struct rmap_item *get_next_rmap_item(struct mm_slot *mm_slot,\n\t\t\t\t\t    struct rmap_item **rmap_list,\n\t\t\t\t\t    unsigned long addr)\n{\n\tstruct rmap_item *rmap_item;\n\n\twhile (*rmap_list) {\n\t\trmap_item = *rmap_list;\n\t\tif ((rmap_item->address & PAGE_MASK) == addr)\n\t\t\treturn rmap_item;\n\t\tif (rmap_item->address > addr)\n\t\t\tbreak;\n\t\t*rmap_list = rmap_item->rmap_list;\n\t\tremove_rmap_item_from_tree(rmap_item);\n\t\tfree_rmap_item(rmap_item);\n\t}\n\n\trmap_item = alloc_rmap_item();\n\tif (rmap_item) {\n\t\t/* It has already been zeroed */\n\t\trmap_item->mm = mm_slot->mm;\n\t\trmap_item->address = addr;\n\t\trmap_item->rmap_list = *rmap_list;\n\t\t*rmap_list = rmap_item;\n\t}\n\treturn rmap_item;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct rmap_item *get_next_rmap_item(struct mm_slot *mm_slot,\n\t\t\t\t\t    struct rmap_item **rmap_list,\n\t\t\t\t\t    unsigned long addr)\n{\n\tstruct rmap_item *rmap_item;\n\n\twhile (*rmap_list) {\n\t\trmap_item = *rmap_list;\n\t\tif ((rmap_item->address & PAGE_MASK) == addr)\n\t\t\treturn rmap_item;\n\t\tif (rmap_item->address > addr)\n\t\t\tbreak;\n\t\t*rmap_list = rmap_item->rmap_list;\n\t\tremove_rmap_item_from_tree(rmap_item);\n\t\tfree_rmap_item(rmap_item);\n\t}\n\n\trmap_item = alloc_rmap_item();\n\tif (rmap_item) {\n\t\t/* It has already been zeroed */\n\t\trmap_item->mm = mm_slot->mm;\n\t\trmap_item->address = addr;\n\t\trmap_item->rmap_list = *rmap_list;\n\t\t*rmap_list = rmap_item;\n\t}\n\treturn rmap_item;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "*page"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_anon_page",
          "args": [
            "vma",
            "*page",
            "ksm_scan.address"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "*page"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "*page"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_page",
          "args": [
            "vma",
            "ksm_scan.address",
            "FOLL_GET"
          ],
          "line": 2290
        },
        "resolved": true,
        "details": {
          "function_name": "follow_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "1712-1716",
          "snippet": "struct page *follow_page(struct vm_area_struct *vma, unsigned long address,\n\t\t\t unsigned int foll_flags)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct page *follow_page(struct vm_area_struct *vma, unsigned long address,\n\t\t\t unsigned int foll_flags)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "mm",
            "ksm_scan.address"
          ],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "775-796",
          "snippet": "struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ksm_mmlist_lock"
          ],
          "line": 2260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "slot->mm_list.next",
            "structmm_slot",
            "mm_list"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ksm_mmlist_lock"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ksm_page",
          "args": [
            "stable_node",
            "false"
          ],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "get_ksm_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "688-752",
          "snippet": "static struct page *get_ksm_page(struct stable_node *stable_node, bool lock_it)\n{\n\tstruct page *page;\n\tvoid *expected_mapping;\n\tunsigned long kpfn;\n\n\texpected_mapping = (void *)((unsigned long)stable_node |\n\t\t\t\t\tPAGE_MAPPING_KSM);\nagain:\n\tkpfn = READ_ONCE(stable_node->kpfn); /* Address dependency. */\n\tpage = pfn_to_page(kpfn);\n\tif (READ_ONCE(page->mapping) != expected_mapping)\n\t\tgoto stale;\n\n\t/*\n\t * We cannot do anything with the page while its refcount is 0.\n\t * Usually 0 means free, or tail of a higher-order page: in which\n\t * case this node is no longer referenced, and should be freed;\n\t * however, it might mean that the page is under page_ref_freeze().\n\t * The __remove_mapping() case is easy, again the node is now stale;\n\t * but if page is swapcache in migrate_page_move_mapping(), it might\n\t * still be our page, in which case it's essential to keep the node.\n\t */\n\twhile (!get_page_unless_zero(page)) {\n\t\t/*\n\t\t * Another check for page->mapping != expected_mapping would\n\t\t * work here too.  We have chosen the !PageSwapCache test to\n\t\t * optimize the common case, when the page is or is about to\n\t\t * be freed: PageSwapCache is cleared (under spin_lock_irq)\n\t\t * in the ref_freeze section of __remove_mapping(); but Anon\n\t\t * page->mapping reset to NULL later, in free_pages_prepare().\n\t\t */\n\t\tif (!PageSwapCache(page))\n\t\t\tgoto stale;\n\t\tcpu_relax();\n\t}\n\n\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\tput_page(page);\n\t\tgoto stale;\n\t}\n\n\tif (lock_it) {\n\t\tlock_page(page);\n\t\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto stale;\n\t\t}\n\t}\n\treturn page;\n\nstale:\n\t/*\n\t * We come here from above when page->mapping or !PageSwapCache\n\t * suggests that the node is stale; but it might be under migration.\n\t * We need smp_rmb(), matching the smp_wmb() in ksm_migrate_page(),\n\t * before checking whether node->kpfn has been changed.\n\t */\n\tsmp_rmb();\n\tif (READ_ONCE(stable_node->kpfn) != kpfn)\n\t\tgoto again;\n\tremove_node_from_stable_tree(stable_node);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct page *get_ksm_page(struct stable_node *stable_node, bool lock_it)\n{\n\tstruct page *page;\n\tvoid *expected_mapping;\n\tunsigned long kpfn;\n\n\texpected_mapping = (void *)((unsigned long)stable_node |\n\t\t\t\t\tPAGE_MAPPING_KSM);\nagain:\n\tkpfn = READ_ONCE(stable_node->kpfn); /* Address dependency. */\n\tpage = pfn_to_page(kpfn);\n\tif (READ_ONCE(page->mapping) != expected_mapping)\n\t\tgoto stale;\n\n\t/*\n\t * We cannot do anything with the page while its refcount is 0.\n\t * Usually 0 means free, or tail of a higher-order page: in which\n\t * case this node is no longer referenced, and should be freed;\n\t * however, it might mean that the page is under page_ref_freeze().\n\t * The __remove_mapping() case is easy, again the node is now stale;\n\t * but if page is swapcache in migrate_page_move_mapping(), it might\n\t * still be our page, in which case it's essential to keep the node.\n\t */\n\twhile (!get_page_unless_zero(page)) {\n\t\t/*\n\t\t * Another check for page->mapping != expected_mapping would\n\t\t * work here too.  We have chosen the !PageSwapCache test to\n\t\t * optimize the common case, when the page is or is about to\n\t\t * be freed: PageSwapCache is cleared (under spin_lock_irq)\n\t\t * in the ref_freeze section of __remove_mapping(); but Anon\n\t\t * page->mapping reset to NULL later, in free_pages_prepare().\n\t\t */\n\t\tif (!PageSwapCache(page))\n\t\t\tgoto stale;\n\t\tcpu_relax();\n\t}\n\n\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\tput_page(page);\n\t\tgoto stale;\n\t}\n\n\tif (lock_it) {\n\t\tlock_page(page);\n\t\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto stale;\n\t\t}\n\t}\n\treturn page;\n\nstale:\n\t/*\n\t * We come here from above when page->mapping or !PageSwapCache\n\t * suggests that the node is stale; but it might be under migration.\n\t * We need smp_rmb(), matching the smp_wmb() in ksm_migrate_page(),\n\t * before checking whether node->kpfn has been changed.\n\t */\n\tsmp_rmb();\n\tif (READ_ONCE(stable_node->kpfn) != kpfn)\n\t\tgoto again;\n\tremove_node_from_stable_tree(stable_node);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "stable_node",
            "next",
            "&migrate_nodes",
            "list"
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_add_drain_all",
          "args": [],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ksm_mm_head.mm_list"
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define ksm_nr_node_ids\t\t1\n#define ksm_merge_across_nodes\t1U\n\nstatic struct rb_root *root_unstable_tree = one_unstable_tree;\nstatic LIST_HEAD(migrate_nodes);\nstatic struct mm_slot ksm_mm_head = {\n\t.mm_list = LIST_HEAD_INIT(ksm_mm_head.mm_list),\n};\nstatic struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};\nstatic DEFINE_SPINLOCK(ksm_mmlist_lock);\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct rmap_item *scan_get_next_rmap_item(struct page **page)\n{\n\tstruct mm_struct *mm;\n\tstruct mm_slot *slot;\n\tstruct vm_area_struct *vma;\n\tstruct rmap_item *rmap_item;\n\tint nid;\n\n\tif (list_empty(&ksm_mm_head.mm_list))\n\t\treturn NULL;\n\n\tslot = ksm_scan.mm_slot;\n\tif (slot == &ksm_mm_head) {\n\t\t/*\n\t\t * A number of pages can hang around indefinitely on per-cpu\n\t\t * pagevecs, raised page count preventing write_protect_page\n\t\t * from merging them.  Though it doesn't really matter much,\n\t\t * it is puzzling to see some stuck in pages_volatile until\n\t\t * other activity jostles them out, and they also prevented\n\t\t * LTP's KSM test from succeeding deterministically; so drain\n\t\t * them here (here rather than on entry to ksm_do_scan(),\n\t\t * so we don't IPI too often when pages_to_scan is set low).\n\t\t */\n\t\tlru_add_drain_all();\n\n\t\t/*\n\t\t * Whereas stale stable_nodes on the stable_tree itself\n\t\t * get pruned in the regular course of stable_tree_search(),\n\t\t * those moved out to the migrate_nodes list can accumulate:\n\t\t * so prune them once before each full scan.\n\t\t */\n\t\tif (!ksm_merge_across_nodes) {\n\t\t\tstruct stable_node *stable_node, *next;\n\t\t\tstruct page *page;\n\n\t\t\tlist_for_each_entry_safe(stable_node, next,\n\t\t\t\t\t\t &migrate_nodes, list) {\n\t\t\t\tpage = get_ksm_page(stable_node, false);\n\t\t\t\tif (page)\n\t\t\t\t\tput_page(page);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t}\n\n\t\tfor (nid = 0; nid < ksm_nr_node_ids; nid++)\n\t\t\troot_unstable_tree[nid] = RB_ROOT;\n\n\t\tspin_lock(&ksm_mmlist_lock);\n\t\tslot = list_entry(slot->mm_list.next, struct mm_slot, mm_list);\n\t\tksm_scan.mm_slot = slot;\n\t\tspin_unlock(&ksm_mmlist_lock);\n\t\t/*\n\t\t * Although we tested list_empty() above, a racing __ksm_exit\n\t\t * of the last mm on the list may have removed it since then.\n\t\t */\n\t\tif (slot == &ksm_mm_head)\n\t\t\treturn NULL;\nnext_mm:\n\t\tksm_scan.address = 0;\n\t\tksm_scan.rmap_list = &slot->rmap_list;\n\t}\n\n\tmm = slot->mm;\n\tdown_read(&mm->mmap_sem);\n\tif (ksm_test_exit(mm))\n\t\tvma = NULL;\n\telse\n\t\tvma = find_vma(mm, ksm_scan.address);\n\n\tfor (; vma; vma = vma->vm_next) {\n\t\tif (!(vma->vm_flags & VM_MERGEABLE))\n\t\t\tcontinue;\n\t\tif (ksm_scan.address < vma->vm_start)\n\t\t\tksm_scan.address = vma->vm_start;\n\t\tif (!vma->anon_vma)\n\t\t\tksm_scan.address = vma->vm_end;\n\n\t\twhile (ksm_scan.address < vma->vm_end) {\n\t\t\tif (ksm_test_exit(mm))\n\t\t\t\tbreak;\n\t\t\t*page = follow_page(vma, ksm_scan.address, FOLL_GET);\n\t\t\tif (IS_ERR_OR_NULL(*page)) {\n\t\t\t\tksm_scan.address += PAGE_SIZE;\n\t\t\t\tcond_resched();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (PageAnon(*page)) {\n\t\t\t\tflush_anon_page(vma, *page, ksm_scan.address);\n\t\t\t\tflush_dcache_page(*page);\n\t\t\t\trmap_item = get_next_rmap_item(slot,\n\t\t\t\t\tksm_scan.rmap_list, ksm_scan.address);\n\t\t\t\tif (rmap_item) {\n\t\t\t\t\tksm_scan.rmap_list =\n\t\t\t\t\t\t\t&rmap_item->rmap_list;\n\t\t\t\t\tksm_scan.address += PAGE_SIZE;\n\t\t\t\t} else\n\t\t\t\t\tput_page(*page);\n\t\t\t\tup_read(&mm->mmap_sem);\n\t\t\t\treturn rmap_item;\n\t\t\t}\n\t\t\tput_page(*page);\n\t\t\tksm_scan.address += PAGE_SIZE;\n\t\t\tcond_resched();\n\t\t}\n\t}\n\n\tif (ksm_test_exit(mm)) {\n\t\tksm_scan.address = 0;\n\t\tksm_scan.rmap_list = &slot->rmap_list;\n\t}\n\t/*\n\t * Nuke all the rmap_items that are above this current rmap:\n\t * because there were no VM_MERGEABLE vmas with such addresses.\n\t */\n\tremove_trailing_rmap_items(slot, ksm_scan.rmap_list);\n\n\tspin_lock(&ksm_mmlist_lock);\n\tksm_scan.mm_slot = list_entry(slot->mm_list.next,\n\t\t\t\t\t\tstruct mm_slot, mm_list);\n\tif (ksm_scan.address == 0) {\n\t\t/*\n\t\t * We've completed a full scan of all vmas, holding mmap_sem\n\t\t * throughout, and found no VM_MERGEABLE: so do the same as\n\t\t * __ksm_exit does to remove this mm from all our lists now.\n\t\t * This applies either when cleaning up after __ksm_exit\n\t\t * (but beware: we can reach here even before __ksm_exit),\n\t\t * or when all VM_MERGEABLE areas have been unmapped (and\n\t\t * mmap_sem then protects against race with MADV_MERGEABLE).\n\t\t */\n\t\thash_del(&slot->link);\n\t\tlist_del(&slot->mm_list);\n\t\tspin_unlock(&ksm_mmlist_lock);\n\n\t\tfree_mm_slot(slot);\n\t\tclear_bit(MMF_VM_MERGEABLE, &mm->flags);\n\t\tup_read(&mm->mmap_sem);\n\t\tmmdrop(mm);\n\t} else {\n\t\tup_read(&mm->mmap_sem);\n\t\t/*\n\t\t * up_read(&mm->mmap_sem) first because after\n\t\t * spin_unlock(&ksm_mmlist_lock) run, the \"mm\" may\n\t\t * already have been freed under us by __ksm_exit()\n\t\t * because the \"mm_slot\" is still hashed and\n\t\t * ksm_scan.mm_slot doesn't point to it anymore.\n\t\t */\n\t\tspin_unlock(&ksm_mmlist_lock);\n\t}\n\n\t/* Repeat until we've completed scanning the whole list */\n\tslot = ksm_scan.mm_slot;\n\tif (slot != &ksm_mm_head)\n\t\tgoto next_mm;\n\n\tksm_scan.seqnr++;\n\treturn NULL;\n}"
  },
  {
    "function_name": "get_next_rmap_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2182-2208",
    "snippet": "static struct rmap_item *get_next_rmap_item(struct mm_slot *mm_slot,\n\t\t\t\t\t    struct rmap_item **rmap_list,\n\t\t\t\t\t    unsigned long addr)\n{\n\tstruct rmap_item *rmap_item;\n\n\twhile (*rmap_list) {\n\t\trmap_item = *rmap_list;\n\t\tif ((rmap_item->address & PAGE_MASK) == addr)\n\t\t\treturn rmap_item;\n\t\tif (rmap_item->address > addr)\n\t\t\tbreak;\n\t\t*rmap_list = rmap_item->rmap_list;\n\t\tremove_rmap_item_from_tree(rmap_item);\n\t\tfree_rmap_item(rmap_item);\n\t}\n\n\trmap_item = alloc_rmap_item();\n\tif (rmap_item) {\n\t\t/* It has already been zeroed */\n\t\trmap_item->mm = mm_slot->mm;\n\t\trmap_item->address = addr;\n\t\trmap_item->rmap_list = *rmap_list;\n\t\t*rmap_list = rmap_item;\n\t}\n\treturn rmap_item;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_rmap_item",
          "args": [],
          "line": 2199
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_rmap_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "377-386",
          "snippet": "static inline struct rmap_item *alloc_rmap_item(void)\n{\n\tstruct rmap_item *rmap_item;\n\n\trmap_item = kmem_cache_zalloc(rmap_item_cache, GFP_KERNEL |\n\t\t\t\t\t\t__GFP_NORETRY | __GFP_NOWARN);\n\tif (rmap_item)\n\t\tksm_rmap_items++;\n\treturn rmap_item;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *rmap_item_cache;",
            "static unsigned long ksm_rmap_items;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct kmem_cache *rmap_item_cache;\nstatic unsigned long ksm_rmap_items;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline struct rmap_item *alloc_rmap_item(void)\n{\n\tstruct rmap_item *rmap_item;\n\n\trmap_item = kmem_cache_zalloc(rmap_item_cache, GFP_KERNEL |\n\t\t\t\t\t\t__GFP_NORETRY | __GFP_NOWARN);\n\tif (rmap_item)\n\t\tksm_rmap_items++;\n\treturn rmap_item;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_rmap_item",
          "args": [
            "rmap_item"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "free_rmap_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "388-393",
          "snippet": "static inline void free_rmap_item(struct rmap_item *rmap_item)\n{\n\tksm_rmap_items--;\n\trmap_item->mm = NULL;\t/* debug safety */\n\tkmem_cache_free(rmap_item_cache, rmap_item);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *rmap_item_cache;",
            "static unsigned long ksm_rmap_items;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct kmem_cache *rmap_item_cache;\nstatic unsigned long ksm_rmap_items;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void free_rmap_item(struct rmap_item *rmap_item)\n{\n\tksm_rmap_items--;\n\trmap_item->mm = NULL;\t/* debug safety */\n\tkmem_cache_free(rmap_item_cache, rmap_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_rmap_item_from_tree",
          "args": [
            "rmap_item"
          ],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "remove_rmap_item_from_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "758-802",
          "snippet": "static void remove_rmap_item_from_tree(struct rmap_item *rmap_item)\n{\n\tif (rmap_item->address & STABLE_FLAG) {\n\t\tstruct stable_node *stable_node;\n\t\tstruct page *page;\n\n\t\tstable_node = rmap_item->head;\n\t\tpage = get_ksm_page(stable_node, true);\n\t\tif (!page)\n\t\t\tgoto out;\n\n\t\thlist_del(&rmap_item->hlist);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (!hlist_empty(&stable_node->hlist))\n\t\t\tksm_pages_sharing--;\n\t\telse\n\t\t\tksm_pages_shared--;\n\t\tVM_BUG_ON(stable_node->rmap_hlist_len <= 0);\n\t\tstable_node->rmap_hlist_len--;\n\n\t\tput_anon_vma(rmap_item->anon_vma);\n\t\trmap_item->address &= PAGE_MASK;\n\n\t} else if (rmap_item->address & UNSTABLE_FLAG) {\n\t\tunsigned char age;\n\t\t/*\n\t\t * Usually ksmd can and must skip the rb_erase, because\n\t\t * root_unstable_tree was already reset to RB_ROOT.\n\t\t * But be careful when an mm is exiting: do the rb_erase\n\t\t * if this rmap_item was inserted by this scan, rather\n\t\t * than left over from before.\n\t\t */\n\t\tage = (unsigned char)(ksm_scan.seqnr - rmap_item->address);\n\t\tBUG_ON(age > 1);\n\t\tif (!age)\n\t\t\trb_erase(&rmap_item->node,\n\t\t\t\t root_unstable_tree + NUMA(rmap_item->nid));\n\t\tksm_pages_unshared--;\n\t\trmap_item->address &= PAGE_MASK;\n\t}\nout:\n\tcond_resched();\t\t/* we're called from many long loops */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_FLAG\t0x200\t/* is listed from the stable tree */",
            "#define UNSTABLE_FLAG\t0x100\t/* is a node of the unstable tree */"
          ],
          "globals_used": [
            "static struct rb_root *root_unstable_tree = one_unstable_tree;",
            "static struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};",
            "static unsigned long ksm_pages_shared;",
            "static unsigned long ksm_pages_sharing;",
            "static unsigned long ksm_pages_unshared;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_FLAG\t0x200\t/* is listed from the stable tree */\n#define UNSTABLE_FLAG\t0x100\t/* is a node of the unstable tree */\n\nstatic struct rb_root *root_unstable_tree = one_unstable_tree;\nstatic struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};\nstatic unsigned long ksm_pages_shared;\nstatic unsigned long ksm_pages_sharing;\nstatic unsigned long ksm_pages_unshared;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic void remove_rmap_item_from_tree(struct rmap_item *rmap_item)\n{\n\tif (rmap_item->address & STABLE_FLAG) {\n\t\tstruct stable_node *stable_node;\n\t\tstruct page *page;\n\n\t\tstable_node = rmap_item->head;\n\t\tpage = get_ksm_page(stable_node, true);\n\t\tif (!page)\n\t\t\tgoto out;\n\n\t\thlist_del(&rmap_item->hlist);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (!hlist_empty(&stable_node->hlist))\n\t\t\tksm_pages_sharing--;\n\t\telse\n\t\t\tksm_pages_shared--;\n\t\tVM_BUG_ON(stable_node->rmap_hlist_len <= 0);\n\t\tstable_node->rmap_hlist_len--;\n\n\t\tput_anon_vma(rmap_item->anon_vma);\n\t\trmap_item->address &= PAGE_MASK;\n\n\t} else if (rmap_item->address & UNSTABLE_FLAG) {\n\t\tunsigned char age;\n\t\t/*\n\t\t * Usually ksmd can and must skip the rb_erase, because\n\t\t * root_unstable_tree was already reset to RB_ROOT.\n\t\t * But be careful when an mm is exiting: do the rb_erase\n\t\t * if this rmap_item was inserted by this scan, rather\n\t\t * than left over from before.\n\t\t */\n\t\tage = (unsigned char)(ksm_scan.seqnr - rmap_item->address);\n\t\tBUG_ON(age > 1);\n\t\tif (!age)\n\t\t\trb_erase(&rmap_item->node,\n\t\t\t\t root_unstable_tree + NUMA(rmap_item->nid));\n\t\tksm_pages_unshared--;\n\t\trmap_item->address &= PAGE_MASK;\n\t}\nout:\n\tcond_resched();\t\t/* we're called from many long loops */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct rmap_item *get_next_rmap_item(struct mm_slot *mm_slot,\n\t\t\t\t\t    struct rmap_item **rmap_list,\n\t\t\t\t\t    unsigned long addr)\n{\n\tstruct rmap_item *rmap_item;\n\n\twhile (*rmap_list) {\n\t\trmap_item = *rmap_list;\n\t\tif ((rmap_item->address & PAGE_MASK) == addr)\n\t\t\treturn rmap_item;\n\t\tif (rmap_item->address > addr)\n\t\t\tbreak;\n\t\t*rmap_list = rmap_item->rmap_list;\n\t\tremove_rmap_item_from_tree(rmap_item);\n\t\tfree_rmap_item(rmap_item);\n\t}\n\n\trmap_item = alloc_rmap_item();\n\tif (rmap_item) {\n\t\t/* It has already been zeroed */\n\t\trmap_item->mm = mm_slot->mm;\n\t\trmap_item->address = addr;\n\t\trmap_item->rmap_list = *rmap_list;\n\t\t*rmap_list = rmap_item;\n\t}\n\treturn rmap_item;\n}"
  },
  {
    "function_name": "cmp_and_merge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "2032-2180",
    "snippet": "static void cmp_and_merge_page(struct page *page, struct rmap_item *rmap_item)\n{\n\tstruct mm_struct *mm = rmap_item->mm;\n\tstruct rmap_item *tree_rmap_item;\n\tstruct page *tree_page = NULL;\n\tstruct stable_node *stable_node;\n\tstruct page *kpage;\n\tunsigned int checksum;\n\tint err;\n\tbool max_page_sharing_bypass = false;\n\n\tstable_node = page_stable_node(page);\n\tif (stable_node) {\n\t\tif (stable_node->head != &migrate_nodes &&\n\t\t    get_kpfn_nid(READ_ONCE(stable_node->kpfn)) !=\n\t\t    NUMA(stable_node->nid)) {\n\t\t\tstable_node_dup_del(stable_node);\n\t\t\tstable_node->head = &migrate_nodes;\n\t\t\tlist_add(&stable_node->list, stable_node->head);\n\t\t}\n\t\tif (stable_node->head != &migrate_nodes &&\n\t\t    rmap_item->head == stable_node)\n\t\t\treturn;\n\t\t/*\n\t\t * If it's a KSM fork, allow it to go over the sharing limit\n\t\t * without warnings.\n\t\t */\n\t\tif (!is_page_sharing_candidate(stable_node))\n\t\t\tmax_page_sharing_bypass = true;\n\t}\n\n\t/* We first start with searching the page inside the stable tree */\n\tkpage = stable_tree_search(page);\n\tif (kpage == page && rmap_item->head == stable_node) {\n\t\tput_page(kpage);\n\t\treturn;\n\t}\n\n\tremove_rmap_item_from_tree(rmap_item);\n\n\tif (kpage) {\n\t\terr = try_to_merge_with_ksm_page(rmap_item, page, kpage);\n\t\tif (!err) {\n\t\t\t/*\n\t\t\t * The page was successfully merged:\n\t\t\t * add its rmap_item to the stable tree.\n\t\t\t */\n\t\t\tlock_page(kpage);\n\t\t\tstable_tree_append(rmap_item, page_stable_node(kpage),\n\t\t\t\t\t   max_page_sharing_bypass);\n\t\t\tunlock_page(kpage);\n\t\t}\n\t\tput_page(kpage);\n\t\treturn;\n\t}\n\n\t/*\n\t * If the hash value of the page has changed from the last time\n\t * we calculated it, this page is changing frequently: therefore we\n\t * don't want to insert it in the unstable tree, and we don't want\n\t * to waste our time searching for something identical to it there.\n\t */\n\tchecksum = calc_checksum(page);\n\tif (rmap_item->oldchecksum != checksum) {\n\t\trmap_item->oldchecksum = checksum;\n\t\treturn;\n\t}\n\n\t/*\n\t * Same checksum as an empty page. We attempt to merge it with the\n\t * appropriate zero page if the user enabled this via sysfs.\n\t */\n\tif (ksm_use_zero_pages && (checksum == zero_checksum)) {\n\t\tstruct vm_area_struct *vma;\n\n\t\tdown_read(&mm->mmap_sem);\n\t\tvma = find_mergeable_vma(mm, rmap_item->address);\n\t\terr = try_to_merge_one_page(vma, page,\n\t\t\t\t\t    ZERO_PAGE(rmap_item->address));\n\t\tup_read(&mm->mmap_sem);\n\t\t/*\n\t\t * In case of failure, the page was not really empty, so we\n\t\t * need to continue. Otherwise we're done.\n\t\t */\n\t\tif (!err)\n\t\t\treturn;\n\t}\n\ttree_rmap_item =\n\t\tunstable_tree_search_insert(rmap_item, page, &tree_page);\n\tif (tree_rmap_item) {\n\t\tbool split;\n\n\t\tkpage = try_to_merge_two_pages(rmap_item, page,\n\t\t\t\t\t\ttree_rmap_item, tree_page);\n\t\t/*\n\t\t * If both pages we tried to merge belong to the same compound\n\t\t * page, then we actually ended up increasing the reference\n\t\t * count of the same compound page twice, and split_huge_page\n\t\t * failed.\n\t\t * Here we set a flag if that happened, and we use it later to\n\t\t * try split_huge_page again. Since we call put_page right\n\t\t * afterwards, the reference count will be correct and\n\t\t * split_huge_page should succeed.\n\t\t */\n\t\tsplit = PageTransCompound(page)\n\t\t\t&& compound_head(page) == compound_head(tree_page);\n\t\tput_page(tree_page);\n\t\tif (kpage) {\n\t\t\t/*\n\t\t\t * The pages were successfully merged: insert new\n\t\t\t * node in the stable tree and add both rmap_items.\n\t\t\t */\n\t\t\tlock_page(kpage);\n\t\t\tstable_node = stable_tree_insert(kpage);\n\t\t\tif (stable_node) {\n\t\t\t\tstable_tree_append(tree_rmap_item, stable_node,\n\t\t\t\t\t\t   false);\n\t\t\t\tstable_tree_append(rmap_item, stable_node,\n\t\t\t\t\t\t   false);\n\t\t\t}\n\t\t\tunlock_page(kpage);\n\n\t\t\t/*\n\t\t\t * If we fail to insert the page into the stable tree,\n\t\t\t * we will have 2 virtual addresses that are pointing\n\t\t\t * to a ksm page left outside the stable tree,\n\t\t\t * in which case we need to break_cow on both.\n\t\t\t */\n\t\t\tif (!stable_node) {\n\t\t\t\tbreak_cow(tree_rmap_item);\n\t\t\t\tbreak_cow(rmap_item);\n\t\t\t}\n\t\t} else if (split) {\n\t\t\t/*\n\t\t\t * We are here if we tried to merge two pages and\n\t\t\t * failed because they both belonged to the same\n\t\t\t * compound page. We will split the page now, but no\n\t\t\t * merging will take place.\n\t\t\t * We do not want to add the cost of a full lock; if\n\t\t\t * the page is locked, it is better to skip it and\n\t\t\t * perhaps try again later.\n\t\t\t */\n\t\t\tif (!trylock_page(page))\n\t\t\t\treturn;\n\t\t\tsplit_huge_page(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(migrate_nodes);",
      "static unsigned int zero_checksum",
      "static bool ksm_use_zero_pages",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2177
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "split_huge_page",
          "args": [
            "page"
          ],
          "line": 2176
        },
        "resolved": true,
        "details": {
          "function_name": "deferred_split_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2760-2774",
          "snippet": "void deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "break_cow",
          "args": [
            "rmap_item"
          ],
          "line": 2162
        },
        "resolved": true,
        "details": {
          "function_name": "break_cow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "533-550",
          "snippet": "static void break_cow(struct rmap_item *rmap_item)\n{\n\tstruct mm_struct *mm = rmap_item->mm;\n\tunsigned long addr = rmap_item->address;\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * It is not an accident that whenever we want to break COW\n\t * to undo, we also need to drop a reference to the anon_vma.\n\t */\n\tput_anon_vma(rmap_item->anon_vma);\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_mergeable_vma(mm, addr);\n\tif (vma)\n\t\tbreak_ksm(vma, addr);\n\tup_read(&mm->mmap_sem);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic void break_cow(struct rmap_item *rmap_item)\n{\n\tstruct mm_struct *mm = rmap_item->mm;\n\tunsigned long addr = rmap_item->address;\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * It is not an accident that whenever we want to break COW\n\t * to undo, we also need to drop a reference to the anon_vma.\n\t */\n\tput_anon_vma(rmap_item->anon_vma);\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_mergeable_vma(mm, addr);\n\tif (vma)\n\t\tbreak_ksm(vma, addr);\n\tup_read(&mm->mmap_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stable_tree_append",
          "args": [
            "rmap_item",
            "stable_node",
            "false"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "stable_tree_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1991-2021",
          "snippet": "static void stable_tree_append(struct rmap_item *rmap_item,\n\t\t\t       struct stable_node *stable_node,\n\t\t\t       bool max_page_sharing_bypass)\n{\n\t/*\n\t * rmap won't find this mapping if we don't insert the\n\t * rmap_item in the right stable_node\n\t * duplicate. page_migration could break later if rmap breaks,\n\t * so we can as well crash here. We really need to check for\n\t * rmap_hlist_len == STABLE_NODE_CHAIN, but we can as well check\n\t * for other negative values as an undeflow if detected here\n\t * for the first time (and not when decreasing rmap_hlist_len)\n\t * would be sign of memory corruption in the stable_node.\n\t */\n\tBUG_ON(stable_node->rmap_hlist_len < 0);\n\n\tstable_node->rmap_hlist_len++;\n\tif (!max_page_sharing_bypass)\n\t\t/* possibly non fatal but unexpected overflow, only warn */\n\t\tWARN_ON_ONCE(stable_node->rmap_hlist_len >\n\t\t\t     ksm_max_page_sharing);\n\n\trmap_item->head = stable_node;\n\trmap_item->address |= STABLE_FLAG;\n\thlist_add_head(&rmap_item->hlist, &stable_node->hlist);\n\n\tif (rmap_item->hlist.next)\n\t\tksm_pages_sharing++;\n\telse\n\t\tksm_pages_shared++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_FLAG\t0x200\t/* is listed from the stable tree */",
            "#define STABLE_NODE_CHAIN -1024"
          ],
          "globals_used": [
            "static unsigned long ksm_pages_shared;",
            "static unsigned long ksm_pages_sharing;",
            "static int ksm_max_page_sharing = 256;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_FLAG\t0x200\t/* is listed from the stable tree */\n#define STABLE_NODE_CHAIN -1024\n\nstatic unsigned long ksm_pages_shared;\nstatic unsigned long ksm_pages_sharing;\nstatic int ksm_max_page_sharing = 256;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic void stable_tree_append(struct rmap_item *rmap_item,\n\t\t\t       struct stable_node *stable_node,\n\t\t\t       bool max_page_sharing_bypass)\n{\n\t/*\n\t * rmap won't find this mapping if we don't insert the\n\t * rmap_item in the right stable_node\n\t * duplicate. page_migration could break later if rmap breaks,\n\t * so we can as well crash here. We really need to check for\n\t * rmap_hlist_len == STABLE_NODE_CHAIN, but we can as well check\n\t * for other negative values as an undeflow if detected here\n\t * for the first time (and not when decreasing rmap_hlist_len)\n\t * would be sign of memory corruption in the stable_node.\n\t */\n\tBUG_ON(stable_node->rmap_hlist_len < 0);\n\n\tstable_node->rmap_hlist_len++;\n\tif (!max_page_sharing_bypass)\n\t\t/* possibly non fatal but unexpected overflow, only warn */\n\t\tWARN_ON_ONCE(stable_node->rmap_hlist_len >\n\t\t\t     ksm_max_page_sharing);\n\n\trmap_item->head = stable_node;\n\trmap_item->address |= STABLE_FLAG;\n\thlist_add_head(&rmap_item->hlist, &stable_node->hlist);\n\n\tif (rmap_item->hlist.next)\n\t\tksm_pages_sharing++;\n\telse\n\t\tksm_pages_shared++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stable_tree_insert",
          "args": [
            "kpage"
          ],
          "line": 2145
        },
        "resolved": true,
        "details": {
          "function_name": "stable_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1801-1903",
          "snippet": "static struct stable_node *stable_tree_insert(struct page *kpage)\n{\n\tint nid;\n\tunsigned long kpfn;\n\tstruct rb_root *root;\n\tstruct rb_node **new;\n\tstruct rb_node *parent;\n\tstruct stable_node *stable_node, *stable_node_dup, *stable_node_any;\n\tbool need_chain = false;\n\n\tkpfn = page_to_pfn(kpage);\n\tnid = get_kpfn_nid(kpfn);\n\troot = root_stable_tree + nid;\nagain:\n\tparent = NULL;\n\tnew = &root->rb_node;\n\n\twhile (*new) {\n\t\tstruct page *tree_page;\n\t\tint ret;\n\n\t\tcond_resched();\n\t\tstable_node = rb_entry(*new, struct stable_node, node);\n\t\tstable_node_any = NULL;\n\t\ttree_page = chain(&stable_node_dup, stable_node, root);\n\t\tif (!stable_node_dup) {\n\t\t\t/*\n\t\t\t * Either all stable_node dups were full in\n\t\t\t * this stable_node chain, or this chain was\n\t\t\t * empty and should be rb_erased.\n\t\t\t */\n\t\t\tstable_node_any = stable_node_dup_any(stable_node,\n\t\t\t\t\t\t\t      root);\n\t\t\tif (!stable_node_any) {\n\t\t\t\t/* rb_erase just run */\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Take any of the stable_node dups page of\n\t\t\t * this stable_node chain to let the tree walk\n\t\t\t * continue. All KSM pages belonging to the\n\t\t\t * stable_node dups in a stable_node chain\n\t\t\t * have the same content and they're\n\t\t\t * wrprotected at all times. Any will work\n\t\t\t * fine to continue the walk.\n\t\t\t */\n\t\t\ttree_page = get_ksm_page(stable_node_any, false);\n\t\t}\n\t\tVM_BUG_ON(!stable_node_dup ^ !!stable_node_any);\n\t\tif (!tree_page) {\n\t\t\t/*\n\t\t\t * If we walked over a stale stable_node,\n\t\t\t * get_ksm_page() will call rb_erase() and it\n\t\t\t * may rebalance the tree from under us. So\n\t\t\t * restart the search from scratch. Returning\n\t\t\t * NULL would be safe too, but we'd generate\n\t\t\t * false negative insertions just because some\n\t\t\t * stable_node was stale.\n\t\t\t */\n\t\t\tgoto again;\n\t\t}\n\n\t\tret = memcmp_pages(kpage, tree_page);\n\t\tput_page(tree_page);\n\n\t\tparent = *new;\n\t\tif (ret < 0)\n\t\t\tnew = &parent->rb_left;\n\t\telse if (ret > 0)\n\t\t\tnew = &parent->rb_right;\n\t\telse {\n\t\t\tneed_chain = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tstable_node_dup = alloc_stable_node();\n\tif (!stable_node_dup)\n\t\treturn NULL;\n\n\tINIT_HLIST_HEAD(&stable_node_dup->hlist);\n\tstable_node_dup->kpfn = kpfn;\n\tset_page_stable_node(kpage, stable_node_dup);\n\tstable_node_dup->rmap_hlist_len = 0;\n\tDO_NUMA(stable_node_dup->nid = nid);\n\tif (!need_chain) {\n\t\trb_link_node(&stable_node_dup->node, parent, new);\n\t\trb_insert_color(&stable_node_dup->node, root);\n\t} else {\n\t\tif (!is_stable_node_chain(stable_node)) {\n\t\t\tstruct stable_node *orig = stable_node;\n\t\t\t/* chain is missing so create it */\n\t\t\tstable_node = alloc_stable_node_chain(orig, root);\n\t\t\tif (!stable_node) {\n\t\t\t\tfree_stable_node(stable_node_dup);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tstable_node_chain_add_dup(stable_node_dup, stable_node);\n\t}\n\n\treturn stable_node_dup;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root *root_stable_tree = one_stable_tree;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct rb_root *root_stable_tree = one_stable_tree;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct stable_node *stable_tree_insert(struct page *kpage)\n{\n\tint nid;\n\tunsigned long kpfn;\n\tstruct rb_root *root;\n\tstruct rb_node **new;\n\tstruct rb_node *parent;\n\tstruct stable_node *stable_node, *stable_node_dup, *stable_node_any;\n\tbool need_chain = false;\n\n\tkpfn = page_to_pfn(kpage);\n\tnid = get_kpfn_nid(kpfn);\n\troot = root_stable_tree + nid;\nagain:\n\tparent = NULL;\n\tnew = &root->rb_node;\n\n\twhile (*new) {\n\t\tstruct page *tree_page;\n\t\tint ret;\n\n\t\tcond_resched();\n\t\tstable_node = rb_entry(*new, struct stable_node, node);\n\t\tstable_node_any = NULL;\n\t\ttree_page = chain(&stable_node_dup, stable_node, root);\n\t\tif (!stable_node_dup) {\n\t\t\t/*\n\t\t\t * Either all stable_node dups were full in\n\t\t\t * this stable_node chain, or this chain was\n\t\t\t * empty and should be rb_erased.\n\t\t\t */\n\t\t\tstable_node_any = stable_node_dup_any(stable_node,\n\t\t\t\t\t\t\t      root);\n\t\t\tif (!stable_node_any) {\n\t\t\t\t/* rb_erase just run */\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Take any of the stable_node dups page of\n\t\t\t * this stable_node chain to let the tree walk\n\t\t\t * continue. All KSM pages belonging to the\n\t\t\t * stable_node dups in a stable_node chain\n\t\t\t * have the same content and they're\n\t\t\t * wrprotected at all times. Any will work\n\t\t\t * fine to continue the walk.\n\t\t\t */\n\t\t\ttree_page = get_ksm_page(stable_node_any, false);\n\t\t}\n\t\tVM_BUG_ON(!stable_node_dup ^ !!stable_node_any);\n\t\tif (!tree_page) {\n\t\t\t/*\n\t\t\t * If we walked over a stale stable_node,\n\t\t\t * get_ksm_page() will call rb_erase() and it\n\t\t\t * may rebalance the tree from under us. So\n\t\t\t * restart the search from scratch. Returning\n\t\t\t * NULL would be safe too, but we'd generate\n\t\t\t * false negative insertions just because some\n\t\t\t * stable_node was stale.\n\t\t\t */\n\t\t\tgoto again;\n\t\t}\n\n\t\tret = memcmp_pages(kpage, tree_page);\n\t\tput_page(tree_page);\n\n\t\tparent = *new;\n\t\tif (ret < 0)\n\t\t\tnew = &parent->rb_left;\n\t\telse if (ret > 0)\n\t\t\tnew = &parent->rb_right;\n\t\telse {\n\t\t\tneed_chain = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tstable_node_dup = alloc_stable_node();\n\tif (!stable_node_dup)\n\t\treturn NULL;\n\n\tINIT_HLIST_HEAD(&stable_node_dup->hlist);\n\tstable_node_dup->kpfn = kpfn;\n\tset_page_stable_node(kpage, stable_node_dup);\n\tstable_node_dup->rmap_hlist_len = 0;\n\tDO_NUMA(stable_node_dup->nid = nid);\n\tif (!need_chain) {\n\t\trb_link_node(&stable_node_dup->node, parent, new);\n\t\trb_insert_color(&stable_node_dup->node, root);\n\t} else {\n\t\tif (!is_stable_node_chain(stable_node)) {\n\t\t\tstruct stable_node *orig = stable_node;\n\t\t\t/* chain is missing so create it */\n\t\t\tstable_node = alloc_stable_node_chain(orig, root);\n\t\t\tif (!stable_node) {\n\t\t\t\tfree_stable_node(stable_node_dup);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tstable_node_chain_add_dup(stable_node_dup, stable_node);\n\t}\n\n\treturn stable_node_dup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "tree_page"
          ],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "tree_page"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "page"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_merge_two_pages",
          "args": [
            "rmap_item",
            "page",
            "tree_rmap_item",
            "tree_page"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_merge_two_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1317-1336",
          "snippet": "static struct page *try_to_merge_two_pages(struct rmap_item *rmap_item,\n\t\t\t\t\t   struct page *page,\n\t\t\t\t\t   struct rmap_item *tree_rmap_item,\n\t\t\t\t\t   struct page *tree_page)\n{\n\tint err;\n\n\terr = try_to_merge_with_ksm_page(rmap_item, page, NULL);\n\tif (!err) {\n\t\terr = try_to_merge_with_ksm_page(tree_rmap_item,\n\t\t\t\t\t\t\ttree_page, page);\n\t\t/*\n\t\t * If that fails, we have a ksm page with only one pte\n\t\t * pointing to it: so break it.\n\t\t */\n\t\tif (err)\n\t\t\tbreak_cow(rmap_item);\n\t}\n\treturn err ? NULL : page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct page *try_to_merge_two_pages(struct rmap_item *rmap_item,\n\t\t\t\t\t   struct page *page,\n\t\t\t\t\t   struct rmap_item *tree_rmap_item,\n\t\t\t\t\t   struct page *tree_page)\n{\n\tint err;\n\n\terr = try_to_merge_with_ksm_page(rmap_item, page, NULL);\n\tif (!err) {\n\t\terr = try_to_merge_with_ksm_page(tree_rmap_item,\n\t\t\t\t\t\t\ttree_page, page);\n\t\t/*\n\t\t * If that fails, we have a ksm page with only one pte\n\t\t * pointing to it: so break it.\n\t\t */\n\t\tif (err)\n\t\t\tbreak_cow(rmap_item);\n\t}\n\treturn err ? NULL : page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unstable_tree_search_insert",
          "args": [
            "rmap_item",
            "page",
            "&tree_page"
          ],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "unstable_tree_search_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1919-1984",
          "snippet": "static\nstruct rmap_item *unstable_tree_search_insert(struct rmap_item *rmap_item,\n\t\t\t\t\t      struct page *page,\n\t\t\t\t\t      struct page **tree_pagep)\n{\n\tstruct rb_node **new;\n\tstruct rb_root *root;\n\tstruct rb_node *parent = NULL;\n\tint nid;\n\n\tnid = get_kpfn_nid(page_to_pfn(page));\n\troot = root_unstable_tree + nid;\n\tnew = &root->rb_node;\n\n\twhile (*new) {\n\t\tstruct rmap_item *tree_rmap_item;\n\t\tstruct page *tree_page;\n\t\tint ret;\n\n\t\tcond_resched();\n\t\ttree_rmap_item = rb_entry(*new, struct rmap_item, node);\n\t\ttree_page = get_mergeable_page(tree_rmap_item);\n\t\tif (!tree_page)\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * Don't substitute a ksm page for a forked page.\n\t\t */\n\t\tif (page == tree_page) {\n\t\t\tput_page(tree_page);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tret = memcmp_pages(page, tree_page);\n\n\t\tparent = *new;\n\t\tif (ret < 0) {\n\t\t\tput_page(tree_page);\n\t\t\tnew = &parent->rb_left;\n\t\t} else if (ret > 0) {\n\t\t\tput_page(tree_page);\n\t\t\tnew = &parent->rb_right;\n\t\t} else if (!ksm_merge_across_nodes &&\n\t\t\t   page_to_nid(tree_page) != nid) {\n\t\t\t/*\n\t\t\t * If tree_page has been migrated to another NUMA node,\n\t\t\t * it will be flushed out and put in the right unstable\n\t\t\t * tree next time: only merge with it when across_nodes.\n\t\t\t */\n\t\t\tput_page(tree_page);\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\t*tree_pagep = tree_page;\n\t\t\treturn tree_rmap_item;\n\t\t}\n\t}\n\n\trmap_item->address |= UNSTABLE_FLAG;\n\trmap_item->address |= (ksm_scan.seqnr & SEQNR_MASK);\n\tDO_NUMA(rmap_item->nid = nid);\n\trb_link_node(&rmap_item->node, parent, new);\n\trb_insert_color(&rmap_item->node, root);\n\n\tksm_pages_unshared++;\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define ksm_merge_across_nodes\t1U",
            "#define UNSTABLE_FLAG\t0x100\t/* is a node of the unstable tree */",
            "#define SEQNR_MASK\t0x0ff\t/* low bits of unstable tree seqnr */"
          ],
          "globals_used": [
            "static struct rb_root *root_unstable_tree = one_unstable_tree;",
            "static struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};",
            "static unsigned long ksm_pages_unshared;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define ksm_merge_across_nodes\t1U\n#define UNSTABLE_FLAG\t0x100\t/* is a node of the unstable tree */\n#define SEQNR_MASK\t0x0ff\t/* low bits of unstable tree seqnr */\n\nstatic struct rb_root *root_unstable_tree = one_unstable_tree;\nstatic struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};\nstatic unsigned long ksm_pages_unshared;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic\nstruct rmap_item *unstable_tree_search_insert(struct rmap_item *rmap_item,\n\t\t\t\t\t      struct page *page,\n\t\t\t\t\t      struct page **tree_pagep)\n{\n\tstruct rb_node **new;\n\tstruct rb_root *root;\n\tstruct rb_node *parent = NULL;\n\tint nid;\n\n\tnid = get_kpfn_nid(page_to_pfn(page));\n\troot = root_unstable_tree + nid;\n\tnew = &root->rb_node;\n\n\twhile (*new) {\n\t\tstruct rmap_item *tree_rmap_item;\n\t\tstruct page *tree_page;\n\t\tint ret;\n\n\t\tcond_resched();\n\t\ttree_rmap_item = rb_entry(*new, struct rmap_item, node);\n\t\ttree_page = get_mergeable_page(tree_rmap_item);\n\t\tif (!tree_page)\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * Don't substitute a ksm page for a forked page.\n\t\t */\n\t\tif (page == tree_page) {\n\t\t\tput_page(tree_page);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tret = memcmp_pages(page, tree_page);\n\n\t\tparent = *new;\n\t\tif (ret < 0) {\n\t\t\tput_page(tree_page);\n\t\t\tnew = &parent->rb_left;\n\t\t} else if (ret > 0) {\n\t\t\tput_page(tree_page);\n\t\t\tnew = &parent->rb_right;\n\t\t} else if (!ksm_merge_across_nodes &&\n\t\t\t   page_to_nid(tree_page) != nid) {\n\t\t\t/*\n\t\t\t * If tree_page has been migrated to another NUMA node,\n\t\t\t * it will be flushed out and put in the right unstable\n\t\t\t * tree next time: only merge with it when across_nodes.\n\t\t\t */\n\t\t\tput_page(tree_page);\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\t*tree_pagep = tree_page;\n\t\t\treturn tree_rmap_item;\n\t\t}\n\t}\n\n\trmap_item->address |= UNSTABLE_FLAG;\n\trmap_item->address |= (ksm_scan.seqnr & SEQNR_MASK);\n\tDO_NUMA(rmap_item->nid = nid);\n\trb_link_node(&rmap_item->node, parent, new);\n\trb_insert_color(&rmap_item->node, root);\n\n\tksm_pages_unshared++;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_merge_one_page",
          "args": [
            "vma",
            "page",
            "ZERO_PAGE(rmap_item->address)"
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_merge_one_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1205-1272",
          "snippet": "static int try_to_merge_one_page(struct vm_area_struct *vma,\n\t\t\t\t struct page *page, struct page *kpage)\n{\n\tpte_t orig_pte = __pte(0);\n\tint err = -EFAULT;\n\n\tif (page == kpage)\t\t\t/* ksm page forked */\n\t\treturn 0;\n\n\tif (!PageAnon(page))\n\t\tgoto out;\n\n\t/*\n\t * We need the page lock to read a stable PageSwapCache in\n\t * write_protect_page().  We use trylock_page() instead of\n\t * lock_page() because we don't want to wait here - we\n\t * prefer to continue scanning and merging different pages,\n\t * then come back to this page when it is unlocked.\n\t */\n\tif (!trylock_page(page))\n\t\tgoto out;\n\n\tif (PageTransCompound(page)) {\n\t\tif (split_huge_page(page))\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * If this anonymous page is mapped only here, its pte may need\n\t * to be write-protected.  If it's mapped elsewhere, all of its\n\t * ptes are necessarily already write-protected.  But in either\n\t * case, we need to lock and check page_count is not raised.\n\t */\n\tif (write_protect_page(vma, page, &orig_pte) == 0) {\n\t\tif (!kpage) {\n\t\t\t/*\n\t\t\t * While we hold page lock, upgrade page from\n\t\t\t * PageAnon+anon_vma to PageKsm+NULL stable_node:\n\t\t\t * stable_tree_insert() will update stable_node.\n\t\t\t */\n\t\t\tset_page_stable_node(page, NULL);\n\t\t\tmark_page_accessed(page);\n\t\t\t/*\n\t\t\t * Page reclaim just frees a clean page with no dirty\n\t\t\t * ptes: make sure that the ksm page would be swapped.\n\t\t\t */\n\t\t\tif (!PageDirty(page))\n\t\t\t\tSetPageDirty(page);\n\t\t\terr = 0;\n\t\t} else if (pages_identical(page, kpage))\n\t\t\terr = replace_page(vma, page, kpage, orig_pte);\n\t}\n\n\tif ((vma->vm_flags & VM_LOCKED) && kpage && !err) {\n\t\tmunlock_vma_page(page);\n\t\tif (!PageMlocked(kpage)) {\n\t\t\tunlock_page(page);\n\t\t\tlock_page(kpage);\n\t\t\tmlock_vma_page(kpage);\n\t\t\tpage = kpage;\t\t/* for final unlock */\n\t\t}\n\t}\n\nout_unlock:\n\tunlock_page(page);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int try_to_merge_one_page(struct vm_area_struct *vma,\n\t\t\t\t struct page *page, struct page *kpage)\n{\n\tpte_t orig_pte = __pte(0);\n\tint err = -EFAULT;\n\n\tif (page == kpage)\t\t\t/* ksm page forked */\n\t\treturn 0;\n\n\tif (!PageAnon(page))\n\t\tgoto out;\n\n\t/*\n\t * We need the page lock to read a stable PageSwapCache in\n\t * write_protect_page().  We use trylock_page() instead of\n\t * lock_page() because we don't want to wait here - we\n\t * prefer to continue scanning and merging different pages,\n\t * then come back to this page when it is unlocked.\n\t */\n\tif (!trylock_page(page))\n\t\tgoto out;\n\n\tif (PageTransCompound(page)) {\n\t\tif (split_huge_page(page))\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * If this anonymous page is mapped only here, its pte may need\n\t * to be write-protected.  If it's mapped elsewhere, all of its\n\t * ptes are necessarily already write-protected.  But in either\n\t * case, we need to lock and check page_count is not raised.\n\t */\n\tif (write_protect_page(vma, page, &orig_pte) == 0) {\n\t\tif (!kpage) {\n\t\t\t/*\n\t\t\t * While we hold page lock, upgrade page from\n\t\t\t * PageAnon+anon_vma to PageKsm+NULL stable_node:\n\t\t\t * stable_tree_insert() will update stable_node.\n\t\t\t */\n\t\t\tset_page_stable_node(page, NULL);\n\t\t\tmark_page_accessed(page);\n\t\t\t/*\n\t\t\t * Page reclaim just frees a clean page with no dirty\n\t\t\t * ptes: make sure that the ksm page would be swapped.\n\t\t\t */\n\t\t\tif (!PageDirty(page))\n\t\t\t\tSetPageDirty(page);\n\t\t\terr = 0;\n\t\t} else if (pages_identical(page, kpage))\n\t\t\terr = replace_page(vma, page, kpage, orig_pte);\n\t}\n\n\tif ((vma->vm_flags & VM_LOCKED) && kpage && !err) {\n\t\tmunlock_vma_page(page);\n\t\tif (!PageMlocked(kpage)) {\n\t\t\tunlock_page(page);\n\t\t\tlock_page(kpage);\n\t\t\tmlock_vma_page(kpage);\n\t\t\tpage = kpage;\t\t/* for final unlock */\n\t\t}\n\t}\n\nout_unlock:\n\tunlock_page(page);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ZERO_PAGE",
          "args": [
            "rmap_item->address"
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_mergeable_vma",
          "args": [
            "mm",
            "rmap_item->address"
          ],
          "line": 2108
        },
        "resolved": true,
        "details": {
          "function_name": "find_mergeable_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "519-531",
          "snippet": "static struct vm_area_struct *find_mergeable_vma(struct mm_struct *mm,\n\t\tunsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\tif (ksm_test_exit(mm))\n\t\treturn NULL;\n\tvma = find_vma(mm, addr);\n\tif (!vma || vma->vm_start > addr)\n\t\treturn NULL;\n\tif (!(vma->vm_flags & VM_MERGEABLE) || !vma->anon_vma)\n\t\treturn NULL;\n\treturn vma;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct vm_area_struct *find_mergeable_vma(struct mm_struct *mm,\n\t\tunsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\tif (ksm_test_exit(mm))\n\t\treturn NULL;\n\tvma = find_vma(mm, addr);\n\tif (!vma || vma->vm_start > addr)\n\t\treturn NULL;\n\tif (!(vma->vm_flags & VM_MERGEABLE) || !vma->anon_vma)\n\t\treturn NULL;\n\treturn vma;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_checksum",
          "args": [
            "page"
          ],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "calc_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1008-1015",
          "snippet": "static u32 calc_checksum(struct page *page)\n{\n\tu32 checksum;\n\tvoid *addr = kmap_atomic(page);\n\tchecksum = jhash2(addr, PAGE_SIZE / 4, 17);\n\tkunmap_atomic(addr);\n\treturn checksum;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic u32 calc_checksum(struct page *page)\n{\n\tu32 checksum;\n\tvoid *addr = kmap_atomic(page);\n\tchecksum = jhash2(addr, PAGE_SIZE / 4, 17);\n\tkunmap_atomic(addr);\n\treturn checksum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_stable_node",
          "args": [
            "kpage"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "page_stable_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "845-848",
          "snippet": "static inline struct stable_node *page_stable_node(struct page *page)\n{\n\treturn PageKsm(page) ? page_rmapping(page) : NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline struct stable_node *page_stable_node(struct page *page)\n{\n\treturn PageKsm(page) ? page_rmapping(page) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_merge_with_ksm_page",
          "args": [
            "rmap_item",
            "page",
            "kpage"
          ],
          "line": 2073
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_merge_with_ksm_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1280-1305",
          "snippet": "static int try_to_merge_with_ksm_page(struct rmap_item *rmap_item,\n\t\t\t\t      struct page *page, struct page *kpage)\n{\n\tstruct mm_struct *mm = rmap_item->mm;\n\tstruct vm_area_struct *vma;\n\tint err = -EFAULT;\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_mergeable_vma(mm, rmap_item->address);\n\tif (!vma)\n\t\tgoto out;\n\n\terr = try_to_merge_one_page(vma, page, kpage);\n\tif (err)\n\t\tgoto out;\n\n\t/* Unstable nid is in union with stable anon_vma: remove first */\n\tremove_rmap_item_from_tree(rmap_item);\n\n\t/* Must get reference to anon_vma while still holding mmap_sem */\n\trmap_item->anon_vma = vma->anon_vma;\n\tget_anon_vma(vma->anon_vma);\nout:\n\tup_read(&mm->mmap_sem);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int try_to_merge_with_ksm_page(struct rmap_item *rmap_item,\n\t\t\t\t      struct page *page, struct page *kpage)\n{\n\tstruct mm_struct *mm = rmap_item->mm;\n\tstruct vm_area_struct *vma;\n\tint err = -EFAULT;\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_mergeable_vma(mm, rmap_item->address);\n\tif (!vma)\n\t\tgoto out;\n\n\terr = try_to_merge_one_page(vma, page, kpage);\n\tif (err)\n\t\tgoto out;\n\n\t/* Unstable nid is in union with stable anon_vma: remove first */\n\tremove_rmap_item_from_tree(rmap_item);\n\n\t/* Must get reference to anon_vma while still holding mmap_sem */\n\trmap_item->anon_vma = vma->anon_vma;\n\tget_anon_vma(vma->anon_vma);\nout:\n\tup_read(&mm->mmap_sem);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_rmap_item_from_tree",
          "args": [
            "rmap_item"
          ],
          "line": 2070
        },
        "resolved": true,
        "details": {
          "function_name": "remove_rmap_item_from_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "758-802",
          "snippet": "static void remove_rmap_item_from_tree(struct rmap_item *rmap_item)\n{\n\tif (rmap_item->address & STABLE_FLAG) {\n\t\tstruct stable_node *stable_node;\n\t\tstruct page *page;\n\n\t\tstable_node = rmap_item->head;\n\t\tpage = get_ksm_page(stable_node, true);\n\t\tif (!page)\n\t\t\tgoto out;\n\n\t\thlist_del(&rmap_item->hlist);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (!hlist_empty(&stable_node->hlist))\n\t\t\tksm_pages_sharing--;\n\t\telse\n\t\t\tksm_pages_shared--;\n\t\tVM_BUG_ON(stable_node->rmap_hlist_len <= 0);\n\t\tstable_node->rmap_hlist_len--;\n\n\t\tput_anon_vma(rmap_item->anon_vma);\n\t\trmap_item->address &= PAGE_MASK;\n\n\t} else if (rmap_item->address & UNSTABLE_FLAG) {\n\t\tunsigned char age;\n\t\t/*\n\t\t * Usually ksmd can and must skip the rb_erase, because\n\t\t * root_unstable_tree was already reset to RB_ROOT.\n\t\t * But be careful when an mm is exiting: do the rb_erase\n\t\t * if this rmap_item was inserted by this scan, rather\n\t\t * than left over from before.\n\t\t */\n\t\tage = (unsigned char)(ksm_scan.seqnr - rmap_item->address);\n\t\tBUG_ON(age > 1);\n\t\tif (!age)\n\t\t\trb_erase(&rmap_item->node,\n\t\t\t\t root_unstable_tree + NUMA(rmap_item->nid));\n\t\tksm_pages_unshared--;\n\t\trmap_item->address &= PAGE_MASK;\n\t}\nout:\n\tcond_resched();\t\t/* we're called from many long loops */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_FLAG\t0x200\t/* is listed from the stable tree */",
            "#define UNSTABLE_FLAG\t0x100\t/* is a node of the unstable tree */"
          ],
          "globals_used": [
            "static struct rb_root *root_unstable_tree = one_unstable_tree;",
            "static struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};",
            "static unsigned long ksm_pages_shared;",
            "static unsigned long ksm_pages_sharing;",
            "static unsigned long ksm_pages_unshared;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_FLAG\t0x200\t/* is listed from the stable tree */\n#define UNSTABLE_FLAG\t0x100\t/* is a node of the unstable tree */\n\nstatic struct rb_root *root_unstable_tree = one_unstable_tree;\nstatic struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};\nstatic unsigned long ksm_pages_shared;\nstatic unsigned long ksm_pages_sharing;\nstatic unsigned long ksm_pages_unshared;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic void remove_rmap_item_from_tree(struct rmap_item *rmap_item)\n{\n\tif (rmap_item->address & STABLE_FLAG) {\n\t\tstruct stable_node *stable_node;\n\t\tstruct page *page;\n\n\t\tstable_node = rmap_item->head;\n\t\tpage = get_ksm_page(stable_node, true);\n\t\tif (!page)\n\t\t\tgoto out;\n\n\t\thlist_del(&rmap_item->hlist);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (!hlist_empty(&stable_node->hlist))\n\t\t\tksm_pages_sharing--;\n\t\telse\n\t\t\tksm_pages_shared--;\n\t\tVM_BUG_ON(stable_node->rmap_hlist_len <= 0);\n\t\tstable_node->rmap_hlist_len--;\n\n\t\tput_anon_vma(rmap_item->anon_vma);\n\t\trmap_item->address &= PAGE_MASK;\n\n\t} else if (rmap_item->address & UNSTABLE_FLAG) {\n\t\tunsigned char age;\n\t\t/*\n\t\t * Usually ksmd can and must skip the rb_erase, because\n\t\t * root_unstable_tree was already reset to RB_ROOT.\n\t\t * But be careful when an mm is exiting: do the rb_erase\n\t\t * if this rmap_item was inserted by this scan, rather\n\t\t * than left over from before.\n\t\t */\n\t\tage = (unsigned char)(ksm_scan.seqnr - rmap_item->address);\n\t\tBUG_ON(age > 1);\n\t\tif (!age)\n\t\t\trb_erase(&rmap_item->node,\n\t\t\t\t root_unstable_tree + NUMA(rmap_item->nid));\n\t\tksm_pages_unshared--;\n\t\trmap_item->address &= PAGE_MASK;\n\t}\nout:\n\tcond_resched();\t\t/* we're called from many long loops */\n}"
        }
      },
      {
        "call_info": {
          "callee": "stable_tree_search",
          "args": [
            "page"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "stable_tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1555-1792",
          "snippet": "static struct page *stable_tree_search(struct page *page)\n{\n\tint nid;\n\tstruct rb_root *root;\n\tstruct rb_node **new;\n\tstruct rb_node *parent;\n\tstruct stable_node *stable_node, *stable_node_dup, *stable_node_any;\n\tstruct stable_node *page_node;\n\n\tpage_node = page_stable_node(page);\n\tif (page_node && page_node->head != &migrate_nodes) {\n\t\t/* ksm page forked */\n\t\tget_page(page);\n\t\treturn page;\n\t}\n\n\tnid = get_kpfn_nid(page_to_pfn(page));\n\troot = root_stable_tree + nid;\nagain:\n\tnew = &root->rb_node;\n\tparent = NULL;\n\n\twhile (*new) {\n\t\tstruct page *tree_page;\n\t\tint ret;\n\n\t\tcond_resched();\n\t\tstable_node = rb_entry(*new, struct stable_node, node);\n\t\tstable_node_any = NULL;\n\t\ttree_page = chain_prune(&stable_node_dup, &stable_node,\troot);\n\t\t/*\n\t\t * NOTE: stable_node may have been freed by\n\t\t * chain_prune() if the returned stable_node_dup is\n\t\t * not NULL. stable_node_dup may have been inserted in\n\t\t * the rbtree instead as a regular stable_node (in\n\t\t * order to collapse the stable_node chain if a single\n\t\t * stable_node dup was found in it). In such case the\n\t\t * stable_node is overwritten by the calleee to point\n\t\t * to the stable_node_dup that was collapsed in the\n\t\t * stable rbtree and stable_node will be equal to\n\t\t * stable_node_dup like if the chain never existed.\n\t\t */\n\t\tif (!stable_node_dup) {\n\t\t\t/*\n\t\t\t * Either all stable_node dups were full in\n\t\t\t * this stable_node chain, or this chain was\n\t\t\t * empty and should be rb_erased.\n\t\t\t */\n\t\t\tstable_node_any = stable_node_dup_any(stable_node,\n\t\t\t\t\t\t\t      root);\n\t\t\tif (!stable_node_any) {\n\t\t\t\t/* rb_erase just run */\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Take any of the stable_node dups page of\n\t\t\t * this stable_node chain to let the tree walk\n\t\t\t * continue. All KSM pages belonging to the\n\t\t\t * stable_node dups in a stable_node chain\n\t\t\t * have the same content and they're\n\t\t\t * wrprotected at all times. Any will work\n\t\t\t * fine to continue the walk.\n\t\t\t */\n\t\t\ttree_page = get_ksm_page(stable_node_any, false);\n\t\t}\n\t\tVM_BUG_ON(!stable_node_dup ^ !!stable_node_any);\n\t\tif (!tree_page) {\n\t\t\t/*\n\t\t\t * If we walked over a stale stable_node,\n\t\t\t * get_ksm_page() will call rb_erase() and it\n\t\t\t * may rebalance the tree from under us. So\n\t\t\t * restart the search from scratch. Returning\n\t\t\t * NULL would be safe too, but we'd generate\n\t\t\t * false negative insertions just because some\n\t\t\t * stable_node was stale.\n\t\t\t */\n\t\t\tgoto again;\n\t\t}\n\n\t\tret = memcmp_pages(page, tree_page);\n\t\tput_page(tree_page);\n\n\t\tparent = *new;\n\t\tif (ret < 0)\n\t\t\tnew = &parent->rb_left;\n\t\telse if (ret > 0)\n\t\t\tnew = &parent->rb_right;\n\t\telse {\n\t\t\tif (page_node) {\n\t\t\t\tVM_BUG_ON(page_node->head != &migrate_nodes);\n\t\t\t\t/*\n\t\t\t\t * Test if the migrated page should be merged\n\t\t\t\t * into a stable node dup. If the mapcount is\n\t\t\t\t * 1 we can migrate it with another KSM page\n\t\t\t\t * without adding it to the chain.\n\t\t\t\t */\n\t\t\t\tif (page_mapcount(page) > 1)\n\t\t\t\t\tgoto chain_append;\n\t\t\t}\n\n\t\t\tif (!stable_node_dup) {\n\t\t\t\t/*\n\t\t\t\t * If the stable_node is a chain and\n\t\t\t\t * we got a payload match in memcmp\n\t\t\t\t * but we cannot merge the scanned\n\t\t\t\t * page in any of the existing\n\t\t\t\t * stable_node dups because they're\n\t\t\t\t * all full, we need to wait the\n\t\t\t\t * scanned page to find itself a match\n\t\t\t\t * in the unstable tree to create a\n\t\t\t\t * brand new KSM page to add later to\n\t\t\t\t * the dups of this stable_node.\n\t\t\t\t */\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Lock and unlock the stable_node's page (which\n\t\t\t * might already have been migrated) so that page\n\t\t\t * migration is sure to notice its raised count.\n\t\t\t * It would be more elegant to return stable_node\n\t\t\t * than kpage, but that involves more changes.\n\t\t\t */\n\t\t\ttree_page = get_ksm_page(stable_node_dup, true);\n\t\t\tif (unlikely(!tree_page))\n\t\t\t\t/*\n\t\t\t\t * The tree may have been rebalanced,\n\t\t\t\t * so re-evaluate parent and new.\n\t\t\t\t */\n\t\t\t\tgoto again;\n\t\t\tunlock_page(tree_page);\n\n\t\t\tif (get_kpfn_nid(stable_node_dup->kpfn) !=\n\t\t\t    NUMA(stable_node_dup->nid)) {\n\t\t\t\tput_page(tree_page);\n\t\t\t\tgoto replace;\n\t\t\t}\n\t\t\treturn tree_page;\n\t\t}\n\t}\n\n\tif (!page_node)\n\t\treturn NULL;\n\n\tlist_del(&page_node->list);\n\tDO_NUMA(page_node->nid = nid);\n\trb_link_node(&page_node->node, parent, new);\n\trb_insert_color(&page_node->node, root);\nout:\n\tif (is_page_sharing_candidate(page_node)) {\n\t\tget_page(page);\n\t\treturn page;\n\t} else\n\t\treturn NULL;\n\nreplace:\n\t/*\n\t * If stable_node was a chain and chain_prune collapsed it,\n\t * stable_node has been updated to be the new regular\n\t * stable_node. A collapse of the chain is indistinguishable\n\t * from the case there was no chain in the stable\n\t * rbtree. Otherwise stable_node is the chain and\n\t * stable_node_dup is the dup to replace.\n\t */\n\tif (stable_node_dup == stable_node) {\n\t\tVM_BUG_ON(is_stable_node_chain(stable_node_dup));\n\t\tVM_BUG_ON(is_stable_node_dup(stable_node_dup));\n\t\t/* there is no chain */\n\t\tif (page_node) {\n\t\t\tVM_BUG_ON(page_node->head != &migrate_nodes);\n\t\t\tlist_del(&page_node->list);\n\t\t\tDO_NUMA(page_node->nid = nid);\n\t\t\trb_replace_node(&stable_node_dup->node,\n\t\t\t\t\t&page_node->node,\n\t\t\t\t\troot);\n\t\t\tif (is_page_sharing_candidate(page_node))\n\t\t\t\tget_page(page);\n\t\t\telse\n\t\t\t\tpage = NULL;\n\t\t} else {\n\t\t\trb_erase(&stable_node_dup->node, root);\n\t\t\tpage = NULL;\n\t\t}\n\t} else {\n\t\tVM_BUG_ON(!is_stable_node_chain(stable_node));\n\t\t__stable_node_dup_del(stable_node_dup);\n\t\tif (page_node) {\n\t\t\tVM_BUG_ON(page_node->head != &migrate_nodes);\n\t\t\tlist_del(&page_node->list);\n\t\t\tDO_NUMA(page_node->nid = nid);\n\t\t\tstable_node_chain_add_dup(page_node, stable_node);\n\t\t\tif (is_page_sharing_candidate(page_node))\n\t\t\t\tget_page(page);\n\t\t\telse\n\t\t\t\tpage = NULL;\n\t\t} else {\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\tstable_node_dup->head = &migrate_nodes;\n\tlist_add(&stable_node_dup->list, stable_node_dup->head);\n\treturn page;\n\nchain_append:\n\t/* stable_node_dup could be null if it reached the limit */\n\tif (!stable_node_dup)\n\t\tstable_node_dup = stable_node_any;\n\t/*\n\t * If stable_node was a chain and chain_prune collapsed it,\n\t * stable_node has been updated to be the new regular\n\t * stable_node. A collapse of the chain is indistinguishable\n\t * from the case there was no chain in the stable\n\t * rbtree. Otherwise stable_node is the chain and\n\t * stable_node_dup is the dup to replace.\n\t */\n\tif (stable_node_dup == stable_node) {\n\t\tVM_BUG_ON(is_stable_node_chain(stable_node_dup));\n\t\tVM_BUG_ON(is_stable_node_dup(stable_node_dup));\n\t\t/* chain is missing so create it */\n\t\tstable_node = alloc_stable_node_chain(stable_node_dup,\n\t\t\t\t\t\t      root);\n\t\tif (!stable_node)\n\t\t\treturn NULL;\n\t}\n\t/*\n\t * Add this stable_node dup that was\n\t * migrated to the stable_node chain\n\t * of the current nid for this page\n\t * content.\n\t */\n\tVM_BUG_ON(!is_stable_node_chain(stable_node));\n\tVM_BUG_ON(!is_stable_node_dup(stable_node_dup));\n\tVM_BUG_ON(page_node->head != &migrate_nodes);\n\tlist_del(&page_node->list);\n\tDO_NUMA(page_node->nid = nid);\n\tstable_node_chain_add_dup(page_node, stable_node);\n\tgoto out;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root *root_stable_tree = one_stable_tree;",
            "static LIST_HEAD(migrate_nodes);",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct rb_root *root_stable_tree = one_stable_tree;\nstatic LIST_HEAD(migrate_nodes);\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct page *stable_tree_search(struct page *page)\n{\n\tint nid;\n\tstruct rb_root *root;\n\tstruct rb_node **new;\n\tstruct rb_node *parent;\n\tstruct stable_node *stable_node, *stable_node_dup, *stable_node_any;\n\tstruct stable_node *page_node;\n\n\tpage_node = page_stable_node(page);\n\tif (page_node && page_node->head != &migrate_nodes) {\n\t\t/* ksm page forked */\n\t\tget_page(page);\n\t\treturn page;\n\t}\n\n\tnid = get_kpfn_nid(page_to_pfn(page));\n\troot = root_stable_tree + nid;\nagain:\n\tnew = &root->rb_node;\n\tparent = NULL;\n\n\twhile (*new) {\n\t\tstruct page *tree_page;\n\t\tint ret;\n\n\t\tcond_resched();\n\t\tstable_node = rb_entry(*new, struct stable_node, node);\n\t\tstable_node_any = NULL;\n\t\ttree_page = chain_prune(&stable_node_dup, &stable_node,\troot);\n\t\t/*\n\t\t * NOTE: stable_node may have been freed by\n\t\t * chain_prune() if the returned stable_node_dup is\n\t\t * not NULL. stable_node_dup may have been inserted in\n\t\t * the rbtree instead as a regular stable_node (in\n\t\t * order to collapse the stable_node chain if a single\n\t\t * stable_node dup was found in it). In such case the\n\t\t * stable_node is overwritten by the calleee to point\n\t\t * to the stable_node_dup that was collapsed in the\n\t\t * stable rbtree and stable_node will be equal to\n\t\t * stable_node_dup like if the chain never existed.\n\t\t */\n\t\tif (!stable_node_dup) {\n\t\t\t/*\n\t\t\t * Either all stable_node dups were full in\n\t\t\t * this stable_node chain, or this chain was\n\t\t\t * empty and should be rb_erased.\n\t\t\t */\n\t\t\tstable_node_any = stable_node_dup_any(stable_node,\n\t\t\t\t\t\t\t      root);\n\t\t\tif (!stable_node_any) {\n\t\t\t\t/* rb_erase just run */\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Take any of the stable_node dups page of\n\t\t\t * this stable_node chain to let the tree walk\n\t\t\t * continue. All KSM pages belonging to the\n\t\t\t * stable_node dups in a stable_node chain\n\t\t\t * have the same content and they're\n\t\t\t * wrprotected at all times. Any will work\n\t\t\t * fine to continue the walk.\n\t\t\t */\n\t\t\ttree_page = get_ksm_page(stable_node_any, false);\n\t\t}\n\t\tVM_BUG_ON(!stable_node_dup ^ !!stable_node_any);\n\t\tif (!tree_page) {\n\t\t\t/*\n\t\t\t * If we walked over a stale stable_node,\n\t\t\t * get_ksm_page() will call rb_erase() and it\n\t\t\t * may rebalance the tree from under us. So\n\t\t\t * restart the search from scratch. Returning\n\t\t\t * NULL would be safe too, but we'd generate\n\t\t\t * false negative insertions just because some\n\t\t\t * stable_node was stale.\n\t\t\t */\n\t\t\tgoto again;\n\t\t}\n\n\t\tret = memcmp_pages(page, tree_page);\n\t\tput_page(tree_page);\n\n\t\tparent = *new;\n\t\tif (ret < 0)\n\t\t\tnew = &parent->rb_left;\n\t\telse if (ret > 0)\n\t\t\tnew = &parent->rb_right;\n\t\telse {\n\t\t\tif (page_node) {\n\t\t\t\tVM_BUG_ON(page_node->head != &migrate_nodes);\n\t\t\t\t/*\n\t\t\t\t * Test if the migrated page should be merged\n\t\t\t\t * into a stable node dup. If the mapcount is\n\t\t\t\t * 1 we can migrate it with another KSM page\n\t\t\t\t * without adding it to the chain.\n\t\t\t\t */\n\t\t\t\tif (page_mapcount(page) > 1)\n\t\t\t\t\tgoto chain_append;\n\t\t\t}\n\n\t\t\tif (!stable_node_dup) {\n\t\t\t\t/*\n\t\t\t\t * If the stable_node is a chain and\n\t\t\t\t * we got a payload match in memcmp\n\t\t\t\t * but we cannot merge the scanned\n\t\t\t\t * page in any of the existing\n\t\t\t\t * stable_node dups because they're\n\t\t\t\t * all full, we need to wait the\n\t\t\t\t * scanned page to find itself a match\n\t\t\t\t * in the unstable tree to create a\n\t\t\t\t * brand new KSM page to add later to\n\t\t\t\t * the dups of this stable_node.\n\t\t\t\t */\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Lock and unlock the stable_node's page (which\n\t\t\t * might already have been migrated) so that page\n\t\t\t * migration is sure to notice its raised count.\n\t\t\t * It would be more elegant to return stable_node\n\t\t\t * than kpage, but that involves more changes.\n\t\t\t */\n\t\t\ttree_page = get_ksm_page(stable_node_dup, true);\n\t\t\tif (unlikely(!tree_page))\n\t\t\t\t/*\n\t\t\t\t * The tree may have been rebalanced,\n\t\t\t\t * so re-evaluate parent and new.\n\t\t\t\t */\n\t\t\t\tgoto again;\n\t\t\tunlock_page(tree_page);\n\n\t\t\tif (get_kpfn_nid(stable_node_dup->kpfn) !=\n\t\t\t    NUMA(stable_node_dup->nid)) {\n\t\t\t\tput_page(tree_page);\n\t\t\t\tgoto replace;\n\t\t\t}\n\t\t\treturn tree_page;\n\t\t}\n\t}\n\n\tif (!page_node)\n\t\treturn NULL;\n\n\tlist_del(&page_node->list);\n\tDO_NUMA(page_node->nid = nid);\n\trb_link_node(&page_node->node, parent, new);\n\trb_insert_color(&page_node->node, root);\nout:\n\tif (is_page_sharing_candidate(page_node)) {\n\t\tget_page(page);\n\t\treturn page;\n\t} else\n\t\treturn NULL;\n\nreplace:\n\t/*\n\t * If stable_node was a chain and chain_prune collapsed it,\n\t * stable_node has been updated to be the new regular\n\t * stable_node. A collapse of the chain is indistinguishable\n\t * from the case there was no chain in the stable\n\t * rbtree. Otherwise stable_node is the chain and\n\t * stable_node_dup is the dup to replace.\n\t */\n\tif (stable_node_dup == stable_node) {\n\t\tVM_BUG_ON(is_stable_node_chain(stable_node_dup));\n\t\tVM_BUG_ON(is_stable_node_dup(stable_node_dup));\n\t\t/* there is no chain */\n\t\tif (page_node) {\n\t\t\tVM_BUG_ON(page_node->head != &migrate_nodes);\n\t\t\tlist_del(&page_node->list);\n\t\t\tDO_NUMA(page_node->nid = nid);\n\t\t\trb_replace_node(&stable_node_dup->node,\n\t\t\t\t\t&page_node->node,\n\t\t\t\t\troot);\n\t\t\tif (is_page_sharing_candidate(page_node))\n\t\t\t\tget_page(page);\n\t\t\telse\n\t\t\t\tpage = NULL;\n\t\t} else {\n\t\t\trb_erase(&stable_node_dup->node, root);\n\t\t\tpage = NULL;\n\t\t}\n\t} else {\n\t\tVM_BUG_ON(!is_stable_node_chain(stable_node));\n\t\t__stable_node_dup_del(stable_node_dup);\n\t\tif (page_node) {\n\t\t\tVM_BUG_ON(page_node->head != &migrate_nodes);\n\t\t\tlist_del(&page_node->list);\n\t\t\tDO_NUMA(page_node->nid = nid);\n\t\t\tstable_node_chain_add_dup(page_node, stable_node);\n\t\t\tif (is_page_sharing_candidate(page_node))\n\t\t\t\tget_page(page);\n\t\t\telse\n\t\t\t\tpage = NULL;\n\t\t} else {\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\tstable_node_dup->head = &migrate_nodes;\n\tlist_add(&stable_node_dup->list, stable_node_dup->head);\n\treturn page;\n\nchain_append:\n\t/* stable_node_dup could be null if it reached the limit */\n\tif (!stable_node_dup)\n\t\tstable_node_dup = stable_node_any;\n\t/*\n\t * If stable_node was a chain and chain_prune collapsed it,\n\t * stable_node has been updated to be the new regular\n\t * stable_node. A collapse of the chain is indistinguishable\n\t * from the case there was no chain in the stable\n\t * rbtree. Otherwise stable_node is the chain and\n\t * stable_node_dup is the dup to replace.\n\t */\n\tif (stable_node_dup == stable_node) {\n\t\tVM_BUG_ON(is_stable_node_chain(stable_node_dup));\n\t\tVM_BUG_ON(is_stable_node_dup(stable_node_dup));\n\t\t/* chain is missing so create it */\n\t\tstable_node = alloc_stable_node_chain(stable_node_dup,\n\t\t\t\t\t\t      root);\n\t\tif (!stable_node)\n\t\t\treturn NULL;\n\t}\n\t/*\n\t * Add this stable_node dup that was\n\t * migrated to the stable_node chain\n\t * of the current nid for this page\n\t * content.\n\t */\n\tVM_BUG_ON(!is_stable_node_chain(stable_node));\n\tVM_BUG_ON(!is_stable_node_dup(stable_node_dup));\n\tVM_BUG_ON(page_node->head != &migrate_nodes);\n\tlist_del(&page_node->list);\n\tDO_NUMA(page_node->nid = nid);\n\tstable_node_chain_add_dup(page_node, stable_node);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_page_sharing_candidate",
          "args": [
            "stable_node"
          ],
          "line": 2059
        },
        "resolved": true,
        "details": {
          "function_name": "is_page_sharing_candidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1352-1356",
          "snippet": "static __always_inline\nbool is_page_sharing_candidate(struct stable_node *stable_node)\n{\n\treturn __is_page_sharing_candidate(stable_node, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic __always_inline\nbool is_page_sharing_candidate(struct stable_node *stable_node)\n{\n\treturn __is_page_sharing_candidate(stable_node, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&stable_node->list",
            "stable_node->head"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stable_node_dup_del",
          "args": [
            "stable_node"
          ],
          "line": 2048
        },
        "resolved": true,
        "details": {
          "function_name": "stable_node_dup_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "365-375",
          "snippet": "static inline void stable_node_dup_del(struct stable_node *dup)\n{\n\tVM_BUG_ON(is_stable_node_chain(dup));\n\tif (is_stable_node_dup(dup))\n\t\t__stable_node_dup_del(dup);\n\telse\n\t\trb_erase(&dup->node, root_stable_tree + NUMA(dup->nid));\n#ifdef CONFIG_DEBUG_VM\n\tdup->head = NULL;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root *root_stable_tree = one_stable_tree;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct rb_root *root_stable_tree = one_stable_tree;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void stable_node_dup_del(struct stable_node *dup)\n{\n\tVM_BUG_ON(is_stable_node_chain(dup));\n\tif (is_stable_node_dup(dup))\n\t\t__stable_node_dup_del(dup);\n\telse\n\t\trb_erase(&dup->node, root_stable_tree + NUMA(dup->nid));\n#ifdef CONFIG_DEBUG_VM\n\tdup->head = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "NUMA",
          "args": [
            "stable_node->nid"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_kpfn_nid",
          "args": [
            "READ_ONCE(stable_node->kpfn)"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "get_kpfn_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "585-588",
          "snippet": "static inline int get_kpfn_nid(unsigned long kpfn)\n{\n\treturn ksm_merge_across_nodes ? 0 : NUMA(pfn_to_nid(kpfn));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define ksm_merge_across_nodes\t1U"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define ksm_merge_across_nodes\t1U\n\nstatic inline int get_kpfn_nid(unsigned long kpfn)\n{\n\treturn ksm_merge_across_nodes ? 0 : NUMA(pfn_to_nid(kpfn));\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "stable_node->kpfn"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic LIST_HEAD(migrate_nodes);\nstatic unsigned int zero_checksum;\nstatic bool ksm_use_zero_pages;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic void cmp_and_merge_page(struct page *page, struct rmap_item *rmap_item)\n{\n\tstruct mm_struct *mm = rmap_item->mm;\n\tstruct rmap_item *tree_rmap_item;\n\tstruct page *tree_page = NULL;\n\tstruct stable_node *stable_node;\n\tstruct page *kpage;\n\tunsigned int checksum;\n\tint err;\n\tbool max_page_sharing_bypass = false;\n\n\tstable_node = page_stable_node(page);\n\tif (stable_node) {\n\t\tif (stable_node->head != &migrate_nodes &&\n\t\t    get_kpfn_nid(READ_ONCE(stable_node->kpfn)) !=\n\t\t    NUMA(stable_node->nid)) {\n\t\t\tstable_node_dup_del(stable_node);\n\t\t\tstable_node->head = &migrate_nodes;\n\t\t\tlist_add(&stable_node->list, stable_node->head);\n\t\t}\n\t\tif (stable_node->head != &migrate_nodes &&\n\t\t    rmap_item->head == stable_node)\n\t\t\treturn;\n\t\t/*\n\t\t * If it's a KSM fork, allow it to go over the sharing limit\n\t\t * without warnings.\n\t\t */\n\t\tif (!is_page_sharing_candidate(stable_node))\n\t\t\tmax_page_sharing_bypass = true;\n\t}\n\n\t/* We first start with searching the page inside the stable tree */\n\tkpage = stable_tree_search(page);\n\tif (kpage == page && rmap_item->head == stable_node) {\n\t\tput_page(kpage);\n\t\treturn;\n\t}\n\n\tremove_rmap_item_from_tree(rmap_item);\n\n\tif (kpage) {\n\t\terr = try_to_merge_with_ksm_page(rmap_item, page, kpage);\n\t\tif (!err) {\n\t\t\t/*\n\t\t\t * The page was successfully merged:\n\t\t\t * add its rmap_item to the stable tree.\n\t\t\t */\n\t\t\tlock_page(kpage);\n\t\t\tstable_tree_append(rmap_item, page_stable_node(kpage),\n\t\t\t\t\t   max_page_sharing_bypass);\n\t\t\tunlock_page(kpage);\n\t\t}\n\t\tput_page(kpage);\n\t\treturn;\n\t}\n\n\t/*\n\t * If the hash value of the page has changed from the last time\n\t * we calculated it, this page is changing frequently: therefore we\n\t * don't want to insert it in the unstable tree, and we don't want\n\t * to waste our time searching for something identical to it there.\n\t */\n\tchecksum = calc_checksum(page);\n\tif (rmap_item->oldchecksum != checksum) {\n\t\trmap_item->oldchecksum = checksum;\n\t\treturn;\n\t}\n\n\t/*\n\t * Same checksum as an empty page. We attempt to merge it with the\n\t * appropriate zero page if the user enabled this via sysfs.\n\t */\n\tif (ksm_use_zero_pages && (checksum == zero_checksum)) {\n\t\tstruct vm_area_struct *vma;\n\n\t\tdown_read(&mm->mmap_sem);\n\t\tvma = find_mergeable_vma(mm, rmap_item->address);\n\t\terr = try_to_merge_one_page(vma, page,\n\t\t\t\t\t    ZERO_PAGE(rmap_item->address));\n\t\tup_read(&mm->mmap_sem);\n\t\t/*\n\t\t * In case of failure, the page was not really empty, so we\n\t\t * need to continue. Otherwise we're done.\n\t\t */\n\t\tif (!err)\n\t\t\treturn;\n\t}\n\ttree_rmap_item =\n\t\tunstable_tree_search_insert(rmap_item, page, &tree_page);\n\tif (tree_rmap_item) {\n\t\tbool split;\n\n\t\tkpage = try_to_merge_two_pages(rmap_item, page,\n\t\t\t\t\t\ttree_rmap_item, tree_page);\n\t\t/*\n\t\t * If both pages we tried to merge belong to the same compound\n\t\t * page, then we actually ended up increasing the reference\n\t\t * count of the same compound page twice, and split_huge_page\n\t\t * failed.\n\t\t * Here we set a flag if that happened, and we use it later to\n\t\t * try split_huge_page again. Since we call put_page right\n\t\t * afterwards, the reference count will be correct and\n\t\t * split_huge_page should succeed.\n\t\t */\n\t\tsplit = PageTransCompound(page)\n\t\t\t&& compound_head(page) == compound_head(tree_page);\n\t\tput_page(tree_page);\n\t\tif (kpage) {\n\t\t\t/*\n\t\t\t * The pages were successfully merged: insert new\n\t\t\t * node in the stable tree and add both rmap_items.\n\t\t\t */\n\t\t\tlock_page(kpage);\n\t\t\tstable_node = stable_tree_insert(kpage);\n\t\t\tif (stable_node) {\n\t\t\t\tstable_tree_append(tree_rmap_item, stable_node,\n\t\t\t\t\t\t   false);\n\t\t\t\tstable_tree_append(rmap_item, stable_node,\n\t\t\t\t\t\t   false);\n\t\t\t}\n\t\t\tunlock_page(kpage);\n\n\t\t\t/*\n\t\t\t * If we fail to insert the page into the stable tree,\n\t\t\t * we will have 2 virtual addresses that are pointing\n\t\t\t * to a ksm page left outside the stable tree,\n\t\t\t * in which case we need to break_cow on both.\n\t\t\t */\n\t\t\tif (!stable_node) {\n\t\t\t\tbreak_cow(tree_rmap_item);\n\t\t\t\tbreak_cow(rmap_item);\n\t\t\t}\n\t\t} else if (split) {\n\t\t\t/*\n\t\t\t * We are here if we tried to merge two pages and\n\t\t\t * failed because they both belonged to the same\n\t\t\t * compound page. We will split the page now, but no\n\t\t\t * merging will take place.\n\t\t\t * We do not want to add the cost of a full lock; if\n\t\t\t * the page is locked, it is better to skip it and\n\t\t\t * perhaps try again later.\n\t\t\t */\n\t\t\tif (!trylock_page(page))\n\t\t\t\treturn;\n\t\t\tsplit_huge_page(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "stable_tree_append",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "1991-2021",
    "snippet": "static void stable_tree_append(struct rmap_item *rmap_item,\n\t\t\t       struct stable_node *stable_node,\n\t\t\t       bool max_page_sharing_bypass)\n{\n\t/*\n\t * rmap won't find this mapping if we don't insert the\n\t * rmap_item in the right stable_node\n\t * duplicate. page_migration could break later if rmap breaks,\n\t * so we can as well crash here. We really need to check for\n\t * rmap_hlist_len == STABLE_NODE_CHAIN, but we can as well check\n\t * for other negative values as an undeflow if detected here\n\t * for the first time (and not when decreasing rmap_hlist_len)\n\t * would be sign of memory corruption in the stable_node.\n\t */\n\tBUG_ON(stable_node->rmap_hlist_len < 0);\n\n\tstable_node->rmap_hlist_len++;\n\tif (!max_page_sharing_bypass)\n\t\t/* possibly non fatal but unexpected overflow, only warn */\n\t\tWARN_ON_ONCE(stable_node->rmap_hlist_len >\n\t\t\t     ksm_max_page_sharing);\n\n\trmap_item->head = stable_node;\n\trmap_item->address |= STABLE_FLAG;\n\thlist_add_head(&rmap_item->hlist, &stable_node->hlist);\n\n\tif (rmap_item->hlist.next)\n\t\tksm_pages_sharing++;\n\telse\n\t\tksm_pages_shared++;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define STABLE_FLAG\t0x200\t/* is listed from the stable tree */",
      "#define STABLE_NODE_CHAIN -1024"
    ],
    "globals_used": [
      "static unsigned long ksm_pages_shared;",
      "static unsigned long ksm_pages_sharing;",
      "static int ksm_max_page_sharing = 256;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&rmap_item->hlist",
            "&stable_node->hlist"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "stable_node->rmap_hlist_len >\n\t\t\t     ksm_max_page_sharing"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "stable_node->rmap_hlist_len < 0"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_FLAG\t0x200\t/* is listed from the stable tree */\n#define STABLE_NODE_CHAIN -1024\n\nstatic unsigned long ksm_pages_shared;\nstatic unsigned long ksm_pages_sharing;\nstatic int ksm_max_page_sharing = 256;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic void stable_tree_append(struct rmap_item *rmap_item,\n\t\t\t       struct stable_node *stable_node,\n\t\t\t       bool max_page_sharing_bypass)\n{\n\t/*\n\t * rmap won't find this mapping if we don't insert the\n\t * rmap_item in the right stable_node\n\t * duplicate. page_migration could break later if rmap breaks,\n\t * so we can as well crash here. We really need to check for\n\t * rmap_hlist_len == STABLE_NODE_CHAIN, but we can as well check\n\t * for other negative values as an undeflow if detected here\n\t * for the first time (and not when decreasing rmap_hlist_len)\n\t * would be sign of memory corruption in the stable_node.\n\t */\n\tBUG_ON(stable_node->rmap_hlist_len < 0);\n\n\tstable_node->rmap_hlist_len++;\n\tif (!max_page_sharing_bypass)\n\t\t/* possibly non fatal but unexpected overflow, only warn */\n\t\tWARN_ON_ONCE(stable_node->rmap_hlist_len >\n\t\t\t     ksm_max_page_sharing);\n\n\trmap_item->head = stable_node;\n\trmap_item->address |= STABLE_FLAG;\n\thlist_add_head(&rmap_item->hlist, &stable_node->hlist);\n\n\tif (rmap_item->hlist.next)\n\t\tksm_pages_sharing++;\n\telse\n\t\tksm_pages_shared++;\n}"
  },
  {
    "function_name": "unstable_tree_search_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "1919-1984",
    "snippet": "static\nstruct rmap_item *unstable_tree_search_insert(struct rmap_item *rmap_item,\n\t\t\t\t\t      struct page *page,\n\t\t\t\t\t      struct page **tree_pagep)\n{\n\tstruct rb_node **new;\n\tstruct rb_root *root;\n\tstruct rb_node *parent = NULL;\n\tint nid;\n\n\tnid = get_kpfn_nid(page_to_pfn(page));\n\troot = root_unstable_tree + nid;\n\tnew = &root->rb_node;\n\n\twhile (*new) {\n\t\tstruct rmap_item *tree_rmap_item;\n\t\tstruct page *tree_page;\n\t\tint ret;\n\n\t\tcond_resched();\n\t\ttree_rmap_item = rb_entry(*new, struct rmap_item, node);\n\t\ttree_page = get_mergeable_page(tree_rmap_item);\n\t\tif (!tree_page)\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * Don't substitute a ksm page for a forked page.\n\t\t */\n\t\tif (page == tree_page) {\n\t\t\tput_page(tree_page);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tret = memcmp_pages(page, tree_page);\n\n\t\tparent = *new;\n\t\tif (ret < 0) {\n\t\t\tput_page(tree_page);\n\t\t\tnew = &parent->rb_left;\n\t\t} else if (ret > 0) {\n\t\t\tput_page(tree_page);\n\t\t\tnew = &parent->rb_right;\n\t\t} else if (!ksm_merge_across_nodes &&\n\t\t\t   page_to_nid(tree_page) != nid) {\n\t\t\t/*\n\t\t\t * If tree_page has been migrated to another NUMA node,\n\t\t\t * it will be flushed out and put in the right unstable\n\t\t\t * tree next time: only merge with it when across_nodes.\n\t\t\t */\n\t\t\tput_page(tree_page);\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\t*tree_pagep = tree_page;\n\t\t\treturn tree_rmap_item;\n\t\t}\n\t}\n\n\trmap_item->address |= UNSTABLE_FLAG;\n\trmap_item->address |= (ksm_scan.seqnr & SEQNR_MASK);\n\tDO_NUMA(rmap_item->nid = nid);\n\trb_link_node(&rmap_item->node, parent, new);\n\trb_insert_color(&rmap_item->node, root);\n\n\tksm_pages_unshared++;\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define ksm_merge_across_nodes\t1U",
      "#define UNSTABLE_FLAG\t0x100\t/* is a node of the unstable tree */",
      "#define SEQNR_MASK\t0x0ff\t/* low bits of unstable tree seqnr */"
    ],
    "globals_used": [
      "static struct rb_root *root_unstable_tree = one_unstable_tree;",
      "static struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};",
      "static unsigned long ksm_pages_unshared;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&rmap_item->node",
            "root"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&rmap_item->node",
            "parent",
            "new"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_NUMA",
          "args": [
            "rmap_item->nid = nid"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "tree_page"
          ],
          "line": 1968
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "tree_page"
          ],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp_pages",
          "args": [
            "page",
            "tree_page"
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "memcmp_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1017-1028",
          "snippet": "static int memcmp_pages(struct page *page1, struct page *page2)\n{\n\tchar *addr1, *addr2;\n\tint ret;\n\n\taddr1 = kmap_atomic(page1);\n\taddr2 = kmap_atomic(page2);\n\tret = memcmp(addr1, addr2, PAGE_SIZE);\n\tkunmap_atomic(addr2);\n\tkunmap_atomic(addr1);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int memcmp_pages(struct page *page1, struct page *page2)\n{\n\tchar *addr1, *addr2;\n\tint ret;\n\n\taddr1 = kmap_atomic(page1);\n\taddr2 = kmap_atomic(page2);\n\tret = memcmp(addr1, addr2, PAGE_SIZE);\n\tkunmap_atomic(addr2);\n\tkunmap_atomic(addr1);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_mergeable_page",
          "args": [
            "tree_rmap_item"
          ],
          "line": 1940
        },
        "resolved": true,
        "details": {
          "function_name": "get_mergeable_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "552-577",
          "snippet": "static struct page *get_mergeable_page(struct rmap_item *rmap_item)\n{\n\tstruct mm_struct *mm = rmap_item->mm;\n\tunsigned long addr = rmap_item->address;\n\tstruct vm_area_struct *vma;\n\tstruct page *page;\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_mergeable_vma(mm, addr);\n\tif (!vma)\n\t\tgoto out;\n\n\tpage = follow_page(vma, addr, FOLL_GET);\n\tif (IS_ERR_OR_NULL(page))\n\t\tgoto out;\n\tif (PageAnon(page)) {\n\t\tflush_anon_page(vma, page, addr);\n\t\tflush_dcache_page(page);\n\t} else {\n\t\tput_page(page);\nout:\n\t\tpage = NULL;\n\t}\n\tup_read(&mm->mmap_sem);\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct page *get_mergeable_page(struct rmap_item *rmap_item)\n{\n\tstruct mm_struct *mm = rmap_item->mm;\n\tunsigned long addr = rmap_item->address;\n\tstruct vm_area_struct *vma;\n\tstruct page *page;\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_mergeable_vma(mm, addr);\n\tif (!vma)\n\t\tgoto out;\n\n\tpage = follow_page(vma, addr, FOLL_GET);\n\tif (IS_ERR_OR_NULL(page))\n\t\tgoto out;\n\tif (PageAnon(page)) {\n\t\tflush_anon_page(vma, page, addr);\n\t\tflush_dcache_page(page);\n\t} else {\n\t\tput_page(page);\nout:\n\t\tpage = NULL;\n\t}\n\tup_read(&mm->mmap_sem);\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "*new",
            "structrmap_item",
            "node"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_kpfn_nid",
          "args": [
            "page_to_pfn(page)"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "get_kpfn_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "585-588",
          "snippet": "static inline int get_kpfn_nid(unsigned long kpfn)\n{\n\treturn ksm_merge_across_nodes ? 0 : NUMA(pfn_to_nid(kpfn));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define ksm_merge_across_nodes\t1U"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define ksm_merge_across_nodes\t1U\n\nstatic inline int get_kpfn_nid(unsigned long kpfn)\n{\n\treturn ksm_merge_across_nodes ? 0 : NUMA(pfn_to_nid(kpfn));\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define ksm_merge_across_nodes\t1U\n#define UNSTABLE_FLAG\t0x100\t/* is a node of the unstable tree */\n#define SEQNR_MASK\t0x0ff\t/* low bits of unstable tree seqnr */\n\nstatic struct rb_root *root_unstable_tree = one_unstable_tree;\nstatic struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};\nstatic unsigned long ksm_pages_unshared;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic\nstruct rmap_item *unstable_tree_search_insert(struct rmap_item *rmap_item,\n\t\t\t\t\t      struct page *page,\n\t\t\t\t\t      struct page **tree_pagep)\n{\n\tstruct rb_node **new;\n\tstruct rb_root *root;\n\tstruct rb_node *parent = NULL;\n\tint nid;\n\n\tnid = get_kpfn_nid(page_to_pfn(page));\n\troot = root_unstable_tree + nid;\n\tnew = &root->rb_node;\n\n\twhile (*new) {\n\t\tstruct rmap_item *tree_rmap_item;\n\t\tstruct page *tree_page;\n\t\tint ret;\n\n\t\tcond_resched();\n\t\ttree_rmap_item = rb_entry(*new, struct rmap_item, node);\n\t\ttree_page = get_mergeable_page(tree_rmap_item);\n\t\tif (!tree_page)\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * Don't substitute a ksm page for a forked page.\n\t\t */\n\t\tif (page == tree_page) {\n\t\t\tput_page(tree_page);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tret = memcmp_pages(page, tree_page);\n\n\t\tparent = *new;\n\t\tif (ret < 0) {\n\t\t\tput_page(tree_page);\n\t\t\tnew = &parent->rb_left;\n\t\t} else if (ret > 0) {\n\t\t\tput_page(tree_page);\n\t\t\tnew = &parent->rb_right;\n\t\t} else if (!ksm_merge_across_nodes &&\n\t\t\t   page_to_nid(tree_page) != nid) {\n\t\t\t/*\n\t\t\t * If tree_page has been migrated to another NUMA node,\n\t\t\t * it will be flushed out and put in the right unstable\n\t\t\t * tree next time: only merge with it when across_nodes.\n\t\t\t */\n\t\t\tput_page(tree_page);\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\t*tree_pagep = tree_page;\n\t\t\treturn tree_rmap_item;\n\t\t}\n\t}\n\n\trmap_item->address |= UNSTABLE_FLAG;\n\trmap_item->address |= (ksm_scan.seqnr & SEQNR_MASK);\n\tDO_NUMA(rmap_item->nid = nid);\n\trb_link_node(&rmap_item->node, parent, new);\n\trb_insert_color(&rmap_item->node, root);\n\n\tksm_pages_unshared++;\n\treturn NULL;\n}"
  },
  {
    "function_name": "stable_tree_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "1801-1903",
    "snippet": "static struct stable_node *stable_tree_insert(struct page *kpage)\n{\n\tint nid;\n\tunsigned long kpfn;\n\tstruct rb_root *root;\n\tstruct rb_node **new;\n\tstruct rb_node *parent;\n\tstruct stable_node *stable_node, *stable_node_dup, *stable_node_any;\n\tbool need_chain = false;\n\n\tkpfn = page_to_pfn(kpage);\n\tnid = get_kpfn_nid(kpfn);\n\troot = root_stable_tree + nid;\nagain:\n\tparent = NULL;\n\tnew = &root->rb_node;\n\n\twhile (*new) {\n\t\tstruct page *tree_page;\n\t\tint ret;\n\n\t\tcond_resched();\n\t\tstable_node = rb_entry(*new, struct stable_node, node);\n\t\tstable_node_any = NULL;\n\t\ttree_page = chain(&stable_node_dup, stable_node, root);\n\t\tif (!stable_node_dup) {\n\t\t\t/*\n\t\t\t * Either all stable_node dups were full in\n\t\t\t * this stable_node chain, or this chain was\n\t\t\t * empty and should be rb_erased.\n\t\t\t */\n\t\t\tstable_node_any = stable_node_dup_any(stable_node,\n\t\t\t\t\t\t\t      root);\n\t\t\tif (!stable_node_any) {\n\t\t\t\t/* rb_erase just run */\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Take any of the stable_node dups page of\n\t\t\t * this stable_node chain to let the tree walk\n\t\t\t * continue. All KSM pages belonging to the\n\t\t\t * stable_node dups in a stable_node chain\n\t\t\t * have the same content and they're\n\t\t\t * wrprotected at all times. Any will work\n\t\t\t * fine to continue the walk.\n\t\t\t */\n\t\t\ttree_page = get_ksm_page(stable_node_any, false);\n\t\t}\n\t\tVM_BUG_ON(!stable_node_dup ^ !!stable_node_any);\n\t\tif (!tree_page) {\n\t\t\t/*\n\t\t\t * If we walked over a stale stable_node,\n\t\t\t * get_ksm_page() will call rb_erase() and it\n\t\t\t * may rebalance the tree from under us. So\n\t\t\t * restart the search from scratch. Returning\n\t\t\t * NULL would be safe too, but we'd generate\n\t\t\t * false negative insertions just because some\n\t\t\t * stable_node was stale.\n\t\t\t */\n\t\t\tgoto again;\n\t\t}\n\n\t\tret = memcmp_pages(kpage, tree_page);\n\t\tput_page(tree_page);\n\n\t\tparent = *new;\n\t\tif (ret < 0)\n\t\t\tnew = &parent->rb_left;\n\t\telse if (ret > 0)\n\t\t\tnew = &parent->rb_right;\n\t\telse {\n\t\t\tneed_chain = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tstable_node_dup = alloc_stable_node();\n\tif (!stable_node_dup)\n\t\treturn NULL;\n\n\tINIT_HLIST_HEAD(&stable_node_dup->hlist);\n\tstable_node_dup->kpfn = kpfn;\n\tset_page_stable_node(kpage, stable_node_dup);\n\tstable_node_dup->rmap_hlist_len = 0;\n\tDO_NUMA(stable_node_dup->nid = nid);\n\tif (!need_chain) {\n\t\trb_link_node(&stable_node_dup->node, parent, new);\n\t\trb_insert_color(&stable_node_dup->node, root);\n\t} else {\n\t\tif (!is_stable_node_chain(stable_node)) {\n\t\t\tstruct stable_node *orig = stable_node;\n\t\t\t/* chain is missing so create it */\n\t\t\tstable_node = alloc_stable_node_chain(orig, root);\n\t\t\tif (!stable_node) {\n\t\t\t\tfree_stable_node(stable_node_dup);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tstable_node_chain_add_dup(stable_node_dup, stable_node);\n\t}\n\n\treturn stable_node_dup;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root *root_stable_tree = one_stable_tree;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stable_node_chain_add_dup",
          "args": [
            "stable_node_dup",
            "stable_node"
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "stable_node_chain_add_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "348-356",
          "snippet": "static inline void stable_node_chain_add_dup(struct stable_node *dup,\n\t\t\t\t\t     struct stable_node *chain)\n{\n\tVM_BUG_ON(is_stable_node_dup(dup));\n\tdup->head = STABLE_NODE_DUP_HEAD;\n\tVM_BUG_ON(!is_stable_node_chain(chain));\n\thlist_add_head(&dup->hlist_dup, &chain->hlist);\n\tksm_stable_node_dups++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)"
          ],
          "globals_used": [
            "static unsigned long ksm_stable_node_dups;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)\n\nstatic unsigned long ksm_stable_node_dups;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void stable_node_chain_add_dup(struct stable_node *dup,\n\t\t\t\t\t     struct stable_node *chain)\n{\n\tVM_BUG_ON(is_stable_node_dup(dup));\n\tdup->head = STABLE_NODE_DUP_HEAD;\n\tVM_BUG_ON(!is_stable_node_chain(chain));\n\thlist_add_head(&dup->hlist_dup, &chain->hlist);\n\tksm_stable_node_dups++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_stable_node",
          "args": [
            "stable_node_dup"
          ],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "free_stable_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "405-410",
          "snippet": "static inline void free_stable_node(struct stable_node *stable_node)\n{\n\tVM_BUG_ON(stable_node->rmap_hlist_len &&\n\t\t  !is_stable_node_chain(stable_node));\n\tkmem_cache_free(stable_node_cache, stable_node);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *stable_node_cache;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct kmem_cache *stable_node_cache;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void free_stable_node(struct stable_node *stable_node)\n{\n\tVM_BUG_ON(stable_node->rmap_hlist_len &&\n\t\t  !is_stable_node_chain(stable_node));\n\tkmem_cache_free(stable_node_cache, stable_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_stable_node_chain",
          "args": [
            "orig",
            "root"
          ],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_stable_node_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "590-621",
          "snippet": "static struct stable_node *alloc_stable_node_chain(struct stable_node *dup,\n\t\t\t\t\t\t   struct rb_root *root)\n{\n\tstruct stable_node *chain = alloc_stable_node();\n\tVM_BUG_ON(is_stable_node_chain(dup));\n\tif (likely(chain)) {\n\t\tINIT_HLIST_HEAD(&chain->hlist);\n\t\tchain->chain_prune_time = jiffies;\n\t\tchain->rmap_hlist_len = STABLE_NODE_CHAIN;\n#if defined (CONFIG_DEBUG_VM) && defined(CONFIG_NUMA)\n\t\tchain->nid = -1; /* debug */\n#endif\n\t\tksm_stable_node_chains++;\n\n\t\t/*\n\t\t * Put the stable node chain in the first dimension of\n\t\t * the stable tree and at the same time remove the old\n\t\t * stable node.\n\t\t */\n\t\trb_replace_node(&dup->node, &chain->node, root);\n\n\t\t/*\n\t\t * Move the old stable node to the second dimension\n\t\t * queued in the hlist_dup. The invariant is that all\n\t\t * dup stable_nodes in the chain->hlist point to pages\n\t\t * that are wrprotected and have the exact same\n\t\t * content.\n\t\t */\n\t\tstable_node_chain_add_dup(dup, chain);\n\t}\n\treturn chain;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_NODE_CHAIN -1024"
          ],
          "globals_used": [
            "static unsigned long ksm_stable_node_chains;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_CHAIN -1024\n\nstatic unsigned long ksm_stable_node_chains;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct stable_node *alloc_stable_node_chain(struct stable_node *dup,\n\t\t\t\t\t\t   struct rb_root *root)\n{\n\tstruct stable_node *chain = alloc_stable_node();\n\tVM_BUG_ON(is_stable_node_chain(dup));\n\tif (likely(chain)) {\n\t\tINIT_HLIST_HEAD(&chain->hlist);\n\t\tchain->chain_prune_time = jiffies;\n\t\tchain->rmap_hlist_len = STABLE_NODE_CHAIN;\n#if defined (CONFIG_DEBUG_VM) && defined(CONFIG_NUMA)\n\t\tchain->nid = -1; /* debug */\n#endif\n\t\tksm_stable_node_chains++;\n\n\t\t/*\n\t\t * Put the stable node chain in the first dimension of\n\t\t * the stable tree and at the same time remove the old\n\t\t * stable node.\n\t\t */\n\t\trb_replace_node(&dup->node, &chain->node, root);\n\n\t\t/*\n\t\t * Move the old stable node to the second dimension\n\t\t * queued in the hlist_dup. The invariant is that all\n\t\t * dup stable_nodes in the chain->hlist point to pages\n\t\t * that are wrprotected and have the exact same\n\t\t * content.\n\t\t */\n\t\tstable_node_chain_add_dup(dup, chain);\n\t}\n\treturn chain;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_stable_node_chain",
          "args": [
            "stable_node"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "is_stable_node_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "338-341",
          "snippet": "static __always_inline bool is_stable_node_chain(struct stable_node *chain)\n{\n\treturn chain->rmap_hlist_len == STABLE_NODE_CHAIN;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_NODE_CHAIN -1024"
          ],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_CHAIN -1024\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic __always_inline bool is_stable_node_chain(struct stable_node *chain)\n{\n\treturn chain->rmap_hlist_len == STABLE_NODE_CHAIN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&stable_node_dup->node",
            "root"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&stable_node_dup->node",
            "parent",
            "new"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_NUMA",
          "args": [
            "stable_node_dup->nid = nid"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_stable_node",
          "args": [
            "kpage",
            "stable_node_dup"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_stable_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "850-854",
          "snippet": "static inline void set_page_stable_node(struct page *page,\n\t\t\t\t\tstruct stable_node *stable_node)\n{\n\tpage->mapping = (void *)((unsigned long)stable_node | PAGE_MAPPING_KSM);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void set_page_stable_node(struct page *page,\n\t\t\t\t\tstruct stable_node *stable_node)\n{\n\tpage->mapping = (void *)((unsigned long)stable_node | PAGE_MAPPING_KSM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&stable_node_dup->hlist"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_stable_node",
          "args": [],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_stable_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "395-403",
          "snippet": "static inline struct stable_node *alloc_stable_node(void)\n{\n\t/*\n\t * The allocation can take too long with GFP_KERNEL when memory is under\n\t * pressure, which may lead to hung task warnings.  Adding __GFP_HIGH\n\t * grants access to memory reserves, helping to avoid this problem.\n\t */\n\treturn kmem_cache_alloc(stable_node_cache, GFP_KERNEL | __GFP_HIGH);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *stable_node_cache;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct kmem_cache *stable_node_cache;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline struct stable_node *alloc_stable_node(void)\n{\n\t/*\n\t * The allocation can take too long with GFP_KERNEL when memory is under\n\t * pressure, which may lead to hung task warnings.  Adding __GFP_HIGH\n\t * grants access to memory reserves, helping to avoid this problem.\n\t */\n\treturn kmem_cache_alloc(stable_node_cache, GFP_KERNEL | __GFP_HIGH);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "tree_page"
          ],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp_pages",
          "args": [
            "kpage",
            "tree_page"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "memcmp_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1017-1028",
          "snippet": "static int memcmp_pages(struct page *page1, struct page *page2)\n{\n\tchar *addr1, *addr2;\n\tint ret;\n\n\taddr1 = kmap_atomic(page1);\n\taddr2 = kmap_atomic(page2);\n\tret = memcmp(addr1, addr2, PAGE_SIZE);\n\tkunmap_atomic(addr2);\n\tkunmap_atomic(addr1);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int memcmp_pages(struct page *page1, struct page *page2)\n{\n\tchar *addr1, *addr2;\n\tint ret;\n\n\taddr1 = kmap_atomic(page1);\n\taddr2 = kmap_atomic(page2);\n\tret = memcmp(addr1, addr2, PAGE_SIZE);\n\tkunmap_atomic(addr2);\n\tkunmap_atomic(addr1);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!stable_node_dup ^ !!stable_node_any"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ksm_page",
          "args": [
            "stable_node_any",
            "false"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "get_ksm_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "688-752",
          "snippet": "static struct page *get_ksm_page(struct stable_node *stable_node, bool lock_it)\n{\n\tstruct page *page;\n\tvoid *expected_mapping;\n\tunsigned long kpfn;\n\n\texpected_mapping = (void *)((unsigned long)stable_node |\n\t\t\t\t\tPAGE_MAPPING_KSM);\nagain:\n\tkpfn = READ_ONCE(stable_node->kpfn); /* Address dependency. */\n\tpage = pfn_to_page(kpfn);\n\tif (READ_ONCE(page->mapping) != expected_mapping)\n\t\tgoto stale;\n\n\t/*\n\t * We cannot do anything with the page while its refcount is 0.\n\t * Usually 0 means free, or tail of a higher-order page: in which\n\t * case this node is no longer referenced, and should be freed;\n\t * however, it might mean that the page is under page_ref_freeze().\n\t * The __remove_mapping() case is easy, again the node is now stale;\n\t * but if page is swapcache in migrate_page_move_mapping(), it might\n\t * still be our page, in which case it's essential to keep the node.\n\t */\n\twhile (!get_page_unless_zero(page)) {\n\t\t/*\n\t\t * Another check for page->mapping != expected_mapping would\n\t\t * work here too.  We have chosen the !PageSwapCache test to\n\t\t * optimize the common case, when the page is or is about to\n\t\t * be freed: PageSwapCache is cleared (under spin_lock_irq)\n\t\t * in the ref_freeze section of __remove_mapping(); but Anon\n\t\t * page->mapping reset to NULL later, in free_pages_prepare().\n\t\t */\n\t\tif (!PageSwapCache(page))\n\t\t\tgoto stale;\n\t\tcpu_relax();\n\t}\n\n\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\tput_page(page);\n\t\tgoto stale;\n\t}\n\n\tif (lock_it) {\n\t\tlock_page(page);\n\t\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto stale;\n\t\t}\n\t}\n\treturn page;\n\nstale:\n\t/*\n\t * We come here from above when page->mapping or !PageSwapCache\n\t * suggests that the node is stale; but it might be under migration.\n\t * We need smp_rmb(), matching the smp_wmb() in ksm_migrate_page(),\n\t * before checking whether node->kpfn has been changed.\n\t */\n\tsmp_rmb();\n\tif (READ_ONCE(stable_node->kpfn) != kpfn)\n\t\tgoto again;\n\tremove_node_from_stable_tree(stable_node);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct page *get_ksm_page(struct stable_node *stable_node, bool lock_it)\n{\n\tstruct page *page;\n\tvoid *expected_mapping;\n\tunsigned long kpfn;\n\n\texpected_mapping = (void *)((unsigned long)stable_node |\n\t\t\t\t\tPAGE_MAPPING_KSM);\nagain:\n\tkpfn = READ_ONCE(stable_node->kpfn); /* Address dependency. */\n\tpage = pfn_to_page(kpfn);\n\tif (READ_ONCE(page->mapping) != expected_mapping)\n\t\tgoto stale;\n\n\t/*\n\t * We cannot do anything with the page while its refcount is 0.\n\t * Usually 0 means free, or tail of a higher-order page: in which\n\t * case this node is no longer referenced, and should be freed;\n\t * however, it might mean that the page is under page_ref_freeze().\n\t * The __remove_mapping() case is easy, again the node is now stale;\n\t * but if page is swapcache in migrate_page_move_mapping(), it might\n\t * still be our page, in which case it's essential to keep the node.\n\t */\n\twhile (!get_page_unless_zero(page)) {\n\t\t/*\n\t\t * Another check for page->mapping != expected_mapping would\n\t\t * work here too.  We have chosen the !PageSwapCache test to\n\t\t * optimize the common case, when the page is or is about to\n\t\t * be freed: PageSwapCache is cleared (under spin_lock_irq)\n\t\t * in the ref_freeze section of __remove_mapping(); but Anon\n\t\t * page->mapping reset to NULL later, in free_pages_prepare().\n\t\t */\n\t\tif (!PageSwapCache(page))\n\t\t\tgoto stale;\n\t\tcpu_relax();\n\t}\n\n\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\tput_page(page);\n\t\tgoto stale;\n\t}\n\n\tif (lock_it) {\n\t\tlock_page(page);\n\t\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto stale;\n\t\t}\n\t}\n\treturn page;\n\nstale:\n\t/*\n\t * We come here from above when page->mapping or !PageSwapCache\n\t * suggests that the node is stale; but it might be under migration.\n\t * We need smp_rmb(), matching the smp_wmb() in ksm_migrate_page(),\n\t * before checking whether node->kpfn has been changed.\n\t */\n\tsmp_rmb();\n\tif (READ_ONCE(stable_node->kpfn) != kpfn)\n\t\tgoto again;\n\tremove_node_from_stable_tree(stable_node);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stable_node_dup_any",
          "args": [
            "stable_node",
            "root"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "stable_node_dup_any",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1477-1488",
          "snippet": "static struct stable_node *stable_node_dup_any(struct stable_node *stable_node,\n\t\t\t\t\t       struct rb_root *root)\n{\n\tif (!is_stable_node_chain(stable_node))\n\t\treturn stable_node;\n\tif (hlist_empty(&stable_node->hlist)) {\n\t\tfree_stable_node_chain(stable_node, root);\n\t\treturn NULL;\n\t}\n\treturn hlist_entry(stable_node->hlist.first,\n\t\t\t   typeof(*stable_node), hlist_dup);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct stable_node *stable_node_dup_any(struct stable_node *stable_node,\n\t\t\t\t\t       struct rb_root *root)\n{\n\tif (!is_stable_node_chain(stable_node))\n\t\treturn stable_node;\n\tif (hlist_empty(&stable_node->hlist)) {\n\t\tfree_stable_node_chain(stable_node, root);\n\t\treturn NULL;\n\t}\n\treturn hlist_entry(stable_node->hlist.first,\n\t\t\t   typeof(*stable_node), hlist_dup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chain",
          "args": [
            "&stable_node_dup",
            "stable_node",
            "root"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "stable_node_chains_prune_millisecs_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "3076-3082",
          "snippet": "static ssize_t\nstable_node_chains_prune_millisecs_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", ksm_stable_node_chains_prune_millisecs);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ksm_stable_node_chains_prune_millisecs = 2000;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic int ksm_stable_node_chains_prune_millisecs = 2000;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic ssize_t\nstable_node_chains_prune_millisecs_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", ksm_stable_node_chains_prune_millisecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "*new",
            "structstable_node",
            "node"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_kpfn_nid",
          "args": [
            "kpfn"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "get_kpfn_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "585-588",
          "snippet": "static inline int get_kpfn_nid(unsigned long kpfn)\n{\n\treturn ksm_merge_across_nodes ? 0 : NUMA(pfn_to_nid(kpfn));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define ksm_merge_across_nodes\t1U"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define ksm_merge_across_nodes\t1U\n\nstatic inline int get_kpfn_nid(unsigned long kpfn)\n{\n\treturn ksm_merge_across_nodes ? 0 : NUMA(pfn_to_nid(kpfn));\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "kpage"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct rb_root *root_stable_tree = one_stable_tree;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct stable_node *stable_tree_insert(struct page *kpage)\n{\n\tint nid;\n\tunsigned long kpfn;\n\tstruct rb_root *root;\n\tstruct rb_node **new;\n\tstruct rb_node *parent;\n\tstruct stable_node *stable_node, *stable_node_dup, *stable_node_any;\n\tbool need_chain = false;\n\n\tkpfn = page_to_pfn(kpage);\n\tnid = get_kpfn_nid(kpfn);\n\troot = root_stable_tree + nid;\nagain:\n\tparent = NULL;\n\tnew = &root->rb_node;\n\n\twhile (*new) {\n\t\tstruct page *tree_page;\n\t\tint ret;\n\n\t\tcond_resched();\n\t\tstable_node = rb_entry(*new, struct stable_node, node);\n\t\tstable_node_any = NULL;\n\t\ttree_page = chain(&stable_node_dup, stable_node, root);\n\t\tif (!stable_node_dup) {\n\t\t\t/*\n\t\t\t * Either all stable_node dups were full in\n\t\t\t * this stable_node chain, or this chain was\n\t\t\t * empty and should be rb_erased.\n\t\t\t */\n\t\t\tstable_node_any = stable_node_dup_any(stable_node,\n\t\t\t\t\t\t\t      root);\n\t\t\tif (!stable_node_any) {\n\t\t\t\t/* rb_erase just run */\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Take any of the stable_node dups page of\n\t\t\t * this stable_node chain to let the tree walk\n\t\t\t * continue. All KSM pages belonging to the\n\t\t\t * stable_node dups in a stable_node chain\n\t\t\t * have the same content and they're\n\t\t\t * wrprotected at all times. Any will work\n\t\t\t * fine to continue the walk.\n\t\t\t */\n\t\t\ttree_page = get_ksm_page(stable_node_any, false);\n\t\t}\n\t\tVM_BUG_ON(!stable_node_dup ^ !!stable_node_any);\n\t\tif (!tree_page) {\n\t\t\t/*\n\t\t\t * If we walked over a stale stable_node,\n\t\t\t * get_ksm_page() will call rb_erase() and it\n\t\t\t * may rebalance the tree from under us. So\n\t\t\t * restart the search from scratch. Returning\n\t\t\t * NULL would be safe too, but we'd generate\n\t\t\t * false negative insertions just because some\n\t\t\t * stable_node was stale.\n\t\t\t */\n\t\t\tgoto again;\n\t\t}\n\n\t\tret = memcmp_pages(kpage, tree_page);\n\t\tput_page(tree_page);\n\n\t\tparent = *new;\n\t\tif (ret < 0)\n\t\t\tnew = &parent->rb_left;\n\t\telse if (ret > 0)\n\t\t\tnew = &parent->rb_right;\n\t\telse {\n\t\t\tneed_chain = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tstable_node_dup = alloc_stable_node();\n\tif (!stable_node_dup)\n\t\treturn NULL;\n\n\tINIT_HLIST_HEAD(&stable_node_dup->hlist);\n\tstable_node_dup->kpfn = kpfn;\n\tset_page_stable_node(kpage, stable_node_dup);\n\tstable_node_dup->rmap_hlist_len = 0;\n\tDO_NUMA(stable_node_dup->nid = nid);\n\tif (!need_chain) {\n\t\trb_link_node(&stable_node_dup->node, parent, new);\n\t\trb_insert_color(&stable_node_dup->node, root);\n\t} else {\n\t\tif (!is_stable_node_chain(stable_node)) {\n\t\t\tstruct stable_node *orig = stable_node;\n\t\t\t/* chain is missing so create it */\n\t\t\tstable_node = alloc_stable_node_chain(orig, root);\n\t\t\tif (!stable_node) {\n\t\t\t\tfree_stable_node(stable_node_dup);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tstable_node_chain_add_dup(stable_node_dup, stable_node);\n\t}\n\n\treturn stable_node_dup;\n}"
  },
  {
    "function_name": "stable_tree_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "1555-1792",
    "snippet": "static struct page *stable_tree_search(struct page *page)\n{\n\tint nid;\n\tstruct rb_root *root;\n\tstruct rb_node **new;\n\tstruct rb_node *parent;\n\tstruct stable_node *stable_node, *stable_node_dup, *stable_node_any;\n\tstruct stable_node *page_node;\n\n\tpage_node = page_stable_node(page);\n\tif (page_node && page_node->head != &migrate_nodes) {\n\t\t/* ksm page forked */\n\t\tget_page(page);\n\t\treturn page;\n\t}\n\n\tnid = get_kpfn_nid(page_to_pfn(page));\n\troot = root_stable_tree + nid;\nagain:\n\tnew = &root->rb_node;\n\tparent = NULL;\n\n\twhile (*new) {\n\t\tstruct page *tree_page;\n\t\tint ret;\n\n\t\tcond_resched();\n\t\tstable_node = rb_entry(*new, struct stable_node, node);\n\t\tstable_node_any = NULL;\n\t\ttree_page = chain_prune(&stable_node_dup, &stable_node,\troot);\n\t\t/*\n\t\t * NOTE: stable_node may have been freed by\n\t\t * chain_prune() if the returned stable_node_dup is\n\t\t * not NULL. stable_node_dup may have been inserted in\n\t\t * the rbtree instead as a regular stable_node (in\n\t\t * order to collapse the stable_node chain if a single\n\t\t * stable_node dup was found in it). In such case the\n\t\t * stable_node is overwritten by the calleee to point\n\t\t * to the stable_node_dup that was collapsed in the\n\t\t * stable rbtree and stable_node will be equal to\n\t\t * stable_node_dup like if the chain never existed.\n\t\t */\n\t\tif (!stable_node_dup) {\n\t\t\t/*\n\t\t\t * Either all stable_node dups were full in\n\t\t\t * this stable_node chain, or this chain was\n\t\t\t * empty and should be rb_erased.\n\t\t\t */\n\t\t\tstable_node_any = stable_node_dup_any(stable_node,\n\t\t\t\t\t\t\t      root);\n\t\t\tif (!stable_node_any) {\n\t\t\t\t/* rb_erase just run */\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Take any of the stable_node dups page of\n\t\t\t * this stable_node chain to let the tree walk\n\t\t\t * continue. All KSM pages belonging to the\n\t\t\t * stable_node dups in a stable_node chain\n\t\t\t * have the same content and they're\n\t\t\t * wrprotected at all times. Any will work\n\t\t\t * fine to continue the walk.\n\t\t\t */\n\t\t\ttree_page = get_ksm_page(stable_node_any, false);\n\t\t}\n\t\tVM_BUG_ON(!stable_node_dup ^ !!stable_node_any);\n\t\tif (!tree_page) {\n\t\t\t/*\n\t\t\t * If we walked over a stale stable_node,\n\t\t\t * get_ksm_page() will call rb_erase() and it\n\t\t\t * may rebalance the tree from under us. So\n\t\t\t * restart the search from scratch. Returning\n\t\t\t * NULL would be safe too, but we'd generate\n\t\t\t * false negative insertions just because some\n\t\t\t * stable_node was stale.\n\t\t\t */\n\t\t\tgoto again;\n\t\t}\n\n\t\tret = memcmp_pages(page, tree_page);\n\t\tput_page(tree_page);\n\n\t\tparent = *new;\n\t\tif (ret < 0)\n\t\t\tnew = &parent->rb_left;\n\t\telse if (ret > 0)\n\t\t\tnew = &parent->rb_right;\n\t\telse {\n\t\t\tif (page_node) {\n\t\t\t\tVM_BUG_ON(page_node->head != &migrate_nodes);\n\t\t\t\t/*\n\t\t\t\t * Test if the migrated page should be merged\n\t\t\t\t * into a stable node dup. If the mapcount is\n\t\t\t\t * 1 we can migrate it with another KSM page\n\t\t\t\t * without adding it to the chain.\n\t\t\t\t */\n\t\t\t\tif (page_mapcount(page) > 1)\n\t\t\t\t\tgoto chain_append;\n\t\t\t}\n\n\t\t\tif (!stable_node_dup) {\n\t\t\t\t/*\n\t\t\t\t * If the stable_node is a chain and\n\t\t\t\t * we got a payload match in memcmp\n\t\t\t\t * but we cannot merge the scanned\n\t\t\t\t * page in any of the existing\n\t\t\t\t * stable_node dups because they're\n\t\t\t\t * all full, we need to wait the\n\t\t\t\t * scanned page to find itself a match\n\t\t\t\t * in the unstable tree to create a\n\t\t\t\t * brand new KSM page to add later to\n\t\t\t\t * the dups of this stable_node.\n\t\t\t\t */\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Lock and unlock the stable_node's page (which\n\t\t\t * might already have been migrated) so that page\n\t\t\t * migration is sure to notice its raised count.\n\t\t\t * It would be more elegant to return stable_node\n\t\t\t * than kpage, but that involves more changes.\n\t\t\t */\n\t\t\ttree_page = get_ksm_page(stable_node_dup, true);\n\t\t\tif (unlikely(!tree_page))\n\t\t\t\t/*\n\t\t\t\t * The tree may have been rebalanced,\n\t\t\t\t * so re-evaluate parent and new.\n\t\t\t\t */\n\t\t\t\tgoto again;\n\t\t\tunlock_page(tree_page);\n\n\t\t\tif (get_kpfn_nid(stable_node_dup->kpfn) !=\n\t\t\t    NUMA(stable_node_dup->nid)) {\n\t\t\t\tput_page(tree_page);\n\t\t\t\tgoto replace;\n\t\t\t}\n\t\t\treturn tree_page;\n\t\t}\n\t}\n\n\tif (!page_node)\n\t\treturn NULL;\n\n\tlist_del(&page_node->list);\n\tDO_NUMA(page_node->nid = nid);\n\trb_link_node(&page_node->node, parent, new);\n\trb_insert_color(&page_node->node, root);\nout:\n\tif (is_page_sharing_candidate(page_node)) {\n\t\tget_page(page);\n\t\treturn page;\n\t} else\n\t\treturn NULL;\n\nreplace:\n\t/*\n\t * If stable_node was a chain and chain_prune collapsed it,\n\t * stable_node has been updated to be the new regular\n\t * stable_node. A collapse of the chain is indistinguishable\n\t * from the case there was no chain in the stable\n\t * rbtree. Otherwise stable_node is the chain and\n\t * stable_node_dup is the dup to replace.\n\t */\n\tif (stable_node_dup == stable_node) {\n\t\tVM_BUG_ON(is_stable_node_chain(stable_node_dup));\n\t\tVM_BUG_ON(is_stable_node_dup(stable_node_dup));\n\t\t/* there is no chain */\n\t\tif (page_node) {\n\t\t\tVM_BUG_ON(page_node->head != &migrate_nodes);\n\t\t\tlist_del(&page_node->list);\n\t\t\tDO_NUMA(page_node->nid = nid);\n\t\t\trb_replace_node(&stable_node_dup->node,\n\t\t\t\t\t&page_node->node,\n\t\t\t\t\troot);\n\t\t\tif (is_page_sharing_candidate(page_node))\n\t\t\t\tget_page(page);\n\t\t\telse\n\t\t\t\tpage = NULL;\n\t\t} else {\n\t\t\trb_erase(&stable_node_dup->node, root);\n\t\t\tpage = NULL;\n\t\t}\n\t} else {\n\t\tVM_BUG_ON(!is_stable_node_chain(stable_node));\n\t\t__stable_node_dup_del(stable_node_dup);\n\t\tif (page_node) {\n\t\t\tVM_BUG_ON(page_node->head != &migrate_nodes);\n\t\t\tlist_del(&page_node->list);\n\t\t\tDO_NUMA(page_node->nid = nid);\n\t\t\tstable_node_chain_add_dup(page_node, stable_node);\n\t\t\tif (is_page_sharing_candidate(page_node))\n\t\t\t\tget_page(page);\n\t\t\telse\n\t\t\t\tpage = NULL;\n\t\t} else {\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\tstable_node_dup->head = &migrate_nodes;\n\tlist_add(&stable_node_dup->list, stable_node_dup->head);\n\treturn page;\n\nchain_append:\n\t/* stable_node_dup could be null if it reached the limit */\n\tif (!stable_node_dup)\n\t\tstable_node_dup = stable_node_any;\n\t/*\n\t * If stable_node was a chain and chain_prune collapsed it,\n\t * stable_node has been updated to be the new regular\n\t * stable_node. A collapse of the chain is indistinguishable\n\t * from the case there was no chain in the stable\n\t * rbtree. Otherwise stable_node is the chain and\n\t * stable_node_dup is the dup to replace.\n\t */\n\tif (stable_node_dup == stable_node) {\n\t\tVM_BUG_ON(is_stable_node_chain(stable_node_dup));\n\t\tVM_BUG_ON(is_stable_node_dup(stable_node_dup));\n\t\t/* chain is missing so create it */\n\t\tstable_node = alloc_stable_node_chain(stable_node_dup,\n\t\t\t\t\t\t      root);\n\t\tif (!stable_node)\n\t\t\treturn NULL;\n\t}\n\t/*\n\t * Add this stable_node dup that was\n\t * migrated to the stable_node chain\n\t * of the current nid for this page\n\t * content.\n\t */\n\tVM_BUG_ON(!is_stable_node_chain(stable_node));\n\tVM_BUG_ON(!is_stable_node_dup(stable_node_dup));\n\tVM_BUG_ON(page_node->head != &migrate_nodes);\n\tlist_del(&page_node->list);\n\tDO_NUMA(page_node->nid = nid);\n\tstable_node_chain_add_dup(page_node, stable_node);\n\tgoto out;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root *root_stable_tree = one_stable_tree;",
      "static LIST_HEAD(migrate_nodes);",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stable_node_chain_add_dup",
          "args": [
            "page_node",
            "stable_node"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "stable_node_chain_add_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "348-356",
          "snippet": "static inline void stable_node_chain_add_dup(struct stable_node *dup,\n\t\t\t\t\t     struct stable_node *chain)\n{\n\tVM_BUG_ON(is_stable_node_dup(dup));\n\tdup->head = STABLE_NODE_DUP_HEAD;\n\tVM_BUG_ON(!is_stable_node_chain(chain));\n\thlist_add_head(&dup->hlist_dup, &chain->hlist);\n\tksm_stable_node_dups++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)"
          ],
          "globals_used": [
            "static unsigned long ksm_stable_node_dups;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)\n\nstatic unsigned long ksm_stable_node_dups;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void stable_node_chain_add_dup(struct stable_node *dup,\n\t\t\t\t\t     struct stable_node *chain)\n{\n\tVM_BUG_ON(is_stable_node_dup(dup));\n\tdup->head = STABLE_NODE_DUP_HEAD;\n\tVM_BUG_ON(!is_stable_node_chain(chain));\n\thlist_add_head(&dup->hlist_dup, &chain->hlist);\n\tksm_stable_node_dups++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DO_NUMA",
          "args": [
            "page_node->nid = nid"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page_node->list"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "page_node->head != &migrate_nodes"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!is_stable_node_dup(stable_node_dup)"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_stable_node_dup",
          "args": [
            "stable_node_dup"
          ],
          "line": 1786
        },
        "resolved": true,
        "details": {
          "function_name": "is_stable_node_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "343-346",
          "snippet": "static __always_inline bool is_stable_node_dup(struct stable_node *dup)\n{\n\treturn dup->head == STABLE_NODE_DUP_HEAD;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)"
          ],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic __always_inline bool is_stable_node_dup(struct stable_node *dup)\n{\n\treturn dup->head == STABLE_NODE_DUP_HEAD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!is_stable_node_chain(stable_node)"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_stable_node_chain",
          "args": [
            "stable_node"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "is_stable_node_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "338-341",
          "snippet": "static __always_inline bool is_stable_node_chain(struct stable_node *chain)\n{\n\treturn chain->rmap_hlist_len == STABLE_NODE_CHAIN;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_NODE_CHAIN -1024"
          ],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_CHAIN -1024\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic __always_inline bool is_stable_node_chain(struct stable_node *chain)\n{\n\treturn chain->rmap_hlist_len == STABLE_NODE_CHAIN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_stable_node_chain",
          "args": [
            "stable_node_dup",
            "root"
          ],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_stable_node_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "590-621",
          "snippet": "static struct stable_node *alloc_stable_node_chain(struct stable_node *dup,\n\t\t\t\t\t\t   struct rb_root *root)\n{\n\tstruct stable_node *chain = alloc_stable_node();\n\tVM_BUG_ON(is_stable_node_chain(dup));\n\tif (likely(chain)) {\n\t\tINIT_HLIST_HEAD(&chain->hlist);\n\t\tchain->chain_prune_time = jiffies;\n\t\tchain->rmap_hlist_len = STABLE_NODE_CHAIN;\n#if defined (CONFIG_DEBUG_VM) && defined(CONFIG_NUMA)\n\t\tchain->nid = -1; /* debug */\n#endif\n\t\tksm_stable_node_chains++;\n\n\t\t/*\n\t\t * Put the stable node chain in the first dimension of\n\t\t * the stable tree and at the same time remove the old\n\t\t * stable node.\n\t\t */\n\t\trb_replace_node(&dup->node, &chain->node, root);\n\n\t\t/*\n\t\t * Move the old stable node to the second dimension\n\t\t * queued in the hlist_dup. The invariant is that all\n\t\t * dup stable_nodes in the chain->hlist point to pages\n\t\t * that are wrprotected and have the exact same\n\t\t * content.\n\t\t */\n\t\tstable_node_chain_add_dup(dup, chain);\n\t}\n\treturn chain;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_NODE_CHAIN -1024"
          ],
          "globals_used": [
            "static unsigned long ksm_stable_node_chains;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_CHAIN -1024\n\nstatic unsigned long ksm_stable_node_chains;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct stable_node *alloc_stable_node_chain(struct stable_node *dup,\n\t\t\t\t\t\t   struct rb_root *root)\n{\n\tstruct stable_node *chain = alloc_stable_node();\n\tVM_BUG_ON(is_stable_node_chain(dup));\n\tif (likely(chain)) {\n\t\tINIT_HLIST_HEAD(&chain->hlist);\n\t\tchain->chain_prune_time = jiffies;\n\t\tchain->rmap_hlist_len = STABLE_NODE_CHAIN;\n#if defined (CONFIG_DEBUG_VM) && defined(CONFIG_NUMA)\n\t\tchain->nid = -1; /* debug */\n#endif\n\t\tksm_stable_node_chains++;\n\n\t\t/*\n\t\t * Put the stable node chain in the first dimension of\n\t\t * the stable tree and at the same time remove the old\n\t\t * stable node.\n\t\t */\n\t\trb_replace_node(&dup->node, &chain->node, root);\n\n\t\t/*\n\t\t * Move the old stable node to the second dimension\n\t\t * queued in the hlist_dup. The invariant is that all\n\t\t * dup stable_nodes in the chain->hlist point to pages\n\t\t * that are wrprotected and have the exact same\n\t\t * content.\n\t\t */\n\t\tstable_node_chain_add_dup(dup, chain);\n\t}\n\treturn chain;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "is_stable_node_dup(stable_node_dup)"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "is_stable_node_chain(stable_node_dup)"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&stable_node_dup->list",
            "stable_node_dup->head"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_page_sharing_candidate",
          "args": [
            "page_node"
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "is_page_sharing_candidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1352-1356",
          "snippet": "static __always_inline\nbool is_page_sharing_candidate(struct stable_node *stable_node)\n{\n\treturn __is_page_sharing_candidate(stable_node, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic __always_inline\nbool is_page_sharing_candidate(struct stable_node *stable_node)\n{\n\treturn __is_page_sharing_candidate(stable_node, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DO_NUMA",
          "args": [
            "page_node->nid = nid"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page_node->list"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "page_node->head != &migrate_nodes"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__stable_node_dup_del",
          "args": [
            "stable_node_dup"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "__stable_node_dup_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "358-363",
          "snippet": "static inline void __stable_node_dup_del(struct stable_node *dup)\n{\n\tVM_BUG_ON(!is_stable_node_dup(dup));\n\thlist_del(&dup->hlist_dup);\n\tksm_stable_node_dups--;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long ksm_stable_node_dups;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic unsigned long ksm_stable_node_dups;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void __stable_node_dup_del(struct stable_node *dup)\n{\n\tVM_BUG_ON(!is_stable_node_dup(dup));\n\thlist_del(&dup->hlist_dup);\n\tksm_stable_node_dups--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!is_stable_node_chain(stable_node)"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&stable_node_dup->node",
            "root"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "vma_rb_erase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "479-489",
          "snippet": "static __always_inline void vma_rb_erase(struct vm_area_struct *vma,\n\t\t\t\t\t struct rb_root *root)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the vma being erased.\n\t */\n\tvalidate_mm_rb(root, vma);\n\n\t__vma_rb_erase(vma, root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic __always_inline void vma_rb_erase(struct vm_area_struct *vma,\n\t\t\t\t\t struct rb_root *root)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the vma being erased.\n\t */\n\tvalidate_mm_rb(root, vma);\n\n\t__vma_rb_erase(vma, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_replace_node",
          "args": [
            "&stable_node_dup->node",
            "&page_node->node",
            "root"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_NUMA",
          "args": [
            "page_node->nid = nid"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page_node->list"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "page_node->head != &migrate_nodes"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "is_stable_node_dup(stable_node_dup)"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "is_stable_node_chain(stable_node_dup)"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&page_node->node",
            "root"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&page_node->node",
            "parent",
            "new"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_NUMA",
          "args": [
            "page_node->nid = nid"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page_node->list"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "tree_page"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NUMA",
          "args": [
            "stable_node_dup->nid"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_kpfn_nid",
          "args": [
            "stable_node_dup->kpfn"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "get_kpfn_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "585-588",
          "snippet": "static inline int get_kpfn_nid(unsigned long kpfn)\n{\n\treturn ksm_merge_across_nodes ? 0 : NUMA(pfn_to_nid(kpfn));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define ksm_merge_across_nodes\t1U"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define ksm_merge_across_nodes\t1U\n\nstatic inline int get_kpfn_nid(unsigned long kpfn)\n{\n\treturn ksm_merge_across_nodes ? 0 : NUMA(pfn_to_nid(kpfn));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "tree_page"
          ],
          "line": 1685
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tree_page"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ksm_page",
          "args": [
            "stable_node_dup",
            "true"
          ],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "get_ksm_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "688-752",
          "snippet": "static struct page *get_ksm_page(struct stable_node *stable_node, bool lock_it)\n{\n\tstruct page *page;\n\tvoid *expected_mapping;\n\tunsigned long kpfn;\n\n\texpected_mapping = (void *)((unsigned long)stable_node |\n\t\t\t\t\tPAGE_MAPPING_KSM);\nagain:\n\tkpfn = READ_ONCE(stable_node->kpfn); /* Address dependency. */\n\tpage = pfn_to_page(kpfn);\n\tif (READ_ONCE(page->mapping) != expected_mapping)\n\t\tgoto stale;\n\n\t/*\n\t * We cannot do anything with the page while its refcount is 0.\n\t * Usually 0 means free, or tail of a higher-order page: in which\n\t * case this node is no longer referenced, and should be freed;\n\t * however, it might mean that the page is under page_ref_freeze().\n\t * The __remove_mapping() case is easy, again the node is now stale;\n\t * but if page is swapcache in migrate_page_move_mapping(), it might\n\t * still be our page, in which case it's essential to keep the node.\n\t */\n\twhile (!get_page_unless_zero(page)) {\n\t\t/*\n\t\t * Another check for page->mapping != expected_mapping would\n\t\t * work here too.  We have chosen the !PageSwapCache test to\n\t\t * optimize the common case, when the page is or is about to\n\t\t * be freed: PageSwapCache is cleared (under spin_lock_irq)\n\t\t * in the ref_freeze section of __remove_mapping(); but Anon\n\t\t * page->mapping reset to NULL later, in free_pages_prepare().\n\t\t */\n\t\tif (!PageSwapCache(page))\n\t\t\tgoto stale;\n\t\tcpu_relax();\n\t}\n\n\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\tput_page(page);\n\t\tgoto stale;\n\t}\n\n\tif (lock_it) {\n\t\tlock_page(page);\n\t\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto stale;\n\t\t}\n\t}\n\treturn page;\n\nstale:\n\t/*\n\t * We come here from above when page->mapping or !PageSwapCache\n\t * suggests that the node is stale; but it might be under migration.\n\t * We need smp_rmb(), matching the smp_wmb() in ksm_migrate_page(),\n\t * before checking whether node->kpfn has been changed.\n\t */\n\tsmp_rmb();\n\tif (READ_ONCE(stable_node->kpfn) != kpfn)\n\t\tgoto again;\n\tremove_node_from_stable_tree(stable_node);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct page *get_ksm_page(struct stable_node *stable_node, bool lock_it)\n{\n\tstruct page *page;\n\tvoid *expected_mapping;\n\tunsigned long kpfn;\n\n\texpected_mapping = (void *)((unsigned long)stable_node |\n\t\t\t\t\tPAGE_MAPPING_KSM);\nagain:\n\tkpfn = READ_ONCE(stable_node->kpfn); /* Address dependency. */\n\tpage = pfn_to_page(kpfn);\n\tif (READ_ONCE(page->mapping) != expected_mapping)\n\t\tgoto stale;\n\n\t/*\n\t * We cannot do anything with the page while its refcount is 0.\n\t * Usually 0 means free, or tail of a higher-order page: in which\n\t * case this node is no longer referenced, and should be freed;\n\t * however, it might mean that the page is under page_ref_freeze().\n\t * The __remove_mapping() case is easy, again the node is now stale;\n\t * but if page is swapcache in migrate_page_move_mapping(), it might\n\t * still be our page, in which case it's essential to keep the node.\n\t */\n\twhile (!get_page_unless_zero(page)) {\n\t\t/*\n\t\t * Another check for page->mapping != expected_mapping would\n\t\t * work here too.  We have chosen the !PageSwapCache test to\n\t\t * optimize the common case, when the page is or is about to\n\t\t * be freed: PageSwapCache is cleared (under spin_lock_irq)\n\t\t * in the ref_freeze section of __remove_mapping(); but Anon\n\t\t * page->mapping reset to NULL later, in free_pages_prepare().\n\t\t */\n\t\tif (!PageSwapCache(page))\n\t\t\tgoto stale;\n\t\tcpu_relax();\n\t}\n\n\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\tput_page(page);\n\t\tgoto stale;\n\t}\n\n\tif (lock_it) {\n\t\tlock_page(page);\n\t\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto stale;\n\t\t}\n\t}\n\treturn page;\n\nstale:\n\t/*\n\t * We come here from above when page->mapping or !PageSwapCache\n\t * suggests that the node is stale; but it might be under migration.\n\t * We need smp_rmb(), matching the smp_wmb() in ksm_migrate_page(),\n\t * before checking whether node->kpfn has been changed.\n\t */\n\tsmp_rmb();\n\tif (READ_ONCE(stable_node->kpfn) != kpfn)\n\t\tgoto again;\n\tremove_node_from_stable_tree(stable_node);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "page"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "page_node->head != &migrate_nodes"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp_pages",
          "args": [
            "page",
            "tree_page"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "memcmp_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1017-1028",
          "snippet": "static int memcmp_pages(struct page *page1, struct page *page2)\n{\n\tchar *addr1, *addr2;\n\tint ret;\n\n\taddr1 = kmap_atomic(page1);\n\taddr2 = kmap_atomic(page2);\n\tret = memcmp(addr1, addr2, PAGE_SIZE);\n\tkunmap_atomic(addr2);\n\tkunmap_atomic(addr1);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int memcmp_pages(struct page *page1, struct page *page2)\n{\n\tchar *addr1, *addr2;\n\tint ret;\n\n\taddr1 = kmap_atomic(page1);\n\taddr2 = kmap_atomic(page2);\n\tret = memcmp(addr1, addr2, PAGE_SIZE);\n\tkunmap_atomic(addr2);\n\tkunmap_atomic(addr1);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!stable_node_dup ^ !!stable_node_any"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stable_node_dup_any",
          "args": [
            "stable_node",
            "root"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "stable_node_dup_any",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1477-1488",
          "snippet": "static struct stable_node *stable_node_dup_any(struct stable_node *stable_node,\n\t\t\t\t\t       struct rb_root *root)\n{\n\tif (!is_stable_node_chain(stable_node))\n\t\treturn stable_node;\n\tif (hlist_empty(&stable_node->hlist)) {\n\t\tfree_stable_node_chain(stable_node, root);\n\t\treturn NULL;\n\t}\n\treturn hlist_entry(stable_node->hlist.first,\n\t\t\t   typeof(*stable_node), hlist_dup);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct stable_node *stable_node_dup_any(struct stable_node *stable_node,\n\t\t\t\t\t       struct rb_root *root)\n{\n\tif (!is_stable_node_chain(stable_node))\n\t\treturn stable_node;\n\tif (hlist_empty(&stable_node->hlist)) {\n\t\tfree_stable_node_chain(stable_node, root);\n\t\treturn NULL;\n\t}\n\treturn hlist_entry(stable_node->hlist.first,\n\t\t\t   typeof(*stable_node), hlist_dup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chain_prune",
          "args": [
            "&stable_node_dup",
            "&stable_node",
            "root"
          ],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "chain_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1526-1531",
          "snippet": "page *chain_prune(struct stable_node **s_n_d,\n\t\t\t\t\t\tstruct stable_node **s_n,\n\t\t\t\t\t\tstruct rb_root *root)\n{\n\treturn __stable_node_chain(s_n_d, s_n, root, true);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\npage *chain_prune(struct stable_node **s_n_d,\n\t\t\t\t\t\tstruct stable_node **s_n,\n\t\t\t\t\t\tstruct rb_root *root)\n{\n\treturn __stable_node_chain(s_n_d, s_n, root, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "*new",
            "structstable_node",
            "node"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_stable_node",
          "args": [
            "page"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "page_stable_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "845-848",
          "snippet": "static inline struct stable_node *page_stable_node(struct page *page)\n{\n\treturn PageKsm(page) ? page_rmapping(page) : NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline struct stable_node *page_stable_node(struct page *page)\n{\n\treturn PageKsm(page) ? page_rmapping(page) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct rb_root *root_stable_tree = one_stable_tree;\nstatic LIST_HEAD(migrate_nodes);\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct page *stable_tree_search(struct page *page)\n{\n\tint nid;\n\tstruct rb_root *root;\n\tstruct rb_node **new;\n\tstruct rb_node *parent;\n\tstruct stable_node *stable_node, *stable_node_dup, *stable_node_any;\n\tstruct stable_node *page_node;\n\n\tpage_node = page_stable_node(page);\n\tif (page_node && page_node->head != &migrate_nodes) {\n\t\t/* ksm page forked */\n\t\tget_page(page);\n\t\treturn page;\n\t}\n\n\tnid = get_kpfn_nid(page_to_pfn(page));\n\troot = root_stable_tree + nid;\nagain:\n\tnew = &root->rb_node;\n\tparent = NULL;\n\n\twhile (*new) {\n\t\tstruct page *tree_page;\n\t\tint ret;\n\n\t\tcond_resched();\n\t\tstable_node = rb_entry(*new, struct stable_node, node);\n\t\tstable_node_any = NULL;\n\t\ttree_page = chain_prune(&stable_node_dup, &stable_node,\troot);\n\t\t/*\n\t\t * NOTE: stable_node may have been freed by\n\t\t * chain_prune() if the returned stable_node_dup is\n\t\t * not NULL. stable_node_dup may have been inserted in\n\t\t * the rbtree instead as a regular stable_node (in\n\t\t * order to collapse the stable_node chain if a single\n\t\t * stable_node dup was found in it). In such case the\n\t\t * stable_node is overwritten by the calleee to point\n\t\t * to the stable_node_dup that was collapsed in the\n\t\t * stable rbtree and stable_node will be equal to\n\t\t * stable_node_dup like if the chain never existed.\n\t\t */\n\t\tif (!stable_node_dup) {\n\t\t\t/*\n\t\t\t * Either all stable_node dups were full in\n\t\t\t * this stable_node chain, or this chain was\n\t\t\t * empty and should be rb_erased.\n\t\t\t */\n\t\t\tstable_node_any = stable_node_dup_any(stable_node,\n\t\t\t\t\t\t\t      root);\n\t\t\tif (!stable_node_any) {\n\t\t\t\t/* rb_erase just run */\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Take any of the stable_node dups page of\n\t\t\t * this stable_node chain to let the tree walk\n\t\t\t * continue. All KSM pages belonging to the\n\t\t\t * stable_node dups in a stable_node chain\n\t\t\t * have the same content and they're\n\t\t\t * wrprotected at all times. Any will work\n\t\t\t * fine to continue the walk.\n\t\t\t */\n\t\t\ttree_page = get_ksm_page(stable_node_any, false);\n\t\t}\n\t\tVM_BUG_ON(!stable_node_dup ^ !!stable_node_any);\n\t\tif (!tree_page) {\n\t\t\t/*\n\t\t\t * If we walked over a stale stable_node,\n\t\t\t * get_ksm_page() will call rb_erase() and it\n\t\t\t * may rebalance the tree from under us. So\n\t\t\t * restart the search from scratch. Returning\n\t\t\t * NULL would be safe too, but we'd generate\n\t\t\t * false negative insertions just because some\n\t\t\t * stable_node was stale.\n\t\t\t */\n\t\t\tgoto again;\n\t\t}\n\n\t\tret = memcmp_pages(page, tree_page);\n\t\tput_page(tree_page);\n\n\t\tparent = *new;\n\t\tif (ret < 0)\n\t\t\tnew = &parent->rb_left;\n\t\telse if (ret > 0)\n\t\t\tnew = &parent->rb_right;\n\t\telse {\n\t\t\tif (page_node) {\n\t\t\t\tVM_BUG_ON(page_node->head != &migrate_nodes);\n\t\t\t\t/*\n\t\t\t\t * Test if the migrated page should be merged\n\t\t\t\t * into a stable node dup. If the mapcount is\n\t\t\t\t * 1 we can migrate it with another KSM page\n\t\t\t\t * without adding it to the chain.\n\t\t\t\t */\n\t\t\t\tif (page_mapcount(page) > 1)\n\t\t\t\t\tgoto chain_append;\n\t\t\t}\n\n\t\t\tif (!stable_node_dup) {\n\t\t\t\t/*\n\t\t\t\t * If the stable_node is a chain and\n\t\t\t\t * we got a payload match in memcmp\n\t\t\t\t * but we cannot merge the scanned\n\t\t\t\t * page in any of the existing\n\t\t\t\t * stable_node dups because they're\n\t\t\t\t * all full, we need to wait the\n\t\t\t\t * scanned page to find itself a match\n\t\t\t\t * in the unstable tree to create a\n\t\t\t\t * brand new KSM page to add later to\n\t\t\t\t * the dups of this stable_node.\n\t\t\t\t */\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Lock and unlock the stable_node's page (which\n\t\t\t * might already have been migrated) so that page\n\t\t\t * migration is sure to notice its raised count.\n\t\t\t * It would be more elegant to return stable_node\n\t\t\t * than kpage, but that involves more changes.\n\t\t\t */\n\t\t\ttree_page = get_ksm_page(stable_node_dup, true);\n\t\t\tif (unlikely(!tree_page))\n\t\t\t\t/*\n\t\t\t\t * The tree may have been rebalanced,\n\t\t\t\t * so re-evaluate parent and new.\n\t\t\t\t */\n\t\t\t\tgoto again;\n\t\t\tunlock_page(tree_page);\n\n\t\t\tif (get_kpfn_nid(stable_node_dup->kpfn) !=\n\t\t\t    NUMA(stable_node_dup->nid)) {\n\t\t\t\tput_page(tree_page);\n\t\t\t\tgoto replace;\n\t\t\t}\n\t\t\treturn tree_page;\n\t\t}\n\t}\n\n\tif (!page_node)\n\t\treturn NULL;\n\n\tlist_del(&page_node->list);\n\tDO_NUMA(page_node->nid = nid);\n\trb_link_node(&page_node->node, parent, new);\n\trb_insert_color(&page_node->node, root);\nout:\n\tif (is_page_sharing_candidate(page_node)) {\n\t\tget_page(page);\n\t\treturn page;\n\t} else\n\t\treturn NULL;\n\nreplace:\n\t/*\n\t * If stable_node was a chain and chain_prune collapsed it,\n\t * stable_node has been updated to be the new regular\n\t * stable_node. A collapse of the chain is indistinguishable\n\t * from the case there was no chain in the stable\n\t * rbtree. Otherwise stable_node is the chain and\n\t * stable_node_dup is the dup to replace.\n\t */\n\tif (stable_node_dup == stable_node) {\n\t\tVM_BUG_ON(is_stable_node_chain(stable_node_dup));\n\t\tVM_BUG_ON(is_stable_node_dup(stable_node_dup));\n\t\t/* there is no chain */\n\t\tif (page_node) {\n\t\t\tVM_BUG_ON(page_node->head != &migrate_nodes);\n\t\t\tlist_del(&page_node->list);\n\t\t\tDO_NUMA(page_node->nid = nid);\n\t\t\trb_replace_node(&stable_node_dup->node,\n\t\t\t\t\t&page_node->node,\n\t\t\t\t\troot);\n\t\t\tif (is_page_sharing_candidate(page_node))\n\t\t\t\tget_page(page);\n\t\t\telse\n\t\t\t\tpage = NULL;\n\t\t} else {\n\t\t\trb_erase(&stable_node_dup->node, root);\n\t\t\tpage = NULL;\n\t\t}\n\t} else {\n\t\tVM_BUG_ON(!is_stable_node_chain(stable_node));\n\t\t__stable_node_dup_del(stable_node_dup);\n\t\tif (page_node) {\n\t\t\tVM_BUG_ON(page_node->head != &migrate_nodes);\n\t\t\tlist_del(&page_node->list);\n\t\t\tDO_NUMA(page_node->nid = nid);\n\t\t\tstable_node_chain_add_dup(page_node, stable_node);\n\t\t\tif (is_page_sharing_candidate(page_node))\n\t\t\t\tget_page(page);\n\t\t\telse\n\t\t\t\tpage = NULL;\n\t\t} else {\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\tstable_node_dup->head = &migrate_nodes;\n\tlist_add(&stable_node_dup->list, stable_node_dup->head);\n\treturn page;\n\nchain_append:\n\t/* stable_node_dup could be null if it reached the limit */\n\tif (!stable_node_dup)\n\t\tstable_node_dup = stable_node_any;\n\t/*\n\t * If stable_node was a chain and chain_prune collapsed it,\n\t * stable_node has been updated to be the new regular\n\t * stable_node. A collapse of the chain is indistinguishable\n\t * from the case there was no chain in the stable\n\t * rbtree. Otherwise stable_node is the chain and\n\t * stable_node_dup is the dup to replace.\n\t */\n\tif (stable_node_dup == stable_node) {\n\t\tVM_BUG_ON(is_stable_node_chain(stable_node_dup));\n\t\tVM_BUG_ON(is_stable_node_dup(stable_node_dup));\n\t\t/* chain is missing so create it */\n\t\tstable_node = alloc_stable_node_chain(stable_node_dup,\n\t\t\t\t\t\t      root);\n\t\tif (!stable_node)\n\t\t\treturn NULL;\n\t}\n\t/*\n\t * Add this stable_node dup that was\n\t * migrated to the stable_node chain\n\t * of the current nid for this page\n\t * content.\n\t */\n\tVM_BUG_ON(!is_stable_node_chain(stable_node));\n\tVM_BUG_ON(!is_stable_node_dup(stable_node_dup));\n\tVM_BUG_ON(page_node->head != &migrate_nodes);\n\tlist_del(&page_node->list);\n\tDO_NUMA(page_node->nid = nid);\n\tstable_node_chain_add_dup(page_node, stable_node);\n\tgoto out;\n}"
  },
  {
    "function_name": "chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "1533-1544",
    "snippet": "page *chain(struct stable_node **s_n_d,\n\t\t\t\t\t  struct stable_node *s_n,\n\t\t\t\t\t  struct rb_root *root)\n{\n\tstruct stable_node *old_stable_node = s_n;\n\tstruct page *tree_page;\n\n\ttree_page = __stable_node_chain(s_n_d, &s_n, root, false);\n\t/* not pruning dups so s_n cannot have changed */\n\tVM_BUG_ON(s_n != old_stable_node);\n\treturn tree_page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "s_n != old_stable_node"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__stable_node_chain",
          "args": [
            "s_n_d",
            "&s_n",
            "root",
            "false"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "__stable_node_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1504-1524",
          "snippet": "static struct page *__stable_node_chain(struct stable_node **_stable_node_dup,\n\t\t\t\t\tstruct stable_node **_stable_node,\n\t\t\t\t\tstruct rb_root *root,\n\t\t\t\t\tbool prune_stale_stable_nodes)\n{\n\tstruct stable_node *stable_node = *_stable_node;\n\tif (!is_stable_node_chain(stable_node)) {\n\t\tif (is_page_sharing_candidate(stable_node)) {\n\t\t\t*_stable_node_dup = stable_node;\n\t\t\treturn get_ksm_page(stable_node, false);\n\t\t}\n\t\t/*\n\t\t * _stable_node_dup set to NULL means the stable_node\n\t\t * reached the ksm_max_page_sharing limit.\n\t\t */\n\t\t*_stable_node_dup = NULL;\n\t\treturn NULL;\n\t}\n\treturn stable_node_dup(_stable_node_dup, _stable_node, root,\n\t\t\t       prune_stale_stable_nodes);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ksm_max_page_sharing = 256;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic int ksm_max_page_sharing = 256;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct page *__stable_node_chain(struct stable_node **_stable_node_dup,\n\t\t\t\t\tstruct stable_node **_stable_node,\n\t\t\t\t\tstruct rb_root *root,\n\t\t\t\t\tbool prune_stale_stable_nodes)\n{\n\tstruct stable_node *stable_node = *_stable_node;\n\tif (!is_stable_node_chain(stable_node)) {\n\t\tif (is_page_sharing_candidate(stable_node)) {\n\t\t\t*_stable_node_dup = stable_node;\n\t\t\treturn get_ksm_page(stable_node, false);\n\t\t}\n\t\t/*\n\t\t * _stable_node_dup set to NULL means the stable_node\n\t\t * reached the ksm_max_page_sharing limit.\n\t\t */\n\t\t*_stable_node_dup = NULL;\n\t\treturn NULL;\n\t}\n\treturn stable_node_dup(_stable_node_dup, _stable_node, root,\n\t\t\t       prune_stale_stable_nodes);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\npage *chain(struct stable_node **s_n_d,\n\t\t\t\t\t  struct stable_node *s_n,\n\t\t\t\t\t  struct rb_root *root)\n{\n\tstruct stable_node *old_stable_node = s_n;\n\tstruct page *tree_page;\n\n\ttree_page = __stable_node_chain(s_n_d, &s_n, root, false);\n\t/* not pruning dups so s_n cannot have changed */\n\tVM_BUG_ON(s_n != old_stable_node);\n\treturn tree_page;\n}"
  },
  {
    "function_name": "chain_prune",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "1526-1531",
    "snippet": "page *chain_prune(struct stable_node **s_n_d,\n\t\t\t\t\t\tstruct stable_node **s_n,\n\t\t\t\t\t\tstruct rb_root *root)\n{\n\treturn __stable_node_chain(s_n_d, s_n, root, true);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__stable_node_chain",
          "args": [
            "s_n_d",
            "s_n",
            "root",
            "true"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "__stable_node_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1504-1524",
          "snippet": "static struct page *__stable_node_chain(struct stable_node **_stable_node_dup,\n\t\t\t\t\tstruct stable_node **_stable_node,\n\t\t\t\t\tstruct rb_root *root,\n\t\t\t\t\tbool prune_stale_stable_nodes)\n{\n\tstruct stable_node *stable_node = *_stable_node;\n\tif (!is_stable_node_chain(stable_node)) {\n\t\tif (is_page_sharing_candidate(stable_node)) {\n\t\t\t*_stable_node_dup = stable_node;\n\t\t\treturn get_ksm_page(stable_node, false);\n\t\t}\n\t\t/*\n\t\t * _stable_node_dup set to NULL means the stable_node\n\t\t * reached the ksm_max_page_sharing limit.\n\t\t */\n\t\t*_stable_node_dup = NULL;\n\t\treturn NULL;\n\t}\n\treturn stable_node_dup(_stable_node_dup, _stable_node, root,\n\t\t\t       prune_stale_stable_nodes);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ksm_max_page_sharing = 256;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic int ksm_max_page_sharing = 256;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct page *__stable_node_chain(struct stable_node **_stable_node_dup,\n\t\t\t\t\tstruct stable_node **_stable_node,\n\t\t\t\t\tstruct rb_root *root,\n\t\t\t\t\tbool prune_stale_stable_nodes)\n{\n\tstruct stable_node *stable_node = *_stable_node;\n\tif (!is_stable_node_chain(stable_node)) {\n\t\tif (is_page_sharing_candidate(stable_node)) {\n\t\t\t*_stable_node_dup = stable_node;\n\t\t\treturn get_ksm_page(stable_node, false);\n\t\t}\n\t\t/*\n\t\t * _stable_node_dup set to NULL means the stable_node\n\t\t * reached the ksm_max_page_sharing limit.\n\t\t */\n\t\t*_stable_node_dup = NULL;\n\t\treturn NULL;\n\t}\n\treturn stable_node_dup(_stable_node_dup, _stable_node, root,\n\t\t\t       prune_stale_stable_nodes);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\npage *chain_prune(struct stable_node **s_n_d,\n\t\t\t\t\t\tstruct stable_node **s_n,\n\t\t\t\t\t\tstruct rb_root *root)\n{\n\treturn __stable_node_chain(s_n_d, s_n, root, true);\n}"
  },
  {
    "function_name": "__stable_node_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "1504-1524",
    "snippet": "static struct page *__stable_node_chain(struct stable_node **_stable_node_dup,\n\t\t\t\t\tstruct stable_node **_stable_node,\n\t\t\t\t\tstruct rb_root *root,\n\t\t\t\t\tbool prune_stale_stable_nodes)\n{\n\tstruct stable_node *stable_node = *_stable_node;\n\tif (!is_stable_node_chain(stable_node)) {\n\t\tif (is_page_sharing_candidate(stable_node)) {\n\t\t\t*_stable_node_dup = stable_node;\n\t\t\treturn get_ksm_page(stable_node, false);\n\t\t}\n\t\t/*\n\t\t * _stable_node_dup set to NULL means the stable_node\n\t\t * reached the ksm_max_page_sharing limit.\n\t\t */\n\t\t*_stable_node_dup = NULL;\n\t\treturn NULL;\n\t}\n\treturn stable_node_dup(_stable_node_dup, _stable_node, root,\n\t\t\t       prune_stale_stable_nodes);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ksm_max_page_sharing = 256;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stable_node_dup",
          "args": [
            "_stable_node_dup",
            "_stable_node",
            "root",
            "prune_stale_stable_nodes"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "stable_node_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1358-1475",
          "snippet": "static struct page *stable_node_dup(struct stable_node **_stable_node_dup,\n\t\t\t\t    struct stable_node **_stable_node,\n\t\t\t\t    struct rb_root *root,\n\t\t\t\t    bool prune_stale_stable_nodes)\n{\n\tstruct stable_node *dup, *found = NULL, *stable_node = *_stable_node;\n\tstruct hlist_node *hlist_safe;\n\tstruct page *_tree_page, *tree_page = NULL;\n\tint nr = 0;\n\tint found_rmap_hlist_len;\n\n\tif (!prune_stale_stable_nodes ||\n\t    time_before(jiffies, stable_node->chain_prune_time +\n\t\t\tmsecs_to_jiffies(\n\t\t\t\tksm_stable_node_chains_prune_millisecs)))\n\t\tprune_stale_stable_nodes = false;\n\telse\n\t\tstable_node->chain_prune_time = jiffies;\n\n\thlist_for_each_entry_safe(dup, hlist_safe,\n\t\t\t\t  &stable_node->hlist, hlist_dup) {\n\t\tcond_resched();\n\t\t/*\n\t\t * We must walk all stable_node_dup to prune the stale\n\t\t * stable nodes during lookup.\n\t\t *\n\t\t * get_ksm_page can drop the nodes from the\n\t\t * stable_node->hlist if they point to freed pages\n\t\t * (that's why we do a _safe walk). The \"dup\"\n\t\t * stable_node parameter itself will be freed from\n\t\t * under us if it returns NULL.\n\t\t */\n\t\t_tree_page = get_ksm_page(dup, false);\n\t\tif (!_tree_page)\n\t\t\tcontinue;\n\t\tnr += 1;\n\t\tif (is_page_sharing_candidate(dup)) {\n\t\t\tif (!found ||\n\t\t\t    dup->rmap_hlist_len > found_rmap_hlist_len) {\n\t\t\t\tif (found)\n\t\t\t\t\tput_page(tree_page);\n\t\t\t\tfound = dup;\n\t\t\t\tfound_rmap_hlist_len = found->rmap_hlist_len;\n\t\t\t\ttree_page = _tree_page;\n\n\t\t\t\t/* skip put_page for found dup */\n\t\t\t\tif (!prune_stale_stable_nodes)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tput_page(_tree_page);\n\t}\n\n\tif (found) {\n\t\t/*\n\t\t * nr is counting all dups in the chain only if\n\t\t * prune_stale_stable_nodes is true, otherwise we may\n\t\t * break the loop at nr == 1 even if there are\n\t\t * multiple entries.\n\t\t */\n\t\tif (prune_stale_stable_nodes && nr == 1) {\n\t\t\t/*\n\t\t\t * If there's not just one entry it would\n\t\t\t * corrupt memory, better BUG_ON. In KSM\n\t\t\t * context with no lock held it's not even\n\t\t\t * fatal.\n\t\t\t */\n\t\t\tBUG_ON(stable_node->hlist.first->next);\n\n\t\t\t/*\n\t\t\t * There's just one entry and it is below the\n\t\t\t * deduplication limit so drop the chain.\n\t\t\t */\n\t\t\trb_replace_node(&stable_node->node, &found->node,\n\t\t\t\t\troot);\n\t\t\tfree_stable_node(stable_node);\n\t\t\tksm_stable_node_chains--;\n\t\t\tksm_stable_node_dups--;\n\t\t\t/*\n\t\t\t * NOTE: the caller depends on the stable_node\n\t\t\t * to be equal to stable_node_dup if the chain\n\t\t\t * was collapsed.\n\t\t\t */\n\t\t\t*_stable_node = found;\n\t\t\t/*\n\t\t\t * Just for robustneess as stable_node is\n\t\t\t * otherwise left as a stable pointer, the\n\t\t\t * compiler shall optimize it away at build\n\t\t\t * time.\n\t\t\t */\n\t\t\tstable_node = NULL;\n\t\t} else if (stable_node->hlist.first != &found->hlist_dup &&\n\t\t\t   __is_page_sharing_candidate(found, 1)) {\n\t\t\t/*\n\t\t\t * If the found stable_node dup can accept one\n\t\t\t * more future merge (in addition to the one\n\t\t\t * that is underway) and is not at the head of\n\t\t\t * the chain, put it there so next search will\n\t\t\t * be quicker in the !prune_stale_stable_nodes\n\t\t\t * case.\n\t\t\t *\n\t\t\t * NOTE: it would be inaccurate to use nr > 1\n\t\t\t * instead of checking the hlist.first pointer\n\t\t\t * directly, because in the\n\t\t\t * prune_stale_stable_nodes case \"nr\" isn't\n\t\t\t * the position of the found dup in the chain,\n\t\t\t * but the total number of dups in the chain.\n\t\t\t */\n\t\t\thlist_del(&found->hlist_dup);\n\t\t\thlist_add_head(&found->hlist_dup,\n\t\t\t\t       &stable_node->hlist);\n\t\t}\n\t}\n\n\t*_stable_node_dup = found;\n\treturn tree_page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long ksm_stable_node_chains;",
            "static unsigned long ksm_stable_node_dups;",
            "static int ksm_stable_node_chains_prune_millisecs = 2000;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic unsigned long ksm_stable_node_chains;\nstatic unsigned long ksm_stable_node_dups;\nstatic int ksm_stable_node_chains_prune_millisecs = 2000;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct page *stable_node_dup(struct stable_node **_stable_node_dup,\n\t\t\t\t    struct stable_node **_stable_node,\n\t\t\t\t    struct rb_root *root,\n\t\t\t\t    bool prune_stale_stable_nodes)\n{\n\tstruct stable_node *dup, *found = NULL, *stable_node = *_stable_node;\n\tstruct hlist_node *hlist_safe;\n\tstruct page *_tree_page, *tree_page = NULL;\n\tint nr = 0;\n\tint found_rmap_hlist_len;\n\n\tif (!prune_stale_stable_nodes ||\n\t    time_before(jiffies, stable_node->chain_prune_time +\n\t\t\tmsecs_to_jiffies(\n\t\t\t\tksm_stable_node_chains_prune_millisecs)))\n\t\tprune_stale_stable_nodes = false;\n\telse\n\t\tstable_node->chain_prune_time = jiffies;\n\n\thlist_for_each_entry_safe(dup, hlist_safe,\n\t\t\t\t  &stable_node->hlist, hlist_dup) {\n\t\tcond_resched();\n\t\t/*\n\t\t * We must walk all stable_node_dup to prune the stale\n\t\t * stable nodes during lookup.\n\t\t *\n\t\t * get_ksm_page can drop the nodes from the\n\t\t * stable_node->hlist if they point to freed pages\n\t\t * (that's why we do a _safe walk). The \"dup\"\n\t\t * stable_node parameter itself will be freed from\n\t\t * under us if it returns NULL.\n\t\t */\n\t\t_tree_page = get_ksm_page(dup, false);\n\t\tif (!_tree_page)\n\t\t\tcontinue;\n\t\tnr += 1;\n\t\tif (is_page_sharing_candidate(dup)) {\n\t\t\tif (!found ||\n\t\t\t    dup->rmap_hlist_len > found_rmap_hlist_len) {\n\t\t\t\tif (found)\n\t\t\t\t\tput_page(tree_page);\n\t\t\t\tfound = dup;\n\t\t\t\tfound_rmap_hlist_len = found->rmap_hlist_len;\n\t\t\t\ttree_page = _tree_page;\n\n\t\t\t\t/* skip put_page for found dup */\n\t\t\t\tif (!prune_stale_stable_nodes)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tput_page(_tree_page);\n\t}\n\n\tif (found) {\n\t\t/*\n\t\t * nr is counting all dups in the chain only if\n\t\t * prune_stale_stable_nodes is true, otherwise we may\n\t\t * break the loop at nr == 1 even if there are\n\t\t * multiple entries.\n\t\t */\n\t\tif (prune_stale_stable_nodes && nr == 1) {\n\t\t\t/*\n\t\t\t * If there's not just one entry it would\n\t\t\t * corrupt memory, better BUG_ON. In KSM\n\t\t\t * context with no lock held it's not even\n\t\t\t * fatal.\n\t\t\t */\n\t\t\tBUG_ON(stable_node->hlist.first->next);\n\n\t\t\t/*\n\t\t\t * There's just one entry and it is below the\n\t\t\t * deduplication limit so drop the chain.\n\t\t\t */\n\t\t\trb_replace_node(&stable_node->node, &found->node,\n\t\t\t\t\troot);\n\t\t\tfree_stable_node(stable_node);\n\t\t\tksm_stable_node_chains--;\n\t\t\tksm_stable_node_dups--;\n\t\t\t/*\n\t\t\t * NOTE: the caller depends on the stable_node\n\t\t\t * to be equal to stable_node_dup if the chain\n\t\t\t * was collapsed.\n\t\t\t */\n\t\t\t*_stable_node = found;\n\t\t\t/*\n\t\t\t * Just for robustneess as stable_node is\n\t\t\t * otherwise left as a stable pointer, the\n\t\t\t * compiler shall optimize it away at build\n\t\t\t * time.\n\t\t\t */\n\t\t\tstable_node = NULL;\n\t\t} else if (stable_node->hlist.first != &found->hlist_dup &&\n\t\t\t   __is_page_sharing_candidate(found, 1)) {\n\t\t\t/*\n\t\t\t * If the found stable_node dup can accept one\n\t\t\t * more future merge (in addition to the one\n\t\t\t * that is underway) and is not at the head of\n\t\t\t * the chain, put it there so next search will\n\t\t\t * be quicker in the !prune_stale_stable_nodes\n\t\t\t * case.\n\t\t\t *\n\t\t\t * NOTE: it would be inaccurate to use nr > 1\n\t\t\t * instead of checking the hlist.first pointer\n\t\t\t * directly, because in the\n\t\t\t * prune_stale_stable_nodes case \"nr\" isn't\n\t\t\t * the position of the found dup in the chain,\n\t\t\t * but the total number of dups in the chain.\n\t\t\t */\n\t\t\thlist_del(&found->hlist_dup);\n\t\t\thlist_add_head(&found->hlist_dup,\n\t\t\t\t       &stable_node->hlist);\n\t\t}\n\t}\n\n\t*_stable_node_dup = found;\n\treturn tree_page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_ksm_page",
          "args": [
            "stable_node",
            "false"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "get_ksm_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "688-752",
          "snippet": "static struct page *get_ksm_page(struct stable_node *stable_node, bool lock_it)\n{\n\tstruct page *page;\n\tvoid *expected_mapping;\n\tunsigned long kpfn;\n\n\texpected_mapping = (void *)((unsigned long)stable_node |\n\t\t\t\t\tPAGE_MAPPING_KSM);\nagain:\n\tkpfn = READ_ONCE(stable_node->kpfn); /* Address dependency. */\n\tpage = pfn_to_page(kpfn);\n\tif (READ_ONCE(page->mapping) != expected_mapping)\n\t\tgoto stale;\n\n\t/*\n\t * We cannot do anything with the page while its refcount is 0.\n\t * Usually 0 means free, or tail of a higher-order page: in which\n\t * case this node is no longer referenced, and should be freed;\n\t * however, it might mean that the page is under page_ref_freeze().\n\t * The __remove_mapping() case is easy, again the node is now stale;\n\t * but if page is swapcache in migrate_page_move_mapping(), it might\n\t * still be our page, in which case it's essential to keep the node.\n\t */\n\twhile (!get_page_unless_zero(page)) {\n\t\t/*\n\t\t * Another check for page->mapping != expected_mapping would\n\t\t * work here too.  We have chosen the !PageSwapCache test to\n\t\t * optimize the common case, when the page is or is about to\n\t\t * be freed: PageSwapCache is cleared (under spin_lock_irq)\n\t\t * in the ref_freeze section of __remove_mapping(); but Anon\n\t\t * page->mapping reset to NULL later, in free_pages_prepare().\n\t\t */\n\t\tif (!PageSwapCache(page))\n\t\t\tgoto stale;\n\t\tcpu_relax();\n\t}\n\n\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\tput_page(page);\n\t\tgoto stale;\n\t}\n\n\tif (lock_it) {\n\t\tlock_page(page);\n\t\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto stale;\n\t\t}\n\t}\n\treturn page;\n\nstale:\n\t/*\n\t * We come here from above when page->mapping or !PageSwapCache\n\t * suggests that the node is stale; but it might be under migration.\n\t * We need smp_rmb(), matching the smp_wmb() in ksm_migrate_page(),\n\t * before checking whether node->kpfn has been changed.\n\t */\n\tsmp_rmb();\n\tif (READ_ONCE(stable_node->kpfn) != kpfn)\n\t\tgoto again;\n\tremove_node_from_stable_tree(stable_node);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct page *get_ksm_page(struct stable_node *stable_node, bool lock_it)\n{\n\tstruct page *page;\n\tvoid *expected_mapping;\n\tunsigned long kpfn;\n\n\texpected_mapping = (void *)((unsigned long)stable_node |\n\t\t\t\t\tPAGE_MAPPING_KSM);\nagain:\n\tkpfn = READ_ONCE(stable_node->kpfn); /* Address dependency. */\n\tpage = pfn_to_page(kpfn);\n\tif (READ_ONCE(page->mapping) != expected_mapping)\n\t\tgoto stale;\n\n\t/*\n\t * We cannot do anything with the page while its refcount is 0.\n\t * Usually 0 means free, or tail of a higher-order page: in which\n\t * case this node is no longer referenced, and should be freed;\n\t * however, it might mean that the page is under page_ref_freeze().\n\t * The __remove_mapping() case is easy, again the node is now stale;\n\t * but if page is swapcache in migrate_page_move_mapping(), it might\n\t * still be our page, in which case it's essential to keep the node.\n\t */\n\twhile (!get_page_unless_zero(page)) {\n\t\t/*\n\t\t * Another check for page->mapping != expected_mapping would\n\t\t * work here too.  We have chosen the !PageSwapCache test to\n\t\t * optimize the common case, when the page is or is about to\n\t\t * be freed: PageSwapCache is cleared (under spin_lock_irq)\n\t\t * in the ref_freeze section of __remove_mapping(); but Anon\n\t\t * page->mapping reset to NULL later, in free_pages_prepare().\n\t\t */\n\t\tif (!PageSwapCache(page))\n\t\t\tgoto stale;\n\t\tcpu_relax();\n\t}\n\n\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\tput_page(page);\n\t\tgoto stale;\n\t}\n\n\tif (lock_it) {\n\t\tlock_page(page);\n\t\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto stale;\n\t\t}\n\t}\n\treturn page;\n\nstale:\n\t/*\n\t * We come here from above when page->mapping or !PageSwapCache\n\t * suggests that the node is stale; but it might be under migration.\n\t * We need smp_rmb(), matching the smp_wmb() in ksm_migrate_page(),\n\t * before checking whether node->kpfn has been changed.\n\t */\n\tsmp_rmb();\n\tif (READ_ONCE(stable_node->kpfn) != kpfn)\n\t\tgoto again;\n\tremove_node_from_stable_tree(stable_node);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_page_sharing_candidate",
          "args": [
            "stable_node"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "is_page_sharing_candidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1352-1356",
          "snippet": "static __always_inline\nbool is_page_sharing_candidate(struct stable_node *stable_node)\n{\n\treturn __is_page_sharing_candidate(stable_node, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic __always_inline\nbool is_page_sharing_candidate(struct stable_node *stable_node)\n{\n\treturn __is_page_sharing_candidate(stable_node, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_stable_node_chain",
          "args": [
            "stable_node"
          ],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "is_stable_node_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "338-341",
          "snippet": "static __always_inline bool is_stable_node_chain(struct stable_node *chain)\n{\n\treturn chain->rmap_hlist_len == STABLE_NODE_CHAIN;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_NODE_CHAIN -1024"
          ],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_CHAIN -1024\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic __always_inline bool is_stable_node_chain(struct stable_node *chain)\n{\n\treturn chain->rmap_hlist_len == STABLE_NODE_CHAIN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic int ksm_max_page_sharing = 256;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct page *__stable_node_chain(struct stable_node **_stable_node_dup,\n\t\t\t\t\tstruct stable_node **_stable_node,\n\t\t\t\t\tstruct rb_root *root,\n\t\t\t\t\tbool prune_stale_stable_nodes)\n{\n\tstruct stable_node *stable_node = *_stable_node;\n\tif (!is_stable_node_chain(stable_node)) {\n\t\tif (is_page_sharing_candidate(stable_node)) {\n\t\t\t*_stable_node_dup = stable_node;\n\t\t\treturn get_ksm_page(stable_node, false);\n\t\t}\n\t\t/*\n\t\t * _stable_node_dup set to NULL means the stable_node\n\t\t * reached the ksm_max_page_sharing limit.\n\t\t */\n\t\t*_stable_node_dup = NULL;\n\t\treturn NULL;\n\t}\n\treturn stable_node_dup(_stable_node_dup, _stable_node, root,\n\t\t\t       prune_stale_stable_nodes);\n}"
  },
  {
    "function_name": "stable_node_dup_any",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "1477-1488",
    "snippet": "static struct stable_node *stable_node_dup_any(struct stable_node *stable_node,\n\t\t\t\t\t       struct rb_root *root)\n{\n\tif (!is_stable_node_chain(stable_node))\n\t\treturn stable_node;\n\tif (hlist_empty(&stable_node->hlist)) {\n\t\tfree_stable_node_chain(stable_node, root);\n\t\treturn NULL;\n\t}\n\treturn hlist_entry(stable_node->hlist.first,\n\t\t\t   typeof(*stable_node), hlist_dup);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "stable_node->hlist.first",
            "typeof(*stable_node)",
            "hlist_dup"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*stable_node"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_stable_node_chain",
          "args": [
            "stable_node",
            "root"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "free_stable_node_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "623-629",
          "snippet": "static inline void free_stable_node_chain(struct stable_node *chain,\n\t\t\t\t\t  struct rb_root *root)\n{\n\trb_erase(&chain->node, root);\n\tfree_stable_node(chain);\n\tksm_stable_node_chains--;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long ksm_stable_node_chains;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic unsigned long ksm_stable_node_chains;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void free_stable_node_chain(struct stable_node *chain,\n\t\t\t\t\t  struct rb_root *root)\n{\n\trb_erase(&chain->node, root);\n\tfree_stable_node(chain);\n\tksm_stable_node_chains--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&stable_node->hlist"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_stable_node_chain",
          "args": [
            "stable_node"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "is_stable_node_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "338-341",
          "snippet": "static __always_inline bool is_stable_node_chain(struct stable_node *chain)\n{\n\treturn chain->rmap_hlist_len == STABLE_NODE_CHAIN;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_NODE_CHAIN -1024"
          ],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_CHAIN -1024\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic __always_inline bool is_stable_node_chain(struct stable_node *chain)\n{\n\treturn chain->rmap_hlist_len == STABLE_NODE_CHAIN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct stable_node *stable_node_dup_any(struct stable_node *stable_node,\n\t\t\t\t\t       struct rb_root *root)\n{\n\tif (!is_stable_node_chain(stable_node))\n\t\treturn stable_node;\n\tif (hlist_empty(&stable_node->hlist)) {\n\t\tfree_stable_node_chain(stable_node, root);\n\t\treturn NULL;\n\t}\n\treturn hlist_entry(stable_node->hlist.first,\n\t\t\t   typeof(*stable_node), hlist_dup);\n}"
  },
  {
    "function_name": "stable_node_dup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "1358-1475",
    "snippet": "static struct page *stable_node_dup(struct stable_node **_stable_node_dup,\n\t\t\t\t    struct stable_node **_stable_node,\n\t\t\t\t    struct rb_root *root,\n\t\t\t\t    bool prune_stale_stable_nodes)\n{\n\tstruct stable_node *dup, *found = NULL, *stable_node = *_stable_node;\n\tstruct hlist_node *hlist_safe;\n\tstruct page *_tree_page, *tree_page = NULL;\n\tint nr = 0;\n\tint found_rmap_hlist_len;\n\n\tif (!prune_stale_stable_nodes ||\n\t    time_before(jiffies, stable_node->chain_prune_time +\n\t\t\tmsecs_to_jiffies(\n\t\t\t\tksm_stable_node_chains_prune_millisecs)))\n\t\tprune_stale_stable_nodes = false;\n\telse\n\t\tstable_node->chain_prune_time = jiffies;\n\n\thlist_for_each_entry_safe(dup, hlist_safe,\n\t\t\t\t  &stable_node->hlist, hlist_dup) {\n\t\tcond_resched();\n\t\t/*\n\t\t * We must walk all stable_node_dup to prune the stale\n\t\t * stable nodes during lookup.\n\t\t *\n\t\t * get_ksm_page can drop the nodes from the\n\t\t * stable_node->hlist if they point to freed pages\n\t\t * (that's why we do a _safe walk). The \"dup\"\n\t\t * stable_node parameter itself will be freed from\n\t\t * under us if it returns NULL.\n\t\t */\n\t\t_tree_page = get_ksm_page(dup, false);\n\t\tif (!_tree_page)\n\t\t\tcontinue;\n\t\tnr += 1;\n\t\tif (is_page_sharing_candidate(dup)) {\n\t\t\tif (!found ||\n\t\t\t    dup->rmap_hlist_len > found_rmap_hlist_len) {\n\t\t\t\tif (found)\n\t\t\t\t\tput_page(tree_page);\n\t\t\t\tfound = dup;\n\t\t\t\tfound_rmap_hlist_len = found->rmap_hlist_len;\n\t\t\t\ttree_page = _tree_page;\n\n\t\t\t\t/* skip put_page for found dup */\n\t\t\t\tif (!prune_stale_stable_nodes)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tput_page(_tree_page);\n\t}\n\n\tif (found) {\n\t\t/*\n\t\t * nr is counting all dups in the chain only if\n\t\t * prune_stale_stable_nodes is true, otherwise we may\n\t\t * break the loop at nr == 1 even if there are\n\t\t * multiple entries.\n\t\t */\n\t\tif (prune_stale_stable_nodes && nr == 1) {\n\t\t\t/*\n\t\t\t * If there's not just one entry it would\n\t\t\t * corrupt memory, better BUG_ON. In KSM\n\t\t\t * context with no lock held it's not even\n\t\t\t * fatal.\n\t\t\t */\n\t\t\tBUG_ON(stable_node->hlist.first->next);\n\n\t\t\t/*\n\t\t\t * There's just one entry and it is below the\n\t\t\t * deduplication limit so drop the chain.\n\t\t\t */\n\t\t\trb_replace_node(&stable_node->node, &found->node,\n\t\t\t\t\troot);\n\t\t\tfree_stable_node(stable_node);\n\t\t\tksm_stable_node_chains--;\n\t\t\tksm_stable_node_dups--;\n\t\t\t/*\n\t\t\t * NOTE: the caller depends on the stable_node\n\t\t\t * to be equal to stable_node_dup if the chain\n\t\t\t * was collapsed.\n\t\t\t */\n\t\t\t*_stable_node = found;\n\t\t\t/*\n\t\t\t * Just for robustneess as stable_node is\n\t\t\t * otherwise left as a stable pointer, the\n\t\t\t * compiler shall optimize it away at build\n\t\t\t * time.\n\t\t\t */\n\t\t\tstable_node = NULL;\n\t\t} else if (stable_node->hlist.first != &found->hlist_dup &&\n\t\t\t   __is_page_sharing_candidate(found, 1)) {\n\t\t\t/*\n\t\t\t * If the found stable_node dup can accept one\n\t\t\t * more future merge (in addition to the one\n\t\t\t * that is underway) and is not at the head of\n\t\t\t * the chain, put it there so next search will\n\t\t\t * be quicker in the !prune_stale_stable_nodes\n\t\t\t * case.\n\t\t\t *\n\t\t\t * NOTE: it would be inaccurate to use nr > 1\n\t\t\t * instead of checking the hlist.first pointer\n\t\t\t * directly, because in the\n\t\t\t * prune_stale_stable_nodes case \"nr\" isn't\n\t\t\t * the position of the found dup in the chain,\n\t\t\t * but the total number of dups in the chain.\n\t\t\t */\n\t\t\thlist_del(&found->hlist_dup);\n\t\t\thlist_add_head(&found->hlist_dup,\n\t\t\t\t       &stable_node->hlist);\n\t\t}\n\t}\n\n\t*_stable_node_dup = found;\n\treturn tree_page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long ksm_stable_node_chains;",
      "static unsigned long ksm_stable_node_dups;",
      "static int ksm_stable_node_chains_prune_millisecs = 2000;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&found->hlist_dup",
            "&stable_node->hlist"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "&found->hlist_dup"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__is_page_sharing_candidate",
          "args": [
            "found",
            "1"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "__is_page_sharing_candidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1338-1350",
          "snippet": "static __always_inline\nbool __is_page_sharing_candidate(struct stable_node *stable_node, int offset)\n{\n\tVM_BUG_ON(stable_node->rmap_hlist_len < 0);\n\t/*\n\t * Check that at least one mapping still exists, otherwise\n\t * there's no much point to merge and share with this\n\t * stable_node, as the underlying tree_page of the other\n\t * sharer is going to be freed soon.\n\t */\n\treturn stable_node->rmap_hlist_len &&\n\t\tstable_node->rmap_hlist_len + offset < ksm_max_page_sharing;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ksm_max_page_sharing = 256;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic int ksm_max_page_sharing = 256;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic __always_inline\nbool __is_page_sharing_candidate(struct stable_node *stable_node, int offset)\n{\n\tVM_BUG_ON(stable_node->rmap_hlist_len < 0);\n\t/*\n\t * Check that at least one mapping still exists, otherwise\n\t * there's no much point to merge and share with this\n\t * stable_node, as the underlying tree_page of the other\n\t * sharer is going to be freed soon.\n\t */\n\treturn stable_node->rmap_hlist_len &&\n\t\tstable_node->rmap_hlist_len + offset < ksm_max_page_sharing;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_stable_node",
          "args": [
            "stable_node"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "free_stable_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "405-410",
          "snippet": "static inline void free_stable_node(struct stable_node *stable_node)\n{\n\tVM_BUG_ON(stable_node->rmap_hlist_len &&\n\t\t  !is_stable_node_chain(stable_node));\n\tkmem_cache_free(stable_node_cache, stable_node);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *stable_node_cache;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct kmem_cache *stable_node_cache;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void free_stable_node(struct stable_node *stable_node)\n{\n\tVM_BUG_ON(stable_node->rmap_hlist_len &&\n\t\t  !is_stable_node_chain(stable_node));\n\tkmem_cache_free(stable_node_cache, stable_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_replace_node",
          "args": [
            "&stable_node->node",
            "&found->node",
            "root"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "stable_node->hlist.first->next"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "_tree_page"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_page_sharing_candidate",
          "args": [
            "dup"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "is_page_sharing_candidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1352-1356",
          "snippet": "static __always_inline\nbool is_page_sharing_candidate(struct stable_node *stable_node)\n{\n\treturn __is_page_sharing_candidate(stable_node, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic __always_inline\nbool is_page_sharing_candidate(struct stable_node *stable_node)\n{\n\treturn __is_page_sharing_candidate(stable_node, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_ksm_page",
          "args": [
            "dup",
            "false"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "get_ksm_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "688-752",
          "snippet": "static struct page *get_ksm_page(struct stable_node *stable_node, bool lock_it)\n{\n\tstruct page *page;\n\tvoid *expected_mapping;\n\tunsigned long kpfn;\n\n\texpected_mapping = (void *)((unsigned long)stable_node |\n\t\t\t\t\tPAGE_MAPPING_KSM);\nagain:\n\tkpfn = READ_ONCE(stable_node->kpfn); /* Address dependency. */\n\tpage = pfn_to_page(kpfn);\n\tif (READ_ONCE(page->mapping) != expected_mapping)\n\t\tgoto stale;\n\n\t/*\n\t * We cannot do anything with the page while its refcount is 0.\n\t * Usually 0 means free, or tail of a higher-order page: in which\n\t * case this node is no longer referenced, and should be freed;\n\t * however, it might mean that the page is under page_ref_freeze().\n\t * The __remove_mapping() case is easy, again the node is now stale;\n\t * but if page is swapcache in migrate_page_move_mapping(), it might\n\t * still be our page, in which case it's essential to keep the node.\n\t */\n\twhile (!get_page_unless_zero(page)) {\n\t\t/*\n\t\t * Another check for page->mapping != expected_mapping would\n\t\t * work here too.  We have chosen the !PageSwapCache test to\n\t\t * optimize the common case, when the page is or is about to\n\t\t * be freed: PageSwapCache is cleared (under spin_lock_irq)\n\t\t * in the ref_freeze section of __remove_mapping(); but Anon\n\t\t * page->mapping reset to NULL later, in free_pages_prepare().\n\t\t */\n\t\tif (!PageSwapCache(page))\n\t\t\tgoto stale;\n\t\tcpu_relax();\n\t}\n\n\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\tput_page(page);\n\t\tgoto stale;\n\t}\n\n\tif (lock_it) {\n\t\tlock_page(page);\n\t\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto stale;\n\t\t}\n\t}\n\treturn page;\n\nstale:\n\t/*\n\t * We come here from above when page->mapping or !PageSwapCache\n\t * suggests that the node is stale; but it might be under migration.\n\t * We need smp_rmb(), matching the smp_wmb() in ksm_migrate_page(),\n\t * before checking whether node->kpfn has been changed.\n\t */\n\tsmp_rmb();\n\tif (READ_ONCE(stable_node->kpfn) != kpfn)\n\t\tgoto again;\n\tremove_node_from_stable_tree(stable_node);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct page *get_ksm_page(struct stable_node *stable_node, bool lock_it)\n{\n\tstruct page *page;\n\tvoid *expected_mapping;\n\tunsigned long kpfn;\n\n\texpected_mapping = (void *)((unsigned long)stable_node |\n\t\t\t\t\tPAGE_MAPPING_KSM);\nagain:\n\tkpfn = READ_ONCE(stable_node->kpfn); /* Address dependency. */\n\tpage = pfn_to_page(kpfn);\n\tif (READ_ONCE(page->mapping) != expected_mapping)\n\t\tgoto stale;\n\n\t/*\n\t * We cannot do anything with the page while its refcount is 0.\n\t * Usually 0 means free, or tail of a higher-order page: in which\n\t * case this node is no longer referenced, and should be freed;\n\t * however, it might mean that the page is under page_ref_freeze().\n\t * The __remove_mapping() case is easy, again the node is now stale;\n\t * but if page is swapcache in migrate_page_move_mapping(), it might\n\t * still be our page, in which case it's essential to keep the node.\n\t */\n\twhile (!get_page_unless_zero(page)) {\n\t\t/*\n\t\t * Another check for page->mapping != expected_mapping would\n\t\t * work here too.  We have chosen the !PageSwapCache test to\n\t\t * optimize the common case, when the page is or is about to\n\t\t * be freed: PageSwapCache is cleared (under spin_lock_irq)\n\t\t * in the ref_freeze section of __remove_mapping(); but Anon\n\t\t * page->mapping reset to NULL later, in free_pages_prepare().\n\t\t */\n\t\tif (!PageSwapCache(page))\n\t\t\tgoto stale;\n\t\tcpu_relax();\n\t}\n\n\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\tput_page(page);\n\t\tgoto stale;\n\t}\n\n\tif (lock_it) {\n\t\tlock_page(page);\n\t\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto stale;\n\t\t}\n\t}\n\treturn page;\n\nstale:\n\t/*\n\t * We come here from above when page->mapping or !PageSwapCache\n\t * suggests that the node is stale; but it might be under migration.\n\t * We need smp_rmb(), matching the smp_wmb() in ksm_migrate_page(),\n\t * before checking whether node->kpfn has been changed.\n\t */\n\tsmp_rmb();\n\tif (READ_ONCE(stable_node->kpfn) != kpfn)\n\t\tgoto again;\n\tremove_node_from_stable_tree(stable_node);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "dup",
            "hlist_safe",
            "&stable_node->hlist",
            "hlist_dup"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "stable_node->chain_prune_time +\n\t\t\tmsecs_to_jiffies(\n\t\t\t\tksm_stable_node_chains_prune_millisecs)"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "ksm_stable_node_chains_prune_millisecs"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic unsigned long ksm_stable_node_chains;\nstatic unsigned long ksm_stable_node_dups;\nstatic int ksm_stable_node_chains_prune_millisecs = 2000;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct page *stable_node_dup(struct stable_node **_stable_node_dup,\n\t\t\t\t    struct stable_node **_stable_node,\n\t\t\t\t    struct rb_root *root,\n\t\t\t\t    bool prune_stale_stable_nodes)\n{\n\tstruct stable_node *dup, *found = NULL, *stable_node = *_stable_node;\n\tstruct hlist_node *hlist_safe;\n\tstruct page *_tree_page, *tree_page = NULL;\n\tint nr = 0;\n\tint found_rmap_hlist_len;\n\n\tif (!prune_stale_stable_nodes ||\n\t    time_before(jiffies, stable_node->chain_prune_time +\n\t\t\tmsecs_to_jiffies(\n\t\t\t\tksm_stable_node_chains_prune_millisecs)))\n\t\tprune_stale_stable_nodes = false;\n\telse\n\t\tstable_node->chain_prune_time = jiffies;\n\n\thlist_for_each_entry_safe(dup, hlist_safe,\n\t\t\t\t  &stable_node->hlist, hlist_dup) {\n\t\tcond_resched();\n\t\t/*\n\t\t * We must walk all stable_node_dup to prune the stale\n\t\t * stable nodes during lookup.\n\t\t *\n\t\t * get_ksm_page can drop the nodes from the\n\t\t * stable_node->hlist if they point to freed pages\n\t\t * (that's why we do a _safe walk). The \"dup\"\n\t\t * stable_node parameter itself will be freed from\n\t\t * under us if it returns NULL.\n\t\t */\n\t\t_tree_page = get_ksm_page(dup, false);\n\t\tif (!_tree_page)\n\t\t\tcontinue;\n\t\tnr += 1;\n\t\tif (is_page_sharing_candidate(dup)) {\n\t\t\tif (!found ||\n\t\t\t    dup->rmap_hlist_len > found_rmap_hlist_len) {\n\t\t\t\tif (found)\n\t\t\t\t\tput_page(tree_page);\n\t\t\t\tfound = dup;\n\t\t\t\tfound_rmap_hlist_len = found->rmap_hlist_len;\n\t\t\t\ttree_page = _tree_page;\n\n\t\t\t\t/* skip put_page for found dup */\n\t\t\t\tif (!prune_stale_stable_nodes)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tput_page(_tree_page);\n\t}\n\n\tif (found) {\n\t\t/*\n\t\t * nr is counting all dups in the chain only if\n\t\t * prune_stale_stable_nodes is true, otherwise we may\n\t\t * break the loop at nr == 1 even if there are\n\t\t * multiple entries.\n\t\t */\n\t\tif (prune_stale_stable_nodes && nr == 1) {\n\t\t\t/*\n\t\t\t * If there's not just one entry it would\n\t\t\t * corrupt memory, better BUG_ON. In KSM\n\t\t\t * context with no lock held it's not even\n\t\t\t * fatal.\n\t\t\t */\n\t\t\tBUG_ON(stable_node->hlist.first->next);\n\n\t\t\t/*\n\t\t\t * There's just one entry and it is below the\n\t\t\t * deduplication limit so drop the chain.\n\t\t\t */\n\t\t\trb_replace_node(&stable_node->node, &found->node,\n\t\t\t\t\troot);\n\t\t\tfree_stable_node(stable_node);\n\t\t\tksm_stable_node_chains--;\n\t\t\tksm_stable_node_dups--;\n\t\t\t/*\n\t\t\t * NOTE: the caller depends on the stable_node\n\t\t\t * to be equal to stable_node_dup if the chain\n\t\t\t * was collapsed.\n\t\t\t */\n\t\t\t*_stable_node = found;\n\t\t\t/*\n\t\t\t * Just for robustneess as stable_node is\n\t\t\t * otherwise left as a stable pointer, the\n\t\t\t * compiler shall optimize it away at build\n\t\t\t * time.\n\t\t\t */\n\t\t\tstable_node = NULL;\n\t\t} else if (stable_node->hlist.first != &found->hlist_dup &&\n\t\t\t   __is_page_sharing_candidate(found, 1)) {\n\t\t\t/*\n\t\t\t * If the found stable_node dup can accept one\n\t\t\t * more future merge (in addition to the one\n\t\t\t * that is underway) and is not at the head of\n\t\t\t * the chain, put it there so next search will\n\t\t\t * be quicker in the !prune_stale_stable_nodes\n\t\t\t * case.\n\t\t\t *\n\t\t\t * NOTE: it would be inaccurate to use nr > 1\n\t\t\t * instead of checking the hlist.first pointer\n\t\t\t * directly, because in the\n\t\t\t * prune_stale_stable_nodes case \"nr\" isn't\n\t\t\t * the position of the found dup in the chain,\n\t\t\t * but the total number of dups in the chain.\n\t\t\t */\n\t\t\thlist_del(&found->hlist_dup);\n\t\t\thlist_add_head(&found->hlist_dup,\n\t\t\t\t       &stable_node->hlist);\n\t\t}\n\t}\n\n\t*_stable_node_dup = found;\n\treturn tree_page;\n}"
  },
  {
    "function_name": "is_page_sharing_candidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "1352-1356",
    "snippet": "static __always_inline\nbool is_page_sharing_candidate(struct stable_node *stable_node)\n{\n\treturn __is_page_sharing_candidate(stable_node, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__is_page_sharing_candidate",
          "args": [
            "stable_node",
            "0"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "__is_page_sharing_candidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1338-1350",
          "snippet": "static __always_inline\nbool __is_page_sharing_candidate(struct stable_node *stable_node, int offset)\n{\n\tVM_BUG_ON(stable_node->rmap_hlist_len < 0);\n\t/*\n\t * Check that at least one mapping still exists, otherwise\n\t * there's no much point to merge and share with this\n\t * stable_node, as the underlying tree_page of the other\n\t * sharer is going to be freed soon.\n\t */\n\treturn stable_node->rmap_hlist_len &&\n\t\tstable_node->rmap_hlist_len + offset < ksm_max_page_sharing;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ksm_max_page_sharing = 256;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic int ksm_max_page_sharing = 256;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic __always_inline\nbool __is_page_sharing_candidate(struct stable_node *stable_node, int offset)\n{\n\tVM_BUG_ON(stable_node->rmap_hlist_len < 0);\n\t/*\n\t * Check that at least one mapping still exists, otherwise\n\t * there's no much point to merge and share with this\n\t * stable_node, as the underlying tree_page of the other\n\t * sharer is going to be freed soon.\n\t */\n\treturn stable_node->rmap_hlist_len &&\n\t\tstable_node->rmap_hlist_len + offset < ksm_max_page_sharing;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic __always_inline\nbool is_page_sharing_candidate(struct stable_node *stable_node)\n{\n\treturn __is_page_sharing_candidate(stable_node, 0);\n}"
  },
  {
    "function_name": "__is_page_sharing_candidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "1338-1350",
    "snippet": "static __always_inline\nbool __is_page_sharing_candidate(struct stable_node *stable_node, int offset)\n{\n\tVM_BUG_ON(stable_node->rmap_hlist_len < 0);\n\t/*\n\t * Check that at least one mapping still exists, otherwise\n\t * there's no much point to merge and share with this\n\t * stable_node, as the underlying tree_page of the other\n\t * sharer is going to be freed soon.\n\t */\n\treturn stable_node->rmap_hlist_len &&\n\t\tstable_node->rmap_hlist_len + offset < ksm_max_page_sharing;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ksm_max_page_sharing = 256;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "stable_node->rmap_hlist_len < 0"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic int ksm_max_page_sharing = 256;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic __always_inline\nbool __is_page_sharing_candidate(struct stable_node *stable_node, int offset)\n{\n\tVM_BUG_ON(stable_node->rmap_hlist_len < 0);\n\t/*\n\t * Check that at least one mapping still exists, otherwise\n\t * there's no much point to merge and share with this\n\t * stable_node, as the underlying tree_page of the other\n\t * sharer is going to be freed soon.\n\t */\n\treturn stable_node->rmap_hlist_len &&\n\t\tstable_node->rmap_hlist_len + offset < ksm_max_page_sharing;\n}"
  },
  {
    "function_name": "try_to_merge_two_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "1317-1336",
    "snippet": "static struct page *try_to_merge_two_pages(struct rmap_item *rmap_item,\n\t\t\t\t\t   struct page *page,\n\t\t\t\t\t   struct rmap_item *tree_rmap_item,\n\t\t\t\t\t   struct page *tree_page)\n{\n\tint err;\n\n\terr = try_to_merge_with_ksm_page(rmap_item, page, NULL);\n\tif (!err) {\n\t\terr = try_to_merge_with_ksm_page(tree_rmap_item,\n\t\t\t\t\t\t\ttree_page, page);\n\t\t/*\n\t\t * If that fails, we have a ksm page with only one pte\n\t\t * pointing to it: so break it.\n\t\t */\n\t\tif (err)\n\t\t\tbreak_cow(rmap_item);\n\t}\n\treturn err ? NULL : page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "break_cow",
          "args": [
            "rmap_item"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "break_cow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "533-550",
          "snippet": "static void break_cow(struct rmap_item *rmap_item)\n{\n\tstruct mm_struct *mm = rmap_item->mm;\n\tunsigned long addr = rmap_item->address;\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * It is not an accident that whenever we want to break COW\n\t * to undo, we also need to drop a reference to the anon_vma.\n\t */\n\tput_anon_vma(rmap_item->anon_vma);\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_mergeable_vma(mm, addr);\n\tif (vma)\n\t\tbreak_ksm(vma, addr);\n\tup_read(&mm->mmap_sem);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic void break_cow(struct rmap_item *rmap_item)\n{\n\tstruct mm_struct *mm = rmap_item->mm;\n\tunsigned long addr = rmap_item->address;\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * It is not an accident that whenever we want to break COW\n\t * to undo, we also need to drop a reference to the anon_vma.\n\t */\n\tput_anon_vma(rmap_item->anon_vma);\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_mergeable_vma(mm, addr);\n\tif (vma)\n\t\tbreak_ksm(vma, addr);\n\tup_read(&mm->mmap_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_merge_with_ksm_page",
          "args": [
            "tree_rmap_item",
            "tree_page",
            "page"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_merge_with_ksm_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1280-1305",
          "snippet": "static int try_to_merge_with_ksm_page(struct rmap_item *rmap_item,\n\t\t\t\t      struct page *page, struct page *kpage)\n{\n\tstruct mm_struct *mm = rmap_item->mm;\n\tstruct vm_area_struct *vma;\n\tint err = -EFAULT;\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_mergeable_vma(mm, rmap_item->address);\n\tif (!vma)\n\t\tgoto out;\n\n\terr = try_to_merge_one_page(vma, page, kpage);\n\tif (err)\n\t\tgoto out;\n\n\t/* Unstable nid is in union with stable anon_vma: remove first */\n\tremove_rmap_item_from_tree(rmap_item);\n\n\t/* Must get reference to anon_vma while still holding mmap_sem */\n\trmap_item->anon_vma = vma->anon_vma;\n\tget_anon_vma(vma->anon_vma);\nout:\n\tup_read(&mm->mmap_sem);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int try_to_merge_with_ksm_page(struct rmap_item *rmap_item,\n\t\t\t\t      struct page *page, struct page *kpage)\n{\n\tstruct mm_struct *mm = rmap_item->mm;\n\tstruct vm_area_struct *vma;\n\tint err = -EFAULT;\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_mergeable_vma(mm, rmap_item->address);\n\tif (!vma)\n\t\tgoto out;\n\n\terr = try_to_merge_one_page(vma, page, kpage);\n\tif (err)\n\t\tgoto out;\n\n\t/* Unstable nid is in union with stable anon_vma: remove first */\n\tremove_rmap_item_from_tree(rmap_item);\n\n\t/* Must get reference to anon_vma while still holding mmap_sem */\n\trmap_item->anon_vma = vma->anon_vma;\n\tget_anon_vma(vma->anon_vma);\nout:\n\tup_read(&mm->mmap_sem);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct page *try_to_merge_two_pages(struct rmap_item *rmap_item,\n\t\t\t\t\t   struct page *page,\n\t\t\t\t\t   struct rmap_item *tree_rmap_item,\n\t\t\t\t\t   struct page *tree_page)\n{\n\tint err;\n\n\terr = try_to_merge_with_ksm_page(rmap_item, page, NULL);\n\tif (!err) {\n\t\terr = try_to_merge_with_ksm_page(tree_rmap_item,\n\t\t\t\t\t\t\ttree_page, page);\n\t\t/*\n\t\t * If that fails, we have a ksm page with only one pte\n\t\t * pointing to it: so break it.\n\t\t */\n\t\tif (err)\n\t\t\tbreak_cow(rmap_item);\n\t}\n\treturn err ? NULL : page;\n}"
  },
  {
    "function_name": "try_to_merge_with_ksm_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "1280-1305",
    "snippet": "static int try_to_merge_with_ksm_page(struct rmap_item *rmap_item,\n\t\t\t\t      struct page *page, struct page *kpage)\n{\n\tstruct mm_struct *mm = rmap_item->mm;\n\tstruct vm_area_struct *vma;\n\tint err = -EFAULT;\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_mergeable_vma(mm, rmap_item->address);\n\tif (!vma)\n\t\tgoto out;\n\n\terr = try_to_merge_one_page(vma, page, kpage);\n\tif (err)\n\t\tgoto out;\n\n\t/* Unstable nid is in union with stable anon_vma: remove first */\n\tremove_rmap_item_from_tree(rmap_item);\n\n\t/* Must get reference to anon_vma while still holding mmap_sem */\n\trmap_item->anon_vma = vma->anon_vma;\n\tget_anon_vma(vma->anon_vma);\nout:\n\tup_read(&mm->mmap_sem);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_anon_vma",
          "args": [
            "vma->anon_vma"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "page_get_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "464-498",
          "snippet": "struct anon_vma *page_get_anon_vma(struct page *page)\n{\n\tstruct anon_vma *anon_vma = NULL;\n\tunsigned long anon_mapping;\n\n\trcu_read_lock();\n\tanon_mapping = (unsigned long)READ_ONCE(page->mapping);\n\tif ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\tgoto out;\n\tif (!page_mapped(page))\n\t\tgoto out;\n\n\tanon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);\n\tif (!atomic_inc_not_zero(&anon_vma->refcount)) {\n\t\tanon_vma = NULL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If this page is still mapped, then its anon_vma cannot have been\n\t * freed.  But if it has been unmapped, we have no security against the\n\t * anon_vma structure being freed and reused (for another anon_vma:\n\t * SLAB_TYPESAFE_BY_RCU guarantees that - so the atomic_inc_not_zero()\n\t * above cannot corrupt).\n\t */\n\tif (!page_mapped(page)) {\n\t\trcu_read_unlock();\n\t\tput_anon_vma(anon_vma);\n\t\treturn NULL;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn anon_vma;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstruct anon_vma *page_get_anon_vma(struct page *page)\n{\n\tstruct anon_vma *anon_vma = NULL;\n\tunsigned long anon_mapping;\n\n\trcu_read_lock();\n\tanon_mapping = (unsigned long)READ_ONCE(page->mapping);\n\tif ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\tgoto out;\n\tif (!page_mapped(page))\n\t\tgoto out;\n\n\tanon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);\n\tif (!atomic_inc_not_zero(&anon_vma->refcount)) {\n\t\tanon_vma = NULL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If this page is still mapped, then its anon_vma cannot have been\n\t * freed.  But if it has been unmapped, we have no security against the\n\t * anon_vma structure being freed and reused (for another anon_vma:\n\t * SLAB_TYPESAFE_BY_RCU guarantees that - so the atomic_inc_not_zero()\n\t * above cannot corrupt).\n\t */\n\tif (!page_mapped(page)) {\n\t\trcu_read_unlock();\n\t\tput_anon_vma(anon_vma);\n\t\treturn NULL;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn anon_vma;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_rmap_item_from_tree",
          "args": [
            "rmap_item"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "remove_rmap_item_from_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "758-802",
          "snippet": "static void remove_rmap_item_from_tree(struct rmap_item *rmap_item)\n{\n\tif (rmap_item->address & STABLE_FLAG) {\n\t\tstruct stable_node *stable_node;\n\t\tstruct page *page;\n\n\t\tstable_node = rmap_item->head;\n\t\tpage = get_ksm_page(stable_node, true);\n\t\tif (!page)\n\t\t\tgoto out;\n\n\t\thlist_del(&rmap_item->hlist);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (!hlist_empty(&stable_node->hlist))\n\t\t\tksm_pages_sharing--;\n\t\telse\n\t\t\tksm_pages_shared--;\n\t\tVM_BUG_ON(stable_node->rmap_hlist_len <= 0);\n\t\tstable_node->rmap_hlist_len--;\n\n\t\tput_anon_vma(rmap_item->anon_vma);\n\t\trmap_item->address &= PAGE_MASK;\n\n\t} else if (rmap_item->address & UNSTABLE_FLAG) {\n\t\tunsigned char age;\n\t\t/*\n\t\t * Usually ksmd can and must skip the rb_erase, because\n\t\t * root_unstable_tree was already reset to RB_ROOT.\n\t\t * But be careful when an mm is exiting: do the rb_erase\n\t\t * if this rmap_item was inserted by this scan, rather\n\t\t * than left over from before.\n\t\t */\n\t\tage = (unsigned char)(ksm_scan.seqnr - rmap_item->address);\n\t\tBUG_ON(age > 1);\n\t\tif (!age)\n\t\t\trb_erase(&rmap_item->node,\n\t\t\t\t root_unstable_tree + NUMA(rmap_item->nid));\n\t\tksm_pages_unshared--;\n\t\trmap_item->address &= PAGE_MASK;\n\t}\nout:\n\tcond_resched();\t\t/* we're called from many long loops */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_FLAG\t0x200\t/* is listed from the stable tree */",
            "#define UNSTABLE_FLAG\t0x100\t/* is a node of the unstable tree */"
          ],
          "globals_used": [
            "static struct rb_root *root_unstable_tree = one_unstable_tree;",
            "static struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};",
            "static unsigned long ksm_pages_shared;",
            "static unsigned long ksm_pages_sharing;",
            "static unsigned long ksm_pages_unshared;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_FLAG\t0x200\t/* is listed from the stable tree */\n#define UNSTABLE_FLAG\t0x100\t/* is a node of the unstable tree */\n\nstatic struct rb_root *root_unstable_tree = one_unstable_tree;\nstatic struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};\nstatic unsigned long ksm_pages_shared;\nstatic unsigned long ksm_pages_sharing;\nstatic unsigned long ksm_pages_unshared;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic void remove_rmap_item_from_tree(struct rmap_item *rmap_item)\n{\n\tif (rmap_item->address & STABLE_FLAG) {\n\t\tstruct stable_node *stable_node;\n\t\tstruct page *page;\n\n\t\tstable_node = rmap_item->head;\n\t\tpage = get_ksm_page(stable_node, true);\n\t\tif (!page)\n\t\t\tgoto out;\n\n\t\thlist_del(&rmap_item->hlist);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (!hlist_empty(&stable_node->hlist))\n\t\t\tksm_pages_sharing--;\n\t\telse\n\t\t\tksm_pages_shared--;\n\t\tVM_BUG_ON(stable_node->rmap_hlist_len <= 0);\n\t\tstable_node->rmap_hlist_len--;\n\n\t\tput_anon_vma(rmap_item->anon_vma);\n\t\trmap_item->address &= PAGE_MASK;\n\n\t} else if (rmap_item->address & UNSTABLE_FLAG) {\n\t\tunsigned char age;\n\t\t/*\n\t\t * Usually ksmd can and must skip the rb_erase, because\n\t\t * root_unstable_tree was already reset to RB_ROOT.\n\t\t * But be careful when an mm is exiting: do the rb_erase\n\t\t * if this rmap_item was inserted by this scan, rather\n\t\t * than left over from before.\n\t\t */\n\t\tage = (unsigned char)(ksm_scan.seqnr - rmap_item->address);\n\t\tBUG_ON(age > 1);\n\t\tif (!age)\n\t\t\trb_erase(&rmap_item->node,\n\t\t\t\t root_unstable_tree + NUMA(rmap_item->nid));\n\t\tksm_pages_unshared--;\n\t\trmap_item->address &= PAGE_MASK;\n\t}\nout:\n\tcond_resched();\t\t/* we're called from many long loops */\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_merge_one_page",
          "args": [
            "vma",
            "page",
            "kpage"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_merge_one_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1205-1272",
          "snippet": "static int try_to_merge_one_page(struct vm_area_struct *vma,\n\t\t\t\t struct page *page, struct page *kpage)\n{\n\tpte_t orig_pte = __pte(0);\n\tint err = -EFAULT;\n\n\tif (page == kpage)\t\t\t/* ksm page forked */\n\t\treturn 0;\n\n\tif (!PageAnon(page))\n\t\tgoto out;\n\n\t/*\n\t * We need the page lock to read a stable PageSwapCache in\n\t * write_protect_page().  We use trylock_page() instead of\n\t * lock_page() because we don't want to wait here - we\n\t * prefer to continue scanning and merging different pages,\n\t * then come back to this page when it is unlocked.\n\t */\n\tif (!trylock_page(page))\n\t\tgoto out;\n\n\tif (PageTransCompound(page)) {\n\t\tif (split_huge_page(page))\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * If this anonymous page is mapped only here, its pte may need\n\t * to be write-protected.  If it's mapped elsewhere, all of its\n\t * ptes are necessarily already write-protected.  But in either\n\t * case, we need to lock and check page_count is not raised.\n\t */\n\tif (write_protect_page(vma, page, &orig_pte) == 0) {\n\t\tif (!kpage) {\n\t\t\t/*\n\t\t\t * While we hold page lock, upgrade page from\n\t\t\t * PageAnon+anon_vma to PageKsm+NULL stable_node:\n\t\t\t * stable_tree_insert() will update stable_node.\n\t\t\t */\n\t\t\tset_page_stable_node(page, NULL);\n\t\t\tmark_page_accessed(page);\n\t\t\t/*\n\t\t\t * Page reclaim just frees a clean page with no dirty\n\t\t\t * ptes: make sure that the ksm page would be swapped.\n\t\t\t */\n\t\t\tif (!PageDirty(page))\n\t\t\t\tSetPageDirty(page);\n\t\t\terr = 0;\n\t\t} else if (pages_identical(page, kpage))\n\t\t\terr = replace_page(vma, page, kpage, orig_pte);\n\t}\n\n\tif ((vma->vm_flags & VM_LOCKED) && kpage && !err) {\n\t\tmunlock_vma_page(page);\n\t\tif (!PageMlocked(kpage)) {\n\t\t\tunlock_page(page);\n\t\t\tlock_page(kpage);\n\t\t\tmlock_vma_page(kpage);\n\t\t\tpage = kpage;\t\t/* for final unlock */\n\t\t}\n\t}\n\nout_unlock:\n\tunlock_page(page);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int try_to_merge_one_page(struct vm_area_struct *vma,\n\t\t\t\t struct page *page, struct page *kpage)\n{\n\tpte_t orig_pte = __pte(0);\n\tint err = -EFAULT;\n\n\tif (page == kpage)\t\t\t/* ksm page forked */\n\t\treturn 0;\n\n\tif (!PageAnon(page))\n\t\tgoto out;\n\n\t/*\n\t * We need the page lock to read a stable PageSwapCache in\n\t * write_protect_page().  We use trylock_page() instead of\n\t * lock_page() because we don't want to wait here - we\n\t * prefer to continue scanning and merging different pages,\n\t * then come back to this page when it is unlocked.\n\t */\n\tif (!trylock_page(page))\n\t\tgoto out;\n\n\tif (PageTransCompound(page)) {\n\t\tif (split_huge_page(page))\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * If this anonymous page is mapped only here, its pte may need\n\t * to be write-protected.  If it's mapped elsewhere, all of its\n\t * ptes are necessarily already write-protected.  But in either\n\t * case, we need to lock and check page_count is not raised.\n\t */\n\tif (write_protect_page(vma, page, &orig_pte) == 0) {\n\t\tif (!kpage) {\n\t\t\t/*\n\t\t\t * While we hold page lock, upgrade page from\n\t\t\t * PageAnon+anon_vma to PageKsm+NULL stable_node:\n\t\t\t * stable_tree_insert() will update stable_node.\n\t\t\t */\n\t\t\tset_page_stable_node(page, NULL);\n\t\t\tmark_page_accessed(page);\n\t\t\t/*\n\t\t\t * Page reclaim just frees a clean page with no dirty\n\t\t\t * ptes: make sure that the ksm page would be swapped.\n\t\t\t */\n\t\t\tif (!PageDirty(page))\n\t\t\t\tSetPageDirty(page);\n\t\t\terr = 0;\n\t\t} else if (pages_identical(page, kpage))\n\t\t\terr = replace_page(vma, page, kpage, orig_pte);\n\t}\n\n\tif ((vma->vm_flags & VM_LOCKED) && kpage && !err) {\n\t\tmunlock_vma_page(page);\n\t\tif (!PageMlocked(kpage)) {\n\t\t\tunlock_page(page);\n\t\t\tlock_page(kpage);\n\t\t\tmlock_vma_page(kpage);\n\t\t\tpage = kpage;\t\t/* for final unlock */\n\t\t}\n\t}\n\nout_unlock:\n\tunlock_page(page);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_mergeable_vma",
          "args": [
            "mm",
            "rmap_item->address"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "find_mergeable_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "519-531",
          "snippet": "static struct vm_area_struct *find_mergeable_vma(struct mm_struct *mm,\n\t\tunsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\tif (ksm_test_exit(mm))\n\t\treturn NULL;\n\tvma = find_vma(mm, addr);\n\tif (!vma || vma->vm_start > addr)\n\t\treturn NULL;\n\tif (!(vma->vm_flags & VM_MERGEABLE) || !vma->anon_vma)\n\t\treturn NULL;\n\treturn vma;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct vm_area_struct *find_mergeable_vma(struct mm_struct *mm,\n\t\tunsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\tif (ksm_test_exit(mm))\n\t\treturn NULL;\n\tvma = find_vma(mm, addr);\n\tif (!vma || vma->vm_start > addr)\n\t\treturn NULL;\n\tif (!(vma->vm_flags & VM_MERGEABLE) || !vma->anon_vma)\n\t\treturn NULL;\n\treturn vma;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int try_to_merge_with_ksm_page(struct rmap_item *rmap_item,\n\t\t\t\t      struct page *page, struct page *kpage)\n{\n\tstruct mm_struct *mm = rmap_item->mm;\n\tstruct vm_area_struct *vma;\n\tint err = -EFAULT;\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_mergeable_vma(mm, rmap_item->address);\n\tif (!vma)\n\t\tgoto out;\n\n\terr = try_to_merge_one_page(vma, page, kpage);\n\tif (err)\n\t\tgoto out;\n\n\t/* Unstable nid is in union with stable anon_vma: remove first */\n\tremove_rmap_item_from_tree(rmap_item);\n\n\t/* Must get reference to anon_vma while still holding mmap_sem */\n\trmap_item->anon_vma = vma->anon_vma;\n\tget_anon_vma(vma->anon_vma);\nout:\n\tup_read(&mm->mmap_sem);\n\treturn err;\n}"
  },
  {
    "function_name": "try_to_merge_one_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "1205-1272",
    "snippet": "static int try_to_merge_one_page(struct vm_area_struct *vma,\n\t\t\t\t struct page *page, struct page *kpage)\n{\n\tpte_t orig_pte = __pte(0);\n\tint err = -EFAULT;\n\n\tif (page == kpage)\t\t\t/* ksm page forked */\n\t\treturn 0;\n\n\tif (!PageAnon(page))\n\t\tgoto out;\n\n\t/*\n\t * We need the page lock to read a stable PageSwapCache in\n\t * write_protect_page().  We use trylock_page() instead of\n\t * lock_page() because we don't want to wait here - we\n\t * prefer to continue scanning and merging different pages,\n\t * then come back to this page when it is unlocked.\n\t */\n\tif (!trylock_page(page))\n\t\tgoto out;\n\n\tif (PageTransCompound(page)) {\n\t\tif (split_huge_page(page))\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * If this anonymous page is mapped only here, its pte may need\n\t * to be write-protected.  If it's mapped elsewhere, all of its\n\t * ptes are necessarily already write-protected.  But in either\n\t * case, we need to lock and check page_count is not raised.\n\t */\n\tif (write_protect_page(vma, page, &orig_pte) == 0) {\n\t\tif (!kpage) {\n\t\t\t/*\n\t\t\t * While we hold page lock, upgrade page from\n\t\t\t * PageAnon+anon_vma to PageKsm+NULL stable_node:\n\t\t\t * stable_tree_insert() will update stable_node.\n\t\t\t */\n\t\t\tset_page_stable_node(page, NULL);\n\t\t\tmark_page_accessed(page);\n\t\t\t/*\n\t\t\t * Page reclaim just frees a clean page with no dirty\n\t\t\t * ptes: make sure that the ksm page would be swapped.\n\t\t\t */\n\t\t\tif (!PageDirty(page))\n\t\t\t\tSetPageDirty(page);\n\t\t\terr = 0;\n\t\t} else if (pages_identical(page, kpage))\n\t\t\terr = replace_page(vma, page, kpage, orig_pte);\n\t}\n\n\tif ((vma->vm_flags & VM_LOCKED) && kpage && !err) {\n\t\tmunlock_vma_page(page);\n\t\tif (!PageMlocked(kpage)) {\n\t\t\tunlock_page(page);\n\t\t\tlock_page(kpage);\n\t\t\tmlock_vma_page(kpage);\n\t\t\tpage = kpage;\t\t/* for final unlock */\n\t\t}\n\t}\n\nout_unlock:\n\tunlock_page(page);\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlock_vma_page",
          "args": [
            "kpage"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "mlock_vma_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "359-359",
          "snippet": "static inline void mlock_vma_page(struct page *page) { }",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mlock_vma_page(struct page *page) { }"
        }
      },
      {
        "call_info": {
          "callee": "PageMlocked",
          "args": [
            "kpage"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "munlock_vma_page",
          "args": [
            "page"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "munlock_vma_pages_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "292-295",
          "snippet": "static inline void munlock_vma_pages_all(struct vm_area_struct *vma)\n{\n\tmunlock_vma_pages_range(vma, vma->vm_start, vma->vm_end);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void munlock_vma_pages_all(struct vm_area_struct *vma)\n{\n\tmunlock_vma_pages_range(vma, vma->vm_start, vma->vm_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "replace_page",
          "args": [
            "vma",
            "page",
            "kpage",
            "orig_pte"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "replace_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1122-1194",
          "snippet": "static int replace_page(struct vm_area_struct *vma, struct page *page,\n\t\t\tstruct page *kpage, pte_t orig_pte)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpmd_t *pmd;\n\tpte_t *ptep;\n\tpte_t newpte;\n\tspinlock_t *ptl;\n\tunsigned long addr;\n\tint err = -EFAULT;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\n\taddr = page_address_in_vma(page, vma);\n\tif (addr == -EFAULT)\n\t\tgoto out;\n\n\tpmd = mm_find_pmd(mm, addr);\n\tif (!pmd)\n\t\tgoto out;\n\n\tmmun_start = addr;\n\tmmun_end   = addr + PAGE_SIZE;\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\n\tptep = pte_offset_map_lock(mm, pmd, addr, &ptl);\n\tif (!pte_same(*ptep, orig_pte)) {\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tgoto out_mn;\n\t}\n\n\t/*\n\t * No need to check ksm_use_zero_pages here: we can only have a\n\t * zero_page here if ksm_use_zero_pages was enabled alreaady.\n\t */\n\tif (!is_zero_pfn(page_to_pfn(kpage))) {\n\t\tget_page(kpage);\n\t\tpage_add_anon_rmap(kpage, vma, addr, false);\n\t\tnewpte = mk_pte(kpage, vma->vm_page_prot);\n\t} else {\n\t\tnewpte = pte_mkspecial(pfn_pte(page_to_pfn(kpage),\n\t\t\t\t\t       vma->vm_page_prot));\n\t\t/*\n\t\t * We're replacing an anonymous page with a zero page, which is\n\t\t * not anonymous. We need to do proper accounting otherwise we\n\t\t * will get wrong values in /proc, and a BUG message in dmesg\n\t\t * when tearing down the mm.\n\t\t */\n\t\tdec_mm_counter(mm, MM_ANONPAGES);\n\t}\n\n\tflush_cache_page(vma, addr, pte_pfn(*ptep));\n\t/*\n\t * No need to notify as we are replacing a read only page with another\n\t * read only page with the same content.\n\t *\n\t * See Documentation/vm/mmu_notifier.rst\n\t */\n\tptep_clear_flush(vma, addr, ptep);\n\tset_pte_at_notify(mm, addr, ptep, newpte);\n\n\tpage_remove_rmap(page, false);\n\tif (!page_mapped(page))\n\t\ttry_to_free_swap(page);\n\tput_page(page);\n\n\tpte_unmap_unlock(ptep, ptl);\n\terr = 0;\nout_mn:\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ksm_use_zero_pages",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic bool ksm_use_zero_pages;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int replace_page(struct vm_area_struct *vma, struct page *page,\n\t\t\tstruct page *kpage, pte_t orig_pte)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpmd_t *pmd;\n\tpte_t *ptep;\n\tpte_t newpte;\n\tspinlock_t *ptl;\n\tunsigned long addr;\n\tint err = -EFAULT;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\n\taddr = page_address_in_vma(page, vma);\n\tif (addr == -EFAULT)\n\t\tgoto out;\n\n\tpmd = mm_find_pmd(mm, addr);\n\tif (!pmd)\n\t\tgoto out;\n\n\tmmun_start = addr;\n\tmmun_end   = addr + PAGE_SIZE;\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\n\tptep = pte_offset_map_lock(mm, pmd, addr, &ptl);\n\tif (!pte_same(*ptep, orig_pte)) {\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tgoto out_mn;\n\t}\n\n\t/*\n\t * No need to check ksm_use_zero_pages here: we can only have a\n\t * zero_page here if ksm_use_zero_pages was enabled alreaady.\n\t */\n\tif (!is_zero_pfn(page_to_pfn(kpage))) {\n\t\tget_page(kpage);\n\t\tpage_add_anon_rmap(kpage, vma, addr, false);\n\t\tnewpte = mk_pte(kpage, vma->vm_page_prot);\n\t} else {\n\t\tnewpte = pte_mkspecial(pfn_pte(page_to_pfn(kpage),\n\t\t\t\t\t       vma->vm_page_prot));\n\t\t/*\n\t\t * We're replacing an anonymous page with a zero page, which is\n\t\t * not anonymous. We need to do proper accounting otherwise we\n\t\t * will get wrong values in /proc, and a BUG message in dmesg\n\t\t * when tearing down the mm.\n\t\t */\n\t\tdec_mm_counter(mm, MM_ANONPAGES);\n\t}\n\n\tflush_cache_page(vma, addr, pte_pfn(*ptep));\n\t/*\n\t * No need to notify as we are replacing a read only page with another\n\t * read only page with the same content.\n\t *\n\t * See Documentation/vm/mmu_notifier.rst\n\t */\n\tptep_clear_flush(vma, addr, ptep);\n\tset_pte_at_notify(mm, addr, ptep, newpte);\n\n\tpage_remove_rmap(page, false);\n\tif (!page_mapped(page))\n\t\ttry_to_free_swap(page);\n\tput_page(page);\n\n\tpte_unmap_unlock(ptep, ptl);\n\terr = 0;\nout_mn:\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pages_identical",
          "args": [
            "page",
            "kpage"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "pages_identical",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1030-1033",
          "snippet": "static inline int pages_identical(struct page *page1, struct page *page2)\n{\n\treturn !memcmp_pages(page1, page2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline int pages_identical(struct page *page1, struct page *page2)\n{\n\treturn !memcmp_pages(page1, page2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageDirty",
          "args": [
            "page"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_page_accessed",
          "args": [
            "page"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "mark_page_accessed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "376-400",
          "snippet": "void mark_page_accessed(struct page *page)\n{\n\tpage = compound_head(page);\n\tif (!PageActive(page) && !PageUnevictable(page) &&\n\t\t\tPageReferenced(page)) {\n\n\t\t/*\n\t\t * If the page is on the LRU, queue it for activation via\n\t\t * activate_page_pvecs. Otherwise, assume the page is on a\n\t\t * pagevec, mark it active and it'll be moved to the active\n\t\t * LRU on the next drain.\n\t\t */\n\t\tif (PageLRU(page))\n\t\t\tactivate_page(page);\n\t\telse\n\t\t\t__lru_cache_activate_page(page);\n\t\tClearPageReferenced(page);\n\t\tif (page_is_file_cache(page))\n\t\t\tworkingset_activation(page);\n\t} else if (!PageReferenced(page)) {\n\t\tSetPageReferenced(page);\n\t}\n\tif (page_is_idle(page))\n\t\tclear_page_idle(page);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid mark_page_accessed(struct page *page)\n{\n\tpage = compound_head(page);\n\tif (!PageActive(page) && !PageUnevictable(page) &&\n\t\t\tPageReferenced(page)) {\n\n\t\t/*\n\t\t * If the page is on the LRU, queue it for activation via\n\t\t * activate_page_pvecs. Otherwise, assume the page is on a\n\t\t * pagevec, mark it active and it'll be moved to the active\n\t\t * LRU on the next drain.\n\t\t */\n\t\tif (PageLRU(page))\n\t\t\tactivate_page(page);\n\t\telse\n\t\t\t__lru_cache_activate_page(page);\n\t\tClearPageReferenced(page);\n\t\tif (page_is_file_cache(page))\n\t\t\tworkingset_activation(page);\n\t} else if (!PageReferenced(page)) {\n\t\tSetPageReferenced(page);\n\t}\n\tif (page_is_idle(page))\n\t\tclear_page_idle(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_stable_node",
          "args": [
            "page",
            "NULL"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_stable_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "850-854",
          "snippet": "static inline void set_page_stable_node(struct page *page,\n\t\t\t\t\tstruct stable_node *stable_node)\n{\n\tpage->mapping = (void *)((unsigned long)stable_node | PAGE_MAPPING_KSM);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void set_page_stable_node(struct page *page,\n\t\t\t\t\tstruct stable_node *stable_node)\n{\n\tpage->mapping = (void *)((unsigned long)stable_node | PAGE_MAPPING_KSM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_protect_page",
          "args": [
            "vma",
            "page",
            "&orig_pte"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "write_protect_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1035-1111",
          "snippet": "static int write_protect_page(struct vm_area_struct *vma, struct page *page,\n\t\t\t      pte_t *orig_pte)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = page,\n\t\t.vma = vma,\n\t};\n\tint swapped;\n\tint err = -EFAULT;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\n\tpvmw.address = page_address_in_vma(page, vma);\n\tif (pvmw.address == -EFAULT)\n\t\tgoto out;\n\n\tBUG_ON(PageTransCompound(page));\n\n\tmmun_start = pvmw.address;\n\tmmun_end   = pvmw.address + PAGE_SIZE;\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\n\tif (!page_vma_mapped_walk(&pvmw))\n\t\tgoto out_mn;\n\tif (WARN_ONCE(!pvmw.pte, \"Unexpected PMD mapping?\"))\n\t\tgoto out_unlock;\n\n\tif (pte_write(*pvmw.pte) || pte_dirty(*pvmw.pte) ||\n\t    (pte_protnone(*pvmw.pte) && pte_savedwrite(*pvmw.pte)) ||\n\t\t\t\t\t\tmm_tlb_flush_pending(mm)) {\n\t\tpte_t entry;\n\n\t\tswapped = PageSwapCache(page);\n\t\tflush_cache_page(vma, pvmw.address, page_to_pfn(page));\n\t\t/*\n\t\t * Ok this is tricky, when get_user_pages_fast() run it doesn't\n\t\t * take any lock, therefore the check that we are going to make\n\t\t * with the pagecount against the mapcount is racey and\n\t\t * O_DIRECT can happen right after the check.\n\t\t * So we clear the pte and flush the tlb before the check\n\t\t * this assure us that no O_DIRECT can happen after the check\n\t\t * or in the middle of the check.\n\t\t *\n\t\t * No need to notify as we are downgrading page table to read\n\t\t * only not changing it to point to a new page.\n\t\t *\n\t\t * See Documentation/vm/mmu_notifier.rst\n\t\t */\n\t\tentry = ptep_clear_flush(vma, pvmw.address, pvmw.pte);\n\t\t/*\n\t\t * Check that no O_DIRECT or similar I/O is in progress on the\n\t\t * page\n\t\t */\n\t\tif (page_mapcount(page) + 1 + swapped != page_count(page)) {\n\t\t\tset_pte_at(mm, pvmw.address, pvmw.pte, entry);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (pte_dirty(entry))\n\t\t\tset_page_dirty(page);\n\n\t\tif (pte_protnone(entry))\n\t\t\tentry = pte_mkclean(pte_clear_savedwrite(entry));\n\t\telse\n\t\t\tentry = pte_mkclean(pte_wrprotect(entry));\n\t\tset_pte_at_notify(mm, pvmw.address, pvmw.pte, entry);\n\t}\n\t*orig_pte = *pvmw.pte;\n\terr = 0;\n\nout_unlock:\n\tpage_vma_mapped_walk_done(&pvmw);\nout_mn:\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int write_protect_page(struct vm_area_struct *vma, struct page *page,\n\t\t\t      pte_t *orig_pte)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = page,\n\t\t.vma = vma,\n\t};\n\tint swapped;\n\tint err = -EFAULT;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\n\tpvmw.address = page_address_in_vma(page, vma);\n\tif (pvmw.address == -EFAULT)\n\t\tgoto out;\n\n\tBUG_ON(PageTransCompound(page));\n\n\tmmun_start = pvmw.address;\n\tmmun_end   = pvmw.address + PAGE_SIZE;\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\n\tif (!page_vma_mapped_walk(&pvmw))\n\t\tgoto out_mn;\n\tif (WARN_ONCE(!pvmw.pte, \"Unexpected PMD mapping?\"))\n\t\tgoto out_unlock;\n\n\tif (pte_write(*pvmw.pte) || pte_dirty(*pvmw.pte) ||\n\t    (pte_protnone(*pvmw.pte) && pte_savedwrite(*pvmw.pte)) ||\n\t\t\t\t\t\tmm_tlb_flush_pending(mm)) {\n\t\tpte_t entry;\n\n\t\tswapped = PageSwapCache(page);\n\t\tflush_cache_page(vma, pvmw.address, page_to_pfn(page));\n\t\t/*\n\t\t * Ok this is tricky, when get_user_pages_fast() run it doesn't\n\t\t * take any lock, therefore the check that we are going to make\n\t\t * with the pagecount against the mapcount is racey and\n\t\t * O_DIRECT can happen right after the check.\n\t\t * So we clear the pte and flush the tlb before the check\n\t\t * this assure us that no O_DIRECT can happen after the check\n\t\t * or in the middle of the check.\n\t\t *\n\t\t * No need to notify as we are downgrading page table to read\n\t\t * only not changing it to point to a new page.\n\t\t *\n\t\t * See Documentation/vm/mmu_notifier.rst\n\t\t */\n\t\tentry = ptep_clear_flush(vma, pvmw.address, pvmw.pte);\n\t\t/*\n\t\t * Check that no O_DIRECT or similar I/O is in progress on the\n\t\t * page\n\t\t */\n\t\tif (page_mapcount(page) + 1 + swapped != page_count(page)) {\n\t\t\tset_pte_at(mm, pvmw.address, pvmw.pte, entry);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (pte_dirty(entry))\n\t\t\tset_page_dirty(page);\n\n\t\tif (pte_protnone(entry))\n\t\t\tentry = pte_mkclean(pte_clear_savedwrite(entry));\n\t\telse\n\t\t\tentry = pte_mkclean(pte_wrprotect(entry));\n\t\tset_pte_at_notify(mm, pvmw.address, pvmw.pte, entry);\n\t}\n\t*orig_pte = *pvmw.pte;\n\terr = 0;\n\nout_unlock:\n\tpage_vma_mapped_walk_done(&pvmw);\nout_mn:\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "split_huge_page",
          "args": [
            "page"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "deferred_split_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2760-2774",
          "snippet": "void deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "page"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pte",
          "args": [
            "0"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int try_to_merge_one_page(struct vm_area_struct *vma,\n\t\t\t\t struct page *page, struct page *kpage)\n{\n\tpte_t orig_pte = __pte(0);\n\tint err = -EFAULT;\n\n\tif (page == kpage)\t\t\t/* ksm page forked */\n\t\treturn 0;\n\n\tif (!PageAnon(page))\n\t\tgoto out;\n\n\t/*\n\t * We need the page lock to read a stable PageSwapCache in\n\t * write_protect_page().  We use trylock_page() instead of\n\t * lock_page() because we don't want to wait here - we\n\t * prefer to continue scanning and merging different pages,\n\t * then come back to this page when it is unlocked.\n\t */\n\tif (!trylock_page(page))\n\t\tgoto out;\n\n\tif (PageTransCompound(page)) {\n\t\tif (split_huge_page(page))\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * If this anonymous page is mapped only here, its pte may need\n\t * to be write-protected.  If it's mapped elsewhere, all of its\n\t * ptes are necessarily already write-protected.  But in either\n\t * case, we need to lock and check page_count is not raised.\n\t */\n\tif (write_protect_page(vma, page, &orig_pte) == 0) {\n\t\tif (!kpage) {\n\t\t\t/*\n\t\t\t * While we hold page lock, upgrade page from\n\t\t\t * PageAnon+anon_vma to PageKsm+NULL stable_node:\n\t\t\t * stable_tree_insert() will update stable_node.\n\t\t\t */\n\t\t\tset_page_stable_node(page, NULL);\n\t\t\tmark_page_accessed(page);\n\t\t\t/*\n\t\t\t * Page reclaim just frees a clean page with no dirty\n\t\t\t * ptes: make sure that the ksm page would be swapped.\n\t\t\t */\n\t\t\tif (!PageDirty(page))\n\t\t\t\tSetPageDirty(page);\n\t\t\terr = 0;\n\t\t} else if (pages_identical(page, kpage))\n\t\t\terr = replace_page(vma, page, kpage, orig_pte);\n\t}\n\n\tif ((vma->vm_flags & VM_LOCKED) && kpage && !err) {\n\t\tmunlock_vma_page(page);\n\t\tif (!PageMlocked(kpage)) {\n\t\t\tunlock_page(page);\n\t\t\tlock_page(kpage);\n\t\t\tmlock_vma_page(kpage);\n\t\t\tpage = kpage;\t\t/* for final unlock */\n\t\t}\n\t}\n\nout_unlock:\n\tunlock_page(page);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "replace_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "1122-1194",
    "snippet": "static int replace_page(struct vm_area_struct *vma, struct page *page,\n\t\t\tstruct page *kpage, pte_t orig_pte)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpmd_t *pmd;\n\tpte_t *ptep;\n\tpte_t newpte;\n\tspinlock_t *ptl;\n\tunsigned long addr;\n\tint err = -EFAULT;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\n\taddr = page_address_in_vma(page, vma);\n\tif (addr == -EFAULT)\n\t\tgoto out;\n\n\tpmd = mm_find_pmd(mm, addr);\n\tif (!pmd)\n\t\tgoto out;\n\n\tmmun_start = addr;\n\tmmun_end   = addr + PAGE_SIZE;\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\n\tptep = pte_offset_map_lock(mm, pmd, addr, &ptl);\n\tif (!pte_same(*ptep, orig_pte)) {\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tgoto out_mn;\n\t}\n\n\t/*\n\t * No need to check ksm_use_zero_pages here: we can only have a\n\t * zero_page here if ksm_use_zero_pages was enabled alreaady.\n\t */\n\tif (!is_zero_pfn(page_to_pfn(kpage))) {\n\t\tget_page(kpage);\n\t\tpage_add_anon_rmap(kpage, vma, addr, false);\n\t\tnewpte = mk_pte(kpage, vma->vm_page_prot);\n\t} else {\n\t\tnewpte = pte_mkspecial(pfn_pte(page_to_pfn(kpage),\n\t\t\t\t\t       vma->vm_page_prot));\n\t\t/*\n\t\t * We're replacing an anonymous page with a zero page, which is\n\t\t * not anonymous. We need to do proper accounting otherwise we\n\t\t * will get wrong values in /proc, and a BUG message in dmesg\n\t\t * when tearing down the mm.\n\t\t */\n\t\tdec_mm_counter(mm, MM_ANONPAGES);\n\t}\n\n\tflush_cache_page(vma, addr, pte_pfn(*ptep));\n\t/*\n\t * No need to notify as we are replacing a read only page with another\n\t * read only page with the same content.\n\t *\n\t * See Documentation/vm/mmu_notifier.rst\n\t */\n\tptep_clear_flush(vma, addr, ptep);\n\tset_pte_at_notify(mm, addr, ptep, newpte);\n\n\tpage_remove_rmap(page, false);\n\tif (!page_mapped(page))\n\t\ttry_to_free_swap(page);\n\tput_page(page);\n\n\tpte_unmap_unlock(ptep, ptl);\n\terr = 0;\nout_mn:\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool ksm_use_zero_pages",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_end",
          "args": [
            "mm",
            "mmun_start",
            "mmun_end"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "ptep",
            "ptl"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_free_swap",
          "args": [
            "page"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1584-1617",
          "snippet": "int try_to_free_swap(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (!PageSwapCache(page))\n\t\treturn 0;\n\tif (PageWriteback(page))\n\t\treturn 0;\n\tif (page_swapped(page))\n\t\treturn 0;\n\n\t/*\n\t * Once hibernation has begun to create its image of memory,\n\t * there's a danger that one of the calls to try_to_free_swap()\n\t * - most probably a call from __try_to_reclaim_swap() while\n\t * hibernation is allocating its own swap pages for the image,\n\t * but conceivably even a call from memory reclaim - will free\n\t * the swap from a page which has already been recorded in the\n\t * image as a clean swapcache page, and then reuse its swap for\n\t * another page of the image.  On waking from hibernation, the\n\t * original page might be freed under memory pressure, then\n\t * later read back in from swap, now with the wrong data.\n\t *\n\t * Hibernation suspends storage while it is writing the image\n\t * to disk so check that here.\n\t */\n\tif (pm_suspended_storage())\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\tdelete_from_swap_cache(page);\n\tSetPageDirty(page);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint try_to_free_swap(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (!PageSwapCache(page))\n\t\treturn 0;\n\tif (PageWriteback(page))\n\t\treturn 0;\n\tif (page_swapped(page))\n\t\treturn 0;\n\n\t/*\n\t * Once hibernation has begun to create its image of memory,\n\t * there's a danger that one of the calls to try_to_free_swap()\n\t * - most probably a call from __try_to_reclaim_swap() while\n\t * hibernation is allocating its own swap pages for the image,\n\t * but conceivably even a call from memory reclaim - will free\n\t * the swap from a page which has already been recorded in the\n\t * image as a clean swapcache page, and then reuse its swap for\n\t * another page of the image.  On waking from hibernation, the\n\t * original page might be freed under memory pressure, then\n\t * later read back in from swap, now with the wrong data.\n\t *\n\t * Hibernation suspends storage while it is writing the image\n\t * to disk so check that here.\n\t */\n\tif (pm_suspended_storage())\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\tdelete_from_swap_cache(page);\n\tSetPageDirty(page);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "page"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "470-486",
          "snippet": "bool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nbool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_remove_rmap",
          "args": [
            "page",
            "false"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "page_remove_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1297-1331",
          "snippet": "void page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_pte_at_notify",
          "args": [
            "mm",
            "addr",
            "ptep",
            "newpte"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptep_clear_flush",
          "args": [
            "vma",
            "addr",
            "ptep"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "ptep_clear_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "81-90",
          "snippet": "pte_t ptep_clear_flush(struct vm_area_struct *vma, unsigned long address,\n\t\t       pte_t *ptep)\n{\n\tstruct mm_struct *mm = (vma)->vm_mm;\n\tpte_t pte;\n\tpte = ptep_get_and_clear(mm, address, ptep);\n\tif (pte_accessible(mm, pte))\n\t\tflush_tlb_page(vma, address);\n\treturn pte;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\npte_t ptep_clear_flush(struct vm_area_struct *vma, unsigned long address,\n\t\t       pte_t *ptep)\n{\n\tstruct mm_struct *mm = (vma)->vm_mm;\n\tpte_t pte;\n\tpte = ptep_get_and_clear(mm, address, ptep);\n\tif (pte_accessible(mm, pte))\n\t\tflush_tlb_page(vma, address);\n\treturn pte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_cache_page",
          "args": [
            "vma",
            "addr",
            "pte_pfn(*ptep)"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "*ptep"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_mm_counter",
          "args": [
            "mm",
            "MM_ANONPAGES"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkspecial",
          "args": [
            "pfn_pte(page_to_pfn(kpage),\n\t\t\t\t\t       vma->vm_page_prot)"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_pte",
          "args": [
            "page_to_pfn(kpage)",
            "vma->vm_page_prot"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "kpage"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mk_pte",
          "args": [
            "kpage",
            "vma->vm_page_prot"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_add_anon_rmap",
          "args": [
            "kpage",
            "vma",
            "addr",
            "false"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "do_page_add_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1098-1137",
          "snippet": "void do_page_add_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int flags)\n{\n\tbool compound = flags & RMAP_COMPOUND;\n\tbool first;\n\n\tif (compound) {\n\t\tatomic_t *mapcount;\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\tmapcount = compound_mapcount_ptr(page);\n\t\tfirst = atomic_inc_and_test(mapcount);\n\t} else {\n\t\tfirst = atomic_inc_and_test(&page->_mapcount);\n\t}\n\n\tif (first) {\n\t\tint nr = compound ? hpage_nr_pages(page) : 1;\n\t\t/*\n\t\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t\t * these counters are not modified in interrupt context, and\n\t\t * pte lock(a spinlock) is held, which implies preemption\n\t\t * disabled.\n\t\t */\n\t\tif (compound)\n\t\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t}\n\tif (unlikely(PageKsm(page)))\n\t\treturn;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\t/* address might be in next vma when migration races vma_adjust */\n\tif (first)\n\t\t__page_set_anon_rmap(page, vma, address,\n\t\t\t\tflags & RMAP_EXCLUSIVE);\n\telse\n\t\t__page_check_anon_rmap(page, vma, address);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid do_page_add_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int flags)\n{\n\tbool compound = flags & RMAP_COMPOUND;\n\tbool first;\n\n\tif (compound) {\n\t\tatomic_t *mapcount;\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\tmapcount = compound_mapcount_ptr(page);\n\t\tfirst = atomic_inc_and_test(mapcount);\n\t} else {\n\t\tfirst = atomic_inc_and_test(&page->_mapcount);\n\t}\n\n\tif (first) {\n\t\tint nr = compound ? hpage_nr_pages(page) : 1;\n\t\t/*\n\t\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t\t * these counters are not modified in interrupt context, and\n\t\t * pte lock(a spinlock) is held, which implies preemption\n\t\t * disabled.\n\t\t */\n\t\tif (compound)\n\t\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t}\n\tif (unlikely(PageKsm(page)))\n\t\treturn;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\t/* address might be in next vma when migration races vma_adjust */\n\tif (first)\n\t\t__page_set_anon_rmap(page, vma, address,\n\t\t\t\tflags & RMAP_EXCLUSIVE);\n\telse\n\t\t__page_check_anon_rmap(page, vma, address);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "kpage"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_zero_pfn",
          "args": [
            "page_to_pfn(kpage)"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "kpage"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "ptep",
            "ptl"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_same",
          "args": [
            "*ptep",
            "orig_pte"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "pte_same_as_swp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1735-1738",
          "snippet": "static inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline int pte_same_as_swp(pte_t pte, pte_t swp_pte)\n{\n\treturn pte_same(pte_swp_clear_soft_dirty(pte), swp_pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "mm",
            "pmd",
            "addr",
            "&ptl"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "mm",
            "mmun_start",
            "mmun_end"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_find_pmd",
          "args": [
            "mm",
            "addr"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "mm_find_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "710-742",
          "snippet": "pmd_t *mm_find_pmd(struct mm_struct *mm, unsigned long address)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd = NULL;\n\tpmd_t pmde;\n\n\tpgd = pgd_offset(mm, address);\n\tif (!pgd_present(*pgd))\n\t\tgoto out;\n\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\tgoto out;\n\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\tgoto out;\n\n\tpmd = pmd_offset(pud, address);\n\t/*\n\t * Some THP functions use the sequence pmdp_huge_clear_flush(), set_pmd_at()\n\t * without holding anon_vma lock for write.  So when looking for a\n\t * genuine pmde (in which to find pte), test present and !THP together.\n\t */\n\tpmde = *pmd;\n\tbarrier();\n\tif (!pmd_present(pmde) || pmd_trans_huge(pmde))\n\t\tpmd = NULL;\nout:\n\treturn pmd;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\npmd_t *mm_find_pmd(struct mm_struct *mm, unsigned long address)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd = NULL;\n\tpmd_t pmde;\n\n\tpgd = pgd_offset(mm, address);\n\tif (!pgd_present(*pgd))\n\t\tgoto out;\n\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\tgoto out;\n\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\tgoto out;\n\n\tpmd = pmd_offset(pud, address);\n\t/*\n\t * Some THP functions use the sequence pmdp_huge_clear_flush(), set_pmd_at()\n\t * without holding anon_vma lock for write.  So when looking for a\n\t * genuine pmde (in which to find pte), test present and !THP together.\n\t */\n\tpmde = *pmd;\n\tbarrier();\n\tif (!pmd_present(pmde) || pmd_trans_huge(pmde))\n\t\tpmd = NULL;\nout:\n\treturn pmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address_in_vma",
          "args": [
            "page",
            "vma"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "page_address_in_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "687-708",
          "snippet": "unsigned long page_address_in_vma(struct page *page, struct vm_area_struct *vma)\n{\n\tunsigned long address;\n\tif (PageAnon(page)) {\n\t\tstruct anon_vma *page__anon_vma = page_anon_vma(page);\n\t\t/*\n\t\t * Note: swapoff's unuse_vma() is more efficient with this\n\t\t * check, and needs it to match anon_vma when KSM is active.\n\t\t */\n\t\tif (!vma->anon_vma || !page__anon_vma ||\n\t\t    vma->anon_vma->root != page__anon_vma->root)\n\t\t\treturn -EFAULT;\n\t} else if (page->mapping) {\n\t\tif (!vma->vm_file || vma->vm_file->f_mapping != page->mapping)\n\t\t\treturn -EFAULT;\n\t} else\n\t\treturn -EFAULT;\n\taddress = __vma_address(page, vma);\n\tif (unlikely(address < vma->vm_start || address >= vma->vm_end))\n\t\treturn -EFAULT;\n\treturn address;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long page_address_in_vma(struct page *page, struct vm_area_struct *vma)\n{\n\tunsigned long address;\n\tif (PageAnon(page)) {\n\t\tstruct anon_vma *page__anon_vma = page_anon_vma(page);\n\t\t/*\n\t\t * Note: swapoff's unuse_vma() is more efficient with this\n\t\t * check, and needs it to match anon_vma when KSM is active.\n\t\t */\n\t\tif (!vma->anon_vma || !page__anon_vma ||\n\t\t    vma->anon_vma->root != page__anon_vma->root)\n\t\t\treturn -EFAULT;\n\t} else if (page->mapping) {\n\t\tif (!vma->vm_file || vma->vm_file->f_mapping != page->mapping)\n\t\t\treturn -EFAULT;\n\t} else\n\t\treturn -EFAULT;\n\taddress = __vma_address(page, vma);\n\tif (unlikely(address < vma->vm_start || address >= vma->vm_end))\n\t\treturn -EFAULT;\n\treturn address;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic bool ksm_use_zero_pages;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int replace_page(struct vm_area_struct *vma, struct page *page,\n\t\t\tstruct page *kpage, pte_t orig_pte)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpmd_t *pmd;\n\tpte_t *ptep;\n\tpte_t newpte;\n\tspinlock_t *ptl;\n\tunsigned long addr;\n\tint err = -EFAULT;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\n\taddr = page_address_in_vma(page, vma);\n\tif (addr == -EFAULT)\n\t\tgoto out;\n\n\tpmd = mm_find_pmd(mm, addr);\n\tif (!pmd)\n\t\tgoto out;\n\n\tmmun_start = addr;\n\tmmun_end   = addr + PAGE_SIZE;\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\n\tptep = pte_offset_map_lock(mm, pmd, addr, &ptl);\n\tif (!pte_same(*ptep, orig_pte)) {\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tgoto out_mn;\n\t}\n\n\t/*\n\t * No need to check ksm_use_zero_pages here: we can only have a\n\t * zero_page here if ksm_use_zero_pages was enabled alreaady.\n\t */\n\tif (!is_zero_pfn(page_to_pfn(kpage))) {\n\t\tget_page(kpage);\n\t\tpage_add_anon_rmap(kpage, vma, addr, false);\n\t\tnewpte = mk_pte(kpage, vma->vm_page_prot);\n\t} else {\n\t\tnewpte = pte_mkspecial(pfn_pte(page_to_pfn(kpage),\n\t\t\t\t\t       vma->vm_page_prot));\n\t\t/*\n\t\t * We're replacing an anonymous page with a zero page, which is\n\t\t * not anonymous. We need to do proper accounting otherwise we\n\t\t * will get wrong values in /proc, and a BUG message in dmesg\n\t\t * when tearing down the mm.\n\t\t */\n\t\tdec_mm_counter(mm, MM_ANONPAGES);\n\t}\n\n\tflush_cache_page(vma, addr, pte_pfn(*ptep));\n\t/*\n\t * No need to notify as we are replacing a read only page with another\n\t * read only page with the same content.\n\t *\n\t * See Documentation/vm/mmu_notifier.rst\n\t */\n\tptep_clear_flush(vma, addr, ptep);\n\tset_pte_at_notify(mm, addr, ptep, newpte);\n\n\tpage_remove_rmap(page, false);\n\tif (!page_mapped(page))\n\t\ttry_to_free_swap(page);\n\tput_page(page);\n\n\tpte_unmap_unlock(ptep, ptl);\n\terr = 0;\nout_mn:\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "write_protect_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "1035-1111",
    "snippet": "static int write_protect_page(struct vm_area_struct *vma, struct page *page,\n\t\t\t      pte_t *orig_pte)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = page,\n\t\t.vma = vma,\n\t};\n\tint swapped;\n\tint err = -EFAULT;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\n\tpvmw.address = page_address_in_vma(page, vma);\n\tif (pvmw.address == -EFAULT)\n\t\tgoto out;\n\n\tBUG_ON(PageTransCompound(page));\n\n\tmmun_start = pvmw.address;\n\tmmun_end   = pvmw.address + PAGE_SIZE;\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\n\tif (!page_vma_mapped_walk(&pvmw))\n\t\tgoto out_mn;\n\tif (WARN_ONCE(!pvmw.pte, \"Unexpected PMD mapping?\"))\n\t\tgoto out_unlock;\n\n\tif (pte_write(*pvmw.pte) || pte_dirty(*pvmw.pte) ||\n\t    (pte_protnone(*pvmw.pte) && pte_savedwrite(*pvmw.pte)) ||\n\t\t\t\t\t\tmm_tlb_flush_pending(mm)) {\n\t\tpte_t entry;\n\n\t\tswapped = PageSwapCache(page);\n\t\tflush_cache_page(vma, pvmw.address, page_to_pfn(page));\n\t\t/*\n\t\t * Ok this is tricky, when get_user_pages_fast() run it doesn't\n\t\t * take any lock, therefore the check that we are going to make\n\t\t * with the pagecount against the mapcount is racey and\n\t\t * O_DIRECT can happen right after the check.\n\t\t * So we clear the pte and flush the tlb before the check\n\t\t * this assure us that no O_DIRECT can happen after the check\n\t\t * or in the middle of the check.\n\t\t *\n\t\t * No need to notify as we are downgrading page table to read\n\t\t * only not changing it to point to a new page.\n\t\t *\n\t\t * See Documentation/vm/mmu_notifier.rst\n\t\t */\n\t\tentry = ptep_clear_flush(vma, pvmw.address, pvmw.pte);\n\t\t/*\n\t\t * Check that no O_DIRECT or similar I/O is in progress on the\n\t\t * page\n\t\t */\n\t\tif (page_mapcount(page) + 1 + swapped != page_count(page)) {\n\t\t\tset_pte_at(mm, pvmw.address, pvmw.pte, entry);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (pte_dirty(entry))\n\t\t\tset_page_dirty(page);\n\n\t\tif (pte_protnone(entry))\n\t\t\tentry = pte_mkclean(pte_clear_savedwrite(entry));\n\t\telse\n\t\t\tentry = pte_mkclean(pte_wrprotect(entry));\n\t\tset_pte_at_notify(mm, pvmw.address, pvmw.pte, entry);\n\t}\n\t*orig_pte = *pvmw.pte;\n\terr = 0;\n\nout_unlock:\n\tpage_vma_mapped_walk_done(&pvmw);\nout_mn:\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_end",
          "args": [
            "mm",
            "mmun_start",
            "mmun_end"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_vma_mapped_walk_done",
          "args": [
            "&pvmw"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at_notify",
          "args": [
            "mm",
            "pvmw.address",
            "pvmw.pte",
            "entry"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkclean",
          "args": [
            "pte_wrprotect(entry)"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_wrprotect",
          "args": [
            "entry"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkclean",
          "args": [
            "pte_clear_savedwrite(entry)"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_clear_savedwrite",
          "args": [
            "entry"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_protnone",
          "args": [
            "entry"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_dirty_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2573-2581",
          "snippet": "int set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_dirty",
          "args": [
            "entry"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "mm",
            "pvmw.address",
            "pvmw.pte",
            "entry"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "page"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptep_clear_flush",
          "args": [
            "vma",
            "pvmw.address",
            "pvmw.pte"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "ptep_clear_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "81-90",
          "snippet": "pte_t ptep_clear_flush(struct vm_area_struct *vma, unsigned long address,\n\t\t       pte_t *ptep)\n{\n\tstruct mm_struct *mm = (vma)->vm_mm;\n\tpte_t pte;\n\tpte = ptep_get_and_clear(mm, address, ptep);\n\tif (pte_accessible(mm, pte))\n\t\tflush_tlb_page(vma, address);\n\treturn pte;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\npte_t ptep_clear_flush(struct vm_area_struct *vma, unsigned long address,\n\t\t       pte_t *ptep)\n{\n\tstruct mm_struct *mm = (vma)->vm_mm;\n\tpte_t pte;\n\tpte = ptep_get_and_clear(mm, address, ptep);\n\tif (pte_accessible(mm, pte))\n\t\tflush_tlb_page(vma, address);\n\treturn pte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_cache_page",
          "args": [
            "vma",
            "pvmw.address",
            "page_to_pfn(page)"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_tlb_flush_pending",
          "args": [
            "mm"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_savedwrite",
          "args": [
            "*pvmw.pte"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_protnone",
          "args": [
            "*pvmw.pte"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_dirty",
          "args": [
            "*pvmw.pte"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_write",
          "args": [
            "*pvmw.pte"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "!pvmw.pte",
            "\"Unexpected PMD mapping?\""
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_vma_mapped_walk",
          "args": [
            "&pvmw"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "page_vma_mapped_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_vma_mapped.c",
          "lines": "138-247",
          "snippet": "bool page_vma_mapped_walk(struct page_vma_mapped_walk *pvmw)\n{\n\tstruct mm_struct *mm = pvmw->vma->vm_mm;\n\tstruct page *page = pvmw->page;\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t pmde;\n\n\t/* The only possible pmd mapping has been handled on last iteration */\n\tif (pvmw->pmd && !pvmw->pte)\n\t\treturn not_found(pvmw);\n\n\tif (pvmw->pte)\n\t\tgoto next_pte;\n\n\tif (unlikely(PageHuge(pvmw->page))) {\n\t\t/* when pud is not present, pte will be NULL */\n\t\tpvmw->pte = huge_pte_offset(mm, pvmw->address,\n\t\t\t\t\t    PAGE_SIZE << compound_order(page));\n\t\tif (!pvmw->pte)\n\t\t\treturn false;\n\n\t\tpvmw->ptl = huge_pte_lockptr(page_hstate(page), mm, pvmw->pte);\n\t\tspin_lock(pvmw->ptl);\n\t\tif (!check_pte(pvmw))\n\t\t\treturn not_found(pvmw);\n\t\treturn true;\n\t}\nrestart:\n\tpgd = pgd_offset(mm, pvmw->address);\n\tif (!pgd_present(*pgd))\n\t\treturn false;\n\tp4d = p4d_offset(pgd, pvmw->address);\n\tif (!p4d_present(*p4d))\n\t\treturn false;\n\tpud = pud_offset(p4d, pvmw->address);\n\tif (!pud_present(*pud))\n\t\treturn false;\n\tpvmw->pmd = pmd_offset(pud, pvmw->address);\n\t/*\n\t * Make sure the pmd value isn't cached in a register by the\n\t * compiler and used as a stale value after we've observed a\n\t * subsequent update.\n\t */\n\tpmde = READ_ONCE(*pvmw->pmd);\n\tif (pmd_trans_huge(pmde) || is_pmd_migration_entry(pmde)) {\n\t\tpvmw->ptl = pmd_lock(mm, pvmw->pmd);\n\t\tif (likely(pmd_trans_huge(*pvmw->pmd))) {\n\t\t\tif (pvmw->flags & PVMW_MIGRATION)\n\t\t\t\treturn not_found(pvmw);\n\t\t\tif (pmd_page(*pvmw->pmd) != page)\n\t\t\t\treturn not_found(pvmw);\n\t\t\treturn true;\n\t\t} else if (!pmd_present(*pvmw->pmd)) {\n\t\t\tif (thp_migration_supported()) {\n\t\t\t\tif (!(pvmw->flags & PVMW_MIGRATION))\n\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\tif (is_migration_entry(pmd_to_swp_entry(*pvmw->pmd))) {\n\t\t\t\t\tswp_entry_t entry = pmd_to_swp_entry(*pvmw->pmd);\n\n\t\t\t\t\tif (migration_entry_to_page(entry) != page)\n\t\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn not_found(pvmw);\n\t\t} else {\n\t\t\t/* THP pmd was split under us: handle on pte level */\n\t\t\tspin_unlock(pvmw->ptl);\n\t\t\tpvmw->ptl = NULL;\n\t\t}\n\t} else if (!pmd_present(pmde)) {\n\t\treturn false;\n\t}\n\tif (!map_pte(pvmw))\n\t\tgoto next_pte;\n\twhile (1) {\n\t\tif (check_pte(pvmw))\n\t\t\treturn true;\nnext_pte:\n\t\t/* Seek to next pte only makes sense for THP */\n\t\tif (!PageTransHuge(pvmw->page) || PageHuge(pvmw->page))\n\t\t\treturn not_found(pvmw);\n\t\tdo {\n\t\t\tpvmw->address += PAGE_SIZE;\n\t\t\tif (pvmw->address >= pvmw->vma->vm_end ||\n\t\t\t    pvmw->address >=\n\t\t\t\t\t__vma_address(pvmw->page, pvmw->vma) +\n\t\t\t\t\thpage_nr_pages(pvmw->page) * PAGE_SIZE)\n\t\t\t\treturn not_found(pvmw);\n\t\t\t/* Did we cross page table boundary? */\n\t\t\tif (pvmw->address % PMD_SIZE == 0) {\n\t\t\t\tpte_unmap(pvmw->pte);\n\t\t\t\tif (pvmw->ptl) {\n\t\t\t\t\tspin_unlock(pvmw->ptl);\n\t\t\t\t\tpvmw->ptl = NULL;\n\t\t\t\t}\n\t\t\t\tgoto restart;\n\t\t\t} else {\n\t\t\t\tpvmw->pte++;\n\t\t\t}\n\t\t} while (pte_none(*pvmw->pte));\n\n\t\tif (!pvmw->ptl) {\n\t\t\tpvmw->ptl = pte_lockptr(mm, pvmw->pmd);\n\t\t\tspin_lock(pvmw->ptl);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/hugetlb.h>\n#include <linux/rmap.h>\n#include <linux/mm.h>\n\nbool page_vma_mapped_walk(struct page_vma_mapped_walk *pvmw)\n{\n\tstruct mm_struct *mm = pvmw->vma->vm_mm;\n\tstruct page *page = pvmw->page;\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t pmde;\n\n\t/* The only possible pmd mapping has been handled on last iteration */\n\tif (pvmw->pmd && !pvmw->pte)\n\t\treturn not_found(pvmw);\n\n\tif (pvmw->pte)\n\t\tgoto next_pte;\n\n\tif (unlikely(PageHuge(pvmw->page))) {\n\t\t/* when pud is not present, pte will be NULL */\n\t\tpvmw->pte = huge_pte_offset(mm, pvmw->address,\n\t\t\t\t\t    PAGE_SIZE << compound_order(page));\n\t\tif (!pvmw->pte)\n\t\t\treturn false;\n\n\t\tpvmw->ptl = huge_pte_lockptr(page_hstate(page), mm, pvmw->pte);\n\t\tspin_lock(pvmw->ptl);\n\t\tif (!check_pte(pvmw))\n\t\t\treturn not_found(pvmw);\n\t\treturn true;\n\t}\nrestart:\n\tpgd = pgd_offset(mm, pvmw->address);\n\tif (!pgd_present(*pgd))\n\t\treturn false;\n\tp4d = p4d_offset(pgd, pvmw->address);\n\tif (!p4d_present(*p4d))\n\t\treturn false;\n\tpud = pud_offset(p4d, pvmw->address);\n\tif (!pud_present(*pud))\n\t\treturn false;\n\tpvmw->pmd = pmd_offset(pud, pvmw->address);\n\t/*\n\t * Make sure the pmd value isn't cached in a register by the\n\t * compiler and used as a stale value after we've observed a\n\t * subsequent update.\n\t */\n\tpmde = READ_ONCE(*pvmw->pmd);\n\tif (pmd_trans_huge(pmde) || is_pmd_migration_entry(pmde)) {\n\t\tpvmw->ptl = pmd_lock(mm, pvmw->pmd);\n\t\tif (likely(pmd_trans_huge(*pvmw->pmd))) {\n\t\t\tif (pvmw->flags & PVMW_MIGRATION)\n\t\t\t\treturn not_found(pvmw);\n\t\t\tif (pmd_page(*pvmw->pmd) != page)\n\t\t\t\treturn not_found(pvmw);\n\t\t\treturn true;\n\t\t} else if (!pmd_present(*pvmw->pmd)) {\n\t\t\tif (thp_migration_supported()) {\n\t\t\t\tif (!(pvmw->flags & PVMW_MIGRATION))\n\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\tif (is_migration_entry(pmd_to_swp_entry(*pvmw->pmd))) {\n\t\t\t\t\tswp_entry_t entry = pmd_to_swp_entry(*pvmw->pmd);\n\n\t\t\t\t\tif (migration_entry_to_page(entry) != page)\n\t\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn not_found(pvmw);\n\t\t} else {\n\t\t\t/* THP pmd was split under us: handle on pte level */\n\t\t\tspin_unlock(pvmw->ptl);\n\t\t\tpvmw->ptl = NULL;\n\t\t}\n\t} else if (!pmd_present(pmde)) {\n\t\treturn false;\n\t}\n\tif (!map_pte(pvmw))\n\t\tgoto next_pte;\n\twhile (1) {\n\t\tif (check_pte(pvmw))\n\t\t\treturn true;\nnext_pte:\n\t\t/* Seek to next pte only makes sense for THP */\n\t\tif (!PageTransHuge(pvmw->page) || PageHuge(pvmw->page))\n\t\t\treturn not_found(pvmw);\n\t\tdo {\n\t\t\tpvmw->address += PAGE_SIZE;\n\t\t\tif (pvmw->address >= pvmw->vma->vm_end ||\n\t\t\t    pvmw->address >=\n\t\t\t\t\t__vma_address(pvmw->page, pvmw->vma) +\n\t\t\t\t\thpage_nr_pages(pvmw->page) * PAGE_SIZE)\n\t\t\t\treturn not_found(pvmw);\n\t\t\t/* Did we cross page table boundary? */\n\t\t\tif (pvmw->address % PMD_SIZE == 0) {\n\t\t\t\tpte_unmap(pvmw->pte);\n\t\t\t\tif (pvmw->ptl) {\n\t\t\t\t\tspin_unlock(pvmw->ptl);\n\t\t\t\t\tpvmw->ptl = NULL;\n\t\t\t\t}\n\t\t\t\tgoto restart;\n\t\t\t} else {\n\t\t\t\tpvmw->pte++;\n\t\t\t}\n\t\t} while (pte_none(*pvmw->pte));\n\n\t\tif (!pvmw->ptl) {\n\t\t\tpvmw->ptl = pte_lockptr(mm, pvmw->pmd);\n\t\t\tspin_lock(pvmw->ptl);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "mm",
            "mmun_start",
            "mmun_end"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageTransCompound(page)"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "page"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address_in_vma",
          "args": [
            "page",
            "vma"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "page_address_in_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "687-708",
          "snippet": "unsigned long page_address_in_vma(struct page *page, struct vm_area_struct *vma)\n{\n\tunsigned long address;\n\tif (PageAnon(page)) {\n\t\tstruct anon_vma *page__anon_vma = page_anon_vma(page);\n\t\t/*\n\t\t * Note: swapoff's unuse_vma() is more efficient with this\n\t\t * check, and needs it to match anon_vma when KSM is active.\n\t\t */\n\t\tif (!vma->anon_vma || !page__anon_vma ||\n\t\t    vma->anon_vma->root != page__anon_vma->root)\n\t\t\treturn -EFAULT;\n\t} else if (page->mapping) {\n\t\tif (!vma->vm_file || vma->vm_file->f_mapping != page->mapping)\n\t\t\treturn -EFAULT;\n\t} else\n\t\treturn -EFAULT;\n\taddress = __vma_address(page, vma);\n\tif (unlikely(address < vma->vm_start || address >= vma->vm_end))\n\t\treturn -EFAULT;\n\treturn address;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long page_address_in_vma(struct page *page, struct vm_area_struct *vma)\n{\n\tunsigned long address;\n\tif (PageAnon(page)) {\n\t\tstruct anon_vma *page__anon_vma = page_anon_vma(page);\n\t\t/*\n\t\t * Note: swapoff's unuse_vma() is more efficient with this\n\t\t * check, and needs it to match anon_vma when KSM is active.\n\t\t */\n\t\tif (!vma->anon_vma || !page__anon_vma ||\n\t\t    vma->anon_vma->root != page__anon_vma->root)\n\t\t\treturn -EFAULT;\n\t} else if (page->mapping) {\n\t\tif (!vma->vm_file || vma->vm_file->f_mapping != page->mapping)\n\t\t\treturn -EFAULT;\n\t} else\n\t\treturn -EFAULT;\n\taddress = __vma_address(page, vma);\n\tif (unlikely(address < vma->vm_start || address >= vma->vm_end))\n\t\treturn -EFAULT;\n\treturn address;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int write_protect_page(struct vm_area_struct *vma, struct page *page,\n\t\t\t      pte_t *orig_pte)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = page,\n\t\t.vma = vma,\n\t};\n\tint swapped;\n\tint err = -EFAULT;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\n\tpvmw.address = page_address_in_vma(page, vma);\n\tif (pvmw.address == -EFAULT)\n\t\tgoto out;\n\n\tBUG_ON(PageTransCompound(page));\n\n\tmmun_start = pvmw.address;\n\tmmun_end   = pvmw.address + PAGE_SIZE;\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\n\tif (!page_vma_mapped_walk(&pvmw))\n\t\tgoto out_mn;\n\tif (WARN_ONCE(!pvmw.pte, \"Unexpected PMD mapping?\"))\n\t\tgoto out_unlock;\n\n\tif (pte_write(*pvmw.pte) || pte_dirty(*pvmw.pte) ||\n\t    (pte_protnone(*pvmw.pte) && pte_savedwrite(*pvmw.pte)) ||\n\t\t\t\t\t\tmm_tlb_flush_pending(mm)) {\n\t\tpte_t entry;\n\n\t\tswapped = PageSwapCache(page);\n\t\tflush_cache_page(vma, pvmw.address, page_to_pfn(page));\n\t\t/*\n\t\t * Ok this is tricky, when get_user_pages_fast() run it doesn't\n\t\t * take any lock, therefore the check that we are going to make\n\t\t * with the pagecount against the mapcount is racey and\n\t\t * O_DIRECT can happen right after the check.\n\t\t * So we clear the pte and flush the tlb before the check\n\t\t * this assure us that no O_DIRECT can happen after the check\n\t\t * or in the middle of the check.\n\t\t *\n\t\t * No need to notify as we are downgrading page table to read\n\t\t * only not changing it to point to a new page.\n\t\t *\n\t\t * See Documentation/vm/mmu_notifier.rst\n\t\t */\n\t\tentry = ptep_clear_flush(vma, pvmw.address, pvmw.pte);\n\t\t/*\n\t\t * Check that no O_DIRECT or similar I/O is in progress on the\n\t\t * page\n\t\t */\n\t\tif (page_mapcount(page) + 1 + swapped != page_count(page)) {\n\t\t\tset_pte_at(mm, pvmw.address, pvmw.pte, entry);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (pte_dirty(entry))\n\t\t\tset_page_dirty(page);\n\n\t\tif (pte_protnone(entry))\n\t\t\tentry = pte_mkclean(pte_clear_savedwrite(entry));\n\t\telse\n\t\t\tentry = pte_mkclean(pte_wrprotect(entry));\n\t\tset_pte_at_notify(mm, pvmw.address, pvmw.pte, entry);\n\t}\n\t*orig_pte = *pvmw.pte;\n\terr = 0;\n\nout_unlock:\n\tpage_vma_mapped_walk_done(&pvmw);\nout_mn:\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "pages_identical",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "1030-1033",
    "snippet": "static inline int pages_identical(struct page *page1, struct page *page2)\n{\n\treturn !memcmp_pages(page1, page2);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp_pages",
          "args": [
            "page1",
            "page2"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "memcmp_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "1017-1028",
          "snippet": "static int memcmp_pages(struct page *page1, struct page *page2)\n{\n\tchar *addr1, *addr2;\n\tint ret;\n\n\taddr1 = kmap_atomic(page1);\n\taddr2 = kmap_atomic(page2);\n\tret = memcmp(addr1, addr2, PAGE_SIZE);\n\tkunmap_atomic(addr2);\n\tkunmap_atomic(addr1);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int memcmp_pages(struct page *page1, struct page *page2)\n{\n\tchar *addr1, *addr2;\n\tint ret;\n\n\taddr1 = kmap_atomic(page1);\n\taddr2 = kmap_atomic(page2);\n\tret = memcmp(addr1, addr2, PAGE_SIZE);\n\tkunmap_atomic(addr2);\n\tkunmap_atomic(addr1);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline int pages_identical(struct page *page1, struct page *page2)\n{\n\treturn !memcmp_pages(page1, page2);\n}"
  },
  {
    "function_name": "memcmp_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "1017-1028",
    "snippet": "static int memcmp_pages(struct page *page1, struct page *page2)\n{\n\tchar *addr1, *addr2;\n\tint ret;\n\n\taddr1 = kmap_atomic(page1);\n\taddr2 = kmap_atomic(page2);\n\tret = memcmp(addr1, addr2, PAGE_SIZE);\n\tkunmap_atomic(addr2);\n\tkunmap_atomic(addr1);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "addr1"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "addr2"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "addr1",
            "addr2",
            "PAGE_SIZE"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page2"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page1"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int memcmp_pages(struct page *page1, struct page *page2)\n{\n\tchar *addr1, *addr2;\n\tint ret;\n\n\taddr1 = kmap_atomic(page1);\n\taddr2 = kmap_atomic(page2);\n\tret = memcmp(addr1, addr2, PAGE_SIZE);\n\tkunmap_atomic(addr2);\n\tkunmap_atomic(addr1);\n\treturn ret;\n}"
  },
  {
    "function_name": "calc_checksum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "1008-1015",
    "snippet": "static u32 calc_checksum(struct page *page)\n{\n\tu32 checksum;\n\tvoid *addr = kmap_atomic(page);\n\tchecksum = jhash2(addr, PAGE_SIZE / 4, 17);\n\tkunmap_atomic(addr);\n\treturn checksum;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "addr"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jhash2",
          "args": [
            "addr",
            "PAGE_SIZE / 4",
            "17"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic u32 calc_checksum(struct page *page)\n{\n\tu32 checksum;\n\tvoid *addr = kmap_atomic(page);\n\tchecksum = jhash2(addr, PAGE_SIZE / 4, 17);\n\tkunmap_atomic(addr);\n\treturn checksum;\n}"
  },
  {
    "function_name": "unmerge_and_remove_all_rmap_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "949-1005",
    "snippet": "static int unmerge_and_remove_all_rmap_items(void)\n{\n\tstruct mm_slot *mm_slot;\n\tstruct mm_struct *mm;\n\tstruct vm_area_struct *vma;\n\tint err = 0;\n\n\tspin_lock(&ksm_mmlist_lock);\n\tksm_scan.mm_slot = list_entry(ksm_mm_head.mm_list.next,\n\t\t\t\t\t\tstruct mm_slot, mm_list);\n\tspin_unlock(&ksm_mmlist_lock);\n\n\tfor (mm_slot = ksm_scan.mm_slot;\n\t\t\tmm_slot != &ksm_mm_head; mm_slot = ksm_scan.mm_slot) {\n\t\tmm = mm_slot->mm;\n\t\tdown_read(&mm->mmap_sem);\n\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\t\tif (ksm_test_exit(mm))\n\t\t\t\tbreak;\n\t\t\tif (!(vma->vm_flags & VM_MERGEABLE) || !vma->anon_vma)\n\t\t\t\tcontinue;\n\t\t\terr = unmerge_ksm_pages(vma,\n\t\t\t\t\t\tvma->vm_start, vma->vm_end);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tremove_trailing_rmap_items(mm_slot, &mm_slot->rmap_list);\n\t\tup_read(&mm->mmap_sem);\n\n\t\tspin_lock(&ksm_mmlist_lock);\n\t\tksm_scan.mm_slot = list_entry(mm_slot->mm_list.next,\n\t\t\t\t\t\tstruct mm_slot, mm_list);\n\t\tif (ksm_test_exit(mm)) {\n\t\t\thash_del(&mm_slot->link);\n\t\t\tlist_del(&mm_slot->mm_list);\n\t\t\tspin_unlock(&ksm_mmlist_lock);\n\n\t\t\tfree_mm_slot(mm_slot);\n\t\t\tclear_bit(MMF_VM_MERGEABLE, &mm->flags);\n\t\t\tmmdrop(mm);\n\t\t} else\n\t\t\tspin_unlock(&ksm_mmlist_lock);\n\t}\n\n\t/* Clean up stable nodes, but don't worry if some are still busy */\n\tremove_all_stable_nodes();\n\tksm_scan.seqnr = 0;\n\treturn 0;\n\nerror:\n\tup_read(&mm->mmap_sem);\n\tspin_lock(&ksm_mmlist_lock);\n\tksm_scan.mm_slot = &ksm_mm_head;\n\tspin_unlock(&ksm_mmlist_lock);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct mm_slot ksm_mm_head = {\n\t.mm_list = LIST_HEAD_INIT(ksm_mm_head.mm_list),\n};",
      "static struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};",
      "static DEFINE_SPINLOCK(ksm_mmlist_lock);",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ksm_mmlist_lock"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ksm_mmlist_lock"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_all_stable_nodes",
          "args": [],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "remove_all_stable_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "923-947",
          "snippet": "static int remove_all_stable_nodes(void)\n{\n\tstruct stable_node *stable_node, *next;\n\tint nid;\n\tint err = 0;\n\n\tfor (nid = 0; nid < ksm_nr_node_ids; nid++) {\n\t\twhile (root_stable_tree[nid].rb_node) {\n\t\t\tstable_node = rb_entry(root_stable_tree[nid].rb_node,\n\t\t\t\t\t\tstruct stable_node, node);\n\t\t\tif (remove_stable_node_chain(stable_node,\n\t\t\t\t\t\t     root_stable_tree + nid)) {\n\t\t\t\terr = -EBUSY;\n\t\t\t\tbreak;\t/* proceed to next nid */\n\t\t\t}\n\t\t\tcond_resched();\n\t\t}\n\t}\n\tlist_for_each_entry_safe(stable_node, next, &migrate_nodes, list) {\n\t\tif (remove_stable_node(stable_node))\n\t\t\terr = -EBUSY;\n\t\tcond_resched();\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define ksm_nr_node_ids\t\t1"
          ],
          "globals_used": [
            "static struct rb_root *root_stable_tree = one_stable_tree;",
            "static LIST_HEAD(migrate_nodes);",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define ksm_nr_node_ids\t\t1\n\nstatic struct rb_root *root_stable_tree = one_stable_tree;\nstatic LIST_HEAD(migrate_nodes);\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int remove_all_stable_nodes(void)\n{\n\tstruct stable_node *stable_node, *next;\n\tint nid;\n\tint err = 0;\n\n\tfor (nid = 0; nid < ksm_nr_node_ids; nid++) {\n\t\twhile (root_stable_tree[nid].rb_node) {\n\t\t\tstable_node = rb_entry(root_stable_tree[nid].rb_node,\n\t\t\t\t\t\tstruct stable_node, node);\n\t\t\tif (remove_stable_node_chain(stable_node,\n\t\t\t\t\t\t     root_stable_tree + nid)) {\n\t\t\t\terr = -EBUSY;\n\t\t\t\tbreak;\t/* proceed to next nid */\n\t\t\t}\n\t\t\tcond_resched();\n\t\t}\n\t}\n\tlist_for_each_entry_safe(stable_node, next, &migrate_nodes, list) {\n\t\tif (remove_stable_node(stable_node))\n\t\t\terr = -EBUSY;\n\t\tcond_resched();\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ksm_mmlist_lock"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmdrop",
          "args": [
            "mm"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "MMF_VM_MERGEABLE",
            "&mm->flags"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "clear_bit_unlock_is_negative_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1171-1176",
          "snippet": "static inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_mm_slot",
          "args": [
            "mm_slot"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "free_mm_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "419-422",
          "snippet": "static inline void free_mm_slot(struct mm_slot *mm_slot)\n{\n\tkmem_cache_free(mm_slot_cache, mm_slot);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *mm_slot_cache;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct kmem_cache *mm_slot_cache;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void free_mm_slot(struct mm_slot *mm_slot)\n{\n\tkmem_cache_free(mm_slot_cache, mm_slot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ksm_mmlist_lock"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&mm_slot->mm_list"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_del",
          "args": [
            "&mm_slot->link"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ksm_test_exit",
          "args": [
            "mm"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "ksm_test_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "450-453",
          "snippet": "static inline bool ksm_test_exit(struct mm_struct *mm)\n{\n\treturn atomic_read(&mm->mm_users) == 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline bool ksm_test_exit(struct mm_struct *mm)\n{\n\treturn atomic_read(&mm->mm_users) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "mm_slot->mm_list.next",
            "structmm_slot",
            "mm_list"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ksm_mmlist_lock"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_trailing_rmap_items",
          "args": [
            "mm_slot",
            "&mm_slot->rmap_list"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "remove_trailing_rmap_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "804-813",
          "snippet": "static void remove_trailing_rmap_items(struct mm_slot *mm_slot,\n\t\t\t\t       struct rmap_item **rmap_list)\n{\n\twhile (*rmap_list) {\n\t\tstruct rmap_item *rmap_item = *rmap_list;\n\t\t*rmap_list = rmap_item->rmap_list;\n\t\tremove_rmap_item_from_tree(rmap_item);\n\t\tfree_rmap_item(rmap_item);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic void remove_trailing_rmap_items(struct mm_slot *mm_slot,\n\t\t\t\t       struct rmap_item **rmap_list)\n{\n\twhile (*rmap_list) {\n\t\tstruct rmap_item *rmap_item = *rmap_list;\n\t\t*rmap_list = rmap_item->rmap_list;\n\t\tremove_rmap_item_from_tree(rmap_item);\n\t\tfree_rmap_item(rmap_item);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unmerge_ksm_pages",
          "args": [
            "vma",
            "vma->vm_start",
            "vma->vm_end"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "unmerge_ksm_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "828-843",
          "snippet": "static int unmerge_ksm_pages(struct vm_area_struct *vma,\n\t\t\t     unsigned long start, unsigned long end)\n{\n\tunsigned long addr;\n\tint err = 0;\n\n\tfor (addr = start; addr < end && !err; addr += PAGE_SIZE) {\n\t\tif (ksm_test_exit(vma->vm_mm))\n\t\t\tbreak;\n\t\tif (signal_pending(current))\n\t\t\terr = -ERESTARTSYS;\n\t\telse\n\t\t\terr = break_ksm(vma, addr);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int unmerge_ksm_pages(struct vm_area_struct *vma,\n\t\t\t     unsigned long start, unsigned long end)\n{\n\tunsigned long addr;\n\tint err = 0;\n\n\tfor (addr = start; addr < end && !err; addr += PAGE_SIZE) {\n\t\tif (ksm_test_exit(vma->vm_mm))\n\t\t\tbreak;\n\t\tif (signal_pending(current))\n\t\t\terr = -ERESTARTSYS;\n\t\telse\n\t\t\terr = break_ksm(vma, addr);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ksm_mmlist_lock"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "ksm_mm_head.mm_list.next",
            "structmm_slot",
            "mm_list"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ksm_mmlist_lock"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct mm_slot ksm_mm_head = {\n\t.mm_list = LIST_HEAD_INIT(ksm_mm_head.mm_list),\n};\nstatic struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};\nstatic DEFINE_SPINLOCK(ksm_mmlist_lock);\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int unmerge_and_remove_all_rmap_items(void)\n{\n\tstruct mm_slot *mm_slot;\n\tstruct mm_struct *mm;\n\tstruct vm_area_struct *vma;\n\tint err = 0;\n\n\tspin_lock(&ksm_mmlist_lock);\n\tksm_scan.mm_slot = list_entry(ksm_mm_head.mm_list.next,\n\t\t\t\t\t\tstruct mm_slot, mm_list);\n\tspin_unlock(&ksm_mmlist_lock);\n\n\tfor (mm_slot = ksm_scan.mm_slot;\n\t\t\tmm_slot != &ksm_mm_head; mm_slot = ksm_scan.mm_slot) {\n\t\tmm = mm_slot->mm;\n\t\tdown_read(&mm->mmap_sem);\n\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\t\tif (ksm_test_exit(mm))\n\t\t\t\tbreak;\n\t\t\tif (!(vma->vm_flags & VM_MERGEABLE) || !vma->anon_vma)\n\t\t\t\tcontinue;\n\t\t\terr = unmerge_ksm_pages(vma,\n\t\t\t\t\t\tvma->vm_start, vma->vm_end);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tremove_trailing_rmap_items(mm_slot, &mm_slot->rmap_list);\n\t\tup_read(&mm->mmap_sem);\n\n\t\tspin_lock(&ksm_mmlist_lock);\n\t\tksm_scan.mm_slot = list_entry(mm_slot->mm_list.next,\n\t\t\t\t\t\tstruct mm_slot, mm_list);\n\t\tif (ksm_test_exit(mm)) {\n\t\t\thash_del(&mm_slot->link);\n\t\t\tlist_del(&mm_slot->mm_list);\n\t\t\tspin_unlock(&ksm_mmlist_lock);\n\n\t\t\tfree_mm_slot(mm_slot);\n\t\t\tclear_bit(MMF_VM_MERGEABLE, &mm->flags);\n\t\t\tmmdrop(mm);\n\t\t} else\n\t\t\tspin_unlock(&ksm_mmlist_lock);\n\t}\n\n\t/* Clean up stable nodes, but don't worry if some are still busy */\n\tremove_all_stable_nodes();\n\tksm_scan.seqnr = 0;\n\treturn 0;\n\nerror:\n\tup_read(&mm->mmap_sem);\n\tspin_lock(&ksm_mmlist_lock);\n\tksm_scan.mm_slot = &ksm_mm_head;\n\tspin_unlock(&ksm_mmlist_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "remove_all_stable_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "923-947",
    "snippet": "static int remove_all_stable_nodes(void)\n{\n\tstruct stable_node *stable_node, *next;\n\tint nid;\n\tint err = 0;\n\n\tfor (nid = 0; nid < ksm_nr_node_ids; nid++) {\n\t\twhile (root_stable_tree[nid].rb_node) {\n\t\t\tstable_node = rb_entry(root_stable_tree[nid].rb_node,\n\t\t\t\t\t\tstruct stable_node, node);\n\t\t\tif (remove_stable_node_chain(stable_node,\n\t\t\t\t\t\t     root_stable_tree + nid)) {\n\t\t\t\terr = -EBUSY;\n\t\t\t\tbreak;\t/* proceed to next nid */\n\t\t\t}\n\t\t\tcond_resched();\n\t\t}\n\t}\n\tlist_for_each_entry_safe(stable_node, next, &migrate_nodes, list) {\n\t\tif (remove_stable_node(stable_node))\n\t\t\terr = -EBUSY;\n\t\tcond_resched();\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define ksm_nr_node_ids\t\t1"
    ],
    "globals_used": [
      "static struct rb_root *root_stable_tree = one_stable_tree;",
      "static LIST_HEAD(migrate_nodes);",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_stable_node",
          "args": [
            "stable_node"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "remove_stable_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "860-896",
          "snippet": "static int remove_stable_node(struct stable_node *stable_node)\n{\n\tstruct page *page;\n\tint err;\n\n\tpage = get_ksm_page(stable_node, true);\n\tif (!page) {\n\t\t/*\n\t\t * get_ksm_page did remove_node_from_stable_tree itself.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tif (WARN_ON_ONCE(page_mapped(page))) {\n\t\t/*\n\t\t * This should not happen: but if it does, just refuse to let\n\t\t * merge_across_nodes be switched - there is no need to panic.\n\t\t */\n\t\terr = -EBUSY;\n\t} else {\n\t\t/*\n\t\t * The stable node did not yet appear stale to get_ksm_page(),\n\t\t * since that allows for an unmapped ksm page to be recognized\n\t\t * right up until it is freed; but the node is safe to remove.\n\t\t * This page might be in a pagevec waiting to be freed,\n\t\t * or it might be PageSwapCache (perhaps under writeback),\n\t\t * or it might have been removed from swapcache a moment ago.\n\t\t */\n\t\tset_page_stable_node(page, NULL);\n\t\tremove_node_from_stable_tree(stable_node);\n\t\terr = 0;\n\t}\n\n\tunlock_page(page);\n\tput_page(page);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int remove_stable_node(struct stable_node *stable_node)\n{\n\tstruct page *page;\n\tint err;\n\n\tpage = get_ksm_page(stable_node, true);\n\tif (!page) {\n\t\t/*\n\t\t * get_ksm_page did remove_node_from_stable_tree itself.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tif (WARN_ON_ONCE(page_mapped(page))) {\n\t\t/*\n\t\t * This should not happen: but if it does, just refuse to let\n\t\t * merge_across_nodes be switched - there is no need to panic.\n\t\t */\n\t\terr = -EBUSY;\n\t} else {\n\t\t/*\n\t\t * The stable node did not yet appear stale to get_ksm_page(),\n\t\t * since that allows for an unmapped ksm page to be recognized\n\t\t * right up until it is freed; but the node is safe to remove.\n\t\t * This page might be in a pagevec waiting to be freed,\n\t\t * or it might be PageSwapCache (perhaps under writeback),\n\t\t * or it might have been removed from swapcache a moment ago.\n\t\t */\n\t\tset_page_stable_node(page, NULL);\n\t\tremove_node_from_stable_tree(stable_node);\n\t\terr = 0;\n\t}\n\n\tunlock_page(page);\n\tput_page(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "stable_node",
            "next",
            "&migrate_nodes",
            "list"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_stable_node_chain",
          "args": [
            "stable_node",
            "root_stable_tree + nid"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "remove_stable_node_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "898-921",
          "snippet": "static int remove_stable_node_chain(struct stable_node *stable_node,\n\t\t\t\t    struct rb_root *root)\n{\n\tstruct stable_node *dup;\n\tstruct hlist_node *hlist_safe;\n\n\tif (!is_stable_node_chain(stable_node)) {\n\t\tVM_BUG_ON(is_stable_node_dup(stable_node));\n\t\tif (remove_stable_node(stable_node))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\thlist_for_each_entry_safe(dup, hlist_safe,\n\t\t\t\t  &stable_node->hlist, hlist_dup) {\n\t\tVM_BUG_ON(!is_stable_node_dup(dup));\n\t\tif (remove_stable_node(dup))\n\t\t\treturn true;\n\t}\n\tBUG_ON(!hlist_empty(&stable_node->hlist));\n\tfree_stable_node_chain(stable_node, root);\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int remove_stable_node_chain(struct stable_node *stable_node,\n\t\t\t\t    struct rb_root *root)\n{\n\tstruct stable_node *dup;\n\tstruct hlist_node *hlist_safe;\n\n\tif (!is_stable_node_chain(stable_node)) {\n\t\tVM_BUG_ON(is_stable_node_dup(stable_node));\n\t\tif (remove_stable_node(stable_node))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\thlist_for_each_entry_safe(dup, hlist_safe,\n\t\t\t\t  &stable_node->hlist, hlist_dup) {\n\t\tVM_BUG_ON(!is_stable_node_dup(dup));\n\t\tif (remove_stable_node(dup))\n\t\t\treturn true;\n\t}\n\tBUG_ON(!hlist_empty(&stable_node->hlist));\n\tfree_stable_node_chain(stable_node, root);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "root_stable_tree[nid].rb_node",
            "structstable_node",
            "node"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define ksm_nr_node_ids\t\t1\n\nstatic struct rb_root *root_stable_tree = one_stable_tree;\nstatic LIST_HEAD(migrate_nodes);\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int remove_all_stable_nodes(void)\n{\n\tstruct stable_node *stable_node, *next;\n\tint nid;\n\tint err = 0;\n\n\tfor (nid = 0; nid < ksm_nr_node_ids; nid++) {\n\t\twhile (root_stable_tree[nid].rb_node) {\n\t\t\tstable_node = rb_entry(root_stable_tree[nid].rb_node,\n\t\t\t\t\t\tstruct stable_node, node);\n\t\t\tif (remove_stable_node_chain(stable_node,\n\t\t\t\t\t\t     root_stable_tree + nid)) {\n\t\t\t\terr = -EBUSY;\n\t\t\t\tbreak;\t/* proceed to next nid */\n\t\t\t}\n\t\t\tcond_resched();\n\t\t}\n\t}\n\tlist_for_each_entry_safe(stable_node, next, &migrate_nodes, list) {\n\t\tif (remove_stable_node(stable_node))\n\t\t\terr = -EBUSY;\n\t\tcond_resched();\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "remove_stable_node_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "898-921",
    "snippet": "static int remove_stable_node_chain(struct stable_node *stable_node,\n\t\t\t\t    struct rb_root *root)\n{\n\tstruct stable_node *dup;\n\tstruct hlist_node *hlist_safe;\n\n\tif (!is_stable_node_chain(stable_node)) {\n\t\tVM_BUG_ON(is_stable_node_dup(stable_node));\n\t\tif (remove_stable_node(stable_node))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\thlist_for_each_entry_safe(dup, hlist_safe,\n\t\t\t\t  &stable_node->hlist, hlist_dup) {\n\t\tVM_BUG_ON(!is_stable_node_dup(dup));\n\t\tif (remove_stable_node(dup))\n\t\t\treturn true;\n\t}\n\tBUG_ON(!hlist_empty(&stable_node->hlist));\n\tfree_stable_node_chain(stable_node, root);\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_stable_node_chain",
          "args": [
            "stable_node",
            "root"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "free_stable_node_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "623-629",
          "snippet": "static inline void free_stable_node_chain(struct stable_node *chain,\n\t\t\t\t\t  struct rb_root *root)\n{\n\trb_erase(&chain->node, root);\n\tfree_stable_node(chain);\n\tksm_stable_node_chains--;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long ksm_stable_node_chains;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic unsigned long ksm_stable_node_chains;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void free_stable_node_chain(struct stable_node *chain,\n\t\t\t\t\t  struct rb_root *root)\n{\n\trb_erase(&chain->node, root);\n\tfree_stable_node(chain);\n\tksm_stable_node_chains--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!hlist_empty(&stable_node->hlist)"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&stable_node->hlist"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_stable_node",
          "args": [
            "dup"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "remove_stable_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "860-896",
          "snippet": "static int remove_stable_node(struct stable_node *stable_node)\n{\n\tstruct page *page;\n\tint err;\n\n\tpage = get_ksm_page(stable_node, true);\n\tif (!page) {\n\t\t/*\n\t\t * get_ksm_page did remove_node_from_stable_tree itself.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tif (WARN_ON_ONCE(page_mapped(page))) {\n\t\t/*\n\t\t * This should not happen: but if it does, just refuse to let\n\t\t * merge_across_nodes be switched - there is no need to panic.\n\t\t */\n\t\terr = -EBUSY;\n\t} else {\n\t\t/*\n\t\t * The stable node did not yet appear stale to get_ksm_page(),\n\t\t * since that allows for an unmapped ksm page to be recognized\n\t\t * right up until it is freed; but the node is safe to remove.\n\t\t * This page might be in a pagevec waiting to be freed,\n\t\t * or it might be PageSwapCache (perhaps under writeback),\n\t\t * or it might have been removed from swapcache a moment ago.\n\t\t */\n\t\tset_page_stable_node(page, NULL);\n\t\tremove_node_from_stable_tree(stable_node);\n\t\terr = 0;\n\t}\n\n\tunlock_page(page);\n\tput_page(page);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int remove_stable_node(struct stable_node *stable_node)\n{\n\tstruct page *page;\n\tint err;\n\n\tpage = get_ksm_page(stable_node, true);\n\tif (!page) {\n\t\t/*\n\t\t * get_ksm_page did remove_node_from_stable_tree itself.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tif (WARN_ON_ONCE(page_mapped(page))) {\n\t\t/*\n\t\t * This should not happen: but if it does, just refuse to let\n\t\t * merge_across_nodes be switched - there is no need to panic.\n\t\t */\n\t\terr = -EBUSY;\n\t} else {\n\t\t/*\n\t\t * The stable node did not yet appear stale to get_ksm_page(),\n\t\t * since that allows for an unmapped ksm page to be recognized\n\t\t * right up until it is freed; but the node is safe to remove.\n\t\t * This page might be in a pagevec waiting to be freed,\n\t\t * or it might be PageSwapCache (perhaps under writeback),\n\t\t * or it might have been removed from swapcache a moment ago.\n\t\t */\n\t\tset_page_stable_node(page, NULL);\n\t\tremove_node_from_stable_tree(stable_node);\n\t\terr = 0;\n\t}\n\n\tunlock_page(page);\n\tput_page(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!is_stable_node_dup(dup)"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_stable_node_dup",
          "args": [
            "dup"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "is_stable_node_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "343-346",
          "snippet": "static __always_inline bool is_stable_node_dup(struct stable_node *dup)\n{\n\treturn dup->head == STABLE_NODE_DUP_HEAD;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)"
          ],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic __always_inline bool is_stable_node_dup(struct stable_node *dup)\n{\n\treturn dup->head == STABLE_NODE_DUP_HEAD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "dup",
            "hlist_safe",
            "&stable_node->hlist",
            "hlist_dup"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "is_stable_node_dup(stable_node)"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_stable_node_chain",
          "args": [
            "stable_node"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "is_stable_node_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "338-341",
          "snippet": "static __always_inline bool is_stable_node_chain(struct stable_node *chain)\n{\n\treturn chain->rmap_hlist_len == STABLE_NODE_CHAIN;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_NODE_CHAIN -1024"
          ],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_CHAIN -1024\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic __always_inline bool is_stable_node_chain(struct stable_node *chain)\n{\n\treturn chain->rmap_hlist_len == STABLE_NODE_CHAIN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int remove_stable_node_chain(struct stable_node *stable_node,\n\t\t\t\t    struct rb_root *root)\n{\n\tstruct stable_node *dup;\n\tstruct hlist_node *hlist_safe;\n\n\tif (!is_stable_node_chain(stable_node)) {\n\t\tVM_BUG_ON(is_stable_node_dup(stable_node));\n\t\tif (remove_stable_node(stable_node))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\thlist_for_each_entry_safe(dup, hlist_safe,\n\t\t\t\t  &stable_node->hlist, hlist_dup) {\n\t\tVM_BUG_ON(!is_stable_node_dup(dup));\n\t\tif (remove_stable_node(dup))\n\t\t\treturn true;\n\t}\n\tBUG_ON(!hlist_empty(&stable_node->hlist));\n\tfree_stable_node_chain(stable_node, root);\n\treturn false;\n}"
  },
  {
    "function_name": "remove_stable_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "860-896",
    "snippet": "static int remove_stable_node(struct stable_node *stable_node)\n{\n\tstruct page *page;\n\tint err;\n\n\tpage = get_ksm_page(stable_node, true);\n\tif (!page) {\n\t\t/*\n\t\t * get_ksm_page did remove_node_from_stable_tree itself.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tif (WARN_ON_ONCE(page_mapped(page))) {\n\t\t/*\n\t\t * This should not happen: but if it does, just refuse to let\n\t\t * merge_across_nodes be switched - there is no need to panic.\n\t\t */\n\t\terr = -EBUSY;\n\t} else {\n\t\t/*\n\t\t * The stable node did not yet appear stale to get_ksm_page(),\n\t\t * since that allows for an unmapped ksm page to be recognized\n\t\t * right up until it is freed; but the node is safe to remove.\n\t\t * This page might be in a pagevec waiting to be freed,\n\t\t * or it might be PageSwapCache (perhaps under writeback),\n\t\t * or it might have been removed from swapcache a moment ago.\n\t\t */\n\t\tset_page_stable_node(page, NULL);\n\t\tremove_node_from_stable_tree(stable_node);\n\t\terr = 0;\n\t}\n\n\tunlock_page(page);\n\tput_page(page);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_node_from_stable_tree",
          "args": [
            "stable_node"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "remove_node_from_stable_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "631-667",
          "snippet": "static void remove_node_from_stable_tree(struct stable_node *stable_node)\n{\n\tstruct rmap_item *rmap_item;\n\n\t/* check it's not STABLE_NODE_CHAIN or negative */\n\tBUG_ON(stable_node->rmap_hlist_len < 0);\n\n\thlist_for_each_entry(rmap_item, &stable_node->hlist, hlist) {\n\t\tif (rmap_item->hlist.next)\n\t\t\tksm_pages_sharing--;\n\t\telse\n\t\t\tksm_pages_shared--;\n\t\tVM_BUG_ON(stable_node->rmap_hlist_len <= 0);\n\t\tstable_node->rmap_hlist_len--;\n\t\tput_anon_vma(rmap_item->anon_vma);\n\t\trmap_item->address &= PAGE_MASK;\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * We need the second aligned pointer of the migrate_nodes\n\t * list_head to stay clear from the rb_parent_color union\n\t * (aligned and different than any node) and also different\n\t * from &migrate_nodes. This will verify that future list.h changes\n\t * don't break STABLE_NODE_DUP_HEAD. Only recent gcc can handle it.\n\t */\n#if defined(GCC_VERSION) && GCC_VERSION >= 40903\n\tBUILD_BUG_ON(STABLE_NODE_DUP_HEAD <= &migrate_nodes);\n\tBUILD_BUG_ON(STABLE_NODE_DUP_HEAD >= &migrate_nodes + 1);\n#endif\n\n\tif (stable_node->head == &migrate_nodes)\n\t\tlist_del(&stable_node->list);\n\telse\n\t\tstable_node_dup_del(stable_node);\n\tfree_stable_node(stable_node);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)",
            "#define STABLE_NODE_CHAIN -1024"
          ],
          "globals_used": [
            "static LIST_HEAD(migrate_nodes);",
            "static unsigned long ksm_pages_shared;",
            "static unsigned long ksm_pages_sharing;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)\n#define STABLE_NODE_CHAIN -1024\n\nstatic LIST_HEAD(migrate_nodes);\nstatic unsigned long ksm_pages_shared;\nstatic unsigned long ksm_pages_sharing;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic void remove_node_from_stable_tree(struct stable_node *stable_node)\n{\n\tstruct rmap_item *rmap_item;\n\n\t/* check it's not STABLE_NODE_CHAIN or negative */\n\tBUG_ON(stable_node->rmap_hlist_len < 0);\n\n\thlist_for_each_entry(rmap_item, &stable_node->hlist, hlist) {\n\t\tif (rmap_item->hlist.next)\n\t\t\tksm_pages_sharing--;\n\t\telse\n\t\t\tksm_pages_shared--;\n\t\tVM_BUG_ON(stable_node->rmap_hlist_len <= 0);\n\t\tstable_node->rmap_hlist_len--;\n\t\tput_anon_vma(rmap_item->anon_vma);\n\t\trmap_item->address &= PAGE_MASK;\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * We need the second aligned pointer of the migrate_nodes\n\t * list_head to stay clear from the rb_parent_color union\n\t * (aligned and different than any node) and also different\n\t * from &migrate_nodes. This will verify that future list.h changes\n\t * don't break STABLE_NODE_DUP_HEAD. Only recent gcc can handle it.\n\t */\n#if defined(GCC_VERSION) && GCC_VERSION >= 40903\n\tBUILD_BUG_ON(STABLE_NODE_DUP_HEAD <= &migrate_nodes);\n\tBUILD_BUG_ON(STABLE_NODE_DUP_HEAD >= &migrate_nodes + 1);\n#endif\n\n\tif (stable_node->head == &migrate_nodes)\n\t\tlist_del(&stable_node->list);\n\telse\n\t\tstable_node_dup_del(stable_node);\n\tfree_stable_node(stable_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_stable_node",
          "args": [
            "page",
            "NULL"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_stable_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "850-854",
          "snippet": "static inline void set_page_stable_node(struct page *page,\n\t\t\t\t\tstruct stable_node *stable_node)\n{\n\tpage->mapping = (void *)((unsigned long)stable_node | PAGE_MAPPING_KSM);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void set_page_stable_node(struct page *page,\n\t\t\t\t\tstruct stable_node *stable_node)\n{\n\tpage->mapping = (void *)((unsigned long)stable_node | PAGE_MAPPING_KSM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "page_mapped(page)"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "page"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "470-486",
          "snippet": "bool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nbool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_ksm_page",
          "args": [
            "stable_node",
            "true"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "get_ksm_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "688-752",
          "snippet": "static struct page *get_ksm_page(struct stable_node *stable_node, bool lock_it)\n{\n\tstruct page *page;\n\tvoid *expected_mapping;\n\tunsigned long kpfn;\n\n\texpected_mapping = (void *)((unsigned long)stable_node |\n\t\t\t\t\tPAGE_MAPPING_KSM);\nagain:\n\tkpfn = READ_ONCE(stable_node->kpfn); /* Address dependency. */\n\tpage = pfn_to_page(kpfn);\n\tif (READ_ONCE(page->mapping) != expected_mapping)\n\t\tgoto stale;\n\n\t/*\n\t * We cannot do anything with the page while its refcount is 0.\n\t * Usually 0 means free, or tail of a higher-order page: in which\n\t * case this node is no longer referenced, and should be freed;\n\t * however, it might mean that the page is under page_ref_freeze().\n\t * The __remove_mapping() case is easy, again the node is now stale;\n\t * but if page is swapcache in migrate_page_move_mapping(), it might\n\t * still be our page, in which case it's essential to keep the node.\n\t */\n\twhile (!get_page_unless_zero(page)) {\n\t\t/*\n\t\t * Another check for page->mapping != expected_mapping would\n\t\t * work here too.  We have chosen the !PageSwapCache test to\n\t\t * optimize the common case, when the page is or is about to\n\t\t * be freed: PageSwapCache is cleared (under spin_lock_irq)\n\t\t * in the ref_freeze section of __remove_mapping(); but Anon\n\t\t * page->mapping reset to NULL later, in free_pages_prepare().\n\t\t */\n\t\tif (!PageSwapCache(page))\n\t\t\tgoto stale;\n\t\tcpu_relax();\n\t}\n\n\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\tput_page(page);\n\t\tgoto stale;\n\t}\n\n\tif (lock_it) {\n\t\tlock_page(page);\n\t\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto stale;\n\t\t}\n\t}\n\treturn page;\n\nstale:\n\t/*\n\t * We come here from above when page->mapping or !PageSwapCache\n\t * suggests that the node is stale; but it might be under migration.\n\t * We need smp_rmb(), matching the smp_wmb() in ksm_migrate_page(),\n\t * before checking whether node->kpfn has been changed.\n\t */\n\tsmp_rmb();\n\tif (READ_ONCE(stable_node->kpfn) != kpfn)\n\t\tgoto again;\n\tremove_node_from_stable_tree(stable_node);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct page *get_ksm_page(struct stable_node *stable_node, bool lock_it)\n{\n\tstruct page *page;\n\tvoid *expected_mapping;\n\tunsigned long kpfn;\n\n\texpected_mapping = (void *)((unsigned long)stable_node |\n\t\t\t\t\tPAGE_MAPPING_KSM);\nagain:\n\tkpfn = READ_ONCE(stable_node->kpfn); /* Address dependency. */\n\tpage = pfn_to_page(kpfn);\n\tif (READ_ONCE(page->mapping) != expected_mapping)\n\t\tgoto stale;\n\n\t/*\n\t * We cannot do anything with the page while its refcount is 0.\n\t * Usually 0 means free, or tail of a higher-order page: in which\n\t * case this node is no longer referenced, and should be freed;\n\t * however, it might mean that the page is under page_ref_freeze().\n\t * The __remove_mapping() case is easy, again the node is now stale;\n\t * but if page is swapcache in migrate_page_move_mapping(), it might\n\t * still be our page, in which case it's essential to keep the node.\n\t */\n\twhile (!get_page_unless_zero(page)) {\n\t\t/*\n\t\t * Another check for page->mapping != expected_mapping would\n\t\t * work here too.  We have chosen the !PageSwapCache test to\n\t\t * optimize the common case, when the page is or is about to\n\t\t * be freed: PageSwapCache is cleared (under spin_lock_irq)\n\t\t * in the ref_freeze section of __remove_mapping(); but Anon\n\t\t * page->mapping reset to NULL later, in free_pages_prepare().\n\t\t */\n\t\tif (!PageSwapCache(page))\n\t\t\tgoto stale;\n\t\tcpu_relax();\n\t}\n\n\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\tput_page(page);\n\t\tgoto stale;\n\t}\n\n\tif (lock_it) {\n\t\tlock_page(page);\n\t\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto stale;\n\t\t}\n\t}\n\treturn page;\n\nstale:\n\t/*\n\t * We come here from above when page->mapping or !PageSwapCache\n\t * suggests that the node is stale; but it might be under migration.\n\t * We need smp_rmb(), matching the smp_wmb() in ksm_migrate_page(),\n\t * before checking whether node->kpfn has been changed.\n\t */\n\tsmp_rmb();\n\tif (READ_ONCE(stable_node->kpfn) != kpfn)\n\t\tgoto again;\n\tremove_node_from_stable_tree(stable_node);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int remove_stable_node(struct stable_node *stable_node)\n{\n\tstruct page *page;\n\tint err;\n\n\tpage = get_ksm_page(stable_node, true);\n\tif (!page) {\n\t\t/*\n\t\t * get_ksm_page did remove_node_from_stable_tree itself.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tif (WARN_ON_ONCE(page_mapped(page))) {\n\t\t/*\n\t\t * This should not happen: but if it does, just refuse to let\n\t\t * merge_across_nodes be switched - there is no need to panic.\n\t\t */\n\t\terr = -EBUSY;\n\t} else {\n\t\t/*\n\t\t * The stable node did not yet appear stale to get_ksm_page(),\n\t\t * since that allows for an unmapped ksm page to be recognized\n\t\t * right up until it is freed; but the node is safe to remove.\n\t\t * This page might be in a pagevec waiting to be freed,\n\t\t * or it might be PageSwapCache (perhaps under writeback),\n\t\t * or it might have been removed from swapcache a moment ago.\n\t\t */\n\t\tset_page_stable_node(page, NULL);\n\t\tremove_node_from_stable_tree(stable_node);\n\t\terr = 0;\n\t}\n\n\tunlock_page(page);\n\tput_page(page);\n\treturn err;\n}"
  },
  {
    "function_name": "set_page_stable_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "850-854",
    "snippet": "static inline void set_page_stable_node(struct page *page,\n\t\t\t\t\tstruct stable_node *stable_node)\n{\n\tpage->mapping = (void *)((unsigned long)stable_node | PAGE_MAPPING_KSM);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void set_page_stable_node(struct page *page,\n\t\t\t\t\tstruct stable_node *stable_node)\n{\n\tpage->mapping = (void *)((unsigned long)stable_node | PAGE_MAPPING_KSM);\n}"
  },
  {
    "function_name": "page_stable_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "845-848",
    "snippet": "static inline struct stable_node *page_stable_node(struct page *page)\n{\n\treturn PageKsm(page) ? page_rmapping(page) : NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_rmapping",
          "args": [
            "page"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "page_rmapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "460-464",
          "snippet": "void *page_rmapping(struct page *page)\n{\n\tpage = compound_head(page);\n\treturn __page_rmapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid *page_rmapping(struct page *page)\n{\n\tpage = compound_head(page);\n\treturn __page_rmapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageKsm",
          "args": [
            "page"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline struct stable_node *page_stable_node(struct page *page)\n{\n\treturn PageKsm(page) ? page_rmapping(page) : NULL;\n}"
  },
  {
    "function_name": "unmerge_ksm_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "828-843",
    "snippet": "static int unmerge_ksm_pages(struct vm_area_struct *vma,\n\t\t\t     unsigned long start, unsigned long end)\n{\n\tunsigned long addr;\n\tint err = 0;\n\n\tfor (addr = start; addr < end && !err; addr += PAGE_SIZE) {\n\t\tif (ksm_test_exit(vma->vm_mm))\n\t\t\tbreak;\n\t\tif (signal_pending(current))\n\t\t\terr = -ERESTARTSYS;\n\t\telse\n\t\t\terr = break_ksm(vma, addr);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "break_ksm",
          "args": [
            "vma",
            "addr"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "break_ksm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "470-517",
          "snippet": "static int break_ksm(struct vm_area_struct *vma, unsigned long addr)\n{\n\tstruct page *page;\n\tvm_fault_t ret = 0;\n\n\tdo {\n\t\tcond_resched();\n\t\tpage = follow_page(vma, addr,\n\t\t\t\tFOLL_GET | FOLL_MIGRATION | FOLL_REMOTE);\n\t\tif (IS_ERR_OR_NULL(page))\n\t\t\tbreak;\n\t\tif (PageKsm(page))\n\t\t\tret = handle_mm_fault(vma, addr,\n\t\t\t\t\tFAULT_FLAG_WRITE | FAULT_FLAG_REMOTE);\n\t\telse\n\t\t\tret = VM_FAULT_WRITE;\n\t\tput_page(page);\n\t} while (!(ret & (VM_FAULT_WRITE | VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV | VM_FAULT_OOM)));\n\t/*\n\t * We must loop because handle_mm_fault() may back out if there's\n\t * any difficulty e.g. if pte accessed bit gets updated concurrently.\n\t *\n\t * VM_FAULT_WRITE is what we have been hoping for: it indicates that\n\t * COW has been broken, even if the vma does not permit VM_WRITE;\n\t * but note that a concurrent fault might break PageKsm for us.\n\t *\n\t * VM_FAULT_SIGBUS could occur if we race with truncation of the\n\t * backing file, which also invalidates anonymous pages: that's\n\t * okay, that truncation will have unmapped the PageKsm for us.\n\t *\n\t * VM_FAULT_OOM: at the time of writing (late July 2009), setting\n\t * aside mem_cgroup limits, VM_FAULT_OOM would only be set if the\n\t * current task has TIF_MEMDIE set, and will be OOM killed on return\n\t * to user; and ksmd, having no mm, would never be chosen for that.\n\t *\n\t * But if the mm is in a limited mem_cgroup, then the fault may fail\n\t * with VM_FAULT_OOM even if the current task is not TIF_MEMDIE; and\n\t * even ksmd can fail in this way - though it's usually breaking ksm\n\t * just to undo a merge it made a moment before, so unlikely to oom.\n\t *\n\t * That's a pity: we might therefore have more kernel pages allocated\n\t * than we're counting as nodes in the stable tree; but ksm_do_scan\n\t * will retry to break_cow on each pass, so should recover the page\n\t * in due course.  The important thing is to not let VM_MERGEABLE\n\t * be cleared while any such pages might remain in the area.\n\t */\n\treturn (ret & VM_FAULT_OOM) ? -ENOMEM : 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int break_ksm(struct vm_area_struct *vma, unsigned long addr)\n{\n\tstruct page *page;\n\tvm_fault_t ret = 0;\n\n\tdo {\n\t\tcond_resched();\n\t\tpage = follow_page(vma, addr,\n\t\t\t\tFOLL_GET | FOLL_MIGRATION | FOLL_REMOTE);\n\t\tif (IS_ERR_OR_NULL(page))\n\t\t\tbreak;\n\t\tif (PageKsm(page))\n\t\t\tret = handle_mm_fault(vma, addr,\n\t\t\t\t\tFAULT_FLAG_WRITE | FAULT_FLAG_REMOTE);\n\t\telse\n\t\t\tret = VM_FAULT_WRITE;\n\t\tput_page(page);\n\t} while (!(ret & (VM_FAULT_WRITE | VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV | VM_FAULT_OOM)));\n\t/*\n\t * We must loop because handle_mm_fault() may back out if there's\n\t * any difficulty e.g. if pte accessed bit gets updated concurrently.\n\t *\n\t * VM_FAULT_WRITE is what we have been hoping for: it indicates that\n\t * COW has been broken, even if the vma does not permit VM_WRITE;\n\t * but note that a concurrent fault might break PageKsm for us.\n\t *\n\t * VM_FAULT_SIGBUS could occur if we race with truncation of the\n\t * backing file, which also invalidates anonymous pages: that's\n\t * okay, that truncation will have unmapped the PageKsm for us.\n\t *\n\t * VM_FAULT_OOM: at the time of writing (late July 2009), setting\n\t * aside mem_cgroup limits, VM_FAULT_OOM would only be set if the\n\t * current task has TIF_MEMDIE set, and will be OOM killed on return\n\t * to user; and ksmd, having no mm, would never be chosen for that.\n\t *\n\t * But if the mm is in a limited mem_cgroup, then the fault may fail\n\t * with VM_FAULT_OOM even if the current task is not TIF_MEMDIE; and\n\t * even ksmd can fail in this way - though it's usually breaking ksm\n\t * just to undo a merge it made a moment before, so unlikely to oom.\n\t *\n\t * That's a pity: we might therefore have more kernel pages allocated\n\t * than we're counting as nodes in the stable tree; but ksm_do_scan\n\t * will retry to break_cow on each pass, so should recover the page\n\t * in due course.  The important thing is to not let VM_MERGEABLE\n\t * be cleared while any such pages might remain in the area.\n\t */\n\treturn (ret & VM_FAULT_OOM) ? -ENOMEM : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ksm_test_exit",
          "args": [
            "vma->vm_mm"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "ksm_test_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "450-453",
          "snippet": "static inline bool ksm_test_exit(struct mm_struct *mm)\n{\n\treturn atomic_read(&mm->mm_users) == 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline bool ksm_test_exit(struct mm_struct *mm)\n{\n\treturn atomic_read(&mm->mm_users) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int unmerge_ksm_pages(struct vm_area_struct *vma,\n\t\t\t     unsigned long start, unsigned long end)\n{\n\tunsigned long addr;\n\tint err = 0;\n\n\tfor (addr = start; addr < end && !err; addr += PAGE_SIZE) {\n\t\tif (ksm_test_exit(vma->vm_mm))\n\t\t\tbreak;\n\t\tif (signal_pending(current))\n\t\t\terr = -ERESTARTSYS;\n\t\telse\n\t\t\terr = break_ksm(vma, addr);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "remove_trailing_rmap_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "804-813",
    "snippet": "static void remove_trailing_rmap_items(struct mm_slot *mm_slot,\n\t\t\t\t       struct rmap_item **rmap_list)\n{\n\twhile (*rmap_list) {\n\t\tstruct rmap_item *rmap_item = *rmap_list;\n\t\t*rmap_list = rmap_item->rmap_list;\n\t\tremove_rmap_item_from_tree(rmap_item);\n\t\tfree_rmap_item(rmap_item);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_rmap_item",
          "args": [
            "rmap_item"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "free_rmap_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "388-393",
          "snippet": "static inline void free_rmap_item(struct rmap_item *rmap_item)\n{\n\tksm_rmap_items--;\n\trmap_item->mm = NULL;\t/* debug safety */\n\tkmem_cache_free(rmap_item_cache, rmap_item);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *rmap_item_cache;",
            "static unsigned long ksm_rmap_items;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct kmem_cache *rmap_item_cache;\nstatic unsigned long ksm_rmap_items;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void free_rmap_item(struct rmap_item *rmap_item)\n{\n\tksm_rmap_items--;\n\trmap_item->mm = NULL;\t/* debug safety */\n\tkmem_cache_free(rmap_item_cache, rmap_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_rmap_item_from_tree",
          "args": [
            "rmap_item"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "remove_rmap_item_from_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "758-802",
          "snippet": "static void remove_rmap_item_from_tree(struct rmap_item *rmap_item)\n{\n\tif (rmap_item->address & STABLE_FLAG) {\n\t\tstruct stable_node *stable_node;\n\t\tstruct page *page;\n\n\t\tstable_node = rmap_item->head;\n\t\tpage = get_ksm_page(stable_node, true);\n\t\tif (!page)\n\t\t\tgoto out;\n\n\t\thlist_del(&rmap_item->hlist);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (!hlist_empty(&stable_node->hlist))\n\t\t\tksm_pages_sharing--;\n\t\telse\n\t\t\tksm_pages_shared--;\n\t\tVM_BUG_ON(stable_node->rmap_hlist_len <= 0);\n\t\tstable_node->rmap_hlist_len--;\n\n\t\tput_anon_vma(rmap_item->anon_vma);\n\t\trmap_item->address &= PAGE_MASK;\n\n\t} else if (rmap_item->address & UNSTABLE_FLAG) {\n\t\tunsigned char age;\n\t\t/*\n\t\t * Usually ksmd can and must skip the rb_erase, because\n\t\t * root_unstable_tree was already reset to RB_ROOT.\n\t\t * But be careful when an mm is exiting: do the rb_erase\n\t\t * if this rmap_item was inserted by this scan, rather\n\t\t * than left over from before.\n\t\t */\n\t\tage = (unsigned char)(ksm_scan.seqnr - rmap_item->address);\n\t\tBUG_ON(age > 1);\n\t\tif (!age)\n\t\t\trb_erase(&rmap_item->node,\n\t\t\t\t root_unstable_tree + NUMA(rmap_item->nid));\n\t\tksm_pages_unshared--;\n\t\trmap_item->address &= PAGE_MASK;\n\t}\nout:\n\tcond_resched();\t\t/* we're called from many long loops */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_FLAG\t0x200\t/* is listed from the stable tree */",
            "#define UNSTABLE_FLAG\t0x100\t/* is a node of the unstable tree */"
          ],
          "globals_used": [
            "static struct rb_root *root_unstable_tree = one_unstable_tree;",
            "static struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};",
            "static unsigned long ksm_pages_shared;",
            "static unsigned long ksm_pages_sharing;",
            "static unsigned long ksm_pages_unshared;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_FLAG\t0x200\t/* is listed from the stable tree */\n#define UNSTABLE_FLAG\t0x100\t/* is a node of the unstable tree */\n\nstatic struct rb_root *root_unstable_tree = one_unstable_tree;\nstatic struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};\nstatic unsigned long ksm_pages_shared;\nstatic unsigned long ksm_pages_sharing;\nstatic unsigned long ksm_pages_unshared;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic void remove_rmap_item_from_tree(struct rmap_item *rmap_item)\n{\n\tif (rmap_item->address & STABLE_FLAG) {\n\t\tstruct stable_node *stable_node;\n\t\tstruct page *page;\n\n\t\tstable_node = rmap_item->head;\n\t\tpage = get_ksm_page(stable_node, true);\n\t\tif (!page)\n\t\t\tgoto out;\n\n\t\thlist_del(&rmap_item->hlist);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (!hlist_empty(&stable_node->hlist))\n\t\t\tksm_pages_sharing--;\n\t\telse\n\t\t\tksm_pages_shared--;\n\t\tVM_BUG_ON(stable_node->rmap_hlist_len <= 0);\n\t\tstable_node->rmap_hlist_len--;\n\n\t\tput_anon_vma(rmap_item->anon_vma);\n\t\trmap_item->address &= PAGE_MASK;\n\n\t} else if (rmap_item->address & UNSTABLE_FLAG) {\n\t\tunsigned char age;\n\t\t/*\n\t\t * Usually ksmd can and must skip the rb_erase, because\n\t\t * root_unstable_tree was already reset to RB_ROOT.\n\t\t * But be careful when an mm is exiting: do the rb_erase\n\t\t * if this rmap_item was inserted by this scan, rather\n\t\t * than left over from before.\n\t\t */\n\t\tage = (unsigned char)(ksm_scan.seqnr - rmap_item->address);\n\t\tBUG_ON(age > 1);\n\t\tif (!age)\n\t\t\trb_erase(&rmap_item->node,\n\t\t\t\t root_unstable_tree + NUMA(rmap_item->nid));\n\t\tksm_pages_unshared--;\n\t\trmap_item->address &= PAGE_MASK;\n\t}\nout:\n\tcond_resched();\t\t/* we're called from many long loops */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic void remove_trailing_rmap_items(struct mm_slot *mm_slot,\n\t\t\t\t       struct rmap_item **rmap_list)\n{\n\twhile (*rmap_list) {\n\t\tstruct rmap_item *rmap_item = *rmap_list;\n\t\t*rmap_list = rmap_item->rmap_list;\n\t\tremove_rmap_item_from_tree(rmap_item);\n\t\tfree_rmap_item(rmap_item);\n\t}\n}"
  },
  {
    "function_name": "remove_rmap_item_from_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "758-802",
    "snippet": "static void remove_rmap_item_from_tree(struct rmap_item *rmap_item)\n{\n\tif (rmap_item->address & STABLE_FLAG) {\n\t\tstruct stable_node *stable_node;\n\t\tstruct page *page;\n\n\t\tstable_node = rmap_item->head;\n\t\tpage = get_ksm_page(stable_node, true);\n\t\tif (!page)\n\t\t\tgoto out;\n\n\t\thlist_del(&rmap_item->hlist);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (!hlist_empty(&stable_node->hlist))\n\t\t\tksm_pages_sharing--;\n\t\telse\n\t\t\tksm_pages_shared--;\n\t\tVM_BUG_ON(stable_node->rmap_hlist_len <= 0);\n\t\tstable_node->rmap_hlist_len--;\n\n\t\tput_anon_vma(rmap_item->anon_vma);\n\t\trmap_item->address &= PAGE_MASK;\n\n\t} else if (rmap_item->address & UNSTABLE_FLAG) {\n\t\tunsigned char age;\n\t\t/*\n\t\t * Usually ksmd can and must skip the rb_erase, because\n\t\t * root_unstable_tree was already reset to RB_ROOT.\n\t\t * But be careful when an mm is exiting: do the rb_erase\n\t\t * if this rmap_item was inserted by this scan, rather\n\t\t * than left over from before.\n\t\t */\n\t\tage = (unsigned char)(ksm_scan.seqnr - rmap_item->address);\n\t\tBUG_ON(age > 1);\n\t\tif (!age)\n\t\t\trb_erase(&rmap_item->node,\n\t\t\t\t root_unstable_tree + NUMA(rmap_item->nid));\n\t\tksm_pages_unshared--;\n\t\trmap_item->address &= PAGE_MASK;\n\t}\nout:\n\tcond_resched();\t\t/* we're called from many long loops */\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define STABLE_FLAG\t0x200\t/* is listed from the stable tree */",
      "#define UNSTABLE_FLAG\t0x100\t/* is a node of the unstable tree */"
    ],
    "globals_used": [
      "static struct rb_root *root_unstable_tree = one_unstable_tree;",
      "static struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};",
      "static unsigned long ksm_pages_shared;",
      "static unsigned long ksm_pages_sharing;",
      "static unsigned long ksm_pages_unshared;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&rmap_item->node",
            "root_unstable_tree + NUMA(rmap_item->nid)"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "vma_rb_erase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "479-489",
          "snippet": "static __always_inline void vma_rb_erase(struct vm_area_struct *vma,\n\t\t\t\t\t struct rb_root *root)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the vma being erased.\n\t */\n\tvalidate_mm_rb(root, vma);\n\n\t__vma_rb_erase(vma, root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic __always_inline void vma_rb_erase(struct vm_area_struct *vma,\n\t\t\t\t\t struct rb_root *root)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the vma being erased.\n\t */\n\tvalidate_mm_rb(root, vma);\n\n\t__vma_rb_erase(vma, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NUMA",
          "args": [
            "rmap_item->nid"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "age > 1"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_anon_vma",
          "args": [
            "rmap_item->anon_vma"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "__put_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1758-1765",
          "snippet": "void __put_anon_vma(struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *root = anon_vma->root;\n\n\tanon_vma_free(anon_vma);\n\tif (root != anon_vma && atomic_dec_and_test(&root->refcount))\n\t\tanon_vma_free(root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid __put_anon_vma(struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *root = anon_vma->root;\n\n\tanon_vma_free(anon_vma);\n\tif (root != anon_vma && atomic_dec_and_test(&root->refcount))\n\t\tanon_vma_free(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "stable_node->rmap_hlist_len <= 0"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&stable_node->hlist"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "&rmap_item->hlist"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ksm_page",
          "args": [
            "stable_node",
            "true"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "get_ksm_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "688-752",
          "snippet": "static struct page *get_ksm_page(struct stable_node *stable_node, bool lock_it)\n{\n\tstruct page *page;\n\tvoid *expected_mapping;\n\tunsigned long kpfn;\n\n\texpected_mapping = (void *)((unsigned long)stable_node |\n\t\t\t\t\tPAGE_MAPPING_KSM);\nagain:\n\tkpfn = READ_ONCE(stable_node->kpfn); /* Address dependency. */\n\tpage = pfn_to_page(kpfn);\n\tif (READ_ONCE(page->mapping) != expected_mapping)\n\t\tgoto stale;\n\n\t/*\n\t * We cannot do anything with the page while its refcount is 0.\n\t * Usually 0 means free, or tail of a higher-order page: in which\n\t * case this node is no longer referenced, and should be freed;\n\t * however, it might mean that the page is under page_ref_freeze().\n\t * The __remove_mapping() case is easy, again the node is now stale;\n\t * but if page is swapcache in migrate_page_move_mapping(), it might\n\t * still be our page, in which case it's essential to keep the node.\n\t */\n\twhile (!get_page_unless_zero(page)) {\n\t\t/*\n\t\t * Another check for page->mapping != expected_mapping would\n\t\t * work here too.  We have chosen the !PageSwapCache test to\n\t\t * optimize the common case, when the page is or is about to\n\t\t * be freed: PageSwapCache is cleared (under spin_lock_irq)\n\t\t * in the ref_freeze section of __remove_mapping(); but Anon\n\t\t * page->mapping reset to NULL later, in free_pages_prepare().\n\t\t */\n\t\tif (!PageSwapCache(page))\n\t\t\tgoto stale;\n\t\tcpu_relax();\n\t}\n\n\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\tput_page(page);\n\t\tgoto stale;\n\t}\n\n\tif (lock_it) {\n\t\tlock_page(page);\n\t\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto stale;\n\t\t}\n\t}\n\treturn page;\n\nstale:\n\t/*\n\t * We come here from above when page->mapping or !PageSwapCache\n\t * suggests that the node is stale; but it might be under migration.\n\t * We need smp_rmb(), matching the smp_wmb() in ksm_migrate_page(),\n\t * before checking whether node->kpfn has been changed.\n\t */\n\tsmp_rmb();\n\tif (READ_ONCE(stable_node->kpfn) != kpfn)\n\t\tgoto again;\n\tremove_node_from_stable_tree(stable_node);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct page *get_ksm_page(struct stable_node *stable_node, bool lock_it)\n{\n\tstruct page *page;\n\tvoid *expected_mapping;\n\tunsigned long kpfn;\n\n\texpected_mapping = (void *)((unsigned long)stable_node |\n\t\t\t\t\tPAGE_MAPPING_KSM);\nagain:\n\tkpfn = READ_ONCE(stable_node->kpfn); /* Address dependency. */\n\tpage = pfn_to_page(kpfn);\n\tif (READ_ONCE(page->mapping) != expected_mapping)\n\t\tgoto stale;\n\n\t/*\n\t * We cannot do anything with the page while its refcount is 0.\n\t * Usually 0 means free, or tail of a higher-order page: in which\n\t * case this node is no longer referenced, and should be freed;\n\t * however, it might mean that the page is under page_ref_freeze().\n\t * The __remove_mapping() case is easy, again the node is now stale;\n\t * but if page is swapcache in migrate_page_move_mapping(), it might\n\t * still be our page, in which case it's essential to keep the node.\n\t */\n\twhile (!get_page_unless_zero(page)) {\n\t\t/*\n\t\t * Another check for page->mapping != expected_mapping would\n\t\t * work here too.  We have chosen the !PageSwapCache test to\n\t\t * optimize the common case, when the page is or is about to\n\t\t * be freed: PageSwapCache is cleared (under spin_lock_irq)\n\t\t * in the ref_freeze section of __remove_mapping(); but Anon\n\t\t * page->mapping reset to NULL later, in free_pages_prepare().\n\t\t */\n\t\tif (!PageSwapCache(page))\n\t\t\tgoto stale;\n\t\tcpu_relax();\n\t}\n\n\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\tput_page(page);\n\t\tgoto stale;\n\t}\n\n\tif (lock_it) {\n\t\tlock_page(page);\n\t\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto stale;\n\t\t}\n\t}\n\treturn page;\n\nstale:\n\t/*\n\t * We come here from above when page->mapping or !PageSwapCache\n\t * suggests that the node is stale; but it might be under migration.\n\t * We need smp_rmb(), matching the smp_wmb() in ksm_migrate_page(),\n\t * before checking whether node->kpfn has been changed.\n\t */\n\tsmp_rmb();\n\tif (READ_ONCE(stable_node->kpfn) != kpfn)\n\t\tgoto again;\n\tremove_node_from_stable_tree(stable_node);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_FLAG\t0x200\t/* is listed from the stable tree */\n#define UNSTABLE_FLAG\t0x100\t/* is a node of the unstable tree */\n\nstatic struct rb_root *root_unstable_tree = one_unstable_tree;\nstatic struct ksm_scan ksm_scan = {\n\t.mm_slot = &ksm_mm_head,\n};\nstatic unsigned long ksm_pages_shared;\nstatic unsigned long ksm_pages_sharing;\nstatic unsigned long ksm_pages_unshared;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic void remove_rmap_item_from_tree(struct rmap_item *rmap_item)\n{\n\tif (rmap_item->address & STABLE_FLAG) {\n\t\tstruct stable_node *stable_node;\n\t\tstruct page *page;\n\n\t\tstable_node = rmap_item->head;\n\t\tpage = get_ksm_page(stable_node, true);\n\t\tif (!page)\n\t\t\tgoto out;\n\n\t\thlist_del(&rmap_item->hlist);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\n\t\tif (!hlist_empty(&stable_node->hlist))\n\t\t\tksm_pages_sharing--;\n\t\telse\n\t\t\tksm_pages_shared--;\n\t\tVM_BUG_ON(stable_node->rmap_hlist_len <= 0);\n\t\tstable_node->rmap_hlist_len--;\n\n\t\tput_anon_vma(rmap_item->anon_vma);\n\t\trmap_item->address &= PAGE_MASK;\n\n\t} else if (rmap_item->address & UNSTABLE_FLAG) {\n\t\tunsigned char age;\n\t\t/*\n\t\t * Usually ksmd can and must skip the rb_erase, because\n\t\t * root_unstable_tree was already reset to RB_ROOT.\n\t\t * But be careful when an mm is exiting: do the rb_erase\n\t\t * if this rmap_item was inserted by this scan, rather\n\t\t * than left over from before.\n\t\t */\n\t\tage = (unsigned char)(ksm_scan.seqnr - rmap_item->address);\n\t\tBUG_ON(age > 1);\n\t\tif (!age)\n\t\t\trb_erase(&rmap_item->node,\n\t\t\t\t root_unstable_tree + NUMA(rmap_item->nid));\n\t\tksm_pages_unshared--;\n\t\trmap_item->address &= PAGE_MASK;\n\t}\nout:\n\tcond_resched();\t\t/* we're called from many long loops */\n}"
  },
  {
    "function_name": "get_ksm_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "688-752",
    "snippet": "static struct page *get_ksm_page(struct stable_node *stable_node, bool lock_it)\n{\n\tstruct page *page;\n\tvoid *expected_mapping;\n\tunsigned long kpfn;\n\n\texpected_mapping = (void *)((unsigned long)stable_node |\n\t\t\t\t\tPAGE_MAPPING_KSM);\nagain:\n\tkpfn = READ_ONCE(stable_node->kpfn); /* Address dependency. */\n\tpage = pfn_to_page(kpfn);\n\tif (READ_ONCE(page->mapping) != expected_mapping)\n\t\tgoto stale;\n\n\t/*\n\t * We cannot do anything with the page while its refcount is 0.\n\t * Usually 0 means free, or tail of a higher-order page: in which\n\t * case this node is no longer referenced, and should be freed;\n\t * however, it might mean that the page is under page_ref_freeze().\n\t * The __remove_mapping() case is easy, again the node is now stale;\n\t * but if page is swapcache in migrate_page_move_mapping(), it might\n\t * still be our page, in which case it's essential to keep the node.\n\t */\n\twhile (!get_page_unless_zero(page)) {\n\t\t/*\n\t\t * Another check for page->mapping != expected_mapping would\n\t\t * work here too.  We have chosen the !PageSwapCache test to\n\t\t * optimize the common case, when the page is or is about to\n\t\t * be freed: PageSwapCache is cleared (under spin_lock_irq)\n\t\t * in the ref_freeze section of __remove_mapping(); but Anon\n\t\t * page->mapping reset to NULL later, in free_pages_prepare().\n\t\t */\n\t\tif (!PageSwapCache(page))\n\t\t\tgoto stale;\n\t\tcpu_relax();\n\t}\n\n\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\tput_page(page);\n\t\tgoto stale;\n\t}\n\n\tif (lock_it) {\n\t\tlock_page(page);\n\t\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto stale;\n\t\t}\n\t}\n\treturn page;\n\nstale:\n\t/*\n\t * We come here from above when page->mapping or !PageSwapCache\n\t * suggests that the node is stale; but it might be under migration.\n\t * We need smp_rmb(), matching the smp_wmb() in ksm_migrate_page(),\n\t * before checking whether node->kpfn has been changed.\n\t */\n\tsmp_rmb();\n\tif (READ_ONCE(stable_node->kpfn) != kpfn)\n\t\tgoto again;\n\tremove_node_from_stable_tree(stable_node);\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_node_from_stable_tree",
          "args": [
            "stable_node"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "remove_node_from_stable_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "631-667",
          "snippet": "static void remove_node_from_stable_tree(struct stable_node *stable_node)\n{\n\tstruct rmap_item *rmap_item;\n\n\t/* check it's not STABLE_NODE_CHAIN or negative */\n\tBUG_ON(stable_node->rmap_hlist_len < 0);\n\n\thlist_for_each_entry(rmap_item, &stable_node->hlist, hlist) {\n\t\tif (rmap_item->hlist.next)\n\t\t\tksm_pages_sharing--;\n\t\telse\n\t\t\tksm_pages_shared--;\n\t\tVM_BUG_ON(stable_node->rmap_hlist_len <= 0);\n\t\tstable_node->rmap_hlist_len--;\n\t\tput_anon_vma(rmap_item->anon_vma);\n\t\trmap_item->address &= PAGE_MASK;\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * We need the second aligned pointer of the migrate_nodes\n\t * list_head to stay clear from the rb_parent_color union\n\t * (aligned and different than any node) and also different\n\t * from &migrate_nodes. This will verify that future list.h changes\n\t * don't break STABLE_NODE_DUP_HEAD. Only recent gcc can handle it.\n\t */\n#if defined(GCC_VERSION) && GCC_VERSION >= 40903\n\tBUILD_BUG_ON(STABLE_NODE_DUP_HEAD <= &migrate_nodes);\n\tBUILD_BUG_ON(STABLE_NODE_DUP_HEAD >= &migrate_nodes + 1);\n#endif\n\n\tif (stable_node->head == &migrate_nodes)\n\t\tlist_del(&stable_node->list);\n\telse\n\t\tstable_node_dup_del(stable_node);\n\tfree_stable_node(stable_node);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)",
            "#define STABLE_NODE_CHAIN -1024"
          ],
          "globals_used": [
            "static LIST_HEAD(migrate_nodes);",
            "static unsigned long ksm_pages_shared;",
            "static unsigned long ksm_pages_sharing;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)\n#define STABLE_NODE_CHAIN -1024\n\nstatic LIST_HEAD(migrate_nodes);\nstatic unsigned long ksm_pages_shared;\nstatic unsigned long ksm_pages_sharing;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic void remove_node_from_stable_tree(struct stable_node *stable_node)\n{\n\tstruct rmap_item *rmap_item;\n\n\t/* check it's not STABLE_NODE_CHAIN or negative */\n\tBUG_ON(stable_node->rmap_hlist_len < 0);\n\n\thlist_for_each_entry(rmap_item, &stable_node->hlist, hlist) {\n\t\tif (rmap_item->hlist.next)\n\t\t\tksm_pages_sharing--;\n\t\telse\n\t\t\tksm_pages_shared--;\n\t\tVM_BUG_ON(stable_node->rmap_hlist_len <= 0);\n\t\tstable_node->rmap_hlist_len--;\n\t\tput_anon_vma(rmap_item->anon_vma);\n\t\trmap_item->address &= PAGE_MASK;\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * We need the second aligned pointer of the migrate_nodes\n\t * list_head to stay clear from the rb_parent_color union\n\t * (aligned and different than any node) and also different\n\t * from &migrate_nodes. This will verify that future list.h changes\n\t * don't break STABLE_NODE_DUP_HEAD. Only recent gcc can handle it.\n\t */\n#if defined(GCC_VERSION) && GCC_VERSION >= 40903\n\tBUILD_BUG_ON(STABLE_NODE_DUP_HEAD <= &migrate_nodes);\n\tBUILD_BUG_ON(STABLE_NODE_DUP_HEAD >= &migrate_nodes + 1);\n#endif\n\n\tif (stable_node->head == &migrate_nodes)\n\t\tlist_del(&stable_node->list);\n\telse\n\t\tstable_node_dup_del(stable_node);\n\tfree_stable_node(stable_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "stable_node->kpfn"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "page->mapping"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "page->mapping"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page_unless_zero",
          "args": [
            "page"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "page->mapping"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "kpfn"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "stable_node->kpfn"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct page *get_ksm_page(struct stable_node *stable_node, bool lock_it)\n{\n\tstruct page *page;\n\tvoid *expected_mapping;\n\tunsigned long kpfn;\n\n\texpected_mapping = (void *)((unsigned long)stable_node |\n\t\t\t\t\tPAGE_MAPPING_KSM);\nagain:\n\tkpfn = READ_ONCE(stable_node->kpfn); /* Address dependency. */\n\tpage = pfn_to_page(kpfn);\n\tif (READ_ONCE(page->mapping) != expected_mapping)\n\t\tgoto stale;\n\n\t/*\n\t * We cannot do anything with the page while its refcount is 0.\n\t * Usually 0 means free, or tail of a higher-order page: in which\n\t * case this node is no longer referenced, and should be freed;\n\t * however, it might mean that the page is under page_ref_freeze().\n\t * The __remove_mapping() case is easy, again the node is now stale;\n\t * but if page is swapcache in migrate_page_move_mapping(), it might\n\t * still be our page, in which case it's essential to keep the node.\n\t */\n\twhile (!get_page_unless_zero(page)) {\n\t\t/*\n\t\t * Another check for page->mapping != expected_mapping would\n\t\t * work here too.  We have chosen the !PageSwapCache test to\n\t\t * optimize the common case, when the page is or is about to\n\t\t * be freed: PageSwapCache is cleared (under spin_lock_irq)\n\t\t * in the ref_freeze section of __remove_mapping(); but Anon\n\t\t * page->mapping reset to NULL later, in free_pages_prepare().\n\t\t */\n\t\tif (!PageSwapCache(page))\n\t\t\tgoto stale;\n\t\tcpu_relax();\n\t}\n\n\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\tput_page(page);\n\t\tgoto stale;\n\t}\n\n\tif (lock_it) {\n\t\tlock_page(page);\n\t\tif (READ_ONCE(page->mapping) != expected_mapping) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto stale;\n\t\t}\n\t}\n\treturn page;\n\nstale:\n\t/*\n\t * We come here from above when page->mapping or !PageSwapCache\n\t * suggests that the node is stale; but it might be under migration.\n\t * We need smp_rmb(), matching the smp_wmb() in ksm_migrate_page(),\n\t * before checking whether node->kpfn has been changed.\n\t */\n\tsmp_rmb();\n\tif (READ_ONCE(stable_node->kpfn) != kpfn)\n\t\tgoto again;\n\tremove_node_from_stable_tree(stable_node);\n\treturn NULL;\n}"
  },
  {
    "function_name": "remove_node_from_stable_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "631-667",
    "snippet": "static void remove_node_from_stable_tree(struct stable_node *stable_node)\n{\n\tstruct rmap_item *rmap_item;\n\n\t/* check it's not STABLE_NODE_CHAIN or negative */\n\tBUG_ON(stable_node->rmap_hlist_len < 0);\n\n\thlist_for_each_entry(rmap_item, &stable_node->hlist, hlist) {\n\t\tif (rmap_item->hlist.next)\n\t\t\tksm_pages_sharing--;\n\t\telse\n\t\t\tksm_pages_shared--;\n\t\tVM_BUG_ON(stable_node->rmap_hlist_len <= 0);\n\t\tstable_node->rmap_hlist_len--;\n\t\tput_anon_vma(rmap_item->anon_vma);\n\t\trmap_item->address &= PAGE_MASK;\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * We need the second aligned pointer of the migrate_nodes\n\t * list_head to stay clear from the rb_parent_color union\n\t * (aligned and different than any node) and also different\n\t * from &migrate_nodes. This will verify that future list.h changes\n\t * don't break STABLE_NODE_DUP_HEAD. Only recent gcc can handle it.\n\t */\n#if defined(GCC_VERSION) && GCC_VERSION >= 40903\n\tBUILD_BUG_ON(STABLE_NODE_DUP_HEAD <= &migrate_nodes);\n\tBUILD_BUG_ON(STABLE_NODE_DUP_HEAD >= &migrate_nodes + 1);\n#endif\n\n\tif (stable_node->head == &migrate_nodes)\n\t\tlist_del(&stable_node->list);\n\telse\n\t\tstable_node_dup_del(stable_node);\n\tfree_stable_node(stable_node);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)",
      "#define STABLE_NODE_CHAIN -1024"
    ],
    "globals_used": [
      "static LIST_HEAD(migrate_nodes);",
      "static unsigned long ksm_pages_shared;",
      "static unsigned long ksm_pages_sharing;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_stable_node",
          "args": [
            "stable_node"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "free_stable_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "405-410",
          "snippet": "static inline void free_stable_node(struct stable_node *stable_node)\n{\n\tVM_BUG_ON(stable_node->rmap_hlist_len &&\n\t\t  !is_stable_node_chain(stable_node));\n\tkmem_cache_free(stable_node_cache, stable_node);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *stable_node_cache;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct kmem_cache *stable_node_cache;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void free_stable_node(struct stable_node *stable_node)\n{\n\tVM_BUG_ON(stable_node->rmap_hlist_len &&\n\t\t  !is_stable_node_chain(stable_node));\n\tkmem_cache_free(stable_node_cache, stable_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stable_node_dup_del",
          "args": [
            "stable_node"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "stable_node_dup_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "365-375",
          "snippet": "static inline void stable_node_dup_del(struct stable_node *dup)\n{\n\tVM_BUG_ON(is_stable_node_chain(dup));\n\tif (is_stable_node_dup(dup))\n\t\t__stable_node_dup_del(dup);\n\telse\n\t\trb_erase(&dup->node, root_stable_tree + NUMA(dup->nid));\n#ifdef CONFIG_DEBUG_VM\n\tdup->head = NULL;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root *root_stable_tree = one_stable_tree;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct rb_root *root_stable_tree = one_stable_tree;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void stable_node_dup_del(struct stable_node *dup)\n{\n\tVM_BUG_ON(is_stable_node_chain(dup));\n\tif (is_stable_node_dup(dup))\n\t\t__stable_node_dup_del(dup);\n\telse\n\t\trb_erase(&dup->node, root_stable_tree + NUMA(dup->nid));\n#ifdef CONFIG_DEBUG_VM\n\tdup->head = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&stable_node->list"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "STABLE_NODE_DUP_HEAD >= &migrate_nodes + 1"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "STABLE_NODE_DUP_HEAD <= &migrate_nodes"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_anon_vma",
          "args": [
            "rmap_item->anon_vma"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "__put_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1758-1765",
          "snippet": "void __put_anon_vma(struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *root = anon_vma->root;\n\n\tanon_vma_free(anon_vma);\n\tif (root != anon_vma && atomic_dec_and_test(&root->refcount))\n\t\tanon_vma_free(root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid __put_anon_vma(struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *root = anon_vma->root;\n\n\tanon_vma_free(anon_vma);\n\tif (root != anon_vma && atomic_dec_and_test(&root->refcount))\n\t\tanon_vma_free(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "stable_node->rmap_hlist_len <= 0"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "rmap_item",
            "&stable_node->hlist",
            "hlist"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "stable_node->rmap_hlist_len < 0"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)\n#define STABLE_NODE_CHAIN -1024\n\nstatic LIST_HEAD(migrate_nodes);\nstatic unsigned long ksm_pages_shared;\nstatic unsigned long ksm_pages_sharing;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic void remove_node_from_stable_tree(struct stable_node *stable_node)\n{\n\tstruct rmap_item *rmap_item;\n\n\t/* check it's not STABLE_NODE_CHAIN or negative */\n\tBUG_ON(stable_node->rmap_hlist_len < 0);\n\n\thlist_for_each_entry(rmap_item, &stable_node->hlist, hlist) {\n\t\tif (rmap_item->hlist.next)\n\t\t\tksm_pages_sharing--;\n\t\telse\n\t\t\tksm_pages_shared--;\n\t\tVM_BUG_ON(stable_node->rmap_hlist_len <= 0);\n\t\tstable_node->rmap_hlist_len--;\n\t\tput_anon_vma(rmap_item->anon_vma);\n\t\trmap_item->address &= PAGE_MASK;\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * We need the second aligned pointer of the migrate_nodes\n\t * list_head to stay clear from the rb_parent_color union\n\t * (aligned and different than any node) and also different\n\t * from &migrate_nodes. This will verify that future list.h changes\n\t * don't break STABLE_NODE_DUP_HEAD. Only recent gcc can handle it.\n\t */\n#if defined(GCC_VERSION) && GCC_VERSION >= 40903\n\tBUILD_BUG_ON(STABLE_NODE_DUP_HEAD <= &migrate_nodes);\n\tBUILD_BUG_ON(STABLE_NODE_DUP_HEAD >= &migrate_nodes + 1);\n#endif\n\n\tif (stable_node->head == &migrate_nodes)\n\t\tlist_del(&stable_node->list);\n\telse\n\t\tstable_node_dup_del(stable_node);\n\tfree_stable_node(stable_node);\n}"
  },
  {
    "function_name": "free_stable_node_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "623-629",
    "snippet": "static inline void free_stable_node_chain(struct stable_node *chain,\n\t\t\t\t\t  struct rb_root *root)\n{\n\trb_erase(&chain->node, root);\n\tfree_stable_node(chain);\n\tksm_stable_node_chains--;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long ksm_stable_node_chains;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_stable_node",
          "args": [
            "chain"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "free_stable_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "405-410",
          "snippet": "static inline void free_stable_node(struct stable_node *stable_node)\n{\n\tVM_BUG_ON(stable_node->rmap_hlist_len &&\n\t\t  !is_stable_node_chain(stable_node));\n\tkmem_cache_free(stable_node_cache, stable_node);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *stable_node_cache;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct kmem_cache *stable_node_cache;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void free_stable_node(struct stable_node *stable_node)\n{\n\tVM_BUG_ON(stable_node->rmap_hlist_len &&\n\t\t  !is_stable_node_chain(stable_node));\n\tkmem_cache_free(stable_node_cache, stable_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&chain->node",
            "root"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "vma_rb_erase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "479-489",
          "snippet": "static __always_inline void vma_rb_erase(struct vm_area_struct *vma,\n\t\t\t\t\t struct rb_root *root)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the vma being erased.\n\t */\n\tvalidate_mm_rb(root, vma);\n\n\t__vma_rb_erase(vma, root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic __always_inline void vma_rb_erase(struct vm_area_struct *vma,\n\t\t\t\t\t struct rb_root *root)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the vma being erased.\n\t */\n\tvalidate_mm_rb(root, vma);\n\n\t__vma_rb_erase(vma, root);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic unsigned long ksm_stable_node_chains;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void free_stable_node_chain(struct stable_node *chain,\n\t\t\t\t\t  struct rb_root *root)\n{\n\trb_erase(&chain->node, root);\n\tfree_stable_node(chain);\n\tksm_stable_node_chains--;\n}"
  },
  {
    "function_name": "alloc_stable_node_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "590-621",
    "snippet": "static struct stable_node *alloc_stable_node_chain(struct stable_node *dup,\n\t\t\t\t\t\t   struct rb_root *root)\n{\n\tstruct stable_node *chain = alloc_stable_node();\n\tVM_BUG_ON(is_stable_node_chain(dup));\n\tif (likely(chain)) {\n\t\tINIT_HLIST_HEAD(&chain->hlist);\n\t\tchain->chain_prune_time = jiffies;\n\t\tchain->rmap_hlist_len = STABLE_NODE_CHAIN;\n#if defined (CONFIG_DEBUG_VM) && defined(CONFIG_NUMA)\n\t\tchain->nid = -1; /* debug */\n#endif\n\t\tksm_stable_node_chains++;\n\n\t\t/*\n\t\t * Put the stable node chain in the first dimension of\n\t\t * the stable tree and at the same time remove the old\n\t\t * stable node.\n\t\t */\n\t\trb_replace_node(&dup->node, &chain->node, root);\n\n\t\t/*\n\t\t * Move the old stable node to the second dimension\n\t\t * queued in the hlist_dup. The invariant is that all\n\t\t * dup stable_nodes in the chain->hlist point to pages\n\t\t * that are wrprotected and have the exact same\n\t\t * content.\n\t\t */\n\t\tstable_node_chain_add_dup(dup, chain);\n\t}\n\treturn chain;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define STABLE_NODE_CHAIN -1024"
    ],
    "globals_used": [
      "static unsigned long ksm_stable_node_chains;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stable_node_chain_add_dup",
          "args": [
            "dup",
            "chain"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "stable_node_chain_add_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "348-356",
          "snippet": "static inline void stable_node_chain_add_dup(struct stable_node *dup,\n\t\t\t\t\t     struct stable_node *chain)\n{\n\tVM_BUG_ON(is_stable_node_dup(dup));\n\tdup->head = STABLE_NODE_DUP_HEAD;\n\tVM_BUG_ON(!is_stable_node_chain(chain));\n\thlist_add_head(&dup->hlist_dup, &chain->hlist);\n\tksm_stable_node_dups++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)"
          ],
          "globals_used": [
            "static unsigned long ksm_stable_node_dups;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)\n\nstatic unsigned long ksm_stable_node_dups;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void stable_node_chain_add_dup(struct stable_node *dup,\n\t\t\t\t\t     struct stable_node *chain)\n{\n\tVM_BUG_ON(is_stable_node_dup(dup));\n\tdup->head = STABLE_NODE_DUP_HEAD;\n\tVM_BUG_ON(!is_stable_node_chain(chain));\n\thlist_add_head(&dup->hlist_dup, &chain->hlist);\n\tksm_stable_node_dups++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_replace_node",
          "args": [
            "&dup->node",
            "&chain->node",
            "root"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&chain->hlist"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "chain"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "is_stable_node_chain(dup)"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_stable_node_chain",
          "args": [
            "dup"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "is_stable_node_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "338-341",
          "snippet": "static __always_inline bool is_stable_node_chain(struct stable_node *chain)\n{\n\treturn chain->rmap_hlist_len == STABLE_NODE_CHAIN;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_NODE_CHAIN -1024"
          ],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_CHAIN -1024\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic __always_inline bool is_stable_node_chain(struct stable_node *chain)\n{\n\treturn chain->rmap_hlist_len == STABLE_NODE_CHAIN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_stable_node",
          "args": [],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_stable_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "395-403",
          "snippet": "static inline struct stable_node *alloc_stable_node(void)\n{\n\t/*\n\t * The allocation can take too long with GFP_KERNEL when memory is under\n\t * pressure, which may lead to hung task warnings.  Adding __GFP_HIGH\n\t * grants access to memory reserves, helping to avoid this problem.\n\t */\n\treturn kmem_cache_alloc(stable_node_cache, GFP_KERNEL | __GFP_HIGH);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *stable_node_cache;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct kmem_cache *stable_node_cache;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline struct stable_node *alloc_stable_node(void)\n{\n\t/*\n\t * The allocation can take too long with GFP_KERNEL when memory is under\n\t * pressure, which may lead to hung task warnings.  Adding __GFP_HIGH\n\t * grants access to memory reserves, helping to avoid this problem.\n\t */\n\treturn kmem_cache_alloc(stable_node_cache, GFP_KERNEL | __GFP_HIGH);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_CHAIN -1024\n\nstatic unsigned long ksm_stable_node_chains;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct stable_node *alloc_stable_node_chain(struct stable_node *dup,\n\t\t\t\t\t\t   struct rb_root *root)\n{\n\tstruct stable_node *chain = alloc_stable_node();\n\tVM_BUG_ON(is_stable_node_chain(dup));\n\tif (likely(chain)) {\n\t\tINIT_HLIST_HEAD(&chain->hlist);\n\t\tchain->chain_prune_time = jiffies;\n\t\tchain->rmap_hlist_len = STABLE_NODE_CHAIN;\n#if defined (CONFIG_DEBUG_VM) && defined(CONFIG_NUMA)\n\t\tchain->nid = -1; /* debug */\n#endif\n\t\tksm_stable_node_chains++;\n\n\t\t/*\n\t\t * Put the stable node chain in the first dimension of\n\t\t * the stable tree and at the same time remove the old\n\t\t * stable node.\n\t\t */\n\t\trb_replace_node(&dup->node, &chain->node, root);\n\n\t\t/*\n\t\t * Move the old stable node to the second dimension\n\t\t * queued in the hlist_dup. The invariant is that all\n\t\t * dup stable_nodes in the chain->hlist point to pages\n\t\t * that are wrprotected and have the exact same\n\t\t * content.\n\t\t */\n\t\tstable_node_chain_add_dup(dup, chain);\n\t}\n\treturn chain;\n}"
  },
  {
    "function_name": "get_kpfn_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "585-588",
    "snippet": "static inline int get_kpfn_nid(unsigned long kpfn)\n{\n\treturn ksm_merge_across_nodes ? 0 : NUMA(pfn_to_nid(kpfn));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define ksm_merge_across_nodes\t1U"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NUMA",
          "args": [
            "pfn_to_nid(kpfn)"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_nid",
          "args": [
            "kpfn"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "early_pfn_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1292-1304",
          "snippet": "int __meminit early_pfn_to_nid(unsigned long pfn)\n{\n\tstatic DEFINE_SPINLOCK(early_pfn_lock);\n\tint nid;\n\n\tspin_lock(&early_pfn_lock);\n\tnid = __early_pfn_to_nid(pfn, &early_pfnnid_cache);\n\tif (nid < 0)\n\t\tnid = first_online_node;\n\tspin_unlock(&early_pfn_lock);\n\n\treturn nid;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint __meminit early_pfn_to_nid(unsigned long pfn)\n{\n\tstatic DEFINE_SPINLOCK(early_pfn_lock);\n\tint nid;\n\n\tspin_lock(&early_pfn_lock);\n\tnid = __early_pfn_to_nid(pfn, &early_pfnnid_cache);\n\tif (nid < 0)\n\t\tnid = first_online_node;\n\tspin_unlock(&early_pfn_lock);\n\n\treturn nid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define ksm_merge_across_nodes\t1U\n\nstatic inline int get_kpfn_nid(unsigned long kpfn)\n{\n\treturn ksm_merge_across_nodes ? 0 : NUMA(pfn_to_nid(kpfn));\n}"
  },
  {
    "function_name": "get_mergeable_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "552-577",
    "snippet": "static struct page *get_mergeable_page(struct rmap_item *rmap_item)\n{\n\tstruct mm_struct *mm = rmap_item->mm;\n\tunsigned long addr = rmap_item->address;\n\tstruct vm_area_struct *vma;\n\tstruct page *page;\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_mergeable_vma(mm, addr);\n\tif (!vma)\n\t\tgoto out;\n\n\tpage = follow_page(vma, addr, FOLL_GET);\n\tif (IS_ERR_OR_NULL(page))\n\t\tgoto out;\n\tif (PageAnon(page)) {\n\t\tflush_anon_page(vma, page, addr);\n\t\tflush_dcache_page(page);\n\t} else {\n\t\tput_page(page);\nout:\n\t\tpage = NULL;\n\t}\n\tup_read(&mm->mmap_sem);\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_anon_page",
          "args": [
            "vma",
            "page",
            "addr"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "page"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_page",
          "args": [
            "vma",
            "addr",
            "FOLL_GET"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "follow_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "1712-1716",
          "snippet": "struct page *follow_page(struct vm_area_struct *vma, unsigned long address,\n\t\t\t unsigned int foll_flags)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct page *follow_page(struct vm_area_struct *vma, unsigned long address,\n\t\t\t unsigned int foll_flags)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_mergeable_vma",
          "args": [
            "mm",
            "addr"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "find_mergeable_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "519-531",
          "snippet": "static struct vm_area_struct *find_mergeable_vma(struct mm_struct *mm,\n\t\tunsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\tif (ksm_test_exit(mm))\n\t\treturn NULL;\n\tvma = find_vma(mm, addr);\n\tif (!vma || vma->vm_start > addr)\n\t\treturn NULL;\n\tif (!(vma->vm_flags & VM_MERGEABLE) || !vma->anon_vma)\n\t\treturn NULL;\n\treturn vma;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct vm_area_struct *find_mergeable_vma(struct mm_struct *mm,\n\t\tunsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\tif (ksm_test_exit(mm))\n\t\treturn NULL;\n\tvma = find_vma(mm, addr);\n\tif (!vma || vma->vm_start > addr)\n\t\treturn NULL;\n\tif (!(vma->vm_flags & VM_MERGEABLE) || !vma->anon_vma)\n\t\treturn NULL;\n\treturn vma;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct page *get_mergeable_page(struct rmap_item *rmap_item)\n{\n\tstruct mm_struct *mm = rmap_item->mm;\n\tunsigned long addr = rmap_item->address;\n\tstruct vm_area_struct *vma;\n\tstruct page *page;\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_mergeable_vma(mm, addr);\n\tif (!vma)\n\t\tgoto out;\n\n\tpage = follow_page(vma, addr, FOLL_GET);\n\tif (IS_ERR_OR_NULL(page))\n\t\tgoto out;\n\tif (PageAnon(page)) {\n\t\tflush_anon_page(vma, page, addr);\n\t\tflush_dcache_page(page);\n\t} else {\n\t\tput_page(page);\nout:\n\t\tpage = NULL;\n\t}\n\tup_read(&mm->mmap_sem);\n\treturn page;\n}"
  },
  {
    "function_name": "break_cow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "533-550",
    "snippet": "static void break_cow(struct rmap_item *rmap_item)\n{\n\tstruct mm_struct *mm = rmap_item->mm;\n\tunsigned long addr = rmap_item->address;\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * It is not an accident that whenever we want to break COW\n\t * to undo, we also need to drop a reference to the anon_vma.\n\t */\n\tput_anon_vma(rmap_item->anon_vma);\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_mergeable_vma(mm, addr);\n\tif (vma)\n\t\tbreak_ksm(vma, addr);\n\tup_read(&mm->mmap_sem);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "break_ksm",
          "args": [
            "vma",
            "addr"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "break_ksm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "470-517",
          "snippet": "static int break_ksm(struct vm_area_struct *vma, unsigned long addr)\n{\n\tstruct page *page;\n\tvm_fault_t ret = 0;\n\n\tdo {\n\t\tcond_resched();\n\t\tpage = follow_page(vma, addr,\n\t\t\t\tFOLL_GET | FOLL_MIGRATION | FOLL_REMOTE);\n\t\tif (IS_ERR_OR_NULL(page))\n\t\t\tbreak;\n\t\tif (PageKsm(page))\n\t\t\tret = handle_mm_fault(vma, addr,\n\t\t\t\t\tFAULT_FLAG_WRITE | FAULT_FLAG_REMOTE);\n\t\telse\n\t\t\tret = VM_FAULT_WRITE;\n\t\tput_page(page);\n\t} while (!(ret & (VM_FAULT_WRITE | VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV | VM_FAULT_OOM)));\n\t/*\n\t * We must loop because handle_mm_fault() may back out if there's\n\t * any difficulty e.g. if pte accessed bit gets updated concurrently.\n\t *\n\t * VM_FAULT_WRITE is what we have been hoping for: it indicates that\n\t * COW has been broken, even if the vma does not permit VM_WRITE;\n\t * but note that a concurrent fault might break PageKsm for us.\n\t *\n\t * VM_FAULT_SIGBUS could occur if we race with truncation of the\n\t * backing file, which also invalidates anonymous pages: that's\n\t * okay, that truncation will have unmapped the PageKsm for us.\n\t *\n\t * VM_FAULT_OOM: at the time of writing (late July 2009), setting\n\t * aside mem_cgroup limits, VM_FAULT_OOM would only be set if the\n\t * current task has TIF_MEMDIE set, and will be OOM killed on return\n\t * to user; and ksmd, having no mm, would never be chosen for that.\n\t *\n\t * But if the mm is in a limited mem_cgroup, then the fault may fail\n\t * with VM_FAULT_OOM even if the current task is not TIF_MEMDIE; and\n\t * even ksmd can fail in this way - though it's usually breaking ksm\n\t * just to undo a merge it made a moment before, so unlikely to oom.\n\t *\n\t * That's a pity: we might therefore have more kernel pages allocated\n\t * than we're counting as nodes in the stable tree; but ksm_do_scan\n\t * will retry to break_cow on each pass, so should recover the page\n\t * in due course.  The important thing is to not let VM_MERGEABLE\n\t * be cleared while any such pages might remain in the area.\n\t */\n\treturn (ret & VM_FAULT_OOM) ? -ENOMEM : 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int break_ksm(struct vm_area_struct *vma, unsigned long addr)\n{\n\tstruct page *page;\n\tvm_fault_t ret = 0;\n\n\tdo {\n\t\tcond_resched();\n\t\tpage = follow_page(vma, addr,\n\t\t\t\tFOLL_GET | FOLL_MIGRATION | FOLL_REMOTE);\n\t\tif (IS_ERR_OR_NULL(page))\n\t\t\tbreak;\n\t\tif (PageKsm(page))\n\t\t\tret = handle_mm_fault(vma, addr,\n\t\t\t\t\tFAULT_FLAG_WRITE | FAULT_FLAG_REMOTE);\n\t\telse\n\t\t\tret = VM_FAULT_WRITE;\n\t\tput_page(page);\n\t} while (!(ret & (VM_FAULT_WRITE | VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV | VM_FAULT_OOM)));\n\t/*\n\t * We must loop because handle_mm_fault() may back out if there's\n\t * any difficulty e.g. if pte accessed bit gets updated concurrently.\n\t *\n\t * VM_FAULT_WRITE is what we have been hoping for: it indicates that\n\t * COW has been broken, even if the vma does not permit VM_WRITE;\n\t * but note that a concurrent fault might break PageKsm for us.\n\t *\n\t * VM_FAULT_SIGBUS could occur if we race with truncation of the\n\t * backing file, which also invalidates anonymous pages: that's\n\t * okay, that truncation will have unmapped the PageKsm for us.\n\t *\n\t * VM_FAULT_OOM: at the time of writing (late July 2009), setting\n\t * aside mem_cgroup limits, VM_FAULT_OOM would only be set if the\n\t * current task has TIF_MEMDIE set, and will be OOM killed on return\n\t * to user; and ksmd, having no mm, would never be chosen for that.\n\t *\n\t * But if the mm is in a limited mem_cgroup, then the fault may fail\n\t * with VM_FAULT_OOM even if the current task is not TIF_MEMDIE; and\n\t * even ksmd can fail in this way - though it's usually breaking ksm\n\t * just to undo a merge it made a moment before, so unlikely to oom.\n\t *\n\t * That's a pity: we might therefore have more kernel pages allocated\n\t * than we're counting as nodes in the stable tree; but ksm_do_scan\n\t * will retry to break_cow on each pass, so should recover the page\n\t * in due course.  The important thing is to not let VM_MERGEABLE\n\t * be cleared while any such pages might remain in the area.\n\t */\n\treturn (ret & VM_FAULT_OOM) ? -ENOMEM : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_mergeable_vma",
          "args": [
            "mm",
            "addr"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "find_mergeable_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "519-531",
          "snippet": "static struct vm_area_struct *find_mergeable_vma(struct mm_struct *mm,\n\t\tunsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\tif (ksm_test_exit(mm))\n\t\treturn NULL;\n\tvma = find_vma(mm, addr);\n\tif (!vma || vma->vm_start > addr)\n\t\treturn NULL;\n\tif (!(vma->vm_flags & VM_MERGEABLE) || !vma->anon_vma)\n\t\treturn NULL;\n\treturn vma;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct vm_area_struct *find_mergeable_vma(struct mm_struct *mm,\n\t\tunsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\tif (ksm_test_exit(mm))\n\t\treturn NULL;\n\tvma = find_vma(mm, addr);\n\tif (!vma || vma->vm_start > addr)\n\t\treturn NULL;\n\tif (!(vma->vm_flags & VM_MERGEABLE) || !vma->anon_vma)\n\t\treturn NULL;\n\treturn vma;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_anon_vma",
          "args": [
            "rmap_item->anon_vma"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "__put_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1758-1765",
          "snippet": "void __put_anon_vma(struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *root = anon_vma->root;\n\n\tanon_vma_free(anon_vma);\n\tif (root != anon_vma && atomic_dec_and_test(&root->refcount))\n\t\tanon_vma_free(root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid __put_anon_vma(struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *root = anon_vma->root;\n\n\tanon_vma_free(anon_vma);\n\tif (root != anon_vma && atomic_dec_and_test(&root->refcount))\n\t\tanon_vma_free(root);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic void break_cow(struct rmap_item *rmap_item)\n{\n\tstruct mm_struct *mm = rmap_item->mm;\n\tunsigned long addr = rmap_item->address;\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * It is not an accident that whenever we want to break COW\n\t * to undo, we also need to drop a reference to the anon_vma.\n\t */\n\tput_anon_vma(rmap_item->anon_vma);\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_mergeable_vma(mm, addr);\n\tif (vma)\n\t\tbreak_ksm(vma, addr);\n\tup_read(&mm->mmap_sem);\n}"
  },
  {
    "function_name": "find_mergeable_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "519-531",
    "snippet": "static struct vm_area_struct *find_mergeable_vma(struct mm_struct *mm,\n\t\tunsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\tif (ksm_test_exit(mm))\n\t\treturn NULL;\n\tvma = find_vma(mm, addr);\n\tif (!vma || vma->vm_start > addr)\n\t\treturn NULL;\n\tif (!(vma->vm_flags & VM_MERGEABLE) || !vma->anon_vma)\n\t\treturn NULL;\n\treturn vma;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "mm",
            "addr"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "775-796",
          "snippet": "struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ksm_test_exit",
          "args": [
            "mm"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "ksm_test_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "450-453",
          "snippet": "static inline bool ksm_test_exit(struct mm_struct *mm)\n{\n\treturn atomic_read(&mm->mm_users) == 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline bool ksm_test_exit(struct mm_struct *mm)\n{\n\treturn atomic_read(&mm->mm_users) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct vm_area_struct *find_mergeable_vma(struct mm_struct *mm,\n\t\tunsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\tif (ksm_test_exit(mm))\n\t\treturn NULL;\n\tvma = find_vma(mm, addr);\n\tif (!vma || vma->vm_start > addr)\n\t\treturn NULL;\n\tif (!(vma->vm_flags & VM_MERGEABLE) || !vma->anon_vma)\n\t\treturn NULL;\n\treturn vma;\n}"
  },
  {
    "function_name": "break_ksm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "470-517",
    "snippet": "static int break_ksm(struct vm_area_struct *vma, unsigned long addr)\n{\n\tstruct page *page;\n\tvm_fault_t ret = 0;\n\n\tdo {\n\t\tcond_resched();\n\t\tpage = follow_page(vma, addr,\n\t\t\t\tFOLL_GET | FOLL_MIGRATION | FOLL_REMOTE);\n\t\tif (IS_ERR_OR_NULL(page))\n\t\t\tbreak;\n\t\tif (PageKsm(page))\n\t\t\tret = handle_mm_fault(vma, addr,\n\t\t\t\t\tFAULT_FLAG_WRITE | FAULT_FLAG_REMOTE);\n\t\telse\n\t\t\tret = VM_FAULT_WRITE;\n\t\tput_page(page);\n\t} while (!(ret & (VM_FAULT_WRITE | VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV | VM_FAULT_OOM)));\n\t/*\n\t * We must loop because handle_mm_fault() may back out if there's\n\t * any difficulty e.g. if pte accessed bit gets updated concurrently.\n\t *\n\t * VM_FAULT_WRITE is what we have been hoping for: it indicates that\n\t * COW has been broken, even if the vma does not permit VM_WRITE;\n\t * but note that a concurrent fault might break PageKsm for us.\n\t *\n\t * VM_FAULT_SIGBUS could occur if we race with truncation of the\n\t * backing file, which also invalidates anonymous pages: that's\n\t * okay, that truncation will have unmapped the PageKsm for us.\n\t *\n\t * VM_FAULT_OOM: at the time of writing (late July 2009), setting\n\t * aside mem_cgroup limits, VM_FAULT_OOM would only be set if the\n\t * current task has TIF_MEMDIE set, and will be OOM killed on return\n\t * to user; and ksmd, having no mm, would never be chosen for that.\n\t *\n\t * But if the mm is in a limited mem_cgroup, then the fault may fail\n\t * with VM_FAULT_OOM even if the current task is not TIF_MEMDIE; and\n\t * even ksmd can fail in this way - though it's usually breaking ksm\n\t * just to undo a merge it made a moment before, so unlikely to oom.\n\t *\n\t * That's a pity: we might therefore have more kernel pages allocated\n\t * than we're counting as nodes in the stable tree; but ksm_do_scan\n\t * will retry to break_cow on each pass, so should recover the page\n\t * in due course.  The important thing is to not let VM_MERGEABLE\n\t * be cleared while any such pages might remain in the area.\n\t */\n\treturn (ret & VM_FAULT_OOM) ? -ENOMEM : 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_mm_fault",
          "args": [
            "vma",
            "addr",
            "FAULT_FLAG_WRITE | FAULT_FLAG_REMOTE"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "handle_mm_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3898-3941",
          "snippet": "vm_fault_t handle_mm_fault(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned int flags)\n{\n\tvm_fault_t ret;\n\n\t__set_current_state(TASK_RUNNING);\n\n\tcount_vm_event(PGFAULT);\n\tcount_memcg_event_mm(vma->vm_mm, PGFAULT);\n\n\t/* do counter updates before entering really critical section. */\n\tcheck_sync_rss_stat(current);\n\n\tif (!arch_vma_access_permitted(vma, flags & FAULT_FLAG_WRITE,\n\t\t\t\t\t    flags & FAULT_FLAG_INSTRUCTION,\n\t\t\t\t\t    flags & FAULT_FLAG_REMOTE))\n\t\treturn VM_FAULT_SIGSEGV;\n\n\t/*\n\t * Enable the memcg OOM handling for faults triggered in user\n\t * space.  Kernel faults are handled more gracefully.\n\t */\n\tif (flags & FAULT_FLAG_USER)\n\t\tmem_cgroup_enter_user_fault();\n\n\tif (unlikely(is_vm_hugetlb_page(vma)))\n\t\tret = hugetlb_fault(vma->vm_mm, vma, address, flags);\n\telse\n\t\tret = __handle_mm_fault(vma, address, flags);\n\n\tif (flags & FAULT_FLAG_USER) {\n\t\tmem_cgroup_exit_user_fault();\n\t\t/*\n\t\t * The task may have entered a memcg OOM situation but\n\t\t * if the allocation error was handled gracefully (no\n\t\t * VM_FAULT_OOM), there is no need to kill anything.\n\t\t * Just clean up the OOM state peacefully.\n\t\t */\n\t\tif (task_in_memcg_oom(current) && !(ret & VM_FAULT_OOM))\n\t\t\tmem_cgroup_oom_synchronize(false);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvm_fault_t handle_mm_fault(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned int flags)\n{\n\tvm_fault_t ret;\n\n\t__set_current_state(TASK_RUNNING);\n\n\tcount_vm_event(PGFAULT);\n\tcount_memcg_event_mm(vma->vm_mm, PGFAULT);\n\n\t/* do counter updates before entering really critical section. */\n\tcheck_sync_rss_stat(current);\n\n\tif (!arch_vma_access_permitted(vma, flags & FAULT_FLAG_WRITE,\n\t\t\t\t\t    flags & FAULT_FLAG_INSTRUCTION,\n\t\t\t\t\t    flags & FAULT_FLAG_REMOTE))\n\t\treturn VM_FAULT_SIGSEGV;\n\n\t/*\n\t * Enable the memcg OOM handling for faults triggered in user\n\t * space.  Kernel faults are handled more gracefully.\n\t */\n\tif (flags & FAULT_FLAG_USER)\n\t\tmem_cgroup_enter_user_fault();\n\n\tif (unlikely(is_vm_hugetlb_page(vma)))\n\t\tret = hugetlb_fault(vma->vm_mm, vma, address, flags);\n\telse\n\t\tret = __handle_mm_fault(vma, address, flags);\n\n\tif (flags & FAULT_FLAG_USER) {\n\t\tmem_cgroup_exit_user_fault();\n\t\t/*\n\t\t * The task may have entered a memcg OOM situation but\n\t\t * if the allocation error was handled gracefully (no\n\t\t * VM_FAULT_OOM), there is no need to kill anything.\n\t\t * Just clean up the OOM state peacefully.\n\t\t */\n\t\tif (task_in_memcg_oom(current) && !(ret & VM_FAULT_OOM))\n\t\t\tmem_cgroup_oom_synchronize(false);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageKsm",
          "args": [
            "page"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "page"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_page",
          "args": [
            "vma",
            "addr",
            "FOLL_GET | FOLL_MIGRATION | FOLL_REMOTE"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "follow_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "1712-1716",
          "snippet": "struct page *follow_page(struct vm_area_struct *vma, unsigned long address,\n\t\t\t unsigned int foll_flags)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct page *follow_page(struct vm_area_struct *vma, unsigned long address,\n\t\t\t unsigned int foll_flags)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic int break_ksm(struct vm_area_struct *vma, unsigned long addr)\n{\n\tstruct page *page;\n\tvm_fault_t ret = 0;\n\n\tdo {\n\t\tcond_resched();\n\t\tpage = follow_page(vma, addr,\n\t\t\t\tFOLL_GET | FOLL_MIGRATION | FOLL_REMOTE);\n\t\tif (IS_ERR_OR_NULL(page))\n\t\t\tbreak;\n\t\tif (PageKsm(page))\n\t\t\tret = handle_mm_fault(vma, addr,\n\t\t\t\t\tFAULT_FLAG_WRITE | FAULT_FLAG_REMOTE);\n\t\telse\n\t\t\tret = VM_FAULT_WRITE;\n\t\tput_page(page);\n\t} while (!(ret & (VM_FAULT_WRITE | VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV | VM_FAULT_OOM)));\n\t/*\n\t * We must loop because handle_mm_fault() may back out if there's\n\t * any difficulty e.g. if pte accessed bit gets updated concurrently.\n\t *\n\t * VM_FAULT_WRITE is what we have been hoping for: it indicates that\n\t * COW has been broken, even if the vma does not permit VM_WRITE;\n\t * but note that a concurrent fault might break PageKsm for us.\n\t *\n\t * VM_FAULT_SIGBUS could occur if we race with truncation of the\n\t * backing file, which also invalidates anonymous pages: that's\n\t * okay, that truncation will have unmapped the PageKsm for us.\n\t *\n\t * VM_FAULT_OOM: at the time of writing (late July 2009), setting\n\t * aside mem_cgroup limits, VM_FAULT_OOM would only be set if the\n\t * current task has TIF_MEMDIE set, and will be OOM killed on return\n\t * to user; and ksmd, having no mm, would never be chosen for that.\n\t *\n\t * But if the mm is in a limited mem_cgroup, then the fault may fail\n\t * with VM_FAULT_OOM even if the current task is not TIF_MEMDIE; and\n\t * even ksmd can fail in this way - though it's usually breaking ksm\n\t * just to undo a merge it made a moment before, so unlikely to oom.\n\t *\n\t * That's a pity: we might therefore have more kernel pages allocated\n\t * than we're counting as nodes in the stable tree; but ksm_do_scan\n\t * will retry to break_cow on each pass, so should recover the page\n\t * in due course.  The important thing is to not let VM_MERGEABLE\n\t * be cleared while any such pages might remain in the area.\n\t */\n\treturn (ret & VM_FAULT_OOM) ? -ENOMEM : 0;\n}"
  },
  {
    "function_name": "ksm_test_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "450-453",
    "snippet": "static inline bool ksm_test_exit(struct mm_struct *mm)\n{\n\treturn atomic_read(&mm->mm_users) == 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&mm->mm_users"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline bool ksm_test_exit(struct mm_struct *mm)\n{\n\treturn atomic_read(&mm->mm_users) == 0;\n}"
  },
  {
    "function_name": "insert_to_mm_slots_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "435-440",
    "snippet": "static void insert_to_mm_slots_hash(struct mm_struct *mm,\n\t\t\t\t    struct mm_slot *mm_slot)\n{\n\tmm_slot->mm = mm;\n\thash_add(mm_slots_hash, &mm_slot->link, (unsigned long)mm);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_add",
          "args": [
            "mm_slots_hash",
            "&mm_slot->link",
            "(unsigned long)mm"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic void insert_to_mm_slots_hash(struct mm_struct *mm,\n\t\t\t\t    struct mm_slot *mm_slot)\n{\n\tmm_slot->mm = mm;\n\thash_add(mm_slots_hash, &mm_slot->link, (unsigned long)mm);\n}"
  },
  {
    "function_name": "get_mm_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "424-433",
    "snippet": "static struct mm_slot *get_mm_slot(struct mm_struct *mm)\n{\n\tstruct mm_slot *slot;\n\n\thash_for_each_possible(mm_slots_hash, slot, link, (unsigned long)mm)\n\t\tif (slot->mm == mm)\n\t\t\treturn slot;\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_for_each_possible",
          "args": [
            "mm_slots_hash",
            "slot",
            "link",
            "(unsigned long)mm"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic struct mm_slot *get_mm_slot(struct mm_struct *mm)\n{\n\tstruct mm_slot *slot;\n\n\thash_for_each_possible(mm_slots_hash, slot, link, (unsigned long)mm)\n\t\tif (slot->mm == mm)\n\t\t\treturn slot;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "free_mm_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "419-422",
    "snippet": "static inline void free_mm_slot(struct mm_slot *mm_slot)\n{\n\tkmem_cache_free(mm_slot_cache, mm_slot);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *mm_slot_cache;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "mm_slot_cache",
            "mm_slot"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3749-3764",
          "snippet": "void kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct kmem_cache *mm_slot_cache;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void free_mm_slot(struct mm_slot *mm_slot)\n{\n\tkmem_cache_free(mm_slot_cache, mm_slot);\n}"
  },
  {
    "function_name": "alloc_mm_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "412-417",
    "snippet": "static inline struct mm_slot *alloc_mm_slot(void)\n{\n\tif (!mm_slot_cache)\t/* initialization failed */\n\t\treturn NULL;\n\treturn kmem_cache_zalloc(mm_slot_cache, GFP_KERNEL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *mm_slot_cache;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "mm_slot_cache",
            "GFP_KERNEL"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct kmem_cache *mm_slot_cache;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline struct mm_slot *alloc_mm_slot(void)\n{\n\tif (!mm_slot_cache)\t/* initialization failed */\n\t\treturn NULL;\n\treturn kmem_cache_zalloc(mm_slot_cache, GFP_KERNEL);\n}"
  },
  {
    "function_name": "free_stable_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "405-410",
    "snippet": "static inline void free_stable_node(struct stable_node *stable_node)\n{\n\tVM_BUG_ON(stable_node->rmap_hlist_len &&\n\t\t  !is_stable_node_chain(stable_node));\n\tkmem_cache_free(stable_node_cache, stable_node);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *stable_node_cache;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "stable_node_cache",
            "stable_node"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3749-3764",
          "snippet": "void kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "stable_node->rmap_hlist_len &&\n\t\t  !is_stable_node_chain(stable_node)"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_stable_node_chain",
          "args": [
            "stable_node"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "is_stable_node_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "338-341",
          "snippet": "static __always_inline bool is_stable_node_chain(struct stable_node *chain)\n{\n\treturn chain->rmap_hlist_len == STABLE_NODE_CHAIN;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_NODE_CHAIN -1024"
          ],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_CHAIN -1024\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic __always_inline bool is_stable_node_chain(struct stable_node *chain)\n{\n\treturn chain->rmap_hlist_len == STABLE_NODE_CHAIN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct kmem_cache *stable_node_cache;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void free_stable_node(struct stable_node *stable_node)\n{\n\tVM_BUG_ON(stable_node->rmap_hlist_len &&\n\t\t  !is_stable_node_chain(stable_node));\n\tkmem_cache_free(stable_node_cache, stable_node);\n}"
  },
  {
    "function_name": "alloc_stable_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "395-403",
    "snippet": "static inline struct stable_node *alloc_stable_node(void)\n{\n\t/*\n\t * The allocation can take too long with GFP_KERNEL when memory is under\n\t * pressure, which may lead to hung task warnings.  Adding __GFP_HIGH\n\t * grants access to memory reserves, helping to avoid this problem.\n\t */\n\treturn kmem_cache_alloc(stable_node_cache, GFP_KERNEL | __GFP_HIGH);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *stable_node_cache;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "stable_node_cache",
            "GFP_KERNEL | __GFP_HIGH"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3550-3559",
          "snippet": "void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *ret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc(_RET_IP_, ret,\n\t\t\t       cachep->object_size, cachep->size, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *ret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc(_RET_IP_, ret,\n\t\t\t       cachep->object_size, cachep->size, flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct kmem_cache *stable_node_cache;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline struct stable_node *alloc_stable_node(void)\n{\n\t/*\n\t * The allocation can take too long with GFP_KERNEL when memory is under\n\t * pressure, which may lead to hung task warnings.  Adding __GFP_HIGH\n\t * grants access to memory reserves, helping to avoid this problem.\n\t */\n\treturn kmem_cache_alloc(stable_node_cache, GFP_KERNEL | __GFP_HIGH);\n}"
  },
  {
    "function_name": "free_rmap_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "388-393",
    "snippet": "static inline void free_rmap_item(struct rmap_item *rmap_item)\n{\n\tksm_rmap_items--;\n\trmap_item->mm = NULL;\t/* debug safety */\n\tkmem_cache_free(rmap_item_cache, rmap_item);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *rmap_item_cache;",
      "static unsigned long ksm_rmap_items;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "rmap_item_cache",
            "rmap_item"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3749-3764",
          "snippet": "void kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct kmem_cache *rmap_item_cache;\nstatic unsigned long ksm_rmap_items;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void free_rmap_item(struct rmap_item *rmap_item)\n{\n\tksm_rmap_items--;\n\trmap_item->mm = NULL;\t/* debug safety */\n\tkmem_cache_free(rmap_item_cache, rmap_item);\n}"
  },
  {
    "function_name": "alloc_rmap_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "377-386",
    "snippet": "static inline struct rmap_item *alloc_rmap_item(void)\n{\n\tstruct rmap_item *rmap_item;\n\n\trmap_item = kmem_cache_zalloc(rmap_item_cache, GFP_KERNEL |\n\t\t\t\t\t\t__GFP_NORETRY | __GFP_NOWARN);\n\tif (rmap_item)\n\t\tksm_rmap_items++;\n\treturn rmap_item;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *rmap_item_cache;",
      "static unsigned long ksm_rmap_items;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "rmap_item_cache",
            "GFP_KERNEL |\n\t\t\t\t\t\t__GFP_NORETRY | __GFP_NOWARN"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct kmem_cache *rmap_item_cache;\nstatic unsigned long ksm_rmap_items;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline struct rmap_item *alloc_rmap_item(void)\n{\n\tstruct rmap_item *rmap_item;\n\n\trmap_item = kmem_cache_zalloc(rmap_item_cache, GFP_KERNEL |\n\t\t\t\t\t\t__GFP_NORETRY | __GFP_NOWARN);\n\tif (rmap_item)\n\t\tksm_rmap_items++;\n\treturn rmap_item;\n}"
  },
  {
    "function_name": "stable_node_dup_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "365-375",
    "snippet": "static inline void stable_node_dup_del(struct stable_node *dup)\n{\n\tVM_BUG_ON(is_stable_node_chain(dup));\n\tif (is_stable_node_dup(dup))\n\t\t__stable_node_dup_del(dup);\n\telse\n\t\trb_erase(&dup->node, root_stable_tree + NUMA(dup->nid));\n#ifdef CONFIG_DEBUG_VM\n\tdup->head = NULL;\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root *root_stable_tree = one_stable_tree;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&dup->node",
            "root_stable_tree + NUMA(dup->nid)"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "vma_rb_erase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "479-489",
          "snippet": "static __always_inline void vma_rb_erase(struct vm_area_struct *vma,\n\t\t\t\t\t struct rb_root *root)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the vma being erased.\n\t */\n\tvalidate_mm_rb(root, vma);\n\n\t__vma_rb_erase(vma, root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic __always_inline void vma_rb_erase(struct vm_area_struct *vma,\n\t\t\t\t\t struct rb_root *root)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the vma being erased.\n\t */\n\tvalidate_mm_rb(root, vma);\n\n\t__vma_rb_erase(vma, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NUMA",
          "args": [
            "dup->nid"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__stable_node_dup_del",
          "args": [
            "dup"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "__stable_node_dup_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "358-363",
          "snippet": "static inline void __stable_node_dup_del(struct stable_node *dup)\n{\n\tVM_BUG_ON(!is_stable_node_dup(dup));\n\thlist_del(&dup->hlist_dup);\n\tksm_stable_node_dups--;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long ksm_stable_node_dups;",
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic unsigned long ksm_stable_node_dups;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void __stable_node_dup_del(struct stable_node *dup)\n{\n\tVM_BUG_ON(!is_stable_node_dup(dup));\n\thlist_del(&dup->hlist_dup);\n\tksm_stable_node_dups--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_stable_node_dup",
          "args": [
            "dup"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "is_stable_node_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "343-346",
          "snippet": "static __always_inline bool is_stable_node_dup(struct stable_node *dup)\n{\n\treturn dup->head == STABLE_NODE_DUP_HEAD;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)"
          ],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic __always_inline bool is_stable_node_dup(struct stable_node *dup)\n{\n\treturn dup->head == STABLE_NODE_DUP_HEAD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "is_stable_node_chain(dup)"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_stable_node_chain",
          "args": [
            "dup"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "is_stable_node_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "338-341",
          "snippet": "static __always_inline bool is_stable_node_chain(struct stable_node *chain)\n{\n\treturn chain->rmap_hlist_len == STABLE_NODE_CHAIN;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_NODE_CHAIN -1024"
          ],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_CHAIN -1024\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic __always_inline bool is_stable_node_chain(struct stable_node *chain)\n{\n\treturn chain->rmap_hlist_len == STABLE_NODE_CHAIN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct rb_root *root_stable_tree = one_stable_tree;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void stable_node_dup_del(struct stable_node *dup)\n{\n\tVM_BUG_ON(is_stable_node_chain(dup));\n\tif (is_stable_node_dup(dup))\n\t\t__stable_node_dup_del(dup);\n\telse\n\t\trb_erase(&dup->node, root_stable_tree + NUMA(dup->nid));\n#ifdef CONFIG_DEBUG_VM\n\tdup->head = NULL;\n#endif\n}"
  },
  {
    "function_name": "__stable_node_dup_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "358-363",
    "snippet": "static inline void __stable_node_dup_del(struct stable_node *dup)\n{\n\tVM_BUG_ON(!is_stable_node_dup(dup));\n\thlist_del(&dup->hlist_dup);\n\tksm_stable_node_dups--;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long ksm_stable_node_dups;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "&dup->hlist_dup"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!is_stable_node_dup(dup)"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_stable_node_dup",
          "args": [
            "dup"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "is_stable_node_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "343-346",
          "snippet": "static __always_inline bool is_stable_node_dup(struct stable_node *dup)\n{\n\treturn dup->head == STABLE_NODE_DUP_HEAD;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)"
          ],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic __always_inline bool is_stable_node_dup(struct stable_node *dup)\n{\n\treturn dup->head == STABLE_NODE_DUP_HEAD;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic unsigned long ksm_stable_node_dups;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void __stable_node_dup_del(struct stable_node *dup)\n{\n\tVM_BUG_ON(!is_stable_node_dup(dup));\n\thlist_del(&dup->hlist_dup);\n\tksm_stable_node_dups--;\n}"
  },
  {
    "function_name": "stable_node_chain_add_dup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "348-356",
    "snippet": "static inline void stable_node_chain_add_dup(struct stable_node *dup,\n\t\t\t\t\t     struct stable_node *chain)\n{\n\tVM_BUG_ON(is_stable_node_dup(dup));\n\tdup->head = STABLE_NODE_DUP_HEAD;\n\tVM_BUG_ON(!is_stable_node_chain(chain));\n\thlist_add_head(&dup->hlist_dup, &chain->hlist);\n\tksm_stable_node_dups++;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)"
    ],
    "globals_used": [
      "static unsigned long ksm_stable_node_dups;",
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&dup->hlist_dup",
            "&chain->hlist"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!is_stable_node_chain(chain)"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_stable_node_chain",
          "args": [
            "chain"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "is_stable_node_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "338-341",
          "snippet": "static __always_inline bool is_stable_node_chain(struct stable_node *chain)\n{\n\treturn chain->rmap_hlist_len == STABLE_NODE_CHAIN;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_NODE_CHAIN -1024"
          ],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_CHAIN -1024\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic __always_inline bool is_stable_node_chain(struct stable_node *chain)\n{\n\treturn chain->rmap_hlist_len == STABLE_NODE_CHAIN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "is_stable_node_dup(dup)"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_stable_node_dup",
          "args": [
            "dup"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "is_stable_node_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "343-346",
          "snippet": "static __always_inline bool is_stable_node_dup(struct stable_node *dup)\n{\n\treturn dup->head == STABLE_NODE_DUP_HEAD;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)"
          ],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic __always_inline bool is_stable_node_dup(struct stable_node *dup)\n{\n\treturn dup->head == STABLE_NODE_DUP_HEAD;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)\n\nstatic unsigned long ksm_stable_node_dups;\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic inline void stable_node_chain_add_dup(struct stable_node *dup,\n\t\t\t\t\t     struct stable_node *chain)\n{\n\tVM_BUG_ON(is_stable_node_dup(dup));\n\tdup->head = STABLE_NODE_DUP_HEAD;\n\tVM_BUG_ON(!is_stable_node_chain(chain));\n\thlist_add_head(&dup->hlist_dup, &chain->hlist);\n\tksm_stable_node_dups++;\n}"
  },
  {
    "function_name": "is_stable_node_dup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "343-346",
    "snippet": "static __always_inline bool is_stable_node_dup(struct stable_node *dup)\n{\n\treturn dup->head == STABLE_NODE_DUP_HEAD;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)"
    ],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_DUP_HEAD ((struct list_head *)&migrate_nodes.prev)\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic __always_inline bool is_stable_node_dup(struct stable_node *dup)\n{\n\treturn dup->head == STABLE_NODE_DUP_HEAD;\n}"
  },
  {
    "function_name": "is_stable_node_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "338-341",
    "snippet": "static __always_inline bool is_stable_node_chain(struct stable_node *chain)\n{\n\treturn chain->rmap_hlist_len == STABLE_NODE_CHAIN;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define STABLE_NODE_CHAIN -1024"
    ],
    "globals_used": [
      "static __always_inline struct",
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define STABLE_NODE_CHAIN -1024\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nstatic __always_inline bool is_stable_node_chain(struct stable_node *chain)\n{\n\treturn chain->rmap_hlist_len == STABLE_NODE_CHAIN;\n}"
  },
  {
    "function_name": "ksm_slab_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "330-336",
    "snippet": "static void __init ksm_slab_free(void)\n{\n\tkmem_cache_destroy(mm_slot_cache);\n\tkmem_cache_destroy(stable_node_cache);\n\tkmem_cache_destroy(rmap_item_cache);\n\tmm_slot_cache = NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *rmap_item_cache;",
      "static struct kmem_cache *stable_node_cache;",
      "static struct kmem_cache *mm_slot_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "rmap_item_cache"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "874-906",
          "snippet": "void kmem_cache_destroy(struct kmem_cache *s)\n{\n\tint err;\n\n\tif (unlikely(!s))\n\t\treturn;\n\n\tflush_memcg_workqueue(s);\n\n\tget_online_cpus();\n\tget_online_mems();\n\n\tmutex_lock(&slab_mutex);\n\n\ts->refcount--;\n\tif (s->refcount)\n\t\tgoto out_unlock;\n\n\terr = shutdown_memcg_caches(s);\n\tif (!err)\n\t\terr = shutdown_cache(s);\n\n\tif (err) {\n\t\tpr_err(\"kmem_cache_destroy %s: Slab cache still has objects\\n\",\n\t\t       s->name);\n\t\tdump_stack();\n\t}\nout_unlock:\n\tmutex_unlock(&slab_mutex);\n\n\tput_online_mems();\n\tput_online_cpus();\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid kmem_cache_destroy(struct kmem_cache *s)\n{\n\tint err;\n\n\tif (unlikely(!s))\n\t\treturn;\n\n\tflush_memcg_workqueue(s);\n\n\tget_online_cpus();\n\tget_online_mems();\n\n\tmutex_lock(&slab_mutex);\n\n\ts->refcount--;\n\tif (s->refcount)\n\t\tgoto out_unlock;\n\n\terr = shutdown_memcg_caches(s);\n\tif (!err)\n\t\terr = shutdown_cache(s);\n\n\tif (err) {\n\t\tpr_err(\"kmem_cache_destroy %s: Slab cache still has objects\\n\",\n\t\t       s->name);\n\t\tdump_stack();\n\t}\nout_unlock:\n\tmutex_unlock(&slab_mutex);\n\n\tput_online_mems();\n\tput_online_cpus();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct kmem_cache *rmap_item_cache;\nstatic struct kmem_cache *stable_node_cache;\nstatic struct kmem_cache *mm_slot_cache;\n\nstatic void __init ksm_slab_free(void)\n{\n\tkmem_cache_destroy(mm_slot_cache);\n\tkmem_cache_destroy(stable_node_cache);\n\tkmem_cache_destroy(rmap_item_cache);\n\tmm_slot_cache = NULL;\n}"
  },
  {
    "function_name": "ksm_slab_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
    "lines": "306-328",
    "snippet": "static int __init ksm_slab_init(void)\n{\n\trmap_item_cache = KSM_KMEM_CACHE(rmap_item, 0);\n\tif (!rmap_item_cache)\n\t\tgoto out;\n\n\tstable_node_cache = KSM_KMEM_CACHE(stable_node, 0);\n\tif (!stable_node_cache)\n\t\tgoto out_free1;\n\n\tmm_slot_cache = KSM_KMEM_CACHE(mm_slot, 0);\n\tif (!mm_slot_cache)\n\t\tgoto out_free2;\n\n\treturn 0;\n\nout_free2:\n\tkmem_cache_destroy(stable_node_cache);\nout_free1:\n\tkmem_cache_destroy(rmap_item_cache);\nout:\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <linux/numa.h>",
      "#include <linux/oom.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/ksm.h>",
      "#include <linux/swap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/memory.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/jhash.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mman.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *rmap_item_cache;",
      "static struct kmem_cache *stable_node_cache;",
      "static struct kmem_cache *mm_slot_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "rmap_item_cache"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "874-906",
          "snippet": "void kmem_cache_destroy(struct kmem_cache *s)\n{\n\tint err;\n\n\tif (unlikely(!s))\n\t\treturn;\n\n\tflush_memcg_workqueue(s);\n\n\tget_online_cpus();\n\tget_online_mems();\n\n\tmutex_lock(&slab_mutex);\n\n\ts->refcount--;\n\tif (s->refcount)\n\t\tgoto out_unlock;\n\n\terr = shutdown_memcg_caches(s);\n\tif (!err)\n\t\terr = shutdown_cache(s);\n\n\tif (err) {\n\t\tpr_err(\"kmem_cache_destroy %s: Slab cache still has objects\\n\",\n\t\t       s->name);\n\t\tdump_stack();\n\t}\nout_unlock:\n\tmutex_unlock(&slab_mutex);\n\n\tput_online_mems();\n\tput_online_cpus();\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid kmem_cache_destroy(struct kmem_cache *s)\n{\n\tint err;\n\n\tif (unlikely(!s))\n\t\treturn;\n\n\tflush_memcg_workqueue(s);\n\n\tget_online_cpus();\n\tget_online_mems();\n\n\tmutex_lock(&slab_mutex);\n\n\ts->refcount--;\n\tif (s->refcount)\n\t\tgoto out_unlock;\n\n\terr = shutdown_memcg_caches(s);\n\tif (!err)\n\t\terr = shutdown_cache(s);\n\n\tif (err) {\n\t\tpr_err(\"kmem_cache_destroy %s: Slab cache still has objects\\n\",\n\t\t       s->name);\n\t\tdump_stack();\n\t}\nout_unlock:\n\tmutex_unlock(&slab_mutex);\n\n\tput_online_mems();\n\tput_online_cpus();\n}"
        }
      },
      {
        "call_info": {
          "callee": "KSM_KMEM_CACHE",
          "args": [
            "mm_slot",
            "0"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KSM_KMEM_CACHE",
          "args": [
            "stable_node",
            "0"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KSM_KMEM_CACHE",
          "args": [
            "rmap_item",
            "0"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic struct kmem_cache *rmap_item_cache;\nstatic struct kmem_cache *stable_node_cache;\nstatic struct kmem_cache *mm_slot_cache;\n\nstatic int __init ksm_slab_init(void)\n{\n\trmap_item_cache = KSM_KMEM_CACHE(rmap_item, 0);\n\tif (!rmap_item_cache)\n\t\tgoto out;\n\n\tstable_node_cache = KSM_KMEM_CACHE(stable_node, 0);\n\tif (!stable_node_cache)\n\t\tgoto out_free1;\n\n\tmm_slot_cache = KSM_KMEM_CACHE(mm_slot, 0);\n\tif (!mm_slot_cache)\n\t\tgoto out_free2;\n\n\treturn 0;\n\nout_free2:\n\tkmem_cache_destroy(stable_node_cache);\nout_free1:\n\tkmem_cache_destroy(rmap_item_cache);\nout:\n\treturn -ENOMEM;\n}"
  }
]