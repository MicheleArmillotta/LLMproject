[
  {
    "function_name": "pageowner_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
    "lines": "625-638",
    "snippet": "static int __init pageowner_init(void)\n{\n\tstruct dentry *dentry;\n\n\tif (!static_branch_unlikely(&page_owner_inited)) {\n\t\tpr_info(\"page_owner is disabled\\n\");\n\t\treturn 0;\n\t}\n\n\tdentry = debugfs_create_file(\"page_owner\", 0400, NULL,\n\t\t\t\t     NULL, &proc_page_owner_operations);\n\n\treturn PTR_ERR_OR_ZERO(dentry);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/stackdepot.h>",
      "#include <linux/migrate.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations proc_page_owner_operations = {\n\t.read\t\t= read_page_owner,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR_OR_ZERO",
          "args": [
            "dentry"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"page_owner\"",
            "0400",
            "NULL",
            "NULL",
            "&proc_page_owner_operations"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"page_owner is disabled\\n\""
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&page_owner_inited"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstatic const struct file_operations proc_page_owner_operations = {\n\t.read\t\t= read_page_owner,\n};\n\nstatic int __init pageowner_init(void)\n{\n\tstruct dentry *dentry;\n\n\tif (!static_branch_unlikely(&page_owner_inited)) {\n\t\tpr_info(\"page_owner is disabled\\n\");\n\t\treturn 0;\n\t}\n\n\tdentry = debugfs_create_file(\"page_owner\", 0400, NULL,\n\t\t\t\t     NULL, &proc_page_owner_operations);\n\n\treturn PTR_ERR_OR_ZERO(dentry);\n}"
  },
  {
    "function_name": "init_early_allocated_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
    "lines": "613-619",
    "snippet": "static void init_early_allocated_pages(void)\n{\n\tpg_data_t *pgdat;\n\n\tfor_each_online_pgdat(pgdat)\n\t\tinit_zones_in_node(pgdat);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/stackdepot.h>",
      "#include <linux/migrate.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_early_allocated_pages(void);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstatic void init_early_allocated_pages(void);\n\nstatic void init_early_allocated_pages(void)\n{\n\tpg_data_t *pgdat;\n\n\tfor_each_online_pgdat(pgdat)\n\t\tinit_zones_in_node(pgdat);\n}"
  },
  {
    "function_name": "init_zones_in_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
    "lines": "600-611",
    "snippet": "static void init_zones_in_node(pg_data_t *pgdat)\n{\n\tstruct zone *zone;\n\tstruct zone *node_zones = pgdat->node_zones;\n\n\tfor (zone = node_zones; zone - node_zones < MAX_NR_ZONES; ++zone) {\n\t\tif (!populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tinit_pages_in_zone(pgdat, zone);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/stackdepot.h>",
      "#include <linux/migrate.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_pages_in_zone",
          "args": [
            "pgdat",
            "zone"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "init_pages_in_zone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
          "lines": "529-598",
          "snippet": "static void init_pages_in_zone(pg_data_t *pgdat, struct zone *zone)\n{\n\tunsigned long pfn = zone->zone_start_pfn;\n\tunsigned long end_pfn = zone_end_pfn(zone);\n\tunsigned long count = 0;\n\n\t/*\n\t * Walk the zone in pageblock_nr_pages steps. If a page block spans\n\t * a zone boundary, it will be double counted between zones. This does\n\t * not matter as the mixed block count will still be correct\n\t */\n\tfor (; pfn < end_pfn; ) {\n\t\tunsigned long block_end_pfn;\n\n\t\tif (!pfn_valid(pfn)) {\n\t\t\tpfn = ALIGN(pfn + 1, MAX_ORDER_NR_PAGES);\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock_end_pfn = ALIGN(pfn + 1, pageblock_nr_pages);\n\t\tblock_end_pfn = min(block_end_pfn, end_pfn);\n\n\t\tfor (; pfn < block_end_pfn; pfn++) {\n\t\t\tstruct page *page;\n\t\t\tstruct page_ext *page_ext;\n\n\t\t\tif (!pfn_valid_within(pfn))\n\t\t\t\tcontinue;\n\n\t\t\tpage = pfn_to_page(pfn);\n\n\t\t\tif (page_zone(page) != zone)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * To avoid having to grab zone->lock, be a little\n\t\t\t * careful when reading buddy page order. The only\n\t\t\t * danger is that we skip too much and potentially miss\n\t\t\t * some early allocated pages, which is better than\n\t\t\t * heavy lock contention.\n\t\t\t */\n\t\t\tif (PageBuddy(page)) {\n\t\t\t\tunsigned long order = page_order_unsafe(page);\n\n\t\t\t\tif (order > 0 && order < MAX_ORDER)\n\t\t\t\t\tpfn += (1UL << order) - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (PageReserved(page))\n\t\t\t\tcontinue;\n\n\t\t\tpage_ext = lookup_page_ext(page);\n\t\t\tif (unlikely(!page_ext))\n\t\t\t\tcontinue;\n\n\t\t\t/* Maybe overlapping zone */\n\t\t\tif (test_bit(PAGE_EXT_OWNER, &page_ext->flags))\n\t\t\t\tcontinue;\n\n\t\t\t/* Found early allocated page */\n\t\t\t__set_page_owner_handle(page_ext, early_handle, 0, 0);\n\t\t\tcount++;\n\t\t}\n\t\tcond_resched();\n\t}\n\n\tpr_info(\"Node %d, zone %8s: page owner found early allocated %lu pages\\n\",\n\t\tpgdat->node_id, zone->name, count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/migrate.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static depot_stack_handle_t early_handle;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstatic depot_stack_handle_t early_handle;\n\nstatic void init_pages_in_zone(pg_data_t *pgdat, struct zone *zone)\n{\n\tunsigned long pfn = zone->zone_start_pfn;\n\tunsigned long end_pfn = zone_end_pfn(zone);\n\tunsigned long count = 0;\n\n\t/*\n\t * Walk the zone in pageblock_nr_pages steps. If a page block spans\n\t * a zone boundary, it will be double counted between zones. This does\n\t * not matter as the mixed block count will still be correct\n\t */\n\tfor (; pfn < end_pfn; ) {\n\t\tunsigned long block_end_pfn;\n\n\t\tif (!pfn_valid(pfn)) {\n\t\t\tpfn = ALIGN(pfn + 1, MAX_ORDER_NR_PAGES);\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock_end_pfn = ALIGN(pfn + 1, pageblock_nr_pages);\n\t\tblock_end_pfn = min(block_end_pfn, end_pfn);\n\n\t\tfor (; pfn < block_end_pfn; pfn++) {\n\t\t\tstruct page *page;\n\t\t\tstruct page_ext *page_ext;\n\n\t\t\tif (!pfn_valid_within(pfn))\n\t\t\t\tcontinue;\n\n\t\t\tpage = pfn_to_page(pfn);\n\n\t\t\tif (page_zone(page) != zone)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * To avoid having to grab zone->lock, be a little\n\t\t\t * careful when reading buddy page order. The only\n\t\t\t * danger is that we skip too much and potentially miss\n\t\t\t * some early allocated pages, which is better than\n\t\t\t * heavy lock contention.\n\t\t\t */\n\t\t\tif (PageBuddy(page)) {\n\t\t\t\tunsigned long order = page_order_unsafe(page);\n\n\t\t\t\tif (order > 0 && order < MAX_ORDER)\n\t\t\t\t\tpfn += (1UL << order) - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (PageReserved(page))\n\t\t\t\tcontinue;\n\n\t\t\tpage_ext = lookup_page_ext(page);\n\t\t\tif (unlikely(!page_ext))\n\t\t\t\tcontinue;\n\n\t\t\t/* Maybe overlapping zone */\n\t\t\tif (test_bit(PAGE_EXT_OWNER, &page_ext->flags))\n\t\t\t\tcontinue;\n\n\t\t\t/* Found early allocated page */\n\t\t\t__set_page_owner_handle(page_ext, early_handle, 0, 0);\n\t\t\tcount++;\n\t\t}\n\t\tcond_resched();\n\t}\n\n\tpr_info(\"Node %d, zone %8s: page owner found early allocated %lu pages\\n\",\n\t\tpgdat->node_id, zone->name, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "populated_zone",
          "args": [
            "zone"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstatic void init_zones_in_node(pg_data_t *pgdat)\n{\n\tstruct zone *zone;\n\tstruct zone *node_zones = pgdat->node_zones;\n\n\tfor (zone = node_zones; zone - node_zones < MAX_NR_ZONES; ++zone) {\n\t\tif (!populated_zone(zone))\n\t\t\tcontinue;\n\n\t\tinit_pages_in_zone(pgdat, zone);\n\t}\n}"
  },
  {
    "function_name": "init_pages_in_zone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
    "lines": "529-598",
    "snippet": "static void init_pages_in_zone(pg_data_t *pgdat, struct zone *zone)\n{\n\tunsigned long pfn = zone->zone_start_pfn;\n\tunsigned long end_pfn = zone_end_pfn(zone);\n\tunsigned long count = 0;\n\n\t/*\n\t * Walk the zone in pageblock_nr_pages steps. If a page block spans\n\t * a zone boundary, it will be double counted between zones. This does\n\t * not matter as the mixed block count will still be correct\n\t */\n\tfor (; pfn < end_pfn; ) {\n\t\tunsigned long block_end_pfn;\n\n\t\tif (!pfn_valid(pfn)) {\n\t\t\tpfn = ALIGN(pfn + 1, MAX_ORDER_NR_PAGES);\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock_end_pfn = ALIGN(pfn + 1, pageblock_nr_pages);\n\t\tblock_end_pfn = min(block_end_pfn, end_pfn);\n\n\t\tfor (; pfn < block_end_pfn; pfn++) {\n\t\t\tstruct page *page;\n\t\t\tstruct page_ext *page_ext;\n\n\t\t\tif (!pfn_valid_within(pfn))\n\t\t\t\tcontinue;\n\n\t\t\tpage = pfn_to_page(pfn);\n\n\t\t\tif (page_zone(page) != zone)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * To avoid having to grab zone->lock, be a little\n\t\t\t * careful when reading buddy page order. The only\n\t\t\t * danger is that we skip too much and potentially miss\n\t\t\t * some early allocated pages, which is better than\n\t\t\t * heavy lock contention.\n\t\t\t */\n\t\t\tif (PageBuddy(page)) {\n\t\t\t\tunsigned long order = page_order_unsafe(page);\n\n\t\t\t\tif (order > 0 && order < MAX_ORDER)\n\t\t\t\t\tpfn += (1UL << order) - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (PageReserved(page))\n\t\t\t\tcontinue;\n\n\t\t\tpage_ext = lookup_page_ext(page);\n\t\t\tif (unlikely(!page_ext))\n\t\t\t\tcontinue;\n\n\t\t\t/* Maybe overlapping zone */\n\t\t\tif (test_bit(PAGE_EXT_OWNER, &page_ext->flags))\n\t\t\t\tcontinue;\n\n\t\t\t/* Found early allocated page */\n\t\t\t__set_page_owner_handle(page_ext, early_handle, 0, 0);\n\t\t\tcount++;\n\t\t}\n\t\tcond_resched();\n\t}\n\n\tpr_info(\"Node %d, zone %8s: page owner found early allocated %lu pages\\n\",\n\t\tpgdat->node_id, zone->name, count);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/stackdepot.h>",
      "#include <linux/migrate.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static depot_stack_handle_t early_handle;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Node %d, zone %8s: page owner found early allocated %lu pages\\n\"",
            "pgdat->node_id",
            "zone->name",
            "count"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_page_owner_handle",
          "args": [
            "page_ext",
            "early_handle",
            "0",
            "0"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "__set_page_owner_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
          "lines": "172-184",
          "snippet": "static inline void __set_page_owner_handle(struct page_ext *page_ext,\n\tdepot_stack_handle_t handle, unsigned int order, gfp_t gfp_mask)\n{\n\tstruct page_owner *page_owner;\n\n\tpage_owner = get_page_owner(page_ext);\n\tpage_owner->handle = handle;\n\tpage_owner->order = order;\n\tpage_owner->gfp_mask = gfp_mask;\n\tpage_owner->last_migrate_reason = -1;\n\n\t__set_bit(PAGE_EXT_OWNER, &page_ext->flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/migrate.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline depot_stack_handle_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstatic __always_inline depot_stack_handle_t;\n\nstatic inline void __set_page_owner_handle(struct page_ext *page_ext,\n\tdepot_stack_handle_t handle, unsigned int order, gfp_t gfp_mask)\n{\n\tstruct page_owner *page_owner;\n\n\tpage_owner = get_page_owner(page_ext);\n\tpage_owner->handle = handle;\n\tpage_owner->order = order;\n\tpage_owner->gfp_mask = gfp_mask;\n\tpage_owner->last_migrate_reason = -1;\n\n\t__set_bit(PAGE_EXT_OWNER, &page_ext->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "PAGE_EXT_OWNER",
            "&page_ext->flags"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page_ext"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_page_ext",
          "args": [
            "page"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "198-211",
          "snippet": "struct page_ext *lookup_page_ext(const struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct mem_section *section = __pfn_to_section(pfn);\n\t/*\n\t * The sanity checks the page allocator does upon freeing a\n\t * page can reach here before the page_ext arrays are\n\t * allocated when feeding a range of pages to the allocator\n\t * for the first time during bootup or memory hotplug.\n\t */\n\tif (!section->page_ext)\n\t\treturn NULL;\n\treturn get_entry(section->page_ext, pfn);\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstruct page_ext *lookup_page_ext(const struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct mem_section *section = __pfn_to_section(pfn);\n\t/*\n\t * The sanity checks the page allocator does upon freeing a\n\t * page can reach here before the page_ext arrays are\n\t * allocated when feeding a range of pages to the allocator\n\t * for the first time during bootup or memory hotplug.\n\t */\n\tif (!section->page_ext)\n\t\treturn NULL;\n\treturn get_entry(section->page_ext, pfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageReserved",
          "args": [
            "page"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_order_unsafe",
          "args": [
            "page"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageBuddy",
          "args": [
            "page"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid_within",
          "args": [
            "pfn"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "block_end_pfn",
            "end_pfn"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "pfn + 1",
            "pageblock_nr_pages"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "pfn + 1",
            "MAX_ORDER_NR_PAGES"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_end_pfn",
          "args": [
            "zone"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstatic depot_stack_handle_t early_handle;\n\nstatic void init_pages_in_zone(pg_data_t *pgdat, struct zone *zone)\n{\n\tunsigned long pfn = zone->zone_start_pfn;\n\tunsigned long end_pfn = zone_end_pfn(zone);\n\tunsigned long count = 0;\n\n\t/*\n\t * Walk the zone in pageblock_nr_pages steps. If a page block spans\n\t * a zone boundary, it will be double counted between zones. This does\n\t * not matter as the mixed block count will still be correct\n\t */\n\tfor (; pfn < end_pfn; ) {\n\t\tunsigned long block_end_pfn;\n\n\t\tif (!pfn_valid(pfn)) {\n\t\t\tpfn = ALIGN(pfn + 1, MAX_ORDER_NR_PAGES);\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock_end_pfn = ALIGN(pfn + 1, pageblock_nr_pages);\n\t\tblock_end_pfn = min(block_end_pfn, end_pfn);\n\n\t\tfor (; pfn < block_end_pfn; pfn++) {\n\t\t\tstruct page *page;\n\t\t\tstruct page_ext *page_ext;\n\n\t\t\tif (!pfn_valid_within(pfn))\n\t\t\t\tcontinue;\n\n\t\t\tpage = pfn_to_page(pfn);\n\n\t\t\tif (page_zone(page) != zone)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * To avoid having to grab zone->lock, be a little\n\t\t\t * careful when reading buddy page order. The only\n\t\t\t * danger is that we skip too much and potentially miss\n\t\t\t * some early allocated pages, which is better than\n\t\t\t * heavy lock contention.\n\t\t\t */\n\t\t\tif (PageBuddy(page)) {\n\t\t\t\tunsigned long order = page_order_unsafe(page);\n\n\t\t\t\tif (order > 0 && order < MAX_ORDER)\n\t\t\t\t\tpfn += (1UL << order) - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (PageReserved(page))\n\t\t\t\tcontinue;\n\n\t\t\tpage_ext = lookup_page_ext(page);\n\t\t\tif (unlikely(!page_ext))\n\t\t\t\tcontinue;\n\n\t\t\t/* Maybe overlapping zone */\n\t\t\tif (test_bit(PAGE_EXT_OWNER, &page_ext->flags))\n\t\t\t\tcontinue;\n\n\t\t\t/* Found early allocated page */\n\t\t\t__set_page_owner_handle(page_ext, early_handle, 0, 0);\n\t\t\tcount++;\n\t\t}\n\t\tcond_resched();\n\t}\n\n\tpr_info(\"Node %d, zone %8s: page owner found early allocated %lu pages\\n\",\n\t\tpgdat->node_id, zone->name, count);\n}"
  },
  {
    "function_name": "read_page_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
    "lines": "453-527",
    "snippet": "static ssize_t\nread_page_owner(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tunsigned long pfn;\n\tstruct page *page;\n\tstruct page_ext *page_ext;\n\tstruct page_owner *page_owner;\n\tdepot_stack_handle_t handle;\n\n\tif (!static_branch_unlikely(&page_owner_inited))\n\t\treturn -EINVAL;\n\n\tpage = NULL;\n\tpfn = min_low_pfn + *ppos;\n\n\t/* Find a valid PFN or the start of a MAX_ORDER_NR_PAGES area */\n\twhile (!pfn_valid(pfn) && (pfn & (MAX_ORDER_NR_PAGES - 1)) != 0)\n\t\tpfn++;\n\n\tdrain_all_pages(NULL);\n\n\t/* Find an allocated page */\n\tfor (; pfn < max_pfn; pfn++) {\n\t\t/*\n\t\t * If the new page is in a new MAX_ORDER_NR_PAGES area,\n\t\t * validate the area as existing, skip it if not\n\t\t */\n\t\tif ((pfn & (MAX_ORDER_NR_PAGES - 1)) == 0 && !pfn_valid(pfn)) {\n\t\t\tpfn += MAX_ORDER_NR_PAGES - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Check for holes within a MAX_ORDER area */\n\t\tif (!pfn_valid_within(pfn))\n\t\t\tcontinue;\n\n\t\tpage = pfn_to_page(pfn);\n\t\tif (PageBuddy(page)) {\n\t\t\tunsigned long freepage_order = page_order_unsafe(page);\n\n\t\t\tif (freepage_order < MAX_ORDER)\n\t\t\t\tpfn += (1UL << freepage_order) - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage_ext = lookup_page_ext(page);\n\t\tif (unlikely(!page_ext))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Some pages could be missed by concurrent allocation or free,\n\t\t * because we don't hold the zone lock.\n\t\t */\n\t\tif (!test_bit(PAGE_EXT_OWNER, &page_ext->flags))\n\t\t\tcontinue;\n\n\t\tpage_owner = get_page_owner(page_ext);\n\n\t\t/*\n\t\t * Access to page_ext->handle isn't synchronous so we should\n\t\t * be careful to access it.\n\t\t */\n\t\thandle = READ_ONCE(page_owner->handle);\n\t\tif (!handle)\n\t\t\tcontinue;\n\n\t\t/* Record the next PFN to read in the file offset */\n\t\t*ppos = (pfn - min_low_pfn) + 1;\n\n\t\treturn print_page_owner(buf, count, pfn, page,\n\t\t\t\tpage_owner, handle);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/stackdepot.h>",
      "#include <linux/migrate.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline depot_stack_handle_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_page_owner",
          "args": [
            "buf",
            "count",
            "pfn",
            "page",
            "page_owner",
            "handle"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "print_page_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
          "lines": "338-406",
          "snippet": "static ssize_t\nprint_page_owner(char __user *buf, size_t count, unsigned long pfn,\n\t\tstruct page *page, struct page_owner *page_owner,\n\t\tdepot_stack_handle_t handle)\n{\n\tint ret;\n\tint pageblock_mt, page_mt;\n\tchar *kbuf;\n\tunsigned long entries[PAGE_OWNER_STACK_DEPTH];\n\tstruct stack_trace trace = {\n\t\t.nr_entries = 0,\n\t\t.entries = entries,\n\t\t.max_entries = PAGE_OWNER_STACK_DEPTH,\n\t\t.skip = 0\n\t};\n\n\tkbuf = kmalloc(count, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tret = snprintf(kbuf, count,\n\t\t\t\"Page allocated via order %u, mask %#x(%pGg)\\n\",\n\t\t\tpage_owner->order, page_owner->gfp_mask,\n\t\t\t&page_owner->gfp_mask);\n\n\tif (ret >= count)\n\t\tgoto err;\n\n\t/* Print information relevant to grouping pages by mobility */\n\tpageblock_mt = get_pageblock_migratetype(page);\n\tpage_mt  = gfpflags_to_migratetype(page_owner->gfp_mask);\n\tret += snprintf(kbuf + ret, count - ret,\n\t\t\t\"PFN %lu type %s Block %lu type %s Flags %#lx(%pGp)\\n\",\n\t\t\tpfn,\n\t\t\tmigratetype_names[page_mt],\n\t\t\tpfn >> pageblock_order,\n\t\t\tmigratetype_names[pageblock_mt],\n\t\t\tpage->flags, &page->flags);\n\n\tif (ret >= count)\n\t\tgoto err;\n\n\tdepot_fetch_stack(handle, &trace);\n\tret += snprint_stack_trace(kbuf + ret, count - ret, &trace, 0);\n\tif (ret >= count)\n\t\tgoto err;\n\n\tif (page_owner->last_migrate_reason != -1) {\n\t\tret += snprintf(kbuf + ret, count - ret,\n\t\t\t\"Page has been migrated, last migrate reason: %s\\n\",\n\t\t\tmigrate_reason_names[page_owner->last_migrate_reason]);\n\t\tif (ret >= count)\n\t\t\tgoto err;\n\t}\n\n\tret += snprintf(kbuf + ret, count - ret, \"\\n\");\n\tif (ret >= count)\n\t\tgoto err;\n\n\tif (copy_to_user(buf, kbuf, ret))\n\t\tret = -EFAULT;\n\n\tkfree(kbuf);\n\treturn ret;\n\nerr:\n\tkfree(kbuf);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/migrate.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [
            "#define PAGE_OWNER_STACK_DEPTH (16)"
          ],
          "globals_used": [
            "static __always_inline depot_stack_handle_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\n#define PAGE_OWNER_STACK_DEPTH (16)\n\nstatic __always_inline depot_stack_handle_t;\n\nstatic ssize_t\nprint_page_owner(char __user *buf, size_t count, unsigned long pfn,\n\t\tstruct page *page, struct page_owner *page_owner,\n\t\tdepot_stack_handle_t handle)\n{\n\tint ret;\n\tint pageblock_mt, page_mt;\n\tchar *kbuf;\n\tunsigned long entries[PAGE_OWNER_STACK_DEPTH];\n\tstruct stack_trace trace = {\n\t\t.nr_entries = 0,\n\t\t.entries = entries,\n\t\t.max_entries = PAGE_OWNER_STACK_DEPTH,\n\t\t.skip = 0\n\t};\n\n\tkbuf = kmalloc(count, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tret = snprintf(kbuf, count,\n\t\t\t\"Page allocated via order %u, mask %#x(%pGg)\\n\",\n\t\t\tpage_owner->order, page_owner->gfp_mask,\n\t\t\t&page_owner->gfp_mask);\n\n\tif (ret >= count)\n\t\tgoto err;\n\n\t/* Print information relevant to grouping pages by mobility */\n\tpageblock_mt = get_pageblock_migratetype(page);\n\tpage_mt  = gfpflags_to_migratetype(page_owner->gfp_mask);\n\tret += snprintf(kbuf + ret, count - ret,\n\t\t\t\"PFN %lu type %s Block %lu type %s Flags %#lx(%pGp)\\n\",\n\t\t\tpfn,\n\t\t\tmigratetype_names[page_mt],\n\t\t\tpfn >> pageblock_order,\n\t\t\tmigratetype_names[pageblock_mt],\n\t\t\tpage->flags, &page->flags);\n\n\tif (ret >= count)\n\t\tgoto err;\n\n\tdepot_fetch_stack(handle, &trace);\n\tret += snprint_stack_trace(kbuf + ret, count - ret, &trace, 0);\n\tif (ret >= count)\n\t\tgoto err;\n\n\tif (page_owner->last_migrate_reason != -1) {\n\t\tret += snprintf(kbuf + ret, count - ret,\n\t\t\t\"Page has been migrated, last migrate reason: %s\\n\",\n\t\t\tmigrate_reason_names[page_owner->last_migrate_reason]);\n\t\tif (ret >= count)\n\t\t\tgoto err;\n\t}\n\n\tret += snprintf(kbuf + ret, count - ret, \"\\n\");\n\tif (ret >= count)\n\t\tgoto err;\n\n\tif (copy_to_user(buf, kbuf, ret))\n\t\tret = -EFAULT;\n\n\tkfree(kbuf);\n\treturn ret;\n\nerr:\n\tkfree(kbuf);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "page_owner->handle"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page_owner",
          "args": [
            "page_ext"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "get_page_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
          "lines": "105-108",
          "snippet": "static inline struct page_owner *get_page_owner(struct page_ext *page_ext)\n{\n\treturn (void *)page_ext + page_owner_ops.offset;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/migrate.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct page_ext_operations page_owner_ops = {\n\t.size = sizeof(struct page_owner),\n\t.need = need_page_owner,\n\t.init = init_page_owner,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstruct page_ext_operations page_owner_ops = {\n\t.size = sizeof(struct page_owner),\n\t.need = need_page_owner,\n\t.init = init_page_owner,\n};\n\nstatic inline struct page_owner *get_page_owner(struct page_ext *page_ext)\n{\n\treturn (void *)page_ext + page_owner_ops.offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "PAGE_EXT_OWNER",
            "&page_ext->flags"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page_ext"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_page_ext",
          "args": [
            "page"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "198-211",
          "snippet": "struct page_ext *lookup_page_ext(const struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct mem_section *section = __pfn_to_section(pfn);\n\t/*\n\t * The sanity checks the page allocator does upon freeing a\n\t * page can reach here before the page_ext arrays are\n\t * allocated when feeding a range of pages to the allocator\n\t * for the first time during bootup or memory hotplug.\n\t */\n\tif (!section->page_ext)\n\t\treturn NULL;\n\treturn get_entry(section->page_ext, pfn);\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstruct page_ext *lookup_page_ext(const struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct mem_section *section = __pfn_to_section(pfn);\n\t/*\n\t * The sanity checks the page allocator does upon freeing a\n\t * page can reach here before the page_ext arrays are\n\t * allocated when feeding a range of pages to the allocator\n\t * for the first time during bootup or memory hotplug.\n\t */\n\tif (!section->page_ext)\n\t\treturn NULL;\n\treturn get_entry(section->page_ext, pfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_order_unsafe",
          "args": [
            "page"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageBuddy",
          "args": [
            "page"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid_within",
          "args": [
            "pfn"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drain_all_pages",
          "args": [
            "NULL"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "drain_all_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2614-2682",
          "snippet": "void drain_all_pages(struct zone *zone)\n{\n\tint cpu;\n\n\t/*\n\t * Allocate in the BSS so we wont require allocation in\n\t * direct reclaim path for CONFIG_CPUMASK_OFFSTACK=y\n\t */\n\tstatic cpumask_t cpus_with_pcps;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON_ONCE(!mm_percpu_wq))\n\t\treturn;\n\n\t/*\n\t * Do not drain if one is already in progress unless it's specific to\n\t * a zone. Such callers are primarily CMA and memory hotplug and need\n\t * the drain to be complete when the call returns.\n\t */\n\tif (unlikely(!mutex_trylock(&pcpu_drain_mutex))) {\n\t\tif (!zone)\n\t\t\treturn;\n\t\tmutex_lock(&pcpu_drain_mutex);\n\t}\n\n\t/*\n\t * We don't care about racing with CPU hotplug event\n\t * as offline notification will cause the notified\n\t * cpu to drain that CPU pcps and on_each_cpu_mask\n\t * disables preemption as part of its processing\n\t */\n\tfor_each_online_cpu(cpu) {\n\t\tstruct per_cpu_pageset *pcp;\n\t\tstruct zone *z;\n\t\tbool has_pcps = false;\n\n\t\tif (zone) {\n\t\t\tpcp = per_cpu_ptr(zone->pageset, cpu);\n\t\t\tif (pcp->pcp.count)\n\t\t\t\thas_pcps = true;\n\t\t} else {\n\t\t\tfor_each_populated_zone(z) {\n\t\t\t\tpcp = per_cpu_ptr(z->pageset, cpu);\n\t\t\t\tif (pcp->pcp.count) {\n\t\t\t\t\thas_pcps = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (has_pcps)\n\t\t\tcpumask_set_cpu(cpu, &cpus_with_pcps);\n\t\telse\n\t\t\tcpumask_clear_cpu(cpu, &cpus_with_pcps);\n\t}\n\n\tfor_each_cpu(cpu, &cpus_with_pcps) {\n\t\tstruct work_struct *work = per_cpu_ptr(&pcpu_drain, cpu);\n\t\tINIT_WORK(work, drain_local_pages_wq);\n\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t}\n\tfor_each_cpu(cpu, &cpus_with_pcps)\n\t\tflush_work(per_cpu_ptr(&pcpu_drain, cpu));\n\n\tmutex_unlock(&pcpu_drain_mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid drain_all_pages(struct zone *zone)\n{\n\tint cpu;\n\n\t/*\n\t * Allocate in the BSS so we wont require allocation in\n\t * direct reclaim path for CONFIG_CPUMASK_OFFSTACK=y\n\t */\n\tstatic cpumask_t cpus_with_pcps;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON_ONCE(!mm_percpu_wq))\n\t\treturn;\n\n\t/*\n\t * Do not drain if one is already in progress unless it's specific to\n\t * a zone. Such callers are primarily CMA and memory hotplug and need\n\t * the drain to be complete when the call returns.\n\t */\n\tif (unlikely(!mutex_trylock(&pcpu_drain_mutex))) {\n\t\tif (!zone)\n\t\t\treturn;\n\t\tmutex_lock(&pcpu_drain_mutex);\n\t}\n\n\t/*\n\t * We don't care about racing with CPU hotplug event\n\t * as offline notification will cause the notified\n\t * cpu to drain that CPU pcps and on_each_cpu_mask\n\t * disables preemption as part of its processing\n\t */\n\tfor_each_online_cpu(cpu) {\n\t\tstruct per_cpu_pageset *pcp;\n\t\tstruct zone *z;\n\t\tbool has_pcps = false;\n\n\t\tif (zone) {\n\t\t\tpcp = per_cpu_ptr(zone->pageset, cpu);\n\t\t\tif (pcp->pcp.count)\n\t\t\t\thas_pcps = true;\n\t\t} else {\n\t\t\tfor_each_populated_zone(z) {\n\t\t\t\tpcp = per_cpu_ptr(z->pageset, cpu);\n\t\t\t\tif (pcp->pcp.count) {\n\t\t\t\t\thas_pcps = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (has_pcps)\n\t\t\tcpumask_set_cpu(cpu, &cpus_with_pcps);\n\t\telse\n\t\t\tcpumask_clear_cpu(cpu, &cpus_with_pcps);\n\t}\n\n\tfor_each_cpu(cpu, &cpus_with_pcps) {\n\t\tstruct work_struct *work = per_cpu_ptr(&pcpu_drain, cpu);\n\t\tINIT_WORK(work, drain_local_pages_wq);\n\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t}\n\tfor_each_cpu(cpu, &cpus_with_pcps)\n\t\tflush_work(per_cpu_ptr(&pcpu_drain, cpu));\n\n\tmutex_unlock(&pcpu_drain_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&page_owner_inited"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstatic __always_inline depot_stack_handle_t;\n\nstatic ssize_t\nread_page_owner(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tunsigned long pfn;\n\tstruct page *page;\n\tstruct page_ext *page_ext;\n\tstruct page_owner *page_owner;\n\tdepot_stack_handle_t handle;\n\n\tif (!static_branch_unlikely(&page_owner_inited))\n\t\treturn -EINVAL;\n\n\tpage = NULL;\n\tpfn = min_low_pfn + *ppos;\n\n\t/* Find a valid PFN or the start of a MAX_ORDER_NR_PAGES area */\n\twhile (!pfn_valid(pfn) && (pfn & (MAX_ORDER_NR_PAGES - 1)) != 0)\n\t\tpfn++;\n\n\tdrain_all_pages(NULL);\n\n\t/* Find an allocated page */\n\tfor (; pfn < max_pfn; pfn++) {\n\t\t/*\n\t\t * If the new page is in a new MAX_ORDER_NR_PAGES area,\n\t\t * validate the area as existing, skip it if not\n\t\t */\n\t\tif ((pfn & (MAX_ORDER_NR_PAGES - 1)) == 0 && !pfn_valid(pfn)) {\n\t\t\tpfn += MAX_ORDER_NR_PAGES - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Check for holes within a MAX_ORDER area */\n\t\tif (!pfn_valid_within(pfn))\n\t\t\tcontinue;\n\n\t\tpage = pfn_to_page(pfn);\n\t\tif (PageBuddy(page)) {\n\t\t\tunsigned long freepage_order = page_order_unsafe(page);\n\n\t\t\tif (freepage_order < MAX_ORDER)\n\t\t\t\tpfn += (1UL << freepage_order) - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage_ext = lookup_page_ext(page);\n\t\tif (unlikely(!page_ext))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Some pages could be missed by concurrent allocation or free,\n\t\t * because we don't hold the zone lock.\n\t\t */\n\t\tif (!test_bit(PAGE_EXT_OWNER, &page_ext->flags))\n\t\t\tcontinue;\n\n\t\tpage_owner = get_page_owner(page_ext);\n\n\t\t/*\n\t\t * Access to page_ext->handle isn't synchronous so we should\n\t\t * be careful to access it.\n\t\t */\n\t\thandle = READ_ONCE(page_owner->handle);\n\t\tif (!handle)\n\t\t\tcontinue;\n\n\t\t/* Record the next PFN to read in the file offset */\n\t\t*ppos = (pfn - min_low_pfn) + 1;\n\n\t\treturn print_page_owner(buf, count, pfn, page,\n\t\t\t\tpage_owner, handle);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__dump_page_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
    "lines": "408-451",
    "snippet": "void __dump_page_owner(struct page *page)\n{\n\tstruct page_ext *page_ext = lookup_page_ext(page);\n\tstruct page_owner *page_owner;\n\tunsigned long entries[PAGE_OWNER_STACK_DEPTH];\n\tstruct stack_trace trace = {\n\t\t.nr_entries = 0,\n\t\t.entries = entries,\n\t\t.max_entries = PAGE_OWNER_STACK_DEPTH,\n\t\t.skip = 0\n\t};\n\tdepot_stack_handle_t handle;\n\tgfp_t gfp_mask;\n\tint mt;\n\n\tif (unlikely(!page_ext)) {\n\t\tpr_alert(\"There is not page extension available.\\n\");\n\t\treturn;\n\t}\n\n\tpage_owner = get_page_owner(page_ext);\n\tgfp_mask = page_owner->gfp_mask;\n\tmt = gfpflags_to_migratetype(gfp_mask);\n\n\tif (!test_bit(PAGE_EXT_OWNER, &page_ext->flags)) {\n\t\tpr_alert(\"page_owner info is not active (free page?)\\n\");\n\t\treturn;\n\t}\n\n\thandle = READ_ONCE(page_owner->handle);\n\tif (!handle) {\n\t\tpr_alert(\"page_owner info is not active (free page?)\\n\");\n\t\treturn;\n\t}\n\n\tdepot_fetch_stack(handle, &trace);\n\tpr_alert(\"page allocated via order %u, migratetype %s, gfp_mask %#x(%pGg)\\n\",\n\t\t page_owner->order, migratetype_names[mt], gfp_mask, &gfp_mask);\n\tprint_stack_trace(&trace, 0);\n\n\tif (page_owner->last_migrate_reason != -1)\n\t\tpr_alert(\"page has been migrated, last migrate reason: %s\\n\",\n\t\t\tmigrate_reason_names[page_owner->last_migrate_reason]);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/stackdepot.h>",
      "#include <linux/migrate.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [
      "#define PAGE_OWNER_STACK_DEPTH (16)"
    ],
    "globals_used": [
      "static __always_inline depot_stack_handle_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"page has been migrated, last migrate reason: %s\\n\"",
            "migrate_reason_names[page_owner->last_migrate_reason]"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_stack_trace",
          "args": [
            "&trace",
            "0"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"page allocated via order %u, migratetype %s, gfp_mask %#x(%pGg)\\n\"",
            "page_owner->order",
            "migratetype_names[mt]",
            "gfp_mask",
            "&gfp_mask"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "depot_fetch_stack",
          "args": [
            "handle",
            "&trace"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"page_owner info is not active (free page?)\\n\""
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "page_owner->handle"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"page_owner info is not active (free page?)\\n\""
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "PAGE_EXT_OWNER",
            "&page_ext->flags"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfpflags_to_migratetype",
          "args": [
            "gfp_mask"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page_owner",
          "args": [
            "page_ext"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "get_page_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
          "lines": "105-108",
          "snippet": "static inline struct page_owner *get_page_owner(struct page_ext *page_ext)\n{\n\treturn (void *)page_ext + page_owner_ops.offset;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/migrate.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct page_ext_operations page_owner_ops = {\n\t.size = sizeof(struct page_owner),\n\t.need = need_page_owner,\n\t.init = init_page_owner,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstruct page_ext_operations page_owner_ops = {\n\t.size = sizeof(struct page_owner),\n\t.need = need_page_owner,\n\t.init = init_page_owner,\n};\n\nstatic inline struct page_owner *get_page_owner(struct page_ext *page_ext)\n{\n\treturn (void *)page_ext + page_owner_ops.offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"There is not page extension available.\\n\""
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page_ext"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_page_ext",
          "args": [
            "page"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "198-211",
          "snippet": "struct page_ext *lookup_page_ext(const struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct mem_section *section = __pfn_to_section(pfn);\n\t/*\n\t * The sanity checks the page allocator does upon freeing a\n\t * page can reach here before the page_ext arrays are\n\t * allocated when feeding a range of pages to the allocator\n\t * for the first time during bootup or memory hotplug.\n\t */\n\tif (!section->page_ext)\n\t\treturn NULL;\n\treturn get_entry(section->page_ext, pfn);\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstruct page_ext *lookup_page_ext(const struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct mem_section *section = __pfn_to_section(pfn);\n\t/*\n\t * The sanity checks the page allocator does upon freeing a\n\t * page can reach here before the page_ext arrays are\n\t * allocated when feeding a range of pages to the allocator\n\t * for the first time during bootup or memory hotplug.\n\t */\n\tif (!section->page_ext)\n\t\treturn NULL;\n\treturn get_entry(section->page_ext, pfn);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\n#define PAGE_OWNER_STACK_DEPTH (16)\n\nstatic __always_inline depot_stack_handle_t;\n\nvoid __dump_page_owner(struct page *page)\n{\n\tstruct page_ext *page_ext = lookup_page_ext(page);\n\tstruct page_owner *page_owner;\n\tunsigned long entries[PAGE_OWNER_STACK_DEPTH];\n\tstruct stack_trace trace = {\n\t\t.nr_entries = 0,\n\t\t.entries = entries,\n\t\t.max_entries = PAGE_OWNER_STACK_DEPTH,\n\t\t.skip = 0\n\t};\n\tdepot_stack_handle_t handle;\n\tgfp_t gfp_mask;\n\tint mt;\n\n\tif (unlikely(!page_ext)) {\n\t\tpr_alert(\"There is not page extension available.\\n\");\n\t\treturn;\n\t}\n\n\tpage_owner = get_page_owner(page_ext);\n\tgfp_mask = page_owner->gfp_mask;\n\tmt = gfpflags_to_migratetype(gfp_mask);\n\n\tif (!test_bit(PAGE_EXT_OWNER, &page_ext->flags)) {\n\t\tpr_alert(\"page_owner info is not active (free page?)\\n\");\n\t\treturn;\n\t}\n\n\thandle = READ_ONCE(page_owner->handle);\n\tif (!handle) {\n\t\tpr_alert(\"page_owner info is not active (free page?)\\n\");\n\t\treturn;\n\t}\n\n\tdepot_fetch_stack(handle, &trace);\n\tpr_alert(\"page allocated via order %u, migratetype %s, gfp_mask %#x(%pGg)\\n\",\n\t\t page_owner->order, migratetype_names[mt], gfp_mask, &gfp_mask);\n\tprint_stack_trace(&trace, 0);\n\n\tif (page_owner->last_migrate_reason != -1)\n\t\tpr_alert(\"page has been migrated, last migrate reason: %s\\n\",\n\t\t\tmigrate_reason_names[page_owner->last_migrate_reason]);\n}"
  },
  {
    "function_name": "print_page_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
    "lines": "338-406",
    "snippet": "static ssize_t\nprint_page_owner(char __user *buf, size_t count, unsigned long pfn,\n\t\tstruct page *page, struct page_owner *page_owner,\n\t\tdepot_stack_handle_t handle)\n{\n\tint ret;\n\tint pageblock_mt, page_mt;\n\tchar *kbuf;\n\tunsigned long entries[PAGE_OWNER_STACK_DEPTH];\n\tstruct stack_trace trace = {\n\t\t.nr_entries = 0,\n\t\t.entries = entries,\n\t\t.max_entries = PAGE_OWNER_STACK_DEPTH,\n\t\t.skip = 0\n\t};\n\n\tkbuf = kmalloc(count, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tret = snprintf(kbuf, count,\n\t\t\t\"Page allocated via order %u, mask %#x(%pGg)\\n\",\n\t\t\tpage_owner->order, page_owner->gfp_mask,\n\t\t\t&page_owner->gfp_mask);\n\n\tif (ret >= count)\n\t\tgoto err;\n\n\t/* Print information relevant to grouping pages by mobility */\n\tpageblock_mt = get_pageblock_migratetype(page);\n\tpage_mt  = gfpflags_to_migratetype(page_owner->gfp_mask);\n\tret += snprintf(kbuf + ret, count - ret,\n\t\t\t\"PFN %lu type %s Block %lu type %s Flags %#lx(%pGp)\\n\",\n\t\t\tpfn,\n\t\t\tmigratetype_names[page_mt],\n\t\t\tpfn >> pageblock_order,\n\t\t\tmigratetype_names[pageblock_mt],\n\t\t\tpage->flags, &page->flags);\n\n\tif (ret >= count)\n\t\tgoto err;\n\n\tdepot_fetch_stack(handle, &trace);\n\tret += snprint_stack_trace(kbuf + ret, count - ret, &trace, 0);\n\tif (ret >= count)\n\t\tgoto err;\n\n\tif (page_owner->last_migrate_reason != -1) {\n\t\tret += snprintf(kbuf + ret, count - ret,\n\t\t\t\"Page has been migrated, last migrate reason: %s\\n\",\n\t\t\tmigrate_reason_names[page_owner->last_migrate_reason]);\n\t\tif (ret >= count)\n\t\t\tgoto err;\n\t}\n\n\tret += snprintf(kbuf + ret, count - ret, \"\\n\");\n\tif (ret >= count)\n\t\tgoto err;\n\n\tif (copy_to_user(buf, kbuf, ret))\n\t\tret = -EFAULT;\n\n\tkfree(kbuf);\n\treturn ret;\n\nerr:\n\tkfree(kbuf);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/stackdepot.h>",
      "#include <linux/migrate.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [
      "#define PAGE_OWNER_STACK_DEPTH (16)"
    ],
    "globals_used": [
      "static __always_inline depot_stack_handle_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "kbuf"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf",
            "kbuf",
            "ret"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "kbuf + ret",
            "count - ret",
            "\"\\n\""
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "kbuf + ret",
            "count - ret",
            "\"Page has been migrated, last migrate reason: %s\\n\"",
            "migrate_reason_names[page_owner->last_migrate_reason]"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprint_stack_trace",
          "args": [
            "kbuf + ret",
            "count - ret",
            "&trace",
            "0"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "depot_fetch_stack",
          "args": [
            "handle",
            "&trace"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "kbuf + ret",
            "count - ret",
            "\"PFN %lu type %s Block %lu type %s Flags %#lx(%pGp)\\n\"",
            "pfn",
            "migratetype_names[page_mt]",
            "pfn >> pageblock_order",
            "migratetype_names[pageblock_mt]",
            "page->flags",
            "&page->flags"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfpflags_to_migratetype",
          "args": [
            "page_owner->gfp_mask"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pageblock_migratetype",
          "args": [
            "page"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "kbuf",
            "count",
            "\"Page allocated via order %u, mask %#x(%pGg)\\n\"",
            "page_owner->order",
            "page_owner->gfp_mask",
            "&page_owner->gfp_mask"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "count",
            "GFP_KERNEL"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3729-3732",
          "snippet": "void *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\n#define PAGE_OWNER_STACK_DEPTH (16)\n\nstatic __always_inline depot_stack_handle_t;\n\nstatic ssize_t\nprint_page_owner(char __user *buf, size_t count, unsigned long pfn,\n\t\tstruct page *page, struct page_owner *page_owner,\n\t\tdepot_stack_handle_t handle)\n{\n\tint ret;\n\tint pageblock_mt, page_mt;\n\tchar *kbuf;\n\tunsigned long entries[PAGE_OWNER_STACK_DEPTH];\n\tstruct stack_trace trace = {\n\t\t.nr_entries = 0,\n\t\t.entries = entries,\n\t\t.max_entries = PAGE_OWNER_STACK_DEPTH,\n\t\t.skip = 0\n\t};\n\n\tkbuf = kmalloc(count, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tret = snprintf(kbuf, count,\n\t\t\t\"Page allocated via order %u, mask %#x(%pGg)\\n\",\n\t\t\tpage_owner->order, page_owner->gfp_mask,\n\t\t\t&page_owner->gfp_mask);\n\n\tif (ret >= count)\n\t\tgoto err;\n\n\t/* Print information relevant to grouping pages by mobility */\n\tpageblock_mt = get_pageblock_migratetype(page);\n\tpage_mt  = gfpflags_to_migratetype(page_owner->gfp_mask);\n\tret += snprintf(kbuf + ret, count - ret,\n\t\t\t\"PFN %lu type %s Block %lu type %s Flags %#lx(%pGp)\\n\",\n\t\t\tpfn,\n\t\t\tmigratetype_names[page_mt],\n\t\t\tpfn >> pageblock_order,\n\t\t\tmigratetype_names[pageblock_mt],\n\t\t\tpage->flags, &page->flags);\n\n\tif (ret >= count)\n\t\tgoto err;\n\n\tdepot_fetch_stack(handle, &trace);\n\tret += snprint_stack_trace(kbuf + ret, count - ret, &trace, 0);\n\tif (ret >= count)\n\t\tgoto err;\n\n\tif (page_owner->last_migrate_reason != -1) {\n\t\tret += snprintf(kbuf + ret, count - ret,\n\t\t\t\"Page has been migrated, last migrate reason: %s\\n\",\n\t\t\tmigrate_reason_names[page_owner->last_migrate_reason]);\n\t\tif (ret >= count)\n\t\t\tgoto err;\n\t}\n\n\tret += snprintf(kbuf + ret, count - ret, \"\\n\");\n\tif (ret >= count)\n\t\tgoto err;\n\n\tif (copy_to_user(buf, kbuf, ret))\n\t\tret = -EFAULT;\n\n\tkfree(kbuf);\n\treturn ret;\n\nerr:\n\tkfree(kbuf);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "pagetypeinfo_showmixedcount_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
    "lines": "255-336",
    "snippet": "void pagetypeinfo_showmixedcount_print(struct seq_file *m,\n\t\t\t\t       pg_data_t *pgdat, struct zone *zone)\n{\n\tstruct page *page;\n\tstruct page_ext *page_ext;\n\tstruct page_owner *page_owner;\n\tunsigned long pfn = zone->zone_start_pfn, block_end_pfn;\n\tunsigned long end_pfn = pfn + zone->spanned_pages;\n\tunsigned long count[MIGRATE_TYPES] = { 0, };\n\tint pageblock_mt, page_mt;\n\tint i;\n\n\t/* Scan block by block. First and last block may be incomplete */\n\tpfn = zone->zone_start_pfn;\n\n\t/*\n\t * Walk the zone in pageblock_nr_pages steps. If a page block spans\n\t * a zone boundary, it will be double counted between zones. This does\n\t * not matter as the mixed block count will still be correct\n\t */\n\tfor (; pfn < end_pfn; ) {\n\t\tif (!pfn_valid(pfn)) {\n\t\t\tpfn = ALIGN(pfn + 1, MAX_ORDER_NR_PAGES);\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock_end_pfn = ALIGN(pfn + 1, pageblock_nr_pages);\n\t\tblock_end_pfn = min(block_end_pfn, end_pfn);\n\n\t\tpage = pfn_to_page(pfn);\n\t\tpageblock_mt = get_pageblock_migratetype(page);\n\n\t\tfor (; pfn < block_end_pfn; pfn++) {\n\t\t\tif (!pfn_valid_within(pfn))\n\t\t\t\tcontinue;\n\n\t\t\tpage = pfn_to_page(pfn);\n\n\t\t\tif (page_zone(page) != zone)\n\t\t\t\tcontinue;\n\n\t\t\tif (PageBuddy(page)) {\n\t\t\t\tunsigned long freepage_order;\n\n\t\t\t\tfreepage_order = page_order_unsafe(page);\n\t\t\t\tif (freepage_order < MAX_ORDER)\n\t\t\t\t\tpfn += (1UL << freepage_order) - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (PageReserved(page))\n\t\t\t\tcontinue;\n\n\t\t\tpage_ext = lookup_page_ext(page);\n\t\t\tif (unlikely(!page_ext))\n\t\t\t\tcontinue;\n\n\t\t\tif (!test_bit(PAGE_EXT_OWNER, &page_ext->flags))\n\t\t\t\tcontinue;\n\n\t\t\tpage_owner = get_page_owner(page_ext);\n\t\t\tpage_mt = gfpflags_to_migratetype(\n\t\t\t\t\tpage_owner->gfp_mask);\n\t\t\tif (pageblock_mt != page_mt) {\n\t\t\t\tif (is_migrate_cma(pageblock_mt))\n\t\t\t\t\tcount[MIGRATE_MOVABLE]++;\n\t\t\t\telse\n\t\t\t\t\tcount[pageblock_mt]++;\n\n\t\t\t\tpfn = block_end_pfn;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpfn += (1UL << page_owner->order) - 1;\n\t\t}\n\t}\n\n\t/* Print counts */\n\tseq_printf(m, \"Node %d, zone %8s \", pgdat->node_id, zone->name);\n\tfor (i = 0; i < MIGRATE_TYPES; i++)\n\t\tseq_printf(m, \"%12lu \", count[i]);\n\tseq_putc(m, '\\n');\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/stackdepot.h>",
      "#include <linux/migrate.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%12lu \"",
            "count[i]"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Node %d, zone %8s \"",
            "pgdat->node_id",
            "zone->name"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_migrate_cma",
          "args": [
            "pageblock_mt"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfpflags_to_migratetype",
          "args": [
            "page_owner->gfp_mask"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page_owner",
          "args": [
            "page_ext"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "get_page_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
          "lines": "105-108",
          "snippet": "static inline struct page_owner *get_page_owner(struct page_ext *page_ext)\n{\n\treturn (void *)page_ext + page_owner_ops.offset;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/migrate.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct page_ext_operations page_owner_ops = {\n\t.size = sizeof(struct page_owner),\n\t.need = need_page_owner,\n\t.init = init_page_owner,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstruct page_ext_operations page_owner_ops = {\n\t.size = sizeof(struct page_owner),\n\t.need = need_page_owner,\n\t.init = init_page_owner,\n};\n\nstatic inline struct page_owner *get_page_owner(struct page_ext *page_ext)\n{\n\treturn (void *)page_ext + page_owner_ops.offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "PAGE_EXT_OWNER",
            "&page_ext->flags"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page_ext"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_page_ext",
          "args": [
            "page"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "198-211",
          "snippet": "struct page_ext *lookup_page_ext(const struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct mem_section *section = __pfn_to_section(pfn);\n\t/*\n\t * The sanity checks the page allocator does upon freeing a\n\t * page can reach here before the page_ext arrays are\n\t * allocated when feeding a range of pages to the allocator\n\t * for the first time during bootup or memory hotplug.\n\t */\n\tif (!section->page_ext)\n\t\treturn NULL;\n\treturn get_entry(section->page_ext, pfn);\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstruct page_ext *lookup_page_ext(const struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct mem_section *section = __pfn_to_section(pfn);\n\t/*\n\t * The sanity checks the page allocator does upon freeing a\n\t * page can reach here before the page_ext arrays are\n\t * allocated when feeding a range of pages to the allocator\n\t * for the first time during bootup or memory hotplug.\n\t */\n\tif (!section->page_ext)\n\t\treturn NULL;\n\treturn get_entry(section->page_ext, pfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageReserved",
          "args": [
            "page"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_order_unsafe",
          "args": [
            "page"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageBuddy",
          "args": [
            "page"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid_within",
          "args": [
            "pfn"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pageblock_migratetype",
          "args": [
            "page"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "block_end_pfn",
            "end_pfn"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "pfn + 1",
            "pageblock_nr_pages"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "pfn + 1",
            "MAX_ORDER_NR_PAGES"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nvoid pagetypeinfo_showmixedcount_print(struct seq_file *m,\n\t\t\t\t       pg_data_t *pgdat, struct zone *zone)\n{\n\tstruct page *page;\n\tstruct page_ext *page_ext;\n\tstruct page_owner *page_owner;\n\tunsigned long pfn = zone->zone_start_pfn, block_end_pfn;\n\tunsigned long end_pfn = pfn + zone->spanned_pages;\n\tunsigned long count[MIGRATE_TYPES] = { 0, };\n\tint pageblock_mt, page_mt;\n\tint i;\n\n\t/* Scan block by block. First and last block may be incomplete */\n\tpfn = zone->zone_start_pfn;\n\n\t/*\n\t * Walk the zone in pageblock_nr_pages steps. If a page block spans\n\t * a zone boundary, it will be double counted between zones. This does\n\t * not matter as the mixed block count will still be correct\n\t */\n\tfor (; pfn < end_pfn; ) {\n\t\tif (!pfn_valid(pfn)) {\n\t\t\tpfn = ALIGN(pfn + 1, MAX_ORDER_NR_PAGES);\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock_end_pfn = ALIGN(pfn + 1, pageblock_nr_pages);\n\t\tblock_end_pfn = min(block_end_pfn, end_pfn);\n\n\t\tpage = pfn_to_page(pfn);\n\t\tpageblock_mt = get_pageblock_migratetype(page);\n\n\t\tfor (; pfn < block_end_pfn; pfn++) {\n\t\t\tif (!pfn_valid_within(pfn))\n\t\t\t\tcontinue;\n\n\t\t\tpage = pfn_to_page(pfn);\n\n\t\t\tif (page_zone(page) != zone)\n\t\t\t\tcontinue;\n\n\t\t\tif (PageBuddy(page)) {\n\t\t\t\tunsigned long freepage_order;\n\n\t\t\t\tfreepage_order = page_order_unsafe(page);\n\t\t\t\tif (freepage_order < MAX_ORDER)\n\t\t\t\t\tpfn += (1UL << freepage_order) - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (PageReserved(page))\n\t\t\t\tcontinue;\n\n\t\t\tpage_ext = lookup_page_ext(page);\n\t\t\tif (unlikely(!page_ext))\n\t\t\t\tcontinue;\n\n\t\t\tif (!test_bit(PAGE_EXT_OWNER, &page_ext->flags))\n\t\t\t\tcontinue;\n\n\t\t\tpage_owner = get_page_owner(page_ext);\n\t\t\tpage_mt = gfpflags_to_migratetype(\n\t\t\t\t\tpage_owner->gfp_mask);\n\t\t\tif (pageblock_mt != page_mt) {\n\t\t\t\tif (is_migrate_cma(pageblock_mt))\n\t\t\t\t\tcount[MIGRATE_MOVABLE]++;\n\t\t\t\telse\n\t\t\t\t\tcount[pageblock_mt]++;\n\n\t\t\t\tpfn = block_end_pfn;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpfn += (1UL << page_owner->order) - 1;\n\t\t}\n\t}\n\n\t/* Print counts */\n\tseq_printf(m, \"Node %d, zone %8s \", pgdat->node_id, zone->name);\n\tfor (i = 0; i < MIGRATE_TYPES; i++)\n\t\tseq_printf(m, \"%12lu \", count[i]);\n\tseq_putc(m, '\\n');\n}"
  },
  {
    "function_name": "__copy_page_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
    "lines": "226-253",
    "snippet": "void __copy_page_owner(struct page *oldpage, struct page *newpage)\n{\n\tstruct page_ext *old_ext = lookup_page_ext(oldpage);\n\tstruct page_ext *new_ext = lookup_page_ext(newpage);\n\tstruct page_owner *old_page_owner, *new_page_owner;\n\n\tif (unlikely(!old_ext || !new_ext))\n\t\treturn;\n\n\told_page_owner = get_page_owner(old_ext);\n\tnew_page_owner = get_page_owner(new_ext);\n\tnew_page_owner->order = old_page_owner->order;\n\tnew_page_owner->gfp_mask = old_page_owner->gfp_mask;\n\tnew_page_owner->last_migrate_reason =\n\t\told_page_owner->last_migrate_reason;\n\tnew_page_owner->handle = old_page_owner->handle;\n\n\t/*\n\t * We don't clear the bit on the oldpage as it's going to be freed\n\t * after migration. Until then, the info can be useful in case of\n\t * a bug, and the overal stats will be off a bit only temporarily.\n\t * Also, migrate_misplaced_transhuge_page() can still fail the\n\t * migration and then we want the oldpage to retain the info. But\n\t * in that case we also don't need to explicitly clear the info from\n\t * the new page, which will be freed.\n\t */\n\t__set_bit(PAGE_EXT_OWNER, &new_ext->flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/stackdepot.h>",
      "#include <linux/migrate.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "PAGE_EXT_OWNER",
            "&new_ext->flags"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page_owner",
          "args": [
            "new_ext"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "get_page_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
          "lines": "105-108",
          "snippet": "static inline struct page_owner *get_page_owner(struct page_ext *page_ext)\n{\n\treturn (void *)page_ext + page_owner_ops.offset;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/migrate.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct page_ext_operations page_owner_ops = {\n\t.size = sizeof(struct page_owner),\n\t.need = need_page_owner,\n\t.init = init_page_owner,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstruct page_ext_operations page_owner_ops = {\n\t.size = sizeof(struct page_owner),\n\t.need = need_page_owner,\n\t.init = init_page_owner,\n};\n\nstatic inline struct page_owner *get_page_owner(struct page_ext *page_ext)\n{\n\treturn (void *)page_ext + page_owner_ops.offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!old_ext || !new_ext"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_page_ext",
          "args": [
            "newpage"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "198-211",
          "snippet": "struct page_ext *lookup_page_ext(const struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct mem_section *section = __pfn_to_section(pfn);\n\t/*\n\t * The sanity checks the page allocator does upon freeing a\n\t * page can reach here before the page_ext arrays are\n\t * allocated when feeding a range of pages to the allocator\n\t * for the first time during bootup or memory hotplug.\n\t */\n\tif (!section->page_ext)\n\t\treturn NULL;\n\treturn get_entry(section->page_ext, pfn);\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstruct page_ext *lookup_page_ext(const struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct mem_section *section = __pfn_to_section(pfn);\n\t/*\n\t * The sanity checks the page allocator does upon freeing a\n\t * page can reach here before the page_ext arrays are\n\t * allocated when feeding a range of pages to the allocator\n\t * for the first time during bootup or memory hotplug.\n\t */\n\tif (!section->page_ext)\n\t\treturn NULL;\n\treturn get_entry(section->page_ext, pfn);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nvoid __copy_page_owner(struct page *oldpage, struct page *newpage)\n{\n\tstruct page_ext *old_ext = lookup_page_ext(oldpage);\n\tstruct page_ext *new_ext = lookup_page_ext(newpage);\n\tstruct page_owner *old_page_owner, *new_page_owner;\n\n\tif (unlikely(!old_ext || !new_ext))\n\t\treturn;\n\n\told_page_owner = get_page_owner(old_ext);\n\tnew_page_owner = get_page_owner(new_ext);\n\tnew_page_owner->order = old_page_owner->order;\n\tnew_page_owner->gfp_mask = old_page_owner->gfp_mask;\n\tnew_page_owner->last_migrate_reason =\n\t\told_page_owner->last_migrate_reason;\n\tnew_page_owner->handle = old_page_owner->handle;\n\n\t/*\n\t * We don't clear the bit on the oldpage as it's going to be freed\n\t * after migration. Until then, the info can be useful in case of\n\t * a bug, and the overal stats will be off a bit only temporarily.\n\t * Also, migrate_misplaced_transhuge_page() can still fail the\n\t * migration and then we want the oldpage to retain the info. But\n\t * in that case we also don't need to explicitly clear the info from\n\t * the new page, which will be freed.\n\t */\n\t__set_bit(PAGE_EXT_OWNER, &new_ext->flags);\n}"
  },
  {
    "function_name": "__split_page_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
    "lines": "211-224",
    "snippet": "void __split_page_owner(struct page *page, unsigned int order)\n{\n\tint i;\n\tstruct page_ext *page_ext = lookup_page_ext(page);\n\tstruct page_owner *page_owner;\n\n\tif (unlikely(!page_ext))\n\t\treturn;\n\n\tpage_owner = get_page_owner(page_ext);\n\tpage_owner->order = 0;\n\tfor (i = 1; i < (1 << order); i++)\n\t\t__copy_page_owner(page, page + i);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/stackdepot.h>",
      "#include <linux/migrate.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_page_owner",
          "args": [
            "page",
            "page + i"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "__copy_page_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
          "lines": "226-253",
          "snippet": "void __copy_page_owner(struct page *oldpage, struct page *newpage)\n{\n\tstruct page_ext *old_ext = lookup_page_ext(oldpage);\n\tstruct page_ext *new_ext = lookup_page_ext(newpage);\n\tstruct page_owner *old_page_owner, *new_page_owner;\n\n\tif (unlikely(!old_ext || !new_ext))\n\t\treturn;\n\n\told_page_owner = get_page_owner(old_ext);\n\tnew_page_owner = get_page_owner(new_ext);\n\tnew_page_owner->order = old_page_owner->order;\n\tnew_page_owner->gfp_mask = old_page_owner->gfp_mask;\n\tnew_page_owner->last_migrate_reason =\n\t\told_page_owner->last_migrate_reason;\n\tnew_page_owner->handle = old_page_owner->handle;\n\n\t/*\n\t * We don't clear the bit on the oldpage as it's going to be freed\n\t * after migration. Until then, the info can be useful in case of\n\t * a bug, and the overal stats will be off a bit only temporarily.\n\t * Also, migrate_misplaced_transhuge_page() can still fail the\n\t * migration and then we want the oldpage to retain the info. But\n\t * in that case we also don't need to explicitly clear the info from\n\t * the new page, which will be freed.\n\t */\n\t__set_bit(PAGE_EXT_OWNER, &new_ext->flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/migrate.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nvoid __copy_page_owner(struct page *oldpage, struct page *newpage)\n{\n\tstruct page_ext *old_ext = lookup_page_ext(oldpage);\n\tstruct page_ext *new_ext = lookup_page_ext(newpage);\n\tstruct page_owner *old_page_owner, *new_page_owner;\n\n\tif (unlikely(!old_ext || !new_ext))\n\t\treturn;\n\n\told_page_owner = get_page_owner(old_ext);\n\tnew_page_owner = get_page_owner(new_ext);\n\tnew_page_owner->order = old_page_owner->order;\n\tnew_page_owner->gfp_mask = old_page_owner->gfp_mask;\n\tnew_page_owner->last_migrate_reason =\n\t\told_page_owner->last_migrate_reason;\n\tnew_page_owner->handle = old_page_owner->handle;\n\n\t/*\n\t * We don't clear the bit on the oldpage as it's going to be freed\n\t * after migration. Until then, the info can be useful in case of\n\t * a bug, and the overal stats will be off a bit only temporarily.\n\t * Also, migrate_misplaced_transhuge_page() can still fail the\n\t * migration and then we want the oldpage to retain the info. But\n\t * in that case we also don't need to explicitly clear the info from\n\t * the new page, which will be freed.\n\t */\n\t__set_bit(PAGE_EXT_OWNER, &new_ext->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_page_owner",
          "args": [
            "page_ext"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "get_page_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
          "lines": "105-108",
          "snippet": "static inline struct page_owner *get_page_owner(struct page_ext *page_ext)\n{\n\treturn (void *)page_ext + page_owner_ops.offset;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/migrate.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct page_ext_operations page_owner_ops = {\n\t.size = sizeof(struct page_owner),\n\t.need = need_page_owner,\n\t.init = init_page_owner,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstruct page_ext_operations page_owner_ops = {\n\t.size = sizeof(struct page_owner),\n\t.need = need_page_owner,\n\t.init = init_page_owner,\n};\n\nstatic inline struct page_owner *get_page_owner(struct page_ext *page_ext)\n{\n\treturn (void *)page_ext + page_owner_ops.offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page_ext"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_page_ext",
          "args": [
            "page"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "198-211",
          "snippet": "struct page_ext *lookup_page_ext(const struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct mem_section *section = __pfn_to_section(pfn);\n\t/*\n\t * The sanity checks the page allocator does upon freeing a\n\t * page can reach here before the page_ext arrays are\n\t * allocated when feeding a range of pages to the allocator\n\t * for the first time during bootup or memory hotplug.\n\t */\n\tif (!section->page_ext)\n\t\treturn NULL;\n\treturn get_entry(section->page_ext, pfn);\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstruct page_ext *lookup_page_ext(const struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct mem_section *section = __pfn_to_section(pfn);\n\t/*\n\t * The sanity checks the page allocator does upon freeing a\n\t * page can reach here before the page_ext arrays are\n\t * allocated when feeding a range of pages to the allocator\n\t * for the first time during bootup or memory hotplug.\n\t */\n\tif (!section->page_ext)\n\t\treturn NULL;\n\treturn get_entry(section->page_ext, pfn);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nvoid __split_page_owner(struct page *page, unsigned int order)\n{\n\tint i;\n\tstruct page_ext *page_ext = lookup_page_ext(page);\n\tstruct page_owner *page_owner;\n\n\tif (unlikely(!page_ext))\n\t\treturn;\n\n\tpage_owner = get_page_owner(page_ext);\n\tpage_owner->order = 0;\n\tfor (i = 1; i < (1 << order); i++)\n\t\t__copy_page_owner(page, page + i);\n}"
  },
  {
    "function_name": "__set_page_owner_migrate_reason",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
    "lines": "199-209",
    "snippet": "void __set_page_owner_migrate_reason(struct page *page, int reason)\n{\n\tstruct page_ext *page_ext = lookup_page_ext(page);\n\tstruct page_owner *page_owner;\n\n\tif (unlikely(!page_ext))\n\t\treturn;\n\n\tpage_owner = get_page_owner(page_ext);\n\tpage_owner->last_migrate_reason = reason;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/stackdepot.h>",
      "#include <linux/migrate.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_page_owner",
          "args": [
            "page_ext"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "get_page_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
          "lines": "105-108",
          "snippet": "static inline struct page_owner *get_page_owner(struct page_ext *page_ext)\n{\n\treturn (void *)page_ext + page_owner_ops.offset;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/migrate.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct page_ext_operations page_owner_ops = {\n\t.size = sizeof(struct page_owner),\n\t.need = need_page_owner,\n\t.init = init_page_owner,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstruct page_ext_operations page_owner_ops = {\n\t.size = sizeof(struct page_owner),\n\t.need = need_page_owner,\n\t.init = init_page_owner,\n};\n\nstatic inline struct page_owner *get_page_owner(struct page_ext *page_ext)\n{\n\treturn (void *)page_ext + page_owner_ops.offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page_ext"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_page_ext",
          "args": [
            "page"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "198-211",
          "snippet": "struct page_ext *lookup_page_ext(const struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct mem_section *section = __pfn_to_section(pfn);\n\t/*\n\t * The sanity checks the page allocator does upon freeing a\n\t * page can reach here before the page_ext arrays are\n\t * allocated when feeding a range of pages to the allocator\n\t * for the first time during bootup or memory hotplug.\n\t */\n\tif (!section->page_ext)\n\t\treturn NULL;\n\treturn get_entry(section->page_ext, pfn);\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstruct page_ext *lookup_page_ext(const struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct mem_section *section = __pfn_to_section(pfn);\n\t/*\n\t * The sanity checks the page allocator does upon freeing a\n\t * page can reach here before the page_ext arrays are\n\t * allocated when feeding a range of pages to the allocator\n\t * for the first time during bootup or memory hotplug.\n\t */\n\tif (!section->page_ext)\n\t\treturn NULL;\n\treturn get_entry(section->page_ext, pfn);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nvoid __set_page_owner_migrate_reason(struct page *page, int reason)\n{\n\tstruct page_ext *page_ext = lookup_page_ext(page);\n\tstruct page_owner *page_owner;\n\n\tif (unlikely(!page_ext))\n\t\treturn;\n\n\tpage_owner = get_page_owner(page_ext);\n\tpage_owner->last_migrate_reason = reason;\n}"
  },
  {
    "function_name": "__set_page_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
    "lines": "186-197",
    "snippet": "noinline void __set_page_owner(struct page *page, unsigned int order,\n\t\t\t\t\tgfp_t gfp_mask)\n{\n\tstruct page_ext *page_ext = lookup_page_ext(page);\n\tdepot_stack_handle_t handle;\n\n\tif (unlikely(!page_ext))\n\t\treturn;\n\n\thandle = save_stack(gfp_mask);\n\t__set_page_owner_handle(page_ext, handle, order, gfp_mask);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/stackdepot.h>",
      "#include <linux/migrate.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline depot_stack_handle_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_page_owner_handle",
          "args": [
            "page_ext",
            "handle",
            "order",
            "gfp_mask"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "__set_page_owner_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
          "lines": "172-184",
          "snippet": "static inline void __set_page_owner_handle(struct page_ext *page_ext,\n\tdepot_stack_handle_t handle, unsigned int order, gfp_t gfp_mask)\n{\n\tstruct page_owner *page_owner;\n\n\tpage_owner = get_page_owner(page_ext);\n\tpage_owner->handle = handle;\n\tpage_owner->order = order;\n\tpage_owner->gfp_mask = gfp_mask;\n\tpage_owner->last_migrate_reason = -1;\n\n\t__set_bit(PAGE_EXT_OWNER, &page_ext->flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/migrate.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline depot_stack_handle_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstatic __always_inline depot_stack_handle_t;\n\nstatic inline void __set_page_owner_handle(struct page_ext *page_ext,\n\tdepot_stack_handle_t handle, unsigned int order, gfp_t gfp_mask)\n{\n\tstruct page_owner *page_owner;\n\n\tpage_owner = get_page_owner(page_ext);\n\tpage_owner->handle = handle;\n\tpage_owner->order = order;\n\tpage_owner->gfp_mask = gfp_mask;\n\tpage_owner->last_migrate_reason = -1;\n\n\t__set_bit(PAGE_EXT_OWNER, &page_ext->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_stack",
          "args": [
            "gfp_mask"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "save_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
          "lines": "139-170",
          "snippet": "static noinline depot_stack_handle_t save_stack(gfp_t flags)\n{\n\tunsigned long entries[PAGE_OWNER_STACK_DEPTH];\n\tstruct stack_trace trace = {\n\t\t.nr_entries = 0,\n\t\t.entries = entries,\n\t\t.max_entries = PAGE_OWNER_STACK_DEPTH,\n\t\t.skip = 2\n\t};\n\tdepot_stack_handle_t handle;\n\n\tsave_stack_trace(&trace);\n\tif (trace.nr_entries != 0 &&\n\t    trace.entries[trace.nr_entries-1] == ULONG_MAX)\n\t\ttrace.nr_entries--;\n\n\t/*\n\t * We need to check recursion here because our request to stackdepot\n\t * could trigger memory allocation to save new entry. New memory\n\t * allocation would reach here and call depot_save_stack() again\n\t * if we don't catch it. There is still not enough memory in stackdepot\n\t * so it would try to allocate memory again and loop forever.\n\t */\n\tif (check_recursive_alloc(&trace, _RET_IP_))\n\t\treturn dummy_handle;\n\n\thandle = depot_save_stack(&trace, flags);\n\tif (!handle)\n\t\thandle = failure_handle;\n\n\treturn handle;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/migrate.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [
            "#define PAGE_OWNER_STACK_DEPTH (16)"
          ],
          "globals_used": [
            "static depot_stack_handle_t dummy_handle;",
            "static depot_stack_handle_t failure_handle;",
            "static __always_inline depot_stack_handle_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\n#define PAGE_OWNER_STACK_DEPTH (16)\n\nstatic depot_stack_handle_t dummy_handle;\nstatic depot_stack_handle_t failure_handle;\nstatic __always_inline depot_stack_handle_t;\n\nstatic noinline depot_stack_handle_t save_stack(gfp_t flags)\n{\n\tunsigned long entries[PAGE_OWNER_STACK_DEPTH];\n\tstruct stack_trace trace = {\n\t\t.nr_entries = 0,\n\t\t.entries = entries,\n\t\t.max_entries = PAGE_OWNER_STACK_DEPTH,\n\t\t.skip = 2\n\t};\n\tdepot_stack_handle_t handle;\n\n\tsave_stack_trace(&trace);\n\tif (trace.nr_entries != 0 &&\n\t    trace.entries[trace.nr_entries-1] == ULONG_MAX)\n\t\ttrace.nr_entries--;\n\n\t/*\n\t * We need to check recursion here because our request to stackdepot\n\t * could trigger memory allocation to save new entry. New memory\n\t * allocation would reach here and call depot_save_stack() again\n\t * if we don't catch it. There is still not enough memory in stackdepot\n\t * so it would try to allocate memory again and loop forever.\n\t */\n\tif (check_recursive_alloc(&trace, _RET_IP_))\n\t\treturn dummy_handle;\n\n\thandle = depot_save_stack(&trace, flags);\n\tif (!handle)\n\t\thandle = failure_handle;\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page_ext"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_page_ext",
          "args": [
            "page"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "198-211",
          "snippet": "struct page_ext *lookup_page_ext(const struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct mem_section *section = __pfn_to_section(pfn);\n\t/*\n\t * The sanity checks the page allocator does upon freeing a\n\t * page can reach here before the page_ext arrays are\n\t * allocated when feeding a range of pages to the allocator\n\t * for the first time during bootup or memory hotplug.\n\t */\n\tif (!section->page_ext)\n\t\treturn NULL;\n\treturn get_entry(section->page_ext, pfn);\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstruct page_ext *lookup_page_ext(const struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct mem_section *section = __pfn_to_section(pfn);\n\t/*\n\t * The sanity checks the page allocator does upon freeing a\n\t * page can reach here before the page_ext arrays are\n\t * allocated when feeding a range of pages to the allocator\n\t * for the first time during bootup or memory hotplug.\n\t */\n\tif (!section->page_ext)\n\t\treturn NULL;\n\treturn get_entry(section->page_ext, pfn);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstatic __always_inline depot_stack_handle_t;\n\nnoinline void __set_page_owner(struct page *page, unsigned int order,\n\t\t\t\t\tgfp_t gfp_mask)\n{\n\tstruct page_ext *page_ext = lookup_page_ext(page);\n\tdepot_stack_handle_t handle;\n\n\tif (unlikely(!page_ext))\n\t\treturn;\n\n\thandle = save_stack(gfp_mask);\n\t__set_page_owner_handle(page_ext, handle, order, gfp_mask);\n}"
  },
  {
    "function_name": "__set_page_owner_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
    "lines": "172-184",
    "snippet": "static inline void __set_page_owner_handle(struct page_ext *page_ext,\n\tdepot_stack_handle_t handle, unsigned int order, gfp_t gfp_mask)\n{\n\tstruct page_owner *page_owner;\n\n\tpage_owner = get_page_owner(page_ext);\n\tpage_owner->handle = handle;\n\tpage_owner->order = order;\n\tpage_owner->gfp_mask = gfp_mask;\n\tpage_owner->last_migrate_reason = -1;\n\n\t__set_bit(PAGE_EXT_OWNER, &page_ext->flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/stackdepot.h>",
      "#include <linux/migrate.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline depot_stack_handle_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "PAGE_EXT_OWNER",
            "&page_ext->flags"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page_owner",
          "args": [
            "page_ext"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "get_page_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
          "lines": "105-108",
          "snippet": "static inline struct page_owner *get_page_owner(struct page_ext *page_ext)\n{\n\treturn (void *)page_ext + page_owner_ops.offset;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/migrate.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct page_ext_operations page_owner_ops = {\n\t.size = sizeof(struct page_owner),\n\t.need = need_page_owner,\n\t.init = init_page_owner,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstruct page_ext_operations page_owner_ops = {\n\t.size = sizeof(struct page_owner),\n\t.need = need_page_owner,\n\t.init = init_page_owner,\n};\n\nstatic inline struct page_owner *get_page_owner(struct page_ext *page_ext)\n{\n\treturn (void *)page_ext + page_owner_ops.offset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstatic __always_inline depot_stack_handle_t;\n\nstatic inline void __set_page_owner_handle(struct page_ext *page_ext,\n\tdepot_stack_handle_t handle, unsigned int order, gfp_t gfp_mask)\n{\n\tstruct page_owner *page_owner;\n\n\tpage_owner = get_page_owner(page_ext);\n\tpage_owner->handle = handle;\n\tpage_owner->order = order;\n\tpage_owner->gfp_mask = gfp_mask;\n\tpage_owner->last_migrate_reason = -1;\n\n\t__set_bit(PAGE_EXT_OWNER, &page_ext->flags);\n}"
  },
  {
    "function_name": "save_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
    "lines": "139-170",
    "snippet": "static noinline depot_stack_handle_t save_stack(gfp_t flags)\n{\n\tunsigned long entries[PAGE_OWNER_STACK_DEPTH];\n\tstruct stack_trace trace = {\n\t\t.nr_entries = 0,\n\t\t.entries = entries,\n\t\t.max_entries = PAGE_OWNER_STACK_DEPTH,\n\t\t.skip = 2\n\t};\n\tdepot_stack_handle_t handle;\n\n\tsave_stack_trace(&trace);\n\tif (trace.nr_entries != 0 &&\n\t    trace.entries[trace.nr_entries-1] == ULONG_MAX)\n\t\ttrace.nr_entries--;\n\n\t/*\n\t * We need to check recursion here because our request to stackdepot\n\t * could trigger memory allocation to save new entry. New memory\n\t * allocation would reach here and call depot_save_stack() again\n\t * if we don't catch it. There is still not enough memory in stackdepot\n\t * so it would try to allocate memory again and loop forever.\n\t */\n\tif (check_recursive_alloc(&trace, _RET_IP_))\n\t\treturn dummy_handle;\n\n\thandle = depot_save_stack(&trace, flags);\n\tif (!handle)\n\t\thandle = failure_handle;\n\n\treturn handle;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/stackdepot.h>",
      "#include <linux/migrate.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [
      "#define PAGE_OWNER_STACK_DEPTH (16)"
    ],
    "globals_used": [
      "static depot_stack_handle_t dummy_handle;",
      "static depot_stack_handle_t failure_handle;",
      "static __always_inline depot_stack_handle_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "depot_save_stack",
          "args": [
            "&trace",
            "flags"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_recursive_alloc",
          "args": [
            "&trace",
            "_RET_IP_"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "check_recursive_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
          "lines": "123-137",
          "snippet": "static inline bool check_recursive_alloc(struct stack_trace *trace,\n\t\t\t\t\tunsigned long ip)\n{\n\tint i;\n\n\tif (!trace->nr_entries)\n\t\treturn false;\n\n\tfor (i = 0; i < trace->nr_entries; i++) {\n\t\tif (trace->entries[i] == ip)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/migrate.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstatic inline bool check_recursive_alloc(struct stack_trace *trace,\n\t\t\t\t\tunsigned long ip)\n{\n\tint i;\n\n\tif (!trace->nr_entries)\n\t\treturn false;\n\n\tfor (i = 0; i < trace->nr_entries; i++) {\n\t\tif (trace->entries[i] == ip)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_stack_trace",
          "args": [
            "&trace"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "__save_stack_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "554-565",
          "snippet": "static int __save_stack_trace(unsigned long *trace)\n{\n\tstruct stack_trace stack_trace;\n\n\tstack_trace.max_entries = MAX_TRACE;\n\tstack_trace.nr_entries = 0;\n\tstack_trace.entries = trace;\n\tstack_trace.skip = 2;\n\tsave_stack_trace(&stack_trace);\n\n\treturn stack_trace.nr_entries;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define MAX_TRACE\t\t16\t/* stack trace length */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define MAX_TRACE\t\t16\t/* stack trace length */\n\nstatic int __save_stack_trace(unsigned long *trace)\n{\n\tstruct stack_trace stack_trace;\n\n\tstack_trace.max_entries = MAX_TRACE;\n\tstack_trace.nr_entries = 0;\n\tstack_trace.entries = trace;\n\tstack_trace.skip = 2;\n\tsave_stack_trace(&stack_trace);\n\n\treturn stack_trace.nr_entries;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\n#define PAGE_OWNER_STACK_DEPTH (16)\n\nstatic depot_stack_handle_t dummy_handle;\nstatic depot_stack_handle_t failure_handle;\nstatic __always_inline depot_stack_handle_t;\n\nstatic noinline depot_stack_handle_t save_stack(gfp_t flags)\n{\n\tunsigned long entries[PAGE_OWNER_STACK_DEPTH];\n\tstruct stack_trace trace = {\n\t\t.nr_entries = 0,\n\t\t.entries = entries,\n\t\t.max_entries = PAGE_OWNER_STACK_DEPTH,\n\t\t.skip = 2\n\t};\n\tdepot_stack_handle_t handle;\n\n\tsave_stack_trace(&trace);\n\tif (trace.nr_entries != 0 &&\n\t    trace.entries[trace.nr_entries-1] == ULONG_MAX)\n\t\ttrace.nr_entries--;\n\n\t/*\n\t * We need to check recursion here because our request to stackdepot\n\t * could trigger memory allocation to save new entry. New memory\n\t * allocation would reach here and call depot_save_stack() again\n\t * if we don't catch it. There is still not enough memory in stackdepot\n\t * so it would try to allocate memory again and loop forever.\n\t */\n\tif (check_recursive_alloc(&trace, _RET_IP_))\n\t\treturn dummy_handle;\n\n\thandle = depot_save_stack(&trace, flags);\n\tif (!handle)\n\t\thandle = failure_handle;\n\n\treturn handle;\n}"
  },
  {
    "function_name": "check_recursive_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
    "lines": "123-137",
    "snippet": "static inline bool check_recursive_alloc(struct stack_trace *trace,\n\t\t\t\t\tunsigned long ip)\n{\n\tint i;\n\n\tif (!trace->nr_entries)\n\t\treturn false;\n\n\tfor (i = 0; i < trace->nr_entries; i++) {\n\t\tif (trace->entries[i] == ip)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/stackdepot.h>",
      "#include <linux/migrate.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstatic inline bool check_recursive_alloc(struct stack_trace *trace,\n\t\t\t\t\tunsigned long ip)\n{\n\tint i;\n\n\tif (!trace->nr_entries)\n\t\treturn false;\n\n\tfor (i = 0; i < trace->nr_entries; i++) {\n\t\tif (trace->entries[i] == ip)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "__reset_page_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
    "lines": "110-121",
    "snippet": "void __reset_page_owner(struct page *page, unsigned int order)\n{\n\tint i;\n\tstruct page_ext *page_ext;\n\n\tfor (i = 0; i < (1 << order); i++) {\n\t\tpage_ext = lookup_page_ext(page + i);\n\t\tif (unlikely(!page_ext))\n\t\t\tcontinue;\n\t\t__clear_bit(PAGE_EXT_OWNER, &page_ext->flags);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/stackdepot.h>",
      "#include <linux/migrate.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "PAGE_EXT_OWNER",
            "&page_ext->flags"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page_ext"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_page_ext",
          "args": [
            "page + i"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "198-211",
          "snippet": "struct page_ext *lookup_page_ext(const struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct mem_section *section = __pfn_to_section(pfn);\n\t/*\n\t * The sanity checks the page allocator does upon freeing a\n\t * page can reach here before the page_ext arrays are\n\t * allocated when feeding a range of pages to the allocator\n\t * for the first time during bootup or memory hotplug.\n\t */\n\tif (!section->page_ext)\n\t\treturn NULL;\n\treturn get_entry(section->page_ext, pfn);\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstruct page_ext *lookup_page_ext(const struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct mem_section *section = __pfn_to_section(pfn);\n\t/*\n\t * The sanity checks the page allocator does upon freeing a\n\t * page can reach here before the page_ext arrays are\n\t * allocated when feeding a range of pages to the allocator\n\t * for the first time during bootup or memory hotplug.\n\t */\n\tif (!section->page_ext)\n\t\treturn NULL;\n\treturn get_entry(section->page_ext, pfn);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nvoid __reset_page_owner(struct page *page, unsigned int order)\n{\n\tint i;\n\tstruct page_ext *page_ext;\n\n\tfor (i = 0; i < (1 << order); i++) {\n\t\tpage_ext = lookup_page_ext(page + i);\n\t\tif (unlikely(!page_ext))\n\t\t\tcontinue;\n\t\t__clear_bit(PAGE_EXT_OWNER, &page_ext->flags);\n\t}\n}"
  },
  {
    "function_name": "get_page_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
    "lines": "105-108",
    "snippet": "static inline struct page_owner *get_page_owner(struct page_ext *page_ext)\n{\n\treturn (void *)page_ext + page_owner_ops.offset;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/stackdepot.h>",
      "#include <linux/migrate.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct page_ext_operations page_owner_ops = {\n\t.size = sizeof(struct page_owner),\n\t.need = need_page_owner,\n\t.init = init_page_owner,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstruct page_ext_operations page_owner_ops = {\n\t.size = sizeof(struct page_owner),\n\t.need = need_page_owner,\n\t.init = init_page_owner,\n};\n\nstatic inline struct page_owner *get_page_owner(struct page_ext *page_ext)\n{\n\treturn (void *)page_ext + page_owner_ops.offset;\n}"
  },
  {
    "function_name": "init_page_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
    "lines": "87-97",
    "snippet": "static void init_page_owner(void)\n{\n\tif (page_owner_disabled)\n\t\treturn;\n\n\tregister_dummy_stack();\n\tregister_failure_stack();\n\tregister_early_stack();\n\tstatic_branch_enable(&page_owner_inited);\n\tinit_early_allocated_pages();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/stackdepot.h>",
      "#include <linux/migrate.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool page_owner_disabled = true;",
      "static void init_early_allocated_pages(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_early_allocated_pages",
          "args": [],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "init_early_allocated_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
          "lines": "613-619",
          "snippet": "static void init_early_allocated_pages(void)\n{\n\tpg_data_t *pgdat;\n\n\tfor_each_online_pgdat(pgdat)\n\t\tinit_zones_in_node(pgdat);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/migrate.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_early_allocated_pages(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstatic void init_early_allocated_pages(void);\n\nstatic void init_early_allocated_pages(void)\n{\n\tpg_data_t *pgdat;\n\n\tfor_each_online_pgdat(pgdat)\n\t\tinit_zones_in_node(pgdat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_enable",
          "args": [
            "&page_owner_inited"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_early_stack",
          "args": [],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "register_early_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
          "lines": "82-85",
          "snippet": "static noinline void register_early_stack(void)\n{\n\tearly_handle = create_dummy_stack();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/migrate.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static depot_stack_handle_t early_handle;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstatic depot_stack_handle_t early_handle;\n\nstatic noinline void register_early_stack(void)\n{\n\tearly_handle = create_dummy_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_failure_stack",
          "args": [],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "register_failure_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
          "lines": "77-80",
          "snippet": "static noinline void register_failure_stack(void)\n{\n\tfailure_handle = create_dummy_stack();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/migrate.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static depot_stack_handle_t failure_handle;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstatic depot_stack_handle_t failure_handle;\n\nstatic noinline void register_failure_stack(void)\n{\n\tfailure_handle = create_dummy_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_dummy_stack",
          "args": [],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "register_dummy_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
          "lines": "72-75",
          "snippet": "static noinline void register_dummy_stack(void)\n{\n\tdummy_handle = create_dummy_stack();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/migrate.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static depot_stack_handle_t dummy_handle;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstatic depot_stack_handle_t dummy_handle;\n\nstatic noinline void register_dummy_stack(void)\n{\n\tdummy_handle = create_dummy_stack();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstatic bool page_owner_disabled = true;\nstatic void init_early_allocated_pages(void);\n\nstatic void init_page_owner(void)\n{\n\tif (page_owner_disabled)\n\t\treturn;\n\n\tregister_dummy_stack();\n\tregister_failure_stack();\n\tregister_early_stack();\n\tstatic_branch_enable(&page_owner_inited);\n\tinit_early_allocated_pages();\n}"
  },
  {
    "function_name": "register_early_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
    "lines": "82-85",
    "snippet": "static noinline void register_early_stack(void)\n{\n\tearly_handle = create_dummy_stack();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/stackdepot.h>",
      "#include <linux/migrate.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static depot_stack_handle_t early_handle;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_dummy_stack",
          "args": [],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstatic depot_stack_handle_t early_handle;\n\nstatic noinline void register_early_stack(void)\n{\n\tearly_handle = create_dummy_stack();\n}"
  },
  {
    "function_name": "register_failure_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
    "lines": "77-80",
    "snippet": "static noinline void register_failure_stack(void)\n{\n\tfailure_handle = create_dummy_stack();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/stackdepot.h>",
      "#include <linux/migrate.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static depot_stack_handle_t failure_handle;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_dummy_stack",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstatic depot_stack_handle_t failure_handle;\n\nstatic noinline void register_failure_stack(void)\n{\n\tfailure_handle = create_dummy_stack();\n}"
  },
  {
    "function_name": "register_dummy_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
    "lines": "72-75",
    "snippet": "static noinline void register_dummy_stack(void)\n{\n\tdummy_handle = create_dummy_stack();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/stackdepot.h>",
      "#include <linux/migrate.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static depot_stack_handle_t dummy_handle;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_dummy_stack",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstatic depot_stack_handle_t dummy_handle;\n\nstatic noinline void register_dummy_stack(void)\n{\n\tdummy_handle = create_dummy_stack();\n}"
  },
  {
    "function_name": "need_page_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
    "lines": "50-56",
    "snippet": "static bool need_page_owner(void)\n{\n\tif (page_owner_disabled)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/stackdepot.h>",
      "#include <linux/migrate.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool page_owner_disabled = true;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstatic bool page_owner_disabled = true;\n\nstatic bool need_page_owner(void)\n{\n\tif (page_owner_disabled)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "early_page_owner_param",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
    "lines": "38-47",
    "snippet": "static int __init early_page_owner_param(char *buf)\n{\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tif (strcmp(buf, \"on\") == 0)\n\t\tpage_owner_disabled = false;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/stackdepot.h>",
      "#include <linux/migrate.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/memblock.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool page_owner_disabled = true;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "\"on\""
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstatic bool page_owner_disabled = true;\n\nstatic int __init early_page_owner_param(char *buf)\n{\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tif (strcmp(buf, \"on\") == 0)\n\t\tpage_owner_disabled = false;\n\n\treturn 0;\n}"
  }
]