[
  {
    "function_name": "remove_migration_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "2926-2955",
    "snippet": "void remove_migration_pmd(struct page_vma_mapped_walk *pvmw, struct page *new)\n{\n\tstruct vm_area_struct *vma = pvmw->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long address = pvmw->address;\n\tunsigned long mmun_start = address & HPAGE_PMD_MASK;\n\tpmd_t pmde;\n\tswp_entry_t entry;\n\n\tif (!(pvmw->pmd && !pvmw->pte))\n\t\treturn;\n\n\tentry = pmd_to_swp_entry(*pvmw->pmd);\n\tget_page(new);\n\tpmde = pmd_mkold(mk_huge_pmd(new, vma->vm_page_prot));\n\tif (pmd_swp_soft_dirty(*pvmw->pmd))\n\t\tpmde = pmd_mksoft_dirty(pmde);\n\tif (is_write_migration_entry(entry))\n\t\tpmde = maybe_pmd_mkwrite(pmde, vma);\n\n\tflush_cache_range(vma, mmun_start, mmun_start + HPAGE_PMD_SIZE);\n\tif (PageAnon(new))\n\t\tpage_add_anon_rmap(new, vma, mmun_start, true);\n\telse\n\t\tpage_add_file_rmap(new, true);\n\tset_pmd_at(mm, mmun_start, pvmw->pmd, pmde);\n\tif ((vma->vm_flags & VM_LOCKED) && !PageDoubleMap(new))\n\t\tmlock_vma_page(new);\n\tupdate_mmu_cache_pmd(vma, address, pvmw->pmd);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_mmu_cache_pmd",
          "args": [
            "vma",
            "address",
            "pvmw->pmd"
          ],
          "line": 2954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlock_vma_page",
          "args": [
            "new"
          ],
          "line": 2953
        },
        "resolved": true,
        "details": {
          "function_name": "mlock_vma_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "359-359",
          "snippet": "static inline void mlock_vma_page(struct page *page) { }",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mlock_vma_page(struct page *page) { }"
        }
      },
      {
        "call_info": {
          "callee": "PageDoubleMap",
          "args": [
            "new"
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pmd_at",
          "args": [
            "mm",
            "mmun_start",
            "pvmw->pmd",
            "pmde"
          ],
          "line": 2951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_add_file_rmap",
          "args": [
            "new",
            "true"
          ],
          "line": 2950
        },
        "resolved": true,
        "details": {
          "function_name": "page_add_file_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1179-1208",
          "snippet": "void page_add_file_rmap(struct page *page, bool compound)\n{\n\tint i, nr = 1;\n\n\tVM_BUG_ON_PAGE(compound && !PageTransHuge(page), page);\n\tlock_page_memcg(page);\n\tif (compound && PageTransHuge(page)) {\n\t\tfor (i = 0, nr = 0; i < HPAGE_PMD_NR; i++) {\n\t\t\tif (atomic_inc_and_test(&page[i]._mapcount))\n\t\t\t\tnr++;\n\t\t}\n\t\tif (!atomic_inc_and_test(compound_mapcount_ptr(page)))\n\t\t\tgoto out;\n\t\tVM_BUG_ON_PAGE(!PageSwapBacked(page), page);\n\t\t__inc_node_page_state(page, NR_SHMEM_PMDMAPPED);\n\t} else {\n\t\tif (PageTransCompound(page) && page_mapping(page)) {\n\t\t\tVM_WARN_ON_ONCE(!PageLocked(page));\n\n\t\t\tSetPageDoubleMap(compound_head(page));\n\t\t\tif (PageMlocked(page))\n\t\t\t\tclear_page_mlock(compound_head(page));\n\t\t}\n\t\tif (!atomic_inc_and_test(&page->_mapcount))\n\t\t\tgoto out;\n\t}\n\t__mod_lruvec_page_state(page, NR_FILE_MAPPED, nr);\nout:\n\tunlock_page_memcg(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_add_file_rmap(struct page *page, bool compound)\n{\n\tint i, nr = 1;\n\n\tVM_BUG_ON_PAGE(compound && !PageTransHuge(page), page);\n\tlock_page_memcg(page);\n\tif (compound && PageTransHuge(page)) {\n\t\tfor (i = 0, nr = 0; i < HPAGE_PMD_NR; i++) {\n\t\t\tif (atomic_inc_and_test(&page[i]._mapcount))\n\t\t\t\tnr++;\n\t\t}\n\t\tif (!atomic_inc_and_test(compound_mapcount_ptr(page)))\n\t\t\tgoto out;\n\t\tVM_BUG_ON_PAGE(!PageSwapBacked(page), page);\n\t\t__inc_node_page_state(page, NR_SHMEM_PMDMAPPED);\n\t} else {\n\t\tif (PageTransCompound(page) && page_mapping(page)) {\n\t\t\tVM_WARN_ON_ONCE(!PageLocked(page));\n\n\t\t\tSetPageDoubleMap(compound_head(page));\n\t\t\tif (PageMlocked(page))\n\t\t\t\tclear_page_mlock(compound_head(page));\n\t\t}\n\t\tif (!atomic_inc_and_test(&page->_mapcount))\n\t\t\tgoto out;\n\t}\n\t__mod_lruvec_page_state(page, NR_FILE_MAPPED, nr);\nout:\n\tunlock_page_memcg(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_add_anon_rmap",
          "args": [
            "new",
            "vma",
            "mmun_start",
            "true"
          ],
          "line": 2948
        },
        "resolved": true,
        "details": {
          "function_name": "do_page_add_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1098-1137",
          "snippet": "void do_page_add_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int flags)\n{\n\tbool compound = flags & RMAP_COMPOUND;\n\tbool first;\n\n\tif (compound) {\n\t\tatomic_t *mapcount;\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\tmapcount = compound_mapcount_ptr(page);\n\t\tfirst = atomic_inc_and_test(mapcount);\n\t} else {\n\t\tfirst = atomic_inc_and_test(&page->_mapcount);\n\t}\n\n\tif (first) {\n\t\tint nr = compound ? hpage_nr_pages(page) : 1;\n\t\t/*\n\t\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t\t * these counters are not modified in interrupt context, and\n\t\t * pte lock(a spinlock) is held, which implies preemption\n\t\t * disabled.\n\t\t */\n\t\tif (compound)\n\t\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t}\n\tif (unlikely(PageKsm(page)))\n\t\treturn;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\t/* address might be in next vma when migration races vma_adjust */\n\tif (first)\n\t\t__page_set_anon_rmap(page, vma, address,\n\t\t\t\tflags & RMAP_EXCLUSIVE);\n\telse\n\t\t__page_check_anon_rmap(page, vma, address);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid do_page_add_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int flags)\n{\n\tbool compound = flags & RMAP_COMPOUND;\n\tbool first;\n\n\tif (compound) {\n\t\tatomic_t *mapcount;\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\tmapcount = compound_mapcount_ptr(page);\n\t\tfirst = atomic_inc_and_test(mapcount);\n\t} else {\n\t\tfirst = atomic_inc_and_test(&page->_mapcount);\n\t}\n\n\tif (first) {\n\t\tint nr = compound ? hpage_nr_pages(page) : 1;\n\t\t/*\n\t\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t\t * these counters are not modified in interrupt context, and\n\t\t * pte lock(a spinlock) is held, which implies preemption\n\t\t * disabled.\n\t\t */\n\t\tif (compound)\n\t\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t}\n\tif (unlikely(PageKsm(page)))\n\t\treturn;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\t/* address might be in next vma when migration races vma_adjust */\n\tif (first)\n\t\t__page_set_anon_rmap(page, vma, address,\n\t\t\t\tflags & RMAP_EXCLUSIVE);\n\telse\n\t\t__page_check_anon_rmap(page, vma, address);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "new"
          ],
          "line": 2947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_cache_range",
          "args": [
            "vma",
            "mmun_start",
            "mmun_start + HPAGE_PMD_SIZE"
          ],
          "line": 2946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "maybe_pmd_mkwrite",
          "args": [
            "pmde",
            "vma"
          ],
          "line": 2944
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_pmd_mkwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "477-482",
          "snippet": "pmd_t maybe_pmd_mkwrite(pmd_t pmd, struct vm_area_struct *vma)\n{\n\tif (likely(vma->vm_flags & VM_WRITE))\n\t\tpmd = pmd_mkwrite(pmd);\n\treturn pmd;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\npmd_t maybe_pmd_mkwrite(pmd_t pmd, struct vm_area_struct *vma)\n{\n\tif (likely(vma->vm_flags & VM_WRITE))\n\t\tpmd = pmd_mkwrite(pmd);\n\treturn pmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_write_migration_entry",
          "args": [
            "entry"
          ],
          "line": 2943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_mksoft_dirty",
          "args": [
            "pmde"
          ],
          "line": 2942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_swp_soft_dirty",
          "args": [
            "*pvmw->pmd"
          ],
          "line": 2941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_mkold",
          "args": [
            "mk_huge_pmd(new, vma->vm_page_prot)"
          ],
          "line": 2940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mk_huge_pmd",
          "args": [
            "new",
            "vma->vm_page_prot"
          ],
          "line": 2940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "new"
          ],
          "line": 2939
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_to_swp_entry",
          "args": [
            "*pvmw->pmd"
          ],
          "line": 2938
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid remove_migration_pmd(struct page_vma_mapped_walk *pvmw, struct page *new)\n{\n\tstruct vm_area_struct *vma = pvmw->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long address = pvmw->address;\n\tunsigned long mmun_start = address & HPAGE_PMD_MASK;\n\tpmd_t pmde;\n\tswp_entry_t entry;\n\n\tif (!(pvmw->pmd && !pvmw->pte))\n\t\treturn;\n\n\tentry = pmd_to_swp_entry(*pvmw->pmd);\n\tget_page(new);\n\tpmde = pmd_mkold(mk_huge_pmd(new, vma->vm_page_prot));\n\tif (pmd_swp_soft_dirty(*pvmw->pmd))\n\t\tpmde = pmd_mksoft_dirty(pmde);\n\tif (is_write_migration_entry(entry))\n\t\tpmde = maybe_pmd_mkwrite(pmde, vma);\n\n\tflush_cache_range(vma, mmun_start, mmun_start + HPAGE_PMD_SIZE);\n\tif (PageAnon(new))\n\t\tpage_add_anon_rmap(new, vma, mmun_start, true);\n\telse\n\t\tpage_add_file_rmap(new, true);\n\tset_pmd_at(mm, mmun_start, pvmw->pmd, pmde);\n\tif ((vma->vm_flags & VM_LOCKED) && !PageDoubleMap(new))\n\t\tmlock_vma_page(new);\n\tupdate_mmu_cache_pmd(vma, address, pvmw->pmd);\n}"
  },
  {
    "function_name": "set_pmd_migration_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "2899-2924",
    "snippet": "void set_pmd_migration_entry(struct page_vma_mapped_walk *pvmw,\n\t\tstruct page *page)\n{\n\tstruct vm_area_struct *vma = pvmw->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long address = pvmw->address;\n\tpmd_t pmdval;\n\tswp_entry_t entry;\n\tpmd_t pmdswp;\n\n\tif (!(pvmw->pmd && !pvmw->pte))\n\t\treturn;\n\n\tflush_cache_range(vma, address, address + HPAGE_PMD_SIZE);\n\tpmdval = *pvmw->pmd;\n\tpmdp_invalidate(vma, address, pvmw->pmd);\n\tif (pmd_dirty(pmdval))\n\t\tset_page_dirty(page);\n\tentry = make_migration_entry(page, pmd_write(pmdval));\n\tpmdswp = swp_entry_to_pmd(entry);\n\tif (pmd_soft_dirty(pmdval))\n\t\tpmdswp = pmd_swp_mksoft_dirty(pmdswp);\n\tset_pmd_at(mm, address, pvmw->pmd, pmdswp);\n\tpage_remove_rmap(page, true);\n\tput_page(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 2923
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_remove_rmap",
          "args": [
            "page",
            "true"
          ],
          "line": 2922
        },
        "resolved": true,
        "details": {
          "function_name": "page_remove_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1297-1331",
          "snippet": "void page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_pmd_at",
          "args": [
            "mm",
            "address",
            "pvmw->pmd",
            "pmdswp"
          ],
          "line": 2921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_swp_mksoft_dirty",
          "args": [
            "pmdswp"
          ],
          "line": 2920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_soft_dirty",
          "args": [
            "pmdval"
          ],
          "line": 2919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_entry_to_pmd",
          "args": [
            "entry"
          ],
          "line": 2918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_migration_entry",
          "args": [
            "page",
            "pmd_write(pmdval)"
          ],
          "line": 2917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_write",
          "args": [
            "pmdval"
          ],
          "line": 2917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 2916
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_dirty_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2573-2581",
          "snippet": "int set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_dirty",
          "args": [
            "pmdval"
          ],
          "line": 2915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmdp_invalidate",
          "args": [
            "vma",
            "address",
            "pvmw->pmd"
          ],
          "line": 2914
        },
        "resolved": true,
        "details": {
          "function_name": "pmdp_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "185-191",
          "snippet": "pmd_t pmdp_invalidate(struct vm_area_struct *vma, unsigned long address,\n\t\t     pmd_t *pmdp)\n{\n\tpmd_t old = pmdp_establish(vma, address, pmdp, pmd_mknotpresent(*pmdp));\n\tflush_pmd_tlb_range(vma, address, address + HPAGE_PMD_SIZE);\n\treturn old;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\npmd_t pmdp_invalidate(struct vm_area_struct *vma, unsigned long address,\n\t\t     pmd_t *pmdp)\n{\n\tpmd_t old = pmdp_establish(vma, address, pmdp, pmd_mknotpresent(*pmdp));\n\tflush_pmd_tlb_range(vma, address, address + HPAGE_PMD_SIZE);\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_cache_range",
          "args": [
            "vma",
            "address",
            "address + HPAGE_PMD_SIZE"
          ],
          "line": 2912
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid set_pmd_migration_entry(struct page_vma_mapped_walk *pvmw,\n\t\tstruct page *page)\n{\n\tstruct vm_area_struct *vma = pvmw->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long address = pvmw->address;\n\tpmd_t pmdval;\n\tswp_entry_t entry;\n\tpmd_t pmdswp;\n\n\tif (!(pvmw->pmd && !pvmw->pte))\n\t\treturn;\n\n\tflush_cache_range(vma, address, address + HPAGE_PMD_SIZE);\n\tpmdval = *pvmw->pmd;\n\tpmdp_invalidate(vma, address, pvmw->pmd);\n\tif (pmd_dirty(pmdval))\n\t\tset_page_dirty(page);\n\tentry = make_migration_entry(page, pmd_write(pmdval));\n\tpmdswp = swp_entry_to_pmd(entry);\n\tif (pmd_soft_dirty(pmdval))\n\t\tpmdswp = pmd_swp_mksoft_dirty(pmdswp);\n\tset_pmd_at(mm, address, pvmw->pmd, pmdswp);\n\tpage_remove_rmap(page, true);\n\tput_page(page);\n}"
  },
  {
    "function_name": "split_huge_pages_debugfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "2885-2894",
    "snippet": "static int __init split_huge_pages_debugfs(void)\n{\n\tvoid *ret;\n\n\tret = debugfs_create_file(\"split_huge_pages\", 0200, NULL, NULL,\n\t\t\t&split_huge_pages_fops);\n\tif (!ret)\n\t\tpr_warn(\"Failed to create split_huge_pages in debugfs\");\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to create split_huge_pages in debugfs\""
          ],
          "line": 2892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"split_huge_pages\"",
            "0200",
            "NULL",
            "NULL",
            "&split_huge_pages_fops"
          ],
          "line": 2889
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic int __init split_huge_pages_debugfs(void)\n{\n\tvoid *ret;\n\n\tret = debugfs_create_file(\"split_huge_pages\", 0200, NULL, NULL,\n\t\t\t&split_huge_pages_fops);\n\tif (!ret)\n\t\tpr_warn(\"Failed to create split_huge_pages in debugfs\");\n\treturn 0;\n}"
  },
  {
    "function_name": "split_huge_pages_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "2842-2881",
    "snippet": "static int split_huge_pages_set(void *data, u64 val)\n{\n\tstruct zone *zone;\n\tstruct page *page;\n\tunsigned long pfn, max_zone_pfn;\n\tunsigned long total = 0, split = 0;\n\n\tif (val != 1)\n\t\treturn -EINVAL;\n\n\tfor_each_populated_zone(zone) {\n\t\tmax_zone_pfn = zone_end_pfn(zone);\n\t\tfor (pfn = zone->zone_start_pfn; pfn < max_zone_pfn; pfn++) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\tcontinue;\n\n\t\t\tpage = pfn_to_page(pfn);\n\t\t\tif (!get_page_unless_zero(page))\n\t\t\t\tcontinue;\n\n\t\t\tif (zone != page_zone(page))\n\t\t\t\tgoto next;\n\n\t\t\tif (!PageHead(page) || PageHuge(page) || !PageLRU(page))\n\t\t\t\tgoto next;\n\n\t\t\ttotal++;\n\t\t\tlock_page(page);\n\t\t\tif (!split_huge_page(page))\n\t\t\t\tsplit++;\n\t\t\tunlock_page(page);\nnext:\n\t\t\tput_page(page);\n\t\t}\n\t}\n\n\tpr_info(\"%lu of %lu THP split\\n\", split, total);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%lu of %lu THP split\\n\"",
            "split",
            "total"
          ],
          "line": 2878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 2874
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2872
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "split_huge_page",
          "args": [
            "page"
          ],
          "line": 2870
        },
        "resolved": true,
        "details": {
          "function_name": "deferred_split_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2760-2774",
          "snippet": "void deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 2865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 2865
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageHead",
          "args": [
            "page"
          ],
          "line": 2865
        },
        "resolved": true,
        "details": {
          "function_name": "PageHeadHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1350-1356",
          "snippet": "int PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 2862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page_unless_zero",
          "args": [
            "page"
          ],
          "line": 2859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 2858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 2855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_end_pfn",
          "args": [
            "zone"
          ],
          "line": 2853
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic int split_huge_pages_set(void *data, u64 val)\n{\n\tstruct zone *zone;\n\tstruct page *page;\n\tunsigned long pfn, max_zone_pfn;\n\tunsigned long total = 0, split = 0;\n\n\tif (val != 1)\n\t\treturn -EINVAL;\n\n\tfor_each_populated_zone(zone) {\n\t\tmax_zone_pfn = zone_end_pfn(zone);\n\t\tfor (pfn = zone->zone_start_pfn; pfn < max_zone_pfn; pfn++) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\tcontinue;\n\n\t\t\tpage = pfn_to_page(pfn);\n\t\t\tif (!get_page_unless_zero(page))\n\t\t\t\tcontinue;\n\n\t\t\tif (zone != page_zone(page))\n\t\t\t\tgoto next;\n\n\t\t\tif (!PageHead(page) || PageHuge(page) || !PageLRU(page))\n\t\t\t\tgoto next;\n\n\t\t\ttotal++;\n\t\t\tlock_page(page);\n\t\t\tif (!split_huge_page(page))\n\t\t\t\tsplit++;\n\t\t\tunlock_page(page);\nnext:\n\t\t\tput_page(page);\n\t\t}\n\t}\n\n\tpr_info(\"%lu of %lu THP split\\n\", split, total);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "deferred_split_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "2783-2832",
    "snippet": "static unsigned long deferred_split_scan(struct shrinker *shrink,\n\t\tstruct shrink_control *sc)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(sc->nid);\n\tunsigned long flags;\n\tLIST_HEAD(list), *pos, *next;\n\tstruct page *page;\n\tint split = 0;\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\t/* Take pin on all head pages to avoid freeing them under us */\n\tlist_for_each_safe(pos, next, &pgdata->split_queue) {\n\t\tpage = list_entry((void *)pos, struct page, mapping);\n\t\tpage = compound_head(page);\n\t\tif (get_page_unless_zero(page)) {\n\t\t\tlist_move(page_deferred_list(page), &list);\n\t\t} else {\n\t\t\t/* We lost race with put_compound_page() */\n\t\t\tlist_del_init(page_deferred_list(page));\n\t\t\tpgdata->split_queue_len--;\n\t\t}\n\t\tif (!--sc->nr_to_scan)\n\t\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n\n\tlist_for_each_safe(pos, next, &list) {\n\t\tpage = list_entry((void *)pos, struct page, mapping);\n\t\tif (!trylock_page(page))\n\t\t\tgoto next;\n\t\t/* split_huge_page() removes page from list on success */\n\t\tif (!split_huge_page(page))\n\t\t\tsplit++;\n\t\tunlock_page(page);\nnext:\n\t\tput_page(page);\n\t}\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tlist_splice_tail(&list, &pgdata->split_queue);\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n\n\t/*\n\t * Stop shrinker if we didn't split any page, but the queue is empty.\n\t * This can happen if pages were freed under us.\n\t */\n\tif (!split && list_empty(&pgdata->split_queue))\n\t\treturn SHRINK_STOP;\n\treturn split;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pgdata->split_queue"
          ],
          "line": 2829
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pgdata->split_queue_lock",
            "flags"
          ],
          "line": 2823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_tail",
          "args": [
            "&list",
            "&pgdata->split_queue"
          ],
          "line": 2822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pgdata->split_queue_lock",
            "flags"
          ],
          "line": 2821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 2818
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2816
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "split_huge_page",
          "args": [
            "page"
          ],
          "line": 2814
        },
        "resolved": true,
        "details": {
          "function_name": "deferred_split_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2760-2774",
          "snippet": "void deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 2811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "(void *)pos",
            "structpage",
            "mapping"
          ],
          "line": 2810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "pos",
            "next",
            "&list"
          ],
          "line": 2809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pgdata->split_queue_lock",
            "flags"
          ],
          "line": 2807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "page_deferred_list(page)"
          ],
          "line": 2801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_deferred_list",
          "args": [
            "page"
          ],
          "line": 2801
        },
        "resolved": true,
        "details": {
          "function_name": "page_deferred_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "484-488",
          "snippet": "static inline struct list_head *page_deferred_list(struct page *page)\n{\n\t/* ->lru in the tail pages is occupied by compound_head. */\n\treturn &page[2].deferred_list;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline struct list_head *page_deferred_list(struct page *page)\n{\n\t/* ->lru in the tail pages is occupied by compound_head. */\n\treturn &page[2].deferred_list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "page_deferred_list(page)",
            "&list"
          ],
          "line": 2798
        },
        "resolved": true,
        "details": {
          "function_name": "qlist_move_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/quarantine.c",
          "lines": "72-88",
          "snippet": "static void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}",
          "includes": [
            "#include \"kasan.h\"",
            "#include \"../slab.h\"",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/printk.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hash.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kasan.h\"\n#include \"../slab.h\"\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/shrinker.h>\n#include <linux/printk.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/hash.h>\n#include <linux/gfp.h>\n\nstatic void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_page_unless_zero",
          "args": [
            "page"
          ],
          "line": 2797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 2796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "(void *)pos",
            "structpage",
            "mapping"
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "pos",
            "next",
            "&pgdata->split_queue"
          ],
          "line": 2794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pgdata->split_queue_lock",
            "flags"
          ],
          "line": 2792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "list"
          ],
          "line": 2788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "sc->nid"
          ],
          "line": 2786
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned long deferred_split_scan(struct shrinker *shrink,\n\t\tstruct shrink_control *sc)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(sc->nid);\n\tunsigned long flags;\n\tLIST_HEAD(list), *pos, *next;\n\tstruct page *page;\n\tint split = 0;\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\t/* Take pin on all head pages to avoid freeing them under us */\n\tlist_for_each_safe(pos, next, &pgdata->split_queue) {\n\t\tpage = list_entry((void *)pos, struct page, mapping);\n\t\tpage = compound_head(page);\n\t\tif (get_page_unless_zero(page)) {\n\t\t\tlist_move(page_deferred_list(page), &list);\n\t\t} else {\n\t\t\t/* We lost race with put_compound_page() */\n\t\t\tlist_del_init(page_deferred_list(page));\n\t\t\tpgdata->split_queue_len--;\n\t\t}\n\t\tif (!--sc->nr_to_scan)\n\t\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n\n\tlist_for_each_safe(pos, next, &list) {\n\t\tpage = list_entry((void *)pos, struct page, mapping);\n\t\tif (!trylock_page(page))\n\t\t\tgoto next;\n\t\t/* split_huge_page() removes page from list on success */\n\t\tif (!split_huge_page(page))\n\t\t\tsplit++;\n\t\tunlock_page(page);\nnext:\n\t\tput_page(page);\n\t}\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tlist_splice_tail(&list, &pgdata->split_queue);\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n\n\t/*\n\t * Stop shrinker if we didn't split any page, but the queue is empty.\n\t * This can happen if pages were freed under us.\n\t */\n\tif (!split && list_empty(&pgdata->split_queue))\n\t\treturn SHRINK_STOP;\n\treturn split;\n}"
  },
  {
    "function_name": "deferred_split_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "2776-2781",
    "snippet": "static unsigned long deferred_split_count(struct shrinker *shrink,\n\t\tstruct shrink_control *sc)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(sc->nid);\n\treturn READ_ONCE(pgdata->split_queue_len);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "pgdata->split_queue_len"
          ],
          "line": 2780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "sc->nid"
          ],
          "line": 2779
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned long deferred_split_count(struct shrinker *shrink,\n\t\tstruct shrink_control *sc)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(sc->nid);\n\treturn READ_ONCE(pgdata->split_queue_len);\n}"
  },
  {
    "function_name": "deferred_split_huge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "2760-2774",
    "snippet": "void deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pgdata->split_queue_lock",
            "flags"
          ],
          "line": 2773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "page_deferred_list(page)",
            "&pgdata->split_queue"
          ],
          "line": 2770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_deferred_list",
          "args": [
            "page"
          ],
          "line": 2770
        },
        "resolved": true,
        "details": {
          "function_name": "page_deferred_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "484-488",
          "snippet": "static inline struct list_head *page_deferred_list(struct page *page)\n{\n\t/* ->lru in the tail pages is occupied by compound_head. */\n\treturn &page[2].deferred_list;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline struct list_head *page_deferred_list(struct page *page)\n{\n\t/* ->lru in the tail pages is occupied by compound_head. */\n\treturn &page[2].deferred_list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "THP_DEFERRED_SPLIT_PAGE"
          ],
          "line": 2769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "page_deferred_list(page)"
          ],
          "line": 2768
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pgdata->split_queue_lock",
            "flags"
          ],
          "line": 2767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageTransHuge(page)",
            "page"
          ],
          "line": 2765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 2765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "page_to_nid(page)"
          ],
          "line": 2762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 2762
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}"
  },
  {
    "function_name": "free_transhuge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "2746-2758",
    "snippet": "void free_transhuge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (!list_empty(page_deferred_list(page))) {\n\t\tpgdata->split_queue_len--;\n\t\tlist_del(page_deferred_list(page));\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n\tfree_compound_page(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_compound_page",
          "args": [
            "page"
          ],
          "line": 2757
        },
        "resolved": true,
        "details": {
          "function_name": "free_compound_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "571-574",
          "snippet": "void free_compound_page(struct page *page)\n{\n\t__free_pages_ok(page, compound_order(page));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid free_compound_page(struct page *page)\n{\n\t__free_pages_ok(page, compound_order(page));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pgdata->split_queue_lock",
            "flags"
          ],
          "line": 2756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "page_deferred_list(page)"
          ],
          "line": 2754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_deferred_list",
          "args": [
            "page"
          ],
          "line": 2754
        },
        "resolved": true,
        "details": {
          "function_name": "page_deferred_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "484-488",
          "snippet": "static inline struct list_head *page_deferred_list(struct page *page)\n{\n\t/* ->lru in the tail pages is occupied by compound_head. */\n\treturn &page[2].deferred_list;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline struct list_head *page_deferred_list(struct page *page)\n{\n\t/* ->lru in the tail pages is occupied by compound_head. */\n\treturn &page[2].deferred_list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "page_deferred_list(page)"
          ],
          "line": 2752
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pgdata->split_queue_lock",
            "flags"
          ],
          "line": 2751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "page_to_nid(page)"
          ],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 2748
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid free_transhuge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (!list_empty(page_deferred_list(page))) {\n\t\tpgdata->split_queue_len--;\n\t\tlist_del(page_deferred_list(page));\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n\tfree_compound_page(page);\n}"
  },
  {
    "function_name": "split_huge_page_to_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "2620-2744",
    "snippet": "int split_huge_page_to_list(struct page *page, struct list_head *list)\n{\n\tstruct page *head = compound_head(page);\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(head));\n\tstruct anon_vma *anon_vma = NULL;\n\tstruct address_space *mapping = NULL;\n\tint count, mapcount, extra_pins, ret;\n\tbool mlocked;\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(is_huge_zero_page(page), page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageCompound(page), page);\n\n\tif (PageWriteback(page))\n\t\treturn -EBUSY;\n\n\tif (PageAnon(head)) {\n\t\t/*\n\t\t * The caller does not necessarily hold an mmap_sem that would\n\t\t * prevent the anon_vma disappearing so we first we take a\n\t\t * reference to it and then lock the anon_vma for write. This\n\t\t * is similar to page_lock_anon_vma_read except the write lock\n\t\t * is taken to serialise against parallel split or collapse\n\t\t * operations.\n\t\t */\n\t\tanon_vma = page_get_anon_vma(head);\n\t\tif (!anon_vma) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tmapping = NULL;\n\t\tanon_vma_lock_write(anon_vma);\n\t} else {\n\t\tmapping = head->mapping;\n\n\t\t/* Truncated ? */\n\t\tif (!mapping) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tanon_vma = NULL;\n\t\ti_mmap_lock_read(mapping);\n\t}\n\n\t/*\n\t * Racy check if we can split the page, before freeze_page() will\n\t * split PMDs\n\t */\n\tif (!can_split_huge_page(head, &extra_pins)) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\tmlocked = PageMlocked(page);\n\tfreeze_page(head);\n\tVM_BUG_ON_PAGE(compound_mapcount(head), head);\n\n\t/* Make sure the page is not on per-CPU pagevec as it takes pin */\n\tif (mlocked)\n\t\tlru_add_drain();\n\n\t/* prevent PageLRU to go away from under us, and freeze lru stats */\n\tspin_lock_irqsave(zone_lru_lock(page_zone(head)), flags);\n\n\tif (mapping) {\n\t\tXA_STATE(xas, &mapping->i_pages, page_index(head));\n\n\t\t/*\n\t\t * Check if the head page is present in page cache.\n\t\t * We assume all tail are present too, if head is there.\n\t\t */\n\t\txa_lock(&mapping->i_pages);\n\t\tif (xas_load(&xas) != head)\n\t\t\tgoto fail;\n\t}\n\n\t/* Prevent deferred_split_scan() touching ->_refcount */\n\tspin_lock(&pgdata->split_queue_lock);\n\tcount = page_count(head);\n\tmapcount = total_mapcount(head);\n\tif (!mapcount && page_ref_freeze(head, 1 + extra_pins)) {\n\t\tif (!list_empty(page_deferred_list(head))) {\n\t\t\tpgdata->split_queue_len--;\n\t\t\tlist_del(page_deferred_list(head));\n\t\t}\n\t\tif (mapping)\n\t\t\t__dec_node_page_state(page, NR_SHMEM_THPS);\n\t\tspin_unlock(&pgdata->split_queue_lock);\n\t\t__split_huge_page(page, list, flags);\n\t\tif (PageSwapCache(head)) {\n\t\t\tswp_entry_t entry = { .val = page_private(head) };\n\n\t\t\tret = split_swap_cluster(entry);\n\t\t} else\n\t\t\tret = 0;\n\t} else {\n\t\tif (IS_ENABLED(CONFIG_DEBUG_VM) && mapcount) {\n\t\t\tpr_alert(\"total_mapcount: %u, page_count(): %u\\n\",\n\t\t\t\t\tmapcount, count);\n\t\t\tif (PageTail(page))\n\t\t\t\tdump_page(head, NULL);\n\t\t\tdump_page(page, \"total_mapcount(head) > 0\");\n\t\t\tBUG();\n\t\t}\n\t\tspin_unlock(&pgdata->split_queue_lock);\nfail:\t\tif (mapping)\n\t\t\txa_unlock(&mapping->i_pages);\n\t\tspin_unlock_irqrestore(zone_lru_lock(page_zone(head)), flags);\n\t\tunfreeze_page(head);\n\t\tret = -EBUSY;\n\t}\n\nout_unlock:\n\tif (anon_vma) {\n\t\tanon_vma_unlock_write(anon_vma);\n\t\tput_anon_vma(anon_vma);\n\t}\n\tif (mapping)\n\t\ti_mmap_unlock_read(mapping);\nout:\n\tcount_vm_event(!ret ? THP_SPLIT_PAGE : THP_SPLIT_PAGE_FAILED);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "!ret ? THP_SPLIT_PAGE : THP_SPLIT_PAGE_FAILED"
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_mmap_unlock_read",
          "args": [
            "mapping"
          ],
          "line": 2740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_anon_vma",
          "args": [
            "anon_vma"
          ],
          "line": 2737
        },
        "resolved": true,
        "details": {
          "function_name": "__put_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1758-1765",
          "snippet": "void __put_anon_vma(struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *root = anon_vma->root;\n\n\tanon_vma_free(anon_vma);\n\tif (root != anon_vma && atomic_dec_and_test(&root->refcount))\n\t\tanon_vma_free(root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid __put_anon_vma(struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *root = anon_vma->root;\n\n\tanon_vma_free(anon_vma);\n\tif (root != anon_vma && atomic_dec_and_test(&root->refcount))\n\t\tanon_vma_free(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_vma_unlock_write",
          "args": [
            "anon_vma"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unfreeze_page",
          "args": [
            "head"
          ],
          "line": 2730
        },
        "resolved": true,
        "details": {
          "function_name": "unfreeze_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2368-2377",
          "snippet": "static void unfreeze_page(struct page *page)\n{\n\tint i;\n\tif (PageTransHuge(page)) {\n\t\tremove_migration_ptes(page, page, true);\n\t} else {\n\t\tfor (i = 0; i < HPAGE_PMD_NR; i++)\n\t\t\tremove_migration_ptes(page + i, page + i, true);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void unfreeze_page(struct page *page)\n{\n\tint i;\n\tif (PageTransHuge(page)) {\n\t\tremove_migration_ptes(page, page, true);\n\t} else {\n\t\tfor (i = 0; i < HPAGE_PMD_NR; i++)\n\t\t\tremove_migration_ptes(page + i, page + i, true);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "zone_lru_lock(page_zone(head))",
            "flags"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_lru_lock",
          "args": [
            "page_zone(head)"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "head"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_unlock",
          "args": [
            "&mapping->i_pages"
          ],
          "line": 2728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pgdata->split_queue_lock"
          ],
          "line": 2726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_page",
          "args": [
            "page",
            "\"total_mapcount(head) > 0\""
          ],
          "line": 2723
        },
        "resolved": true,
        "details": {
          "function_name": "dump_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/debug.c",
          "lines": "91-95",
          "snippet": "void dump_page(struct page *page, const char *reason)\n{\n\t__dump_page(page, reason);\n\tdump_page_owner(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/migrate.h>",
            "#include <trace/events/mmflags.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/ctype.h>\n#include <linux/page_owner.h>\n#include <linux/migrate.h>\n#include <trace/events/mmflags.h>\n#include <linux/memcontrol.h>\n#include <linux/trace_events.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid dump_page(struct page *page, const char *reason)\n{\n\t__dump_page(page, reason);\n\tdump_page_owner(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageTail",
          "args": [
            "page"
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"total_mapcount: %u, page_count(): %u\\n\"",
            "mapcount",
            "count"
          ],
          "line": 2719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_DEBUG_VM"
          ],
          "line": 2718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split_swap_cluster",
          "args": [
            "entry"
          ],
          "line": 2714
        },
        "resolved": true,
        "details": {
          "function_name": "split_swap_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1273-1286",
          "snippet": "int split_swap_cluster(swp_entry_t entry)\n{\n\tstruct swap_info_struct *si;\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset = swp_offset(entry);\n\n\tsi = _swap_info_get(entry);\n\tif (!si)\n\t\treturn -EBUSY;\n\tci = lock_cluster(si, offset);\n\tcluster_clear_huge(ci);\n\tunlock_cluster(ci);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nint split_swap_cluster(swp_entry_t entry)\n{\n\tstruct swap_info_struct *si;\n\tstruct swap_cluster_info *ci;\n\tunsigned long offset = swp_offset(entry);\n\n\tsi = _swap_info_get(entry);\n\tif (!si)\n\t\treturn -EBUSY;\n\tci = lock_cluster(si, offset);\n\tcluster_clear_huge(ci);\n\tunlock_cluster(ci);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "head"
          ],
          "line": 2712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "head"
          ],
          "line": 2711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__split_huge_page",
          "args": [
            "page",
            "list",
            "flags"
          ],
          "line": 2710
        },
        "resolved": true,
        "details": {
          "function_name": "__split_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2441-2503",
          "snippet": "static void __split_huge_page(struct page *page, struct list_head *list,\n\t\tunsigned long flags)\n{\n\tstruct page *head = compound_head(page);\n\tstruct zone *zone = page_zone(head);\n\tstruct lruvec *lruvec;\n\tpgoff_t end = -1;\n\tint i;\n\n\tlruvec = mem_cgroup_page_lruvec(head, zone->zone_pgdat);\n\n\t/* complete memcg works before add pages to LRU */\n\tmem_cgroup_split_huge_fixup(head);\n\n\tif (!PageAnon(page))\n\t\tend = DIV_ROUND_UP(i_size_read(head->mapping->host), PAGE_SIZE);\n\n\tfor (i = HPAGE_PMD_NR - 1; i >= 1; i--) {\n\t\t__split_huge_page_tail(head, i, lruvec, list);\n\t\t/* Some pages can be beyond i_size: drop them from page cache */\n\t\tif (head[i].index >= end) {\n\t\t\tClearPageDirty(head + i);\n\t\t\t__delete_from_page_cache(head + i, NULL);\n\t\t\tif (IS_ENABLED(CONFIG_SHMEM) && PageSwapBacked(head))\n\t\t\t\tshmem_uncharge(head->mapping->host, 1);\n\t\t\tput_page(head + i);\n\t\t}\n\t}\n\n\tClearPageCompound(head);\n\t/* See comment in __split_huge_page_tail() */\n\tif (PageAnon(head)) {\n\t\t/* Additional pin to swap cache */\n\t\tif (PageSwapCache(head))\n\t\t\tpage_ref_add(head, 2);\n\t\telse\n\t\t\tpage_ref_inc(head);\n\t} else {\n\t\t/* Additional pin to page cache */\n\t\tpage_ref_add(head, 2);\n\t\txa_unlock(&head->mapping->i_pages);\n\t}\n\n\tspin_unlock_irqrestore(zone_lru_lock(page_zone(head)), flags);\n\n\tunfreeze_page(head);\n\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tstruct page *subpage = head + i;\n\t\tif (subpage == page)\n\t\t\tcontinue;\n\t\tunlock_page(subpage);\n\n\t\t/*\n\t\t * Subpages may be freed if there wasn't any mapping\n\t\t * like if add_to_swap() is running on a lru page that\n\t\t * had its mapping zapped. And freeing these pages\n\t\t * requires taking the lru_lock so we do the put_page\n\t\t * of the tail pages after the split is complete.\n\t\t */\n\t\tput_page(subpage);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void __split_huge_page(struct page *page, struct list_head *list,\n\t\tunsigned long flags)\n{\n\tstruct page *head = compound_head(page);\n\tstruct zone *zone = page_zone(head);\n\tstruct lruvec *lruvec;\n\tpgoff_t end = -1;\n\tint i;\n\n\tlruvec = mem_cgroup_page_lruvec(head, zone->zone_pgdat);\n\n\t/* complete memcg works before add pages to LRU */\n\tmem_cgroup_split_huge_fixup(head);\n\n\tif (!PageAnon(page))\n\t\tend = DIV_ROUND_UP(i_size_read(head->mapping->host), PAGE_SIZE);\n\n\tfor (i = HPAGE_PMD_NR - 1; i >= 1; i--) {\n\t\t__split_huge_page_tail(head, i, lruvec, list);\n\t\t/* Some pages can be beyond i_size: drop them from page cache */\n\t\tif (head[i].index >= end) {\n\t\t\tClearPageDirty(head + i);\n\t\t\t__delete_from_page_cache(head + i, NULL);\n\t\t\tif (IS_ENABLED(CONFIG_SHMEM) && PageSwapBacked(head))\n\t\t\t\tshmem_uncharge(head->mapping->host, 1);\n\t\t\tput_page(head + i);\n\t\t}\n\t}\n\n\tClearPageCompound(head);\n\t/* See comment in __split_huge_page_tail() */\n\tif (PageAnon(head)) {\n\t\t/* Additional pin to swap cache */\n\t\tif (PageSwapCache(head))\n\t\t\tpage_ref_add(head, 2);\n\t\telse\n\t\t\tpage_ref_inc(head);\n\t} else {\n\t\t/* Additional pin to page cache */\n\t\tpage_ref_add(head, 2);\n\t\txa_unlock(&head->mapping->i_pages);\n\t}\n\n\tspin_unlock_irqrestore(zone_lru_lock(page_zone(head)), flags);\n\n\tunfreeze_page(head);\n\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tstruct page *subpage = head + i;\n\t\tif (subpage == page)\n\t\t\tcontinue;\n\t\tunlock_page(subpage);\n\n\t\t/*\n\t\t * Subpages may be freed if there wasn't any mapping\n\t\t * like if add_to_swap() is running on a lru page that\n\t\t * had its mapping zapped. And freeing these pages\n\t\t * requires taking the lru_lock so we do the put_page\n\t\t * of the tail pages after the split is complete.\n\t\t */\n\t\tput_page(subpage);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pgdata->split_queue_lock"
          ],
          "line": 2709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dec_node_page_state",
          "args": [
            "page",
            "NR_SHMEM_THPS"
          ],
          "line": 2708
        },
        "resolved": true,
        "details": {
          "function_name": "__dec_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "460-463",
          "snippet": "void __dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__dec_node_state(page_pgdat(page), item);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__dec_node_state(page_pgdat(page), item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "page_deferred_list(head)"
          ],
          "line": 2705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_deferred_list",
          "args": [
            "head"
          ],
          "line": 2705
        },
        "resolved": true,
        "details": {
          "function_name": "page_deferred_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "484-488",
          "snippet": "static inline struct list_head *page_deferred_list(struct page *page)\n{\n\t/* ->lru in the tail pages is occupied by compound_head. */\n\treturn &page[2].deferred_list;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline struct list_head *page_deferred_list(struct page *page)\n{\n\t/* ->lru in the tail pages is occupied by compound_head. */\n\treturn &page[2].deferred_list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "page_deferred_list(head)"
          ],
          "line": 2703
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_ref_freeze",
          "args": [
            "head",
            "1 + extra_pins"
          ],
          "line": 2702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "total_mapcount",
          "args": [
            "head"
          ],
          "line": 2701
        },
        "resolved": true,
        "details": {
          "function_name": "total_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2505-2526",
          "snippet": "int total_mapcount(struct page *page)\n{\n\tint i, compound, ret;\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) + 1;\n\n\tcompound = compound_mapcount(page);\n\tif (PageHuge(page))\n\t\treturn compound;\n\tret = compound;\n\tfor (i = 0; i < HPAGE_PMD_NR; i++)\n\t\tret += atomic_read(&page[i]._mapcount) + 1;\n\t/* File pages has compound_mapcount included in _mapcount */\n\tif (!PageAnon(page))\n\t\treturn ret - compound * HPAGE_PMD_NR;\n\tif (PageDoubleMap(page))\n\t\tret -= HPAGE_PMD_NR;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint total_mapcount(struct page *page)\n{\n\tint i, compound, ret;\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) + 1;\n\n\tcompound = compound_mapcount(page);\n\tif (PageHuge(page))\n\t\treturn compound;\n\tret = compound;\n\tfor (i = 0; i < HPAGE_PMD_NR; i++)\n\t\tret += atomic_read(&page[i]._mapcount) + 1;\n\t/* File pages has compound_mapcount included in _mapcount */\n\tif (!PageAnon(page))\n\t\treturn ret - compound * HPAGE_PMD_NR;\n\tif (PageDoubleMap(page))\n\t\tret -= HPAGE_PMD_NR;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "head"
          ],
          "line": 2700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pgdata->split_queue_lock"
          ],
          "line": 2699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_load",
          "args": [
            "&xas"
          ],
          "line": 2694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_lock",
          "args": [
            "&mapping->i_pages"
          ],
          "line": 2693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "page_index(head)"
          ],
          "line": 2687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_index",
          "args": [
            "head"
          ],
          "line": 2687
        },
        "resolved": true,
        "details": {
          "function_name": "__basepage_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1358-1373",
          "snippet": "pgoff_t __basepage_index(struct page *page)\n{\n\tstruct page *page_head = compound_head(page);\n\tpgoff_t index = page_index(page_head);\n\tunsigned long compound_idx;\n\n\tif (!PageHuge(page_head))\n\t\treturn page_index(page);\n\n\tif (compound_order(page_head) >= MAX_ORDER)\n\t\tcompound_idx = page_to_pfn(page) - page_to_pfn(page_head);\n\telse\n\t\tcompound_idx = page - page_head;\n\n\treturn (index << compound_order(page_head)) + compound_idx;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\npgoff_t __basepage_index(struct page *page)\n{\n\tstruct page *page_head = compound_head(page);\n\tpgoff_t index = page_index(page_head);\n\tunsigned long compound_idx;\n\n\tif (!PageHuge(page_head))\n\t\treturn page_index(page);\n\n\tif (compound_order(page_head) >= MAX_ORDER)\n\t\tcompound_idx = page_to_pfn(page) - page_to_pfn(page_head);\n\telse\n\t\tcompound_idx = page - page_head;\n\n\treturn (index << compound_order(page_head)) + compound_idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "zone_lru_lock(page_zone(head))",
            "flags"
          ],
          "line": 2684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_lru_lock",
          "args": [
            "page_zone(head)"
          ],
          "line": 2684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "head"
          ],
          "line": 2684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_add_drain",
          "args": [],
          "line": 2681
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "compound_mapcount(head)",
            "head"
          ],
          "line": 2677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_mapcount",
          "args": [
            "head"
          ],
          "line": 2677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageMlocked",
          "args": [
            "page"
          ],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "can_split_huge_page",
          "args": [
            "head",
            "&extra_pins"
          ],
          "line": 2670
        },
        "resolved": true,
        "details": {
          "function_name": "can_split_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2587-2599",
          "snippet": "bool can_split_huge_page(struct page *page, int *pextra_pins)\n{\n\tint extra_pins;\n\n\t/* Additional pins from page cache */\n\tif (PageAnon(page))\n\t\textra_pins = PageSwapCache(page) ? HPAGE_PMD_NR : 0;\n\telse\n\t\textra_pins = HPAGE_PMD_NR;\n\tif (pextra_pins)\n\t\t*pextra_pins = extra_pins;\n\treturn total_mapcount(page) == page_count(page) - extra_pins - 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nbool can_split_huge_page(struct page *page, int *pextra_pins)\n{\n\tint extra_pins;\n\n\t/* Additional pins from page cache */\n\tif (PageAnon(page))\n\t\textra_pins = PageSwapCache(page) ? HPAGE_PMD_NR : 0;\n\telse\n\t\textra_pins = HPAGE_PMD_NR;\n\tif (pextra_pins)\n\t\t*pextra_pins = extra_pins;\n\treturn total_mapcount(page) == page_count(page) - extra_pins - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_mmap_lock_read",
          "args": [
            "mapping"
          ],
          "line": 2663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_lock_write",
          "args": [
            "anon_vma"
          ],
          "line": 2652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_get_anon_vma",
          "args": [
            "head"
          ],
          "line": 2646
        },
        "resolved": true,
        "details": {
          "function_name": "page_get_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "464-498",
          "snippet": "struct anon_vma *page_get_anon_vma(struct page *page)\n{\n\tstruct anon_vma *anon_vma = NULL;\n\tunsigned long anon_mapping;\n\n\trcu_read_lock();\n\tanon_mapping = (unsigned long)READ_ONCE(page->mapping);\n\tif ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\tgoto out;\n\tif (!page_mapped(page))\n\t\tgoto out;\n\n\tanon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);\n\tif (!atomic_inc_not_zero(&anon_vma->refcount)) {\n\t\tanon_vma = NULL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If this page is still mapped, then its anon_vma cannot have been\n\t * freed.  But if it has been unmapped, we have no security against the\n\t * anon_vma structure being freed and reused (for another anon_vma:\n\t * SLAB_TYPESAFE_BY_RCU guarantees that - so the atomic_inc_not_zero()\n\t * above cannot corrupt).\n\t */\n\tif (!page_mapped(page)) {\n\t\trcu_read_unlock();\n\t\tput_anon_vma(anon_vma);\n\t\treturn NULL;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn anon_vma;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstruct anon_vma *page_get_anon_vma(struct page *page)\n{\n\tstruct anon_vma *anon_vma = NULL;\n\tunsigned long anon_mapping;\n\n\trcu_read_lock();\n\tanon_mapping = (unsigned long)READ_ONCE(page->mapping);\n\tif ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\tgoto out;\n\tif (!page_mapped(page))\n\t\tgoto out;\n\n\tanon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);\n\tif (!atomic_inc_not_zero(&anon_vma->refcount)) {\n\t\tanon_vma = NULL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If this page is still mapped, then its anon_vma cannot have been\n\t * freed.  But if it has been unmapped, we have no security against the\n\t * anon_vma structure being freed and reused (for another anon_vma:\n\t * SLAB_TYPESAFE_BY_RCU guarantees that - so the atomic_inc_not_zero()\n\t * above cannot corrupt).\n\t */\n\tif (!page_mapped(page)) {\n\t\trcu_read_unlock();\n\t\tput_anon_vma(anon_vma);\n\t\treturn NULL;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn anon_vma;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "head"
          ],
          "line": 2637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageCompound(page)",
            "page"
          ],
          "line": 2632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 2632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 2631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 2631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "is_huge_zero_page(page)",
            "page"
          ],
          "line": 2630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_huge_zero_page",
          "args": [
            "page"
          ],
          "line": 2630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "page_to_nid(head)"
          ],
          "line": 2623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "head"
          ],
          "line": 2623
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 2622
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint split_huge_page_to_list(struct page *page, struct list_head *list)\n{\n\tstruct page *head = compound_head(page);\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(head));\n\tstruct anon_vma *anon_vma = NULL;\n\tstruct address_space *mapping = NULL;\n\tint count, mapcount, extra_pins, ret;\n\tbool mlocked;\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(is_huge_zero_page(page), page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageCompound(page), page);\n\n\tif (PageWriteback(page))\n\t\treturn -EBUSY;\n\n\tif (PageAnon(head)) {\n\t\t/*\n\t\t * The caller does not necessarily hold an mmap_sem that would\n\t\t * prevent the anon_vma disappearing so we first we take a\n\t\t * reference to it and then lock the anon_vma for write. This\n\t\t * is similar to page_lock_anon_vma_read except the write lock\n\t\t * is taken to serialise against parallel split or collapse\n\t\t * operations.\n\t\t */\n\t\tanon_vma = page_get_anon_vma(head);\n\t\tif (!anon_vma) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tmapping = NULL;\n\t\tanon_vma_lock_write(anon_vma);\n\t} else {\n\t\tmapping = head->mapping;\n\n\t\t/* Truncated ? */\n\t\tif (!mapping) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tanon_vma = NULL;\n\t\ti_mmap_lock_read(mapping);\n\t}\n\n\t/*\n\t * Racy check if we can split the page, before freeze_page() will\n\t * split PMDs\n\t */\n\tif (!can_split_huge_page(head, &extra_pins)) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\tmlocked = PageMlocked(page);\n\tfreeze_page(head);\n\tVM_BUG_ON_PAGE(compound_mapcount(head), head);\n\n\t/* Make sure the page is not on per-CPU pagevec as it takes pin */\n\tif (mlocked)\n\t\tlru_add_drain();\n\n\t/* prevent PageLRU to go away from under us, and freeze lru stats */\n\tspin_lock_irqsave(zone_lru_lock(page_zone(head)), flags);\n\n\tif (mapping) {\n\t\tXA_STATE(xas, &mapping->i_pages, page_index(head));\n\n\t\t/*\n\t\t * Check if the head page is present in page cache.\n\t\t * We assume all tail are present too, if head is there.\n\t\t */\n\t\txa_lock(&mapping->i_pages);\n\t\tif (xas_load(&xas) != head)\n\t\t\tgoto fail;\n\t}\n\n\t/* Prevent deferred_split_scan() touching ->_refcount */\n\tspin_lock(&pgdata->split_queue_lock);\n\tcount = page_count(head);\n\tmapcount = total_mapcount(head);\n\tif (!mapcount && page_ref_freeze(head, 1 + extra_pins)) {\n\t\tif (!list_empty(page_deferred_list(head))) {\n\t\t\tpgdata->split_queue_len--;\n\t\t\tlist_del(page_deferred_list(head));\n\t\t}\n\t\tif (mapping)\n\t\t\t__dec_node_page_state(page, NR_SHMEM_THPS);\n\t\tspin_unlock(&pgdata->split_queue_lock);\n\t\t__split_huge_page(page, list, flags);\n\t\tif (PageSwapCache(head)) {\n\t\t\tswp_entry_t entry = { .val = page_private(head) };\n\n\t\t\tret = split_swap_cluster(entry);\n\t\t} else\n\t\t\tret = 0;\n\t} else {\n\t\tif (IS_ENABLED(CONFIG_DEBUG_VM) && mapcount) {\n\t\t\tpr_alert(\"total_mapcount: %u, page_count(): %u\\n\",\n\t\t\t\t\tmapcount, count);\n\t\t\tif (PageTail(page))\n\t\t\t\tdump_page(head, NULL);\n\t\t\tdump_page(page, \"total_mapcount(head) > 0\");\n\t\t\tBUG();\n\t\t}\n\t\tspin_unlock(&pgdata->split_queue_lock);\nfail:\t\tif (mapping)\n\t\t\txa_unlock(&mapping->i_pages);\n\t\tspin_unlock_irqrestore(zone_lru_lock(page_zone(head)), flags);\n\t\tunfreeze_page(head);\n\t\tret = -EBUSY;\n\t}\n\nout_unlock:\n\tif (anon_vma) {\n\t\tanon_vma_unlock_write(anon_vma);\n\t\tput_anon_vma(anon_vma);\n\t}\n\tif (mapping)\n\t\ti_mmap_unlock_read(mapping);\nout:\n\tcount_vm_event(!ret ? THP_SPLIT_PAGE : THP_SPLIT_PAGE_FAILED);\n\treturn ret;\n}"
  },
  {
    "function_name": "can_split_huge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "2587-2599",
    "snippet": "bool can_split_huge_page(struct page *page, int *pextra_pins)\n{\n\tint extra_pins;\n\n\t/* Additional pins from page cache */\n\tif (PageAnon(page))\n\t\textra_pins = PageSwapCache(page) ? HPAGE_PMD_NR : 0;\n\telse\n\t\textra_pins = HPAGE_PMD_NR;\n\tif (pextra_pins)\n\t\t*pextra_pins = extra_pins;\n\treturn total_mapcount(page) == page_count(page) - extra_pins - 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 2598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "total_mapcount",
          "args": [
            "page"
          ],
          "line": 2598
        },
        "resolved": true,
        "details": {
          "function_name": "total_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2505-2526",
          "snippet": "int total_mapcount(struct page *page)\n{\n\tint i, compound, ret;\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) + 1;\n\n\tcompound = compound_mapcount(page);\n\tif (PageHuge(page))\n\t\treturn compound;\n\tret = compound;\n\tfor (i = 0; i < HPAGE_PMD_NR; i++)\n\t\tret += atomic_read(&page[i]._mapcount) + 1;\n\t/* File pages has compound_mapcount included in _mapcount */\n\tif (!PageAnon(page))\n\t\treturn ret - compound * HPAGE_PMD_NR;\n\tif (PageDoubleMap(page))\n\t\tret -= HPAGE_PMD_NR;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint total_mapcount(struct page *page)\n{\n\tint i, compound, ret;\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) + 1;\n\n\tcompound = compound_mapcount(page);\n\tif (PageHuge(page))\n\t\treturn compound;\n\tret = compound;\n\tfor (i = 0; i < HPAGE_PMD_NR; i++)\n\t\tret += atomic_read(&page[i]._mapcount) + 1;\n\t/* File pages has compound_mapcount included in _mapcount */\n\tif (!PageAnon(page))\n\t\treturn ret - compound * HPAGE_PMD_NR;\n\tif (PageDoubleMap(page))\n\t\tret -= HPAGE_PMD_NR;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 2593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 2592
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nbool can_split_huge_page(struct page *page, int *pextra_pins)\n{\n\tint extra_pins;\n\n\t/* Additional pins from page cache */\n\tif (PageAnon(page))\n\t\textra_pins = PageSwapCache(page) ? HPAGE_PMD_NR : 0;\n\telse\n\t\textra_pins = HPAGE_PMD_NR;\n\tif (pextra_pins)\n\t\t*pextra_pins = extra_pins;\n\treturn total_mapcount(page) == page_count(page) - extra_pins - 1;\n}"
  },
  {
    "function_name": "page_trans_huge_mapcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "2552-2584",
    "snippet": "int page_trans_huge_mapcount(struct page *page, int *total_mapcount)\n{\n\tint i, ret, _total_mapcount, mapcount;\n\n\t/* hugetlbfs shouldn't call it */\n\tVM_BUG_ON_PAGE(PageHuge(page), page);\n\n\tif (likely(!PageTransCompound(page))) {\n\t\tmapcount = atomic_read(&page->_mapcount) + 1;\n\t\tif (total_mapcount)\n\t\t\t*total_mapcount = mapcount;\n\t\treturn mapcount;\n\t}\n\n\tpage = compound_head(page);\n\n\t_total_mapcount = ret = 0;\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tmapcount = atomic_read(&page[i]._mapcount) + 1;\n\t\tret = max(ret, mapcount);\n\t\t_total_mapcount += mapcount;\n\t}\n\tif (PageDoubleMap(page)) {\n\t\tret -= 1;\n\t\t_total_mapcount -= HPAGE_PMD_NR;\n\t}\n\tmapcount = compound_mapcount(page);\n\tret += mapcount;\n\t_total_mapcount += mapcount;\n\tif (total_mapcount)\n\t\t*total_mapcount = _total_mapcount;\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compound_mapcount",
          "args": [
            "page"
          ],
          "line": 2578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDoubleMap",
          "args": [
            "page"
          ],
          "line": 2574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "ret",
            "mapcount"
          ],
          "line": 2571
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&page[i]._mapcount"
          ],
          "line": 2570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&page->_mapcount"
          ],
          "line": 2560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!PageTransCompound(page)"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "page"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageHuge(page)",
            "page"
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 2557
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint page_trans_huge_mapcount(struct page *page, int *total_mapcount)\n{\n\tint i, ret, _total_mapcount, mapcount;\n\n\t/* hugetlbfs shouldn't call it */\n\tVM_BUG_ON_PAGE(PageHuge(page), page);\n\n\tif (likely(!PageTransCompound(page))) {\n\t\tmapcount = atomic_read(&page->_mapcount) + 1;\n\t\tif (total_mapcount)\n\t\t\t*total_mapcount = mapcount;\n\t\treturn mapcount;\n\t}\n\n\tpage = compound_head(page);\n\n\t_total_mapcount = ret = 0;\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tmapcount = atomic_read(&page[i]._mapcount) + 1;\n\t\tret = max(ret, mapcount);\n\t\t_total_mapcount += mapcount;\n\t}\n\tif (PageDoubleMap(page)) {\n\t\tret -= 1;\n\t\t_total_mapcount -= HPAGE_PMD_NR;\n\t}\n\tmapcount = compound_mapcount(page);\n\tret += mapcount;\n\t_total_mapcount += mapcount;\n\tif (total_mapcount)\n\t\t*total_mapcount = _total_mapcount;\n\treturn ret;\n}"
  },
  {
    "function_name": "total_mapcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "2505-2526",
    "snippet": "int total_mapcount(struct page *page)\n{\n\tint i, compound, ret;\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) + 1;\n\n\tcompound = compound_mapcount(page);\n\tif (PageHuge(page))\n\t\treturn compound;\n\tret = compound;\n\tfor (i = 0; i < HPAGE_PMD_NR; i++)\n\t\tret += atomic_read(&page[i]._mapcount) + 1;\n\t/* File pages has compound_mapcount included in _mapcount */\n\tif (!PageAnon(page))\n\t\treturn ret - compound * HPAGE_PMD_NR;\n\tif (PageDoubleMap(page))\n\t\tret -= HPAGE_PMD_NR;\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PageDoubleMap",
          "args": [
            "page"
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&page[i]._mapcount"
          ],
          "line": 2519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 2515
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_mapcount",
          "args": [
            "page"
          ],
          "line": 2514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&page->_mapcount"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!PageCompound(page)"
          ],
          "line": 2511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 2511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageTail(page)",
            "page"
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTail",
          "args": [
            "page"
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint total_mapcount(struct page *page)\n{\n\tint i, compound, ret;\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) + 1;\n\n\tcompound = compound_mapcount(page);\n\tif (PageHuge(page))\n\t\treturn compound;\n\tret = compound;\n\tfor (i = 0; i < HPAGE_PMD_NR; i++)\n\t\tret += atomic_read(&page[i]._mapcount) + 1;\n\t/* File pages has compound_mapcount included in _mapcount */\n\tif (!PageAnon(page))\n\t\treturn ret - compound * HPAGE_PMD_NR;\n\tif (PageDoubleMap(page))\n\t\tret -= HPAGE_PMD_NR;\n\treturn ret;\n}"
  },
  {
    "function_name": "__split_huge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "2441-2503",
    "snippet": "static void __split_huge_page(struct page *page, struct list_head *list,\n\t\tunsigned long flags)\n{\n\tstruct page *head = compound_head(page);\n\tstruct zone *zone = page_zone(head);\n\tstruct lruvec *lruvec;\n\tpgoff_t end = -1;\n\tint i;\n\n\tlruvec = mem_cgroup_page_lruvec(head, zone->zone_pgdat);\n\n\t/* complete memcg works before add pages to LRU */\n\tmem_cgroup_split_huge_fixup(head);\n\n\tif (!PageAnon(page))\n\t\tend = DIV_ROUND_UP(i_size_read(head->mapping->host), PAGE_SIZE);\n\n\tfor (i = HPAGE_PMD_NR - 1; i >= 1; i--) {\n\t\t__split_huge_page_tail(head, i, lruvec, list);\n\t\t/* Some pages can be beyond i_size: drop them from page cache */\n\t\tif (head[i].index >= end) {\n\t\t\tClearPageDirty(head + i);\n\t\t\t__delete_from_page_cache(head + i, NULL);\n\t\t\tif (IS_ENABLED(CONFIG_SHMEM) && PageSwapBacked(head))\n\t\t\t\tshmem_uncharge(head->mapping->host, 1);\n\t\t\tput_page(head + i);\n\t\t}\n\t}\n\n\tClearPageCompound(head);\n\t/* See comment in __split_huge_page_tail() */\n\tif (PageAnon(head)) {\n\t\t/* Additional pin to swap cache */\n\t\tif (PageSwapCache(head))\n\t\t\tpage_ref_add(head, 2);\n\t\telse\n\t\t\tpage_ref_inc(head);\n\t} else {\n\t\t/* Additional pin to page cache */\n\t\tpage_ref_add(head, 2);\n\t\txa_unlock(&head->mapping->i_pages);\n\t}\n\n\tspin_unlock_irqrestore(zone_lru_lock(page_zone(head)), flags);\n\n\tunfreeze_page(head);\n\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tstruct page *subpage = head + i;\n\t\tif (subpage == page)\n\t\t\tcontinue;\n\t\tunlock_page(subpage);\n\n\t\t/*\n\t\t * Subpages may be freed if there wasn't any mapping\n\t\t * like if add_to_swap() is running on a lru page that\n\t\t * had its mapping zapped. And freeing these pages\n\t\t * requires taking the lru_lock so we do the put_page\n\t\t * of the tail pages after the split is complete.\n\t\t */\n\t\tput_page(subpage);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "subpage"
          ],
          "line": 2501
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "subpage"
          ],
          "line": 2492
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unfreeze_page",
          "args": [
            "head"
          ],
          "line": 2486
        },
        "resolved": true,
        "details": {
          "function_name": "unfreeze_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2368-2377",
          "snippet": "static void unfreeze_page(struct page *page)\n{\n\tint i;\n\tif (PageTransHuge(page)) {\n\t\tremove_migration_ptes(page, page, true);\n\t} else {\n\t\tfor (i = 0; i < HPAGE_PMD_NR; i++)\n\t\t\tremove_migration_ptes(page + i, page + i, true);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void unfreeze_page(struct page *page)\n{\n\tint i;\n\tif (PageTransHuge(page)) {\n\t\tremove_migration_ptes(page, page, true);\n\t} else {\n\t\tfor (i = 0; i < HPAGE_PMD_NR; i++)\n\t\t\tremove_migration_ptes(page + i, page + i, true);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "zone_lru_lock(page_zone(head))",
            "flags"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_lru_lock",
          "args": [
            "page_zone(head)"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "head"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_unlock",
          "args": [
            "&head->mapping->i_pages"
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_add",
          "args": [
            "head",
            "2"
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_inc",
          "args": [
            "head"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_add",
          "args": [
            "head",
            "2"
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "head"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "head"
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageCompound",
          "args": [
            "head"
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shmem_uncharge",
          "args": [
            "head->mapping->host",
            "1"
          ],
          "line": 2465
        },
        "resolved": true,
        "details": {
          "function_name": "shmem_uncharge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/shmem.c",
          "lines": "310-322",
          "snippet": "void shmem_uncharge(struct inode *inode, long pages)\n{\n\tstruct shmem_inode_info *info = SHMEM_I(inode);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&info->lock, flags);\n\tinfo->alloced -= pages;\n\tinode->i_blocks -= pages * BLOCKS_PER_PAGE;\n\tshmem_recalc_inode(inode);\n\tspin_unlock_irqrestore(&info->lock, flags);\n\n\tshmem_inode_unacct_blocks(inode, pages);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/uuid.h>",
            "#include <linux/rmap.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <uapi/linux/memfd.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/magic.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/highmem.h>",
            "#include <linux/migrate.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/swapops.h>",
            "#include <linux/security.h>",
            "#include <linux/splice.h>",
            "#include <linux/falloc.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mman.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/xattr.h>",
            "#include <asm/tlbflush.h> /* for arch/microblaze update_mmu_cache() */",
            "#include <linux/hugetlb.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/random.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define BLOCKS_PER_PAGE  (PAGE_SIZE/512)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/uuid.h>\n#include <linux/rmap.h>\n#include <linux/userfaultfd_k.h>\n#include <uapi/linux/memfd.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/magic.h>\n#include <linux/seq_file.h>\n#include <linux/highmem.h>\n#include <linux/migrate.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/mempolicy.h>\n#include <linux/swapops.h>\n#include <linux/security.h>\n#include <linux/splice.h>\n#include <linux/falloc.h>\n#include <linux/percpu_counter.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/shmem_fs.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mman.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/exportfs.h>\n#include <linux/xattr.h>\n#include <asm/tlbflush.h> /* for arch/microblaze update_mmu_cache() */\n#include <linux/hugetlb.h>\n#include <linux/khugepaged.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/sched/signal.h>\n#include <linux/random.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/ramfs.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\n#define BLOCKS_PER_PAGE  (PAGE_SIZE/512)\n\nvoid shmem_uncharge(struct inode *inode, long pages)\n{\n\tstruct shmem_inode_info *info = SHMEM_I(inode);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&info->lock, flags);\n\tinfo->alloced -= pages;\n\tinode->i_blocks -= pages * BLOCKS_PER_PAGE;\n\tshmem_recalc_inode(inode);\n\tspin_unlock_irqrestore(&info->lock, flags);\n\n\tshmem_inode_unacct_blocks(inode, pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageSwapBacked",
          "args": [
            "head"
          ],
          "line": 2464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_SHMEM"
          ],
          "line": 2464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__delete_from_page_cache",
          "args": [
            "head + i",
            "NULL"
          ],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "__delete_from_page_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "227-235",
          "snippet": "void __delete_from_page_cache(struct page *page, void *shadow)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\ttrace_mm_filemap_delete_from_page_cache(page);\n\n\tunaccount_page_cache_page(mapping, page);\n\tpage_cache_delete(mapping, page, shadow);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid __delete_from_page_cache(struct page *page, void *shadow)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\ttrace_mm_filemap_delete_from_page_cache(page);\n\n\tunaccount_page_cache_page(mapping, page);\n\tpage_cache_delete(mapping, page, shadow);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageDirty",
          "args": [
            "head + i"
          ],
          "line": 2462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__split_huge_page_tail",
          "args": [
            "head",
            "i",
            "lruvec",
            "list"
          ],
          "line": 2459
        },
        "resolved": true,
        "details": {
          "function_name": "__split_huge_page_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2379-2439",
          "snippet": "static void __split_huge_page_tail(struct page *head, int tail,\n\t\tstruct lruvec *lruvec, struct list_head *list)\n{\n\tstruct page *page_tail = head + tail;\n\n\tVM_BUG_ON_PAGE(atomic_read(&page_tail->_mapcount) != -1, page_tail);\n\n\t/*\n\t * Clone page flags before unfreezing refcount.\n\t *\n\t * After successful get_page_unless_zero() might follow flags change,\n\t * for exmaple lock_page() which set PG_waiters.\n\t */\n\tpage_tail->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;\n\tpage_tail->flags |= (head->flags &\n\t\t\t((1L << PG_referenced) |\n\t\t\t (1L << PG_swapbacked) |\n\t\t\t (1L << PG_swapcache) |\n\t\t\t (1L << PG_mlocked) |\n\t\t\t (1L << PG_uptodate) |\n\t\t\t (1L << PG_active) |\n\t\t\t (1L << PG_workingset) |\n\t\t\t (1L << PG_locked) |\n\t\t\t (1L << PG_unevictable) |\n\t\t\t (1L << PG_dirty)));\n\n\t/* Page flags must be visible before we make the page non-compound. */\n\tsmp_wmb();\n\n\t/*\n\t * Clear PageTail before unfreezing page refcount.\n\t *\n\t * After successful get_page_unless_zero() might follow put_page()\n\t * which needs correct compound_head().\n\t */\n\tclear_compound_head(page_tail);\n\n\t/* Finally unfreeze refcount. Additional reference from page cache. */\n\tpage_ref_unfreeze(page_tail, 1 + (!PageAnon(head) ||\n\t\t\t\t\t  PageSwapCache(head)));\n\n\tif (page_is_young(head))\n\t\tset_page_young(page_tail);\n\tif (page_is_idle(head))\n\t\tset_page_idle(page_tail);\n\n\t/* ->mapping in first tail page is compound_mapcount */\n\tVM_BUG_ON_PAGE(tail > 2 && page_tail->mapping != TAIL_MAPPING,\n\t\t\tpage_tail);\n\tpage_tail->mapping = head->mapping;\n\n\tpage_tail->index = head->index + tail;\n\tpage_cpupid_xchg_last(page_tail, page_cpupid_last(head));\n\n\t/*\n\t * always add to the tail because some iterators expect new\n\t * pages to show after the currently processed elements - e.g.\n\t * migrate_pages\n\t */\n\tlru_add_page_tail(head, page_tail, lruvec, list);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void __split_huge_page_tail(struct page *head, int tail,\n\t\tstruct lruvec *lruvec, struct list_head *list)\n{\n\tstruct page *page_tail = head + tail;\n\n\tVM_BUG_ON_PAGE(atomic_read(&page_tail->_mapcount) != -1, page_tail);\n\n\t/*\n\t * Clone page flags before unfreezing refcount.\n\t *\n\t * After successful get_page_unless_zero() might follow flags change,\n\t * for exmaple lock_page() which set PG_waiters.\n\t */\n\tpage_tail->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;\n\tpage_tail->flags |= (head->flags &\n\t\t\t((1L << PG_referenced) |\n\t\t\t (1L << PG_swapbacked) |\n\t\t\t (1L << PG_swapcache) |\n\t\t\t (1L << PG_mlocked) |\n\t\t\t (1L << PG_uptodate) |\n\t\t\t (1L << PG_active) |\n\t\t\t (1L << PG_workingset) |\n\t\t\t (1L << PG_locked) |\n\t\t\t (1L << PG_unevictable) |\n\t\t\t (1L << PG_dirty)));\n\n\t/* Page flags must be visible before we make the page non-compound. */\n\tsmp_wmb();\n\n\t/*\n\t * Clear PageTail before unfreezing page refcount.\n\t *\n\t * After successful get_page_unless_zero() might follow put_page()\n\t * which needs correct compound_head().\n\t */\n\tclear_compound_head(page_tail);\n\n\t/* Finally unfreeze refcount. Additional reference from page cache. */\n\tpage_ref_unfreeze(page_tail, 1 + (!PageAnon(head) ||\n\t\t\t\t\t  PageSwapCache(head)));\n\n\tif (page_is_young(head))\n\t\tset_page_young(page_tail);\n\tif (page_is_idle(head))\n\t\tset_page_idle(page_tail);\n\n\t/* ->mapping in first tail page is compound_mapcount */\n\tVM_BUG_ON_PAGE(tail > 2 && page_tail->mapping != TAIL_MAPPING,\n\t\t\tpage_tail);\n\tpage_tail->mapping = head->mapping;\n\n\tpage_tail->index = head->index + tail;\n\tpage_cpupid_xchg_last(page_tail, page_cpupid_last(head));\n\n\t/*\n\t * always add to the tail because some iterators expect new\n\t * pages to show after the currently processed elements - e.g.\n\t * migrate_pages\n\t */\n\tlru_add_page_tail(head, page_tail, lruvec, list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "i_size_read(head->mapping->host)",
            "PAGE_SIZE"
          ],
          "line": 2456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "head->mapping->host"
          ],
          "line": 2456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_split_huge_fixup",
          "args": [
            "head"
          ],
          "line": 2453
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_split_huge_fixup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2646-2657",
          "snippet": "void mem_cgroup_split_huge_fixup(struct page *head)\n{\n\tint i;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tfor (i = 1; i < HPAGE_PMD_NR; i++)\n\t\thead[i].mem_cgroup = head->mem_cgroup;\n\n\t__mod_memcg_state(head->mem_cgroup, MEMCG_RSS_HUGE, -HPAGE_PMD_NR);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid mem_cgroup_split_huge_fixup(struct page *head)\n{\n\tint i;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tfor (i = 1; i < HPAGE_PMD_NR; i++)\n\t\thead[i].mem_cgroup = head->mem_cgroup;\n\n\t__mod_memcg_state(head->mem_cgroup, MEMCG_RSS_HUGE, -HPAGE_PMD_NR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_page_lruvec",
          "args": [
            "head",
            "zone->zone_pgdat"
          ],
          "line": 2450
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_page_lruvec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1100-1130",
          "snippet": "struct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "head"
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 2444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void __split_huge_page(struct page *page, struct list_head *list,\n\t\tunsigned long flags)\n{\n\tstruct page *head = compound_head(page);\n\tstruct zone *zone = page_zone(head);\n\tstruct lruvec *lruvec;\n\tpgoff_t end = -1;\n\tint i;\n\n\tlruvec = mem_cgroup_page_lruvec(head, zone->zone_pgdat);\n\n\t/* complete memcg works before add pages to LRU */\n\tmem_cgroup_split_huge_fixup(head);\n\n\tif (!PageAnon(page))\n\t\tend = DIV_ROUND_UP(i_size_read(head->mapping->host), PAGE_SIZE);\n\n\tfor (i = HPAGE_PMD_NR - 1; i >= 1; i--) {\n\t\t__split_huge_page_tail(head, i, lruvec, list);\n\t\t/* Some pages can be beyond i_size: drop them from page cache */\n\t\tif (head[i].index >= end) {\n\t\t\tClearPageDirty(head + i);\n\t\t\t__delete_from_page_cache(head + i, NULL);\n\t\t\tif (IS_ENABLED(CONFIG_SHMEM) && PageSwapBacked(head))\n\t\t\t\tshmem_uncharge(head->mapping->host, 1);\n\t\t\tput_page(head + i);\n\t\t}\n\t}\n\n\tClearPageCompound(head);\n\t/* See comment in __split_huge_page_tail() */\n\tif (PageAnon(head)) {\n\t\t/* Additional pin to swap cache */\n\t\tif (PageSwapCache(head))\n\t\t\tpage_ref_add(head, 2);\n\t\telse\n\t\t\tpage_ref_inc(head);\n\t} else {\n\t\t/* Additional pin to page cache */\n\t\tpage_ref_add(head, 2);\n\t\txa_unlock(&head->mapping->i_pages);\n\t}\n\n\tspin_unlock_irqrestore(zone_lru_lock(page_zone(head)), flags);\n\n\tunfreeze_page(head);\n\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tstruct page *subpage = head + i;\n\t\tif (subpage == page)\n\t\t\tcontinue;\n\t\tunlock_page(subpage);\n\n\t\t/*\n\t\t * Subpages may be freed if there wasn't any mapping\n\t\t * like if add_to_swap() is running on a lru page that\n\t\t * had its mapping zapped. And freeing these pages\n\t\t * requires taking the lru_lock so we do the put_page\n\t\t * of the tail pages after the split is complete.\n\t\t */\n\t\tput_page(subpage);\n\t}\n}"
  },
  {
    "function_name": "__split_huge_page_tail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "2379-2439",
    "snippet": "static void __split_huge_page_tail(struct page *head, int tail,\n\t\tstruct lruvec *lruvec, struct list_head *list)\n{\n\tstruct page *page_tail = head + tail;\n\n\tVM_BUG_ON_PAGE(atomic_read(&page_tail->_mapcount) != -1, page_tail);\n\n\t/*\n\t * Clone page flags before unfreezing refcount.\n\t *\n\t * After successful get_page_unless_zero() might follow flags change,\n\t * for exmaple lock_page() which set PG_waiters.\n\t */\n\tpage_tail->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;\n\tpage_tail->flags |= (head->flags &\n\t\t\t((1L << PG_referenced) |\n\t\t\t (1L << PG_swapbacked) |\n\t\t\t (1L << PG_swapcache) |\n\t\t\t (1L << PG_mlocked) |\n\t\t\t (1L << PG_uptodate) |\n\t\t\t (1L << PG_active) |\n\t\t\t (1L << PG_workingset) |\n\t\t\t (1L << PG_locked) |\n\t\t\t (1L << PG_unevictable) |\n\t\t\t (1L << PG_dirty)));\n\n\t/* Page flags must be visible before we make the page non-compound. */\n\tsmp_wmb();\n\n\t/*\n\t * Clear PageTail before unfreezing page refcount.\n\t *\n\t * After successful get_page_unless_zero() might follow put_page()\n\t * which needs correct compound_head().\n\t */\n\tclear_compound_head(page_tail);\n\n\t/* Finally unfreeze refcount. Additional reference from page cache. */\n\tpage_ref_unfreeze(page_tail, 1 + (!PageAnon(head) ||\n\t\t\t\t\t  PageSwapCache(head)));\n\n\tif (page_is_young(head))\n\t\tset_page_young(page_tail);\n\tif (page_is_idle(head))\n\t\tset_page_idle(page_tail);\n\n\t/* ->mapping in first tail page is compound_mapcount */\n\tVM_BUG_ON_PAGE(tail > 2 && page_tail->mapping != TAIL_MAPPING,\n\t\t\tpage_tail);\n\tpage_tail->mapping = head->mapping;\n\n\tpage_tail->index = head->index + tail;\n\tpage_cpupid_xchg_last(page_tail, page_cpupid_last(head));\n\n\t/*\n\t * always add to the tail because some iterators expect new\n\t * pages to show after the currently processed elements - e.g.\n\t * migrate_pages\n\t */\n\tlru_add_page_tail(head, page_tail, lruvec, list);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lru_add_page_tail",
          "args": [
            "head",
            "page_tail",
            "lruvec",
            "list"
          ],
          "line": 2438
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_page_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "818-854",
          "snippet": "void lru_add_page_tail(struct page *page, struct page *page_tail,\n\t\t       struct lruvec *lruvec, struct list_head *list)\n{\n\tconst int file = 0;\n\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\tVM_BUG_ON_PAGE(PageCompound(page_tail), page);\n\tVM_BUG_ON_PAGE(PageLRU(page_tail), page);\n\tVM_BUG_ON(NR_CPUS != 1 &&\n\t\t  !spin_is_locked(&lruvec_pgdat(lruvec)->lru_lock));\n\n\tif (!list)\n\t\tSetPageLRU(page_tail);\n\n\tif (likely(PageLRU(page)))\n\t\tlist_add_tail(&page_tail->lru, &page->lru);\n\telse if (list) {\n\t\t/* page reclaim is reclaiming a huge page */\n\t\tget_page(page_tail);\n\t\tlist_add_tail(&page_tail->lru, list);\n\t} else {\n\t\tstruct list_head *list_head;\n\t\t/*\n\t\t * Head page has not yet been counted, as an hpage,\n\t\t * so we must account for each subpage individually.\n\t\t *\n\t\t * Use the standard add function to put page_tail on the list,\n\t\t * but then correct its position so they all end up in order.\n\t\t */\n\t\tadd_page_to_lru_list(page_tail, lruvec, page_lru(page_tail));\n\t\tlist_head = page_tail->lru.prev;\n\t\tlist_move_tail(&page_tail->lru, list_head);\n\t}\n\n\tif (!PageUnevictable(page))\n\t\tupdate_page_reclaim_stat(lruvec, file, PageActive(page_tail));\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid lru_add_page_tail(struct page *page, struct page *page_tail,\n\t\t       struct lruvec *lruvec, struct list_head *list)\n{\n\tconst int file = 0;\n\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\tVM_BUG_ON_PAGE(PageCompound(page_tail), page);\n\tVM_BUG_ON_PAGE(PageLRU(page_tail), page);\n\tVM_BUG_ON(NR_CPUS != 1 &&\n\t\t  !spin_is_locked(&lruvec_pgdat(lruvec)->lru_lock));\n\n\tif (!list)\n\t\tSetPageLRU(page_tail);\n\n\tif (likely(PageLRU(page)))\n\t\tlist_add_tail(&page_tail->lru, &page->lru);\n\telse if (list) {\n\t\t/* page reclaim is reclaiming a huge page */\n\t\tget_page(page_tail);\n\t\tlist_add_tail(&page_tail->lru, list);\n\t} else {\n\t\tstruct list_head *list_head;\n\t\t/*\n\t\t * Head page has not yet been counted, as an hpage,\n\t\t * so we must account for each subpage individually.\n\t\t *\n\t\t * Use the standard add function to put page_tail on the list,\n\t\t * but then correct its position so they all end up in order.\n\t\t */\n\t\tadd_page_to_lru_list(page_tail, lruvec, page_lru(page_tail));\n\t\tlist_head = page_tail->lru.prev;\n\t\tlist_move_tail(&page_tail->lru, list_head);\n\t}\n\n\tif (!PageUnevictable(page))\n\t\tupdate_page_reclaim_stat(lruvec, file, PageActive(page_tail));\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cpupid_xchg_last",
          "args": [
            "page_tail",
            "page_cpupid_last(head)"
          ],
          "line": 2431
        },
        "resolved": true,
        "details": {
          "function_name": "page_cpupid_xchg_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmzone.c",
          "lines": "100-114",
          "snippet": "int page_cpupid_xchg_last(struct page *page, int cpupid)\n{\n\tunsigned long old_flags, flags;\n\tint last_cpupid;\n\n\tdo {\n\t\told_flags = flags = page->flags;\n\t\tlast_cpupid = page_cpupid_last(page);\n\n\t\tflags &= ~(LAST_CPUPID_MASK << LAST_CPUPID_PGSHIFT);\n\t\tflags |= (cpupid & LAST_CPUPID_MASK) << LAST_CPUPID_PGSHIFT;\n\t} while (unlikely(cmpxchg(&page->flags, old_flags, flags) != old_flags));\n\n\treturn last_cpupid;\n}",
          "includes": [
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint page_cpupid_xchg_last(struct page *page, int cpupid)\n{\n\tunsigned long old_flags, flags;\n\tint last_cpupid;\n\n\tdo {\n\t\told_flags = flags = page->flags;\n\t\tlast_cpupid = page_cpupid_last(page);\n\n\t\tflags &= ~(LAST_CPUPID_MASK << LAST_CPUPID_PGSHIFT);\n\t\tflags |= (cpupid & LAST_CPUPID_MASK) << LAST_CPUPID_PGSHIFT;\n\t} while (unlikely(cmpxchg(&page->flags, old_flags, flags) != old_flags));\n\n\treturn last_cpupid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cpupid_last",
          "args": [
            "head"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "tail > 2 && page_tail->mapping != TAIL_MAPPING",
            "page_tail"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_idle",
          "args": [
            "page_tail"
          ],
          "line": 2423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_idle",
          "args": [
            "head"
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_young",
          "args": [
            "page_tail"
          ],
          "line": 2421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_young",
          "args": [
            "head"
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_unfreeze",
          "args": [
            "page_tail",
            "1 + (!PageAnon(head) ||\n\t\t\t\t\t  PageSwapCache(head))"
          ],
          "line": 2417
        },
        "resolved": true,
        "details": {
          "function_name": "__page_ref_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/debug_page_ref.c",
          "lines": "50-53",
          "snippet": "void __page_ref_unfreeze(struct page *page, int v)\n{\n\ttrace_page_ref_unfreeze(page, v);\n}",
          "includes": [
            "#include <trace/events/page_ref.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/page_ref.h>\n#include <linux/tracepoint.h>\n#include <linux/mm_types.h>\n\nvoid __page_ref_unfreeze(struct page *page, int v)\n{\n\ttrace_page_ref_unfreeze(page, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "head"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "head"
          ],
          "line": 2417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_compound_head",
          "args": [
            "page_tail"
          ],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "atomic_read(&page_tail->_mapcount) != -1",
            "page_tail"
          ],
          "line": 2384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&page_tail->_mapcount"
          ],
          "line": 2384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void __split_huge_page_tail(struct page *head, int tail,\n\t\tstruct lruvec *lruvec, struct list_head *list)\n{\n\tstruct page *page_tail = head + tail;\n\n\tVM_BUG_ON_PAGE(atomic_read(&page_tail->_mapcount) != -1, page_tail);\n\n\t/*\n\t * Clone page flags before unfreezing refcount.\n\t *\n\t * After successful get_page_unless_zero() might follow flags change,\n\t * for exmaple lock_page() which set PG_waiters.\n\t */\n\tpage_tail->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;\n\tpage_tail->flags |= (head->flags &\n\t\t\t((1L << PG_referenced) |\n\t\t\t (1L << PG_swapbacked) |\n\t\t\t (1L << PG_swapcache) |\n\t\t\t (1L << PG_mlocked) |\n\t\t\t (1L << PG_uptodate) |\n\t\t\t (1L << PG_active) |\n\t\t\t (1L << PG_workingset) |\n\t\t\t (1L << PG_locked) |\n\t\t\t (1L << PG_unevictable) |\n\t\t\t (1L << PG_dirty)));\n\n\t/* Page flags must be visible before we make the page non-compound. */\n\tsmp_wmb();\n\n\t/*\n\t * Clear PageTail before unfreezing page refcount.\n\t *\n\t * After successful get_page_unless_zero() might follow put_page()\n\t * which needs correct compound_head().\n\t */\n\tclear_compound_head(page_tail);\n\n\t/* Finally unfreeze refcount. Additional reference from page cache. */\n\tpage_ref_unfreeze(page_tail, 1 + (!PageAnon(head) ||\n\t\t\t\t\t  PageSwapCache(head)));\n\n\tif (page_is_young(head))\n\t\tset_page_young(page_tail);\n\tif (page_is_idle(head))\n\t\tset_page_idle(page_tail);\n\n\t/* ->mapping in first tail page is compound_mapcount */\n\tVM_BUG_ON_PAGE(tail > 2 && page_tail->mapping != TAIL_MAPPING,\n\t\t\tpage_tail);\n\tpage_tail->mapping = head->mapping;\n\n\tpage_tail->index = head->index + tail;\n\tpage_cpupid_xchg_last(page_tail, page_cpupid_last(head));\n\n\t/*\n\t * always add to the tail because some iterators expect new\n\t * pages to show after the currently processed elements - e.g.\n\t * migrate_pages\n\t */\n\tlru_add_page_tail(head, page_tail, lruvec, list);\n}"
  },
  {
    "function_name": "unfreeze_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "2368-2377",
    "snippet": "static void unfreeze_page(struct page *page)\n{\n\tint i;\n\tif (PageTransHuge(page)) {\n\t\tremove_migration_ptes(page, page, true);\n\t} else {\n\t\tfor (i = 0; i < HPAGE_PMD_NR; i++)\n\t\t\tremove_migration_ptes(page + i, page + i, true);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_migration_ptes",
          "args": [
            "page + i",
            "page + i",
            "true"
          ],
          "line": 2375
        },
        "resolved": true,
        "details": {
          "function_name": "remove_migration_ptes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "292-303",
          "snippet": "void remove_migration_ptes(struct page *old, struct page *new, bool locked)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = remove_migration_pte,\n\t\t.arg = old,\n\t};\n\n\tif (locked)\n\t\trmap_walk_locked(new, &rwc);\n\telse\n\t\trmap_walk(new, &rwc);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid remove_migration_ptes(struct page *old, struct page *new, bool locked)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = remove_migration_pte,\n\t\t.arg = old,\n\t};\n\n\tif (locked)\n\t\trmap_walk_locked(new, &rwc);\n\telse\n\t\trmap_walk(new, &rwc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 2371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void unfreeze_page(struct page *page)\n{\n\tint i;\n\tif (PageTransHuge(page)) {\n\t\tremove_migration_ptes(page, page, true);\n\t} else {\n\t\tfor (i = 0; i < HPAGE_PMD_NR; i++)\n\t\t\tremove_migration_ptes(page + i, page + i, true);\n\t}\n}"
  },
  {
    "function_name": "freeze_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "2353-2366",
    "snippet": "static void freeze_page(struct page *page)\n{\n\tenum ttu_flags ttu_flags = TTU_IGNORE_MLOCK | TTU_IGNORE_ACCESS |\n\t\tTTU_RMAP_LOCKED | TTU_SPLIT_HUGE_PMD;\n\tbool unmap_success;\n\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\n\tif (PageAnon(page))\n\t\tttu_flags |= TTU_SPLIT_FREEZE;\n\n\tunmap_success = try_to_unmap(page, ttu_flags);\n\tVM_BUG_ON_PAGE(!unmap_success, page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!unmap_success",
            "page"
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_unmap",
          "args": [
            "page",
            "ttu_flags"
          ],
          "line": 2364
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1699-1726",
          "snippet": "bool try_to_unmap(struct page *page, enum ttu_flags flags)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = try_to_unmap_one,\n\t\t.arg = (void *)flags,\n\t\t.done = page_mapcount_is_zero,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\t};\n\n\t/*\n\t * During exec, a temporary VMA is setup and later moved.\n\t * The VMA is moved under the anon_vma lock but not the\n\t * page tables leading to a race where migration cannot\n\t * find the migration ptes. Rather than increasing the\n\t * locking requirements of exec(), migration skips\n\t * temporary VMAs until after exec() completes.\n\t */\n\tif ((flags & (TTU_MIGRATION|TTU_SPLIT_FREEZE))\n\t    && !PageKsm(page) && PageAnon(page))\n\t\trwc.invalid_vma = invalid_migration_vma;\n\n\tif (flags & TTU_RMAP_LOCKED)\n\t\trmap_walk_locked(page, &rwc);\n\telse\n\t\trmap_walk(page, &rwc);\n\n\treturn !page_mapcount(page) ? true : false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nbool try_to_unmap(struct page *page, enum ttu_flags flags)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = try_to_unmap_one,\n\t\t.arg = (void *)flags,\n\t\t.done = page_mapcount_is_zero,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\t};\n\n\t/*\n\t * During exec, a temporary VMA is setup and later moved.\n\t * The VMA is moved under the anon_vma lock but not the\n\t * page tables leading to a race where migration cannot\n\t * find the migration ptes. Rather than increasing the\n\t * locking requirements of exec(), migration skips\n\t * temporary VMAs until after exec() completes.\n\t */\n\tif ((flags & (TTU_MIGRATION|TTU_SPLIT_FREEZE))\n\t    && !PageKsm(page) && PageAnon(page))\n\t\trwc.invalid_vma = invalid_migration_vma;\n\n\tif (flags & TTU_RMAP_LOCKED)\n\t\trmap_walk_locked(page, &rwc);\n\telse\n\t\trmap_walk(page, &rwc);\n\n\treturn !page_mapcount(page) ? true : false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageHead(page)",
            "page"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHead",
          "args": [
            "page"
          ],
          "line": 2359
        },
        "resolved": true,
        "details": {
          "function_name": "PageHeadHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1350-1356",
          "snippet": "int PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void freeze_page(struct page *page)\n{\n\tenum ttu_flags ttu_flags = TTU_IGNORE_MLOCK | TTU_IGNORE_ACCESS |\n\t\tTTU_RMAP_LOCKED | TTU_SPLIT_HUGE_PMD;\n\tbool unmap_success;\n\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\n\tif (PageAnon(page))\n\t\tttu_flags |= TTU_SPLIT_FREEZE;\n\n\tunmap_success = try_to_unmap(page, ttu_flags);\n\tVM_BUG_ON_PAGE(!unmap_success, page);\n}"
  },
  {
    "function_name": "vma_adjust_trans_huge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "2312-2351",
    "snippet": "void vma_adjust_trans_huge(struct vm_area_struct *vma,\n\t\t\t     unsigned long start,\n\t\t\t     unsigned long end,\n\t\t\t     long adjust_next)\n{\n\t/*\n\t * If the new start address isn't hpage aligned and it could\n\t * previously contain an hugepage: check if we need to split\n\t * an huge pmd.\n\t */\n\tif (start & ~HPAGE_PMD_MASK &&\n\t    (start & HPAGE_PMD_MASK) >= vma->vm_start &&\n\t    (start & HPAGE_PMD_MASK) + HPAGE_PMD_SIZE <= vma->vm_end)\n\t\tsplit_huge_pmd_address(vma, start, false, NULL);\n\n\t/*\n\t * If the new end address isn't hpage aligned and it could\n\t * previously contain an hugepage: check if we need to split\n\t * an huge pmd.\n\t */\n\tif (end & ~HPAGE_PMD_MASK &&\n\t    (end & HPAGE_PMD_MASK) >= vma->vm_start &&\n\t    (end & HPAGE_PMD_MASK) + HPAGE_PMD_SIZE <= vma->vm_end)\n\t\tsplit_huge_pmd_address(vma, end, false, NULL);\n\n\t/*\n\t * If we're also updating the vma->vm_next->vm_start, if the new\n\t * vm_next->vm_start isn't page aligned and it could previously\n\t * contain an hugepage: check if we need to split an huge pmd.\n\t */\n\tif (adjust_next > 0) {\n\t\tstruct vm_area_struct *next = vma->vm_next;\n\t\tunsigned long nstart = next->vm_start;\n\t\tnstart += adjust_next << PAGE_SHIFT;\n\t\tif (nstart & ~HPAGE_PMD_MASK &&\n\t\t    (nstart & HPAGE_PMD_MASK) >= next->vm_start &&\n\t\t    (nstart & HPAGE_PMD_MASK) + HPAGE_PMD_SIZE <= next->vm_end)\n\t\t\tsplit_huge_pmd_address(next, nstart, false, NULL);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "split_huge_pmd_address",
          "args": [
            "next",
            "nstart",
            "false",
            "NULL"
          ],
          "line": 2349
        },
        "resolved": true,
        "details": {
          "function_name": "split_huge_pmd_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2287-2310",
          "snippet": "void split_huge_pmd_address(struct vm_area_struct *vma, unsigned long address,\n\t\tbool freeze, struct page *page)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(vma->vm_mm, address);\n\tif (!pgd_present(*pgd))\n\t\treturn;\n\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\treturn;\n\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\treturn;\n\n\tpmd = pmd_offset(pud, address);\n\n\t__split_huge_pmd(vma, pmd, address, freeze, page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid split_huge_pmd_address(struct vm_area_struct *vma, unsigned long address,\n\t\tbool freeze, struct page *page)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(vma->vm_mm, address);\n\tif (!pgd_present(*pgd))\n\t\treturn;\n\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\treturn;\n\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\treturn;\n\n\tpmd = pmd_offset(pud, address);\n\n\t__split_huge_pmd(vma, pmd, address, freeze, page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid vma_adjust_trans_huge(struct vm_area_struct *vma,\n\t\t\t     unsigned long start,\n\t\t\t     unsigned long end,\n\t\t\t     long adjust_next)\n{\n\t/*\n\t * If the new start address isn't hpage aligned and it could\n\t * previously contain an hugepage: check if we need to split\n\t * an huge pmd.\n\t */\n\tif (start & ~HPAGE_PMD_MASK &&\n\t    (start & HPAGE_PMD_MASK) >= vma->vm_start &&\n\t    (start & HPAGE_PMD_MASK) + HPAGE_PMD_SIZE <= vma->vm_end)\n\t\tsplit_huge_pmd_address(vma, start, false, NULL);\n\n\t/*\n\t * If the new end address isn't hpage aligned and it could\n\t * previously contain an hugepage: check if we need to split\n\t * an huge pmd.\n\t */\n\tif (end & ~HPAGE_PMD_MASK &&\n\t    (end & HPAGE_PMD_MASK) >= vma->vm_start &&\n\t    (end & HPAGE_PMD_MASK) + HPAGE_PMD_SIZE <= vma->vm_end)\n\t\tsplit_huge_pmd_address(vma, end, false, NULL);\n\n\t/*\n\t * If we're also updating the vma->vm_next->vm_start, if the new\n\t * vm_next->vm_start isn't page aligned and it could previously\n\t * contain an hugepage: check if we need to split an huge pmd.\n\t */\n\tif (adjust_next > 0) {\n\t\tstruct vm_area_struct *next = vma->vm_next;\n\t\tunsigned long nstart = next->vm_start;\n\t\tnstart += adjust_next << PAGE_SHIFT;\n\t\tif (nstart & ~HPAGE_PMD_MASK &&\n\t\t    (nstart & HPAGE_PMD_MASK) >= next->vm_start &&\n\t\t    (nstart & HPAGE_PMD_MASK) + HPAGE_PMD_SIZE <= next->vm_end)\n\t\t\tsplit_huge_pmd_address(next, nstart, false, NULL);\n\t}\n}"
  },
  {
    "function_name": "split_huge_pmd_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "2287-2310",
    "snippet": "void split_huge_pmd_address(struct vm_area_struct *vma, unsigned long address,\n\t\tbool freeze, struct page *page)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(vma->vm_mm, address);\n\tif (!pgd_present(*pgd))\n\t\treturn;\n\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\treturn;\n\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\treturn;\n\n\tpmd = pmd_offset(pud, address);\n\n\t__split_huge_pmd(vma, pmd, address, freeze, page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__split_huge_pmd",
          "args": [
            "vma",
            "pmd",
            "address",
            "freeze",
            "page"
          ],
          "line": 2309
        },
        "resolved": true,
        "details": {
          "function_name": "__split_huge_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2243-2285",
          "snippet": "void __split_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long address, bool freeze, struct page *page)\n{\n\tspinlock_t *ptl;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long haddr = address & HPAGE_PMD_MASK;\n\n\tmmu_notifier_invalidate_range_start(mm, haddr, haddr + HPAGE_PMD_SIZE);\n\tptl = pmd_lock(mm, pmd);\n\n\t/*\n\t * If caller asks to setup a migration entries, we need a page to check\n\t * pmd against. Otherwise we can end up replacing wrong page.\n\t */\n\tVM_BUG_ON(freeze && !page);\n\tif (page && page != pmd_page(*pmd))\n\t        goto out;\n\n\tif (pmd_trans_huge(*pmd)) {\n\t\tpage = pmd_page(*pmd);\n\t\tif (PageMlocked(page))\n\t\t\tclear_page_mlock(page);\n\t} else if (!(pmd_devmap(*pmd) || is_pmd_migration_entry(*pmd)))\n\t\tgoto out;\n\t__split_huge_pmd_locked(vma, pmd, haddr, freeze);\nout:\n\tspin_unlock(ptl);\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback.\n\t * They are 3 cases to consider inside __split_huge_pmd_locked():\n\t *  1) pmdp_huge_clear_flush_notify() call invalidate_range() obvious\n\t *  2) __split_huge_zero_page_pmd() read only zero page and any write\n\t *    fault will trigger a flush_notify before pointing to a new page\n\t *    (it is fine if the secondary mmu keeps pointing to the old zero\n\t *    page in the meantime)\n\t *  3) Split a huge pmd into pte pointing to the same page. No need\n\t *     to invalidate secondary tlb entry they are all still valid.\n\t *     any further changes to individual pte will notify. So no need\n\t *     to call mmu_notifier->invalidate_range()\n\t */\n\tmmu_notifier_invalidate_range_only_end(mm, haddr, haddr +\n\t\t\t\t\t       HPAGE_PMD_SIZE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid __split_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long address, bool freeze, struct page *page)\n{\n\tspinlock_t *ptl;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long haddr = address & HPAGE_PMD_MASK;\n\n\tmmu_notifier_invalidate_range_start(mm, haddr, haddr + HPAGE_PMD_SIZE);\n\tptl = pmd_lock(mm, pmd);\n\n\t/*\n\t * If caller asks to setup a migration entries, we need a page to check\n\t * pmd against. Otherwise we can end up replacing wrong page.\n\t */\n\tVM_BUG_ON(freeze && !page);\n\tif (page && page != pmd_page(*pmd))\n\t        goto out;\n\n\tif (pmd_trans_huge(*pmd)) {\n\t\tpage = pmd_page(*pmd);\n\t\tif (PageMlocked(page))\n\t\t\tclear_page_mlock(page);\n\t} else if (!(pmd_devmap(*pmd) || is_pmd_migration_entry(*pmd)))\n\t\tgoto out;\n\t__split_huge_pmd_locked(vma, pmd, haddr, freeze);\nout:\n\tspin_unlock(ptl);\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback.\n\t * They are 3 cases to consider inside __split_huge_pmd_locked():\n\t *  1) pmdp_huge_clear_flush_notify() call invalidate_range() obvious\n\t *  2) __split_huge_zero_page_pmd() read only zero page and any write\n\t *    fault will trigger a flush_notify before pointing to a new page\n\t *    (it is fine if the secondary mmu keeps pointing to the old zero\n\t *    page in the meantime)\n\t *  3) Split a huge pmd into pte pointing to the same page. No need\n\t *     to invalidate secondary tlb entry they are all still valid.\n\t *     any further changes to individual pte will notify. So no need\n\t *     to call mmu_notifier->invalidate_range()\n\t */\n\tmmu_notifier_invalidate_range_only_end(mm, haddr, haddr +\n\t\t\t\t\t       HPAGE_PMD_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_offset",
          "args": [
            "pud",
            "address"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_present",
          "args": [
            "*pud"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_offset",
          "args": [
            "p4d",
            "address"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_present",
          "args": [
            "*p4d"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_offset",
          "args": [
            "pgd",
            "address"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_present",
          "args": [
            "*pgd"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_offset",
          "args": [
            "vma->vm_mm",
            "address"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid split_huge_pmd_address(struct vm_area_struct *vma, unsigned long address,\n\t\tbool freeze, struct page *page)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(vma->vm_mm, address);\n\tif (!pgd_present(*pgd))\n\t\treturn;\n\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\treturn;\n\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\treturn;\n\n\tpmd = pmd_offset(pud, address);\n\n\t__split_huge_pmd(vma, pmd, address, freeze, page);\n}"
  },
  {
    "function_name": "__split_huge_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "2243-2285",
    "snippet": "void __split_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long address, bool freeze, struct page *page)\n{\n\tspinlock_t *ptl;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long haddr = address & HPAGE_PMD_MASK;\n\n\tmmu_notifier_invalidate_range_start(mm, haddr, haddr + HPAGE_PMD_SIZE);\n\tptl = pmd_lock(mm, pmd);\n\n\t/*\n\t * If caller asks to setup a migration entries, we need a page to check\n\t * pmd against. Otherwise we can end up replacing wrong page.\n\t */\n\tVM_BUG_ON(freeze && !page);\n\tif (page && page != pmd_page(*pmd))\n\t        goto out;\n\n\tif (pmd_trans_huge(*pmd)) {\n\t\tpage = pmd_page(*pmd);\n\t\tif (PageMlocked(page))\n\t\t\tclear_page_mlock(page);\n\t} else if (!(pmd_devmap(*pmd) || is_pmd_migration_entry(*pmd)))\n\t\tgoto out;\n\t__split_huge_pmd_locked(vma, pmd, haddr, freeze);\nout:\n\tspin_unlock(ptl);\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback.\n\t * They are 3 cases to consider inside __split_huge_pmd_locked():\n\t *  1) pmdp_huge_clear_flush_notify() call invalidate_range() obvious\n\t *  2) __split_huge_zero_page_pmd() read only zero page and any write\n\t *    fault will trigger a flush_notify before pointing to a new page\n\t *    (it is fine if the secondary mmu keeps pointing to the old zero\n\t *    page in the meantime)\n\t *  3) Split a huge pmd into pte pointing to the same page. No need\n\t *     to invalidate secondary tlb entry they are all still valid.\n\t *     any further changes to individual pte will notify. So no need\n\t *     to call mmu_notifier->invalidate_range()\n\t */\n\tmmu_notifier_invalidate_range_only_end(mm, haddr, haddr +\n\t\t\t\t\t       HPAGE_PMD_SIZE);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_only_end",
          "args": [
            "mm",
            "haddr",
            "haddr +\n\t\t\t\t\t       HPAGE_PMD_SIZE"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__split_huge_pmd_locked",
          "args": [
            "vma",
            "pmd",
            "haddr",
            "freeze"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "__split_huge_pmd_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2085-2241",
          "snippet": "static void __split_huge_pmd_locked(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long haddr, bool freeze)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page;\n\tpgtable_t pgtable;\n\tpmd_t old_pmd, _pmd;\n\tbool young, write, soft_dirty, pmd_migration = false;\n\tunsigned long addr;\n\tint i;\n\n\tVM_BUG_ON(haddr & ~HPAGE_PMD_MASK);\n\tVM_BUG_ON_VMA(vma->vm_start > haddr, vma);\n\tVM_BUG_ON_VMA(vma->vm_end < haddr + HPAGE_PMD_SIZE, vma);\n\tVM_BUG_ON(!is_pmd_migration_entry(*pmd) && !pmd_trans_huge(*pmd)\n\t\t\t\t&& !pmd_devmap(*pmd));\n\n\tcount_vm_event(THP_SPLIT_PMD);\n\n\tif (!vma_is_anonymous(vma)) {\n\t\t_pmd = pmdp_huge_clear_flush_notify(vma, haddr, pmd);\n\t\t/*\n\t\t * We are going to unmap this huge page. So\n\t\t * just go ahead and zap it\n\t\t */\n\t\tif (arch_needs_pgtable_deposit())\n\t\t\tzap_deposited_table(mm, pmd);\n\t\tif (vma_is_dax(vma))\n\t\t\treturn;\n\t\tpage = pmd_page(_pmd);\n\t\tif (!PageDirty(page) && pmd_dirty(_pmd))\n\t\t\tset_page_dirty(page);\n\t\tif (!PageReferenced(page) && pmd_young(_pmd))\n\t\t\tSetPageReferenced(page);\n\t\tpage_remove_rmap(page, true);\n\t\tput_page(page);\n\t\tadd_mm_counter(mm, mm_counter_file(page), -HPAGE_PMD_NR);\n\t\treturn;\n\t} else if (is_huge_zero_pmd(*pmd)) {\n\t\t/*\n\t\t * FIXME: Do we want to invalidate secondary mmu by calling\n\t\t * mmu_notifier_invalidate_range() see comments below inside\n\t\t * __split_huge_pmd() ?\n\t\t *\n\t\t * We are going from a zero huge page write protected to zero\n\t\t * small page also write protected so it does not seems useful\n\t\t * to invalidate secondary mmu at this time.\n\t\t */\n\t\treturn __split_huge_zero_page_pmd(vma, haddr, pmd);\n\t}\n\n\t/*\n\t * Up to this point the pmd is present and huge and userland has the\n\t * whole access to the hugepage during the split (which happens in\n\t * place). If we overwrite the pmd with the not-huge version pointing\n\t * to the pte here (which of course we could if all CPUs were bug\n\t * free), userland could trigger a small page size TLB miss on the\n\t * small sized TLB while the hugepage TLB entry is still established in\n\t * the huge TLB. Some CPU doesn't like that.\n\t * See http://support.amd.com/us/Processor_TechDocs/41322.pdf, Erratum\n\t * 383 on page 93. Intel should be safe but is also warns that it's\n\t * only safe if the permission and cache attributes of the two entries\n\t * loaded in the two TLB is identical (which should be the case here).\n\t * But it is generally safer to never allow small and huge TLB entries\n\t * for the same virtual address to be loaded simultaneously. So instead\n\t * of doing \"pmd_populate(); flush_pmd_tlb_range();\" we first mark the\n\t * current pmd notpresent (atomically because here the pmd_trans_huge\n\t * must remain set at all times on the pmd until the split is complete\n\t * for this pmd), then we flush the SMP TLB and finally we write the\n\t * non-huge version of the pmd entry with pmd_populate.\n\t */\n\told_pmd = pmdp_invalidate(vma, haddr, pmd);\n\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\n\tpmd_migration = is_pmd_migration_entry(old_pmd);\n\tif (pmd_migration) {\n\t\tswp_entry_t entry;\n\n\t\tentry = pmd_to_swp_entry(old_pmd);\n\t\tpage = pfn_to_page(swp_offset(entry));\n\t} else\n#endif\n\t\tpage = pmd_page(old_pmd);\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tpage_ref_add(page, HPAGE_PMD_NR - 1);\n\tif (pmd_dirty(old_pmd))\n\t\tSetPageDirty(page);\n\twrite = pmd_write(old_pmd);\n\tyoung = pmd_young(old_pmd);\n\tsoft_dirty = pmd_soft_dirty(old_pmd);\n\n\t/*\n\t * Withdraw the table only after we mark the pmd entry invalid.\n\t * This's critical for some architectures (Power).\n\t */\n\tpgtable = pgtable_trans_huge_withdraw(mm, pmd);\n\tpmd_populate(mm, &_pmd, pgtable);\n\n\tfor (i = 0, addr = haddr; i < HPAGE_PMD_NR; i++, addr += PAGE_SIZE) {\n\t\tpte_t entry, *pte;\n\t\t/*\n\t\t * Note that NUMA hinting access restrictions are not\n\t\t * transferred to avoid any possibility of altering\n\t\t * permissions across VMAs.\n\t\t */\n\t\tif (freeze || pmd_migration) {\n\t\t\tswp_entry_t swp_entry;\n\t\t\tswp_entry = make_migration_entry(page + i, write);\n\t\t\tentry = swp_entry_to_pte(swp_entry);\n\t\t\tif (soft_dirty)\n\t\t\t\tentry = pte_swp_mksoft_dirty(entry);\n\t\t} else {\n\t\t\tentry = mk_pte(page + i, READ_ONCE(vma->vm_page_prot));\n\t\t\tentry = maybe_mkwrite(entry, vma);\n\t\t\tif (!write)\n\t\t\t\tentry = pte_wrprotect(entry);\n\t\t\tif (!young)\n\t\t\t\tentry = pte_mkold(entry);\n\t\t\tif (soft_dirty)\n\t\t\t\tentry = pte_mksoft_dirty(entry);\n\t\t}\n\t\tpte = pte_offset_map(&_pmd, addr);\n\t\tBUG_ON(!pte_none(*pte));\n\t\tset_pte_at(mm, addr, pte, entry);\n\t\tatomic_inc(&page[i]._mapcount);\n\t\tpte_unmap(pte);\n\t}\n\n\t/*\n\t * Set PG_double_map before dropping compound_mapcount to avoid\n\t * false-negative page_mapped().\n\t */\n\tif (compound_mapcount(page) > 1 && !TestSetPageDoubleMap(page)) {\n\t\tfor (i = 0; i < HPAGE_PMD_NR; i++)\n\t\t\tatomic_inc(&page[i]._mapcount);\n\t}\n\n\tif (atomic_add_negative(-1, compound_mapcount_ptr(page))) {\n\t\t/* Last compound_mapcount is gone. */\n\t\t__dec_node_page_state(page, NR_ANON_THPS);\n\t\tif (TestClearPageDoubleMap(page)) {\n\t\t\t/* No need in mapcount reference anymore */\n\t\t\tfor (i = 0; i < HPAGE_PMD_NR; i++)\n\t\t\t\tatomic_dec(&page[i]._mapcount);\n\t\t}\n\t}\n\n\tsmp_wmb(); /* make pte visible before pmd */\n\tpmd_populate(mm, pmd, pgtable);\n\n\tif (freeze) {\n\t\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\t\tpage_remove_rmap(page + i, false);\n\t\t\tput_page(page + i);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void __split_huge_pmd_locked(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long haddr, bool freeze)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page;\n\tpgtable_t pgtable;\n\tpmd_t old_pmd, _pmd;\n\tbool young, write, soft_dirty, pmd_migration = false;\n\tunsigned long addr;\n\tint i;\n\n\tVM_BUG_ON(haddr & ~HPAGE_PMD_MASK);\n\tVM_BUG_ON_VMA(vma->vm_start > haddr, vma);\n\tVM_BUG_ON_VMA(vma->vm_end < haddr + HPAGE_PMD_SIZE, vma);\n\tVM_BUG_ON(!is_pmd_migration_entry(*pmd) && !pmd_trans_huge(*pmd)\n\t\t\t\t&& !pmd_devmap(*pmd));\n\n\tcount_vm_event(THP_SPLIT_PMD);\n\n\tif (!vma_is_anonymous(vma)) {\n\t\t_pmd = pmdp_huge_clear_flush_notify(vma, haddr, pmd);\n\t\t/*\n\t\t * We are going to unmap this huge page. So\n\t\t * just go ahead and zap it\n\t\t */\n\t\tif (arch_needs_pgtable_deposit())\n\t\t\tzap_deposited_table(mm, pmd);\n\t\tif (vma_is_dax(vma))\n\t\t\treturn;\n\t\tpage = pmd_page(_pmd);\n\t\tif (!PageDirty(page) && pmd_dirty(_pmd))\n\t\t\tset_page_dirty(page);\n\t\tif (!PageReferenced(page) && pmd_young(_pmd))\n\t\t\tSetPageReferenced(page);\n\t\tpage_remove_rmap(page, true);\n\t\tput_page(page);\n\t\tadd_mm_counter(mm, mm_counter_file(page), -HPAGE_PMD_NR);\n\t\treturn;\n\t} else if (is_huge_zero_pmd(*pmd)) {\n\t\t/*\n\t\t * FIXME: Do we want to invalidate secondary mmu by calling\n\t\t * mmu_notifier_invalidate_range() see comments below inside\n\t\t * __split_huge_pmd() ?\n\t\t *\n\t\t * We are going from a zero huge page write protected to zero\n\t\t * small page also write protected so it does not seems useful\n\t\t * to invalidate secondary mmu at this time.\n\t\t */\n\t\treturn __split_huge_zero_page_pmd(vma, haddr, pmd);\n\t}\n\n\t/*\n\t * Up to this point the pmd is present and huge and userland has the\n\t * whole access to the hugepage during the split (which happens in\n\t * place). If we overwrite the pmd with the not-huge version pointing\n\t * to the pte here (which of course we could if all CPUs were bug\n\t * free), userland could trigger a small page size TLB miss on the\n\t * small sized TLB while the hugepage TLB entry is still established in\n\t * the huge TLB. Some CPU doesn't like that.\n\t * See http://support.amd.com/us/Processor_TechDocs/41322.pdf, Erratum\n\t * 383 on page 93. Intel should be safe but is also warns that it's\n\t * only safe if the permission and cache attributes of the two entries\n\t * loaded in the two TLB is identical (which should be the case here).\n\t * But it is generally safer to never allow small and huge TLB entries\n\t * for the same virtual address to be loaded simultaneously. So instead\n\t * of doing \"pmd_populate(); flush_pmd_tlb_range();\" we first mark the\n\t * current pmd notpresent (atomically because here the pmd_trans_huge\n\t * must remain set at all times on the pmd until the split is complete\n\t * for this pmd), then we flush the SMP TLB and finally we write the\n\t * non-huge version of the pmd entry with pmd_populate.\n\t */\n\told_pmd = pmdp_invalidate(vma, haddr, pmd);\n\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\n\tpmd_migration = is_pmd_migration_entry(old_pmd);\n\tif (pmd_migration) {\n\t\tswp_entry_t entry;\n\n\t\tentry = pmd_to_swp_entry(old_pmd);\n\t\tpage = pfn_to_page(swp_offset(entry));\n\t} else\n#endif\n\t\tpage = pmd_page(old_pmd);\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tpage_ref_add(page, HPAGE_PMD_NR - 1);\n\tif (pmd_dirty(old_pmd))\n\t\tSetPageDirty(page);\n\twrite = pmd_write(old_pmd);\n\tyoung = pmd_young(old_pmd);\n\tsoft_dirty = pmd_soft_dirty(old_pmd);\n\n\t/*\n\t * Withdraw the table only after we mark the pmd entry invalid.\n\t * This's critical for some architectures (Power).\n\t */\n\tpgtable = pgtable_trans_huge_withdraw(mm, pmd);\n\tpmd_populate(mm, &_pmd, pgtable);\n\n\tfor (i = 0, addr = haddr; i < HPAGE_PMD_NR; i++, addr += PAGE_SIZE) {\n\t\tpte_t entry, *pte;\n\t\t/*\n\t\t * Note that NUMA hinting access restrictions are not\n\t\t * transferred to avoid any possibility of altering\n\t\t * permissions across VMAs.\n\t\t */\n\t\tif (freeze || pmd_migration) {\n\t\t\tswp_entry_t swp_entry;\n\t\t\tswp_entry = make_migration_entry(page + i, write);\n\t\t\tentry = swp_entry_to_pte(swp_entry);\n\t\t\tif (soft_dirty)\n\t\t\t\tentry = pte_swp_mksoft_dirty(entry);\n\t\t} else {\n\t\t\tentry = mk_pte(page + i, READ_ONCE(vma->vm_page_prot));\n\t\t\tentry = maybe_mkwrite(entry, vma);\n\t\t\tif (!write)\n\t\t\t\tentry = pte_wrprotect(entry);\n\t\t\tif (!young)\n\t\t\t\tentry = pte_mkold(entry);\n\t\t\tif (soft_dirty)\n\t\t\t\tentry = pte_mksoft_dirty(entry);\n\t\t}\n\t\tpte = pte_offset_map(&_pmd, addr);\n\t\tBUG_ON(!pte_none(*pte));\n\t\tset_pte_at(mm, addr, pte, entry);\n\t\tatomic_inc(&page[i]._mapcount);\n\t\tpte_unmap(pte);\n\t}\n\n\t/*\n\t * Set PG_double_map before dropping compound_mapcount to avoid\n\t * false-negative page_mapped().\n\t */\n\tif (compound_mapcount(page) > 1 && !TestSetPageDoubleMap(page)) {\n\t\tfor (i = 0; i < HPAGE_PMD_NR; i++)\n\t\t\tatomic_inc(&page[i]._mapcount);\n\t}\n\n\tif (atomic_add_negative(-1, compound_mapcount_ptr(page))) {\n\t\t/* Last compound_mapcount is gone. */\n\t\t__dec_node_page_state(page, NR_ANON_THPS);\n\t\tif (TestClearPageDoubleMap(page)) {\n\t\t\t/* No need in mapcount reference anymore */\n\t\t\tfor (i = 0; i < HPAGE_PMD_NR; i++)\n\t\t\t\tatomic_dec(&page[i]._mapcount);\n\t\t}\n\t}\n\n\tsmp_wmb(); /* make pte visible before pmd */\n\tpmd_populate(mm, pmd, pgtable);\n\n\tif (freeze) {\n\t\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\t\tpage_remove_rmap(page + i, false);\n\t\t\tput_page(page + i);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_pmd_migration_entry",
          "args": [
            "*pmd"
          ],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_devmap",
          "args": [
            "*pmd"
          ],
          "line": 2265
        },
        "resolved": true,
        "details": {
          "function_name": "pmd_devmap_trans_unstable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3023-3026",
          "snippet": "static int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page_mlock",
          "args": [
            "page"
          ],
          "line": 2264
        },
        "resolved": true,
        "details": {
          "function_name": "clear_page_mlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "358-358",
          "snippet": "static inline void clear_page_mlock(struct page *page) { }",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void clear_page_mlock(struct page *page) { }"
        }
      },
      {
        "call_info": {
          "callee": "PageMlocked",
          "args": [
            "page"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_page",
          "args": [
            "*pmd"
          ],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "*pmd"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_page",
          "args": [
            "*pmd"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "freeze && !page"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_lock",
          "args": [
            "mm",
            "pmd"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "mm",
            "haddr",
            "haddr + HPAGE_PMD_SIZE"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid __split_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long address, bool freeze, struct page *page)\n{\n\tspinlock_t *ptl;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long haddr = address & HPAGE_PMD_MASK;\n\n\tmmu_notifier_invalidate_range_start(mm, haddr, haddr + HPAGE_PMD_SIZE);\n\tptl = pmd_lock(mm, pmd);\n\n\t/*\n\t * If caller asks to setup a migration entries, we need a page to check\n\t * pmd against. Otherwise we can end up replacing wrong page.\n\t */\n\tVM_BUG_ON(freeze && !page);\n\tif (page && page != pmd_page(*pmd))\n\t        goto out;\n\n\tif (pmd_trans_huge(*pmd)) {\n\t\tpage = pmd_page(*pmd);\n\t\tif (PageMlocked(page))\n\t\t\tclear_page_mlock(page);\n\t} else if (!(pmd_devmap(*pmd) || is_pmd_migration_entry(*pmd)))\n\t\tgoto out;\n\t__split_huge_pmd_locked(vma, pmd, haddr, freeze);\nout:\n\tspin_unlock(ptl);\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback.\n\t * They are 3 cases to consider inside __split_huge_pmd_locked():\n\t *  1) pmdp_huge_clear_flush_notify() call invalidate_range() obvious\n\t *  2) __split_huge_zero_page_pmd() read only zero page and any write\n\t *    fault will trigger a flush_notify before pointing to a new page\n\t *    (it is fine if the secondary mmu keeps pointing to the old zero\n\t *    page in the meantime)\n\t *  3) Split a huge pmd into pte pointing to the same page. No need\n\t *     to invalidate secondary tlb entry they are all still valid.\n\t *     any further changes to individual pte will notify. So no need\n\t *     to call mmu_notifier->invalidate_range()\n\t */\n\tmmu_notifier_invalidate_range_only_end(mm, haddr, haddr +\n\t\t\t\t\t       HPAGE_PMD_SIZE);\n}"
  },
  {
    "function_name": "__split_huge_pmd_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "2085-2241",
    "snippet": "static void __split_huge_pmd_locked(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long haddr, bool freeze)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page;\n\tpgtable_t pgtable;\n\tpmd_t old_pmd, _pmd;\n\tbool young, write, soft_dirty, pmd_migration = false;\n\tunsigned long addr;\n\tint i;\n\n\tVM_BUG_ON(haddr & ~HPAGE_PMD_MASK);\n\tVM_BUG_ON_VMA(vma->vm_start > haddr, vma);\n\tVM_BUG_ON_VMA(vma->vm_end < haddr + HPAGE_PMD_SIZE, vma);\n\tVM_BUG_ON(!is_pmd_migration_entry(*pmd) && !pmd_trans_huge(*pmd)\n\t\t\t\t&& !pmd_devmap(*pmd));\n\n\tcount_vm_event(THP_SPLIT_PMD);\n\n\tif (!vma_is_anonymous(vma)) {\n\t\t_pmd = pmdp_huge_clear_flush_notify(vma, haddr, pmd);\n\t\t/*\n\t\t * We are going to unmap this huge page. So\n\t\t * just go ahead and zap it\n\t\t */\n\t\tif (arch_needs_pgtable_deposit())\n\t\t\tzap_deposited_table(mm, pmd);\n\t\tif (vma_is_dax(vma))\n\t\t\treturn;\n\t\tpage = pmd_page(_pmd);\n\t\tif (!PageDirty(page) && pmd_dirty(_pmd))\n\t\t\tset_page_dirty(page);\n\t\tif (!PageReferenced(page) && pmd_young(_pmd))\n\t\t\tSetPageReferenced(page);\n\t\tpage_remove_rmap(page, true);\n\t\tput_page(page);\n\t\tadd_mm_counter(mm, mm_counter_file(page), -HPAGE_PMD_NR);\n\t\treturn;\n\t} else if (is_huge_zero_pmd(*pmd)) {\n\t\t/*\n\t\t * FIXME: Do we want to invalidate secondary mmu by calling\n\t\t * mmu_notifier_invalidate_range() see comments below inside\n\t\t * __split_huge_pmd() ?\n\t\t *\n\t\t * We are going from a zero huge page write protected to zero\n\t\t * small page also write protected so it does not seems useful\n\t\t * to invalidate secondary mmu at this time.\n\t\t */\n\t\treturn __split_huge_zero_page_pmd(vma, haddr, pmd);\n\t}\n\n\t/*\n\t * Up to this point the pmd is present and huge and userland has the\n\t * whole access to the hugepage during the split (which happens in\n\t * place). If we overwrite the pmd with the not-huge version pointing\n\t * to the pte here (which of course we could if all CPUs were bug\n\t * free), userland could trigger a small page size TLB miss on the\n\t * small sized TLB while the hugepage TLB entry is still established in\n\t * the huge TLB. Some CPU doesn't like that.\n\t * See http://support.amd.com/us/Processor_TechDocs/41322.pdf, Erratum\n\t * 383 on page 93. Intel should be safe but is also warns that it's\n\t * only safe if the permission and cache attributes of the two entries\n\t * loaded in the two TLB is identical (which should be the case here).\n\t * But it is generally safer to never allow small and huge TLB entries\n\t * for the same virtual address to be loaded simultaneously. So instead\n\t * of doing \"pmd_populate(); flush_pmd_tlb_range();\" we first mark the\n\t * current pmd notpresent (atomically because here the pmd_trans_huge\n\t * must remain set at all times on the pmd until the split is complete\n\t * for this pmd), then we flush the SMP TLB and finally we write the\n\t * non-huge version of the pmd entry with pmd_populate.\n\t */\n\told_pmd = pmdp_invalidate(vma, haddr, pmd);\n\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\n\tpmd_migration = is_pmd_migration_entry(old_pmd);\n\tif (pmd_migration) {\n\t\tswp_entry_t entry;\n\n\t\tentry = pmd_to_swp_entry(old_pmd);\n\t\tpage = pfn_to_page(swp_offset(entry));\n\t} else\n#endif\n\t\tpage = pmd_page(old_pmd);\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tpage_ref_add(page, HPAGE_PMD_NR - 1);\n\tif (pmd_dirty(old_pmd))\n\t\tSetPageDirty(page);\n\twrite = pmd_write(old_pmd);\n\tyoung = pmd_young(old_pmd);\n\tsoft_dirty = pmd_soft_dirty(old_pmd);\n\n\t/*\n\t * Withdraw the table only after we mark the pmd entry invalid.\n\t * This's critical for some architectures (Power).\n\t */\n\tpgtable = pgtable_trans_huge_withdraw(mm, pmd);\n\tpmd_populate(mm, &_pmd, pgtable);\n\n\tfor (i = 0, addr = haddr; i < HPAGE_PMD_NR; i++, addr += PAGE_SIZE) {\n\t\tpte_t entry, *pte;\n\t\t/*\n\t\t * Note that NUMA hinting access restrictions are not\n\t\t * transferred to avoid any possibility of altering\n\t\t * permissions across VMAs.\n\t\t */\n\t\tif (freeze || pmd_migration) {\n\t\t\tswp_entry_t swp_entry;\n\t\t\tswp_entry = make_migration_entry(page + i, write);\n\t\t\tentry = swp_entry_to_pte(swp_entry);\n\t\t\tif (soft_dirty)\n\t\t\t\tentry = pte_swp_mksoft_dirty(entry);\n\t\t} else {\n\t\t\tentry = mk_pte(page + i, READ_ONCE(vma->vm_page_prot));\n\t\t\tentry = maybe_mkwrite(entry, vma);\n\t\t\tif (!write)\n\t\t\t\tentry = pte_wrprotect(entry);\n\t\t\tif (!young)\n\t\t\t\tentry = pte_mkold(entry);\n\t\t\tif (soft_dirty)\n\t\t\t\tentry = pte_mksoft_dirty(entry);\n\t\t}\n\t\tpte = pte_offset_map(&_pmd, addr);\n\t\tBUG_ON(!pte_none(*pte));\n\t\tset_pte_at(mm, addr, pte, entry);\n\t\tatomic_inc(&page[i]._mapcount);\n\t\tpte_unmap(pte);\n\t}\n\n\t/*\n\t * Set PG_double_map before dropping compound_mapcount to avoid\n\t * false-negative page_mapped().\n\t */\n\tif (compound_mapcount(page) > 1 && !TestSetPageDoubleMap(page)) {\n\t\tfor (i = 0; i < HPAGE_PMD_NR; i++)\n\t\t\tatomic_inc(&page[i]._mapcount);\n\t}\n\n\tif (atomic_add_negative(-1, compound_mapcount_ptr(page))) {\n\t\t/* Last compound_mapcount is gone. */\n\t\t__dec_node_page_state(page, NR_ANON_THPS);\n\t\tif (TestClearPageDoubleMap(page)) {\n\t\t\t/* No need in mapcount reference anymore */\n\t\t\tfor (i = 0; i < HPAGE_PMD_NR; i++)\n\t\t\t\tatomic_dec(&page[i]._mapcount);\n\t\t}\n\t}\n\n\tsmp_wmb(); /* make pte visible before pmd */\n\tpmd_populate(mm, pmd, pgtable);\n\n\tif (freeze) {\n\t\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\t\tpage_remove_rmap(page + i, false);\n\t\t\tput_page(page + i);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page + i"
          ],
          "line": 2238
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_remove_rmap",
          "args": [
            "page + i",
            "false"
          ],
          "line": 2237
        },
        "resolved": true,
        "details": {
          "function_name": "page_remove_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1297-1331",
          "snippet": "void page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_populate",
          "args": [
            "mm",
            "pmd",
            "pgtable"
          ],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "zero_pmd_populate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan_init.c",
          "lines": "105-135",
          "snippet": "static int __ref zero_pmd_populate(pud_t *pud, unsigned long addr,\n\t\t\t\tunsigned long end)\n{\n\tpmd_t *pmd = pmd_offset(pud, addr);\n\tunsigned long next;\n\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\n\t\tif (IS_ALIGNED(addr, PMD_SIZE) && end - addr >= PMD_SIZE) {\n\t\t\tpmd_populate_kernel(&init_mm, pmd, lm_alias(kasan_zero_pte));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pmd_none(*pmd)) {\n\t\t\tpte_t *p;\n\n\t\t\tif (slab_is_available())\n\t\t\t\tp = pte_alloc_one_kernel(&init_mm, addr);\n\t\t\telse\n\t\t\t\tp = early_alloc(PAGE_SIZE, NUMA_NO_NODE);\n\t\t\tif (!p)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tpmd_populate_kernel(&init_mm, pmd, p);\n\t\t}\n\t\tzero_pte_populate(pmd, addr, next);\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kasan.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/page.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/memblock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pte_t kasan_zero_pte[PTRS_PER_PTE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kasan.h\"\n#include <asm/pgalloc.h>\n#include <asm/page.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/memblock.h>\n\npte_t kasan_zero_pte[PTRS_PER_PTE];\n\nstatic int __ref zero_pmd_populate(pud_t *pud, unsigned long addr,\n\t\t\t\tunsigned long end)\n{\n\tpmd_t *pmd = pmd_offset(pud, addr);\n\tunsigned long next;\n\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\n\t\tif (IS_ALIGNED(addr, PMD_SIZE) && end - addr >= PMD_SIZE) {\n\t\t\tpmd_populate_kernel(&init_mm, pmd, lm_alias(kasan_zero_pte));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pmd_none(*pmd)) {\n\t\t\tpte_t *p;\n\n\t\t\tif (slab_is_available())\n\t\t\t\tp = pte_alloc_one_kernel(&init_mm, addr);\n\t\t\telse\n\t\t\t\tp = early_alloc(PAGE_SIZE, NUMA_NO_NODE);\n\t\t\tif (!p)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tpmd_populate_kernel(&init_mm, pmd, p);\n\t\t}\n\t\tzero_pte_populate(pmd, addr, next);\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&page[i]._mapcount"
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestClearPageDoubleMap",
          "args": [
            "page"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dec_node_page_state",
          "args": [
            "page",
            "NR_ANON_THPS"
          ],
          "line": 2224
        },
        "resolved": true,
        "details": {
          "function_name": "__dec_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "460-463",
          "snippet": "void __dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__dec_node_state(page_pgdat(page), item);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__dec_node_state(page_pgdat(page), item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_add_negative",
          "args": [
            "-1",
            "compound_mapcount_ptr(page)"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_mapcount_ptr",
          "args": [
            "page"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&page[i]._mapcount"
          ],
          "line": 2219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestSetPageDoubleMap",
          "args": [
            "page"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_mapcount",
          "args": [
            "page"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap",
          "args": [
            "pte"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&page[i]._mapcount"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "mm",
            "addr",
            "pte",
            "entry"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!pte_none(*pte)"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "*pte"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map",
          "args": [
            "&_pmd",
            "addr"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mksoft_dirty",
          "args": [
            "entry"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkold",
          "args": [
            "entry"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_wrprotect",
          "args": [
            "entry"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "maybe_mkwrite",
          "args": [
            "entry",
            "vma"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mk_pte",
          "args": [
            "page + i",
            "READ_ONCE(vma->vm_page_prot)"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "vma->vm_page_prot"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_swp_mksoft_dirty",
          "args": [
            "entry"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_entry_to_pte",
          "args": [
            "swp_entry"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_migration_entry",
          "args": [
            "page + i",
            "write"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgtable_trans_huge_withdraw",
          "args": [
            "mm",
            "pmd"
          ],
          "line": 2180
        },
        "resolved": true,
        "details": {
          "function_name": "pgtable_trans_huge_withdraw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "168-181",
          "snippet": "pgtable_t pgtable_trans_huge_withdraw(struct mm_struct *mm, pmd_t *pmdp)\n{\n\tpgtable_t pgtable;\n\n\tassert_spin_locked(pmd_lockptr(mm, pmdp));\n\n\t/* FIFO */\n\tpgtable = pmd_huge_pte(mm, pmdp);\n\tpmd_huge_pte(mm, pmdp) = list_first_entry_or_null(&pgtable->lru,\n\t\t\t\t\t\t\t  struct page, lru);\n\tif (pmd_huge_pte(mm, pmdp))\n\t\tlist_del(&pgtable->lru);\n\treturn pgtable;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\npgtable_t pgtable_trans_huge_withdraw(struct mm_struct *mm, pmd_t *pmdp)\n{\n\tpgtable_t pgtable;\n\n\tassert_spin_locked(pmd_lockptr(mm, pmdp));\n\n\t/* FIFO */\n\tpgtable = pmd_huge_pte(mm, pmdp);\n\tpmd_huge_pte(mm, pmdp) = list_first_entry_or_null(&pgtable->lru,\n\t\t\t\t\t\t\t  struct page, lru);\n\tif (pmd_huge_pte(mm, pmdp))\n\t\tlist_del(&pgtable->lru);\n\treturn pgtable;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_soft_dirty",
          "args": [
            "old_pmd"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_young",
          "args": [
            "old_pmd"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_write",
          "args": [
            "old_pmd"
          ],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageDirty",
          "args": [
            "page"
          ],
          "line": 2171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_dirty",
          "args": [
            "old_pmd"
          ],
          "line": 2170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_add",
          "args": [
            "page",
            "HPAGE_PMD_NR - 1"
          ],
          "line": 2169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!page_count(page)",
            "page"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_page",
          "args": [
            "old_pmd"
          ],
          "line": 2167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "swp_offset(entry)"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_to_swp_entry",
          "args": [
            "old_pmd"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_pmd_migration_entry",
          "args": [
            "old_pmd"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmdp_invalidate",
          "args": [
            "vma",
            "haddr",
            "pmd"
          ],
          "line": 2156
        },
        "resolved": true,
        "details": {
          "function_name": "pmdp_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "185-191",
          "snippet": "pmd_t pmdp_invalidate(struct vm_area_struct *vma, unsigned long address,\n\t\t     pmd_t *pmdp)\n{\n\tpmd_t old = pmdp_establish(vma, address, pmdp, pmd_mknotpresent(*pmdp));\n\tflush_pmd_tlb_range(vma, address, address + HPAGE_PMD_SIZE);\n\treturn old;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\npmd_t pmdp_invalidate(struct vm_area_struct *vma, unsigned long address,\n\t\t     pmd_t *pmdp)\n{\n\tpmd_t old = pmdp_establish(vma, address, pmdp, pmd_mknotpresent(*pmdp));\n\tflush_pmd_tlb_range(vma, address, address + HPAGE_PMD_SIZE);\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__split_huge_zero_page_pmd",
          "args": [
            "vma",
            "haddr",
            "pmd"
          ],
          "line": 2133
        },
        "resolved": true,
        "details": {
          "function_name": "__split_huge_zero_page_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2051-2083",
          "snippet": "static void __split_huge_zero_page_pmd(struct vm_area_struct *vma,\n\t\tunsigned long haddr, pmd_t *pmd)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpgtable_t pgtable;\n\tpmd_t _pmd;\n\tint i;\n\n\t/*\n\t * Leave pmd empty until pte is filled note that it is fine to delay\n\t * notification until mmu_notifier_invalidate_range_end() as we are\n\t * replacing a zero pmd write protected page with a zero pte write\n\t * protected page.\n\t *\n\t * See Documentation/vm/mmu_notifier.rst\n\t */\n\tpmdp_huge_clear_flush(vma, haddr, pmd);\n\n\tpgtable = pgtable_trans_huge_withdraw(mm, pmd);\n\tpmd_populate(mm, &_pmd, pgtable);\n\n\tfor (i = 0; i < HPAGE_PMD_NR; i++, haddr += PAGE_SIZE) {\n\t\tpte_t *pte, entry;\n\t\tentry = pfn_pte(my_zero_pfn(haddr), vma->vm_page_prot);\n\t\tentry = pte_mkspecial(entry);\n\t\tpte = pte_offset_map(&_pmd, haddr);\n\t\tVM_BUG_ON(!pte_none(*pte));\n\t\tset_pte_at(mm, haddr, pte, entry);\n\t\tpte_unmap(pte);\n\t}\n\tsmp_wmb(); /* make pte visible before pmd */\n\tpmd_populate(mm, pmd, pgtable);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void __split_huge_zero_page_pmd(struct vm_area_struct *vma,\n\t\tunsigned long haddr, pmd_t *pmd)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpgtable_t pgtable;\n\tpmd_t _pmd;\n\tint i;\n\n\t/*\n\t * Leave pmd empty until pte is filled note that it is fine to delay\n\t * notification until mmu_notifier_invalidate_range_end() as we are\n\t * replacing a zero pmd write protected page with a zero pte write\n\t * protected page.\n\t *\n\t * See Documentation/vm/mmu_notifier.rst\n\t */\n\tpmdp_huge_clear_flush(vma, haddr, pmd);\n\n\tpgtable = pgtable_trans_huge_withdraw(mm, pmd);\n\tpmd_populate(mm, &_pmd, pgtable);\n\n\tfor (i = 0; i < HPAGE_PMD_NR; i++, haddr += PAGE_SIZE) {\n\t\tpte_t *pte, entry;\n\t\tentry = pfn_pte(my_zero_pfn(haddr), vma->vm_page_prot);\n\t\tentry = pte_mkspecial(entry);\n\t\tpte = pte_offset_map(&_pmd, haddr);\n\t\tVM_BUG_ON(!pte_none(*pte));\n\t\tset_pte_at(mm, haddr, pte, entry);\n\t\tpte_unmap(pte);\n\t}\n\tsmp_wmb(); /* make pte visible before pmd */\n\tpmd_populate(mm, pmd, pgtable);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_huge_zero_pmd",
          "args": [
            "*pmd"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_mm_counter",
          "args": [
            "mm",
            "mm_counter_file(page)",
            "-HPAGE_PMD_NR"
          ],
          "line": 2121
        },
        "resolved": true,
        "details": {
          "function_name": "add_mm_counter_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "157-165",
          "snippet": "static void add_mm_counter_fast(struct mm_struct *mm, int member, int val)\n{\n\tstruct task_struct *task = current;\n\n\tif (likely(task->mm == mm))\n\t\ttask->rss_stat.count[member] += val;\n\telse\n\t\tadd_mm_counter(mm, member, val);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void add_mm_counter_fast(struct mm_struct *mm, int member, int val)\n{\n\tstruct task_struct *task = current;\n\n\tif (likely(task->mm == mm))\n\t\ttask->rss_stat.count[member] += val;\n\telse\n\t\tadd_mm_counter(mm, member, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_counter_file",
          "args": [
            "page"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageReferenced",
          "args": [
            "page"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_young",
          "args": [
            "_pmd"
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageReferenced",
          "args": [
            "page"
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 2116
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_dirty_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2573-2581",
          "snippet": "int set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_dirty",
          "args": [
            "_pmd"
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_page",
          "args": [
            "_pmd"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_is_dax",
          "args": [
            "vma"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zap_deposited_table",
          "args": [
            "mm",
            "pmd"
          ],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "zap_deposited_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1709-1716",
          "snippet": "static inline void zap_deposited_table(struct mm_struct *mm, pmd_t *pmd)\n{\n\tpgtable_t pgtable;\n\n\tpgtable = pgtable_trans_huge_withdraw(mm, pmd);\n\tpte_free(mm, pgtable);\n\tmm_dec_nr_ptes(mm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline void zap_deposited_table(struct mm_struct *mm, pmd_t *pmd)\n{\n\tpgtable_t pgtable;\n\n\tpgtable = pgtable_trans_huge_withdraw(mm, pmd);\n\tpte_free(mm, pgtable);\n\tmm_dec_nr_ptes(mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_needs_pgtable_deposit",
          "args": [],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmdp_huge_clear_flush_notify",
          "args": [
            "vma",
            "haddr",
            "pmd"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_is_anonymous",
          "args": [
            "vma"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "THP_SPLIT_PMD"
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!is_pmd_migration_entry(*pmd) && !pmd_trans_huge(*pmd)\n\t\t\t\t&& !pmd_devmap(*pmd)"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_devmap",
          "args": [
            "*pmd"
          ],
          "line": 2100
        },
        "resolved": true,
        "details": {
          "function_name": "pmd_devmap_trans_unstable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3023-3026",
          "snippet": "static int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "*pmd"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_pmd_migration_entry",
          "args": [
            "*pmd"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_VMA",
          "args": [
            "vma->vm_end < haddr + HPAGE_PMD_SIZE",
            "vma"
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_VMA",
          "args": [
            "vma->vm_start > haddr",
            "vma"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "haddr & ~HPAGE_PMD_MASK"
          ],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void __split_huge_pmd_locked(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long haddr, bool freeze)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page;\n\tpgtable_t pgtable;\n\tpmd_t old_pmd, _pmd;\n\tbool young, write, soft_dirty, pmd_migration = false;\n\tunsigned long addr;\n\tint i;\n\n\tVM_BUG_ON(haddr & ~HPAGE_PMD_MASK);\n\tVM_BUG_ON_VMA(vma->vm_start > haddr, vma);\n\tVM_BUG_ON_VMA(vma->vm_end < haddr + HPAGE_PMD_SIZE, vma);\n\tVM_BUG_ON(!is_pmd_migration_entry(*pmd) && !pmd_trans_huge(*pmd)\n\t\t\t\t&& !pmd_devmap(*pmd));\n\n\tcount_vm_event(THP_SPLIT_PMD);\n\n\tif (!vma_is_anonymous(vma)) {\n\t\t_pmd = pmdp_huge_clear_flush_notify(vma, haddr, pmd);\n\t\t/*\n\t\t * We are going to unmap this huge page. So\n\t\t * just go ahead and zap it\n\t\t */\n\t\tif (arch_needs_pgtable_deposit())\n\t\t\tzap_deposited_table(mm, pmd);\n\t\tif (vma_is_dax(vma))\n\t\t\treturn;\n\t\tpage = pmd_page(_pmd);\n\t\tif (!PageDirty(page) && pmd_dirty(_pmd))\n\t\t\tset_page_dirty(page);\n\t\tif (!PageReferenced(page) && pmd_young(_pmd))\n\t\t\tSetPageReferenced(page);\n\t\tpage_remove_rmap(page, true);\n\t\tput_page(page);\n\t\tadd_mm_counter(mm, mm_counter_file(page), -HPAGE_PMD_NR);\n\t\treturn;\n\t} else if (is_huge_zero_pmd(*pmd)) {\n\t\t/*\n\t\t * FIXME: Do we want to invalidate secondary mmu by calling\n\t\t * mmu_notifier_invalidate_range() see comments below inside\n\t\t * __split_huge_pmd() ?\n\t\t *\n\t\t * We are going from a zero huge page write protected to zero\n\t\t * small page also write protected so it does not seems useful\n\t\t * to invalidate secondary mmu at this time.\n\t\t */\n\t\treturn __split_huge_zero_page_pmd(vma, haddr, pmd);\n\t}\n\n\t/*\n\t * Up to this point the pmd is present and huge and userland has the\n\t * whole access to the hugepage during the split (which happens in\n\t * place). If we overwrite the pmd with the not-huge version pointing\n\t * to the pte here (which of course we could if all CPUs were bug\n\t * free), userland could trigger a small page size TLB miss on the\n\t * small sized TLB while the hugepage TLB entry is still established in\n\t * the huge TLB. Some CPU doesn't like that.\n\t * See http://support.amd.com/us/Processor_TechDocs/41322.pdf, Erratum\n\t * 383 on page 93. Intel should be safe but is also warns that it's\n\t * only safe if the permission and cache attributes of the two entries\n\t * loaded in the two TLB is identical (which should be the case here).\n\t * But it is generally safer to never allow small and huge TLB entries\n\t * for the same virtual address to be loaded simultaneously. So instead\n\t * of doing \"pmd_populate(); flush_pmd_tlb_range();\" we first mark the\n\t * current pmd notpresent (atomically because here the pmd_trans_huge\n\t * must remain set at all times on the pmd until the split is complete\n\t * for this pmd), then we flush the SMP TLB and finally we write the\n\t * non-huge version of the pmd entry with pmd_populate.\n\t */\n\told_pmd = pmdp_invalidate(vma, haddr, pmd);\n\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\n\tpmd_migration = is_pmd_migration_entry(old_pmd);\n\tif (pmd_migration) {\n\t\tswp_entry_t entry;\n\n\t\tentry = pmd_to_swp_entry(old_pmd);\n\t\tpage = pfn_to_page(swp_offset(entry));\n\t} else\n#endif\n\t\tpage = pmd_page(old_pmd);\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tpage_ref_add(page, HPAGE_PMD_NR - 1);\n\tif (pmd_dirty(old_pmd))\n\t\tSetPageDirty(page);\n\twrite = pmd_write(old_pmd);\n\tyoung = pmd_young(old_pmd);\n\tsoft_dirty = pmd_soft_dirty(old_pmd);\n\n\t/*\n\t * Withdraw the table only after we mark the pmd entry invalid.\n\t * This's critical for some architectures (Power).\n\t */\n\tpgtable = pgtable_trans_huge_withdraw(mm, pmd);\n\tpmd_populate(mm, &_pmd, pgtable);\n\n\tfor (i = 0, addr = haddr; i < HPAGE_PMD_NR; i++, addr += PAGE_SIZE) {\n\t\tpte_t entry, *pte;\n\t\t/*\n\t\t * Note that NUMA hinting access restrictions are not\n\t\t * transferred to avoid any possibility of altering\n\t\t * permissions across VMAs.\n\t\t */\n\t\tif (freeze || pmd_migration) {\n\t\t\tswp_entry_t swp_entry;\n\t\t\tswp_entry = make_migration_entry(page + i, write);\n\t\t\tentry = swp_entry_to_pte(swp_entry);\n\t\t\tif (soft_dirty)\n\t\t\t\tentry = pte_swp_mksoft_dirty(entry);\n\t\t} else {\n\t\t\tentry = mk_pte(page + i, READ_ONCE(vma->vm_page_prot));\n\t\t\tentry = maybe_mkwrite(entry, vma);\n\t\t\tif (!write)\n\t\t\t\tentry = pte_wrprotect(entry);\n\t\t\tif (!young)\n\t\t\t\tentry = pte_mkold(entry);\n\t\t\tif (soft_dirty)\n\t\t\t\tentry = pte_mksoft_dirty(entry);\n\t\t}\n\t\tpte = pte_offset_map(&_pmd, addr);\n\t\tBUG_ON(!pte_none(*pte));\n\t\tset_pte_at(mm, addr, pte, entry);\n\t\tatomic_inc(&page[i]._mapcount);\n\t\tpte_unmap(pte);\n\t}\n\n\t/*\n\t * Set PG_double_map before dropping compound_mapcount to avoid\n\t * false-negative page_mapped().\n\t */\n\tif (compound_mapcount(page) > 1 && !TestSetPageDoubleMap(page)) {\n\t\tfor (i = 0; i < HPAGE_PMD_NR; i++)\n\t\t\tatomic_inc(&page[i]._mapcount);\n\t}\n\n\tif (atomic_add_negative(-1, compound_mapcount_ptr(page))) {\n\t\t/* Last compound_mapcount is gone. */\n\t\t__dec_node_page_state(page, NR_ANON_THPS);\n\t\tif (TestClearPageDoubleMap(page)) {\n\t\t\t/* No need in mapcount reference anymore */\n\t\t\tfor (i = 0; i < HPAGE_PMD_NR; i++)\n\t\t\t\tatomic_dec(&page[i]._mapcount);\n\t\t}\n\t}\n\n\tsmp_wmb(); /* make pte visible before pmd */\n\tpmd_populate(mm, pmd, pgtable);\n\n\tif (freeze) {\n\t\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\t\tpage_remove_rmap(page + i, false);\n\t\t\tput_page(page + i);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "__split_huge_zero_page_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "2051-2083",
    "snippet": "static void __split_huge_zero_page_pmd(struct vm_area_struct *vma,\n\t\tunsigned long haddr, pmd_t *pmd)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpgtable_t pgtable;\n\tpmd_t _pmd;\n\tint i;\n\n\t/*\n\t * Leave pmd empty until pte is filled note that it is fine to delay\n\t * notification until mmu_notifier_invalidate_range_end() as we are\n\t * replacing a zero pmd write protected page with a zero pte write\n\t * protected page.\n\t *\n\t * See Documentation/vm/mmu_notifier.rst\n\t */\n\tpmdp_huge_clear_flush(vma, haddr, pmd);\n\n\tpgtable = pgtable_trans_huge_withdraw(mm, pmd);\n\tpmd_populate(mm, &_pmd, pgtable);\n\n\tfor (i = 0; i < HPAGE_PMD_NR; i++, haddr += PAGE_SIZE) {\n\t\tpte_t *pte, entry;\n\t\tentry = pfn_pte(my_zero_pfn(haddr), vma->vm_page_prot);\n\t\tentry = pte_mkspecial(entry);\n\t\tpte = pte_offset_map(&_pmd, haddr);\n\t\tVM_BUG_ON(!pte_none(*pte));\n\t\tset_pte_at(mm, haddr, pte, entry);\n\t\tpte_unmap(pte);\n\t}\n\tsmp_wmb(); /* make pte visible before pmd */\n\tpmd_populate(mm, pmd, pgtable);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pmd_populate",
          "args": [
            "mm",
            "pmd",
            "pgtable"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "zero_pmd_populate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan_init.c",
          "lines": "105-135",
          "snippet": "static int __ref zero_pmd_populate(pud_t *pud, unsigned long addr,\n\t\t\t\tunsigned long end)\n{\n\tpmd_t *pmd = pmd_offset(pud, addr);\n\tunsigned long next;\n\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\n\t\tif (IS_ALIGNED(addr, PMD_SIZE) && end - addr >= PMD_SIZE) {\n\t\t\tpmd_populate_kernel(&init_mm, pmd, lm_alias(kasan_zero_pte));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pmd_none(*pmd)) {\n\t\t\tpte_t *p;\n\n\t\t\tif (slab_is_available())\n\t\t\t\tp = pte_alloc_one_kernel(&init_mm, addr);\n\t\t\telse\n\t\t\t\tp = early_alloc(PAGE_SIZE, NUMA_NO_NODE);\n\t\t\tif (!p)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tpmd_populate_kernel(&init_mm, pmd, p);\n\t\t}\n\t\tzero_pte_populate(pmd, addr, next);\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kasan.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/page.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/memblock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pte_t kasan_zero_pte[PTRS_PER_PTE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kasan.h\"\n#include <asm/pgalloc.h>\n#include <asm/page.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/memblock.h>\n\npte_t kasan_zero_pte[PTRS_PER_PTE];\n\nstatic int __ref zero_pmd_populate(pud_t *pud, unsigned long addr,\n\t\t\t\tunsigned long end)\n{\n\tpmd_t *pmd = pmd_offset(pud, addr);\n\tunsigned long next;\n\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\n\t\tif (IS_ALIGNED(addr, PMD_SIZE) && end - addr >= PMD_SIZE) {\n\t\t\tpmd_populate_kernel(&init_mm, pmd, lm_alias(kasan_zero_pte));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pmd_none(*pmd)) {\n\t\t\tpte_t *p;\n\n\t\t\tif (slab_is_available())\n\t\t\t\tp = pte_alloc_one_kernel(&init_mm, addr);\n\t\t\telse\n\t\t\t\tp = early_alloc(PAGE_SIZE, NUMA_NO_NODE);\n\t\t\tif (!p)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tpmd_populate_kernel(&init_mm, pmd, p);\n\t\t}\n\t\tzero_pte_populate(pmd, addr, next);\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap",
          "args": [
            "pte"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "mm",
            "haddr",
            "pte",
            "entry"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!pte_none(*pte)"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "*pte"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map",
          "args": [
            "&_pmd",
            "haddr"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkspecial",
          "args": [
            "entry"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_pte",
          "args": [
            "my_zero_pfn(haddr)",
            "vma->vm_page_prot"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "my_zero_pfn",
          "args": [
            "haddr"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgtable_trans_huge_withdraw",
          "args": [
            "mm",
            "pmd"
          ],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "pgtable_trans_huge_withdraw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "168-181",
          "snippet": "pgtable_t pgtable_trans_huge_withdraw(struct mm_struct *mm, pmd_t *pmdp)\n{\n\tpgtable_t pgtable;\n\n\tassert_spin_locked(pmd_lockptr(mm, pmdp));\n\n\t/* FIFO */\n\tpgtable = pmd_huge_pte(mm, pmdp);\n\tpmd_huge_pte(mm, pmdp) = list_first_entry_or_null(&pgtable->lru,\n\t\t\t\t\t\t\t  struct page, lru);\n\tif (pmd_huge_pte(mm, pmdp))\n\t\tlist_del(&pgtable->lru);\n\treturn pgtable;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\npgtable_t pgtable_trans_huge_withdraw(struct mm_struct *mm, pmd_t *pmdp)\n{\n\tpgtable_t pgtable;\n\n\tassert_spin_locked(pmd_lockptr(mm, pmdp));\n\n\t/* FIFO */\n\tpgtable = pmd_huge_pte(mm, pmdp);\n\tpmd_huge_pte(mm, pmdp) = list_first_entry_or_null(&pgtable->lru,\n\t\t\t\t\t\t\t  struct page, lru);\n\tif (pmd_huge_pte(mm, pmdp))\n\t\tlist_del(&pgtable->lru);\n\treturn pgtable;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmdp_huge_clear_flush",
          "args": [
            "vma",
            "haddr",
            "pmd"
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "pmdp_huge_clear_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "124-134",
          "snippet": "pmd_t pmdp_huge_clear_flush(struct vm_area_struct *vma, unsigned long address,\n\t\t\t    pmd_t *pmdp)\n{\n\tpmd_t pmd;\n\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);\n\tVM_BUG_ON((pmd_present(*pmdp) && !pmd_trans_huge(*pmdp) &&\n\t\t\t   !pmd_devmap(*pmdp)) || !pmd_present(*pmdp));\n\tpmd = pmdp_huge_get_and_clear(vma->vm_mm, address, pmdp);\n\tflush_pmd_tlb_range(vma, address, address + HPAGE_PMD_SIZE);\n\treturn pmd;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\npmd_t pmdp_huge_clear_flush(struct vm_area_struct *vma, unsigned long address,\n\t\t\t    pmd_t *pmdp)\n{\n\tpmd_t pmd;\n\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);\n\tVM_BUG_ON((pmd_present(*pmdp) && !pmd_trans_huge(*pmdp) &&\n\t\t\t   !pmd_devmap(*pmdp)) || !pmd_present(*pmdp));\n\tpmd = pmdp_huge_get_and_clear(vma->vm_mm, address, pmdp);\n\tflush_pmd_tlb_range(vma, address, address + HPAGE_PMD_SIZE);\n\treturn pmd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void __split_huge_zero_page_pmd(struct vm_area_struct *vma,\n\t\tunsigned long haddr, pmd_t *pmd)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpgtable_t pgtable;\n\tpmd_t _pmd;\n\tint i;\n\n\t/*\n\t * Leave pmd empty until pte is filled note that it is fine to delay\n\t * notification until mmu_notifier_invalidate_range_end() as we are\n\t * replacing a zero pmd write protected page with a zero pte write\n\t * protected page.\n\t *\n\t * See Documentation/vm/mmu_notifier.rst\n\t */\n\tpmdp_huge_clear_flush(vma, haddr, pmd);\n\n\tpgtable = pgtable_trans_huge_withdraw(mm, pmd);\n\tpmd_populate(mm, &_pmd, pgtable);\n\n\tfor (i = 0; i < HPAGE_PMD_NR; i++, haddr += PAGE_SIZE) {\n\t\tpte_t *pte, entry;\n\t\tentry = pfn_pte(my_zero_pfn(haddr), vma->vm_page_prot);\n\t\tentry = pte_mkspecial(entry);\n\t\tpte = pte_offset_map(&_pmd, haddr);\n\t\tVM_BUG_ON(!pte_none(*pte));\n\t\tset_pte_at(mm, haddr, pte, entry);\n\t\tpte_unmap(pte);\n\t}\n\tsmp_wmb(); /* make pte visible before pmd */\n\tpmd_populate(mm, pmd, pgtable);\n}"
  },
  {
    "function_name": "__split_huge_pud",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "2027-2048",
    "snippet": "void __split_huge_pud(struct vm_area_struct *vma, pud_t *pud,\n\t\tunsigned long address)\n{\n\tspinlock_t *ptl;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long haddr = address & HPAGE_PUD_MASK;\n\n\tmmu_notifier_invalidate_range_start(mm, haddr, haddr + HPAGE_PUD_SIZE);\n\tptl = pud_lock(mm, pud);\n\tif (unlikely(!pud_trans_huge(*pud) && !pud_devmap(*pud)))\n\t\tgoto out;\n\t__split_huge_pud_locked(vma, pud, haddr);\n\nout:\n\tspin_unlock(ptl);\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback as\n\t * the above pudp_huge_clear_flush_notify() did already call it.\n\t */\n\tmmu_notifier_invalidate_range_only_end(mm, haddr, haddr +\n\t\t\t\t\t       HPAGE_PUD_SIZE);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_only_end",
          "args": [
            "mm",
            "haddr",
            "haddr +\n\t\t\t\t\t       HPAGE_PUD_SIZE"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__split_huge_pud_locked",
          "args": [
            "vma",
            "pud",
            "haddr"
          ],
          "line": 2038
        },
        "resolved": true,
        "details": {
          "function_name": "__split_huge_pud_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2014-2025",
          "snippet": "static void __split_huge_pud_locked(struct vm_area_struct *vma, pud_t *pud,\n\t\tunsigned long haddr)\n{\n\tVM_BUG_ON(haddr & ~HPAGE_PUD_MASK);\n\tVM_BUG_ON_VMA(vma->vm_start > haddr, vma);\n\tVM_BUG_ON_VMA(vma->vm_end < haddr + HPAGE_PUD_SIZE, vma);\n\tVM_BUG_ON(!pud_trans_huge(*pud) && !pud_devmap(*pud));\n\n\tcount_vm_event(THP_SPLIT_PUD);\n\n\tpudp_huge_clear_flush_notify(vma, haddr, pud);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void __split_huge_pud_locked(struct vm_area_struct *vma, pud_t *pud,\n\t\tunsigned long haddr)\n{\n\tVM_BUG_ON(haddr & ~HPAGE_PUD_MASK);\n\tVM_BUG_ON_VMA(vma->vm_start > haddr, vma);\n\tVM_BUG_ON_VMA(vma->vm_end < haddr + HPAGE_PUD_SIZE, vma);\n\tVM_BUG_ON(!pud_trans_huge(*pud) && !pud_devmap(*pud));\n\n\tcount_vm_event(THP_SPLIT_PUD);\n\n\tpudp_huge_clear_flush_notify(vma, haddr, pud);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pud_trans_huge(*pud) && !pud_devmap(*pud)"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_devmap",
          "args": [
            "*pud"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_trans_huge",
          "args": [
            "*pud"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_lock",
          "args": [
            "mm",
            "pud"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "mm",
            "haddr",
            "haddr + HPAGE_PUD_SIZE"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid __split_huge_pud(struct vm_area_struct *vma, pud_t *pud,\n\t\tunsigned long address)\n{\n\tspinlock_t *ptl;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long haddr = address & HPAGE_PUD_MASK;\n\n\tmmu_notifier_invalidate_range_start(mm, haddr, haddr + HPAGE_PUD_SIZE);\n\tptl = pud_lock(mm, pud);\n\tif (unlikely(!pud_trans_huge(*pud) && !pud_devmap(*pud)))\n\t\tgoto out;\n\t__split_huge_pud_locked(vma, pud, haddr);\n\nout:\n\tspin_unlock(ptl);\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback as\n\t * the above pudp_huge_clear_flush_notify() did already call it.\n\t */\n\tmmu_notifier_invalidate_range_only_end(mm, haddr, haddr +\n\t\t\t\t\t       HPAGE_PUD_SIZE);\n}"
  },
  {
    "function_name": "__split_huge_pud_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "2014-2025",
    "snippet": "static void __split_huge_pud_locked(struct vm_area_struct *vma, pud_t *pud,\n\t\tunsigned long haddr)\n{\n\tVM_BUG_ON(haddr & ~HPAGE_PUD_MASK);\n\tVM_BUG_ON_VMA(vma->vm_start > haddr, vma);\n\tVM_BUG_ON_VMA(vma->vm_end < haddr + HPAGE_PUD_SIZE, vma);\n\tVM_BUG_ON(!pud_trans_huge(*pud) && !pud_devmap(*pud));\n\n\tcount_vm_event(THP_SPLIT_PUD);\n\n\tpudp_huge_clear_flush_notify(vma, haddr, pud);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pudp_huge_clear_flush_notify",
          "args": [
            "vma",
            "haddr",
            "pud"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "THP_SPLIT_PUD"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!pud_trans_huge(*pud) && !pud_devmap(*pud)"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_devmap",
          "args": [
            "*pud"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_trans_huge",
          "args": [
            "*pud"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_VMA",
          "args": [
            "vma->vm_end < haddr + HPAGE_PUD_SIZE",
            "vma"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_VMA",
          "args": [
            "vma->vm_start > haddr",
            "vma"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "haddr & ~HPAGE_PUD_MASK"
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void __split_huge_pud_locked(struct vm_area_struct *vma, pud_t *pud,\n\t\tunsigned long haddr)\n{\n\tVM_BUG_ON(haddr & ~HPAGE_PUD_MASK);\n\tVM_BUG_ON_VMA(vma->vm_start > haddr, vma);\n\tVM_BUG_ON_VMA(vma->vm_end < haddr + HPAGE_PUD_SIZE, vma);\n\tVM_BUG_ON(!pud_trans_huge(*pud) && !pud_devmap(*pud));\n\n\tcount_vm_event(THP_SPLIT_PUD);\n\n\tpudp_huge_clear_flush_notify(vma, haddr, pud);\n}"
  },
  {
    "function_name": "zap_huge_pud",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "1986-2012",
    "snippet": "int zap_huge_pud(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\t pud_t *pud, unsigned long addr)\n{\n\tpud_t orig_pud;\n\tspinlock_t *ptl;\n\n\tptl = __pud_trans_huge_lock(pud, vma);\n\tif (!ptl)\n\t\treturn 0;\n\t/*\n\t * For architectures like ppc64 we look at deposited pgtable\n\t * when calling pudp_huge_get_and_clear. So do the\n\t * pgtable_trans_huge_withdraw after finishing pudp related\n\t * operations.\n\t */\n\torig_pud = pudp_huge_get_and_clear_full(tlb->mm, addr, pud,\n\t\t\ttlb->fullmm);\n\ttlb_remove_pud_tlb_entry(tlb, pud, addr);\n\tif (vma_is_dax(vma)) {\n\t\tspin_unlock(ptl);\n\t\t/* No zero page support yet */\n\t} else {\n\t\t/* No support for anonymous PUD pages yet */\n\t\tBUG();\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_is_dax",
          "args": [
            "vma"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlb_remove_pud_tlb_entry",
          "args": [
            "tlb",
            "pud",
            "addr"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pudp_huge_get_and_clear_full",
          "args": [
            "tlb->mm",
            "addr",
            "pud",
            "tlb->fullmm"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pud_trans_huge_lock",
          "args": [
            "pud",
            "vma"
          ],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "__pud_trans_huge_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1974-1983",
          "snippet": "spinlock_t *__pud_trans_huge_lock(pud_t *pud, struct vm_area_struct *vma)\n{\n\tspinlock_t *ptl;\n\n\tptl = pud_lock(vma->vm_mm, pud);\n\tif (likely(pud_trans_huge(*pud) || pud_devmap(*pud)))\n\t\treturn ptl;\n\tspin_unlock(ptl);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nspinlock_t *__pud_trans_huge_lock(pud_t *pud, struct vm_area_struct *vma)\n{\n\tspinlock_t *ptl;\n\n\tptl = pud_lock(vma->vm_mm, pud);\n\tif (likely(pud_trans_huge(*pud) || pud_devmap(*pud)))\n\t\treturn ptl;\n\tspin_unlock(ptl);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint zap_huge_pud(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\t pud_t *pud, unsigned long addr)\n{\n\tpud_t orig_pud;\n\tspinlock_t *ptl;\n\n\tptl = __pud_trans_huge_lock(pud, vma);\n\tif (!ptl)\n\t\treturn 0;\n\t/*\n\t * For architectures like ppc64 we look at deposited pgtable\n\t * when calling pudp_huge_get_and_clear. So do the\n\t * pgtable_trans_huge_withdraw after finishing pudp related\n\t * operations.\n\t */\n\torig_pud = pudp_huge_get_and_clear_full(tlb->mm, addr, pud,\n\t\t\ttlb->fullmm);\n\ttlb_remove_pud_tlb_entry(tlb, pud, addr);\n\tif (vma_is_dax(vma)) {\n\t\tspin_unlock(ptl);\n\t\t/* No zero page support yet */\n\t} else {\n\t\t/* No support for anonymous PUD pages yet */\n\t\tBUG();\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "__pud_trans_huge_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "1974-1983",
    "snippet": "spinlock_t *__pud_trans_huge_lock(pud_t *pud, struct vm_area_struct *vma)\n{\n\tspinlock_t *ptl;\n\n\tptl = pud_lock(vma->vm_mm, pud);\n\tif (likely(pud_trans_huge(*pud) || pud_devmap(*pud)))\n\t\treturn ptl;\n\tspin_unlock(ptl);\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "pud_trans_huge(*pud) || pud_devmap(*pud)"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_devmap",
          "args": [
            "*pud"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_trans_huge",
          "args": [
            "*pud"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_lock",
          "args": [
            "vma->vm_mm",
            "pud"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nspinlock_t *__pud_trans_huge_lock(pud_t *pud, struct vm_area_struct *vma)\n{\n\tspinlock_t *ptl;\n\n\tptl = pud_lock(vma->vm_mm, pud);\n\tif (likely(pud_trans_huge(*pud) || pud_devmap(*pud)))\n\t\treturn ptl;\n\tspin_unlock(ptl);\n\treturn NULL;\n}"
  },
  {
    "function_name": "__pmd_trans_huge_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "1957-1966",
    "snippet": "spinlock_t *__pmd_trans_huge_lock(pmd_t *pmd, struct vm_area_struct *vma)\n{\n\tspinlock_t *ptl;\n\tptl = pmd_lock(vma->vm_mm, pmd);\n\tif (likely(is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) ||\n\t\t\tpmd_devmap(*pmd)))\n\t\treturn ptl;\n\tspin_unlock(ptl);\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) ||\n\t\t\tpmd_devmap(*pmd)"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_devmap",
          "args": [
            "*pmd"
          ],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "pmd_devmap_trans_unstable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3023-3026",
          "snippet": "static int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "*pmd"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swap_pmd",
          "args": [
            "*pmd"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_lock",
          "args": [
            "vma->vm_mm",
            "pmd"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nspinlock_t *__pmd_trans_huge_lock(pmd_t *pmd, struct vm_area_struct *vma)\n{\n\tspinlock_t *ptl;\n\tptl = pmd_lock(vma->vm_mm, pmd);\n\tif (likely(is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) ||\n\t\t\tpmd_devmap(*pmd)))\n\t\treturn ptl;\n\tspin_unlock(ptl);\n\treturn NULL;\n}"
  },
  {
    "function_name": "change_huge_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "1869-1949",
    "snippet": "int change_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long addr, pgprot_t newprot, int prot_numa)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tspinlock_t *ptl;\n\tpmd_t entry;\n\tbool preserve_write;\n\tint ret;\n\n\tptl = __pmd_trans_huge_lock(pmd, vma);\n\tif (!ptl)\n\t\treturn 0;\n\n\tpreserve_write = prot_numa && pmd_write(*pmd);\n\tret = 1;\n\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\n\tif (is_swap_pmd(*pmd)) {\n\t\tswp_entry_t entry = pmd_to_swp_entry(*pmd);\n\n\t\tVM_BUG_ON(!is_pmd_migration_entry(*pmd));\n\t\tif (is_write_migration_entry(entry)) {\n\t\t\tpmd_t newpmd;\n\t\t\t/*\n\t\t\t * A protection check is difficult so\n\t\t\t * just be safe and disable write\n\t\t\t */\n\t\t\tmake_migration_entry_read(&entry);\n\t\t\tnewpmd = swp_entry_to_pmd(entry);\n\t\t\tif (pmd_swp_soft_dirty(*pmd))\n\t\t\t\tnewpmd = pmd_swp_mksoft_dirty(newpmd);\n\t\t\tset_pmd_at(mm, addr, pmd, newpmd);\n\t\t}\n\t\tgoto unlock;\n\t}\n#endif\n\n\t/*\n\t * Avoid trapping faults against the zero page. The read-only\n\t * data is likely to be read-cached on the local CPU and\n\t * local/remote hits to the zero page are not interesting.\n\t */\n\tif (prot_numa && is_huge_zero_pmd(*pmd))\n\t\tgoto unlock;\n\n\tif (prot_numa && pmd_protnone(*pmd))\n\t\tgoto unlock;\n\n\t/*\n\t * In case prot_numa, we are under down_read(mmap_sem). It's critical\n\t * to not clear pmd intermittently to avoid race with MADV_DONTNEED\n\t * which is also under down_read(mmap_sem):\n\t *\n\t *\tCPU0:\t\t\t\tCPU1:\n\t *\t\t\t\tchange_huge_pmd(prot_numa=1)\n\t *\t\t\t\t pmdp_huge_get_and_clear_notify()\n\t * madvise_dontneed()\n\t *  zap_pmd_range()\n\t *   pmd_trans_huge(*pmd) == 0 (without ptl)\n\t *   // skip the pmd\n\t *\t\t\t\t set_pmd_at();\n\t *\t\t\t\t // pmd is re-established\n\t *\n\t * The race makes MADV_DONTNEED miss the huge pmd and don't clear it\n\t * which may break userspace.\n\t *\n\t * pmdp_invalidate() is required to make sure we don't miss\n\t * dirty/young flags set by hardware.\n\t */\n\tentry = pmdp_invalidate(vma, addr, pmd);\n\n\tentry = pmd_modify(entry, newprot);\n\tif (preserve_write)\n\t\tentry = pmd_mk_savedwrite(entry);\n\tret = HPAGE_PMD_NR;\n\tset_pmd_at(mm, addr, pmd, entry);\n\tBUG_ON(vma_is_anonymous(vma) && !preserve_write && pmd_write(entry));\nunlock:\n\tspin_unlock(ptl);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "vma_is_anonymous(vma) && !preserve_write && pmd_write(entry)"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_write",
          "args": [
            "entry"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_is_anonymous",
          "args": [
            "vma"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pmd_at",
          "args": [
            "mm",
            "addr",
            "pmd",
            "entry"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_mk_savedwrite",
          "args": [
            "entry"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_modify",
          "args": [
            "entry",
            "newprot"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmdp_invalidate",
          "args": [
            "vma",
            "addr",
            "pmd"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "pmdp_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "185-191",
          "snippet": "pmd_t pmdp_invalidate(struct vm_area_struct *vma, unsigned long address,\n\t\t     pmd_t *pmdp)\n{\n\tpmd_t old = pmdp_establish(vma, address, pmdp, pmd_mknotpresent(*pmdp));\n\tflush_pmd_tlb_range(vma, address, address + HPAGE_PMD_SIZE);\n\treturn old;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\npmd_t pmdp_invalidate(struct vm_area_struct *vma, unsigned long address,\n\t\t     pmd_t *pmdp)\n{\n\tpmd_t old = pmdp_establish(vma, address, pmdp, pmd_mknotpresent(*pmdp));\n\tflush_pmd_tlb_range(vma, address, address + HPAGE_PMD_SIZE);\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_protnone",
          "args": [
            "*pmd"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_huge_zero_pmd",
          "args": [
            "*pmd"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pmd_at",
          "args": [
            "mm",
            "addr",
            "pmd",
            "newpmd"
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_swp_mksoft_dirty",
          "args": [
            "newpmd"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_swp_soft_dirty",
          "args": [
            "*pmd"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_entry_to_pmd",
          "args": [
            "entry"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_migration_entry_read",
          "args": [
            "&entry"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_write_migration_entry",
          "args": [
            "entry"
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!is_pmd_migration_entry(*pmd)"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_pmd_migration_entry",
          "args": [
            "*pmd"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_to_swp_entry",
          "args": [
            "*pmd"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swap_pmd",
          "args": [
            "*pmd"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_write",
          "args": [
            "*pmd"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pmd_trans_huge_lock",
          "args": [
            "pmd",
            "vma"
          ],
          "line": 1878
        },
        "resolved": true,
        "details": {
          "function_name": "__pmd_trans_huge_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1957-1966",
          "snippet": "spinlock_t *__pmd_trans_huge_lock(pmd_t *pmd, struct vm_area_struct *vma)\n{\n\tspinlock_t *ptl;\n\tptl = pmd_lock(vma->vm_mm, pmd);\n\tif (likely(is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) ||\n\t\t\tpmd_devmap(*pmd)))\n\t\treturn ptl;\n\tspin_unlock(ptl);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nspinlock_t *__pmd_trans_huge_lock(pmd_t *pmd, struct vm_area_struct *vma)\n{\n\tspinlock_t *ptl;\n\tptl = pmd_lock(vma->vm_mm, pmd);\n\tif (likely(is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) ||\n\t\t\tpmd_devmap(*pmd)))\n\t\treturn ptl;\n\tspin_unlock(ptl);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint change_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long addr, pgprot_t newprot, int prot_numa)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tspinlock_t *ptl;\n\tpmd_t entry;\n\tbool preserve_write;\n\tint ret;\n\n\tptl = __pmd_trans_huge_lock(pmd, vma);\n\tif (!ptl)\n\t\treturn 0;\n\n\tpreserve_write = prot_numa && pmd_write(*pmd);\n\tret = 1;\n\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\n\tif (is_swap_pmd(*pmd)) {\n\t\tswp_entry_t entry = pmd_to_swp_entry(*pmd);\n\n\t\tVM_BUG_ON(!is_pmd_migration_entry(*pmd));\n\t\tif (is_write_migration_entry(entry)) {\n\t\t\tpmd_t newpmd;\n\t\t\t/*\n\t\t\t * A protection check is difficult so\n\t\t\t * just be safe and disable write\n\t\t\t */\n\t\t\tmake_migration_entry_read(&entry);\n\t\t\tnewpmd = swp_entry_to_pmd(entry);\n\t\t\tif (pmd_swp_soft_dirty(*pmd))\n\t\t\t\tnewpmd = pmd_swp_mksoft_dirty(newpmd);\n\t\t\tset_pmd_at(mm, addr, pmd, newpmd);\n\t\t}\n\t\tgoto unlock;\n\t}\n#endif\n\n\t/*\n\t * Avoid trapping faults against the zero page. The read-only\n\t * data is likely to be read-cached on the local CPU and\n\t * local/remote hits to the zero page are not interesting.\n\t */\n\tif (prot_numa && is_huge_zero_pmd(*pmd))\n\t\tgoto unlock;\n\n\tif (prot_numa && pmd_protnone(*pmd))\n\t\tgoto unlock;\n\n\t/*\n\t * In case prot_numa, we are under down_read(mmap_sem). It's critical\n\t * to not clear pmd intermittently to avoid race with MADV_DONTNEED\n\t * which is also under down_read(mmap_sem):\n\t *\n\t *\tCPU0:\t\t\t\tCPU1:\n\t *\t\t\t\tchange_huge_pmd(prot_numa=1)\n\t *\t\t\t\t pmdp_huge_get_and_clear_notify()\n\t * madvise_dontneed()\n\t *  zap_pmd_range()\n\t *   pmd_trans_huge(*pmd) == 0 (without ptl)\n\t *   // skip the pmd\n\t *\t\t\t\t set_pmd_at();\n\t *\t\t\t\t // pmd is re-established\n\t *\n\t * The race makes MADV_DONTNEED miss the huge pmd and don't clear it\n\t * which may break userspace.\n\t *\n\t * pmdp_invalidate() is required to make sure we don't miss\n\t * dirty/young flags set by hardware.\n\t */\n\tentry = pmdp_invalidate(vma, addr, pmd);\n\n\tentry = pmd_modify(entry, newprot);\n\tif (preserve_write)\n\t\tentry = pmd_mk_savedwrite(entry);\n\tret = HPAGE_PMD_NR;\n\tset_pmd_at(mm, addr, pmd, entry);\n\tBUG_ON(vma_is_anonymous(vma) && !preserve_write && pmd_write(entry));\nunlock:\n\tspin_unlock(ptl);\n\treturn ret;\n}"
  },
  {
    "function_name": "move_huge_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "1809-1861",
    "snippet": "bool move_huge_pmd(struct vm_area_struct *vma, unsigned long old_addr,\n\t\t  unsigned long new_addr, unsigned long old_end,\n\t\t  pmd_t *old_pmd, pmd_t *new_pmd)\n{\n\tspinlock_t *old_ptl, *new_ptl;\n\tpmd_t pmd;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tbool force_flush = false;\n\n\tif ((old_addr & ~HPAGE_PMD_MASK) ||\n\t    (new_addr & ~HPAGE_PMD_MASK) ||\n\t    old_end - old_addr < HPAGE_PMD_SIZE)\n\t\treturn false;\n\n\t/*\n\t * The destination pmd shouldn't be established, free_pgtables()\n\t * should have release it.\n\t */\n\tif (WARN_ON(!pmd_none(*new_pmd))) {\n\t\tVM_BUG_ON(pmd_trans_huge(*new_pmd));\n\t\treturn false;\n\t}\n\n\t/*\n\t * We don't have to worry about the ordering of src and dst\n\t * ptlocks because exclusive mmap_sem prevents deadlock.\n\t */\n\told_ptl = __pmd_trans_huge_lock(old_pmd, vma);\n\tif (old_ptl) {\n\t\tnew_ptl = pmd_lockptr(mm, new_pmd);\n\t\tif (new_ptl != old_ptl)\n\t\t\tspin_lock_nested(new_ptl, SINGLE_DEPTH_NESTING);\n\t\tpmd = pmdp_huge_get_and_clear(mm, old_addr, old_pmd);\n\t\tif (pmd_present(pmd))\n\t\t\tforce_flush = true;\n\t\tVM_BUG_ON(!pmd_none(*new_pmd));\n\n\t\tif (pmd_move_must_withdraw(new_ptl, old_ptl, vma)) {\n\t\t\tpgtable_t pgtable;\n\t\t\tpgtable = pgtable_trans_huge_withdraw(mm, old_pmd);\n\t\t\tpgtable_trans_huge_deposit(mm, new_pmd, pgtable);\n\t\t}\n\t\tpmd = move_soft_dirty_pmd(pmd);\n\t\tset_pmd_at(mm, new_addr, new_pmd, pmd);\n\t\tif (force_flush)\n\t\t\tflush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);\n\t\tif (new_ptl != old_ptl)\n\t\t\tspin_unlock(new_ptl);\n\t\tspin_unlock(old_ptl);\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "old_ptl"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "new_ptl"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_tlb_range",
          "args": [
            "vma",
            "old_addr",
            "old_addr + PMD_SIZE"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pmd_at",
          "args": [
            "mm",
            "new_addr",
            "new_pmd",
            "pmd"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "move_soft_dirty_pmd",
          "args": [
            "pmd"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "move_soft_dirty_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1798-1807",
          "snippet": "static pmd_t move_soft_dirty_pmd(pmd_t pmd)\n{\n#ifdef CONFIG_MEM_SOFT_DIRTY\n\tif (unlikely(is_pmd_migration_entry(pmd)))\n\t\tpmd = pmd_swp_mksoft_dirty(pmd);\n\telse if (pmd_present(pmd))\n\t\tpmd = pmd_mksoft_dirty(pmd);\n#endif\n\treturn pmd;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic pmd_t move_soft_dirty_pmd(pmd_t pmd)\n{\n#ifdef CONFIG_MEM_SOFT_DIRTY\n\tif (unlikely(is_pmd_migration_entry(pmd)))\n\t\tpmd = pmd_swp_mksoft_dirty(pmd);\n\telse if (pmd_present(pmd))\n\t\tpmd = pmd_mksoft_dirty(pmd);\n#endif\n\treturn pmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgtable_trans_huge_deposit",
          "args": [
            "mm",
            "new_pmd",
            "pgtable"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "pgtable_trans_huge_deposit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "152-163",
          "snippet": "void pgtable_trans_huge_deposit(struct mm_struct *mm, pmd_t *pmdp,\n\t\t\t\tpgtable_t pgtable)\n{\n\tassert_spin_locked(pmd_lockptr(mm, pmdp));\n\n\t/* FIFO */\n\tif (!pmd_huge_pte(mm, pmdp))\n\t\tINIT_LIST_HEAD(&pgtable->lru);\n\telse\n\t\tlist_add(&pgtable->lru, &pmd_huge_pte(mm, pmdp)->lru);\n\tpmd_huge_pte(mm, pmdp) = pgtable;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\nvoid pgtable_trans_huge_deposit(struct mm_struct *mm, pmd_t *pmdp,\n\t\t\t\tpgtable_t pgtable)\n{\n\tassert_spin_locked(pmd_lockptr(mm, pmdp));\n\n\t/* FIFO */\n\tif (!pmd_huge_pte(mm, pmdp))\n\t\tINIT_LIST_HEAD(&pgtable->lru);\n\telse\n\t\tlist_add(&pgtable->lru, &pmd_huge_pte(mm, pmdp)->lru);\n\tpmd_huge_pte(mm, pmdp) = pgtable;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgtable_trans_huge_withdraw",
          "args": [
            "mm",
            "old_pmd"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "pgtable_trans_huge_withdraw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "168-181",
          "snippet": "pgtable_t pgtable_trans_huge_withdraw(struct mm_struct *mm, pmd_t *pmdp)\n{\n\tpgtable_t pgtable;\n\n\tassert_spin_locked(pmd_lockptr(mm, pmdp));\n\n\t/* FIFO */\n\tpgtable = pmd_huge_pte(mm, pmdp);\n\tpmd_huge_pte(mm, pmdp) = list_first_entry_or_null(&pgtable->lru,\n\t\t\t\t\t\t\t  struct page, lru);\n\tif (pmd_huge_pte(mm, pmdp))\n\t\tlist_del(&pgtable->lru);\n\treturn pgtable;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\npgtable_t pgtable_trans_huge_withdraw(struct mm_struct *mm, pmd_t *pmdp)\n{\n\tpgtable_t pgtable;\n\n\tassert_spin_locked(pmd_lockptr(mm, pmdp));\n\n\t/* FIFO */\n\tpgtable = pmd_huge_pte(mm, pmdp);\n\tpmd_huge_pte(mm, pmdp) = list_first_entry_or_null(&pgtable->lru,\n\t\t\t\t\t\t\t  struct page, lru);\n\tif (pmd_huge_pte(mm, pmdp))\n\t\tlist_del(&pgtable->lru);\n\treturn pgtable;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_move_must_withdraw",
          "args": [
            "new_ptl",
            "old_ptl",
            "vma"
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "pmd_move_must_withdraw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1784-1795",
          "snippet": "static inline int pmd_move_must_withdraw(spinlock_t *new_pmd_ptl,\n\t\t\t\t\t spinlock_t *old_pmd_ptl,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\t/*\n\t * With split pmd lock we also need to move preallocated\n\t * PTE page table if new_pmd is on different PMD page table.\n\t *\n\t * We also don't deposit and withdraw tables for file pages.\n\t */\n\treturn (new_pmd_ptl != old_pmd_ptl) && vma_is_anonymous(vma);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline int pmd_move_must_withdraw(spinlock_t *new_pmd_ptl,\n\t\t\t\t\t spinlock_t *old_pmd_ptl,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\t/*\n\t * With split pmd lock we also need to move preallocated\n\t * PTE page table if new_pmd is on different PMD page table.\n\t *\n\t * We also don't deposit and withdraw tables for file pages.\n\t */\n\treturn (new_pmd_ptl != old_pmd_ptl) && vma_is_anonymous(vma);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!pmd_none(*new_pmd)"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "*new_pmd"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_present",
          "args": [
            "pmd"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmdp_huge_get_and_clear",
          "args": [
            "mm",
            "old_addr",
            "old_pmd"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "new_ptl",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_lockptr",
          "args": [
            "mm",
            "new_pmd"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pmd_trans_huge_lock",
          "args": [
            "old_pmd",
            "vma"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "__pmd_trans_huge_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1957-1966",
          "snippet": "spinlock_t *__pmd_trans_huge_lock(pmd_t *pmd, struct vm_area_struct *vma)\n{\n\tspinlock_t *ptl;\n\tptl = pmd_lock(vma->vm_mm, pmd);\n\tif (likely(is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) ||\n\t\t\tpmd_devmap(*pmd)))\n\t\treturn ptl;\n\tspin_unlock(ptl);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nspinlock_t *__pmd_trans_huge_lock(pmd_t *pmd, struct vm_area_struct *vma)\n{\n\tspinlock_t *ptl;\n\tptl = pmd_lock(vma->vm_mm, pmd);\n\tif (likely(is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) ||\n\t\t\tpmd_devmap(*pmd)))\n\t\treturn ptl;\n\tspin_unlock(ptl);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "pmd_trans_huge(*new_pmd)"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "*new_pmd"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!pmd_none(*new_pmd)"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "*new_pmd"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nbool move_huge_pmd(struct vm_area_struct *vma, unsigned long old_addr,\n\t\t  unsigned long new_addr, unsigned long old_end,\n\t\t  pmd_t *old_pmd, pmd_t *new_pmd)\n{\n\tspinlock_t *old_ptl, *new_ptl;\n\tpmd_t pmd;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tbool force_flush = false;\n\n\tif ((old_addr & ~HPAGE_PMD_MASK) ||\n\t    (new_addr & ~HPAGE_PMD_MASK) ||\n\t    old_end - old_addr < HPAGE_PMD_SIZE)\n\t\treturn false;\n\n\t/*\n\t * The destination pmd shouldn't be established, free_pgtables()\n\t * should have release it.\n\t */\n\tif (WARN_ON(!pmd_none(*new_pmd))) {\n\t\tVM_BUG_ON(pmd_trans_huge(*new_pmd));\n\t\treturn false;\n\t}\n\n\t/*\n\t * We don't have to worry about the ordering of src and dst\n\t * ptlocks because exclusive mmap_sem prevents deadlock.\n\t */\n\told_ptl = __pmd_trans_huge_lock(old_pmd, vma);\n\tif (old_ptl) {\n\t\tnew_ptl = pmd_lockptr(mm, new_pmd);\n\t\tif (new_ptl != old_ptl)\n\t\t\tspin_lock_nested(new_ptl, SINGLE_DEPTH_NESTING);\n\t\tpmd = pmdp_huge_get_and_clear(mm, old_addr, old_pmd);\n\t\tif (pmd_present(pmd))\n\t\t\tforce_flush = true;\n\t\tVM_BUG_ON(!pmd_none(*new_pmd));\n\n\t\tif (pmd_move_must_withdraw(new_ptl, old_ptl, vma)) {\n\t\t\tpgtable_t pgtable;\n\t\t\tpgtable = pgtable_trans_huge_withdraw(mm, old_pmd);\n\t\t\tpgtable_trans_huge_deposit(mm, new_pmd, pgtable);\n\t\t}\n\t\tpmd = move_soft_dirty_pmd(pmd);\n\t\tset_pmd_at(mm, new_addr, new_pmd, pmd);\n\t\tif (force_flush)\n\t\t\tflush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);\n\t\tif (new_ptl != old_ptl)\n\t\t\tspin_unlock(new_ptl);\n\t\tspin_unlock(old_ptl);\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "move_soft_dirty_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "1798-1807",
    "snippet": "static pmd_t move_soft_dirty_pmd(pmd_t pmd)\n{\n#ifdef CONFIG_MEM_SOFT_DIRTY\n\tif (unlikely(is_pmd_migration_entry(pmd)))\n\t\tpmd = pmd_swp_mksoft_dirty(pmd);\n\telse if (pmd_present(pmd))\n\t\tpmd = pmd_mksoft_dirty(pmd);\n#endif\n\treturn pmd;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pmd_mksoft_dirty",
          "args": [
            "pmd"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_present",
          "args": [
            "pmd"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_swp_mksoft_dirty",
          "args": [
            "pmd"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_pmd_migration_entry(pmd)"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_pmd_migration_entry",
          "args": [
            "pmd"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic pmd_t move_soft_dirty_pmd(pmd_t pmd)\n{\n#ifdef CONFIG_MEM_SOFT_DIRTY\n\tif (unlikely(is_pmd_migration_entry(pmd)))\n\t\tpmd = pmd_swp_mksoft_dirty(pmd);\n\telse if (pmd_present(pmd))\n\t\tpmd = pmd_mksoft_dirty(pmd);\n#endif\n\treturn pmd;\n}"
  },
  {
    "function_name": "pmd_move_must_withdraw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "1784-1795",
    "snippet": "static inline int pmd_move_must_withdraw(spinlock_t *new_pmd_ptl,\n\t\t\t\t\t spinlock_t *old_pmd_ptl,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\t/*\n\t * With split pmd lock we also need to move preallocated\n\t * PTE page table if new_pmd is on different PMD page table.\n\t *\n\t * We also don't deposit and withdraw tables for file pages.\n\t */\n\treturn (new_pmd_ptl != old_pmd_ptl) && vma_is_anonymous(vma);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vma_is_anonymous",
          "args": [
            "vma"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline int pmd_move_must_withdraw(spinlock_t *new_pmd_ptl,\n\t\t\t\t\t spinlock_t *old_pmd_ptl,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\t/*\n\t * With split pmd lock we also need to move preallocated\n\t * PTE page table if new_pmd is on different PMD page table.\n\t *\n\t * We also don't deposit and withdraw tables for file pages.\n\t */\n\treturn (new_pmd_ptl != old_pmd_ptl) && vma_is_anonymous(vma);\n}"
  },
  {
    "function_name": "zap_huge_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "1718-1781",
    "snippet": "int zap_huge_pmd(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\t pmd_t *pmd, unsigned long addr)\n{\n\tpmd_t orig_pmd;\n\tspinlock_t *ptl;\n\n\ttlb_remove_check_page_size_change(tlb, HPAGE_PMD_SIZE);\n\n\tptl = __pmd_trans_huge_lock(pmd, vma);\n\tif (!ptl)\n\t\treturn 0;\n\t/*\n\t * For architectures like ppc64 we look at deposited pgtable\n\t * when calling pmdp_huge_get_and_clear. So do the\n\t * pgtable_trans_huge_withdraw after finishing pmdp related\n\t * operations.\n\t */\n\torig_pmd = pmdp_huge_get_and_clear_full(tlb->mm, addr, pmd,\n\t\t\ttlb->fullmm);\n\ttlb_remove_pmd_tlb_entry(tlb, pmd, addr);\n\tif (vma_is_dax(vma)) {\n\t\tif (arch_needs_pgtable_deposit())\n\t\t\tzap_deposited_table(tlb->mm, pmd);\n\t\tspin_unlock(ptl);\n\t\tif (is_huge_zero_pmd(orig_pmd))\n\t\t\ttlb_remove_page_size(tlb, pmd_page(orig_pmd), HPAGE_PMD_SIZE);\n\t} else if (is_huge_zero_pmd(orig_pmd)) {\n\t\tzap_deposited_table(tlb->mm, pmd);\n\t\tspin_unlock(ptl);\n\t\ttlb_remove_page_size(tlb, pmd_page(orig_pmd), HPAGE_PMD_SIZE);\n\t} else {\n\t\tstruct page *page = NULL;\n\t\tint flush_needed = 1;\n\n\t\tif (pmd_present(orig_pmd)) {\n\t\t\tpage = pmd_page(orig_pmd);\n\t\t\tpage_remove_rmap(page, true);\n\t\t\tVM_BUG_ON_PAGE(page_mapcount(page) < 0, page);\n\t\t\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\t\t} else if (thp_migration_supported()) {\n\t\t\tswp_entry_t entry;\n\n\t\t\tVM_BUG_ON(!is_pmd_migration_entry(orig_pmd));\n\t\t\tentry = pmd_to_swp_entry(orig_pmd);\n\t\t\tpage = pfn_to_page(swp_offset(entry));\n\t\t\tflush_needed = 0;\n\t\t} else\n\t\t\tWARN_ONCE(1, \"Non present huge pmd without pmd migration enabled!\");\n\n\t\tif (PageAnon(page)) {\n\t\t\tzap_deposited_table(tlb->mm, pmd);\n\t\t\tadd_mm_counter(tlb->mm, MM_ANONPAGES, -HPAGE_PMD_NR);\n\t\t} else {\n\t\t\tif (arch_needs_pgtable_deposit())\n\t\t\t\tzap_deposited_table(tlb->mm, pmd);\n\t\t\tadd_mm_counter(tlb->mm, mm_counter_file(page), -HPAGE_PMD_NR);\n\t\t}\n\n\t\tspin_unlock(ptl);\n\t\tif (flush_needed)\n\t\t\ttlb_remove_page_size(tlb, page, HPAGE_PMD_SIZE);\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tlb_remove_page_size",
          "args": [
            "tlb",
            "page",
            "HPAGE_PMD_SIZE"
          ],
          "line": 1778
        },
        "resolved": true,
        "details": {
          "function_name": "__tlb_remove_page_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
          "lines": "119-140",
          "snippet": "bool __tlb_remove_page_size(struct mmu_gather *tlb, struct page *page, int page_size)\n{\n\tstruct mmu_gather_batch *batch;\n\n\tVM_BUG_ON(!tlb->end);\n\tVM_WARN_ON(tlb->page_size != page_size);\n\n\tbatch = tlb->active;\n\t/*\n\t * Add the page and check if we are full. If so\n\t * force a flush.\n\t */\n\tbatch->pages[batch->nr++] = page;\n\tif (batch->nr == batch->max) {\n\t\tif (!tlb_next_batch(tlb))\n\t\t\treturn true;\n\t\tbatch = tlb->active;\n\t}\n\tVM_BUG_ON_PAGE(batch->nr > batch->max, page);\n\n\treturn false;\n}",
          "includes": [
            "#include <asm/tlb.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/smp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nbool __tlb_remove_page_size(struct mmu_gather *tlb, struct page *page, int page_size)\n{\n\tstruct mmu_gather_batch *batch;\n\n\tVM_BUG_ON(!tlb->end);\n\tVM_WARN_ON(tlb->page_size != page_size);\n\n\tbatch = tlb->active;\n\t/*\n\t * Add the page and check if we are full. If so\n\t * force a flush.\n\t */\n\tbatch->pages[batch->nr++] = page;\n\tif (batch->nr == batch->max) {\n\t\tif (!tlb_next_batch(tlb))\n\t\t\treturn true;\n\t\tbatch = tlb->active;\n\t}\n\tVM_BUG_ON_PAGE(batch->nr > batch->max, page);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_mm_counter",
          "args": [
            "tlb->mm",
            "mm_counter_file(page)",
            "-HPAGE_PMD_NR"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "add_mm_counter_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "157-165",
          "snippet": "static void add_mm_counter_fast(struct mm_struct *mm, int member, int val)\n{\n\tstruct task_struct *task = current;\n\n\tif (likely(task->mm == mm))\n\t\ttask->rss_stat.count[member] += val;\n\telse\n\t\tadd_mm_counter(mm, member, val);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void add_mm_counter_fast(struct mm_struct *mm, int member, int val)\n{\n\tstruct task_struct *task = current;\n\n\tif (likely(task->mm == mm))\n\t\ttask->rss_stat.count[member] += val;\n\telse\n\t\tadd_mm_counter(mm, member, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_counter_file",
          "args": [
            "page"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zap_deposited_table",
          "args": [
            "tlb->mm",
            "pmd"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "zap_deposited_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1709-1716",
          "snippet": "static inline void zap_deposited_table(struct mm_struct *mm, pmd_t *pmd)\n{\n\tpgtable_t pgtable;\n\n\tpgtable = pgtable_trans_huge_withdraw(mm, pmd);\n\tpte_free(mm, pgtable);\n\tmm_dec_nr_ptes(mm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline void zap_deposited_table(struct mm_struct *mm, pmd_t *pmd)\n{\n\tpgtable_t pgtable;\n\n\tpgtable = pgtable_trans_huge_withdraw(mm, pmd);\n\tpte_free(mm, pgtable);\n\tmm_dec_nr_ptes(mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_needs_pgtable_deposit",
          "args": [],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"Non present huge pmd without pmd migration enabled!\""
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "swp_offset(entry)"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_to_swp_entry",
          "args": [
            "orig_pmd"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!is_pmd_migration_entry(orig_pmd)"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_pmd_migration_entry",
          "args": [
            "orig_pmd"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thp_migration_supported",
          "args": [],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageHead(page)",
            "page"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHead",
          "args": [
            "page"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "PageHeadHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1350-1356",
          "snippet": "int PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "page_mapcount(page) < 0",
            "page"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "page"
          ],
          "line": 1755
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_remove_rmap",
          "args": [
            "page",
            "true"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "page_remove_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1297-1331",
          "snippet": "void page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_page",
          "args": [
            "orig_pmd"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_present",
          "args": [
            "orig_pmd"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_page",
          "args": [
            "orig_pmd"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_huge_zero_pmd",
          "args": [
            "orig_pmd"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_page",
          "args": [
            "orig_pmd"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_huge_zero_pmd",
          "args": [
            "orig_pmd"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_needs_pgtable_deposit",
          "args": [],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_is_dax",
          "args": [
            "vma"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlb_remove_pmd_tlb_entry",
          "args": [
            "tlb",
            "pmd",
            "addr"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmdp_huge_get_and_clear_full",
          "args": [
            "tlb->mm",
            "addr",
            "pmd",
            "tlb->fullmm"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pmd_trans_huge_lock",
          "args": [
            "pmd",
            "vma"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "__pmd_trans_huge_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1957-1966",
          "snippet": "spinlock_t *__pmd_trans_huge_lock(pmd_t *pmd, struct vm_area_struct *vma)\n{\n\tspinlock_t *ptl;\n\tptl = pmd_lock(vma->vm_mm, pmd);\n\tif (likely(is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) ||\n\t\t\tpmd_devmap(*pmd)))\n\t\treturn ptl;\n\tspin_unlock(ptl);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nspinlock_t *__pmd_trans_huge_lock(pmd_t *pmd, struct vm_area_struct *vma)\n{\n\tspinlock_t *ptl;\n\tptl = pmd_lock(vma->vm_mm, pmd);\n\tif (likely(is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) ||\n\t\t\tpmd_devmap(*pmd)))\n\t\treturn ptl;\n\tspin_unlock(ptl);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlb_remove_check_page_size_change",
          "args": [
            "tlb",
            "HPAGE_PMD_SIZE"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint zap_huge_pmd(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\t pmd_t *pmd, unsigned long addr)\n{\n\tpmd_t orig_pmd;\n\tspinlock_t *ptl;\n\n\ttlb_remove_check_page_size_change(tlb, HPAGE_PMD_SIZE);\n\n\tptl = __pmd_trans_huge_lock(pmd, vma);\n\tif (!ptl)\n\t\treturn 0;\n\t/*\n\t * For architectures like ppc64 we look at deposited pgtable\n\t * when calling pmdp_huge_get_and_clear. So do the\n\t * pgtable_trans_huge_withdraw after finishing pmdp related\n\t * operations.\n\t */\n\torig_pmd = pmdp_huge_get_and_clear_full(tlb->mm, addr, pmd,\n\t\t\ttlb->fullmm);\n\ttlb_remove_pmd_tlb_entry(tlb, pmd, addr);\n\tif (vma_is_dax(vma)) {\n\t\tif (arch_needs_pgtable_deposit())\n\t\t\tzap_deposited_table(tlb->mm, pmd);\n\t\tspin_unlock(ptl);\n\t\tif (is_huge_zero_pmd(orig_pmd))\n\t\t\ttlb_remove_page_size(tlb, pmd_page(orig_pmd), HPAGE_PMD_SIZE);\n\t} else if (is_huge_zero_pmd(orig_pmd)) {\n\t\tzap_deposited_table(tlb->mm, pmd);\n\t\tspin_unlock(ptl);\n\t\ttlb_remove_page_size(tlb, pmd_page(orig_pmd), HPAGE_PMD_SIZE);\n\t} else {\n\t\tstruct page *page = NULL;\n\t\tint flush_needed = 1;\n\n\t\tif (pmd_present(orig_pmd)) {\n\t\t\tpage = pmd_page(orig_pmd);\n\t\t\tpage_remove_rmap(page, true);\n\t\t\tVM_BUG_ON_PAGE(page_mapcount(page) < 0, page);\n\t\t\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\t\t} else if (thp_migration_supported()) {\n\t\t\tswp_entry_t entry;\n\n\t\t\tVM_BUG_ON(!is_pmd_migration_entry(orig_pmd));\n\t\t\tentry = pmd_to_swp_entry(orig_pmd);\n\t\t\tpage = pfn_to_page(swp_offset(entry));\n\t\t\tflush_needed = 0;\n\t\t} else\n\t\t\tWARN_ONCE(1, \"Non present huge pmd without pmd migration enabled!\");\n\n\t\tif (PageAnon(page)) {\n\t\t\tzap_deposited_table(tlb->mm, pmd);\n\t\t\tadd_mm_counter(tlb->mm, MM_ANONPAGES, -HPAGE_PMD_NR);\n\t\t} else {\n\t\t\tif (arch_needs_pgtable_deposit())\n\t\t\t\tzap_deposited_table(tlb->mm, pmd);\n\t\t\tadd_mm_counter(tlb->mm, mm_counter_file(page), -HPAGE_PMD_NR);\n\t\t}\n\n\t\tspin_unlock(ptl);\n\t\tif (flush_needed)\n\t\t\ttlb_remove_page_size(tlb, page, HPAGE_PMD_SIZE);\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "zap_deposited_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "1709-1716",
    "snippet": "static inline void zap_deposited_table(struct mm_struct *mm, pmd_t *pmd)\n{\n\tpgtable_t pgtable;\n\n\tpgtable = pgtable_trans_huge_withdraw(mm, pmd);\n\tpte_free(mm, pgtable);\n\tmm_dec_nr_ptes(mm);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mm_dec_nr_ptes",
          "args": [
            "mm"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_free",
          "args": [
            "mm",
            "pgtable"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgtable_trans_huge_withdraw",
          "args": [
            "mm",
            "pmd"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "pgtable_trans_huge_withdraw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "168-181",
          "snippet": "pgtable_t pgtable_trans_huge_withdraw(struct mm_struct *mm, pmd_t *pmdp)\n{\n\tpgtable_t pgtable;\n\n\tassert_spin_locked(pmd_lockptr(mm, pmdp));\n\n\t/* FIFO */\n\tpgtable = pmd_huge_pte(mm, pmdp);\n\tpmd_huge_pte(mm, pmdp) = list_first_entry_or_null(&pgtable->lru,\n\t\t\t\t\t\t\t  struct page, lru);\n\tif (pmd_huge_pte(mm, pmdp))\n\t\tlist_del(&pgtable->lru);\n\treturn pgtable;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\npgtable_t pgtable_trans_huge_withdraw(struct mm_struct *mm, pmd_t *pmdp)\n{\n\tpgtable_t pgtable;\n\n\tassert_spin_locked(pmd_lockptr(mm, pmdp));\n\n\t/* FIFO */\n\tpgtable = pmd_huge_pte(mm, pmdp);\n\tpmd_huge_pte(mm, pmdp) = list_first_entry_or_null(&pgtable->lru,\n\t\t\t\t\t\t\t  struct page, lru);\n\tif (pmd_huge_pte(mm, pmdp))\n\t\tlist_del(&pgtable->lru);\n\treturn pgtable;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline void zap_deposited_table(struct mm_struct *mm, pmd_t *pmd)\n{\n\tpgtable_t pgtable;\n\n\tpgtable = pgtable_trans_huge_withdraw(mm, pmd);\n\tpte_free(mm, pgtable);\n\tmm_dec_nr_ptes(mm);\n}"
  },
  {
    "function_name": "madvise_free_huge_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "1639-1707",
    "snippet": "bool madvise_free_huge_pmd(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\tpmd_t *pmd, unsigned long addr, unsigned long next)\n{\n\tspinlock_t *ptl;\n\tpmd_t orig_pmd;\n\tstruct page *page;\n\tstruct mm_struct *mm = tlb->mm;\n\tbool ret = false;\n\n\ttlb_remove_check_page_size_change(tlb, HPAGE_PMD_SIZE);\n\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (!ptl)\n\t\tgoto out_unlocked;\n\n\torig_pmd = *pmd;\n\tif (is_huge_zero_pmd(orig_pmd))\n\t\tgoto out;\n\n\tif (unlikely(!pmd_present(orig_pmd))) {\n\t\tVM_BUG_ON(thp_migration_supported() &&\n\t\t\t\t  !is_pmd_migration_entry(orig_pmd));\n\t\tgoto out;\n\t}\n\n\tpage = pmd_page(orig_pmd);\n\t/*\n\t * If other processes are mapping this page, we couldn't discard\n\t * the page unless they all do MADV_FREE so let's skip the page.\n\t */\n\tif (page_mapcount(page) != 1)\n\t\tgoto out;\n\n\tif (!trylock_page(page))\n\t\tgoto out;\n\n\t/*\n\t * If user want to discard part-pages of THP, split it so MADV_FREE\n\t * will deactivate only them.\n\t */\n\tif (next - addr != HPAGE_PMD_SIZE) {\n\t\tget_page(page);\n\t\tspin_unlock(ptl);\n\t\tsplit_huge_page(page);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tgoto out_unlocked;\n\t}\n\n\tif (PageDirty(page))\n\t\tClearPageDirty(page);\n\tunlock_page(page);\n\n\tif (pmd_young(orig_pmd) || pmd_dirty(orig_pmd)) {\n\t\tpmdp_invalidate(vma, addr, pmd);\n\t\torig_pmd = pmd_mkold(orig_pmd);\n\t\torig_pmd = pmd_mkclean(orig_pmd);\n\n\t\tset_pmd_at(mm, addr, pmd, orig_pmd);\n\t\ttlb_remove_pmd_tlb_entry(tlb, pmd, addr);\n\t}\n\n\tmark_page_lazyfree(page);\n\tret = true;\nout:\n\tspin_unlock(ptl);\nout_unlocked:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_page_lazyfree",
          "args": [
            "page"
          ],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "mark_page_lazyfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "637-648",
          "snippet": "void mark_page_lazyfree(struct page *page)\n{\n\tif (PageLRU(page) && PageAnon(page) && PageSwapBacked(page) &&\n\t    !PageSwapCache(page) && !PageUnevictable(page)) {\n\t\tstruct pagevec *pvec = &get_cpu_var(lru_lazyfree_pvecs);\n\n\t\tget_page(page);\n\t\tif (!pagevec_add(pvec, page) || PageCompound(page))\n\t\t\tpagevec_lru_move_fn(pvec, lru_lazyfree_fn, NULL);\n\t\tput_cpu_var(lru_lazyfree_pvecs);\n\t}\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\n\nvoid mark_page_lazyfree(struct page *page)\n{\n\tif (PageLRU(page) && PageAnon(page) && PageSwapBacked(page) &&\n\t    !PageSwapCache(page) && !PageUnevictable(page)) {\n\t\tstruct pagevec *pvec = &get_cpu_var(lru_lazyfree_pvecs);\n\n\t\tget_page(page);\n\t\tif (!pagevec_add(pvec, page) || PageCompound(page))\n\t\t\tpagevec_lru_move_fn(pvec, lru_lazyfree_fn, NULL);\n\t\tput_cpu_var(lru_lazyfree_pvecs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlb_remove_pmd_tlb_entry",
          "args": [
            "tlb",
            "pmd",
            "addr"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pmd_at",
          "args": [
            "mm",
            "addr",
            "pmd",
            "orig_pmd"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_mkclean",
          "args": [
            "orig_pmd"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_mkold",
          "args": [
            "orig_pmd"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmdp_invalidate",
          "args": [
            "vma",
            "addr",
            "pmd"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "pmdp_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "185-191",
          "snippet": "pmd_t pmdp_invalidate(struct vm_area_struct *vma, unsigned long address,\n\t\t     pmd_t *pmdp)\n{\n\tpmd_t old = pmdp_establish(vma, address, pmdp, pmd_mknotpresent(*pmdp));\n\tflush_pmd_tlb_range(vma, address, address + HPAGE_PMD_SIZE);\n\treturn old;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\npmd_t pmdp_invalidate(struct vm_area_struct *vma, unsigned long address,\n\t\t     pmd_t *pmdp)\n{\n\tpmd_t old = pmdp_establish(vma, address, pmdp, pmd_mknotpresent(*pmdp));\n\tflush_pmd_tlb_range(vma, address, address + HPAGE_PMD_SIZE);\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_dirty",
          "args": [
            "orig_pmd"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_young",
          "args": [
            "orig_pmd"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageDirty",
          "args": [
            "page"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "split_huge_page",
          "args": [
            "page"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "deferred_split_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2760-2774",
          "snippet": "void deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "page"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_page",
          "args": [
            "orig_pmd"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "thp_migration_supported() &&\n\t\t\t\t  !is_pmd_migration_entry(orig_pmd)"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_pmd_migration_entry",
          "args": [
            "orig_pmd"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thp_migration_supported",
          "args": [],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pmd_present(orig_pmd)"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_present",
          "args": [
            "orig_pmd"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_huge_zero_pmd",
          "args": [
            "orig_pmd"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge_lock",
          "args": [
            "pmd",
            "vma"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "__pmd_trans_huge_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1957-1966",
          "snippet": "spinlock_t *__pmd_trans_huge_lock(pmd_t *pmd, struct vm_area_struct *vma)\n{\n\tspinlock_t *ptl;\n\tptl = pmd_lock(vma->vm_mm, pmd);\n\tif (likely(is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) ||\n\t\t\tpmd_devmap(*pmd)))\n\t\treturn ptl;\n\tspin_unlock(ptl);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nspinlock_t *__pmd_trans_huge_lock(pmd_t *pmd, struct vm_area_struct *vma)\n{\n\tspinlock_t *ptl;\n\tptl = pmd_lock(vma->vm_mm, pmd);\n\tif (likely(is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) ||\n\t\t\tpmd_devmap(*pmd)))\n\t\treturn ptl;\n\tspin_unlock(ptl);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlb_remove_check_page_size_change",
          "args": [
            "tlb",
            "HPAGE_PMD_SIZE"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nbool madvise_free_huge_pmd(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\tpmd_t *pmd, unsigned long addr, unsigned long next)\n{\n\tspinlock_t *ptl;\n\tpmd_t orig_pmd;\n\tstruct page *page;\n\tstruct mm_struct *mm = tlb->mm;\n\tbool ret = false;\n\n\ttlb_remove_check_page_size_change(tlb, HPAGE_PMD_SIZE);\n\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (!ptl)\n\t\tgoto out_unlocked;\n\n\torig_pmd = *pmd;\n\tif (is_huge_zero_pmd(orig_pmd))\n\t\tgoto out;\n\n\tif (unlikely(!pmd_present(orig_pmd))) {\n\t\tVM_BUG_ON(thp_migration_supported() &&\n\t\t\t\t  !is_pmd_migration_entry(orig_pmd));\n\t\tgoto out;\n\t}\n\n\tpage = pmd_page(orig_pmd);\n\t/*\n\t * If other processes are mapping this page, we couldn't discard\n\t * the page unless they all do MADV_FREE so let's skip the page.\n\t */\n\tif (page_mapcount(page) != 1)\n\t\tgoto out;\n\n\tif (!trylock_page(page))\n\t\tgoto out;\n\n\t/*\n\t * If user want to discard part-pages of THP, split it so MADV_FREE\n\t * will deactivate only them.\n\t */\n\tif (next - addr != HPAGE_PMD_SIZE) {\n\t\tget_page(page);\n\t\tspin_unlock(ptl);\n\t\tsplit_huge_page(page);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tgoto out_unlocked;\n\t}\n\n\tif (PageDirty(page))\n\t\tClearPageDirty(page);\n\tunlock_page(page);\n\n\tif (pmd_young(orig_pmd) || pmd_dirty(orig_pmd)) {\n\t\tpmdp_invalidate(vma, addr, pmd);\n\t\torig_pmd = pmd_mkold(orig_pmd);\n\t\torig_pmd = pmd_mkclean(orig_pmd);\n\n\t\tset_pmd_at(mm, addr, pmd, orig_pmd);\n\t\ttlb_remove_pmd_tlb_entry(tlb, pmd, addr);\n\t}\n\n\tmark_page_lazyfree(page);\n\tret = true;\nout:\n\tspin_unlock(ptl);\nout_unlocked:\n\treturn ret;\n}"
  },
  {
    "function_name": "do_huge_pmd_numa_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "1477-1633",
    "snippet": "vm_fault_t do_huge_pmd_numa_page(struct vm_fault *vmf, pmd_t pmd)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct anon_vma *anon_vma = NULL;\n\tstruct page *page;\n\tunsigned long haddr = vmf->address & HPAGE_PMD_MASK;\n\tint page_nid = -1, this_nid = numa_node_id();\n\tint target_nid, last_cpupid = -1;\n\tbool page_locked;\n\tbool migrated = false;\n\tbool was_writable;\n\tint flags = 0;\n\n\tvmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);\n\tif (unlikely(!pmd_same(pmd, *vmf->pmd)))\n\t\tgoto out_unlock;\n\n\t/*\n\t * If there are potential migrations, wait for completion and retry\n\t * without disrupting NUMA hinting information. Do not relock and\n\t * check_same as the page may no longer be mapped.\n\t */\n\tif (unlikely(pmd_trans_migrating(*vmf->pmd))) {\n\t\tpage = pmd_page(*vmf->pmd);\n\t\tif (!get_page_unless_zero(page))\n\t\t\tgoto out_unlock;\n\t\tspin_unlock(vmf->ptl);\n\t\twait_on_page_locked(page);\n\t\tput_page(page);\n\t\tgoto out;\n\t}\n\n\tpage = pmd_page(pmd);\n\tBUG_ON(is_huge_zero_page(page));\n\tpage_nid = page_to_nid(page);\n\tlast_cpupid = page_cpupid_last(page);\n\tcount_vm_numa_event(NUMA_HINT_FAULTS);\n\tif (page_nid == this_nid) {\n\t\tcount_vm_numa_event(NUMA_HINT_FAULTS_LOCAL);\n\t\tflags |= TNF_FAULT_LOCAL;\n\t}\n\n\t/* See similar comment in do_numa_page for explanation */\n\tif (!pmd_savedwrite(pmd))\n\t\tflags |= TNF_NO_GROUP;\n\n\t/*\n\t * Acquire the page lock to serialise THP migrations but avoid dropping\n\t * page_table_lock if at all possible\n\t */\n\tpage_locked = trylock_page(page);\n\ttarget_nid = mpol_misplaced(page, vma, haddr);\n\tif (target_nid == -1) {\n\t\t/* If the page was locked, there are no parallel migrations */\n\t\tif (page_locked)\n\t\t\tgoto clear_pmdnuma;\n\t}\n\n\t/* Migration could have started since the pmd_trans_migrating check */\n\tif (!page_locked) {\n\t\tpage_nid = -1;\n\t\tif (!get_page_unless_zero(page))\n\t\t\tgoto out_unlock;\n\t\tspin_unlock(vmf->ptl);\n\t\twait_on_page_locked(page);\n\t\tput_page(page);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Page is misplaced. Page lock serialises migrations. Acquire anon_vma\n\t * to serialises splits\n\t */\n\tget_page(page);\n\tspin_unlock(vmf->ptl);\n\tanon_vma = page_lock_anon_vma_read(page);\n\n\t/* Confirm the PMD did not change while page_table_lock was released */\n\tspin_lock(vmf->ptl);\n\tif (unlikely(!pmd_same(pmd, *vmf->pmd))) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tpage_nid = -1;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Bail if we fail to protect against THP splits for any reason */\n\tif (unlikely(!anon_vma)) {\n\t\tput_page(page);\n\t\tpage_nid = -1;\n\t\tgoto clear_pmdnuma;\n\t}\n\n\t/*\n\t * Since we took the NUMA fault, we must have observed the !accessible\n\t * bit. Make sure all other CPUs agree with that, to avoid them\n\t * modifying the page we're about to migrate.\n\t *\n\t * Must be done under PTL such that we'll observe the relevant\n\t * inc_tlb_flush_pending().\n\t *\n\t * We are not sure a pending tlb flush here is for a huge page\n\t * mapping or not. Hence use the tlb range variant\n\t */\n\tif (mm_tlb_flush_pending(vma->vm_mm)) {\n\t\tflush_tlb_range(vma, haddr, haddr + HPAGE_PMD_SIZE);\n\t\t/*\n\t\t * change_huge_pmd() released the pmd lock before\n\t\t * invalidating the secondary MMUs sharing the primary\n\t\t * MMU pagetables (with ->invalidate_range()). The\n\t\t * mmu_notifier_invalidate_range_end() (which\n\t\t * internally calls ->invalidate_range()) in\n\t\t * change_pmd_range() will run after us, so we can't\n\t\t * rely on it here and we need an explicit invalidate.\n\t\t */\n\t\tmmu_notifier_invalidate_range(vma->vm_mm, haddr,\n\t\t\t\t\t      haddr + HPAGE_PMD_SIZE);\n\t}\n\n\t/*\n\t * Migrate the THP to the requested node, returns with page unlocked\n\t * and access rights restored.\n\t */\n\tspin_unlock(vmf->ptl);\n\n\tmigrated = migrate_misplaced_transhuge_page(vma->vm_mm, vma,\n\t\t\t\tvmf->pmd, pmd, vmf->address, page, target_nid);\n\tif (migrated) {\n\t\tflags |= TNF_MIGRATED;\n\t\tpage_nid = target_nid;\n\t} else\n\t\tflags |= TNF_MIGRATE_FAIL;\n\n\tgoto out;\nclear_pmdnuma:\n\tBUG_ON(!PageLocked(page));\n\twas_writable = pmd_savedwrite(pmd);\n\tpmd = pmd_modify(pmd, vma->vm_page_prot);\n\tpmd = pmd_mkyoung(pmd);\n\tif (was_writable)\n\t\tpmd = pmd_mkwrite(pmd);\n\tset_pmd_at(vma->vm_mm, haddr, vmf->pmd, pmd);\n\tupdate_mmu_cache_pmd(vma, vmf->address, vmf->pmd);\n\tunlock_page(page);\nout_unlock:\n\tspin_unlock(vmf->ptl);\n\nout:\n\tif (anon_vma)\n\t\tpage_unlock_anon_vma_read(anon_vma);\n\n\tif (page_nid != -1)\n\t\ttask_numa_fault(last_cpupid, page_nid, HPAGE_PMD_NR,\n\t\t\t\tflags);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_numa_fault",
          "args": [
            "last_cpupid",
            "page_nid",
            "HPAGE_PMD_NR",
            "flags"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_unlock_anon_vma_read",
          "args": [
            "anon_vma"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "page_unlock_anon_vma_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "569-572",
          "snippet": "void page_unlock_anon_vma_read(struct anon_vma *anon_vma)\n{\n\tanon_vma_unlock_read(anon_vma);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_unlock_anon_vma_read(struct anon_vma *anon_vma)\n{\n\tanon_vma_unlock_read(anon_vma);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "vmf->ptl"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_mmu_cache_pmd",
          "args": [
            "vma",
            "vmf->address",
            "vmf->pmd"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pmd_at",
          "args": [
            "vma->vm_mm",
            "haddr",
            "vmf->pmd",
            "pmd"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_mkwrite",
          "args": [
            "pmd"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_mkyoung",
          "args": [
            "pmd"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_modify",
          "args": [
            "pmd",
            "vma->vm_page_prot"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_savedwrite",
          "args": [
            "pmd"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_misplaced_transhuge_page",
          "args": [
            "vma->vm_mm",
            "vma",
            "vmf->pmd",
            "pmd",
            "vmf->address",
            "page",
            "target_nid"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_misplaced_transhuge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "1955-2081",
          "snippet": "int migrate_misplaced_transhuge_page(struct mm_struct *mm,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tpmd_t *pmd, pmd_t entry,\n\t\t\t\tunsigned long address,\n\t\t\t\tstruct page *page, int node)\n{\n\tspinlock_t *ptl;\n\tpg_data_t *pgdat = NODE_DATA(node);\n\tint isolated = 0;\n\tstruct page *new_page = NULL;\n\tint page_lru = page_is_file_cache(page);\n\tunsigned long start = address & HPAGE_PMD_MASK;\n\n\tnew_page = alloc_pages_node(node,\n\t\t(GFP_TRANSHUGE_LIGHT | __GFP_THISNODE),\n\t\tHPAGE_PMD_ORDER);\n\tif (!new_page)\n\t\tgoto out_fail;\n\tprep_transhuge_page(new_page);\n\n\tisolated = numamigrate_isolate_page(pgdat, page);\n\tif (!isolated) {\n\t\tput_page(new_page);\n\t\tgoto out_fail;\n\t}\n\n\t/* Prepare a page as a migration target */\n\t__SetPageLocked(new_page);\n\tif (PageSwapBacked(page))\n\t\t__SetPageSwapBacked(new_page);\n\n\t/* anon mapping, we can simply copy page->mapping to the new page: */\n\tnew_page->mapping = page->mapping;\n\tnew_page->index = page->index;\n\t/* flush the cache before copying using the kernel virtual address */\n\tflush_cache_range(vma, start, start + HPAGE_PMD_SIZE);\n\tmigrate_page_copy(new_page, page);\n\tWARN_ON(PageLRU(new_page));\n\n\t/* Recheck the target PMD */\n\tptl = pmd_lock(mm, pmd);\n\tif (unlikely(!pmd_same(*pmd, entry) || !page_ref_freeze(page, 2))) {\n\t\tspin_unlock(ptl);\n\n\t\t/* Reverse changes made by migrate_page_copy() */\n\t\tif (TestClearPageActive(new_page))\n\t\t\tSetPageActive(page);\n\t\tif (TestClearPageUnevictable(new_page))\n\t\t\tSetPageUnevictable(page);\n\n\t\tunlock_page(new_page);\n\t\tput_page(new_page);\t\t/* Free it */\n\n\t\t/* Retake the callers reference and putback on LRU */\n\t\tget_page(page);\n\t\tputback_lru_page(page);\n\t\tmod_node_page_state(page_pgdat(page),\n\t\t\t NR_ISOLATED_ANON + page_lru, -HPAGE_PMD_NR);\n\n\t\tgoto out_unlock;\n\t}\n\n\tentry = mk_huge_pmd(new_page, vma->vm_page_prot);\n\tentry = maybe_pmd_mkwrite(pmd_mkdirty(entry), vma);\n\n\t/*\n\t * Overwrite the old entry under pagetable lock and establish\n\t * the new PTE. Any parallel GUP will either observe the old\n\t * page blocking on the page lock, block on the page table\n\t * lock or observe the new page. The SetPageUptodate on the\n\t * new page and page_add_new_anon_rmap guarantee the copy is\n\t * visible before the pagetable update.\n\t */\n\tpage_add_anon_rmap(new_page, vma, start, true);\n\t/*\n\t * At this point the pmd is numa/protnone (i.e. non present) and the TLB\n\t * has already been flushed globally.  So no TLB can be currently\n\t * caching this non present pmd mapping.  There's no need to clear the\n\t * pmd before doing set_pmd_at(), nor to flush the TLB after\n\t * set_pmd_at().  Clearing the pmd here would introduce a race\n\t * condition against MADV_DONTNEED, because MADV_DONTNEED only holds the\n\t * mmap_sem for reading.  If the pmd is set to NULL at any given time,\n\t * MADV_DONTNEED won't wait on the pmd lock and it'll skip clearing this\n\t * pmd.\n\t */\n\tset_pmd_at(mm, start, pmd, entry);\n\tupdate_mmu_cache_pmd(vma, address, &entry);\n\n\tpage_ref_unfreeze(page, 2);\n\tmlock_migrate_page(new_page, page);\n\tpage_remove_rmap(page, true);\n\tset_page_owner_migrate_reason(new_page, MR_NUMA_MISPLACED);\n\n\tspin_unlock(ptl);\n\n\t/* Take an \"isolate\" reference and put new page on the LRU. */\n\tget_page(new_page);\n\tputback_lru_page(new_page);\n\n\tunlock_page(new_page);\n\tunlock_page(page);\n\tput_page(page);\t\t\t/* Drop the rmap reference */\n\tput_page(page);\t\t\t/* Drop the LRU isolation reference */\n\n\tcount_vm_events(PGMIGRATE_SUCCESS, HPAGE_PMD_NR);\n\tcount_vm_numa_events(NUMA_PAGE_MIGRATE, HPAGE_PMD_NR);\n\n\tmod_node_page_state(page_pgdat(page),\n\t\t\tNR_ISOLATED_ANON + page_lru,\n\t\t\t-HPAGE_PMD_NR);\n\treturn isolated;\n\nout_fail:\n\tcount_vm_events(PGMIGRATE_FAIL, HPAGE_PMD_NR);\n\tptl = pmd_lock(mm, pmd);\n\tif (pmd_same(*pmd, entry)) {\n\t\tentry = pmd_modify(entry, vma->vm_page_prot);\n\t\tset_pmd_at(mm, start, pmd, entry);\n\t\tupdate_mmu_cache_pmd(vma, address, &entry);\n\t}\n\tspin_unlock(ptl);\n\nout_unlock:\n\tunlock_page(page);\n\tput_page(page);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint migrate_misplaced_transhuge_page(struct mm_struct *mm,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tpmd_t *pmd, pmd_t entry,\n\t\t\t\tunsigned long address,\n\t\t\t\tstruct page *page, int node)\n{\n\tspinlock_t *ptl;\n\tpg_data_t *pgdat = NODE_DATA(node);\n\tint isolated = 0;\n\tstruct page *new_page = NULL;\n\tint page_lru = page_is_file_cache(page);\n\tunsigned long start = address & HPAGE_PMD_MASK;\n\n\tnew_page = alloc_pages_node(node,\n\t\t(GFP_TRANSHUGE_LIGHT | __GFP_THISNODE),\n\t\tHPAGE_PMD_ORDER);\n\tif (!new_page)\n\t\tgoto out_fail;\n\tprep_transhuge_page(new_page);\n\n\tisolated = numamigrate_isolate_page(pgdat, page);\n\tif (!isolated) {\n\t\tput_page(new_page);\n\t\tgoto out_fail;\n\t}\n\n\t/* Prepare a page as a migration target */\n\t__SetPageLocked(new_page);\n\tif (PageSwapBacked(page))\n\t\t__SetPageSwapBacked(new_page);\n\n\t/* anon mapping, we can simply copy page->mapping to the new page: */\n\tnew_page->mapping = page->mapping;\n\tnew_page->index = page->index;\n\t/* flush the cache before copying using the kernel virtual address */\n\tflush_cache_range(vma, start, start + HPAGE_PMD_SIZE);\n\tmigrate_page_copy(new_page, page);\n\tWARN_ON(PageLRU(new_page));\n\n\t/* Recheck the target PMD */\n\tptl = pmd_lock(mm, pmd);\n\tif (unlikely(!pmd_same(*pmd, entry) || !page_ref_freeze(page, 2))) {\n\t\tspin_unlock(ptl);\n\n\t\t/* Reverse changes made by migrate_page_copy() */\n\t\tif (TestClearPageActive(new_page))\n\t\t\tSetPageActive(page);\n\t\tif (TestClearPageUnevictable(new_page))\n\t\t\tSetPageUnevictable(page);\n\n\t\tunlock_page(new_page);\n\t\tput_page(new_page);\t\t/* Free it */\n\n\t\t/* Retake the callers reference and putback on LRU */\n\t\tget_page(page);\n\t\tputback_lru_page(page);\n\t\tmod_node_page_state(page_pgdat(page),\n\t\t\t NR_ISOLATED_ANON + page_lru, -HPAGE_PMD_NR);\n\n\t\tgoto out_unlock;\n\t}\n\n\tentry = mk_huge_pmd(new_page, vma->vm_page_prot);\n\tentry = maybe_pmd_mkwrite(pmd_mkdirty(entry), vma);\n\n\t/*\n\t * Overwrite the old entry under pagetable lock and establish\n\t * the new PTE. Any parallel GUP will either observe the old\n\t * page blocking on the page lock, block on the page table\n\t * lock or observe the new page. The SetPageUptodate on the\n\t * new page and page_add_new_anon_rmap guarantee the copy is\n\t * visible before the pagetable update.\n\t */\n\tpage_add_anon_rmap(new_page, vma, start, true);\n\t/*\n\t * At this point the pmd is numa/protnone (i.e. non present) and the TLB\n\t * has already been flushed globally.  So no TLB can be currently\n\t * caching this non present pmd mapping.  There's no need to clear the\n\t * pmd before doing set_pmd_at(), nor to flush the TLB after\n\t * set_pmd_at().  Clearing the pmd here would introduce a race\n\t * condition against MADV_DONTNEED, because MADV_DONTNEED only holds the\n\t * mmap_sem for reading.  If the pmd is set to NULL at any given time,\n\t * MADV_DONTNEED won't wait on the pmd lock and it'll skip clearing this\n\t * pmd.\n\t */\n\tset_pmd_at(mm, start, pmd, entry);\n\tupdate_mmu_cache_pmd(vma, address, &entry);\n\n\tpage_ref_unfreeze(page, 2);\n\tmlock_migrate_page(new_page, page);\n\tpage_remove_rmap(page, true);\n\tset_page_owner_migrate_reason(new_page, MR_NUMA_MISPLACED);\n\n\tspin_unlock(ptl);\n\n\t/* Take an \"isolate\" reference and put new page on the LRU. */\n\tget_page(new_page);\n\tputback_lru_page(new_page);\n\n\tunlock_page(new_page);\n\tunlock_page(page);\n\tput_page(page);\t\t\t/* Drop the rmap reference */\n\tput_page(page);\t\t\t/* Drop the LRU isolation reference */\n\n\tcount_vm_events(PGMIGRATE_SUCCESS, HPAGE_PMD_NR);\n\tcount_vm_numa_events(NUMA_PAGE_MIGRATE, HPAGE_PMD_NR);\n\n\tmod_node_page_state(page_pgdat(page),\n\t\t\tNR_ISOLATED_ANON + page_lru,\n\t\t\t-HPAGE_PMD_NR);\n\treturn isolated;\n\nout_fail:\n\tcount_vm_events(PGMIGRATE_FAIL, HPAGE_PMD_NR);\n\tptl = pmd_lock(mm, pmd);\n\tif (pmd_same(*pmd, entry)) {\n\t\tentry = pmd_modify(entry, vma->vm_page_prot);\n\t\tset_pmd_at(mm, start, pmd, entry);\n\t\tupdate_mmu_cache_pmd(vma, address, &entry);\n\t}\n\tspin_unlock(ptl);\n\nout_unlock:\n\tunlock_page(page);\n\tput_page(page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "vmf->ptl"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range",
          "args": [
            "vma->vm_mm",
            "haddr",
            "haddr + HPAGE_PMD_SIZE"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "__mmu_notifier_invalidate_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_notifier.c",
          "lines": "235-247",
          "snippet": "void __mmu_notifier_invalidate_range(struct mm_struct *mm,\n\t\t\t\t  unsigned long start, unsigned long end)\n{\n\tstruct mmu_notifier *mn;\n\tint id;\n\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {\n\t\tif (mn->ops->invalidate_range)\n\t\t\tmn->ops->invalidate_range(mn, mm, start, end);\n\t}\n\tsrcu_read_unlock(&srcu, id);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/srcu.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/srcu.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rculist.h>\n\nvoid __mmu_notifier_invalidate_range(struct mm_struct *mm,\n\t\t\t\t  unsigned long start, unsigned long end)\n{\n\tstruct mmu_notifier *mn;\n\tint id;\n\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {\n\t\tif (mn->ops->invalidate_range)\n\t\t\tmn->ops->invalidate_range(mn, mm, start, end);\n\t}\n\tsrcu_read_unlock(&srcu, id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_tlb_range",
          "args": [
            "vma",
            "haddr",
            "haddr + HPAGE_PMD_SIZE"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_tlb_flush_pending",
          "args": [
            "vma->vm_mm"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!anon_vma"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pmd_same(pmd, *vmf->pmd)"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_same",
          "args": [
            "pmd",
            "*vmf->pmd"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "vmf->ptl"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_lock_anon_vma_read",
          "args": [
            "page"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "page_lock_anon_vma_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "507-567",
          "snippet": "struct anon_vma *page_lock_anon_vma_read(struct page *page)\n{\n\tstruct anon_vma *anon_vma = NULL;\n\tstruct anon_vma *root_anon_vma;\n\tunsigned long anon_mapping;\n\n\trcu_read_lock();\n\tanon_mapping = (unsigned long)READ_ONCE(page->mapping);\n\tif ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\tgoto out;\n\tif (!page_mapped(page))\n\t\tgoto out;\n\n\tanon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);\n\troot_anon_vma = READ_ONCE(anon_vma->root);\n\tif (down_read_trylock(&root_anon_vma->rwsem)) {\n\t\t/*\n\t\t * If the page is still mapped, then this anon_vma is still\n\t\t * its anon_vma, and holding the mutex ensures that it will\n\t\t * not go away, see anon_vma_free().\n\t\t */\n\t\tif (!page_mapped(page)) {\n\t\t\tup_read(&root_anon_vma->rwsem);\n\t\t\tanon_vma = NULL;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* trylock failed, we got to sleep */\n\tif (!atomic_inc_not_zero(&anon_vma->refcount)) {\n\t\tanon_vma = NULL;\n\t\tgoto out;\n\t}\n\n\tif (!page_mapped(page)) {\n\t\trcu_read_unlock();\n\t\tput_anon_vma(anon_vma);\n\t\treturn NULL;\n\t}\n\n\t/* we pinned the anon_vma, its safe to sleep */\n\trcu_read_unlock();\n\tanon_vma_lock_read(anon_vma);\n\n\tif (atomic_dec_and_test(&anon_vma->refcount)) {\n\t\t/*\n\t\t * Oops, we held the last refcount, release the lock\n\t\t * and bail -- can't simply use put_anon_vma() because\n\t\t * we'll deadlock on the anon_vma_lock_write() recursion.\n\t\t */\n\t\tanon_vma_unlock_read(anon_vma);\n\t\t__put_anon_vma(anon_vma);\n\t\tanon_vma = NULL;\n\t}\n\n\treturn anon_vma;\n\nout:\n\trcu_read_unlock();\n\treturn anon_vma;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstruct anon_vma *page_lock_anon_vma_read(struct page *page)\n{\n\tstruct anon_vma *anon_vma = NULL;\n\tstruct anon_vma *root_anon_vma;\n\tunsigned long anon_mapping;\n\n\trcu_read_lock();\n\tanon_mapping = (unsigned long)READ_ONCE(page->mapping);\n\tif ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\tgoto out;\n\tif (!page_mapped(page))\n\t\tgoto out;\n\n\tanon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);\n\troot_anon_vma = READ_ONCE(anon_vma->root);\n\tif (down_read_trylock(&root_anon_vma->rwsem)) {\n\t\t/*\n\t\t * If the page is still mapped, then this anon_vma is still\n\t\t * its anon_vma, and holding the mutex ensures that it will\n\t\t * not go away, see anon_vma_free().\n\t\t */\n\t\tif (!page_mapped(page)) {\n\t\t\tup_read(&root_anon_vma->rwsem);\n\t\t\tanon_vma = NULL;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* trylock failed, we got to sleep */\n\tif (!atomic_inc_not_zero(&anon_vma->refcount)) {\n\t\tanon_vma = NULL;\n\t\tgoto out;\n\t}\n\n\tif (!page_mapped(page)) {\n\t\trcu_read_unlock();\n\t\tput_anon_vma(anon_vma);\n\t\treturn NULL;\n\t}\n\n\t/* we pinned the anon_vma, its safe to sleep */\n\trcu_read_unlock();\n\tanon_vma_lock_read(anon_vma);\n\n\tif (atomic_dec_and_test(&anon_vma->refcount)) {\n\t\t/*\n\t\t * Oops, we held the last refcount, release the lock\n\t\t * and bail -- can't simply use put_anon_vma() because\n\t\t * we'll deadlock on the anon_vma_lock_write() recursion.\n\t\t */\n\t\tanon_vma_unlock_read(anon_vma);\n\t\t__put_anon_vma(anon_vma);\n\t\tanon_vma = NULL;\n\t}\n\n\treturn anon_vma;\n\nout:\n\trcu_read_unlock();\n\treturn anon_vma;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "vmf->ptl"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_page_locked",
          "args": [
            "page"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "vmf->ptl"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page_unless_zero",
          "args": [
            "page"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_misplaced",
          "args": [
            "page",
            "vma",
            "haddr"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_misplaced",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2273-2337",
          "snippet": "int mpol_misplaced(struct page *page, struct vm_area_struct *vma, unsigned long addr)\n{\n\tstruct mempolicy *pol;\n\tstruct zoneref *z;\n\tint curnid = page_to_nid(page);\n\tunsigned long pgoff;\n\tint thiscpu = raw_smp_processor_id();\n\tint thisnid = cpu_to_node(thiscpu);\n\tint polnid = -1;\n\tint ret = -1;\n\n\tpol = get_vma_policy(vma, addr);\n\tif (!(pol->flags & MPOL_F_MOF))\n\t\tgoto out;\n\n\tswitch (pol->mode) {\n\tcase MPOL_INTERLEAVE:\n\t\tpgoff = vma->vm_pgoff;\n\t\tpgoff += (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\tpolnid = offset_il_node(pol, pgoff);\n\t\tbreak;\n\n\tcase MPOL_PREFERRED:\n\t\tif (pol->flags & MPOL_F_LOCAL)\n\t\t\tpolnid = numa_node_id();\n\t\telse\n\t\t\tpolnid = pol->v.preferred_node;\n\t\tbreak;\n\n\tcase MPOL_BIND:\n\n\t\t/*\n\t\t * allows binding to multiple nodes.\n\t\t * use current page if in policy nodemask,\n\t\t * else select nearest allowed node, if any.\n\t\t * If no allowed nodes, use current [!misplaced].\n\t\t */\n\t\tif (node_isset(curnid, pol->v.nodes))\n\t\t\tgoto out;\n\t\tz = first_zones_zonelist(\n\t\t\t\tnode_zonelist(numa_node_id(), GFP_HIGHUSER),\n\t\t\t\tgfp_zone(GFP_HIGHUSER),\n\t\t\t\t&pol->v.nodes);\n\t\tpolnid = zone_to_nid(z->zone);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/* Migrate the page towards the node whose CPU is referencing it */\n\tif (pol->flags & MPOL_F_MORON) {\n\t\tpolnid = thisnid;\n\n\t\tif (!should_numa_migrate_memory(current, page, curnid, thiscpu))\n\t\t\tgoto out;\n\t}\n\n\tif (curnid != polnid)\n\t\tret = polnid;\nout:\n\tmpol_cond_put(pol);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nint mpol_misplaced(struct page *page, struct vm_area_struct *vma, unsigned long addr)\n{\n\tstruct mempolicy *pol;\n\tstruct zoneref *z;\n\tint curnid = page_to_nid(page);\n\tunsigned long pgoff;\n\tint thiscpu = raw_smp_processor_id();\n\tint thisnid = cpu_to_node(thiscpu);\n\tint polnid = -1;\n\tint ret = -1;\n\n\tpol = get_vma_policy(vma, addr);\n\tif (!(pol->flags & MPOL_F_MOF))\n\t\tgoto out;\n\n\tswitch (pol->mode) {\n\tcase MPOL_INTERLEAVE:\n\t\tpgoff = vma->vm_pgoff;\n\t\tpgoff += (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\tpolnid = offset_il_node(pol, pgoff);\n\t\tbreak;\n\n\tcase MPOL_PREFERRED:\n\t\tif (pol->flags & MPOL_F_LOCAL)\n\t\t\tpolnid = numa_node_id();\n\t\telse\n\t\t\tpolnid = pol->v.preferred_node;\n\t\tbreak;\n\n\tcase MPOL_BIND:\n\n\t\t/*\n\t\t * allows binding to multiple nodes.\n\t\t * use current page if in policy nodemask,\n\t\t * else select nearest allowed node, if any.\n\t\t * If no allowed nodes, use current [!misplaced].\n\t\t */\n\t\tif (node_isset(curnid, pol->v.nodes))\n\t\t\tgoto out;\n\t\tz = first_zones_zonelist(\n\t\t\t\tnode_zonelist(numa_node_id(), GFP_HIGHUSER),\n\t\t\t\tgfp_zone(GFP_HIGHUSER),\n\t\t\t\t&pol->v.nodes);\n\t\tpolnid = zone_to_nid(z->zone);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/* Migrate the page towards the node whose CPU is referencing it */\n\tif (pol->flags & MPOL_F_MORON) {\n\t\tpolnid = thisnid;\n\n\t\tif (!should_numa_migrate_memory(current, page, curnid, thiscpu))\n\t\t\tgoto out;\n\t}\n\n\tif (curnid != polnid)\n\t\tret = polnid;\nout:\n\tmpol_cond_put(pol);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_savedwrite",
          "args": [
            "pmd"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_numa_event",
          "args": [
            "NUMA_HINT_FAULTS_LOCAL"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_numa_event",
          "args": [
            "NUMA_HINT_FAULTS"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cpupid_last",
          "args": [
            "page"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "is_huge_zero_page(page)"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_huge_zero_page",
          "args": [
            "page"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_page",
          "args": [
            "pmd"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_locked",
          "args": [
            "page"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "vmf->ptl"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page_unless_zero",
          "args": [
            "page"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_page",
          "args": [
            "*vmf->pmd"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pmd_trans_migrating(*vmf->pmd)"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_migrating",
          "args": [
            "*vmf->pmd"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "pmd_trans_migrating",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "1889-1893",
          "snippet": "bool pmd_trans_migrating(pmd_t pmd)\n{\n\tstruct page *page = pmd_page(pmd);\n\treturn PageLocked(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nbool pmd_trans_migrating(pmd_t pmd)\n{\n\tstruct page *page = pmd_page(pmd);\n\treturn PageLocked(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pmd_same(pmd, *vmf->pmd)"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_same",
          "args": [
            "pmd",
            "*vmf->pmd"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_lock",
          "args": [
            "vma->vm_mm",
            "vmf->pmd"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_node_id",
          "args": [],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvm_fault_t do_huge_pmd_numa_page(struct vm_fault *vmf, pmd_t pmd)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct anon_vma *anon_vma = NULL;\n\tstruct page *page;\n\tunsigned long haddr = vmf->address & HPAGE_PMD_MASK;\n\tint page_nid = -1, this_nid = numa_node_id();\n\tint target_nid, last_cpupid = -1;\n\tbool page_locked;\n\tbool migrated = false;\n\tbool was_writable;\n\tint flags = 0;\n\n\tvmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);\n\tif (unlikely(!pmd_same(pmd, *vmf->pmd)))\n\t\tgoto out_unlock;\n\n\t/*\n\t * If there are potential migrations, wait for completion and retry\n\t * without disrupting NUMA hinting information. Do not relock and\n\t * check_same as the page may no longer be mapped.\n\t */\n\tif (unlikely(pmd_trans_migrating(*vmf->pmd))) {\n\t\tpage = pmd_page(*vmf->pmd);\n\t\tif (!get_page_unless_zero(page))\n\t\t\tgoto out_unlock;\n\t\tspin_unlock(vmf->ptl);\n\t\twait_on_page_locked(page);\n\t\tput_page(page);\n\t\tgoto out;\n\t}\n\n\tpage = pmd_page(pmd);\n\tBUG_ON(is_huge_zero_page(page));\n\tpage_nid = page_to_nid(page);\n\tlast_cpupid = page_cpupid_last(page);\n\tcount_vm_numa_event(NUMA_HINT_FAULTS);\n\tif (page_nid == this_nid) {\n\t\tcount_vm_numa_event(NUMA_HINT_FAULTS_LOCAL);\n\t\tflags |= TNF_FAULT_LOCAL;\n\t}\n\n\t/* See similar comment in do_numa_page for explanation */\n\tif (!pmd_savedwrite(pmd))\n\t\tflags |= TNF_NO_GROUP;\n\n\t/*\n\t * Acquire the page lock to serialise THP migrations but avoid dropping\n\t * page_table_lock if at all possible\n\t */\n\tpage_locked = trylock_page(page);\n\ttarget_nid = mpol_misplaced(page, vma, haddr);\n\tif (target_nid == -1) {\n\t\t/* If the page was locked, there are no parallel migrations */\n\t\tif (page_locked)\n\t\t\tgoto clear_pmdnuma;\n\t}\n\n\t/* Migration could have started since the pmd_trans_migrating check */\n\tif (!page_locked) {\n\t\tpage_nid = -1;\n\t\tif (!get_page_unless_zero(page))\n\t\t\tgoto out_unlock;\n\t\tspin_unlock(vmf->ptl);\n\t\twait_on_page_locked(page);\n\t\tput_page(page);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Page is misplaced. Page lock serialises migrations. Acquire anon_vma\n\t * to serialises splits\n\t */\n\tget_page(page);\n\tspin_unlock(vmf->ptl);\n\tanon_vma = page_lock_anon_vma_read(page);\n\n\t/* Confirm the PMD did not change while page_table_lock was released */\n\tspin_lock(vmf->ptl);\n\tif (unlikely(!pmd_same(pmd, *vmf->pmd))) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tpage_nid = -1;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Bail if we fail to protect against THP splits for any reason */\n\tif (unlikely(!anon_vma)) {\n\t\tput_page(page);\n\t\tpage_nid = -1;\n\t\tgoto clear_pmdnuma;\n\t}\n\n\t/*\n\t * Since we took the NUMA fault, we must have observed the !accessible\n\t * bit. Make sure all other CPUs agree with that, to avoid them\n\t * modifying the page we're about to migrate.\n\t *\n\t * Must be done under PTL such that we'll observe the relevant\n\t * inc_tlb_flush_pending().\n\t *\n\t * We are not sure a pending tlb flush here is for a huge page\n\t * mapping or not. Hence use the tlb range variant\n\t */\n\tif (mm_tlb_flush_pending(vma->vm_mm)) {\n\t\tflush_tlb_range(vma, haddr, haddr + HPAGE_PMD_SIZE);\n\t\t/*\n\t\t * change_huge_pmd() released the pmd lock before\n\t\t * invalidating the secondary MMUs sharing the primary\n\t\t * MMU pagetables (with ->invalidate_range()). The\n\t\t * mmu_notifier_invalidate_range_end() (which\n\t\t * internally calls ->invalidate_range()) in\n\t\t * change_pmd_range() will run after us, so we can't\n\t\t * rely on it here and we need an explicit invalidate.\n\t\t */\n\t\tmmu_notifier_invalidate_range(vma->vm_mm, haddr,\n\t\t\t\t\t      haddr + HPAGE_PMD_SIZE);\n\t}\n\n\t/*\n\t * Migrate the THP to the requested node, returns with page unlocked\n\t * and access rights restored.\n\t */\n\tspin_unlock(vmf->ptl);\n\n\tmigrated = migrate_misplaced_transhuge_page(vma->vm_mm, vma,\n\t\t\t\tvmf->pmd, pmd, vmf->address, page, target_nid);\n\tif (migrated) {\n\t\tflags |= TNF_MIGRATED;\n\t\tpage_nid = target_nid;\n\t} else\n\t\tflags |= TNF_MIGRATE_FAIL;\n\n\tgoto out;\nclear_pmdnuma:\n\tBUG_ON(!PageLocked(page));\n\twas_writable = pmd_savedwrite(pmd);\n\tpmd = pmd_modify(pmd, vma->vm_page_prot);\n\tpmd = pmd_mkyoung(pmd);\n\tif (was_writable)\n\t\tpmd = pmd_mkwrite(pmd);\n\tset_pmd_at(vma->vm_mm, haddr, vmf->pmd, pmd);\n\tupdate_mmu_cache_pmd(vma, vmf->address, vmf->pmd);\n\tunlock_page(page);\nout_unlock:\n\tspin_unlock(vmf->ptl);\n\nout:\n\tif (anon_vma)\n\t\tpage_unlock_anon_vma_read(anon_vma);\n\n\tif (page_nid != -1)\n\t\ttask_numa_fault(last_cpupid, page_nid, HPAGE_PMD_NR,\n\t\t\t\tflags);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "follow_trans_huge_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "1408-1474",
    "snippet": "struct page *follow_trans_huge_pmd(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long addr,\n\t\t\t\t   pmd_t *pmd,\n\t\t\t\t   unsigned int flags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page = NULL;\n\n\tassert_spin_locked(pmd_lockptr(mm, pmd));\n\n\tif (flags & FOLL_WRITE && !can_follow_write_pmd(*pmd, flags))\n\t\tgoto out;\n\n\t/* Avoid dumping huge zero page */\n\tif ((flags & FOLL_DUMP) && is_huge_zero_pmd(*pmd))\n\t\treturn ERR_PTR(-EFAULT);\n\n\t/* Full NUMA hinting faults to serialise migration in fault paths */\n\tif ((flags & FOLL_NUMA) && pmd_protnone(*pmd))\n\t\tgoto out;\n\n\tpage = pmd_page(*pmd);\n\tVM_BUG_ON_PAGE(!PageHead(page) && !is_zone_device_page(page), page);\n\tif (flags & FOLL_TOUCH)\n\t\ttouch_pmd(vma, addr, pmd, flags);\n\tif ((flags & FOLL_MLOCK) && (vma->vm_flags & VM_LOCKED)) {\n\t\t/*\n\t\t * We don't mlock() pte-mapped THPs. This way we can avoid\n\t\t * leaking mlocked pages into non-VM_LOCKED VMAs.\n\t\t *\n\t\t * For anon THP:\n\t\t *\n\t\t * In most cases the pmd is the only mapping of the page as we\n\t\t * break COW for the mlock() -- see gup_flags |= FOLL_WRITE for\n\t\t * writable private mappings in populate_vma_page_range().\n\t\t *\n\t\t * The only scenario when we have the page shared here is if we\n\t\t * mlocking read-only mapping shared over fork(). We skip\n\t\t * mlocking such pages.\n\t\t *\n\t\t * For file THP:\n\t\t *\n\t\t * We can expect PageDoubleMap() to be stable under page lock:\n\t\t * for file pages we set it in page_add_file_rmap(), which\n\t\t * requires page to be locked.\n\t\t */\n\n\t\tif (PageAnon(page) && compound_mapcount(page) != 1)\n\t\t\tgoto skip_mlock;\n\t\tif (PageDoubleMap(page) || !page->mapping)\n\t\t\tgoto skip_mlock;\n\t\tif (!trylock_page(page))\n\t\t\tgoto skip_mlock;\n\t\tlru_add_drain();\n\t\tif (page->mapping && !PageDoubleMap(page))\n\t\t\tmlock_vma_page(page);\n\t\tunlock_page(page);\n\t}\nskip_mlock:\n\tpage += (addr & ~HPAGE_PMD_MASK) >> PAGE_SHIFT;\n\tVM_BUG_ON_PAGE(!PageCompound(page) && !is_zone_device_page(page), page);\n\tif (flags & FOLL_GET)\n\t\tget_page(page);\n\nout:\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageCompound(page) && !is_zone_device_page(page)",
            "page"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_zone_device_page",
          "args": [
            "page"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlock_vma_page",
          "args": [
            "page"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "mlock_vma_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "359-359",
          "snippet": "static inline void mlock_vma_page(struct page *page) { }",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mlock_vma_page(struct page *page) { }"
        }
      },
      {
        "call_info": {
          "callee": "PageDoubleMap",
          "args": [
            "page"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_add_drain",
          "args": [],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDoubleMap",
          "args": [
            "page"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_mapcount",
          "args": [
            "page"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "touch_pmd",
          "args": [
            "vma",
            "addr",
            "pmd",
            "flags"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "touch_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "860-871",
          "snippet": "static void touch_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\tpmd_t *pmd, int flags)\n{\n\tpmd_t _pmd;\n\n\t_pmd = pmd_mkyoung(*pmd);\n\tif (flags & FOLL_WRITE)\n\t\t_pmd = pmd_mkdirty(_pmd);\n\tif (pmdp_set_access_flags(vma, addr & HPAGE_PMD_MASK,\n\t\t\t\tpmd, _pmd, flags & FOLL_WRITE))\n\t\tupdate_mmu_cache_pmd(vma, addr, pmd);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void touch_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\tpmd_t *pmd, int flags)\n{\n\tpmd_t _pmd;\n\n\t_pmd = pmd_mkyoung(*pmd);\n\tif (flags & FOLL_WRITE)\n\t\t_pmd = pmd_mkdirty(_pmd);\n\tif (pmdp_set_access_flags(vma, addr & HPAGE_PMD_MASK,\n\t\t\t\tpmd, _pmd, flags & FOLL_WRITE))\n\t\tupdate_mmu_cache_pmd(vma, addr, pmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageHead(page) && !is_zone_device_page(page)",
            "page"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_zone_device_page",
          "args": [
            "page"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHead",
          "args": [
            "page"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "PageHeadHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1350-1356",
          "snippet": "int PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_page",
          "args": [
            "*pmd"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_protnone",
          "args": [
            "*pmd"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EFAULT"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_huge_zero_pmd",
          "args": [
            "*pmd"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "can_follow_write_pmd",
          "args": [
            "*pmd",
            "flags"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "can_follow_write_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1402-1406",
          "snippet": "static inline bool can_follow_write_pmd(pmd_t pmd, unsigned int flags)\n{\n\treturn pmd_write(pmd) ||\n\t       ((flags & FOLL_FORCE) && (flags & FOLL_COW) && pmd_dirty(pmd));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline bool can_follow_write_pmd(pmd_t pmd, unsigned int flags)\n{\n\treturn pmd_write(pmd) ||\n\t       ((flags & FOLL_FORCE) && (flags & FOLL_COW) && pmd_dirty(pmd));\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "pmd_lockptr(mm, pmd)"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_lockptr",
          "args": [
            "mm",
            "pmd"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstruct page *follow_trans_huge_pmd(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long addr,\n\t\t\t\t   pmd_t *pmd,\n\t\t\t\t   unsigned int flags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page = NULL;\n\n\tassert_spin_locked(pmd_lockptr(mm, pmd));\n\n\tif (flags & FOLL_WRITE && !can_follow_write_pmd(*pmd, flags))\n\t\tgoto out;\n\n\t/* Avoid dumping huge zero page */\n\tif ((flags & FOLL_DUMP) && is_huge_zero_pmd(*pmd))\n\t\treturn ERR_PTR(-EFAULT);\n\n\t/* Full NUMA hinting faults to serialise migration in fault paths */\n\tif ((flags & FOLL_NUMA) && pmd_protnone(*pmd))\n\t\tgoto out;\n\n\tpage = pmd_page(*pmd);\n\tVM_BUG_ON_PAGE(!PageHead(page) && !is_zone_device_page(page), page);\n\tif (flags & FOLL_TOUCH)\n\t\ttouch_pmd(vma, addr, pmd, flags);\n\tif ((flags & FOLL_MLOCK) && (vma->vm_flags & VM_LOCKED)) {\n\t\t/*\n\t\t * We don't mlock() pte-mapped THPs. This way we can avoid\n\t\t * leaking mlocked pages into non-VM_LOCKED VMAs.\n\t\t *\n\t\t * For anon THP:\n\t\t *\n\t\t * In most cases the pmd is the only mapping of the page as we\n\t\t * break COW for the mlock() -- see gup_flags |= FOLL_WRITE for\n\t\t * writable private mappings in populate_vma_page_range().\n\t\t *\n\t\t * The only scenario when we have the page shared here is if we\n\t\t * mlocking read-only mapping shared over fork(). We skip\n\t\t * mlocking such pages.\n\t\t *\n\t\t * For file THP:\n\t\t *\n\t\t * We can expect PageDoubleMap() to be stable under page lock:\n\t\t * for file pages we set it in page_add_file_rmap(), which\n\t\t * requires page to be locked.\n\t\t */\n\n\t\tif (PageAnon(page) && compound_mapcount(page) != 1)\n\t\t\tgoto skip_mlock;\n\t\tif (PageDoubleMap(page) || !page->mapping)\n\t\t\tgoto skip_mlock;\n\t\tif (!trylock_page(page))\n\t\t\tgoto skip_mlock;\n\t\tlru_add_drain();\n\t\tif (page->mapping && !PageDoubleMap(page))\n\t\t\tmlock_vma_page(page);\n\t\tunlock_page(page);\n\t}\nskip_mlock:\n\tpage += (addr & ~HPAGE_PMD_MASK) >> PAGE_SHIFT;\n\tVM_BUG_ON_PAGE(!PageCompound(page) && !is_zone_device_page(page), page);\n\tif (flags & FOLL_GET)\n\t\tget_page(page);\n\nout:\n\treturn page;\n}"
  },
  {
    "function_name": "can_follow_write_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "1402-1406",
    "snippet": "static inline bool can_follow_write_pmd(pmd_t pmd, unsigned int flags)\n{\n\treturn pmd_write(pmd) ||\n\t       ((flags & FOLL_FORCE) && (flags & FOLL_COW) && pmd_dirty(pmd));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pmd_dirty",
          "args": [
            "pmd"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_write",
          "args": [
            "pmd"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline bool can_follow_write_pmd(pmd_t pmd, unsigned int flags)\n{\n\treturn pmd_write(pmd) ||\n\t       ((flags & FOLL_FORCE) && (flags & FOLL_COW) && pmd_dirty(pmd));\n}"
  },
  {
    "function_name": "do_huge_pmd_wp_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "1255-1396",
    "snippet": "vm_fault_t do_huge_pmd_wp_page(struct vm_fault *vmf, pmd_t orig_pmd)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page = NULL, *new_page;\n\tstruct mem_cgroup *memcg;\n\tunsigned long haddr = vmf->address & HPAGE_PMD_MASK;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\tgfp_t huge_gfp;\t\t\t/* for allocation and charge */\n\tvm_fault_t ret = 0;\n\n\tvmf->ptl = pmd_lockptr(vma->vm_mm, vmf->pmd);\n\tVM_BUG_ON_VMA(!vma->anon_vma, vma);\n\tif (is_huge_zero_pmd(orig_pmd))\n\t\tgoto alloc;\n\tspin_lock(vmf->ptl);\n\tif (unlikely(!pmd_same(*vmf->pmd, orig_pmd)))\n\t\tgoto out_unlock;\n\n\tpage = pmd_page(orig_pmd);\n\tVM_BUG_ON_PAGE(!PageCompound(page) || !PageHead(page), page);\n\t/*\n\t * We can only reuse the page if nobody else maps the huge page or it's\n\t * part.\n\t */\n\tif (!trylock_page(page)) {\n\t\tget_page(page);\n\t\tspin_unlock(vmf->ptl);\n\t\tlock_page(page);\n\t\tspin_lock(vmf->ptl);\n\t\tif (unlikely(!pmd_same(*vmf->pmd, orig_pmd))) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tput_page(page);\n\t}\n\tif (reuse_swap_page(page, NULL)) {\n\t\tpmd_t entry;\n\t\tentry = pmd_mkyoung(orig_pmd);\n\t\tentry = maybe_pmd_mkwrite(pmd_mkdirty(entry), vma);\n\t\tif (pmdp_set_access_flags(vma, haddr, vmf->pmd, entry,  1))\n\t\t\tupdate_mmu_cache_pmd(vma, vmf->address, vmf->pmd);\n\t\tret |= VM_FAULT_WRITE;\n\t\tunlock_page(page);\n\t\tgoto out_unlock;\n\t}\n\tunlock_page(page);\n\tget_page(page);\n\tspin_unlock(vmf->ptl);\nalloc:\n\tif (transparent_hugepage_enabled(vma) &&\n\t    !transparent_hugepage_debug_cow()) {\n\t\thuge_gfp = alloc_hugepage_direct_gfpmask(vma, haddr);\n\t\tnew_page = alloc_pages_vma(huge_gfp, HPAGE_PMD_ORDER, vma,\n\t\t\t\thaddr, numa_node_id());\n\t} else\n\t\tnew_page = NULL;\n\n\tif (likely(new_page)) {\n\t\tprep_transhuge_page(new_page);\n\t} else {\n\t\tif (!page) {\n\t\t\tsplit_huge_pmd(vma, vmf->pmd, vmf->address);\n\t\t\tret |= VM_FAULT_FALLBACK;\n\t\t} else {\n\t\t\tret = do_huge_pmd_wp_page_fallback(vmf, orig_pmd, page);\n\t\t\tif (ret & VM_FAULT_OOM) {\n\t\t\t\tsplit_huge_pmd(vma, vmf->pmd, vmf->address);\n\t\t\t\tret |= VM_FAULT_FALLBACK;\n\t\t\t}\n\t\t\tput_page(page);\n\t\t}\n\t\tcount_vm_event(THP_FAULT_FALLBACK);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(mem_cgroup_try_charge_delay(new_page, vma->vm_mm,\n\t\t\t\t\thuge_gfp, &memcg, true))) {\n\t\tput_page(new_page);\n\t\tsplit_huge_pmd(vma, vmf->pmd, vmf->address);\n\t\tif (page)\n\t\t\tput_page(page);\n\t\tret |= VM_FAULT_FALLBACK;\n\t\tcount_vm_event(THP_FAULT_FALLBACK);\n\t\tgoto out;\n\t}\n\n\tcount_vm_event(THP_FAULT_ALLOC);\n\n\tif (!page)\n\t\tclear_huge_page(new_page, vmf->address, HPAGE_PMD_NR);\n\telse\n\t\tcopy_user_huge_page(new_page, page, vmf->address,\n\t\t\t\t    vma, HPAGE_PMD_NR);\n\t__SetPageUptodate(new_page);\n\n\tmmun_start = haddr;\n\tmmun_end   = haddr + HPAGE_PMD_SIZE;\n\tmmu_notifier_invalidate_range_start(vma->vm_mm, mmun_start, mmun_end);\n\n\tspin_lock(vmf->ptl);\n\tif (page)\n\t\tput_page(page);\n\tif (unlikely(!pmd_same(*vmf->pmd, orig_pmd))) {\n\t\tspin_unlock(vmf->ptl);\n\t\tmem_cgroup_cancel_charge(new_page, memcg, true);\n\t\tput_page(new_page);\n\t\tgoto out_mn;\n\t} else {\n\t\tpmd_t entry;\n\t\tentry = mk_huge_pmd(new_page, vma->vm_page_prot);\n\t\tentry = maybe_pmd_mkwrite(pmd_mkdirty(entry), vma);\n\t\tpmdp_huge_clear_flush_notify(vma, haddr, vmf->pmd);\n\t\tpage_add_new_anon_rmap(new_page, vma, haddr, true);\n\t\tmem_cgroup_commit_charge(new_page, memcg, false, true);\n\t\tlru_cache_add_active_or_unevictable(new_page, vma);\n\t\tset_pmd_at(vma->vm_mm, haddr, vmf->pmd, entry);\n\t\tupdate_mmu_cache_pmd(vma, vmf->address, vmf->pmd);\n\t\tif (!page) {\n\t\t\tadd_mm_counter(vma->vm_mm, MM_ANONPAGES, HPAGE_PMD_NR);\n\t\t} else {\n\t\t\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\t\t\tpage_remove_rmap(page, true);\n\t\t\tput_page(page);\n\t\t}\n\t\tret |= VM_FAULT_WRITE;\n\t}\n\tspin_unlock(vmf->ptl);\nout_mn:\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback as\n\t * the above pmdp_huge_clear_flush_notify() did already call it.\n\t */\n\tmmu_notifier_invalidate_range_only_end(vma->vm_mm, mmun_start,\n\t\t\t\t\t       mmun_end);\nout:\n\treturn ret;\nout_unlock:\n\tspin_unlock(vmf->ptl);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "vmf->ptl"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_only_end",
          "args": [
            "vma->vm_mm",
            "mmun_start",
            "mmun_end"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "vmf->ptl"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_remove_rmap",
          "args": [
            "page",
            "true"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "page_remove_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1297-1331",
          "snippet": "void page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageHead(page)",
            "page"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHead",
          "args": [
            "page"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "PageHeadHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1350-1356",
          "snippet": "int PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_mm_counter",
          "args": [
            "vma->vm_mm",
            "MM_ANONPAGES",
            "HPAGE_PMD_NR"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "add_mm_counter_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "157-165",
          "snippet": "static void add_mm_counter_fast(struct mm_struct *mm, int member, int val)\n{\n\tstruct task_struct *task = current;\n\n\tif (likely(task->mm == mm))\n\t\ttask->rss_stat.count[member] += val;\n\telse\n\t\tadd_mm_counter(mm, member, val);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void add_mm_counter_fast(struct mm_struct *mm, int member, int val)\n{\n\tstruct task_struct *task = current;\n\n\tif (likely(task->mm == mm))\n\t\ttask->rss_stat.count[member] += val;\n\telse\n\t\tadd_mm_counter(mm, member, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_mmu_cache_pmd",
          "args": [
            "vma",
            "vmf->address",
            "vmf->pmd"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pmd_at",
          "args": [
            "vma->vm_mm",
            "haddr",
            "vmf->pmd",
            "entry"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_cache_add_active_or_unevictable",
          "args": [
            "new_page",
            "vma"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "lru_cache_add_active_or_unevictable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "458-476",
          "snippet": "void lru_cache_add_active_or_unevictable(struct page *page,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\tif (likely((vma->vm_flags & (VM_LOCKED | VM_SPECIAL)) != VM_LOCKED))\n\t\tSetPageActive(page);\n\telse if (!TestSetPageMlocked(page)) {\n\t\t/*\n\t\t * We use the irq-unsafe __mod_zone_page_stat because this\n\t\t * counter is not modified from interrupt context, and the pte\n\t\t * lock is held(spinlock), which implies preemption disabled.\n\t\t */\n\t\t__mod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t}\n\tlru_cache_add(page);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid lru_cache_add_active_or_unevictable(struct page *page,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\tif (likely((vma->vm_flags & (VM_LOCKED | VM_SPECIAL)) != VM_LOCKED))\n\t\tSetPageActive(page);\n\telse if (!TestSetPageMlocked(page)) {\n\t\t/*\n\t\t * We use the irq-unsafe __mod_zone_page_stat because this\n\t\t * counter is not modified from interrupt context, and the pte\n\t\t * lock is held(spinlock), which implies preemption disabled.\n\t\t */\n\t\t__mod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t}\n\tlru_cache_add(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_commit_charge",
          "args": [
            "new_page",
            "memcg",
            "false",
            "true"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_commit_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5928-5962",
          "snippet": "void mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t      bool lrucare, bool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_PAGE(!page->mapping, page);\n\tVM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcommit_charge(page, memcg, lrucare);\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(memcg, page, compound, nr_pages);\n\tmemcg_check_events(memcg, page);\n\tlocal_irq_enable();\n\n\tif (do_memsw_account() && PageSwapCache(page)) {\n\t\tswp_entry_t entry = { .val = page_private(page) };\n\t\t/*\n\t\t * The swap entry might not get freed for a long time,\n\t\t * let's not wait for it.  The page already received a\n\t\t * memory+swap charge, drop the swap entry duplicate.\n\t\t */\n\t\tmem_cgroup_uncharge_swap(entry, nr_pages);\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t      bool lrucare, bool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_PAGE(!page->mapping, page);\n\tVM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcommit_charge(page, memcg, lrucare);\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(memcg, page, compound, nr_pages);\n\tmemcg_check_events(memcg, page);\n\tlocal_irq_enable();\n\n\tif (do_memsw_account() && PageSwapCache(page)) {\n\t\tswp_entry_t entry = { .val = page_private(page) };\n\t\t/*\n\t\t * The swap entry might not get freed for a long time,\n\t\t * let's not wait for it.  The page already received a\n\t\t * memory+swap charge, drop the swap entry duplicate.\n\t\t */\n\t\tmem_cgroup_uncharge_swap(entry, nr_pages);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_add_new_anon_rmap",
          "args": [
            "new_page",
            "vma",
            "haddr",
            "true"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "page_add_new_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1150-1170",
          "snippet": "void page_add_new_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, bool compound)\n{\n\tint nr = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\t__SetPageSwapBacked(page);\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(compound_mapcount_ptr(page), 0);\n\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t} else {\n\t\t/* Anon THP always mapped first with PMD */\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(&page->_mapcount, 0);\n\t}\n\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t__page_set_anon_rmap(page, vma, address, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_add_new_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, bool compound)\n{\n\tint nr = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\t__SetPageSwapBacked(page);\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(compound_mapcount_ptr(page), 0);\n\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t} else {\n\t\t/* Anon THP always mapped first with PMD */\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(&page->_mapcount, 0);\n\t}\n\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t__page_set_anon_rmap(page, vma, address, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmdp_huge_clear_flush_notify",
          "args": [
            "vma",
            "haddr",
            "vmf->pmd"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "maybe_pmd_mkwrite",
          "args": [
            "pmd_mkdirty(entry)",
            "vma"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_pmd_mkwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "477-482",
          "snippet": "pmd_t maybe_pmd_mkwrite(pmd_t pmd, struct vm_area_struct *vma)\n{\n\tif (likely(vma->vm_flags & VM_WRITE))\n\t\tpmd = pmd_mkwrite(pmd);\n\treturn pmd;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\npmd_t maybe_pmd_mkwrite(pmd_t pmd, struct vm_area_struct *vma)\n{\n\tif (likely(vma->vm_flags & VM_WRITE))\n\t\tpmd = pmd_mkwrite(pmd);\n\treturn pmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_mkdirty",
          "args": [
            "entry"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mk_huge_pmd",
          "args": [
            "new_page",
            "vma->vm_page_prot"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_cancel_charge",
          "args": [
            "new_page",
            "memcg",
            "true"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_cancel_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5972-5988",
          "snippet": "void mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,\n\t\tbool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcancel_charge(memcg, nr_pages);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,\n\t\tbool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcancel_charge(memcg, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "vmf->ptl"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pmd_same(*vmf->pmd, orig_pmd)"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_same",
          "args": [
            "*vmf->pmd",
            "orig_pmd"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "vmf->ptl"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "vma->vm_mm",
            "mmun_start",
            "mmun_end"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SetPageUptodate",
          "args": [
            "new_page"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_user_huge_page",
          "args": [
            "new_page",
            "page",
            "vmf->address",
            "vma",
            "HPAGE_PMD_NR"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "copy_user_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "4487-4506",
          "snippet": "void copy_user_huge_page(struct page *dst, struct page *src,\n\t\t\t unsigned long addr_hint, struct vm_area_struct *vma,\n\t\t\t unsigned int pages_per_huge_page)\n{\n\tunsigned long addr = addr_hint &\n\t\t~(((unsigned long)pages_per_huge_page << PAGE_SHIFT) - 1);\n\tstruct copy_subpage_arg arg = {\n\t\t.dst = dst,\n\t\t.src = src,\n\t\t.vma = vma,\n\t};\n\n\tif (unlikely(pages_per_huge_page > MAX_ORDER_NR_PAGES)) {\n\t\tcopy_user_gigantic_page(dst, src, addr, vma,\n\t\t\t\t\tpages_per_huge_page);\n\t\treturn;\n\t}\n\n\tprocess_huge_page(addr_hint, pages_per_huge_page, copy_subpage, &arg);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid copy_user_huge_page(struct page *dst, struct page *src,\n\t\t\t unsigned long addr_hint, struct vm_area_struct *vma,\n\t\t\t unsigned int pages_per_huge_page)\n{\n\tunsigned long addr = addr_hint &\n\t\t~(((unsigned long)pages_per_huge_page << PAGE_SHIFT) - 1);\n\tstruct copy_subpage_arg arg = {\n\t\t.dst = dst,\n\t\t.src = src,\n\t\t.vma = vma,\n\t};\n\n\tif (unlikely(pages_per_huge_page > MAX_ORDER_NR_PAGES)) {\n\t\tcopy_user_gigantic_page(dst, src, addr, vma,\n\t\t\t\t\tpages_per_huge_page);\n\t\treturn;\n\t}\n\n\tprocess_huge_page(addr_hint, pages_per_huge_page, copy_subpage, &arg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_huge_page",
          "args": [
            "new_page",
            "vmf->address",
            "HPAGE_PMD_NR"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "clear_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "4440-4452",
          "snippet": "void clear_huge_page(struct page *page,\n\t\t     unsigned long addr_hint, unsigned int pages_per_huge_page)\n{\n\tunsigned long addr = addr_hint &\n\t\t~(((unsigned long)pages_per_huge_page << PAGE_SHIFT) - 1);\n\n\tif (unlikely(pages_per_huge_page > MAX_ORDER_NR_PAGES)) {\n\t\tclear_gigantic_page(page, addr, pages_per_huge_page);\n\t\treturn;\n\t}\n\n\tprocess_huge_page(addr_hint, pages_per_huge_page, clear_subpage, page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid clear_huge_page(struct page *page,\n\t\t     unsigned long addr_hint, unsigned int pages_per_huge_page)\n{\n\tunsigned long addr = addr_hint &\n\t\t~(((unsigned long)pages_per_huge_page << PAGE_SHIFT) - 1);\n\n\tif (unlikely(pages_per_huge_page > MAX_ORDER_NR_PAGES)) {\n\t\tclear_gigantic_page(page, addr, pages_per_huge_page);\n\t\treturn;\n\t}\n\n\tprocess_huge_page(addr_hint, pages_per_huge_page, clear_subpage, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "THP_FAULT_ALLOC"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "THP_FAULT_FALLBACK"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split_huge_pmd",
          "args": [
            "vma",
            "vmf->pmd",
            "vmf->address"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "mem_cgroup_try_charge_delay(new_page, vma->vm_mm,\n\t\t\t\t\thuge_gfp, &memcg, true)"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_try_charge_delay",
          "args": [
            "new_page",
            "vma->vm_mm",
            "huge_gfp",
            "&memcg",
            "true"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_try_charge_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5898-5909",
          "snippet": "int mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\tret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);\n\tmemcg = *memcgp;\n\tmem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nint mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\tret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);\n\tmemcg = *memcgp;\n\tmem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "THP_FAULT_FALLBACK"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split_huge_pmd",
          "args": [
            "vma",
            "vmf->pmd",
            "vmf->address"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_huge_pmd_wp_page_fallback",
          "args": [
            "vmf",
            "orig_pmd",
            "page"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "do_huge_pmd_wp_page_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1136-1253",
          "snippet": "static vm_fault_t do_huge_pmd_wp_page_fallback(struct vm_fault *vmf,\n\t\t\tpmd_t orig_pmd, struct page *page)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tunsigned long haddr = vmf->address & HPAGE_PMD_MASK;\n\tstruct mem_cgroup *memcg;\n\tpgtable_t pgtable;\n\tpmd_t _pmd;\n\tint i;\n\tvm_fault_t ret = 0;\n\tstruct page **pages;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\n\tpages = kmalloc_array(HPAGE_PMD_NR, sizeof(struct page *),\n\t\t\t      GFP_KERNEL);\n\tif (unlikely(!pages)) {\n\t\tret |= VM_FAULT_OOM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tpages[i] = alloc_page_vma_node(GFP_HIGHUSER_MOVABLE, vma,\n\t\t\t\t\t       vmf->address, page_to_nid(page));\n\t\tif (unlikely(!pages[i] ||\n\t\t\t     mem_cgroup_try_charge_delay(pages[i], vma->vm_mm,\n\t\t\t\t     GFP_KERNEL, &memcg, false))) {\n\t\t\tif (pages[i])\n\t\t\t\tput_page(pages[i]);\n\t\t\twhile (--i >= 0) {\n\t\t\t\tmemcg = (void *)page_private(pages[i]);\n\t\t\t\tset_page_private(pages[i], 0);\n\t\t\t\tmem_cgroup_cancel_charge(pages[i], memcg,\n\t\t\t\t\t\tfalse);\n\t\t\t\tput_page(pages[i]);\n\t\t\t}\n\t\t\tkfree(pages);\n\t\t\tret |= VM_FAULT_OOM;\n\t\t\tgoto out;\n\t\t}\n\t\tset_page_private(pages[i], (unsigned long)memcg);\n\t}\n\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tcopy_user_highpage(pages[i], page + i,\n\t\t\t\t   haddr + PAGE_SIZE * i, vma);\n\t\t__SetPageUptodate(pages[i]);\n\t\tcond_resched();\n\t}\n\n\tmmun_start = haddr;\n\tmmun_end   = haddr + HPAGE_PMD_SIZE;\n\tmmu_notifier_invalidate_range_start(vma->vm_mm, mmun_start, mmun_end);\n\n\tvmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);\n\tif (unlikely(!pmd_same(*vmf->pmd, orig_pmd)))\n\t\tgoto out_free_pages;\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\n\t/*\n\t * Leave pmd empty until pte is filled note we must notify here as\n\t * concurrent CPU thread might write to new page before the call to\n\t * mmu_notifier_invalidate_range_end() happens which can lead to a\n\t * device seeing memory write in different order than CPU.\n\t *\n\t * See Documentation/vm/mmu_notifier.rst\n\t */\n\tpmdp_huge_clear_flush_notify(vma, haddr, vmf->pmd);\n\n\tpgtable = pgtable_trans_huge_withdraw(vma->vm_mm, vmf->pmd);\n\tpmd_populate(vma->vm_mm, &_pmd, pgtable);\n\n\tfor (i = 0; i < HPAGE_PMD_NR; i++, haddr += PAGE_SIZE) {\n\t\tpte_t entry;\n\t\tentry = mk_pte(pages[i], vma->vm_page_prot);\n\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t\tmemcg = (void *)page_private(pages[i]);\n\t\tset_page_private(pages[i], 0);\n\t\tpage_add_new_anon_rmap(pages[i], vmf->vma, haddr, false);\n\t\tmem_cgroup_commit_charge(pages[i], memcg, false, false);\n\t\tlru_cache_add_active_or_unevictable(pages[i], vma);\n\t\tvmf->pte = pte_offset_map(&_pmd, haddr);\n\t\tVM_BUG_ON(!pte_none(*vmf->pte));\n\t\tset_pte_at(vma->vm_mm, haddr, vmf->pte, entry);\n\t\tpte_unmap(vmf->pte);\n\t}\n\tkfree(pages);\n\n\tsmp_wmb(); /* make pte visible before pmd */\n\tpmd_populate(vma->vm_mm, vmf->pmd, pgtable);\n\tpage_remove_rmap(page, true);\n\tspin_unlock(vmf->ptl);\n\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback as\n\t * the above pmdp_huge_clear_flush_notify() did already call it.\n\t */\n\tmmu_notifier_invalidate_range_only_end(vma->vm_mm, mmun_start,\n\t\t\t\t\t\tmmun_end);\n\n\tret |= VM_FAULT_WRITE;\n\tput_page(page);\n\nout:\n\treturn ret;\n\nout_free_pages:\n\tspin_unlock(vmf->ptl);\n\tmmu_notifier_invalidate_range_end(vma->vm_mm, mmun_start, mmun_end);\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tmemcg = (void *)page_private(pages[i]);\n\t\tset_page_private(pages[i], 0);\n\t\tmem_cgroup_cancel_charge(pages[i], memcg, false);\n\t\tput_page(pages[i]);\n\t}\n\tkfree(pages);\n\tgoto out;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic vm_fault_t do_huge_pmd_wp_page_fallback(struct vm_fault *vmf,\n\t\t\tpmd_t orig_pmd, struct page *page)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tunsigned long haddr = vmf->address & HPAGE_PMD_MASK;\n\tstruct mem_cgroup *memcg;\n\tpgtable_t pgtable;\n\tpmd_t _pmd;\n\tint i;\n\tvm_fault_t ret = 0;\n\tstruct page **pages;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\n\tpages = kmalloc_array(HPAGE_PMD_NR, sizeof(struct page *),\n\t\t\t      GFP_KERNEL);\n\tif (unlikely(!pages)) {\n\t\tret |= VM_FAULT_OOM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tpages[i] = alloc_page_vma_node(GFP_HIGHUSER_MOVABLE, vma,\n\t\t\t\t\t       vmf->address, page_to_nid(page));\n\t\tif (unlikely(!pages[i] ||\n\t\t\t     mem_cgroup_try_charge_delay(pages[i], vma->vm_mm,\n\t\t\t\t     GFP_KERNEL, &memcg, false))) {\n\t\t\tif (pages[i])\n\t\t\t\tput_page(pages[i]);\n\t\t\twhile (--i >= 0) {\n\t\t\t\tmemcg = (void *)page_private(pages[i]);\n\t\t\t\tset_page_private(pages[i], 0);\n\t\t\t\tmem_cgroup_cancel_charge(pages[i], memcg,\n\t\t\t\t\t\tfalse);\n\t\t\t\tput_page(pages[i]);\n\t\t\t}\n\t\t\tkfree(pages);\n\t\t\tret |= VM_FAULT_OOM;\n\t\t\tgoto out;\n\t\t}\n\t\tset_page_private(pages[i], (unsigned long)memcg);\n\t}\n\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tcopy_user_highpage(pages[i], page + i,\n\t\t\t\t   haddr + PAGE_SIZE * i, vma);\n\t\t__SetPageUptodate(pages[i]);\n\t\tcond_resched();\n\t}\n\n\tmmun_start = haddr;\n\tmmun_end   = haddr + HPAGE_PMD_SIZE;\n\tmmu_notifier_invalidate_range_start(vma->vm_mm, mmun_start, mmun_end);\n\n\tvmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);\n\tif (unlikely(!pmd_same(*vmf->pmd, orig_pmd)))\n\t\tgoto out_free_pages;\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\n\t/*\n\t * Leave pmd empty until pte is filled note we must notify here as\n\t * concurrent CPU thread might write to new page before the call to\n\t * mmu_notifier_invalidate_range_end() happens which can lead to a\n\t * device seeing memory write in different order than CPU.\n\t *\n\t * See Documentation/vm/mmu_notifier.rst\n\t */\n\tpmdp_huge_clear_flush_notify(vma, haddr, vmf->pmd);\n\n\tpgtable = pgtable_trans_huge_withdraw(vma->vm_mm, vmf->pmd);\n\tpmd_populate(vma->vm_mm, &_pmd, pgtable);\n\n\tfor (i = 0; i < HPAGE_PMD_NR; i++, haddr += PAGE_SIZE) {\n\t\tpte_t entry;\n\t\tentry = mk_pte(pages[i], vma->vm_page_prot);\n\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t\tmemcg = (void *)page_private(pages[i]);\n\t\tset_page_private(pages[i], 0);\n\t\tpage_add_new_anon_rmap(pages[i], vmf->vma, haddr, false);\n\t\tmem_cgroup_commit_charge(pages[i], memcg, false, false);\n\t\tlru_cache_add_active_or_unevictable(pages[i], vma);\n\t\tvmf->pte = pte_offset_map(&_pmd, haddr);\n\t\tVM_BUG_ON(!pte_none(*vmf->pte));\n\t\tset_pte_at(vma->vm_mm, haddr, vmf->pte, entry);\n\t\tpte_unmap(vmf->pte);\n\t}\n\tkfree(pages);\n\n\tsmp_wmb(); /* make pte visible before pmd */\n\tpmd_populate(vma->vm_mm, vmf->pmd, pgtable);\n\tpage_remove_rmap(page, true);\n\tspin_unlock(vmf->ptl);\n\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback as\n\t * the above pmdp_huge_clear_flush_notify() did already call it.\n\t */\n\tmmu_notifier_invalidate_range_only_end(vma->vm_mm, mmun_start,\n\t\t\t\t\t\tmmun_end);\n\n\tret |= VM_FAULT_WRITE;\n\tput_page(page);\n\nout:\n\treturn ret;\n\nout_free_pages:\n\tspin_unlock(vmf->ptl);\n\tmmu_notifier_invalidate_range_end(vma->vm_mm, mmun_start, mmun_end);\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tmemcg = (void *)page_private(pages[i]);\n\t\tset_page_private(pages[i], 0);\n\t\tmem_cgroup_cancel_charge(pages[i], memcg, false);\n\t\tput_page(pages[i]);\n\t}\n\tkfree(pages);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "split_huge_pmd",
          "args": [
            "vma",
            "vmf->pmd",
            "vmf->address"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prep_transhuge_page",
          "args": [
            "new_page"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "prep_transhuge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "490-499",
          "snippet": "void prep_transhuge_page(struct page *page)\n{\n\t/*\n\t * we use page->mapping and page->indexlru in second tail page\n\t * as list_head: assuming THP order >= 2\n\t */\n\n\tINIT_LIST_HEAD(page_deferred_list(page));\n\tset_compound_page_dtor(page, TRANSHUGE_PAGE_DTOR);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid prep_transhuge_page(struct page *page)\n{\n\t/*\n\t * we use page->mapping and page->indexlru in second tail page\n\t * as list_head: assuming THP order >= 2\n\t */\n\n\tINIT_LIST_HEAD(page_deferred_list(page));\n\tset_compound_page_dtor(page, TRANSHUGE_PAGE_DTOR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "new_page"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages_vma",
          "args": [
            "huge_gfp",
            "HPAGE_PMD_ORDER",
            "vma",
            "haddr",
            "numa_node_id()"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_pages_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2022-2048",
          "snippet": "struct page *\nalloc_pages_vma(gfp_t gfp, int order, struct vm_area_struct *vma,\n\t\tunsigned long addr, int node)\n{\n\tstruct mempolicy *pol;\n\tstruct page *page;\n\tint preferred_nid;\n\tnodemask_t *nmask;\n\n\tpol = get_vma_policy(vma, addr);\n\n\tif (pol->mode == MPOL_INTERLEAVE) {\n\t\tunsigned nid;\n\n\t\tnid = interleave_nid(pol, vma, addr, PAGE_SHIFT + order);\n\t\tmpol_cond_put(pol);\n\t\tpage = alloc_page_interleave(gfp, order, nid);\n\t\tgoto out;\n\t}\n\n\tnmask = policy_nodemask(gfp, pol);\n\tpreferred_nid = policy_node(gfp, pol, node);\n\tpage = __alloc_pages_nodemask(gfp, order, preferred_nid, nmask);\n\tmpol_cond_put(pol);\nout:\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstruct page *\nalloc_pages_vma(gfp_t gfp, int order, struct vm_area_struct *vma,\n\t\tunsigned long addr, int node)\n{\n\tstruct mempolicy *pol;\n\tstruct page *page;\n\tint preferred_nid;\n\tnodemask_t *nmask;\n\n\tpol = get_vma_policy(vma, addr);\n\n\tif (pol->mode == MPOL_INTERLEAVE) {\n\t\tunsigned nid;\n\n\t\tnid = interleave_nid(pol, vma, addr, PAGE_SHIFT + order);\n\t\tmpol_cond_put(pol);\n\t\tpage = alloc_page_interleave(gfp, order, nid);\n\t\tgoto out;\n\t}\n\n\tnmask = policy_nodemask(gfp, pol);\n\tpreferred_nid = policy_node(gfp, pol, node);\n\tpage = __alloc_pages_nodemask(gfp, order, preferred_nid, nmask);\n\tmpol_cond_put(pol);\nout:\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "numa_node_id",
          "args": [],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_hugepage_direct_gfpmask",
          "args": [
            "vma",
            "haddr"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_hugepage_direct_gfpmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "632-666",
          "snippet": "static inline gfp_t alloc_hugepage_direct_gfpmask(struct vm_area_struct *vma, unsigned long addr)\n{\n\tconst bool vma_madvised = !!(vma->vm_flags & VM_HUGEPAGE);\n\tgfp_t this_node = 0;\n\n#ifdef CONFIG_NUMA\n\tstruct mempolicy *pol;\n\t/*\n\t * __GFP_THISNODE is used only when __GFP_DIRECT_RECLAIM is not\n\t * specified, to express a general desire to stay on the current\n\t * node for optimistic allocation attempts. If the defrag mode\n\t * and/or madvise hint requires the direct reclaim then we prefer\n\t * to fallback to other node rather than node reclaim because that\n\t * can lead to excessive reclaim even though there is free memory\n\t * on other nodes. We expect that NUMA preferences are specified\n\t * by memory policies.\n\t */\n\tpol = get_vma_policy(vma, addr);\n\tif (pol->mode != MPOL_BIND)\n\t\tthis_node = __GFP_THISNODE;\n\tmpol_cond_put(pol);\n#endif\n\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE | (vma_madvised ? 0 : __GFP_NORETRY);\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE_LIGHT | __GFP_KSWAPD_RECLAIM | this_node;\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE_LIGHT | (vma_madvised ? __GFP_DIRECT_RECLAIM :\n\t\t\t\t\t\t\t     __GFP_KSWAPD_RECLAIM | this_node);\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE_LIGHT | (vma_madvised ? __GFP_DIRECT_RECLAIM :\n\t\t\t\t\t\t\t     this_node);\n\treturn GFP_TRANSHUGE_LIGHT | this_node;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline gfp_t alloc_hugepage_direct_gfpmask(struct vm_area_struct *vma, unsigned long addr)\n{\n\tconst bool vma_madvised = !!(vma->vm_flags & VM_HUGEPAGE);\n\tgfp_t this_node = 0;\n\n#ifdef CONFIG_NUMA\n\tstruct mempolicy *pol;\n\t/*\n\t * __GFP_THISNODE is used only when __GFP_DIRECT_RECLAIM is not\n\t * specified, to express a general desire to stay on the current\n\t * node for optimistic allocation attempts. If the defrag mode\n\t * and/or madvise hint requires the direct reclaim then we prefer\n\t * to fallback to other node rather than node reclaim because that\n\t * can lead to excessive reclaim even though there is free memory\n\t * on other nodes. We expect that NUMA preferences are specified\n\t * by memory policies.\n\t */\n\tpol = get_vma_policy(vma, addr);\n\tif (pol->mode != MPOL_BIND)\n\t\tthis_node = __GFP_THISNODE;\n\tmpol_cond_put(pol);\n#endif\n\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE | (vma_madvised ? 0 : __GFP_NORETRY);\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE_LIGHT | __GFP_KSWAPD_RECLAIM | this_node;\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE_LIGHT | (vma_madvised ? __GFP_DIRECT_RECLAIM :\n\t\t\t\t\t\t\t     __GFP_KSWAPD_RECLAIM | this_node);\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE_LIGHT | (vma_madvised ? __GFP_DIRECT_RECLAIM :\n\t\t\t\t\t\t\t     this_node);\n\treturn GFP_TRANSHUGE_LIGHT | this_node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "transparent_hugepage_debug_cow",
          "args": [],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "transparent_hugepage_enabled",
          "args": [
            "vma"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "vmf->ptl"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_mmu_cache_pmd",
          "args": [
            "vma",
            "vmf->address",
            "vmf->pmd"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmdp_set_access_flags",
          "args": [
            "vma",
            "haddr",
            "vmf->pmd",
            "entry",
            "1"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "pmdp_set_access_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "96-107",
          "snippet": "int pmdp_set_access_flags(struct vm_area_struct *vma,\n\t\t\t  unsigned long address, pmd_t *pmdp,\n\t\t\t  pmd_t entry, int dirty)\n{\n\tint changed = !pmd_same(*pmdp, entry);\n\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);\n\tif (changed) {\n\t\tset_pmd_at(vma->vm_mm, address, pmdp, entry);\n\t\tflush_pmd_tlb_range(vma, address, address + HPAGE_PMD_SIZE);\n\t}\n\treturn changed;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\nint pmdp_set_access_flags(struct vm_area_struct *vma,\n\t\t\t  unsigned long address, pmd_t *pmdp,\n\t\t\t  pmd_t entry, int dirty)\n{\n\tint changed = !pmd_same(*pmdp, entry);\n\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);\n\tif (changed) {\n\t\tset_pmd_at(vma->vm_mm, address, pmdp, entry);\n\t\tflush_pmd_tlb_range(vma, address, address + HPAGE_PMD_SIZE);\n\t}\n\treturn changed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_mkdirty",
          "args": [
            "entry"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_mkyoung",
          "args": [
            "orig_pmd"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reuse_swap_page",
          "args": [
            "page",
            "NULL"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "reuse_swap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1544-1578",
          "snippet": "bool reuse_swap_page(struct page *page, int *total_map_swapcount)\n{\n\tint count, total_mapcount, total_swapcount;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (unlikely(PageKsm(page)))\n\t\treturn false;\n\tcount = page_trans_huge_map_swapcount(page, &total_mapcount,\n\t\t\t\t\t      &total_swapcount);\n\tif (total_map_swapcount)\n\t\t*total_map_swapcount = total_mapcount + total_swapcount;\n\tif (count == 1 && PageSwapCache(page) &&\n\t    (likely(!PageTransCompound(page)) ||\n\t     /* The remaining swap count will be freed soon */\n\t     total_swapcount == page_swapcount(page))) {\n\t\tif (!PageWriteback(page)) {\n\t\t\tpage = compound_head(page);\n\t\t\tdelete_from_swap_cache(page);\n\t\t\tSetPageDirty(page);\n\t\t} else {\n\t\t\tswp_entry_t entry;\n\t\t\tstruct swap_info_struct *p;\n\n\t\t\tentry.val = page_private(page);\n\t\t\tp = swap_info_get(entry);\n\t\t\tif (p->flags & SWP_STABLE_WRITES) {\n\t\t\t\tspin_unlock(&p->lock);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tspin_unlock(&p->lock);\n\t\t}\n\t}\n\n\treturn count <= 1;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nbool reuse_swap_page(struct page *page, int *total_map_swapcount)\n{\n\tint count, total_mapcount, total_swapcount;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (unlikely(PageKsm(page)))\n\t\treturn false;\n\tcount = page_trans_huge_map_swapcount(page, &total_mapcount,\n\t\t\t\t\t      &total_swapcount);\n\tif (total_map_swapcount)\n\t\t*total_map_swapcount = total_mapcount + total_swapcount;\n\tif (count == 1 && PageSwapCache(page) &&\n\t    (likely(!PageTransCompound(page)) ||\n\t     /* The remaining swap count will be freed soon */\n\t     total_swapcount == page_swapcount(page))) {\n\t\tif (!PageWriteback(page)) {\n\t\t\tpage = compound_head(page);\n\t\t\tdelete_from_swap_cache(page);\n\t\t\tSetPageDirty(page);\n\t\t} else {\n\t\t\tswp_entry_t entry;\n\t\t\tstruct swap_info_struct *p;\n\n\t\t\tentry.val = page_private(page);\n\t\t\tp = swap_info_get(entry);\n\t\t\tif (p->flags & SWP_STABLE_WRITES) {\n\t\t\t\tspin_unlock(&p->lock);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tspin_unlock(&p->lock);\n\t\t}\n\t}\n\n\treturn count <= 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pmd_same(*vmf->pmd, orig_pmd)"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_same",
          "args": [
            "*vmf->pmd",
            "orig_pmd"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "vmf->ptl"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "vmf->ptl"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageCompound(page) || !PageHead(page)",
            "page"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_page",
          "args": [
            "orig_pmd"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pmd_same(*vmf->pmd, orig_pmd)"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_same",
          "args": [
            "*vmf->pmd",
            "orig_pmd"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "vmf->ptl"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_huge_zero_pmd",
          "args": [
            "orig_pmd"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_VMA",
          "args": [
            "!vma->anon_vma",
            "vma"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_lockptr",
          "args": [
            "vma->vm_mm",
            "vmf->pmd"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvm_fault_t do_huge_pmd_wp_page(struct vm_fault *vmf, pmd_t orig_pmd)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page = NULL, *new_page;\n\tstruct mem_cgroup *memcg;\n\tunsigned long haddr = vmf->address & HPAGE_PMD_MASK;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\tgfp_t huge_gfp;\t\t\t/* for allocation and charge */\n\tvm_fault_t ret = 0;\n\n\tvmf->ptl = pmd_lockptr(vma->vm_mm, vmf->pmd);\n\tVM_BUG_ON_VMA(!vma->anon_vma, vma);\n\tif (is_huge_zero_pmd(orig_pmd))\n\t\tgoto alloc;\n\tspin_lock(vmf->ptl);\n\tif (unlikely(!pmd_same(*vmf->pmd, orig_pmd)))\n\t\tgoto out_unlock;\n\n\tpage = pmd_page(orig_pmd);\n\tVM_BUG_ON_PAGE(!PageCompound(page) || !PageHead(page), page);\n\t/*\n\t * We can only reuse the page if nobody else maps the huge page or it's\n\t * part.\n\t */\n\tif (!trylock_page(page)) {\n\t\tget_page(page);\n\t\tspin_unlock(vmf->ptl);\n\t\tlock_page(page);\n\t\tspin_lock(vmf->ptl);\n\t\tif (unlikely(!pmd_same(*vmf->pmd, orig_pmd))) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tput_page(page);\n\t}\n\tif (reuse_swap_page(page, NULL)) {\n\t\tpmd_t entry;\n\t\tentry = pmd_mkyoung(orig_pmd);\n\t\tentry = maybe_pmd_mkwrite(pmd_mkdirty(entry), vma);\n\t\tif (pmdp_set_access_flags(vma, haddr, vmf->pmd, entry,  1))\n\t\t\tupdate_mmu_cache_pmd(vma, vmf->address, vmf->pmd);\n\t\tret |= VM_FAULT_WRITE;\n\t\tunlock_page(page);\n\t\tgoto out_unlock;\n\t}\n\tunlock_page(page);\n\tget_page(page);\n\tspin_unlock(vmf->ptl);\nalloc:\n\tif (transparent_hugepage_enabled(vma) &&\n\t    !transparent_hugepage_debug_cow()) {\n\t\thuge_gfp = alloc_hugepage_direct_gfpmask(vma, haddr);\n\t\tnew_page = alloc_pages_vma(huge_gfp, HPAGE_PMD_ORDER, vma,\n\t\t\t\thaddr, numa_node_id());\n\t} else\n\t\tnew_page = NULL;\n\n\tif (likely(new_page)) {\n\t\tprep_transhuge_page(new_page);\n\t} else {\n\t\tif (!page) {\n\t\t\tsplit_huge_pmd(vma, vmf->pmd, vmf->address);\n\t\t\tret |= VM_FAULT_FALLBACK;\n\t\t} else {\n\t\t\tret = do_huge_pmd_wp_page_fallback(vmf, orig_pmd, page);\n\t\t\tif (ret & VM_FAULT_OOM) {\n\t\t\t\tsplit_huge_pmd(vma, vmf->pmd, vmf->address);\n\t\t\t\tret |= VM_FAULT_FALLBACK;\n\t\t\t}\n\t\t\tput_page(page);\n\t\t}\n\t\tcount_vm_event(THP_FAULT_FALLBACK);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(mem_cgroup_try_charge_delay(new_page, vma->vm_mm,\n\t\t\t\t\thuge_gfp, &memcg, true))) {\n\t\tput_page(new_page);\n\t\tsplit_huge_pmd(vma, vmf->pmd, vmf->address);\n\t\tif (page)\n\t\t\tput_page(page);\n\t\tret |= VM_FAULT_FALLBACK;\n\t\tcount_vm_event(THP_FAULT_FALLBACK);\n\t\tgoto out;\n\t}\n\n\tcount_vm_event(THP_FAULT_ALLOC);\n\n\tif (!page)\n\t\tclear_huge_page(new_page, vmf->address, HPAGE_PMD_NR);\n\telse\n\t\tcopy_user_huge_page(new_page, page, vmf->address,\n\t\t\t\t    vma, HPAGE_PMD_NR);\n\t__SetPageUptodate(new_page);\n\n\tmmun_start = haddr;\n\tmmun_end   = haddr + HPAGE_PMD_SIZE;\n\tmmu_notifier_invalidate_range_start(vma->vm_mm, mmun_start, mmun_end);\n\n\tspin_lock(vmf->ptl);\n\tif (page)\n\t\tput_page(page);\n\tif (unlikely(!pmd_same(*vmf->pmd, orig_pmd))) {\n\t\tspin_unlock(vmf->ptl);\n\t\tmem_cgroup_cancel_charge(new_page, memcg, true);\n\t\tput_page(new_page);\n\t\tgoto out_mn;\n\t} else {\n\t\tpmd_t entry;\n\t\tentry = mk_huge_pmd(new_page, vma->vm_page_prot);\n\t\tentry = maybe_pmd_mkwrite(pmd_mkdirty(entry), vma);\n\t\tpmdp_huge_clear_flush_notify(vma, haddr, vmf->pmd);\n\t\tpage_add_new_anon_rmap(new_page, vma, haddr, true);\n\t\tmem_cgroup_commit_charge(new_page, memcg, false, true);\n\t\tlru_cache_add_active_or_unevictable(new_page, vma);\n\t\tset_pmd_at(vma->vm_mm, haddr, vmf->pmd, entry);\n\t\tupdate_mmu_cache_pmd(vma, vmf->address, vmf->pmd);\n\t\tif (!page) {\n\t\t\tadd_mm_counter(vma->vm_mm, MM_ANONPAGES, HPAGE_PMD_NR);\n\t\t} else {\n\t\t\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\t\t\tpage_remove_rmap(page, true);\n\t\t\tput_page(page);\n\t\t}\n\t\tret |= VM_FAULT_WRITE;\n\t}\n\tspin_unlock(vmf->ptl);\nout_mn:\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback as\n\t * the above pmdp_huge_clear_flush_notify() did already call it.\n\t */\n\tmmu_notifier_invalidate_range_only_end(vma->vm_mm, mmun_start,\n\t\t\t\t\t       mmun_end);\nout:\n\treturn ret;\nout_unlock:\n\tspin_unlock(vmf->ptl);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_huge_pmd_wp_page_fallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "1136-1253",
    "snippet": "static vm_fault_t do_huge_pmd_wp_page_fallback(struct vm_fault *vmf,\n\t\t\tpmd_t orig_pmd, struct page *page)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tunsigned long haddr = vmf->address & HPAGE_PMD_MASK;\n\tstruct mem_cgroup *memcg;\n\tpgtable_t pgtable;\n\tpmd_t _pmd;\n\tint i;\n\tvm_fault_t ret = 0;\n\tstruct page **pages;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\n\tpages = kmalloc_array(HPAGE_PMD_NR, sizeof(struct page *),\n\t\t\t      GFP_KERNEL);\n\tif (unlikely(!pages)) {\n\t\tret |= VM_FAULT_OOM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tpages[i] = alloc_page_vma_node(GFP_HIGHUSER_MOVABLE, vma,\n\t\t\t\t\t       vmf->address, page_to_nid(page));\n\t\tif (unlikely(!pages[i] ||\n\t\t\t     mem_cgroup_try_charge_delay(pages[i], vma->vm_mm,\n\t\t\t\t     GFP_KERNEL, &memcg, false))) {\n\t\t\tif (pages[i])\n\t\t\t\tput_page(pages[i]);\n\t\t\twhile (--i >= 0) {\n\t\t\t\tmemcg = (void *)page_private(pages[i]);\n\t\t\t\tset_page_private(pages[i], 0);\n\t\t\t\tmem_cgroup_cancel_charge(pages[i], memcg,\n\t\t\t\t\t\tfalse);\n\t\t\t\tput_page(pages[i]);\n\t\t\t}\n\t\t\tkfree(pages);\n\t\t\tret |= VM_FAULT_OOM;\n\t\t\tgoto out;\n\t\t}\n\t\tset_page_private(pages[i], (unsigned long)memcg);\n\t}\n\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tcopy_user_highpage(pages[i], page + i,\n\t\t\t\t   haddr + PAGE_SIZE * i, vma);\n\t\t__SetPageUptodate(pages[i]);\n\t\tcond_resched();\n\t}\n\n\tmmun_start = haddr;\n\tmmun_end   = haddr + HPAGE_PMD_SIZE;\n\tmmu_notifier_invalidate_range_start(vma->vm_mm, mmun_start, mmun_end);\n\n\tvmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);\n\tif (unlikely(!pmd_same(*vmf->pmd, orig_pmd)))\n\t\tgoto out_free_pages;\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\n\t/*\n\t * Leave pmd empty until pte is filled note we must notify here as\n\t * concurrent CPU thread might write to new page before the call to\n\t * mmu_notifier_invalidate_range_end() happens which can lead to a\n\t * device seeing memory write in different order than CPU.\n\t *\n\t * See Documentation/vm/mmu_notifier.rst\n\t */\n\tpmdp_huge_clear_flush_notify(vma, haddr, vmf->pmd);\n\n\tpgtable = pgtable_trans_huge_withdraw(vma->vm_mm, vmf->pmd);\n\tpmd_populate(vma->vm_mm, &_pmd, pgtable);\n\n\tfor (i = 0; i < HPAGE_PMD_NR; i++, haddr += PAGE_SIZE) {\n\t\tpte_t entry;\n\t\tentry = mk_pte(pages[i], vma->vm_page_prot);\n\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t\tmemcg = (void *)page_private(pages[i]);\n\t\tset_page_private(pages[i], 0);\n\t\tpage_add_new_anon_rmap(pages[i], vmf->vma, haddr, false);\n\t\tmem_cgroup_commit_charge(pages[i], memcg, false, false);\n\t\tlru_cache_add_active_or_unevictable(pages[i], vma);\n\t\tvmf->pte = pte_offset_map(&_pmd, haddr);\n\t\tVM_BUG_ON(!pte_none(*vmf->pte));\n\t\tset_pte_at(vma->vm_mm, haddr, vmf->pte, entry);\n\t\tpte_unmap(vmf->pte);\n\t}\n\tkfree(pages);\n\n\tsmp_wmb(); /* make pte visible before pmd */\n\tpmd_populate(vma->vm_mm, vmf->pmd, pgtable);\n\tpage_remove_rmap(page, true);\n\tspin_unlock(vmf->ptl);\n\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback as\n\t * the above pmdp_huge_clear_flush_notify() did already call it.\n\t */\n\tmmu_notifier_invalidate_range_only_end(vma->vm_mm, mmun_start,\n\t\t\t\t\t\tmmun_end);\n\n\tret |= VM_FAULT_WRITE;\n\tput_page(page);\n\nout:\n\treturn ret;\n\nout_free_pages:\n\tspin_unlock(vmf->ptl);\n\tmmu_notifier_invalidate_range_end(vma->vm_mm, mmun_start, mmun_end);\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tmemcg = (void *)page_private(pages[i]);\n\t\tset_page_private(pages[i], 0);\n\t\tmem_cgroup_cancel_charge(pages[i], memcg, false);\n\t\tput_page(pages[i]);\n\t}\n\tkfree(pages);\n\tgoto out;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pages"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "pages[i]"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_cancel_charge",
          "args": [
            "pages[i]",
            "memcg",
            "false"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_cancel_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5972-5988",
          "snippet": "void mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,\n\t\tbool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcancel_charge(memcg, nr_pages);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,\n\t\tbool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcancel_charge(memcg, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "pages[i]",
            "0"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "pages[i]"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_end",
          "args": [
            "vma->vm_mm",
            "mmun_start",
            "mmun_end"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "vmf->ptl"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_only_end",
          "args": [
            "vma->vm_mm",
            "mmun_start",
            "mmun_end"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "vmf->ptl"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_remove_rmap",
          "args": [
            "page",
            "true"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "page_remove_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1297-1331",
          "snippet": "void page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_populate",
          "args": [
            "vma->vm_mm",
            "vmf->pmd",
            "pgtable"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "zero_pmd_populate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan_init.c",
          "lines": "105-135",
          "snippet": "static int __ref zero_pmd_populate(pud_t *pud, unsigned long addr,\n\t\t\t\tunsigned long end)\n{\n\tpmd_t *pmd = pmd_offset(pud, addr);\n\tunsigned long next;\n\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\n\t\tif (IS_ALIGNED(addr, PMD_SIZE) && end - addr >= PMD_SIZE) {\n\t\t\tpmd_populate_kernel(&init_mm, pmd, lm_alias(kasan_zero_pte));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pmd_none(*pmd)) {\n\t\t\tpte_t *p;\n\n\t\t\tif (slab_is_available())\n\t\t\t\tp = pte_alloc_one_kernel(&init_mm, addr);\n\t\t\telse\n\t\t\t\tp = early_alloc(PAGE_SIZE, NUMA_NO_NODE);\n\t\t\tif (!p)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tpmd_populate_kernel(&init_mm, pmd, p);\n\t\t}\n\t\tzero_pte_populate(pmd, addr, next);\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kasan.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/page.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/memblock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pte_t kasan_zero_pte[PTRS_PER_PTE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kasan.h\"\n#include <asm/pgalloc.h>\n#include <asm/page.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/memblock.h>\n\npte_t kasan_zero_pte[PTRS_PER_PTE];\n\nstatic int __ref zero_pmd_populate(pud_t *pud, unsigned long addr,\n\t\t\t\tunsigned long end)\n{\n\tpmd_t *pmd = pmd_offset(pud, addr);\n\tunsigned long next;\n\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\n\t\tif (IS_ALIGNED(addr, PMD_SIZE) && end - addr >= PMD_SIZE) {\n\t\t\tpmd_populate_kernel(&init_mm, pmd, lm_alias(kasan_zero_pte));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pmd_none(*pmd)) {\n\t\t\tpte_t *p;\n\n\t\t\tif (slab_is_available())\n\t\t\t\tp = pte_alloc_one_kernel(&init_mm, addr);\n\t\t\telse\n\t\t\t\tp = early_alloc(PAGE_SIZE, NUMA_NO_NODE);\n\t\t\tif (!p)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tpmd_populate_kernel(&init_mm, pmd, p);\n\t\t}\n\t\tzero_pte_populate(pmd, addr, next);\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap",
          "args": [
            "vmf->pte"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "vma->vm_mm",
            "haddr",
            "vmf->pte",
            "entry"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!pte_none(*vmf->pte)"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "*vmf->pte"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map",
          "args": [
            "&_pmd",
            "haddr"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_cache_add_active_or_unevictable",
          "args": [
            "pages[i]",
            "vma"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "lru_cache_add_active_or_unevictable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "458-476",
          "snippet": "void lru_cache_add_active_or_unevictable(struct page *page,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\tif (likely((vma->vm_flags & (VM_LOCKED | VM_SPECIAL)) != VM_LOCKED))\n\t\tSetPageActive(page);\n\telse if (!TestSetPageMlocked(page)) {\n\t\t/*\n\t\t * We use the irq-unsafe __mod_zone_page_stat because this\n\t\t * counter is not modified from interrupt context, and the pte\n\t\t * lock is held(spinlock), which implies preemption disabled.\n\t\t */\n\t\t__mod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t}\n\tlru_cache_add(page);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid lru_cache_add_active_or_unevictable(struct page *page,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\tif (likely((vma->vm_flags & (VM_LOCKED | VM_SPECIAL)) != VM_LOCKED))\n\t\tSetPageActive(page);\n\telse if (!TestSetPageMlocked(page)) {\n\t\t/*\n\t\t * We use the irq-unsafe __mod_zone_page_stat because this\n\t\t * counter is not modified from interrupt context, and the pte\n\t\t * lock is held(spinlock), which implies preemption disabled.\n\t\t */\n\t\t__mod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t}\n\tlru_cache_add(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_commit_charge",
          "args": [
            "pages[i]",
            "memcg",
            "false",
            "false"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_commit_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5928-5962",
          "snippet": "void mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t      bool lrucare, bool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_PAGE(!page->mapping, page);\n\tVM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcommit_charge(page, memcg, lrucare);\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(memcg, page, compound, nr_pages);\n\tmemcg_check_events(memcg, page);\n\tlocal_irq_enable();\n\n\tif (do_memsw_account() && PageSwapCache(page)) {\n\t\tswp_entry_t entry = { .val = page_private(page) };\n\t\t/*\n\t\t * The swap entry might not get freed for a long time,\n\t\t * let's not wait for it.  The page already received a\n\t\t * memory+swap charge, drop the swap entry duplicate.\n\t\t */\n\t\tmem_cgroup_uncharge_swap(entry, nr_pages);\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t      bool lrucare, bool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_PAGE(!page->mapping, page);\n\tVM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcommit_charge(page, memcg, lrucare);\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(memcg, page, compound, nr_pages);\n\tmemcg_check_events(memcg, page);\n\tlocal_irq_enable();\n\n\tif (do_memsw_account() && PageSwapCache(page)) {\n\t\tswp_entry_t entry = { .val = page_private(page) };\n\t\t/*\n\t\t * The swap entry might not get freed for a long time,\n\t\t * let's not wait for it.  The page already received a\n\t\t * memory+swap charge, drop the swap entry duplicate.\n\t\t */\n\t\tmem_cgroup_uncharge_swap(entry, nr_pages);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_add_new_anon_rmap",
          "args": [
            "pages[i]",
            "vmf->vma",
            "haddr",
            "false"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "page_add_new_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1150-1170",
          "snippet": "void page_add_new_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, bool compound)\n{\n\tint nr = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\t__SetPageSwapBacked(page);\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(compound_mapcount_ptr(page), 0);\n\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t} else {\n\t\t/* Anon THP always mapped first with PMD */\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(&page->_mapcount, 0);\n\t}\n\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t__page_set_anon_rmap(page, vma, address, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_add_new_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, bool compound)\n{\n\tint nr = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\t__SetPageSwapBacked(page);\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(compound_mapcount_ptr(page), 0);\n\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t} else {\n\t\t/* Anon THP always mapped first with PMD */\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(&page->_mapcount, 0);\n\t}\n\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t__page_set_anon_rmap(page, vma, address, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "pages[i]",
            "0"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "pages[i]"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "maybe_mkwrite",
          "args": [
            "pte_mkdirty(entry)",
            "vma"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkdirty",
          "args": [
            "entry"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mk_pte",
          "args": [
            "pages[i]",
            "vma->vm_page_prot"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgtable_trans_huge_withdraw",
          "args": [
            "vma->vm_mm",
            "vmf->pmd"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "pgtable_trans_huge_withdraw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "168-181",
          "snippet": "pgtable_t pgtable_trans_huge_withdraw(struct mm_struct *mm, pmd_t *pmdp)\n{\n\tpgtable_t pgtable;\n\n\tassert_spin_locked(pmd_lockptr(mm, pmdp));\n\n\t/* FIFO */\n\tpgtable = pmd_huge_pte(mm, pmdp);\n\tpmd_huge_pte(mm, pmdp) = list_first_entry_or_null(&pgtable->lru,\n\t\t\t\t\t\t\t  struct page, lru);\n\tif (pmd_huge_pte(mm, pmdp))\n\t\tlist_del(&pgtable->lru);\n\treturn pgtable;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\npgtable_t pgtable_trans_huge_withdraw(struct mm_struct *mm, pmd_t *pmdp)\n{\n\tpgtable_t pgtable;\n\n\tassert_spin_locked(pmd_lockptr(mm, pmdp));\n\n\t/* FIFO */\n\tpgtable = pmd_huge_pte(mm, pmdp);\n\tpmd_huge_pte(mm, pmdp) = list_first_entry_or_null(&pgtable->lru,\n\t\t\t\t\t\t\t  struct page, lru);\n\tif (pmd_huge_pte(mm, pmdp))\n\t\tlist_del(&pgtable->lru);\n\treturn pgtable;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmdp_huge_clear_flush_notify",
          "args": [
            "vma",
            "haddr",
            "vmf->pmd"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageHead(page)",
            "page"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHead",
          "args": [
            "page"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "PageHeadHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1350-1356",
          "snippet": "int PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pmd_same(*vmf->pmd, orig_pmd)"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_same",
          "args": [
            "*vmf->pmd",
            "orig_pmd"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_lock",
          "args": [
            "vma->vm_mm",
            "vmf->pmd"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "vma->vm_mm",
            "mmun_start",
            "mmun_end"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SetPageUptodate",
          "args": [
            "pages[i]"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_user_highpage",
          "args": [
            "pages[i]",
            "page + i",
            "haddr + PAGE_SIZE * i",
            "vma"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "pages[i]",
            "(unsigned long)memcg"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "pages[i]",
            "0"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "pages[i]"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pages[i] ||\n\t\t\t     mem_cgroup_try_charge_delay(pages[i], vma->vm_mm,\n\t\t\t\t     GFP_KERNEL, &memcg, false)"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_try_charge_delay",
          "args": [
            "pages[i]",
            "vma->vm_mm",
            "GFP_KERNEL",
            "&memcg",
            "false"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_try_charge_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5898-5909",
          "snippet": "int mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\tret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);\n\tmemcg = *memcgp;\n\tmem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nint mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\tret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);\n\tmemcg = *memcgp;\n\tmem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page_vma_node",
          "args": [
            "GFP_HIGHUSER_MOVABLE",
            "vma",
            "vmf->address",
            "page_to_nid(page)"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pages"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "HPAGE_PMD_NR",
            "sizeof(struct page *)",
            "GFP_KERNEL"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic vm_fault_t do_huge_pmd_wp_page_fallback(struct vm_fault *vmf,\n\t\t\tpmd_t orig_pmd, struct page *page)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tunsigned long haddr = vmf->address & HPAGE_PMD_MASK;\n\tstruct mem_cgroup *memcg;\n\tpgtable_t pgtable;\n\tpmd_t _pmd;\n\tint i;\n\tvm_fault_t ret = 0;\n\tstruct page **pages;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\n\tpages = kmalloc_array(HPAGE_PMD_NR, sizeof(struct page *),\n\t\t\t      GFP_KERNEL);\n\tif (unlikely(!pages)) {\n\t\tret |= VM_FAULT_OOM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tpages[i] = alloc_page_vma_node(GFP_HIGHUSER_MOVABLE, vma,\n\t\t\t\t\t       vmf->address, page_to_nid(page));\n\t\tif (unlikely(!pages[i] ||\n\t\t\t     mem_cgroup_try_charge_delay(pages[i], vma->vm_mm,\n\t\t\t\t     GFP_KERNEL, &memcg, false))) {\n\t\t\tif (pages[i])\n\t\t\t\tput_page(pages[i]);\n\t\t\twhile (--i >= 0) {\n\t\t\t\tmemcg = (void *)page_private(pages[i]);\n\t\t\t\tset_page_private(pages[i], 0);\n\t\t\t\tmem_cgroup_cancel_charge(pages[i], memcg,\n\t\t\t\t\t\tfalse);\n\t\t\t\tput_page(pages[i]);\n\t\t\t}\n\t\t\tkfree(pages);\n\t\t\tret |= VM_FAULT_OOM;\n\t\t\tgoto out;\n\t\t}\n\t\tset_page_private(pages[i], (unsigned long)memcg);\n\t}\n\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tcopy_user_highpage(pages[i], page + i,\n\t\t\t\t   haddr + PAGE_SIZE * i, vma);\n\t\t__SetPageUptodate(pages[i]);\n\t\tcond_resched();\n\t}\n\n\tmmun_start = haddr;\n\tmmun_end   = haddr + HPAGE_PMD_SIZE;\n\tmmu_notifier_invalidate_range_start(vma->vm_mm, mmun_start, mmun_end);\n\n\tvmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);\n\tif (unlikely(!pmd_same(*vmf->pmd, orig_pmd)))\n\t\tgoto out_free_pages;\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\n\t/*\n\t * Leave pmd empty until pte is filled note we must notify here as\n\t * concurrent CPU thread might write to new page before the call to\n\t * mmu_notifier_invalidate_range_end() happens which can lead to a\n\t * device seeing memory write in different order than CPU.\n\t *\n\t * See Documentation/vm/mmu_notifier.rst\n\t */\n\tpmdp_huge_clear_flush_notify(vma, haddr, vmf->pmd);\n\n\tpgtable = pgtable_trans_huge_withdraw(vma->vm_mm, vmf->pmd);\n\tpmd_populate(vma->vm_mm, &_pmd, pgtable);\n\n\tfor (i = 0; i < HPAGE_PMD_NR; i++, haddr += PAGE_SIZE) {\n\t\tpte_t entry;\n\t\tentry = mk_pte(pages[i], vma->vm_page_prot);\n\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t\tmemcg = (void *)page_private(pages[i]);\n\t\tset_page_private(pages[i], 0);\n\t\tpage_add_new_anon_rmap(pages[i], vmf->vma, haddr, false);\n\t\tmem_cgroup_commit_charge(pages[i], memcg, false, false);\n\t\tlru_cache_add_active_or_unevictable(pages[i], vma);\n\t\tvmf->pte = pte_offset_map(&_pmd, haddr);\n\t\tVM_BUG_ON(!pte_none(*vmf->pte));\n\t\tset_pte_at(vma->vm_mm, haddr, vmf->pte, entry);\n\t\tpte_unmap(vmf->pte);\n\t}\n\tkfree(pages);\n\n\tsmp_wmb(); /* make pte visible before pmd */\n\tpmd_populate(vma->vm_mm, vmf->pmd, pgtable);\n\tpage_remove_rmap(page, true);\n\tspin_unlock(vmf->ptl);\n\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback as\n\t * the above pmdp_huge_clear_flush_notify() did already call it.\n\t */\n\tmmu_notifier_invalidate_range_only_end(vma->vm_mm, mmun_start,\n\t\t\t\t\t\tmmun_end);\n\n\tret |= VM_FAULT_WRITE;\n\tput_page(page);\n\nout:\n\treturn ret;\n\nout_free_pages:\n\tspin_unlock(vmf->ptl);\n\tmmu_notifier_invalidate_range_end(vma->vm_mm, mmun_start, mmun_end);\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tmemcg = (void *)page_private(pages[i]);\n\t\tset_page_private(pages[i], 0);\n\t\tmem_cgroup_cancel_charge(pages[i], memcg, false);\n\t\tput_page(pages[i]);\n\t}\n\tkfree(pages);\n\tgoto out;\n}"
  },
  {
    "function_name": "huge_pmd_set_accessed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "1115-1134",
    "snippet": "void huge_pmd_set_accessed(struct vm_fault *vmf, pmd_t orig_pmd)\n{\n\tpmd_t entry;\n\tunsigned long haddr;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\n\tvmf->ptl = pmd_lock(vmf->vma->vm_mm, vmf->pmd);\n\tif (unlikely(!pmd_same(*vmf->pmd, orig_pmd)))\n\t\tgoto unlock;\n\n\tentry = pmd_mkyoung(orig_pmd);\n\tif (write)\n\t\tentry = pmd_mkdirty(entry);\n\thaddr = vmf->address & HPAGE_PMD_MASK;\n\tif (pmdp_set_access_flags(vmf->vma, haddr, vmf->pmd, entry, write))\n\t\tupdate_mmu_cache_pmd(vmf->vma, vmf->address, vmf->pmd);\n\nunlock:\n\tspin_unlock(vmf->ptl);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "vmf->ptl"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_mmu_cache_pmd",
          "args": [
            "vmf->vma",
            "vmf->address",
            "vmf->pmd"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmdp_set_access_flags",
          "args": [
            "vmf->vma",
            "haddr",
            "vmf->pmd",
            "entry",
            "write"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "pmdp_set_access_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "96-107",
          "snippet": "int pmdp_set_access_flags(struct vm_area_struct *vma,\n\t\t\t  unsigned long address, pmd_t *pmdp,\n\t\t\t  pmd_t entry, int dirty)\n{\n\tint changed = !pmd_same(*pmdp, entry);\n\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);\n\tif (changed) {\n\t\tset_pmd_at(vma->vm_mm, address, pmdp, entry);\n\t\tflush_pmd_tlb_range(vma, address, address + HPAGE_PMD_SIZE);\n\t}\n\treturn changed;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\nint pmdp_set_access_flags(struct vm_area_struct *vma,\n\t\t\t  unsigned long address, pmd_t *pmdp,\n\t\t\t  pmd_t entry, int dirty)\n{\n\tint changed = !pmd_same(*pmdp, entry);\n\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);\n\tif (changed) {\n\t\tset_pmd_at(vma->vm_mm, address, pmdp, entry);\n\t\tflush_pmd_tlb_range(vma, address, address + HPAGE_PMD_SIZE);\n\t}\n\treturn changed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_mkdirty",
          "args": [
            "entry"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_mkyoung",
          "args": [
            "orig_pmd"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pmd_same(*vmf->pmd, orig_pmd)"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_same",
          "args": [
            "*vmf->pmd",
            "orig_pmd"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_lock",
          "args": [
            "vmf->vma->vm_mm",
            "vmf->pmd"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid huge_pmd_set_accessed(struct vm_fault *vmf, pmd_t orig_pmd)\n{\n\tpmd_t entry;\n\tunsigned long haddr;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\n\tvmf->ptl = pmd_lock(vmf->vma->vm_mm, vmf->pmd);\n\tif (unlikely(!pmd_same(*vmf->pmd, orig_pmd)))\n\t\tgoto unlock;\n\n\tentry = pmd_mkyoung(orig_pmd);\n\tif (write)\n\t\tentry = pmd_mkdirty(entry);\n\thaddr = vmf->address & HPAGE_PMD_MASK;\n\tif (pmdp_set_access_flags(vmf->vma, haddr, vmf->pmd, entry, write))\n\t\tupdate_mmu_cache_pmd(vmf->vma, vmf->address, vmf->pmd);\n\nunlock:\n\tspin_unlock(vmf->ptl);\n}"
  },
  {
    "function_name": "huge_pud_set_accessed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "1093-1112",
    "snippet": "void huge_pud_set_accessed(struct vm_fault *vmf, pud_t orig_pud)\n{\n\tpud_t entry;\n\tunsigned long haddr;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\n\tvmf->ptl = pud_lock(vmf->vma->vm_mm, vmf->pud);\n\tif (unlikely(!pud_same(*vmf->pud, orig_pud)))\n\t\tgoto unlock;\n\n\tentry = pud_mkyoung(orig_pud);\n\tif (write)\n\t\tentry = pud_mkdirty(entry);\n\thaddr = vmf->address & HPAGE_PUD_MASK;\n\tif (pudp_set_access_flags(vmf->vma, haddr, vmf->pud, entry, write))\n\t\tupdate_mmu_cache_pud(vmf->vma, vmf->address, vmf->pud);\n\nunlock:\n\tspin_unlock(vmf->ptl);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "vmf->ptl"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_mmu_cache_pud",
          "args": [
            "vmf->vma",
            "vmf->address",
            "vmf->pud"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pudp_set_access_flags",
          "args": [
            "vmf->vma",
            "haddr",
            "vmf->pud",
            "entry",
            "write"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_mkdirty",
          "args": [
            "entry"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_mkyoung",
          "args": [
            "orig_pud"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pud_same(*vmf->pud, orig_pud)"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_same",
          "args": [
            "*vmf->pud",
            "orig_pud"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_lock",
          "args": [
            "vmf->vma->vm_mm",
            "vmf->pud"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid huge_pud_set_accessed(struct vm_fault *vmf, pud_t orig_pud)\n{\n\tpud_t entry;\n\tunsigned long haddr;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\n\tvmf->ptl = pud_lock(vmf->vma->vm_mm, vmf->pud);\n\tif (unlikely(!pud_same(*vmf->pud, orig_pud)))\n\t\tgoto unlock;\n\n\tentry = pud_mkyoung(orig_pud);\n\tif (write)\n\t\tentry = pud_mkdirty(entry);\n\thaddr = vmf->address & HPAGE_PUD_MASK;\n\tif (pudp_set_access_flags(vmf->vma, haddr, vmf->pud, entry, write))\n\t\tupdate_mmu_cache_pud(vmf->vma, vmf->address, vmf->pud);\n\nunlock:\n\tspin_unlock(vmf->ptl);\n}"
  },
  {
    "function_name": "copy_huge_pud",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "1056-1091",
    "snippet": "int copy_huge_pud(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\t  pud_t *dst_pud, pud_t *src_pud, unsigned long addr,\n\t\t  struct vm_area_struct *vma)\n{\n\tspinlock_t *dst_ptl, *src_ptl;\n\tpud_t pud;\n\tint ret;\n\n\tdst_ptl = pud_lock(dst_mm, dst_pud);\n\tsrc_ptl = pud_lockptr(src_mm, src_pud);\n\tspin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);\n\n\tret = -EAGAIN;\n\tpud = *src_pud;\n\tif (unlikely(!pud_trans_huge(pud) && !pud_devmap(pud)))\n\t\tgoto out_unlock;\n\n\t/*\n\t * When page table lock is held, the huge zero pud should not be\n\t * under splitting since we don't split the page itself, only pud to\n\t * a page table.\n\t */\n\tif (is_huge_zero_pud(pud)) {\n\t\t/* No huge zero pud yet */\n\t}\n\n\tpudp_set_wrprotect(src_mm, addr, src_pud);\n\tpud = pud_mkold(pud_wrprotect(pud));\n\tset_pud_at(dst_mm, addr, dst_pud, pud);\n\n\tret = 0;\nout_unlock:\n\tspin_unlock(src_ptl);\n\tspin_unlock(dst_ptl);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "dst_ptl"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "src_ptl"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pud_at",
          "args": [
            "dst_mm",
            "addr",
            "dst_pud",
            "pud"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_mkold",
          "args": [
            "pud_wrprotect(pud)"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_wrprotect",
          "args": [
            "pud"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pudp_set_wrprotect",
          "args": [
            "src_mm",
            "addr",
            "src_pud"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_huge_zero_pud",
          "args": [
            "pud"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pud_trans_huge(pud) && !pud_devmap(pud)"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_devmap",
          "args": [
            "pud"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_trans_huge",
          "args": [
            "pud"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "src_ptl",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_lockptr",
          "args": [
            "src_mm",
            "src_pud"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_lock",
          "args": [
            "dst_mm",
            "dst_pud"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint copy_huge_pud(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\t  pud_t *dst_pud, pud_t *src_pud, unsigned long addr,\n\t\t  struct vm_area_struct *vma)\n{\n\tspinlock_t *dst_ptl, *src_ptl;\n\tpud_t pud;\n\tint ret;\n\n\tdst_ptl = pud_lock(dst_mm, dst_pud);\n\tsrc_ptl = pud_lockptr(src_mm, src_pud);\n\tspin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);\n\n\tret = -EAGAIN;\n\tpud = *src_pud;\n\tif (unlikely(!pud_trans_huge(pud) && !pud_devmap(pud)))\n\t\tgoto out_unlock;\n\n\t/*\n\t * When page table lock is held, the huge zero pud should not be\n\t * under splitting since we don't split the page itself, only pud to\n\t * a page table.\n\t */\n\tif (is_huge_zero_pud(pud)) {\n\t\t/* No huge zero pud yet */\n\t}\n\n\tpudp_set_wrprotect(src_mm, addr, src_pud);\n\tpud = pud_mkold(pud_wrprotect(pud));\n\tset_pud_at(dst_mm, addr, dst_pud, pud);\n\n\tret = 0;\nout_unlock:\n\tspin_unlock(src_ptl);\n\tspin_unlock(dst_ptl);\n\treturn ret;\n}"
  },
  {
    "function_name": "follow_devmap_pud",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "1019-1054",
    "snippet": "struct page *follow_devmap_pud(struct vm_area_struct *vma, unsigned long addr,\n\t\tpud_t *pud, int flags, struct dev_pagemap **pgmap)\n{\n\tunsigned long pfn = pud_pfn(*pud);\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page;\n\n\tassert_spin_locked(pud_lockptr(mm, pud));\n\n\tif (flags & FOLL_WRITE && !pud_write(*pud))\n\t\treturn NULL;\n\n\tif (pud_present(*pud) && pud_devmap(*pud))\n\t\t/* pass */;\n\telse\n\t\treturn NULL;\n\n\tif (flags & FOLL_TOUCH)\n\t\ttouch_pud(vma, addr, pud, flags);\n\n\t/*\n\t * device mapped pages can only be returned if the\n\t * caller will manage the page reference count.\n\t */\n\tif (!(flags & FOLL_GET))\n\t\treturn ERR_PTR(-EEXIST);\n\n\tpfn += (addr & ~PUD_MASK) >> PAGE_SHIFT;\n\t*pgmap = get_dev_pagemap(pfn, *pgmap);\n\tif (!*pgmap)\n\t\treturn ERR_PTR(-EFAULT);\n\tpage = pfn_to_page(pfn);\n\tget_page(page);\n\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EFAULT"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dev_pagemap",
          "args": [
            "pfn",
            "*pgmap"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EEXIST"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "touch_pud",
          "args": [
            "vma",
            "addr",
            "pud",
            "flags"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "touch_pud",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1006-1017",
          "snippet": "static void touch_pud(struct vm_area_struct *vma, unsigned long addr,\n\t\tpud_t *pud, int flags)\n{\n\tpud_t _pud;\n\n\t_pud = pud_mkyoung(*pud);\n\tif (flags & FOLL_WRITE)\n\t\t_pud = pud_mkdirty(_pud);\n\tif (pudp_set_access_flags(vma, addr & HPAGE_PUD_MASK,\n\t\t\t\tpud, _pud, flags & FOLL_WRITE))\n\t\tupdate_mmu_cache_pud(vma, addr, pud);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void touch_pud(struct vm_area_struct *vma, unsigned long addr,\n\t\tpud_t *pud, int flags)\n{\n\tpud_t _pud;\n\n\t_pud = pud_mkyoung(*pud);\n\tif (flags & FOLL_WRITE)\n\t\t_pud = pud_mkdirty(_pud);\n\tif (pudp_set_access_flags(vma, addr & HPAGE_PUD_MASK,\n\t\t\t\tpud, _pud, flags & FOLL_WRITE))\n\t\tupdate_mmu_cache_pud(vma, addr, pud);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pud_devmap",
          "args": [
            "*pud"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_present",
          "args": [
            "*pud"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_write",
          "args": [
            "*pud"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "pud_lockptr(mm, pud)"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_lockptr",
          "args": [
            "mm",
            "pud"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_pfn",
          "args": [
            "*pud"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstruct page *follow_devmap_pud(struct vm_area_struct *vma, unsigned long addr,\n\t\tpud_t *pud, int flags, struct dev_pagemap **pgmap)\n{\n\tunsigned long pfn = pud_pfn(*pud);\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page;\n\n\tassert_spin_locked(pud_lockptr(mm, pud));\n\n\tif (flags & FOLL_WRITE && !pud_write(*pud))\n\t\treturn NULL;\n\n\tif (pud_present(*pud) && pud_devmap(*pud))\n\t\t/* pass */;\n\telse\n\t\treturn NULL;\n\n\tif (flags & FOLL_TOUCH)\n\t\ttouch_pud(vma, addr, pud, flags);\n\n\t/*\n\t * device mapped pages can only be returned if the\n\t * caller will manage the page reference count.\n\t */\n\tif (!(flags & FOLL_GET))\n\t\treturn ERR_PTR(-EEXIST);\n\n\tpfn += (addr & ~PUD_MASK) >> PAGE_SHIFT;\n\t*pgmap = get_dev_pagemap(pfn, *pgmap);\n\tif (!*pgmap)\n\t\treturn ERR_PTR(-EFAULT);\n\tpage = pfn_to_page(pfn);\n\tget_page(page);\n\n\treturn page;\n}"
  },
  {
    "function_name": "touch_pud",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "1006-1017",
    "snippet": "static void touch_pud(struct vm_area_struct *vma, unsigned long addr,\n\t\tpud_t *pud, int flags)\n{\n\tpud_t _pud;\n\n\t_pud = pud_mkyoung(*pud);\n\tif (flags & FOLL_WRITE)\n\t\t_pud = pud_mkdirty(_pud);\n\tif (pudp_set_access_flags(vma, addr & HPAGE_PUD_MASK,\n\t\t\t\tpud, _pud, flags & FOLL_WRITE))\n\t\tupdate_mmu_cache_pud(vma, addr, pud);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_mmu_cache_pud",
          "args": [
            "vma",
            "addr",
            "pud"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pudp_set_access_flags",
          "args": [
            "vma",
            "addr & HPAGE_PUD_MASK",
            "pud",
            "_pud",
            "flags & FOLL_WRITE"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_mkdirty",
          "args": [
            "_pud"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_mkyoung",
          "args": [
            "*pud"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void touch_pud(struct vm_area_struct *vma, unsigned long addr,\n\t\tpud_t *pud, int flags)\n{\n\tpud_t _pud;\n\n\t_pud = pud_mkyoung(*pud);\n\tif (flags & FOLL_WRITE)\n\t\t_pud = pud_mkdirty(_pud);\n\tif (pudp_set_access_flags(vma, addr & HPAGE_PUD_MASK,\n\t\t\t\tpud, _pud, flags & FOLL_WRITE))\n\t\tupdate_mmu_cache_pud(vma, addr, pud);\n}"
  },
  {
    "function_name": "copy_huge_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "916-1003",
    "snippet": "int copy_huge_pmd(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\t  pmd_t *dst_pmd, pmd_t *src_pmd, unsigned long addr,\n\t\t  struct vm_area_struct *vma)\n{\n\tspinlock_t *dst_ptl, *src_ptl;\n\tstruct page *src_page;\n\tpmd_t pmd;\n\tpgtable_t pgtable = NULL;\n\tint ret = -ENOMEM;\n\n\t/* Skip if can be re-fill on fault */\n\tif (!vma_is_anonymous(vma))\n\t\treturn 0;\n\n\tpgtable = pte_alloc_one(dst_mm, addr);\n\tif (unlikely(!pgtable))\n\t\tgoto out;\n\n\tdst_ptl = pmd_lock(dst_mm, dst_pmd);\n\tsrc_ptl = pmd_lockptr(src_mm, src_pmd);\n\tspin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);\n\n\tret = -EAGAIN;\n\tpmd = *src_pmd;\n\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\n\tif (unlikely(is_swap_pmd(pmd))) {\n\t\tswp_entry_t entry = pmd_to_swp_entry(pmd);\n\n\t\tVM_BUG_ON(!is_pmd_migration_entry(pmd));\n\t\tif (is_write_migration_entry(entry)) {\n\t\t\tmake_migration_entry_read(&entry);\n\t\t\tpmd = swp_entry_to_pmd(entry);\n\t\t\tif (pmd_swp_soft_dirty(*src_pmd))\n\t\t\t\tpmd = pmd_swp_mksoft_dirty(pmd);\n\t\t\tset_pmd_at(src_mm, addr, src_pmd, pmd);\n\t\t}\n\t\tadd_mm_counter(dst_mm, MM_ANONPAGES, HPAGE_PMD_NR);\n\t\tmm_inc_nr_ptes(dst_mm);\n\t\tpgtable_trans_huge_deposit(dst_mm, dst_pmd, pgtable);\n\t\tset_pmd_at(dst_mm, addr, dst_pmd, pmd);\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n#endif\n\n\tif (unlikely(!pmd_trans_huge(pmd))) {\n\t\tpte_free(dst_mm, pgtable);\n\t\tgoto out_unlock;\n\t}\n\t/*\n\t * When page table lock is held, the huge zero pmd should not be\n\t * under splitting since we don't split the page itself, only pmd to\n\t * a page table.\n\t */\n\tif (is_huge_zero_pmd(pmd)) {\n\t\tstruct page *zero_page;\n\t\t/*\n\t\t * get_huge_zero_page() will never allocate a new page here,\n\t\t * since we already have a zero page to copy. It just takes a\n\t\t * reference.\n\t\t */\n\t\tzero_page = mm_get_huge_zero_page(dst_mm);\n\t\tset_huge_zero_page(pgtable, dst_mm, vma, addr, dst_pmd,\n\t\t\t\tzero_page);\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tsrc_page = pmd_page(pmd);\n\tVM_BUG_ON_PAGE(!PageHead(src_page), src_page);\n\tget_page(src_page);\n\tpage_dup_rmap(src_page, true);\n\tadd_mm_counter(dst_mm, MM_ANONPAGES, HPAGE_PMD_NR);\n\tmm_inc_nr_ptes(dst_mm);\n\tpgtable_trans_huge_deposit(dst_mm, dst_pmd, pgtable);\n\n\tpmdp_set_wrprotect(src_mm, addr, src_pmd);\n\tpmd = pmd_mkold(pmd_wrprotect(pmd));\n\tset_pmd_at(dst_mm, addr, dst_pmd, pmd);\n\n\tret = 0;\nout_unlock:\n\tspin_unlock(src_ptl);\n\tspin_unlock(dst_ptl);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "dst_ptl"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "src_ptl"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pmd_at",
          "args": [
            "dst_mm",
            "addr",
            "dst_pmd",
            "pmd"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_mkold",
          "args": [
            "pmd_wrprotect(pmd)"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_wrprotect",
          "args": [
            "pmd"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmdp_set_wrprotect",
          "args": [
            "src_mm",
            "addr",
            "src_pmd"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgtable_trans_huge_deposit",
          "args": [
            "dst_mm",
            "dst_pmd",
            "pgtable"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "pgtable_trans_huge_deposit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "152-163",
          "snippet": "void pgtable_trans_huge_deposit(struct mm_struct *mm, pmd_t *pmdp,\n\t\t\t\tpgtable_t pgtable)\n{\n\tassert_spin_locked(pmd_lockptr(mm, pmdp));\n\n\t/* FIFO */\n\tif (!pmd_huge_pte(mm, pmdp))\n\t\tINIT_LIST_HEAD(&pgtable->lru);\n\telse\n\t\tlist_add(&pgtable->lru, &pmd_huge_pte(mm, pmdp)->lru);\n\tpmd_huge_pte(mm, pmdp) = pgtable;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\nvoid pgtable_trans_huge_deposit(struct mm_struct *mm, pmd_t *pmdp,\n\t\t\t\tpgtable_t pgtable)\n{\n\tassert_spin_locked(pmd_lockptr(mm, pmdp));\n\n\t/* FIFO */\n\tif (!pmd_huge_pte(mm, pmdp))\n\t\tINIT_LIST_HEAD(&pgtable->lru);\n\telse\n\t\tlist_add(&pgtable->lru, &pmd_huge_pte(mm, pmdp)->lru);\n\tpmd_huge_pte(mm, pmdp) = pgtable;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_inc_nr_ptes",
          "args": [
            "dst_mm"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_mm_counter",
          "args": [
            "dst_mm",
            "MM_ANONPAGES",
            "HPAGE_PMD_NR"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "add_mm_counter_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "157-165",
          "snippet": "static void add_mm_counter_fast(struct mm_struct *mm, int member, int val)\n{\n\tstruct task_struct *task = current;\n\n\tif (likely(task->mm == mm))\n\t\ttask->rss_stat.count[member] += val;\n\telse\n\t\tadd_mm_counter(mm, member, val);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void add_mm_counter_fast(struct mm_struct *mm, int member, int val)\n{\n\tstruct task_struct *task = current;\n\n\tif (likely(task->mm == mm))\n\t\ttask->rss_stat.count[member] += val;\n\telse\n\t\tadd_mm_counter(mm, member, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_dup_rmap",
          "args": [
            "src_page",
            "true"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "src_page"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageHead(src_page)",
            "src_page"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHead",
          "args": [
            "src_page"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "PageHeadHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1350-1356",
          "snippet": "int PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_page",
          "args": [
            "pmd"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_huge_zero_page",
          "args": [
            "pgtable",
            "dst_mm",
            "vma",
            "addr",
            "dst_pmd",
            "zero_page"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "set_huge_zero_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "669-683",
          "snippet": "static bool set_huge_zero_page(pgtable_t pgtable, struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, unsigned long haddr, pmd_t *pmd,\n\t\tstruct page *zero_page)\n{\n\tpmd_t entry;\n\tif (!pmd_none(*pmd))\n\t\treturn false;\n\tentry = mk_pmd(zero_page, vma->vm_page_prot);\n\tentry = pmd_mkhuge(entry);\n\tif (pgtable)\n\t\tpgtable_trans_huge_deposit(mm, pmd, pgtable);\n\tset_pmd_at(mm, haddr, pmd, entry);\n\tmm_inc_nr_ptes(mm);\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic bool set_huge_zero_page(pgtable_t pgtable, struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, unsigned long haddr, pmd_t *pmd,\n\t\tstruct page *zero_page)\n{\n\tpmd_t entry;\n\tif (!pmd_none(*pmd))\n\t\treturn false;\n\tentry = mk_pmd(zero_page, vma->vm_page_prot);\n\tentry = pmd_mkhuge(entry);\n\tif (pgtable)\n\t\tpgtable_trans_huge_deposit(mm, pmd, pgtable);\n\tset_pmd_at(mm, haddr, pmd, entry);\n\tmm_inc_nr_ptes(mm);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_get_huge_zero_page",
          "args": [
            "dst_mm"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "mm_get_huge_zero_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "101-113",
          "snippet": "struct page *mm_get_huge_zero_page(struct mm_struct *mm)\n{\n\tif (test_bit(MMF_HUGE_ZERO_PAGE, &mm->flags))\n\t\treturn READ_ONCE(huge_zero_page);\n\n\tif (!get_huge_zero_page())\n\t\treturn NULL;\n\n\tif (test_and_set_bit(MMF_HUGE_ZERO_PAGE, &mm->flags))\n\t\tput_huge_zero_page();\n\n\treturn READ_ONCE(huge_zero_page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct page *huge_zero_page"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstruct page *huge_zero_page;\n\nstruct page *mm_get_huge_zero_page(struct mm_struct *mm)\n{\n\tif (test_bit(MMF_HUGE_ZERO_PAGE, &mm->flags))\n\t\treturn READ_ONCE(huge_zero_page);\n\n\tif (!get_huge_zero_page())\n\t\treturn NULL;\n\n\tif (test_and_set_bit(MMF_HUGE_ZERO_PAGE, &mm->flags))\n\t\tput_huge_zero_page();\n\n\treturn READ_ONCE(huge_zero_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_huge_zero_pmd",
          "args": [
            "pmd"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_free",
          "args": [
            "dst_mm",
            "pgtable"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pmd_trans_huge(pmd)"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "pmd"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pmd_at",
          "args": [
            "dst_mm",
            "addr",
            "dst_pmd",
            "pmd"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_inc_nr_ptes",
          "args": [
            "dst_mm"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pmd_at",
          "args": [
            "src_mm",
            "addr",
            "src_pmd",
            "pmd"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_swp_mksoft_dirty",
          "args": [
            "pmd"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_swp_soft_dirty",
          "args": [
            "*src_pmd"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_entry_to_pmd",
          "args": [
            "entry"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_migration_entry_read",
          "args": [
            "&entry"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_write_migration_entry",
          "args": [
            "entry"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!is_pmd_migration_entry(pmd)"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_pmd_migration_entry",
          "args": [
            "pmd"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_to_swp_entry",
          "args": [
            "pmd"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_swap_pmd(pmd)"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swap_pmd",
          "args": [
            "pmd"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "src_ptl",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_lockptr",
          "args": [
            "src_mm",
            "src_pmd"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_lock",
          "args": [
            "dst_mm",
            "dst_pmd"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pgtable"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_alloc_one",
          "args": [
            "dst_mm",
            "addr"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_is_anonymous",
          "args": [
            "vma"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint copy_huge_pmd(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\t  pmd_t *dst_pmd, pmd_t *src_pmd, unsigned long addr,\n\t\t  struct vm_area_struct *vma)\n{\n\tspinlock_t *dst_ptl, *src_ptl;\n\tstruct page *src_page;\n\tpmd_t pmd;\n\tpgtable_t pgtable = NULL;\n\tint ret = -ENOMEM;\n\n\t/* Skip if can be re-fill on fault */\n\tif (!vma_is_anonymous(vma))\n\t\treturn 0;\n\n\tpgtable = pte_alloc_one(dst_mm, addr);\n\tif (unlikely(!pgtable))\n\t\tgoto out;\n\n\tdst_ptl = pmd_lock(dst_mm, dst_pmd);\n\tsrc_ptl = pmd_lockptr(src_mm, src_pmd);\n\tspin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);\n\n\tret = -EAGAIN;\n\tpmd = *src_pmd;\n\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\n\tif (unlikely(is_swap_pmd(pmd))) {\n\t\tswp_entry_t entry = pmd_to_swp_entry(pmd);\n\n\t\tVM_BUG_ON(!is_pmd_migration_entry(pmd));\n\t\tif (is_write_migration_entry(entry)) {\n\t\t\tmake_migration_entry_read(&entry);\n\t\t\tpmd = swp_entry_to_pmd(entry);\n\t\t\tif (pmd_swp_soft_dirty(*src_pmd))\n\t\t\t\tpmd = pmd_swp_mksoft_dirty(pmd);\n\t\t\tset_pmd_at(src_mm, addr, src_pmd, pmd);\n\t\t}\n\t\tadd_mm_counter(dst_mm, MM_ANONPAGES, HPAGE_PMD_NR);\n\t\tmm_inc_nr_ptes(dst_mm);\n\t\tpgtable_trans_huge_deposit(dst_mm, dst_pmd, pgtable);\n\t\tset_pmd_at(dst_mm, addr, dst_pmd, pmd);\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n#endif\n\n\tif (unlikely(!pmd_trans_huge(pmd))) {\n\t\tpte_free(dst_mm, pgtable);\n\t\tgoto out_unlock;\n\t}\n\t/*\n\t * When page table lock is held, the huge zero pmd should not be\n\t * under splitting since we don't split the page itself, only pmd to\n\t * a page table.\n\t */\n\tif (is_huge_zero_pmd(pmd)) {\n\t\tstruct page *zero_page;\n\t\t/*\n\t\t * get_huge_zero_page() will never allocate a new page here,\n\t\t * since we already have a zero page to copy. It just takes a\n\t\t * reference.\n\t\t */\n\t\tzero_page = mm_get_huge_zero_page(dst_mm);\n\t\tset_huge_zero_page(pgtable, dst_mm, vma, addr, dst_pmd,\n\t\t\t\tzero_page);\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tsrc_page = pmd_page(pmd);\n\tVM_BUG_ON_PAGE(!PageHead(src_page), src_page);\n\tget_page(src_page);\n\tpage_dup_rmap(src_page, true);\n\tadd_mm_counter(dst_mm, MM_ANONPAGES, HPAGE_PMD_NR);\n\tmm_inc_nr_ptes(dst_mm);\n\tpgtable_trans_huge_deposit(dst_mm, dst_pmd, pgtable);\n\n\tpmdp_set_wrprotect(src_mm, addr, src_pmd);\n\tpmd = pmd_mkold(pmd_wrprotect(pmd));\n\tset_pmd_at(dst_mm, addr, dst_pmd, pmd);\n\n\tret = 0;\nout_unlock:\n\tspin_unlock(src_ptl);\n\tspin_unlock(dst_ptl);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "follow_devmap_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "873-914",
    "snippet": "struct page *follow_devmap_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\tpmd_t *pmd, int flags, struct dev_pagemap **pgmap)\n{\n\tunsigned long pfn = pmd_pfn(*pmd);\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page;\n\n\tassert_spin_locked(pmd_lockptr(mm, pmd));\n\n\t/*\n\t * When we COW a devmap PMD entry, we split it into PTEs, so we should\n\t * not be in this function with `flags & FOLL_COW` set.\n\t */\n\tWARN_ONCE(flags & FOLL_COW, \"mm: In follow_devmap_pmd with FOLL_COW set\");\n\n\tif (flags & FOLL_WRITE && !pmd_write(*pmd))\n\t\treturn NULL;\n\n\tif (pmd_present(*pmd) && pmd_devmap(*pmd))\n\t\t/* pass */;\n\telse\n\t\treturn NULL;\n\n\tif (flags & FOLL_TOUCH)\n\t\ttouch_pmd(vma, addr, pmd, flags);\n\n\t/*\n\t * device mapped pages can only be returned if the\n\t * caller will manage the page reference count.\n\t */\n\tif (!(flags & FOLL_GET))\n\t\treturn ERR_PTR(-EEXIST);\n\n\tpfn += (addr & ~PMD_MASK) >> PAGE_SHIFT;\n\t*pgmap = get_dev_pagemap(pfn, *pgmap);\n\tif (!*pgmap)\n\t\treturn ERR_PTR(-EFAULT);\n\tpage = pfn_to_page(pfn);\n\tget_page(page);\n\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EFAULT"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dev_pagemap",
          "args": [
            "pfn",
            "*pgmap"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EEXIST"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "touch_pmd",
          "args": [
            "vma",
            "addr",
            "pmd",
            "flags"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "touch_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "860-871",
          "snippet": "static void touch_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\tpmd_t *pmd, int flags)\n{\n\tpmd_t _pmd;\n\n\t_pmd = pmd_mkyoung(*pmd);\n\tif (flags & FOLL_WRITE)\n\t\t_pmd = pmd_mkdirty(_pmd);\n\tif (pmdp_set_access_flags(vma, addr & HPAGE_PMD_MASK,\n\t\t\t\tpmd, _pmd, flags & FOLL_WRITE))\n\t\tupdate_mmu_cache_pmd(vma, addr, pmd);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void touch_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\tpmd_t *pmd, int flags)\n{\n\tpmd_t _pmd;\n\n\t_pmd = pmd_mkyoung(*pmd);\n\tif (flags & FOLL_WRITE)\n\t\t_pmd = pmd_mkdirty(_pmd);\n\tif (pmdp_set_access_flags(vma, addr & HPAGE_PMD_MASK,\n\t\t\t\tpmd, _pmd, flags & FOLL_WRITE))\n\t\tupdate_mmu_cache_pmd(vma, addr, pmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_devmap",
          "args": [
            "*pmd"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "pmd_devmap_trans_unstable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3023-3026",
          "snippet": "static int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_present",
          "args": [
            "*pmd"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_write",
          "args": [
            "*pmd"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "flags & FOLL_COW",
            "\"mm: In follow_devmap_pmd with FOLL_COW set\""
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "pmd_lockptr(mm, pmd)"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_lockptr",
          "args": [
            "mm",
            "pmd"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_pfn",
          "args": [
            "*pmd"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstruct page *follow_devmap_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\tpmd_t *pmd, int flags, struct dev_pagemap **pgmap)\n{\n\tunsigned long pfn = pmd_pfn(*pmd);\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct page *page;\n\n\tassert_spin_locked(pmd_lockptr(mm, pmd));\n\n\t/*\n\t * When we COW a devmap PMD entry, we split it into PTEs, so we should\n\t * not be in this function with `flags & FOLL_COW` set.\n\t */\n\tWARN_ONCE(flags & FOLL_COW, \"mm: In follow_devmap_pmd with FOLL_COW set\");\n\n\tif (flags & FOLL_WRITE && !pmd_write(*pmd))\n\t\treturn NULL;\n\n\tif (pmd_present(*pmd) && pmd_devmap(*pmd))\n\t\t/* pass */;\n\telse\n\t\treturn NULL;\n\n\tif (flags & FOLL_TOUCH)\n\t\ttouch_pmd(vma, addr, pmd, flags);\n\n\t/*\n\t * device mapped pages can only be returned if the\n\t * caller will manage the page reference count.\n\t */\n\tif (!(flags & FOLL_GET))\n\t\treturn ERR_PTR(-EEXIST);\n\n\tpfn += (addr & ~PMD_MASK) >> PAGE_SHIFT;\n\t*pgmap = get_dev_pagemap(pfn, *pgmap);\n\tif (!*pgmap)\n\t\treturn ERR_PTR(-EFAULT);\n\tpage = pfn_to_page(pfn);\n\tget_page(page);\n\n\treturn page;\n}"
  },
  {
    "function_name": "touch_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "860-871",
    "snippet": "static void touch_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\tpmd_t *pmd, int flags)\n{\n\tpmd_t _pmd;\n\n\t_pmd = pmd_mkyoung(*pmd);\n\tif (flags & FOLL_WRITE)\n\t\t_pmd = pmd_mkdirty(_pmd);\n\tif (pmdp_set_access_flags(vma, addr & HPAGE_PMD_MASK,\n\t\t\t\tpmd, _pmd, flags & FOLL_WRITE))\n\t\tupdate_mmu_cache_pmd(vma, addr, pmd);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_mmu_cache_pmd",
          "args": [
            "vma",
            "addr",
            "pmd"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmdp_set_access_flags",
          "args": [
            "vma",
            "addr & HPAGE_PMD_MASK",
            "pmd",
            "_pmd",
            "flags & FOLL_WRITE"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "pmdp_set_access_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "96-107",
          "snippet": "int pmdp_set_access_flags(struct vm_area_struct *vma,\n\t\t\t  unsigned long address, pmd_t *pmdp,\n\t\t\t  pmd_t entry, int dirty)\n{\n\tint changed = !pmd_same(*pmdp, entry);\n\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);\n\tif (changed) {\n\t\tset_pmd_at(vma->vm_mm, address, pmdp, entry);\n\t\tflush_pmd_tlb_range(vma, address, address + HPAGE_PMD_SIZE);\n\t}\n\treturn changed;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\nint pmdp_set_access_flags(struct vm_area_struct *vma,\n\t\t\t  unsigned long address, pmd_t *pmdp,\n\t\t\t  pmd_t entry, int dirty)\n{\n\tint changed = !pmd_same(*pmdp, entry);\n\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);\n\tif (changed) {\n\t\tset_pmd_at(vma->vm_mm, address, pmdp, entry);\n\t\tflush_pmd_tlb_range(vma, address, address + HPAGE_PMD_SIZE);\n\t}\n\treturn changed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_mkdirty",
          "args": [
            "_pmd"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_mkyoung",
          "args": [
            "*pmd"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void touch_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\tpmd_t *pmd, int flags)\n{\n\tpmd_t _pmd;\n\n\t_pmd = pmd_mkyoung(*pmd);\n\tif (flags & FOLL_WRITE)\n\t\t_pmd = pmd_mkdirty(_pmd);\n\tif (pmdp_set_access_flags(vma, addr & HPAGE_PMD_MASK,\n\t\t\t\tpmd, _pmd, flags & FOLL_WRITE))\n\t\tupdate_mmu_cache_pmd(vma, addr, pmd);\n}"
  },
  {
    "function_name": "vmf_insert_pfn_pud",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "834-856",
    "snippet": "vm_fault_t vmf_insert_pfn_pud(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tpud_t *pud, pfn_t pfn, bool write)\n{\n\tpgprot_t pgprot = vma->vm_page_prot;\n\t/*\n\t * If we had pud_special, we could avoid all these restrictions,\n\t * but we need to be consistent with PTEs and architectures that\n\t * can't support a 'special' bit.\n\t */\n\tBUG_ON(!(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) &&\n\t\t\t!pfn_t_devmap(pfn));\n\tBUG_ON((vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) ==\n\t\t\t\t\t\t(VM_PFNMAP|VM_MIXEDMAP));\n\tBUG_ON((vma->vm_flags & VM_PFNMAP) && is_cow_mapping(vma->vm_flags));\n\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn VM_FAULT_SIGBUS;\n\n\ttrack_pfn_insert(vma, &pgprot, pfn);\n\n\tinsert_pfn_pud(vma, addr, pud, pfn, pgprot, write);\n\treturn VM_FAULT_NOPAGE;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "insert_pfn_pud",
          "args": [
            "vma",
            "addr",
            "pud",
            "pfn",
            "pgprot",
            "write"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "insert_pfn_pud",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "814-832",
          "snippet": "static void insert_pfn_pud(struct vm_area_struct *vma, unsigned long addr,\n\t\tpud_t *pud, pfn_t pfn, pgprot_t prot, bool write)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpud_t entry;\n\tspinlock_t *ptl;\n\n\tptl = pud_lock(mm, pud);\n\tentry = pud_mkhuge(pfn_t_pud(pfn, prot));\n\tif (pfn_t_devmap(pfn))\n\t\tentry = pud_mkdevmap(entry);\n\tif (write) {\n\t\tentry = pud_mkyoung(pud_mkdirty(entry));\n\t\tentry = maybe_pud_mkwrite(entry, vma);\n\t}\n\tset_pud_at(mm, addr, pud, entry);\n\tupdate_mmu_cache_pud(vma, addr, pud);\n\tspin_unlock(ptl);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void insert_pfn_pud(struct vm_area_struct *vma, unsigned long addr,\n\t\tpud_t *pud, pfn_t pfn, pgprot_t prot, bool write)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpud_t entry;\n\tspinlock_t *ptl;\n\n\tptl = pud_lock(mm, pud);\n\tentry = pud_mkhuge(pfn_t_pud(pfn, prot));\n\tif (pfn_t_devmap(pfn))\n\t\tentry = pud_mkdevmap(entry);\n\tif (write) {\n\t\tentry = pud_mkyoung(pud_mkdirty(entry));\n\t\tentry = maybe_pud_mkwrite(entry, vma);\n\t}\n\tset_pud_at(mm, addr, pud, entry);\n\tupdate_mmu_cache_pud(vma, addr, pud);\n\tspin_unlock(ptl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "track_pfn_insert",
          "args": [
            "vma",
            "&pgprot",
            "pfn"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(vma->vm_flags & VM_PFNMAP) && is_cow_mapping(vma->vm_flags)"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_cow_mapping",
          "args": [
            "vma->vm_flags"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "is_cow_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "247-250",
          "snippet": "static inline bool is_cow_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline bool is_cow_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) ==\n\t\t\t\t\t\t(VM_PFNMAP|VM_MIXEDMAP)"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) &&\n\t\t\t!pfn_t_devmap(pfn)"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_t_devmap",
          "args": [
            "pfn"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvm_fault_t vmf_insert_pfn_pud(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tpud_t *pud, pfn_t pfn, bool write)\n{\n\tpgprot_t pgprot = vma->vm_page_prot;\n\t/*\n\t * If we had pud_special, we could avoid all these restrictions,\n\t * but we need to be consistent with PTEs and architectures that\n\t * can't support a 'special' bit.\n\t */\n\tBUG_ON(!(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) &&\n\t\t\t!pfn_t_devmap(pfn));\n\tBUG_ON((vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) ==\n\t\t\t\t\t\t(VM_PFNMAP|VM_MIXEDMAP));\n\tBUG_ON((vma->vm_flags & VM_PFNMAP) && is_cow_mapping(vma->vm_flags));\n\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn VM_FAULT_SIGBUS;\n\n\ttrack_pfn_insert(vma, &pgprot, pfn);\n\n\tinsert_pfn_pud(vma, addr, pud, pfn, pgprot, write);\n\treturn VM_FAULT_NOPAGE;\n}"
  },
  {
    "function_name": "insert_pfn_pud",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "814-832",
    "snippet": "static void insert_pfn_pud(struct vm_area_struct *vma, unsigned long addr,\n\t\tpud_t *pud, pfn_t pfn, pgprot_t prot, bool write)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpud_t entry;\n\tspinlock_t *ptl;\n\n\tptl = pud_lock(mm, pud);\n\tentry = pud_mkhuge(pfn_t_pud(pfn, prot));\n\tif (pfn_t_devmap(pfn))\n\t\tentry = pud_mkdevmap(entry);\n\tif (write) {\n\t\tentry = pud_mkyoung(pud_mkdirty(entry));\n\t\tentry = maybe_pud_mkwrite(entry, vma);\n\t}\n\tset_pud_at(mm, addr, pud, entry);\n\tupdate_mmu_cache_pud(vma, addr, pud);\n\tspin_unlock(ptl);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_mmu_cache_pud",
          "args": [
            "vma",
            "addr",
            "pud"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pud_at",
          "args": [
            "mm",
            "addr",
            "pud",
            "entry"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "maybe_pud_mkwrite",
          "args": [
            "entry",
            "vma"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_pud_mkwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "807-812",
          "snippet": "static pud_t maybe_pud_mkwrite(pud_t pud, struct vm_area_struct *vma)\n{\n\tif (likely(vma->vm_flags & VM_WRITE))\n\t\tpud = pud_mkwrite(pud);\n\treturn pud;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic pud_t maybe_pud_mkwrite(pud_t pud, struct vm_area_struct *vma)\n{\n\tif (likely(vma->vm_flags & VM_WRITE))\n\t\tpud = pud_mkwrite(pud);\n\treturn pud;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pud_mkyoung",
          "args": [
            "pud_mkdirty(entry)"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_mkdirty",
          "args": [
            "entry"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_mkdevmap",
          "args": [
            "entry"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_t_devmap",
          "args": [
            "pfn"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_mkhuge",
          "args": [
            "pfn_t_pud(pfn, prot)"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_t_pud",
          "args": [
            "pfn",
            "prot"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_lock",
          "args": [
            "mm",
            "pud"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void insert_pfn_pud(struct vm_area_struct *vma, unsigned long addr,\n\t\tpud_t *pud, pfn_t pfn, pgprot_t prot, bool write)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpud_t entry;\n\tspinlock_t *ptl;\n\n\tptl = pud_lock(mm, pud);\n\tentry = pud_mkhuge(pfn_t_pud(pfn, prot));\n\tif (pfn_t_devmap(pfn))\n\t\tentry = pud_mkdevmap(entry);\n\tif (write) {\n\t\tentry = pud_mkyoung(pud_mkdirty(entry));\n\t\tentry = maybe_pud_mkwrite(entry, vma);\n\t}\n\tset_pud_at(mm, addr, pud, entry);\n\tupdate_mmu_cache_pud(vma, addr, pud);\n\tspin_unlock(ptl);\n}"
  },
  {
    "function_name": "maybe_pud_mkwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "807-812",
    "snippet": "static pud_t maybe_pud_mkwrite(pud_t pud, struct vm_area_struct *vma)\n{\n\tif (likely(vma->vm_flags & VM_WRITE))\n\t\tpud = pud_mkwrite(pud);\n\treturn pud;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pud_mkwrite",
          "args": [
            "pud"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "vma->vm_flags & VM_WRITE"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic pud_t maybe_pud_mkwrite(pud_t pud, struct vm_area_struct *vma)\n{\n\tif (likely(vma->vm_flags & VM_WRITE))\n\t\tpud = pud_mkwrite(pud);\n\treturn pud;\n}"
  },
  {
    "function_name": "vmf_insert_pfn_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "774-803",
    "snippet": "vm_fault_t vmf_insert_pfn_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tpmd_t *pmd, pfn_t pfn, bool write)\n{\n\tpgprot_t pgprot = vma->vm_page_prot;\n\tpgtable_t pgtable = NULL;\n\t/*\n\t * If we had pmd_special, we could avoid all these restrictions,\n\t * but we need to be consistent with PTEs and architectures that\n\t * can't support a 'special' bit.\n\t */\n\tBUG_ON(!(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) &&\n\t\t\t!pfn_t_devmap(pfn));\n\tBUG_ON((vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) ==\n\t\t\t\t\t\t(VM_PFNMAP|VM_MIXEDMAP));\n\tBUG_ON((vma->vm_flags & VM_PFNMAP) && is_cow_mapping(vma->vm_flags));\n\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn VM_FAULT_SIGBUS;\n\n\tif (arch_needs_pgtable_deposit()) {\n\t\tpgtable = pte_alloc_one(vma->vm_mm, addr);\n\t\tif (!pgtable)\n\t\t\treturn VM_FAULT_OOM;\n\t}\n\n\ttrack_pfn_insert(vma, &pgprot, pfn);\n\n\tinsert_pfn_pmd(vma, addr, pmd, pfn, pgprot, write, pgtable);\n\treturn VM_FAULT_NOPAGE;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "insert_pfn_pmd",
          "args": [
            "vma",
            "addr",
            "pmd",
            "pfn",
            "pgprot",
            "write",
            "pgtable"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "insert_pfn_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "747-772",
          "snippet": "static void insert_pfn_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\tpmd_t *pmd, pfn_t pfn, pgprot_t prot, bool write,\n\t\tpgtable_t pgtable)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpmd_t entry;\n\tspinlock_t *ptl;\n\n\tptl = pmd_lock(mm, pmd);\n\tentry = pmd_mkhuge(pfn_t_pmd(pfn, prot));\n\tif (pfn_t_devmap(pfn))\n\t\tentry = pmd_mkdevmap(entry);\n\tif (write) {\n\t\tentry = pmd_mkyoung(pmd_mkdirty(entry));\n\t\tentry = maybe_pmd_mkwrite(entry, vma);\n\t}\n\n\tif (pgtable) {\n\t\tpgtable_trans_huge_deposit(mm, pmd, pgtable);\n\t\tmm_inc_nr_ptes(mm);\n\t}\n\n\tset_pmd_at(mm, addr, pmd, entry);\n\tupdate_mmu_cache_pmd(vma, addr, pmd);\n\tspin_unlock(ptl);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void insert_pfn_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\tpmd_t *pmd, pfn_t pfn, pgprot_t prot, bool write,\n\t\tpgtable_t pgtable)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpmd_t entry;\n\tspinlock_t *ptl;\n\n\tptl = pmd_lock(mm, pmd);\n\tentry = pmd_mkhuge(pfn_t_pmd(pfn, prot));\n\tif (pfn_t_devmap(pfn))\n\t\tentry = pmd_mkdevmap(entry);\n\tif (write) {\n\t\tentry = pmd_mkyoung(pmd_mkdirty(entry));\n\t\tentry = maybe_pmd_mkwrite(entry, vma);\n\t}\n\n\tif (pgtable) {\n\t\tpgtable_trans_huge_deposit(mm, pmd, pgtable);\n\t\tmm_inc_nr_ptes(mm);\n\t}\n\n\tset_pmd_at(mm, addr, pmd, entry);\n\tupdate_mmu_cache_pmd(vma, addr, pmd);\n\tspin_unlock(ptl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "track_pfn_insert",
          "args": [
            "vma",
            "&pgprot",
            "pfn"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_alloc_one",
          "args": [
            "vma->vm_mm",
            "addr"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_needs_pgtable_deposit",
          "args": [],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(vma->vm_flags & VM_PFNMAP) && is_cow_mapping(vma->vm_flags)"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_cow_mapping",
          "args": [
            "vma->vm_flags"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "is_cow_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "247-250",
          "snippet": "static inline bool is_cow_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline bool is_cow_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) ==\n\t\t\t\t\t\t(VM_PFNMAP|VM_MIXEDMAP)"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) &&\n\t\t\t!pfn_t_devmap(pfn)"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_t_devmap",
          "args": [
            "pfn"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvm_fault_t vmf_insert_pfn_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tpmd_t *pmd, pfn_t pfn, bool write)\n{\n\tpgprot_t pgprot = vma->vm_page_prot;\n\tpgtable_t pgtable = NULL;\n\t/*\n\t * If we had pmd_special, we could avoid all these restrictions,\n\t * but we need to be consistent with PTEs and architectures that\n\t * can't support a 'special' bit.\n\t */\n\tBUG_ON(!(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) &&\n\t\t\t!pfn_t_devmap(pfn));\n\tBUG_ON((vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) ==\n\t\t\t\t\t\t(VM_PFNMAP|VM_MIXEDMAP));\n\tBUG_ON((vma->vm_flags & VM_PFNMAP) && is_cow_mapping(vma->vm_flags));\n\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn VM_FAULT_SIGBUS;\n\n\tif (arch_needs_pgtable_deposit()) {\n\t\tpgtable = pte_alloc_one(vma->vm_mm, addr);\n\t\tif (!pgtable)\n\t\t\treturn VM_FAULT_OOM;\n\t}\n\n\ttrack_pfn_insert(vma, &pgprot, pfn);\n\n\tinsert_pfn_pmd(vma, addr, pmd, pfn, pgprot, write, pgtable);\n\treturn VM_FAULT_NOPAGE;\n}"
  },
  {
    "function_name": "insert_pfn_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "747-772",
    "snippet": "static void insert_pfn_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\tpmd_t *pmd, pfn_t pfn, pgprot_t prot, bool write,\n\t\tpgtable_t pgtable)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpmd_t entry;\n\tspinlock_t *ptl;\n\n\tptl = pmd_lock(mm, pmd);\n\tentry = pmd_mkhuge(pfn_t_pmd(pfn, prot));\n\tif (pfn_t_devmap(pfn))\n\t\tentry = pmd_mkdevmap(entry);\n\tif (write) {\n\t\tentry = pmd_mkyoung(pmd_mkdirty(entry));\n\t\tentry = maybe_pmd_mkwrite(entry, vma);\n\t}\n\n\tif (pgtable) {\n\t\tpgtable_trans_huge_deposit(mm, pmd, pgtable);\n\t\tmm_inc_nr_ptes(mm);\n\t}\n\n\tset_pmd_at(mm, addr, pmd, entry);\n\tupdate_mmu_cache_pmd(vma, addr, pmd);\n\tspin_unlock(ptl);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_mmu_cache_pmd",
          "args": [
            "vma",
            "addr",
            "pmd"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pmd_at",
          "args": [
            "mm",
            "addr",
            "pmd",
            "entry"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_inc_nr_ptes",
          "args": [
            "mm"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgtable_trans_huge_deposit",
          "args": [
            "mm",
            "pmd",
            "pgtable"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "pgtable_trans_huge_deposit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "152-163",
          "snippet": "void pgtable_trans_huge_deposit(struct mm_struct *mm, pmd_t *pmdp,\n\t\t\t\tpgtable_t pgtable)\n{\n\tassert_spin_locked(pmd_lockptr(mm, pmdp));\n\n\t/* FIFO */\n\tif (!pmd_huge_pte(mm, pmdp))\n\t\tINIT_LIST_HEAD(&pgtable->lru);\n\telse\n\t\tlist_add(&pgtable->lru, &pmd_huge_pte(mm, pmdp)->lru);\n\tpmd_huge_pte(mm, pmdp) = pgtable;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\nvoid pgtable_trans_huge_deposit(struct mm_struct *mm, pmd_t *pmdp,\n\t\t\t\tpgtable_t pgtable)\n{\n\tassert_spin_locked(pmd_lockptr(mm, pmdp));\n\n\t/* FIFO */\n\tif (!pmd_huge_pte(mm, pmdp))\n\t\tINIT_LIST_HEAD(&pgtable->lru);\n\telse\n\t\tlist_add(&pgtable->lru, &pmd_huge_pte(mm, pmdp)->lru);\n\tpmd_huge_pte(mm, pmdp) = pgtable;\n}"
        }
      },
      {
        "call_info": {
          "callee": "maybe_pmd_mkwrite",
          "args": [
            "entry",
            "vma"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_pmd_mkwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "477-482",
          "snippet": "pmd_t maybe_pmd_mkwrite(pmd_t pmd, struct vm_area_struct *vma)\n{\n\tif (likely(vma->vm_flags & VM_WRITE))\n\t\tpmd = pmd_mkwrite(pmd);\n\treturn pmd;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\npmd_t maybe_pmd_mkwrite(pmd_t pmd, struct vm_area_struct *vma)\n{\n\tif (likely(vma->vm_flags & VM_WRITE))\n\t\tpmd = pmd_mkwrite(pmd);\n\treturn pmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_mkyoung",
          "args": [
            "pmd_mkdirty(entry)"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_mkdirty",
          "args": [
            "entry"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_mkdevmap",
          "args": [
            "entry"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_t_devmap",
          "args": [
            "pfn"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_mkhuge",
          "args": [
            "pfn_t_pmd(pfn, prot)"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_t_pmd",
          "args": [
            "pfn",
            "prot"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_lock",
          "args": [
            "mm",
            "pmd"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void insert_pfn_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\tpmd_t *pmd, pfn_t pfn, pgprot_t prot, bool write,\n\t\tpgtable_t pgtable)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpmd_t entry;\n\tspinlock_t *ptl;\n\n\tptl = pmd_lock(mm, pmd);\n\tentry = pmd_mkhuge(pfn_t_pmd(pfn, prot));\n\tif (pfn_t_devmap(pfn))\n\t\tentry = pmd_mkdevmap(entry);\n\tif (write) {\n\t\tentry = pmd_mkyoung(pmd_mkdirty(entry));\n\t\tentry = maybe_pmd_mkwrite(entry, vma);\n\t}\n\n\tif (pgtable) {\n\t\tpgtable_trans_huge_deposit(mm, pmd, pgtable);\n\t\tmm_inc_nr_ptes(mm);\n\t}\n\n\tset_pmd_at(mm, addr, pmd, entry);\n\tupdate_mmu_cache_pmd(vma, addr, pmd);\n\tspin_unlock(ptl);\n}"
  },
  {
    "function_name": "do_huge_pmd_anonymous_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "685-745",
    "snippet": "vm_fault_t do_huge_pmd_anonymous_page(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tgfp_t gfp;\n\tstruct page *page;\n\tunsigned long haddr = vmf->address & HPAGE_PMD_MASK;\n\n\tif (haddr < vma->vm_start || haddr + HPAGE_PMD_SIZE > vma->vm_end)\n\t\treturn VM_FAULT_FALLBACK;\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn VM_FAULT_OOM;\n\tif (unlikely(khugepaged_enter(vma, vma->vm_flags)))\n\t\treturn VM_FAULT_OOM;\n\tif (!(vmf->flags & FAULT_FLAG_WRITE) &&\n\t\t\t!mm_forbids_zeropage(vma->vm_mm) &&\n\t\t\ttransparent_hugepage_use_zero_page()) {\n\t\tpgtable_t pgtable;\n\t\tstruct page *zero_page;\n\t\tbool set;\n\t\tvm_fault_t ret;\n\t\tpgtable = pte_alloc_one(vma->vm_mm, haddr);\n\t\tif (unlikely(!pgtable))\n\t\t\treturn VM_FAULT_OOM;\n\t\tzero_page = mm_get_huge_zero_page(vma->vm_mm);\n\t\tif (unlikely(!zero_page)) {\n\t\t\tpte_free(vma->vm_mm, pgtable);\n\t\t\tcount_vm_event(THP_FAULT_FALLBACK);\n\t\t\treturn VM_FAULT_FALLBACK;\n\t\t}\n\t\tvmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);\n\t\tret = 0;\n\t\tset = false;\n\t\tif (pmd_none(*vmf->pmd)) {\n\t\t\tret = check_stable_address_space(vma->vm_mm);\n\t\t\tif (ret) {\n\t\t\t\tspin_unlock(vmf->ptl);\n\t\t\t} else if (userfaultfd_missing(vma)) {\n\t\t\t\tspin_unlock(vmf->ptl);\n\t\t\t\tret = handle_userfault(vmf, VM_UFFD_MISSING);\n\t\t\t\tVM_BUG_ON(ret & VM_FAULT_FALLBACK);\n\t\t\t} else {\n\t\t\t\tset_huge_zero_page(pgtable, vma->vm_mm, vma,\n\t\t\t\t\t\t   haddr, vmf->pmd, zero_page);\n\t\t\t\tspin_unlock(vmf->ptl);\n\t\t\t\tset = true;\n\t\t\t}\n\t\t} else\n\t\t\tspin_unlock(vmf->ptl);\n\t\tif (!set)\n\t\t\tpte_free(vma->vm_mm, pgtable);\n\t\treturn ret;\n\t}\n\tgfp = alloc_hugepage_direct_gfpmask(vma, haddr);\n\tpage = alloc_pages_vma(gfp, HPAGE_PMD_ORDER, vma, haddr, numa_node_id());\n\tif (unlikely(!page)) {\n\t\tcount_vm_event(THP_FAULT_FALLBACK);\n\t\treturn VM_FAULT_FALLBACK;\n\t}\n\tprep_transhuge_page(page);\n\treturn __do_huge_pmd_anonymous_page(vmf, page, gfp);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__do_huge_pmd_anonymous_page",
          "args": [
            "vmf",
            "page",
            "gfp"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "__do_huge_pmd_anonymous_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "544-621",
          "snippet": "static vm_fault_t __do_huge_pmd_anonymous_page(struct vm_fault *vmf,\n\t\t\tstruct page *page, gfp_t gfp)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct mem_cgroup *memcg;\n\tpgtable_t pgtable;\n\tunsigned long haddr = vmf->address & HPAGE_PMD_MASK;\n\tvm_fault_t ret = 0;\n\n\tVM_BUG_ON_PAGE(!PageCompound(page), page);\n\n\tif (mem_cgroup_try_charge_delay(page, vma->vm_mm, gfp, &memcg, true)) {\n\t\tput_page(page);\n\t\tcount_vm_event(THP_FAULT_FALLBACK);\n\t\treturn VM_FAULT_FALLBACK;\n\t}\n\n\tpgtable = pte_alloc_one(vma->vm_mm, haddr);\n\tif (unlikely(!pgtable)) {\n\t\tret = VM_FAULT_OOM;\n\t\tgoto release;\n\t}\n\n\tclear_huge_page(page, vmf->address, HPAGE_PMD_NR);\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * clear_huge_page writes become visible before the set_pmd_at()\n\t * write.\n\t */\n\t__SetPageUptodate(page);\n\n\tvmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);\n\tif (unlikely(!pmd_none(*vmf->pmd))) {\n\t\tgoto unlock_release;\n\t} else {\n\t\tpmd_t entry;\n\n\t\tret = check_stable_address_space(vma->vm_mm);\n\t\tif (ret)\n\t\t\tgoto unlock_release;\n\n\t\t/* Deliver the page fault to userland */\n\t\tif (userfaultfd_missing(vma)) {\n\t\t\tvm_fault_t ret2;\n\n\t\t\tspin_unlock(vmf->ptl);\n\t\t\tmem_cgroup_cancel_charge(page, memcg, true);\n\t\t\tput_page(page);\n\t\t\tpte_free(vma->vm_mm, pgtable);\n\t\t\tret2 = handle_userfault(vmf, VM_UFFD_MISSING);\n\t\t\tVM_BUG_ON(ret2 & VM_FAULT_FALLBACK);\n\t\t\treturn ret2;\n\t\t}\n\n\t\tentry = mk_huge_pmd(page, vma->vm_page_prot);\n\t\tentry = maybe_pmd_mkwrite(pmd_mkdirty(entry), vma);\n\t\tpage_add_new_anon_rmap(page, vma, haddr, true);\n\t\tmem_cgroup_commit_charge(page, memcg, false, true);\n\t\tlru_cache_add_active_or_unevictable(page, vma);\n\t\tpgtable_trans_huge_deposit(vma->vm_mm, vmf->pmd, pgtable);\n\t\tset_pmd_at(vma->vm_mm, haddr, vmf->pmd, entry);\n\t\tadd_mm_counter(vma->vm_mm, MM_ANONPAGES, HPAGE_PMD_NR);\n\t\tmm_inc_nr_ptes(vma->vm_mm);\n\t\tspin_unlock(vmf->ptl);\n\t\tcount_vm_event(THP_FAULT_ALLOC);\n\t}\n\n\treturn 0;\nunlock_release:\n\tspin_unlock(vmf->ptl);\nrelease:\n\tif (pgtable)\n\t\tpte_free(vma->vm_mm, pgtable);\n\tmem_cgroup_cancel_charge(page, memcg, true);\n\tput_page(page);\n\treturn ret;\n\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic vm_fault_t __do_huge_pmd_anonymous_page(struct vm_fault *vmf,\n\t\t\tstruct page *page, gfp_t gfp)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct mem_cgroup *memcg;\n\tpgtable_t pgtable;\n\tunsigned long haddr = vmf->address & HPAGE_PMD_MASK;\n\tvm_fault_t ret = 0;\n\n\tVM_BUG_ON_PAGE(!PageCompound(page), page);\n\n\tif (mem_cgroup_try_charge_delay(page, vma->vm_mm, gfp, &memcg, true)) {\n\t\tput_page(page);\n\t\tcount_vm_event(THP_FAULT_FALLBACK);\n\t\treturn VM_FAULT_FALLBACK;\n\t}\n\n\tpgtable = pte_alloc_one(vma->vm_mm, haddr);\n\tif (unlikely(!pgtable)) {\n\t\tret = VM_FAULT_OOM;\n\t\tgoto release;\n\t}\n\n\tclear_huge_page(page, vmf->address, HPAGE_PMD_NR);\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * clear_huge_page writes become visible before the set_pmd_at()\n\t * write.\n\t */\n\t__SetPageUptodate(page);\n\n\tvmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);\n\tif (unlikely(!pmd_none(*vmf->pmd))) {\n\t\tgoto unlock_release;\n\t} else {\n\t\tpmd_t entry;\n\n\t\tret = check_stable_address_space(vma->vm_mm);\n\t\tif (ret)\n\t\t\tgoto unlock_release;\n\n\t\t/* Deliver the page fault to userland */\n\t\tif (userfaultfd_missing(vma)) {\n\t\t\tvm_fault_t ret2;\n\n\t\t\tspin_unlock(vmf->ptl);\n\t\t\tmem_cgroup_cancel_charge(page, memcg, true);\n\t\t\tput_page(page);\n\t\t\tpte_free(vma->vm_mm, pgtable);\n\t\t\tret2 = handle_userfault(vmf, VM_UFFD_MISSING);\n\t\t\tVM_BUG_ON(ret2 & VM_FAULT_FALLBACK);\n\t\t\treturn ret2;\n\t\t}\n\n\t\tentry = mk_huge_pmd(page, vma->vm_page_prot);\n\t\tentry = maybe_pmd_mkwrite(pmd_mkdirty(entry), vma);\n\t\tpage_add_new_anon_rmap(page, vma, haddr, true);\n\t\tmem_cgroup_commit_charge(page, memcg, false, true);\n\t\tlru_cache_add_active_or_unevictable(page, vma);\n\t\tpgtable_trans_huge_deposit(vma->vm_mm, vmf->pmd, pgtable);\n\t\tset_pmd_at(vma->vm_mm, haddr, vmf->pmd, entry);\n\t\tadd_mm_counter(vma->vm_mm, MM_ANONPAGES, HPAGE_PMD_NR);\n\t\tmm_inc_nr_ptes(vma->vm_mm);\n\t\tspin_unlock(vmf->ptl);\n\t\tcount_vm_event(THP_FAULT_ALLOC);\n\t}\n\n\treturn 0;\nunlock_release:\n\tspin_unlock(vmf->ptl);\nrelease:\n\tif (pgtable)\n\t\tpte_free(vma->vm_mm, pgtable);\n\tmem_cgroup_cancel_charge(page, memcg, true);\n\tput_page(page);\n\treturn ret;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "prep_transhuge_page",
          "args": [
            "page"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "prep_transhuge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "490-499",
          "snippet": "void prep_transhuge_page(struct page *page)\n{\n\t/*\n\t * we use page->mapping and page->indexlru in second tail page\n\t * as list_head: assuming THP order >= 2\n\t */\n\n\tINIT_LIST_HEAD(page_deferred_list(page));\n\tset_compound_page_dtor(page, TRANSHUGE_PAGE_DTOR);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid prep_transhuge_page(struct page *page)\n{\n\t/*\n\t * we use page->mapping and page->indexlru in second tail page\n\t * as list_head: assuming THP order >= 2\n\t */\n\n\tINIT_LIST_HEAD(page_deferred_list(page));\n\tset_compound_page_dtor(page, TRANSHUGE_PAGE_DTOR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "THP_FAULT_FALLBACK"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages_vma",
          "args": [
            "gfp",
            "HPAGE_PMD_ORDER",
            "vma",
            "haddr",
            "numa_node_id()"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_pages_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2022-2048",
          "snippet": "struct page *\nalloc_pages_vma(gfp_t gfp, int order, struct vm_area_struct *vma,\n\t\tunsigned long addr, int node)\n{\n\tstruct mempolicy *pol;\n\tstruct page *page;\n\tint preferred_nid;\n\tnodemask_t *nmask;\n\n\tpol = get_vma_policy(vma, addr);\n\n\tif (pol->mode == MPOL_INTERLEAVE) {\n\t\tunsigned nid;\n\n\t\tnid = interleave_nid(pol, vma, addr, PAGE_SHIFT + order);\n\t\tmpol_cond_put(pol);\n\t\tpage = alloc_page_interleave(gfp, order, nid);\n\t\tgoto out;\n\t}\n\n\tnmask = policy_nodemask(gfp, pol);\n\tpreferred_nid = policy_node(gfp, pol, node);\n\tpage = __alloc_pages_nodemask(gfp, order, preferred_nid, nmask);\n\tmpol_cond_put(pol);\nout:\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstruct page *\nalloc_pages_vma(gfp_t gfp, int order, struct vm_area_struct *vma,\n\t\tunsigned long addr, int node)\n{\n\tstruct mempolicy *pol;\n\tstruct page *page;\n\tint preferred_nid;\n\tnodemask_t *nmask;\n\n\tpol = get_vma_policy(vma, addr);\n\n\tif (pol->mode == MPOL_INTERLEAVE) {\n\t\tunsigned nid;\n\n\t\tnid = interleave_nid(pol, vma, addr, PAGE_SHIFT + order);\n\t\tmpol_cond_put(pol);\n\t\tpage = alloc_page_interleave(gfp, order, nid);\n\t\tgoto out;\n\t}\n\n\tnmask = policy_nodemask(gfp, pol);\n\tpreferred_nid = policy_node(gfp, pol, node);\n\tpage = __alloc_pages_nodemask(gfp, order, preferred_nid, nmask);\n\tmpol_cond_put(pol);\nout:\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "numa_node_id",
          "args": [],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_hugepage_direct_gfpmask",
          "args": [
            "vma",
            "haddr"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_hugepage_direct_gfpmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "632-666",
          "snippet": "static inline gfp_t alloc_hugepage_direct_gfpmask(struct vm_area_struct *vma, unsigned long addr)\n{\n\tconst bool vma_madvised = !!(vma->vm_flags & VM_HUGEPAGE);\n\tgfp_t this_node = 0;\n\n#ifdef CONFIG_NUMA\n\tstruct mempolicy *pol;\n\t/*\n\t * __GFP_THISNODE is used only when __GFP_DIRECT_RECLAIM is not\n\t * specified, to express a general desire to stay on the current\n\t * node for optimistic allocation attempts. If the defrag mode\n\t * and/or madvise hint requires the direct reclaim then we prefer\n\t * to fallback to other node rather than node reclaim because that\n\t * can lead to excessive reclaim even though there is free memory\n\t * on other nodes. We expect that NUMA preferences are specified\n\t * by memory policies.\n\t */\n\tpol = get_vma_policy(vma, addr);\n\tif (pol->mode != MPOL_BIND)\n\t\tthis_node = __GFP_THISNODE;\n\tmpol_cond_put(pol);\n#endif\n\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE | (vma_madvised ? 0 : __GFP_NORETRY);\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE_LIGHT | __GFP_KSWAPD_RECLAIM | this_node;\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE_LIGHT | (vma_madvised ? __GFP_DIRECT_RECLAIM :\n\t\t\t\t\t\t\t     __GFP_KSWAPD_RECLAIM | this_node);\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE_LIGHT | (vma_madvised ? __GFP_DIRECT_RECLAIM :\n\t\t\t\t\t\t\t     this_node);\n\treturn GFP_TRANSHUGE_LIGHT | this_node;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline gfp_t alloc_hugepage_direct_gfpmask(struct vm_area_struct *vma, unsigned long addr)\n{\n\tconst bool vma_madvised = !!(vma->vm_flags & VM_HUGEPAGE);\n\tgfp_t this_node = 0;\n\n#ifdef CONFIG_NUMA\n\tstruct mempolicy *pol;\n\t/*\n\t * __GFP_THISNODE is used only when __GFP_DIRECT_RECLAIM is not\n\t * specified, to express a general desire to stay on the current\n\t * node for optimistic allocation attempts. If the defrag mode\n\t * and/or madvise hint requires the direct reclaim then we prefer\n\t * to fallback to other node rather than node reclaim because that\n\t * can lead to excessive reclaim even though there is free memory\n\t * on other nodes. We expect that NUMA preferences are specified\n\t * by memory policies.\n\t */\n\tpol = get_vma_policy(vma, addr);\n\tif (pol->mode != MPOL_BIND)\n\t\tthis_node = __GFP_THISNODE;\n\tmpol_cond_put(pol);\n#endif\n\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE | (vma_madvised ? 0 : __GFP_NORETRY);\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE_LIGHT | __GFP_KSWAPD_RECLAIM | this_node;\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE_LIGHT | (vma_madvised ? __GFP_DIRECT_RECLAIM :\n\t\t\t\t\t\t\t     __GFP_KSWAPD_RECLAIM | this_node);\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE_LIGHT | (vma_madvised ? __GFP_DIRECT_RECLAIM :\n\t\t\t\t\t\t\t     this_node);\n\treturn GFP_TRANSHUGE_LIGHT | this_node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_free",
          "args": [
            "vma->vm_mm",
            "pgtable"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "vmf->ptl"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "vmf->ptl"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_huge_zero_page",
          "args": [
            "pgtable",
            "vma->vm_mm",
            "vma",
            "haddr",
            "vmf->pmd",
            "zero_page"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "set_huge_zero_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "669-683",
          "snippet": "static bool set_huge_zero_page(pgtable_t pgtable, struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, unsigned long haddr, pmd_t *pmd,\n\t\tstruct page *zero_page)\n{\n\tpmd_t entry;\n\tif (!pmd_none(*pmd))\n\t\treturn false;\n\tentry = mk_pmd(zero_page, vma->vm_page_prot);\n\tentry = pmd_mkhuge(entry);\n\tif (pgtable)\n\t\tpgtable_trans_huge_deposit(mm, pmd, pgtable);\n\tset_pmd_at(mm, haddr, pmd, entry);\n\tmm_inc_nr_ptes(mm);\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic bool set_huge_zero_page(pgtable_t pgtable, struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, unsigned long haddr, pmd_t *pmd,\n\t\tstruct page *zero_page)\n{\n\tpmd_t entry;\n\tif (!pmd_none(*pmd))\n\t\treturn false;\n\tentry = mk_pmd(zero_page, vma->vm_page_prot);\n\tentry = pmd_mkhuge(entry);\n\tif (pgtable)\n\t\tpgtable_trans_huge_deposit(mm, pmd, pgtable);\n\tset_pmd_at(mm, haddr, pmd, entry);\n\tmm_inc_nr_ptes(mm);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "ret & VM_FAULT_FALLBACK"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_userfault",
          "args": [
            "vmf",
            "VM_UFFD_MISSING"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "vmf->ptl"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userfaultfd_missing",
          "args": [
            "vma"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "vmf->ptl"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stable_address_space",
          "args": [
            "vma->vm_mm"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "*vmf->pmd"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_lock",
          "args": [
            "vma->vm_mm",
            "vmf->pmd"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "THP_FAULT_FALLBACK"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_free",
          "args": [
            "vma->vm_mm",
            "pgtable"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!zero_page"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_get_huge_zero_page",
          "args": [
            "vma->vm_mm"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "mm_get_huge_zero_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "101-113",
          "snippet": "struct page *mm_get_huge_zero_page(struct mm_struct *mm)\n{\n\tif (test_bit(MMF_HUGE_ZERO_PAGE, &mm->flags))\n\t\treturn READ_ONCE(huge_zero_page);\n\n\tif (!get_huge_zero_page())\n\t\treturn NULL;\n\n\tif (test_and_set_bit(MMF_HUGE_ZERO_PAGE, &mm->flags))\n\t\tput_huge_zero_page();\n\n\treturn READ_ONCE(huge_zero_page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct page *huge_zero_page"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstruct page *huge_zero_page;\n\nstruct page *mm_get_huge_zero_page(struct mm_struct *mm)\n{\n\tif (test_bit(MMF_HUGE_ZERO_PAGE, &mm->flags))\n\t\treturn READ_ONCE(huge_zero_page);\n\n\tif (!get_huge_zero_page())\n\t\treturn NULL;\n\n\tif (test_and_set_bit(MMF_HUGE_ZERO_PAGE, &mm->flags))\n\t\tput_huge_zero_page();\n\n\treturn READ_ONCE(huge_zero_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pgtable"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_alloc_one",
          "args": [
            "vma->vm_mm",
            "haddr"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "transparent_hugepage_use_zero_page",
          "args": [],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_forbids_zeropage",
          "args": [
            "vma->vm_mm"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "khugepaged_enter(vma, vma->vm_flags)"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "khugepaged_enter",
          "args": [
            "vma",
            "vma->vm_flags"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_enter_vma_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "453-470",
          "snippet": "int khugepaged_enter_vma_merge(struct vm_area_struct *vma,\n\t\t\t       unsigned long vm_flags)\n{\n\tunsigned long hstart, hend;\n\n\t/*\n\t * khugepaged does not yet work on non-shmem files or special\n\t * mappings. And file-private shmem THP is not supported.\n\t */\n\tif (!hugepage_vma_check(vma, vm_flags))\n\t\treturn 0;\n\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (hstart < hend)\n\t\treturn khugepaged_enter(vma, vm_flags);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint khugepaged_enter_vma_merge(struct vm_area_struct *vma,\n\t\t\t       unsigned long vm_flags)\n{\n\tunsigned long hstart, hend;\n\n\t/*\n\t * khugepaged does not yet work on non-shmem files or special\n\t * mappings. And file-private shmem THP is not supported.\n\t */\n\tif (!hugepage_vma_check(vma, vm_flags))\n\t\treturn 0;\n\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (hstart < hend)\n\t\treturn khugepaged_enter(vma, vm_flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "anon_vma_prepare(vma)"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_prepare",
          "args": [
            "vma"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "__anon_vma_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "175-221",
          "snippet": "int __anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct anon_vma *anon_vma, *allocated;\n\tstruct anon_vma_chain *avc;\n\n\tmight_sleep();\n\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_enomem;\n\n\tanon_vma = find_mergeable_anon_vma(vma);\n\tallocated = NULL;\n\tif (!anon_vma) {\n\t\tanon_vma = anon_vma_alloc();\n\t\tif (unlikely(!anon_vma))\n\t\t\tgoto out_enomem_free_avc;\n\t\tallocated = anon_vma;\n\t}\n\n\tanon_vma_lock_write(anon_vma);\n\t/* page_table_lock to protect against threads */\n\tspin_lock(&mm->page_table_lock);\n\tif (likely(!vma->anon_vma)) {\n\t\tvma->anon_vma = anon_vma;\n\t\tanon_vma_chain_link(vma, avc, anon_vma);\n\t\t/* vma reference or self-parent link for new root */\n\t\tanon_vma->degree++;\n\t\tallocated = NULL;\n\t\tavc = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tanon_vma_unlock_write(anon_vma);\n\n\tif (unlikely(allocated))\n\t\tput_anon_vma(allocated);\n\tif (unlikely(avc))\n\t\tanon_vma_chain_free(avc);\n\n\treturn 0;\n\n out_enomem_free_avc:\n\tanon_vma_chain_free(avc);\n out_enomem:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint __anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct anon_vma *anon_vma, *allocated;\n\tstruct anon_vma_chain *avc;\n\n\tmight_sleep();\n\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_enomem;\n\n\tanon_vma = find_mergeable_anon_vma(vma);\n\tallocated = NULL;\n\tif (!anon_vma) {\n\t\tanon_vma = anon_vma_alloc();\n\t\tif (unlikely(!anon_vma))\n\t\t\tgoto out_enomem_free_avc;\n\t\tallocated = anon_vma;\n\t}\n\n\tanon_vma_lock_write(anon_vma);\n\t/* page_table_lock to protect against threads */\n\tspin_lock(&mm->page_table_lock);\n\tif (likely(!vma->anon_vma)) {\n\t\tvma->anon_vma = anon_vma;\n\t\tanon_vma_chain_link(vma, avc, anon_vma);\n\t\t/* vma reference or self-parent link for new root */\n\t\tanon_vma->degree++;\n\t\tallocated = NULL;\n\t\tavc = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tanon_vma_unlock_write(anon_vma);\n\n\tif (unlikely(allocated))\n\t\tput_anon_vma(allocated);\n\tif (unlikely(avc))\n\t\tanon_vma_chain_free(avc);\n\n\treturn 0;\n\n out_enomem_free_avc:\n\tanon_vma_chain_free(avc);\n out_enomem:\n\treturn -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvm_fault_t do_huge_pmd_anonymous_page(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tgfp_t gfp;\n\tstruct page *page;\n\tunsigned long haddr = vmf->address & HPAGE_PMD_MASK;\n\n\tif (haddr < vma->vm_start || haddr + HPAGE_PMD_SIZE > vma->vm_end)\n\t\treturn VM_FAULT_FALLBACK;\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn VM_FAULT_OOM;\n\tif (unlikely(khugepaged_enter(vma, vma->vm_flags)))\n\t\treturn VM_FAULT_OOM;\n\tif (!(vmf->flags & FAULT_FLAG_WRITE) &&\n\t\t\t!mm_forbids_zeropage(vma->vm_mm) &&\n\t\t\ttransparent_hugepage_use_zero_page()) {\n\t\tpgtable_t pgtable;\n\t\tstruct page *zero_page;\n\t\tbool set;\n\t\tvm_fault_t ret;\n\t\tpgtable = pte_alloc_one(vma->vm_mm, haddr);\n\t\tif (unlikely(!pgtable))\n\t\t\treturn VM_FAULT_OOM;\n\t\tzero_page = mm_get_huge_zero_page(vma->vm_mm);\n\t\tif (unlikely(!zero_page)) {\n\t\t\tpte_free(vma->vm_mm, pgtable);\n\t\t\tcount_vm_event(THP_FAULT_FALLBACK);\n\t\t\treturn VM_FAULT_FALLBACK;\n\t\t}\n\t\tvmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);\n\t\tret = 0;\n\t\tset = false;\n\t\tif (pmd_none(*vmf->pmd)) {\n\t\t\tret = check_stable_address_space(vma->vm_mm);\n\t\t\tif (ret) {\n\t\t\t\tspin_unlock(vmf->ptl);\n\t\t\t} else if (userfaultfd_missing(vma)) {\n\t\t\t\tspin_unlock(vmf->ptl);\n\t\t\t\tret = handle_userfault(vmf, VM_UFFD_MISSING);\n\t\t\t\tVM_BUG_ON(ret & VM_FAULT_FALLBACK);\n\t\t\t} else {\n\t\t\t\tset_huge_zero_page(pgtable, vma->vm_mm, vma,\n\t\t\t\t\t\t   haddr, vmf->pmd, zero_page);\n\t\t\t\tspin_unlock(vmf->ptl);\n\t\t\t\tset = true;\n\t\t\t}\n\t\t} else\n\t\t\tspin_unlock(vmf->ptl);\n\t\tif (!set)\n\t\t\tpte_free(vma->vm_mm, pgtable);\n\t\treturn ret;\n\t}\n\tgfp = alloc_hugepage_direct_gfpmask(vma, haddr);\n\tpage = alloc_pages_vma(gfp, HPAGE_PMD_ORDER, vma, haddr, numa_node_id());\n\tif (unlikely(!page)) {\n\t\tcount_vm_event(THP_FAULT_FALLBACK);\n\t\treturn VM_FAULT_FALLBACK;\n\t}\n\tprep_transhuge_page(page);\n\treturn __do_huge_pmd_anonymous_page(vmf, page, gfp);\n}"
  },
  {
    "function_name": "set_huge_zero_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "669-683",
    "snippet": "static bool set_huge_zero_page(pgtable_t pgtable, struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, unsigned long haddr, pmd_t *pmd,\n\t\tstruct page *zero_page)\n{\n\tpmd_t entry;\n\tif (!pmd_none(*pmd))\n\t\treturn false;\n\tentry = mk_pmd(zero_page, vma->vm_page_prot);\n\tentry = pmd_mkhuge(entry);\n\tif (pgtable)\n\t\tpgtable_trans_huge_deposit(mm, pmd, pgtable);\n\tset_pmd_at(mm, haddr, pmd, entry);\n\tmm_inc_nr_ptes(mm);\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mm_inc_nr_ptes",
          "args": [
            "mm"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pmd_at",
          "args": [
            "mm",
            "haddr",
            "pmd",
            "entry"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgtable_trans_huge_deposit",
          "args": [
            "mm",
            "pmd",
            "pgtable"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "pgtable_trans_huge_deposit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "152-163",
          "snippet": "void pgtable_trans_huge_deposit(struct mm_struct *mm, pmd_t *pmdp,\n\t\t\t\tpgtable_t pgtable)\n{\n\tassert_spin_locked(pmd_lockptr(mm, pmdp));\n\n\t/* FIFO */\n\tif (!pmd_huge_pte(mm, pmdp))\n\t\tINIT_LIST_HEAD(&pgtable->lru);\n\telse\n\t\tlist_add(&pgtable->lru, &pmd_huge_pte(mm, pmdp)->lru);\n\tpmd_huge_pte(mm, pmdp) = pgtable;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\nvoid pgtable_trans_huge_deposit(struct mm_struct *mm, pmd_t *pmdp,\n\t\t\t\tpgtable_t pgtable)\n{\n\tassert_spin_locked(pmd_lockptr(mm, pmdp));\n\n\t/* FIFO */\n\tif (!pmd_huge_pte(mm, pmdp))\n\t\tINIT_LIST_HEAD(&pgtable->lru);\n\telse\n\t\tlist_add(&pgtable->lru, &pmd_huge_pte(mm, pmdp)->lru);\n\tpmd_huge_pte(mm, pmdp) = pgtable;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_mkhuge",
          "args": [
            "entry"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mk_pmd",
          "args": [
            "zero_page",
            "vma->vm_page_prot"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "*pmd"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic bool set_huge_zero_page(pgtable_t pgtable, struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, unsigned long haddr, pmd_t *pmd,\n\t\tstruct page *zero_page)\n{\n\tpmd_t entry;\n\tif (!pmd_none(*pmd))\n\t\treturn false;\n\tentry = mk_pmd(zero_page, vma->vm_page_prot);\n\tentry = pmd_mkhuge(entry);\n\tif (pgtable)\n\t\tpgtable_trans_huge_deposit(mm, pmd, pgtable);\n\tset_pmd_at(mm, haddr, pmd, entry);\n\tmm_inc_nr_ptes(mm);\n\treturn true;\n}"
  },
  {
    "function_name": "alloc_hugepage_direct_gfpmask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "632-666",
    "snippet": "static inline gfp_t alloc_hugepage_direct_gfpmask(struct vm_area_struct *vma, unsigned long addr)\n{\n\tconst bool vma_madvised = !!(vma->vm_flags & VM_HUGEPAGE);\n\tgfp_t this_node = 0;\n\n#ifdef CONFIG_NUMA\n\tstruct mempolicy *pol;\n\t/*\n\t * __GFP_THISNODE is used only when __GFP_DIRECT_RECLAIM is not\n\t * specified, to express a general desire to stay on the current\n\t * node for optimistic allocation attempts. If the defrag mode\n\t * and/or madvise hint requires the direct reclaim then we prefer\n\t * to fallback to other node rather than node reclaim because that\n\t * can lead to excessive reclaim even though there is free memory\n\t * on other nodes. We expect that NUMA preferences are specified\n\t * by memory policies.\n\t */\n\tpol = get_vma_policy(vma, addr);\n\tif (pol->mode != MPOL_BIND)\n\t\tthis_node = __GFP_THISNODE;\n\tmpol_cond_put(pol);\n#endif\n\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE | (vma_madvised ? 0 : __GFP_NORETRY);\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE_LIGHT | __GFP_KSWAPD_RECLAIM | this_node;\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE_LIGHT | (vma_madvised ? __GFP_DIRECT_RECLAIM :\n\t\t\t\t\t\t\t     __GFP_KSWAPD_RECLAIM | this_node);\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE_LIGHT | (vma_madvised ? __GFP_DIRECT_RECLAIM :\n\t\t\t\t\t\t\t     this_node);\n\treturn GFP_TRANSHUGE_LIGHT | this_node;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG",
            "&transparent_hugepage_flags"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG",
            "&transparent_hugepage_flags"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG",
            "&transparent_hugepage_flags"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG",
            "&transparent_hugepage_flags"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_cond_put",
          "args": [
            "pol"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_vma_policy",
          "args": [
            "vma",
            "addr"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "get_vma_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1665-1674",
          "snippet": "struct mempolicy *get_vma_policy(struct vm_area_struct *vma,\n\t\t\t\t\t\tunsigned long addr)\n{\n\tstruct mempolicy *pol = __get_vma_policy(vma, addr);\n\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstruct mempolicy *get_vma_policy(struct vm_area_struct *vma,\n\t\t\t\t\t\tunsigned long addr)\n{\n\tstruct mempolicy *pol = __get_vma_policy(vma, addr);\n\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline gfp_t alloc_hugepage_direct_gfpmask(struct vm_area_struct *vma, unsigned long addr)\n{\n\tconst bool vma_madvised = !!(vma->vm_flags & VM_HUGEPAGE);\n\tgfp_t this_node = 0;\n\n#ifdef CONFIG_NUMA\n\tstruct mempolicy *pol;\n\t/*\n\t * __GFP_THISNODE is used only when __GFP_DIRECT_RECLAIM is not\n\t * specified, to express a general desire to stay on the current\n\t * node for optimistic allocation attempts. If the defrag mode\n\t * and/or madvise hint requires the direct reclaim then we prefer\n\t * to fallback to other node rather than node reclaim because that\n\t * can lead to excessive reclaim even though there is free memory\n\t * on other nodes. We expect that NUMA preferences are specified\n\t * by memory policies.\n\t */\n\tpol = get_vma_policy(vma, addr);\n\tif (pol->mode != MPOL_BIND)\n\t\tthis_node = __GFP_THISNODE;\n\tmpol_cond_put(pol);\n#endif\n\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE | (vma_madvised ? 0 : __GFP_NORETRY);\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE_LIGHT | __GFP_KSWAPD_RECLAIM | this_node;\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE_LIGHT | (vma_madvised ? __GFP_DIRECT_RECLAIM :\n\t\t\t\t\t\t\t     __GFP_KSWAPD_RECLAIM | this_node);\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags))\n\t\treturn GFP_TRANSHUGE_LIGHT | (vma_madvised ? __GFP_DIRECT_RECLAIM :\n\t\t\t\t\t\t\t     this_node);\n\treturn GFP_TRANSHUGE_LIGHT | this_node;\n}"
  },
  {
    "function_name": "__do_huge_pmd_anonymous_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "544-621",
    "snippet": "static vm_fault_t __do_huge_pmd_anonymous_page(struct vm_fault *vmf,\n\t\t\tstruct page *page, gfp_t gfp)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct mem_cgroup *memcg;\n\tpgtable_t pgtable;\n\tunsigned long haddr = vmf->address & HPAGE_PMD_MASK;\n\tvm_fault_t ret = 0;\n\n\tVM_BUG_ON_PAGE(!PageCompound(page), page);\n\n\tif (mem_cgroup_try_charge_delay(page, vma->vm_mm, gfp, &memcg, true)) {\n\t\tput_page(page);\n\t\tcount_vm_event(THP_FAULT_FALLBACK);\n\t\treturn VM_FAULT_FALLBACK;\n\t}\n\n\tpgtable = pte_alloc_one(vma->vm_mm, haddr);\n\tif (unlikely(!pgtable)) {\n\t\tret = VM_FAULT_OOM;\n\t\tgoto release;\n\t}\n\n\tclear_huge_page(page, vmf->address, HPAGE_PMD_NR);\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * clear_huge_page writes become visible before the set_pmd_at()\n\t * write.\n\t */\n\t__SetPageUptodate(page);\n\n\tvmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);\n\tif (unlikely(!pmd_none(*vmf->pmd))) {\n\t\tgoto unlock_release;\n\t} else {\n\t\tpmd_t entry;\n\n\t\tret = check_stable_address_space(vma->vm_mm);\n\t\tif (ret)\n\t\t\tgoto unlock_release;\n\n\t\t/* Deliver the page fault to userland */\n\t\tif (userfaultfd_missing(vma)) {\n\t\t\tvm_fault_t ret2;\n\n\t\t\tspin_unlock(vmf->ptl);\n\t\t\tmem_cgroup_cancel_charge(page, memcg, true);\n\t\t\tput_page(page);\n\t\t\tpte_free(vma->vm_mm, pgtable);\n\t\t\tret2 = handle_userfault(vmf, VM_UFFD_MISSING);\n\t\t\tVM_BUG_ON(ret2 & VM_FAULT_FALLBACK);\n\t\t\treturn ret2;\n\t\t}\n\n\t\tentry = mk_huge_pmd(page, vma->vm_page_prot);\n\t\tentry = maybe_pmd_mkwrite(pmd_mkdirty(entry), vma);\n\t\tpage_add_new_anon_rmap(page, vma, haddr, true);\n\t\tmem_cgroup_commit_charge(page, memcg, false, true);\n\t\tlru_cache_add_active_or_unevictable(page, vma);\n\t\tpgtable_trans_huge_deposit(vma->vm_mm, vmf->pmd, pgtable);\n\t\tset_pmd_at(vma->vm_mm, haddr, vmf->pmd, entry);\n\t\tadd_mm_counter(vma->vm_mm, MM_ANONPAGES, HPAGE_PMD_NR);\n\t\tmm_inc_nr_ptes(vma->vm_mm);\n\t\tspin_unlock(vmf->ptl);\n\t\tcount_vm_event(THP_FAULT_ALLOC);\n\t}\n\n\treturn 0;\nunlock_release:\n\tspin_unlock(vmf->ptl);\nrelease:\n\tif (pgtable)\n\t\tpte_free(vma->vm_mm, pgtable);\n\tmem_cgroup_cancel_charge(page, memcg, true);\n\tput_page(page);\n\treturn ret;\n\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_cancel_charge",
          "args": [
            "page",
            "memcg",
            "true"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_cancel_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5972-5988",
          "snippet": "void mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,\n\t\tbool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcancel_charge(memcg, nr_pages);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,\n\t\tbool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcancel_charge(memcg, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_free",
          "args": [
            "vma->vm_mm",
            "pgtable"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "vmf->ptl"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "THP_FAULT_ALLOC"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "vmf->ptl"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_inc_nr_ptes",
          "args": [
            "vma->vm_mm"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_mm_counter",
          "args": [
            "vma->vm_mm",
            "MM_ANONPAGES",
            "HPAGE_PMD_NR"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "add_mm_counter_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "157-165",
          "snippet": "static void add_mm_counter_fast(struct mm_struct *mm, int member, int val)\n{\n\tstruct task_struct *task = current;\n\n\tif (likely(task->mm == mm))\n\t\ttask->rss_stat.count[member] += val;\n\telse\n\t\tadd_mm_counter(mm, member, val);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void add_mm_counter_fast(struct mm_struct *mm, int member, int val)\n{\n\tstruct task_struct *task = current;\n\n\tif (likely(task->mm == mm))\n\t\ttask->rss_stat.count[member] += val;\n\telse\n\t\tadd_mm_counter(mm, member, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_pmd_at",
          "args": [
            "vma->vm_mm",
            "haddr",
            "vmf->pmd",
            "entry"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgtable_trans_huge_deposit",
          "args": [
            "vma->vm_mm",
            "vmf->pmd",
            "pgtable"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "pgtable_trans_huge_deposit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "152-163",
          "snippet": "void pgtable_trans_huge_deposit(struct mm_struct *mm, pmd_t *pmdp,\n\t\t\t\tpgtable_t pgtable)\n{\n\tassert_spin_locked(pmd_lockptr(mm, pmdp));\n\n\t/* FIFO */\n\tif (!pmd_huge_pte(mm, pmdp))\n\t\tINIT_LIST_HEAD(&pgtable->lru);\n\telse\n\t\tlist_add(&pgtable->lru, &pmd_huge_pte(mm, pmdp)->lru);\n\tpmd_huge_pte(mm, pmdp) = pgtable;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\nvoid pgtable_trans_huge_deposit(struct mm_struct *mm, pmd_t *pmdp,\n\t\t\t\tpgtable_t pgtable)\n{\n\tassert_spin_locked(pmd_lockptr(mm, pmdp));\n\n\t/* FIFO */\n\tif (!pmd_huge_pte(mm, pmdp))\n\t\tINIT_LIST_HEAD(&pgtable->lru);\n\telse\n\t\tlist_add(&pgtable->lru, &pmd_huge_pte(mm, pmdp)->lru);\n\tpmd_huge_pte(mm, pmdp) = pgtable;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_cache_add_active_or_unevictable",
          "args": [
            "page",
            "vma"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "lru_cache_add_active_or_unevictable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "458-476",
          "snippet": "void lru_cache_add_active_or_unevictable(struct page *page,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\tif (likely((vma->vm_flags & (VM_LOCKED | VM_SPECIAL)) != VM_LOCKED))\n\t\tSetPageActive(page);\n\telse if (!TestSetPageMlocked(page)) {\n\t\t/*\n\t\t * We use the irq-unsafe __mod_zone_page_stat because this\n\t\t * counter is not modified from interrupt context, and the pte\n\t\t * lock is held(spinlock), which implies preemption disabled.\n\t\t */\n\t\t__mod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t}\n\tlru_cache_add(page);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid lru_cache_add_active_or_unevictable(struct page *page,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\tif (likely((vma->vm_flags & (VM_LOCKED | VM_SPECIAL)) != VM_LOCKED))\n\t\tSetPageActive(page);\n\telse if (!TestSetPageMlocked(page)) {\n\t\t/*\n\t\t * We use the irq-unsafe __mod_zone_page_stat because this\n\t\t * counter is not modified from interrupt context, and the pte\n\t\t * lock is held(spinlock), which implies preemption disabled.\n\t\t */\n\t\t__mod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t}\n\tlru_cache_add(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_commit_charge",
          "args": [
            "page",
            "memcg",
            "false",
            "true"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_commit_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5928-5962",
          "snippet": "void mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t      bool lrucare, bool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_PAGE(!page->mapping, page);\n\tVM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcommit_charge(page, memcg, lrucare);\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(memcg, page, compound, nr_pages);\n\tmemcg_check_events(memcg, page);\n\tlocal_irq_enable();\n\n\tif (do_memsw_account() && PageSwapCache(page)) {\n\t\tswp_entry_t entry = { .val = page_private(page) };\n\t\t/*\n\t\t * The swap entry might not get freed for a long time,\n\t\t * let's not wait for it.  The page already received a\n\t\t * memory+swap charge, drop the swap entry duplicate.\n\t\t */\n\t\tmem_cgroup_uncharge_swap(entry, nr_pages);\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t      bool lrucare, bool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_PAGE(!page->mapping, page);\n\tVM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcommit_charge(page, memcg, lrucare);\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(memcg, page, compound, nr_pages);\n\tmemcg_check_events(memcg, page);\n\tlocal_irq_enable();\n\n\tif (do_memsw_account() && PageSwapCache(page)) {\n\t\tswp_entry_t entry = { .val = page_private(page) };\n\t\t/*\n\t\t * The swap entry might not get freed for a long time,\n\t\t * let's not wait for it.  The page already received a\n\t\t * memory+swap charge, drop the swap entry duplicate.\n\t\t */\n\t\tmem_cgroup_uncharge_swap(entry, nr_pages);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_add_new_anon_rmap",
          "args": [
            "page",
            "vma",
            "haddr",
            "true"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "page_add_new_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1150-1170",
          "snippet": "void page_add_new_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, bool compound)\n{\n\tint nr = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\t__SetPageSwapBacked(page);\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(compound_mapcount_ptr(page), 0);\n\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t} else {\n\t\t/* Anon THP always mapped first with PMD */\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(&page->_mapcount, 0);\n\t}\n\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t__page_set_anon_rmap(page, vma, address, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_add_new_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, bool compound)\n{\n\tint nr = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\t__SetPageSwapBacked(page);\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(compound_mapcount_ptr(page), 0);\n\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t} else {\n\t\t/* Anon THP always mapped first with PMD */\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(&page->_mapcount, 0);\n\t}\n\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t__page_set_anon_rmap(page, vma, address, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "maybe_pmd_mkwrite",
          "args": [
            "pmd_mkdirty(entry)",
            "vma"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_pmd_mkwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "477-482",
          "snippet": "pmd_t maybe_pmd_mkwrite(pmd_t pmd, struct vm_area_struct *vma)\n{\n\tif (likely(vma->vm_flags & VM_WRITE))\n\t\tpmd = pmd_mkwrite(pmd);\n\treturn pmd;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\npmd_t maybe_pmd_mkwrite(pmd_t pmd, struct vm_area_struct *vma)\n{\n\tif (likely(vma->vm_flags & VM_WRITE))\n\t\tpmd = pmd_mkwrite(pmd);\n\treturn pmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_mkdirty",
          "args": [
            "entry"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mk_huge_pmd",
          "args": [
            "page",
            "vma->vm_page_prot"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "ret2 & VM_FAULT_FALLBACK"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_userfault",
          "args": [
            "vmf",
            "VM_UFFD_MISSING"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_free",
          "args": [
            "vma->vm_mm",
            "pgtable"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "vmf->ptl"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userfaultfd_missing",
          "args": [
            "vma"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stable_address_space",
          "args": [
            "vma->vm_mm"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pmd_none(*vmf->pmd)"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "*vmf->pmd"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_lock",
          "args": [
            "vma->vm_mm",
            "vmf->pmd"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_huge_page",
          "args": [
            "page",
            "vmf->address",
            "HPAGE_PMD_NR"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "clear_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "4440-4452",
          "snippet": "void clear_huge_page(struct page *page,\n\t\t     unsigned long addr_hint, unsigned int pages_per_huge_page)\n{\n\tunsigned long addr = addr_hint &\n\t\t~(((unsigned long)pages_per_huge_page << PAGE_SHIFT) - 1);\n\n\tif (unlikely(pages_per_huge_page > MAX_ORDER_NR_PAGES)) {\n\t\tclear_gigantic_page(page, addr, pages_per_huge_page);\n\t\treturn;\n\t}\n\n\tprocess_huge_page(addr_hint, pages_per_huge_page, clear_subpage, page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid clear_huge_page(struct page *page,\n\t\t     unsigned long addr_hint, unsigned int pages_per_huge_page)\n{\n\tunsigned long addr = addr_hint &\n\t\t~(((unsigned long)pages_per_huge_page << PAGE_SHIFT) - 1);\n\n\tif (unlikely(pages_per_huge_page > MAX_ORDER_NR_PAGES)) {\n\t\tclear_gigantic_page(page, addr, pages_per_huge_page);\n\t\treturn;\n\t}\n\n\tprocess_huge_page(addr_hint, pages_per_huge_page, clear_subpage, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pgtable"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_alloc_one",
          "args": [
            "vma->vm_mm",
            "haddr"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "THP_FAULT_FALLBACK"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_try_charge_delay",
          "args": [
            "page",
            "vma->vm_mm",
            "gfp",
            "&memcg",
            "true"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_try_charge_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5898-5909",
          "snippet": "int mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\tret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);\n\tmemcg = *memcgp;\n\tmem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nint mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\tret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);\n\tmemcg = *memcgp;\n\tmem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageCompound(page)",
            "page"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic vm_fault_t __do_huge_pmd_anonymous_page(struct vm_fault *vmf,\n\t\t\tstruct page *page, gfp_t gfp)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct mem_cgroup *memcg;\n\tpgtable_t pgtable;\n\tunsigned long haddr = vmf->address & HPAGE_PMD_MASK;\n\tvm_fault_t ret = 0;\n\n\tVM_BUG_ON_PAGE(!PageCompound(page), page);\n\n\tif (mem_cgroup_try_charge_delay(page, vma->vm_mm, gfp, &memcg, true)) {\n\t\tput_page(page);\n\t\tcount_vm_event(THP_FAULT_FALLBACK);\n\t\treturn VM_FAULT_FALLBACK;\n\t}\n\n\tpgtable = pte_alloc_one(vma->vm_mm, haddr);\n\tif (unlikely(!pgtable)) {\n\t\tret = VM_FAULT_OOM;\n\t\tgoto release;\n\t}\n\n\tclear_huge_page(page, vmf->address, HPAGE_PMD_NR);\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * clear_huge_page writes become visible before the set_pmd_at()\n\t * write.\n\t */\n\t__SetPageUptodate(page);\n\n\tvmf->ptl = pmd_lock(vma->vm_mm, vmf->pmd);\n\tif (unlikely(!pmd_none(*vmf->pmd))) {\n\t\tgoto unlock_release;\n\t} else {\n\t\tpmd_t entry;\n\n\t\tret = check_stable_address_space(vma->vm_mm);\n\t\tif (ret)\n\t\t\tgoto unlock_release;\n\n\t\t/* Deliver the page fault to userland */\n\t\tif (userfaultfd_missing(vma)) {\n\t\t\tvm_fault_t ret2;\n\n\t\t\tspin_unlock(vmf->ptl);\n\t\t\tmem_cgroup_cancel_charge(page, memcg, true);\n\t\t\tput_page(page);\n\t\t\tpte_free(vma->vm_mm, pgtable);\n\t\t\tret2 = handle_userfault(vmf, VM_UFFD_MISSING);\n\t\t\tVM_BUG_ON(ret2 & VM_FAULT_FALLBACK);\n\t\t\treturn ret2;\n\t\t}\n\n\t\tentry = mk_huge_pmd(page, vma->vm_page_prot);\n\t\tentry = maybe_pmd_mkwrite(pmd_mkdirty(entry), vma);\n\t\tpage_add_new_anon_rmap(page, vma, haddr, true);\n\t\tmem_cgroup_commit_charge(page, memcg, false, true);\n\t\tlru_cache_add_active_or_unevictable(page, vma);\n\t\tpgtable_trans_huge_deposit(vma->vm_mm, vmf->pmd, pgtable);\n\t\tset_pmd_at(vma->vm_mm, haddr, vmf->pmd, entry);\n\t\tadd_mm_counter(vma->vm_mm, MM_ANONPAGES, HPAGE_PMD_NR);\n\t\tmm_inc_nr_ptes(vma->vm_mm);\n\t\tspin_unlock(vmf->ptl);\n\t\tcount_vm_event(THP_FAULT_ALLOC);\n\t}\n\n\treturn 0;\nunlock_release:\n\tspin_unlock(vmf->ptl);\nrelease:\n\tif (pgtable)\n\t\tpte_free(vma->vm_mm, pgtable);\n\tmem_cgroup_cancel_charge(page, memcg, true);\n\tput_page(page);\n\treturn ret;\n\n}"
  },
  {
    "function_name": "thp_get_unmapped_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "525-541",
    "snippet": "unsigned long thp_get_unmapped_area(struct file *filp, unsigned long addr,\n\t\tunsigned long len, unsigned long pgoff, unsigned long flags)\n{\n\tloff_t off = (loff_t)pgoff << PAGE_SHIFT;\n\n\tif (addr)\n\t\tgoto out;\n\tif (!IS_DAX(filp->f_mapping->host) || !IS_ENABLED(CONFIG_FS_DAX_PMD))\n\t\tgoto out;\n\n\taddr = __thp_get_unmapped_area(filp, len, off, flags, PMD_SIZE);\n\tif (addr)\n\t\treturn addr;\n\n out:\n\treturn current->mm->get_unmapped_area(filp, addr, len, pgoff, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current->mm->get_unmapped_area",
          "args": [
            "filp",
            "addr",
            "len",
            "pgoff",
            "flags"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "get_unmapped_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2170-2210",
          "snippet": "unsigned long\nget_unmapped_area(struct file *file, unsigned long addr, unsigned long len,\n\t\tunsigned long pgoff, unsigned long flags)\n{\n\tunsigned long (*get_area)(struct file *, unsigned long,\n\t\t\t\t  unsigned long, unsigned long, unsigned long);\n\n\tunsigned long error = arch_mmap_check(addr, len, flags);\n\tif (error)\n\t\treturn error;\n\n\t/* Careful about overflows.. */\n\tif (len > TASK_SIZE)\n\t\treturn -ENOMEM;\n\n\tget_area = current->mm->get_unmapped_area;\n\tif (file) {\n\t\tif (file->f_op->get_unmapped_area)\n\t\t\tget_area = file->f_op->get_unmapped_area;\n\t} else if (flags & MAP_SHARED) {\n\t\t/*\n\t\t * mmap_region() will call shmem_zero_setup() to create a file,\n\t\t * so use shmem's get_unmapped_area in case it can be huge.\n\t\t * do_mmap_pgoff() will clear pgoff, so match alignment.\n\t\t */\n\t\tpgoff = 0;\n\t\tget_area = shmem_get_unmapped_area;\n\t}\n\n\taddr = get_area(file, addr, len, pgoff, flags);\n\tif (IS_ERR_VALUE(addr))\n\t\treturn addr;\n\n\tif (addr > TASK_SIZE - len)\n\t\treturn -ENOMEM;\n\tif (offset_in_page(addr))\n\t\treturn -EINVAL;\n\n\terror = security_mmap_addr(addr);\n\treturn error ? error : addr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nunsigned long\nget_unmapped_area(struct file *file, unsigned long addr, unsigned long len,\n\t\tunsigned long pgoff, unsigned long flags)\n{\n\tunsigned long (*get_area)(struct file *, unsigned long,\n\t\t\t\t  unsigned long, unsigned long, unsigned long);\n\n\tunsigned long error = arch_mmap_check(addr, len, flags);\n\tif (error)\n\t\treturn error;\n\n\t/* Careful about overflows.. */\n\tif (len > TASK_SIZE)\n\t\treturn -ENOMEM;\n\n\tget_area = current->mm->get_unmapped_area;\n\tif (file) {\n\t\tif (file->f_op->get_unmapped_area)\n\t\t\tget_area = file->f_op->get_unmapped_area;\n\t} else if (flags & MAP_SHARED) {\n\t\t/*\n\t\t * mmap_region() will call shmem_zero_setup() to create a file,\n\t\t * so use shmem's get_unmapped_area in case it can be huge.\n\t\t * do_mmap_pgoff() will clear pgoff, so match alignment.\n\t\t */\n\t\tpgoff = 0;\n\t\tget_area = shmem_get_unmapped_area;\n\t}\n\n\taddr = get_area(file, addr, len, pgoff, flags);\n\tif (IS_ERR_VALUE(addr))\n\t\treturn addr;\n\n\tif (addr > TASK_SIZE - len)\n\t\treturn -ENOMEM;\n\tif (offset_in_page(addr))\n\t\treturn -EINVAL;\n\n\terror = security_mmap_addr(addr);\n\treturn error ? error : addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__thp_get_unmapped_area",
          "args": [
            "filp",
            "len",
            "off",
            "flags",
            "PMD_SIZE"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "__thp_get_unmapped_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "501-523",
          "snippet": "unsigned long __thp_get_unmapped_area(struct file *filp, unsigned long len,\n\t\tloff_t off, unsigned long flags, unsigned long size)\n{\n\tunsigned long addr;\n\tloff_t off_end = off + len;\n\tloff_t off_align = round_up(off, size);\n\tunsigned long len_pad;\n\n\tif (off_end <= off_align || (off_end - off_align) < size)\n\t\treturn 0;\n\n\tlen_pad = len + size;\n\tif (len_pad < len || (off + len_pad) < off)\n\t\treturn 0;\n\n\taddr = current->mm->get_unmapped_area(filp, 0, len_pad,\n\t\t\t\t\t      off >> PAGE_SHIFT, flags);\n\tif (IS_ERR_VALUE(addr))\n\t\treturn 0;\n\n\taddr += (off - addr) & (size - 1);\n\treturn addr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nunsigned long __thp_get_unmapped_area(struct file *filp, unsigned long len,\n\t\tloff_t off, unsigned long flags, unsigned long size)\n{\n\tunsigned long addr;\n\tloff_t off_end = off + len;\n\tloff_t off_align = round_up(off, size);\n\tunsigned long len_pad;\n\n\tif (off_end <= off_align || (off_end - off_align) < size)\n\t\treturn 0;\n\n\tlen_pad = len + size;\n\tif (len_pad < len || (off + len_pad) < off)\n\t\treturn 0;\n\n\taddr = current->mm->get_unmapped_area(filp, 0, len_pad,\n\t\t\t\t\t      off >> PAGE_SHIFT, flags);\n\tif (IS_ERR_VALUE(addr))\n\t\treturn 0;\n\n\taddr += (off - addr) & (size - 1);\n\treturn addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_FS_DAX_PMD"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DAX",
          "args": [
            "filp->f_mapping->host"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nunsigned long thp_get_unmapped_area(struct file *filp, unsigned long addr,\n\t\tunsigned long len, unsigned long pgoff, unsigned long flags)\n{\n\tloff_t off = (loff_t)pgoff << PAGE_SHIFT;\n\n\tif (addr)\n\t\tgoto out;\n\tif (!IS_DAX(filp->f_mapping->host) || !IS_ENABLED(CONFIG_FS_DAX_PMD))\n\t\tgoto out;\n\n\taddr = __thp_get_unmapped_area(filp, len, off, flags, PMD_SIZE);\n\tif (addr)\n\t\treturn addr;\n\n out:\n\treturn current->mm->get_unmapped_area(filp, addr, len, pgoff, flags);\n}"
  },
  {
    "function_name": "__thp_get_unmapped_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "501-523",
    "snippet": "unsigned long __thp_get_unmapped_area(struct file *filp, unsigned long len,\n\t\tloff_t off, unsigned long flags, unsigned long size)\n{\n\tunsigned long addr;\n\tloff_t off_end = off + len;\n\tloff_t off_align = round_up(off, size);\n\tunsigned long len_pad;\n\n\tif (off_end <= off_align || (off_end - off_align) < size)\n\t\treturn 0;\n\n\tlen_pad = len + size;\n\tif (len_pad < len || (off + len_pad) < off)\n\t\treturn 0;\n\n\taddr = current->mm->get_unmapped_area(filp, 0, len_pad,\n\t\t\t\t\t      off >> PAGE_SHIFT, flags);\n\tif (IS_ERR_VALUE(addr))\n\t\treturn 0;\n\n\taddr += (off - addr) & (size - 1);\n\treturn addr;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ERR_VALUE",
          "args": [
            "addr"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current->mm->get_unmapped_area",
          "args": [
            "filp",
            "0",
            "len_pad",
            "off >> PAGE_SHIFT",
            "flags"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "get_unmapped_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2170-2210",
          "snippet": "unsigned long\nget_unmapped_area(struct file *file, unsigned long addr, unsigned long len,\n\t\tunsigned long pgoff, unsigned long flags)\n{\n\tunsigned long (*get_area)(struct file *, unsigned long,\n\t\t\t\t  unsigned long, unsigned long, unsigned long);\n\n\tunsigned long error = arch_mmap_check(addr, len, flags);\n\tif (error)\n\t\treturn error;\n\n\t/* Careful about overflows.. */\n\tif (len > TASK_SIZE)\n\t\treturn -ENOMEM;\n\n\tget_area = current->mm->get_unmapped_area;\n\tif (file) {\n\t\tif (file->f_op->get_unmapped_area)\n\t\t\tget_area = file->f_op->get_unmapped_area;\n\t} else if (flags & MAP_SHARED) {\n\t\t/*\n\t\t * mmap_region() will call shmem_zero_setup() to create a file,\n\t\t * so use shmem's get_unmapped_area in case it can be huge.\n\t\t * do_mmap_pgoff() will clear pgoff, so match alignment.\n\t\t */\n\t\tpgoff = 0;\n\t\tget_area = shmem_get_unmapped_area;\n\t}\n\n\taddr = get_area(file, addr, len, pgoff, flags);\n\tif (IS_ERR_VALUE(addr))\n\t\treturn addr;\n\n\tif (addr > TASK_SIZE - len)\n\t\treturn -ENOMEM;\n\tif (offset_in_page(addr))\n\t\treturn -EINVAL;\n\n\terror = security_mmap_addr(addr);\n\treturn error ? error : addr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nunsigned long\nget_unmapped_area(struct file *file, unsigned long addr, unsigned long len,\n\t\tunsigned long pgoff, unsigned long flags)\n{\n\tunsigned long (*get_area)(struct file *, unsigned long,\n\t\t\t\t  unsigned long, unsigned long, unsigned long);\n\n\tunsigned long error = arch_mmap_check(addr, len, flags);\n\tif (error)\n\t\treturn error;\n\n\t/* Careful about overflows.. */\n\tif (len > TASK_SIZE)\n\t\treturn -ENOMEM;\n\n\tget_area = current->mm->get_unmapped_area;\n\tif (file) {\n\t\tif (file->f_op->get_unmapped_area)\n\t\t\tget_area = file->f_op->get_unmapped_area;\n\t} else if (flags & MAP_SHARED) {\n\t\t/*\n\t\t * mmap_region() will call shmem_zero_setup() to create a file,\n\t\t * so use shmem's get_unmapped_area in case it can be huge.\n\t\t * do_mmap_pgoff() will clear pgoff, so match alignment.\n\t\t */\n\t\tpgoff = 0;\n\t\tget_area = shmem_get_unmapped_area;\n\t}\n\n\taddr = get_area(file, addr, len, pgoff, flags);\n\tif (IS_ERR_VALUE(addr))\n\t\treturn addr;\n\n\tif (addr > TASK_SIZE - len)\n\t\treturn -ENOMEM;\n\tif (offset_in_page(addr))\n\t\treturn -EINVAL;\n\n\terror = security_mmap_addr(addr);\n\treturn error ? error : addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "off",
            "size"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nunsigned long __thp_get_unmapped_area(struct file *filp, unsigned long len,\n\t\tloff_t off, unsigned long flags, unsigned long size)\n{\n\tunsigned long addr;\n\tloff_t off_end = off + len;\n\tloff_t off_align = round_up(off, size);\n\tunsigned long len_pad;\n\n\tif (off_end <= off_align || (off_end - off_align) < size)\n\t\treturn 0;\n\n\tlen_pad = len + size;\n\tif (len_pad < len || (off + len_pad) < off)\n\t\treturn 0;\n\n\taddr = current->mm->get_unmapped_area(filp, 0, len_pad,\n\t\t\t\t\t      off >> PAGE_SHIFT, flags);\n\tif (IS_ERR_VALUE(addr))\n\t\treturn 0;\n\n\taddr += (off - addr) & (size - 1);\n\treturn addr;\n}"
  },
  {
    "function_name": "prep_transhuge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "490-499",
    "snippet": "void prep_transhuge_page(struct page *page)\n{\n\t/*\n\t * we use page->mapping and page->indexlru in second tail page\n\t * as list_head: assuming THP order >= 2\n\t */\n\n\tINIT_LIST_HEAD(page_deferred_list(page));\n\tset_compound_page_dtor(page, TRANSHUGE_PAGE_DTOR);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_compound_page_dtor",
          "args": [
            "page",
            "TRANSHUGE_PAGE_DTOR"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "page_deferred_list(page)"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_deferred_list",
          "args": [
            "page"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "page_deferred_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "484-488",
          "snippet": "static inline struct list_head *page_deferred_list(struct page *page)\n{\n\t/* ->lru in the tail pages is occupied by compound_head. */\n\treturn &page[2].deferred_list;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline struct list_head *page_deferred_list(struct page *page)\n{\n\t/* ->lru in the tail pages is occupied by compound_head. */\n\treturn &page[2].deferred_list;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid prep_transhuge_page(struct page *page)\n{\n\t/*\n\t * we use page->mapping and page->indexlru in second tail page\n\t * as list_head: assuming THP order >= 2\n\t */\n\n\tINIT_LIST_HEAD(page_deferred_list(page));\n\tset_compound_page_dtor(page, TRANSHUGE_PAGE_DTOR);\n}"
  },
  {
    "function_name": "page_deferred_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "484-488",
    "snippet": "static inline struct list_head *page_deferred_list(struct page *page)\n{\n\t/* ->lru in the tail pages is occupied by compound_head. */\n\treturn &page[2].deferred_list;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline struct list_head *page_deferred_list(struct page *page)\n{\n\t/* ->lru in the tail pages is occupied by compound_head. */\n\treturn &page[2].deferred_list;\n}"
  },
  {
    "function_name": "maybe_pmd_mkwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "477-482",
    "snippet": "pmd_t maybe_pmd_mkwrite(pmd_t pmd, struct vm_area_struct *vma)\n{\n\tif (likely(vma->vm_flags & VM_WRITE))\n\t\tpmd = pmd_mkwrite(pmd);\n\treturn pmd;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pmd_mkwrite",
          "args": [
            "pmd"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "vma->vm_flags & VM_WRITE"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\npmd_t maybe_pmd_mkwrite(pmd_t pmd, struct vm_area_struct *vma)\n{\n\tif (likely(vma->vm_flags & VM_WRITE))\n\t\tpmd = pmd_mkwrite(pmd);\n\treturn pmd;\n}"
  },
  {
    "function_name": "setup_transparent_hugepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "446-474",
    "snippet": "static int __init setup_transparent_hugepage(char *str)\n{\n\tint ret = 0;\n\tif (!str)\n\t\tgoto out;\n\tif (!strcmp(str, \"always\")) {\n\t\tset_bit(TRANSPARENT_HUGEPAGE_FLAG,\n\t\t\t&transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG,\n\t\t\t  &transparent_hugepage_flags);\n\t\tret = 1;\n\t} else if (!strcmp(str, \"madvise\")) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_FLAG,\n\t\t\t  &transparent_hugepage_flags);\n\t\tset_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG,\n\t\t\t&transparent_hugepage_flags);\n\t\tret = 1;\n\t} else if (!strcmp(str, \"never\")) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_FLAG,\n\t\t\t  &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG,\n\t\t\t  &transparent_hugepage_flags);\n\t\tret = 1;\n\t}\nout:\n\tif (!ret)\n\t\tpr_warn(\"transparent_hugepage= cannot parse, ignored\\n\");\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"transparent_hugepage= cannot parse, ignored\\n\""
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG",
            "&transparent_hugepage_flags"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "clear_bit_unlock_is_negative_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1171-1176",
          "snippet": "static inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"never\""
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG",
            "&transparent_hugepage_flags"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"madvise\""
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "TRANSPARENT_HUGEPAGE_FLAG",
            "&transparent_hugepage_flags"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"always\""
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic int __init setup_transparent_hugepage(char *str)\n{\n\tint ret = 0;\n\tif (!str)\n\t\tgoto out;\n\tif (!strcmp(str, \"always\")) {\n\t\tset_bit(TRANSPARENT_HUGEPAGE_FLAG,\n\t\t\t&transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG,\n\t\t\t  &transparent_hugepage_flags);\n\t\tret = 1;\n\t} else if (!strcmp(str, \"madvise\")) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_FLAG,\n\t\t\t  &transparent_hugepage_flags);\n\t\tset_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG,\n\t\t\t&transparent_hugepage_flags);\n\t\tret = 1;\n\t} else if (!strcmp(str, \"never\")) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_FLAG,\n\t\t\t  &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG,\n\t\t\t  &transparent_hugepage_flags);\n\t\tret = 1;\n\t}\nout:\n\tif (!ret)\n\t\tpr_warn(\"transparent_hugepage= cannot parse, ignored\\n\");\n\treturn ret;\n}"
  },
  {
    "function_name": "hugepage_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "383-443",
    "snippet": "static int __init hugepage_init(void)\n{\n\tint err;\n\tstruct kobject *hugepage_kobj;\n\n\tif (!has_transparent_hugepage()) {\n\t\ttransparent_hugepage_flags = 0;\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * hugepages can't be allocated by the buddy allocator\n\t */\n\tMAYBE_BUILD_BUG_ON(HPAGE_PMD_ORDER >= MAX_ORDER);\n\t/*\n\t * we use page->mapping and page->index in second tail page\n\t * as list_head: assuming THP order >= 2\n\t */\n\tMAYBE_BUILD_BUG_ON(HPAGE_PMD_ORDER < 2);\n\n\terr = hugepage_init_sysfs(&hugepage_kobj);\n\tif (err)\n\t\tgoto err_sysfs;\n\n\terr = khugepaged_init();\n\tif (err)\n\t\tgoto err_slab;\n\n\terr = register_shrinker(&huge_zero_page_shrinker);\n\tif (err)\n\t\tgoto err_hzp_shrinker;\n\terr = register_shrinker(&deferred_split_shrinker);\n\tif (err)\n\t\tgoto err_split_shrinker;\n\n\t/*\n\t * By default disable transparent hugepages on smaller systems,\n\t * where the extra memory used could hurt more than TLB overhead\n\t * is likely to save.  The admin can still enable it through /sys.\n\t */\n\tif (totalram_pages < (512 << (20 - PAGE_SHIFT))) {\n\t\ttransparent_hugepage_flags = 0;\n\t\treturn 0;\n\t}\n\n\terr = start_stop_khugepaged();\n\tif (err)\n\t\tgoto err_khugepaged;\n\n\treturn 0;\nerr_khugepaged:\n\tunregister_shrinker(&deferred_split_shrinker);\nerr_split_shrinker:\n\tunregister_shrinker(&huge_zero_page_shrinker);\nerr_hzp_shrinker:\n\tkhugepaged_destroy();\nerr_slab:\n\thugepage_exit_sysfs(hugepage_kobj);\nerr_sysfs:\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct shrinker deferred_split_shrinker;",
      "static struct shrinker huge_zero_page_shrinker = {\n\t.count_objects = shrink_huge_zero_page_count,\n\t.scan_objects = shrink_huge_zero_page_scan,\n\t.seeks = DEFAULT_SEEKS,\n};",
      "static struct shrinker deferred_split_shrinker = {\n\t.count_objects = deferred_split_count,\n\t.scan_objects = deferred_split_scan,\n\t.seeks = DEFAULT_SEEKS,\n\t.flags = SHRINKER_NUMA_AWARE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hugepage_exit_sysfs",
          "args": [
            "hugepage_kobj"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "hugepage_exit_sysfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "378-380",
          "snippet": "static inline void hugepage_exit_sysfs(struct kobject *hugepage_kobj)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline void hugepage_exit_sysfs(struct kobject *hugepage_kobj)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "khugepaged_destroy",
          "args": [],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "360-363",
          "snippet": "void __init khugepaged_destroy(void)\n{\n\tkmem_cache_destroy(mm_slot_cache);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *mm_slot_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *mm_slot_cache;\n\nvoid __init khugepaged_destroy(void)\n{\n\tkmem_cache_destroy(mm_slot_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_shrinker",
          "args": [
            "&huge_zero_page_shrinker"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_shrinker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "432-443",
          "snippet": "void unregister_shrinker(struct shrinker *shrinker)\n{\n\tif (!shrinker->nr_deferred)\n\t\treturn;\n\tif (shrinker->flags & SHRINKER_MEMCG_AWARE)\n\t\tunregister_memcg_shrinker(shrinker);\n\tdown_write(&shrinker_rwsem);\n\tlist_del(&shrinker->list);\n\tup_write(&shrinker_rwsem);\n\tkfree(shrinker->nr_deferred);\n\tshrinker->nr_deferred = NULL;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(shrinker_rwsem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic DECLARE_RWSEM(shrinker_rwsem);\n\nvoid unregister_shrinker(struct shrinker *shrinker)\n{\n\tif (!shrinker->nr_deferred)\n\t\treturn;\n\tif (shrinker->flags & SHRINKER_MEMCG_AWARE)\n\t\tunregister_memcg_shrinker(shrinker);\n\tdown_write(&shrinker_rwsem);\n\tlist_del(&shrinker->list);\n\tup_write(&shrinker_rwsem);\n\tkfree(shrinker->nr_deferred);\n\tshrinker->nr_deferred = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_stop_khugepaged",
          "args": [],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "start_stop_khugepaged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "1886-1915",
          "snippet": "int start_stop_khugepaged(void)\n{\n\tstatic struct task_struct *khugepaged_thread __read_mostly;\n\tstatic DEFINE_MUTEX(khugepaged_mutex);\n\tint err = 0;\n\n\tmutex_lock(&khugepaged_mutex);\n\tif (khugepaged_enabled()) {\n\t\tif (!khugepaged_thread)\n\t\t\tkhugepaged_thread = kthread_run(khugepaged, NULL,\n\t\t\t\t\t\t\t\"khugepaged\");\n\t\tif (IS_ERR(khugepaged_thread)) {\n\t\t\tpr_err(\"khugepaged: kthread_run(khugepaged) failed\\n\");\n\t\t\terr = PTR_ERR(khugepaged_thread);\n\t\t\tkhugepaged_thread = NULL;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (!list_empty(&khugepaged_scan.mm_head))\n\t\t\twake_up_interruptible(&khugepaged_wait);\n\n\t\tset_recommended_min_free_kbytes();\n\t} else if (khugepaged_thread) {\n\t\tkthread_stop(khugepaged_thread);\n\t\tkhugepaged_thread = NULL;\n\t}\nfail:\n\tmutex_unlock(&khugepaged_mutex);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(khugepaged_wait);",
            "static struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(khugepaged_wait);\nstatic struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};\n\nint start_stop_khugepaged(void)\n{\n\tstatic struct task_struct *khugepaged_thread __read_mostly;\n\tstatic DEFINE_MUTEX(khugepaged_mutex);\n\tint err = 0;\n\n\tmutex_lock(&khugepaged_mutex);\n\tif (khugepaged_enabled()) {\n\t\tif (!khugepaged_thread)\n\t\t\tkhugepaged_thread = kthread_run(khugepaged, NULL,\n\t\t\t\t\t\t\t\"khugepaged\");\n\t\tif (IS_ERR(khugepaged_thread)) {\n\t\t\tpr_err(\"khugepaged: kthread_run(khugepaged) failed\\n\");\n\t\t\terr = PTR_ERR(khugepaged_thread);\n\t\t\tkhugepaged_thread = NULL;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (!list_empty(&khugepaged_scan.mm_head))\n\t\t\twake_up_interruptible(&khugepaged_wait);\n\n\t\tset_recommended_min_free_kbytes();\n\t} else if (khugepaged_thread) {\n\t\tkthread_stop(khugepaged_thread);\n\t\tkhugepaged_thread = NULL;\n\t}\nfail:\n\tmutex_unlock(&khugepaged_mutex);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "khugepaged_init",
          "args": [],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "345-358",
          "snippet": "int __init khugepaged_init(void)\n{\n\tmm_slot_cache = kmem_cache_create(\"khugepaged_mm_slot\",\n\t\t\t\t\t  sizeof(struct mm_slot),\n\t\t\t\t\t  __alignof__(struct mm_slot), 0, NULL);\n\tif (!mm_slot_cache)\n\t\treturn -ENOMEM;\n\n\tkhugepaged_pages_to_scan = HPAGE_PMD_NR * 8;\n\tkhugepaged_max_ptes_none = HPAGE_PMD_NR - 1;\n\tkhugepaged_max_ptes_swap = HPAGE_PMD_NR / 8;\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int khugepaged_pages_to_scan",
            "static unsigned int khugepaged_max_ptes_none",
            "static unsigned int khugepaged_max_ptes_swap",
            "static struct kmem_cache *mm_slot_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_pages_to_scan;\nstatic unsigned int khugepaged_max_ptes_none;\nstatic unsigned int khugepaged_max_ptes_swap;\nstatic struct kmem_cache *mm_slot_cache;\n\nint __init khugepaged_init(void)\n{\n\tmm_slot_cache = kmem_cache_create(\"khugepaged_mm_slot\",\n\t\t\t\t\t  sizeof(struct mm_slot),\n\t\t\t\t\t  __alignof__(struct mm_slot), 0, NULL);\n\tif (!mm_slot_cache)\n\t\treturn -ENOMEM;\n\n\tkhugepaged_pages_to_scan = HPAGE_PMD_NR * 8;\n\tkhugepaged_max_ptes_none = HPAGE_PMD_NR - 1;\n\tkhugepaged_max_ptes_swap = HPAGE_PMD_NR / 8;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugepage_init_sysfs",
          "args": [
            "&hugepage_kobj"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "hugepage_init_sysfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "373-376",
          "snippet": "static inline int hugepage_init_sysfs(struct kobject **hugepage_kobj)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline int hugepage_init_sysfs(struct kobject **hugepage_kobj)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAYBE_BUILD_BUG_ON",
          "args": [
            "HPAGE_PMD_ORDER < 2"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAYBE_BUILD_BUG_ON",
          "args": [
            "HPAGE_PMD_ORDER >= MAX_ORDER"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_transparent_hugepage",
          "args": [],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic struct shrinker deferred_split_shrinker;\nstatic struct shrinker huge_zero_page_shrinker = {\n\t.count_objects = shrink_huge_zero_page_count,\n\t.scan_objects = shrink_huge_zero_page_scan,\n\t.seeks = DEFAULT_SEEKS,\n};\nstatic struct shrinker deferred_split_shrinker = {\n\t.count_objects = deferred_split_count,\n\t.scan_objects = deferred_split_scan,\n\t.seeks = DEFAULT_SEEKS,\n\t.flags = SHRINKER_NUMA_AWARE,\n};\n\nstatic int __init hugepage_init(void)\n{\n\tint err;\n\tstruct kobject *hugepage_kobj;\n\n\tif (!has_transparent_hugepage()) {\n\t\ttransparent_hugepage_flags = 0;\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * hugepages can't be allocated by the buddy allocator\n\t */\n\tMAYBE_BUILD_BUG_ON(HPAGE_PMD_ORDER >= MAX_ORDER);\n\t/*\n\t * we use page->mapping and page->index in second tail page\n\t * as list_head: assuming THP order >= 2\n\t */\n\tMAYBE_BUILD_BUG_ON(HPAGE_PMD_ORDER < 2);\n\n\terr = hugepage_init_sysfs(&hugepage_kobj);\n\tif (err)\n\t\tgoto err_sysfs;\n\n\terr = khugepaged_init();\n\tif (err)\n\t\tgoto err_slab;\n\n\terr = register_shrinker(&huge_zero_page_shrinker);\n\tif (err)\n\t\tgoto err_hzp_shrinker;\n\terr = register_shrinker(&deferred_split_shrinker);\n\tif (err)\n\t\tgoto err_split_shrinker;\n\n\t/*\n\t * By default disable transparent hugepages on smaller systems,\n\t * where the extra memory used could hurt more than TLB overhead\n\t * is likely to save.  The admin can still enable it through /sys.\n\t */\n\tif (totalram_pages < (512 << (20 - PAGE_SHIFT))) {\n\t\ttransparent_hugepage_flags = 0;\n\t\treturn 0;\n\t}\n\n\terr = start_stop_khugepaged();\n\tif (err)\n\t\tgoto err_khugepaged;\n\n\treturn 0;\nerr_khugepaged:\n\tunregister_shrinker(&deferred_split_shrinker);\nerr_split_shrinker:\n\tunregister_shrinker(&huge_zero_page_shrinker);\nerr_hzp_shrinker:\n\tkhugepaged_destroy();\nerr_slab:\n\thugepage_exit_sysfs(hugepage_kobj);\nerr_sysfs:\n\treturn err;\n}"
  },
  {
    "function_name": "hugepage_exit_sysfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "378-380",
    "snippet": "static inline void hugepage_exit_sysfs(struct kobject *hugepage_kobj)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline void hugepage_exit_sysfs(struct kobject *hugepage_kobj)\n{\n}"
  },
  {
    "function_name": "hugepage_init_sysfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "373-376",
    "snippet": "static inline int hugepage_init_sysfs(struct kobject **hugepage_kobj)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline int hugepage_init_sysfs(struct kobject **hugepage_kobj)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "hugepage_exit_sysfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "366-371",
    "snippet": "static void __init hugepage_exit_sysfs(struct kobject *hugepage_kobj)\n{\n\tsysfs_remove_group(hugepage_kobj, &khugepaged_attr_group);\n\tsysfs_remove_group(hugepage_kobj, &hugepage_attr_group);\n\tkobject_put(hugepage_kobj);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "hugepage_kobj"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_remove_group",
          "args": [
            "hugepage_kobj",
            "&hugepage_attr_group"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_remove_group",
          "args": [
            "hugepage_kobj",
            "&khugepaged_attr_group"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void __init hugepage_exit_sysfs(struct kobject *hugepage_kobj)\n{\n\tsysfs_remove_group(hugepage_kobj, &khugepaged_attr_group);\n\tsysfs_remove_group(hugepage_kobj, &hugepage_attr_group);\n\tkobject_put(hugepage_kobj);\n}"
  },
  {
    "function_name": "hugepage_init_sysfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "335-364",
    "snippet": "static int __init hugepage_init_sysfs(struct kobject **hugepage_kobj)\n{\n\tint err;\n\n\t*hugepage_kobj = kobject_create_and_add(\"transparent_hugepage\", mm_kobj);\n\tif (unlikely(!*hugepage_kobj)) {\n\t\tpr_err(\"failed to create transparent hugepage kobject\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\terr = sysfs_create_group(*hugepage_kobj, &hugepage_attr_group);\n\tif (err) {\n\t\tpr_err(\"failed to register transparent hugepage group\\n\");\n\t\tgoto delete_obj;\n\t}\n\n\terr = sysfs_create_group(*hugepage_kobj, &khugepaged_attr_group);\n\tif (err) {\n\t\tpr_err(\"failed to register transparent hugepage group\\n\");\n\t\tgoto remove_hp_group;\n\t}\n\n\treturn 0;\n\nremove_hp_group:\n\tsysfs_remove_group(*hugepage_kobj, &hugepage_attr_group);\ndelete_obj:\n\tkobject_put(*hugepage_kobj);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "*hugepage_kobj"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_remove_group",
          "args": [
            "*hugepage_kobj",
            "&hugepage_attr_group"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to register transparent hugepage group\\n\""
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_create_group",
          "args": [
            "*hugepage_kobj",
            "&khugepaged_attr_group"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to register transparent hugepage group\\n\""
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_create_group",
          "args": [
            "*hugepage_kobj",
            "&hugepage_attr_group"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to create transparent hugepage kobject\\n\""
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!*hugepage_kobj"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_create_and_add",
          "args": [
            "\"transparent_hugepage\"",
            "mm_kobj"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic int __init hugepage_init_sysfs(struct kobject **hugepage_kobj)\n{\n\tint err;\n\n\t*hugepage_kobj = kobject_create_and_add(\"transparent_hugepage\", mm_kobj);\n\tif (unlikely(!*hugepage_kobj)) {\n\t\tpr_err(\"failed to create transparent hugepage kobject\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\terr = sysfs_create_group(*hugepage_kobj, &hugepage_attr_group);\n\tif (err) {\n\t\tpr_err(\"failed to register transparent hugepage group\\n\");\n\t\tgoto delete_obj;\n\t}\n\n\terr = sysfs_create_group(*hugepage_kobj, &khugepaged_attr_group);\n\tif (err) {\n\t\tpr_err(\"failed to register transparent hugepage group\\n\");\n\t\tgoto remove_hp_group;\n\t}\n\n\treturn 0;\n\nremove_hp_group:\n\tsysfs_remove_group(*hugepage_kobj, &hugepage_attr_group);\ndelete_obj:\n\tkobject_put(*hugepage_kobj);\n\treturn err;\n}"
  },
  {
    "function_name": "debug_cow_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "306-312",
    "snippet": "static ssize_t debug_cow_store(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\treturn single_hugepage_flag_store(kobj, attr, buf, count,\n\t\t\t\t TRANSPARENT_HUGEPAGE_DEBUG_COW_FLAG);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_hugepage_flag_store",
          "args": [
            "kobj",
            "attr",
            "buf",
            "count",
            "TRANSPARENT_HUGEPAGE_DEBUG_COW_FLAG"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "single_hugepage_flag_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "198-218",
          "snippet": "ssize_t single_hugepage_flag_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t count,\n\t\t\t\t enum transparent_hugepage_flag flag)\n{\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (value > 1)\n\t\treturn -EINVAL;\n\n\tif (value)\n\t\tset_bit(flag, &transparent_hugepage_flags);\n\telse\n\t\tclear_bit(flag, &transparent_hugepage_flags);\n\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nssize_t single_hugepage_flag_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t count,\n\t\t\t\t enum transparent_hugepage_flag flag)\n{\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (value > 1)\n\t\treturn -EINVAL;\n\n\tif (value)\n\t\tset_bit(flag, &transparent_hugepage_flags);\n\telse\n\t\tclear_bit(flag, &transparent_hugepage_flags);\n\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic ssize_t debug_cow_store(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\treturn single_hugepage_flag_store(kobj, attr, buf, count,\n\t\t\t\t TRANSPARENT_HUGEPAGE_DEBUG_COW_FLAG);\n}"
  },
  {
    "function_name": "debug_cow_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "300-305",
    "snippet": "static ssize_t debug_cow_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\treturn single_hugepage_flag_show(kobj, attr, buf,\n\t\t\t\tTRANSPARENT_HUGEPAGE_DEBUG_COW_FLAG);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_hugepage_flag_show",
          "args": [
            "kobj",
            "attr",
            "buf",
            "TRANSPARENT_HUGEPAGE_DEBUG_COW_FLAG"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "single_hugepage_flag_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "190-196",
          "snippet": "ssize_t single_hugepage_flag_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, char *buf,\n\t\t\t\tenum transparent_hugepage_flag flag)\n{\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       !!test_bit(flag, &transparent_hugepage_flags));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nssize_t single_hugepage_flag_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, char *buf,\n\t\t\t\tenum transparent_hugepage_flag flag)\n{\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       !!test_bit(flag, &transparent_hugepage_flags));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic ssize_t debug_cow_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\treturn single_hugepage_flag_show(kobj, attr, buf,\n\t\t\t\tTRANSPARENT_HUGEPAGE_DEBUG_COW_FLAG);\n}"
  },
  {
    "function_name": "hpage_pmd_size_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "291-295",
    "snippet": "static ssize_t hpage_pmd_size_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", HPAGE_PMD_SIZE);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%lu\\n\"",
            "HPAGE_PMD_SIZE"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic ssize_t hpage_pmd_size_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", HPAGE_PMD_SIZE);\n}"
  },
  {
    "function_name": "use_zero_page_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "282-287",
    "snippet": "static ssize_t use_zero_page_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\treturn single_hugepage_flag_store(kobj, attr, buf, count,\n\t\t\t\t TRANSPARENT_HUGEPAGE_USE_ZERO_PAGE_FLAG);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_hugepage_flag_store",
          "args": [
            "kobj",
            "attr",
            "buf",
            "count",
            "TRANSPARENT_HUGEPAGE_USE_ZERO_PAGE_FLAG"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "single_hugepage_flag_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "198-218",
          "snippet": "ssize_t single_hugepage_flag_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t count,\n\t\t\t\t enum transparent_hugepage_flag flag)\n{\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (value > 1)\n\t\treturn -EINVAL;\n\n\tif (value)\n\t\tset_bit(flag, &transparent_hugepage_flags);\n\telse\n\t\tclear_bit(flag, &transparent_hugepage_flags);\n\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nssize_t single_hugepage_flag_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t count,\n\t\t\t\t enum transparent_hugepage_flag flag)\n{\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (value > 1)\n\t\treturn -EINVAL;\n\n\tif (value)\n\t\tset_bit(flag, &transparent_hugepage_flags);\n\telse\n\t\tclear_bit(flag, &transparent_hugepage_flags);\n\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic ssize_t use_zero_page_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\treturn single_hugepage_flag_store(kobj, attr, buf, count,\n\t\t\t\t TRANSPARENT_HUGEPAGE_USE_ZERO_PAGE_FLAG);\n}"
  },
  {
    "function_name": "use_zero_page_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "276-281",
    "snippet": "static ssize_t use_zero_page_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\treturn single_hugepage_flag_show(kobj, attr, buf,\n\t\t\t\tTRANSPARENT_HUGEPAGE_USE_ZERO_PAGE_FLAG);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_hugepage_flag_show",
          "args": [
            "kobj",
            "attr",
            "buf",
            "TRANSPARENT_HUGEPAGE_USE_ZERO_PAGE_FLAG"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "single_hugepage_flag_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "190-196",
          "snippet": "ssize_t single_hugepage_flag_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, char *buf,\n\t\t\t\tenum transparent_hugepage_flag flag)\n{\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       !!test_bit(flag, &transparent_hugepage_flags));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nssize_t single_hugepage_flag_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, char *buf,\n\t\t\t\tenum transparent_hugepage_flag flag)\n{\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       !!test_bit(flag, &transparent_hugepage_flags));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic ssize_t use_zero_page_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\treturn single_hugepage_flag_show(kobj, attr, buf,\n\t\t\t\tTRANSPARENT_HUGEPAGE_USE_ZERO_PAGE_FLAG);\n}"
  },
  {
    "function_name": "defrag_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "234-272",
    "snippet": "static ssize_t defrag_store(struct kobject *kobj,\n\t\t\t    struct kobj_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tif (!memcmp(\"always\", buf,\n\t\t    min(sizeof(\"always\")-1, count))) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags);\n\t\tset_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags);\n\t} else if (!memcmp(\"defer+madvise\", buf,\n\t\t    min(sizeof(\"defer+madvise\")-1, count))) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags);\n\t\tset_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags);\n\t} else if (!memcmp(\"defer\", buf,\n\t\t    min(sizeof(\"defer\")-1, count))) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags);\n\t\tset_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags);\n\t} else if (!memcmp(\"madvise\", buf,\n\t\t\t   min(sizeof(\"madvise\")-1, count))) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags);\n\t\tset_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags);\n\t} else if (!memcmp(\"never\", buf,\n\t\t\t   min(sizeof(\"never\")-1, count))) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags);\n\t} else\n\t\treturn -EINVAL;\n\n\treturn count;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG",
            "&transparent_hugepage_flags"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "clear_bit_unlock_is_negative_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1171-1176",
          "snippet": "static inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "\"never\"",
            "buf",
            "min(sizeof(\"never\")-1, count)"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "sizeof(\"never\")-1",
            "count"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG",
            "&transparent_hugepage_flags"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "\"madvise\"",
            "buf",
            "min(sizeof(\"madvise\")-1, count)"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG",
            "&transparent_hugepage_flags"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "\"defer\"",
            "buf",
            "min(sizeof(\"defer\")-1, count)"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG",
            "&transparent_hugepage_flags"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "\"defer+madvise\"",
            "buf",
            "min(sizeof(\"defer+madvise\")-1, count)"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG",
            "&transparent_hugepage_flags"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "\"always\"",
            "buf",
            "min(sizeof(\"always\")-1, count)"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic ssize_t defrag_store(struct kobject *kobj,\n\t\t\t    struct kobj_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tif (!memcmp(\"always\", buf,\n\t\t    min(sizeof(\"always\")-1, count))) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags);\n\t\tset_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags);\n\t} else if (!memcmp(\"defer+madvise\", buf,\n\t\t    min(sizeof(\"defer+madvise\")-1, count))) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags);\n\t\tset_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags);\n\t} else if (!memcmp(\"defer\", buf,\n\t\t    min(sizeof(\"defer\")-1, count))) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags);\n\t\tset_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags);\n\t} else if (!memcmp(\"madvise\", buf,\n\t\t\t   min(sizeof(\"madvise\")-1, count))) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags);\n\t\tset_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags);\n\t} else if (!memcmp(\"never\", buf,\n\t\t\t   min(sizeof(\"never\")-1, count))) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags);\n\t} else\n\t\treturn -EINVAL;\n\n\treturn count;\n}"
  },
  {
    "function_name": "defrag_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "220-232",
    "snippet": "static ssize_t defrag_show(struct kobject *kobj,\n\t\t\t   struct kobj_attribute *attr, char *buf)\n{\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags))\n\t\treturn sprintf(buf, \"[always] defer defer+madvise madvise never\\n\");\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags))\n\t\treturn sprintf(buf, \"always [defer] defer+madvise madvise never\\n\");\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags))\n\t\treturn sprintf(buf, \"always defer [defer+madvise] madvise never\\n\");\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags))\n\t\treturn sprintf(buf, \"always defer defer+madvise [madvise] never\\n\");\n\treturn sprintf(buf, \"always defer defer+madvise madvise [never]\\n\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"always defer defer+madvise madvise [never]\\n\""
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"always defer defer+madvise [madvise] never\\n\""
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG",
            "&transparent_hugepage_flags"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"always defer [defer+madvise] madvise never\\n\""
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG",
            "&transparent_hugepage_flags"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"always [defer] defer+madvise madvise never\\n\""
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG",
            "&transparent_hugepage_flags"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"[always] defer defer+madvise madvise never\\n\""
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG",
            "&transparent_hugepage_flags"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic ssize_t defrag_show(struct kobject *kobj,\n\t\t\t   struct kobj_attribute *attr, char *buf)\n{\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG, &transparent_hugepage_flags))\n\t\treturn sprintf(buf, \"[always] defer defer+madvise madvise never\\n\");\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG, &transparent_hugepage_flags))\n\t\treturn sprintf(buf, \"always [defer] defer+madvise madvise never\\n\");\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG, &transparent_hugepage_flags))\n\t\treturn sprintf(buf, \"always defer [defer+madvise] madvise never\\n\");\n\tif (test_bit(TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG, &transparent_hugepage_flags))\n\t\treturn sprintf(buf, \"always defer defer+madvise [madvise] never\\n\");\n\treturn sprintf(buf, \"always defer defer+madvise madvise [never]\\n\");\n}"
  },
  {
    "function_name": "single_hugepage_flag_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "198-218",
    "snippet": "ssize_t single_hugepage_flag_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t count,\n\t\t\t\t enum transparent_hugepage_flag flag)\n{\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (value > 1)\n\t\treturn -EINVAL;\n\n\tif (value)\n\t\tset_bit(flag, &transparent_hugepage_flags);\n\telse\n\t\tclear_bit(flag, &transparent_hugepage_flags);\n\n\treturn count;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "flag",
            "&transparent_hugepage_flags"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "clear_bit_unlock_is_negative_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1171-1176",
          "snippet": "static inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "flag",
            "&transparent_hugepage_flags"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "buf",
            "10",
            "&value"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nssize_t single_hugepage_flag_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t count,\n\t\t\t\t enum transparent_hugepage_flag flag)\n{\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (value > 1)\n\t\treturn -EINVAL;\n\n\tif (value)\n\t\tset_bit(flag, &transparent_hugepage_flags);\n\telse\n\t\tclear_bit(flag, &transparent_hugepage_flags);\n\n\treturn count;\n}"
  },
  {
    "function_name": "single_hugepage_flag_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "190-196",
    "snippet": "ssize_t single_hugepage_flag_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, char *buf,\n\t\t\t\tenum transparent_hugepage_flag flag)\n{\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       !!test_bit(flag, &transparent_hugepage_flags));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "!!test_bit(flag, &transparent_hugepage_flags)"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "flag",
            "&transparent_hugepage_flags"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nssize_t single_hugepage_flag_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, char *buf,\n\t\t\t\tenum transparent_hugepage_flag flag)\n{\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       !!test_bit(flag, &transparent_hugepage_flags));\n}"
  },
  {
    "function_name": "enabled_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "159-186",
    "snippet": "static ssize_t enabled_store(struct kobject *kobj,\n\t\t\t     struct kobj_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tssize_t ret = count;\n\n\tif (!memcmp(\"always\", buf,\n\t\t    min(sizeof(\"always\")-1, count))) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG, &transparent_hugepage_flags);\n\t\tset_bit(TRANSPARENT_HUGEPAGE_FLAG, &transparent_hugepage_flags);\n\t} else if (!memcmp(\"madvise\", buf,\n\t\t\t   min(sizeof(\"madvise\")-1, count))) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_FLAG, &transparent_hugepage_flags);\n\t\tset_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG, &transparent_hugepage_flags);\n\t} else if (!memcmp(\"never\", buf,\n\t\t\t   min(sizeof(\"never\")-1, count))) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG, &transparent_hugepage_flags);\n\t} else\n\t\tret = -EINVAL;\n\n\tif (ret > 0) {\n\t\tint err = start_stop_khugepaged();\n\t\tif (err)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_stop_khugepaged",
          "args": [],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "start_stop_khugepaged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "1886-1915",
          "snippet": "int start_stop_khugepaged(void)\n{\n\tstatic struct task_struct *khugepaged_thread __read_mostly;\n\tstatic DEFINE_MUTEX(khugepaged_mutex);\n\tint err = 0;\n\n\tmutex_lock(&khugepaged_mutex);\n\tif (khugepaged_enabled()) {\n\t\tif (!khugepaged_thread)\n\t\t\tkhugepaged_thread = kthread_run(khugepaged, NULL,\n\t\t\t\t\t\t\t\"khugepaged\");\n\t\tif (IS_ERR(khugepaged_thread)) {\n\t\t\tpr_err(\"khugepaged: kthread_run(khugepaged) failed\\n\");\n\t\t\terr = PTR_ERR(khugepaged_thread);\n\t\t\tkhugepaged_thread = NULL;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (!list_empty(&khugepaged_scan.mm_head))\n\t\t\twake_up_interruptible(&khugepaged_wait);\n\n\t\tset_recommended_min_free_kbytes();\n\t} else if (khugepaged_thread) {\n\t\tkthread_stop(khugepaged_thread);\n\t\tkhugepaged_thread = NULL;\n\t}\nfail:\n\tmutex_unlock(&khugepaged_mutex);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(khugepaged_wait);",
            "static struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(khugepaged_wait);\nstatic struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};\n\nint start_stop_khugepaged(void)\n{\n\tstatic struct task_struct *khugepaged_thread __read_mostly;\n\tstatic DEFINE_MUTEX(khugepaged_mutex);\n\tint err = 0;\n\n\tmutex_lock(&khugepaged_mutex);\n\tif (khugepaged_enabled()) {\n\t\tif (!khugepaged_thread)\n\t\t\tkhugepaged_thread = kthread_run(khugepaged, NULL,\n\t\t\t\t\t\t\t\"khugepaged\");\n\t\tif (IS_ERR(khugepaged_thread)) {\n\t\t\tpr_err(\"khugepaged: kthread_run(khugepaged) failed\\n\");\n\t\t\terr = PTR_ERR(khugepaged_thread);\n\t\t\tkhugepaged_thread = NULL;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (!list_empty(&khugepaged_scan.mm_head))\n\t\t\twake_up_interruptible(&khugepaged_wait);\n\n\t\tset_recommended_min_free_kbytes();\n\t} else if (khugepaged_thread) {\n\t\tkthread_stop(khugepaged_thread);\n\t\tkhugepaged_thread = NULL;\n\t}\nfail:\n\tmutex_unlock(&khugepaged_mutex);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG",
            "&transparent_hugepage_flags"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "clear_bit_unlock_is_negative_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1171-1176",
          "snippet": "static inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "\"never\"",
            "buf",
            "min(sizeof(\"never\")-1, count)"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "sizeof(\"never\")-1",
            "count"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG",
            "&transparent_hugepage_flags"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "\"madvise\"",
            "buf",
            "min(sizeof(\"madvise\")-1, count)"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "TRANSPARENT_HUGEPAGE_FLAG",
            "&transparent_hugepage_flags"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "\"always\"",
            "buf",
            "min(sizeof(\"always\")-1, count)"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic ssize_t enabled_store(struct kobject *kobj,\n\t\t\t     struct kobj_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tssize_t ret = count;\n\n\tif (!memcmp(\"always\", buf,\n\t\t    min(sizeof(\"always\")-1, count))) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG, &transparent_hugepage_flags);\n\t\tset_bit(TRANSPARENT_HUGEPAGE_FLAG, &transparent_hugepage_flags);\n\t} else if (!memcmp(\"madvise\", buf,\n\t\t\t   min(sizeof(\"madvise\")-1, count))) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_FLAG, &transparent_hugepage_flags);\n\t\tset_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG, &transparent_hugepage_flags);\n\t} else if (!memcmp(\"never\", buf,\n\t\t\t   min(sizeof(\"never\")-1, count))) {\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_FLAG, &transparent_hugepage_flags);\n\t\tclear_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG, &transparent_hugepage_flags);\n\t} else\n\t\tret = -EINVAL;\n\n\tif (ret > 0) {\n\t\tint err = start_stop_khugepaged();\n\t\tif (err)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "enabled_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "148-157",
    "snippet": "static ssize_t enabled_show(struct kobject *kobj,\n\t\t\t    struct kobj_attribute *attr, char *buf)\n{\n\tif (test_bit(TRANSPARENT_HUGEPAGE_FLAG, &transparent_hugepage_flags))\n\t\treturn sprintf(buf, \"[always] madvise never\\n\");\n\telse if (test_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG, &transparent_hugepage_flags))\n\t\treturn sprintf(buf, \"always [madvise] never\\n\");\n\telse\n\t\treturn sprintf(buf, \"always madvise [never]\\n\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"always madvise [never]\\n\""
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"always [madvise] never\\n\""
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG",
            "&transparent_hugepage_flags"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"[always] madvise never\\n\""
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "TRANSPARENT_HUGEPAGE_FLAG",
            "&transparent_hugepage_flags"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic ssize_t enabled_show(struct kobject *kobj,\n\t\t\t    struct kobj_attribute *attr, char *buf)\n{\n\tif (test_bit(TRANSPARENT_HUGEPAGE_FLAG, &transparent_hugepage_flags))\n\t\treturn sprintf(buf, \"[always] madvise never\\n\");\n\telse if (test_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG, &transparent_hugepage_flags))\n\t\treturn sprintf(buf, \"always [madvise] never\\n\");\n\telse\n\t\treturn sprintf(buf, \"always madvise [never]\\n\");\n}"
  },
  {
    "function_name": "shrink_huge_zero_page_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "128-139",
    "snippet": "static unsigned long shrink_huge_zero_page_scan(struct shrinker *shrink,\n\t\t\t\t       struct shrink_control *sc)\n{\n\tif (atomic_cmpxchg(&huge_zero_refcount, 1, 0) == 1) {\n\t\tstruct page *zero_page = xchg(&huge_zero_page, NULL);\n\t\tBUG_ON(zero_page == NULL);\n\t\t__free_pages(zero_page, compound_order(zero_page));\n\t\treturn HPAGE_PMD_NR;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t huge_zero_refcount;",
      "struct page *huge_zero_page"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "zero_page",
            "compound_order(zero_page)"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "__free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4430-4438",
          "snippet": "void __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "zero_page"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "zero_page == NULL"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&huge_zero_page",
            "NULL"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "page_cpupid_xchg_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmzone.c",
          "lines": "100-114",
          "snippet": "int page_cpupid_xchg_last(struct page *page, int cpupid)\n{\n\tunsigned long old_flags, flags;\n\tint last_cpupid;\n\n\tdo {\n\t\told_flags = flags = page->flags;\n\t\tlast_cpupid = page_cpupid_last(page);\n\n\t\tflags &= ~(LAST_CPUPID_MASK << LAST_CPUPID_PGSHIFT);\n\t\tflags |= (cpupid & LAST_CPUPID_MASK) << LAST_CPUPID_PGSHIFT;\n\t} while (unlikely(cmpxchg(&page->flags, old_flags, flags) != old_flags));\n\n\treturn last_cpupid;\n}",
          "includes": [
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint page_cpupid_xchg_last(struct page *page, int cpupid)\n{\n\tunsigned long old_flags, flags;\n\tint last_cpupid;\n\n\tdo {\n\t\told_flags = flags = page->flags;\n\t\tlast_cpupid = page_cpupid_last(page);\n\n\t\tflags &= ~(LAST_CPUPID_MASK << LAST_CPUPID_PGSHIFT);\n\t\tflags |= (cpupid & LAST_CPUPID_MASK) << LAST_CPUPID_PGSHIFT;\n\t} while (unlikely(cmpxchg(&page->flags, old_flags, flags) != old_flags));\n\n\treturn last_cpupid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_cmpxchg",
          "args": [
            "&huge_zero_refcount",
            "1",
            "0"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic atomic_t huge_zero_refcount;\nstruct page *huge_zero_page;\n\nstatic unsigned long shrink_huge_zero_page_scan(struct shrinker *shrink,\n\t\t\t\t       struct shrink_control *sc)\n{\n\tif (atomic_cmpxchg(&huge_zero_refcount, 1, 0) == 1) {\n\t\tstruct page *zero_page = xchg(&huge_zero_page, NULL);\n\t\tBUG_ON(zero_page == NULL);\n\t\t__free_pages(zero_page, compound_order(zero_page));\n\t\treturn HPAGE_PMD_NR;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "shrink_huge_zero_page_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "121-126",
    "snippet": "static unsigned long shrink_huge_zero_page_count(struct shrinker *shrink,\n\t\t\t\t\tstruct shrink_control *sc)\n{\n\t/* we can free zero page only if last reference remains */\n\treturn atomic_read(&huge_zero_refcount) == 1 ? HPAGE_PMD_NR : 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t huge_zero_refcount;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&huge_zero_refcount"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic atomic_t huge_zero_refcount;\n\nstatic unsigned long shrink_huge_zero_page_count(struct shrinker *shrink,\n\t\t\t\t\tstruct shrink_control *sc)\n{\n\t/* we can free zero page only if last reference remains */\n\treturn atomic_read(&huge_zero_refcount) == 1 ? HPAGE_PMD_NR : 0;\n}"
  },
  {
    "function_name": "mm_put_huge_zero_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "115-119",
    "snippet": "void mm_put_huge_zero_page(struct mm_struct *mm)\n{\n\tif (test_bit(MMF_HUGE_ZERO_PAGE, &mm->flags))\n\t\tput_huge_zero_page();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_huge_zero_page",
          "args": [],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "put_huge_zero_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "92-99",
          "snippet": "static void put_huge_zero_page(void)\n{\n\t/*\n\t * Counter should never go to zero here. Only shrinker can put\n\t * last reference.\n\t */\n\tBUG_ON(atomic_dec_and_test(&huge_zero_refcount));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t huge_zero_refcount;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic atomic_t huge_zero_refcount;\n\nstatic void put_huge_zero_page(void)\n{\n\t/*\n\t * Counter should never go to zero here. Only shrinker can put\n\t * last reference.\n\t */\n\tBUG_ON(atomic_dec_and_test(&huge_zero_refcount));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "MMF_HUGE_ZERO_PAGE",
            "&mm->flags"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid mm_put_huge_zero_page(struct mm_struct *mm)\n{\n\tif (test_bit(MMF_HUGE_ZERO_PAGE, &mm->flags))\n\t\tput_huge_zero_page();\n}"
  },
  {
    "function_name": "mm_get_huge_zero_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "101-113",
    "snippet": "struct page *mm_get_huge_zero_page(struct mm_struct *mm)\n{\n\tif (test_bit(MMF_HUGE_ZERO_PAGE, &mm->flags))\n\t\treturn READ_ONCE(huge_zero_page);\n\n\tif (!get_huge_zero_page())\n\t\treturn NULL;\n\n\tif (test_and_set_bit(MMF_HUGE_ZERO_PAGE, &mm->flags))\n\t\tput_huge_zero_page();\n\n\treturn READ_ONCE(huge_zero_page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct page *huge_zero_page"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "huge_zero_page"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_huge_zero_page",
          "args": [],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "put_huge_zero_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "92-99",
          "snippet": "static void put_huge_zero_page(void)\n{\n\t/*\n\t * Counter should never go to zero here. Only shrinker can put\n\t * last reference.\n\t */\n\tBUG_ON(atomic_dec_and_test(&huge_zero_refcount));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t huge_zero_refcount;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic atomic_t huge_zero_refcount;\n\nstatic void put_huge_zero_page(void)\n{\n\t/*\n\t * Counter should never go to zero here. Only shrinker can put\n\t * last reference.\n\t */\n\tBUG_ON(atomic_dec_and_test(&huge_zero_refcount));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "MMF_HUGE_ZERO_PAGE",
            "&mm->flags"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_huge_zero_page",
          "args": [],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "get_huge_zero_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "65-90",
          "snippet": "static struct page *get_huge_zero_page(void)\n{\n\tstruct page *zero_page;\nretry:\n\tif (likely(atomic_inc_not_zero(&huge_zero_refcount)))\n\t\treturn READ_ONCE(huge_zero_page);\n\n\tzero_page = alloc_pages((GFP_TRANSHUGE | __GFP_ZERO) & ~__GFP_MOVABLE,\n\t\t\tHPAGE_PMD_ORDER);\n\tif (!zero_page) {\n\t\tcount_vm_event(THP_ZERO_PAGE_ALLOC_FAILED);\n\t\treturn NULL;\n\t}\n\tcount_vm_event(THP_ZERO_PAGE_ALLOC);\n\tpreempt_disable();\n\tif (cmpxchg(&huge_zero_page, NULL, zero_page)) {\n\t\tpreempt_enable();\n\t\t__free_pages(zero_page, compound_order(zero_page));\n\t\tgoto retry;\n\t}\n\n\t/* We take additional reference here. It will be put back by shrinker */\n\tatomic_set(&huge_zero_refcount, 2);\n\tpreempt_enable();\n\treturn READ_ONCE(huge_zero_page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t huge_zero_refcount;",
            "struct page *huge_zero_page"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic atomic_t huge_zero_refcount;\nstruct page *huge_zero_page;\n\nstatic struct page *get_huge_zero_page(void)\n{\n\tstruct page *zero_page;\nretry:\n\tif (likely(atomic_inc_not_zero(&huge_zero_refcount)))\n\t\treturn READ_ONCE(huge_zero_page);\n\n\tzero_page = alloc_pages((GFP_TRANSHUGE | __GFP_ZERO) & ~__GFP_MOVABLE,\n\t\t\tHPAGE_PMD_ORDER);\n\tif (!zero_page) {\n\t\tcount_vm_event(THP_ZERO_PAGE_ALLOC_FAILED);\n\t\treturn NULL;\n\t}\n\tcount_vm_event(THP_ZERO_PAGE_ALLOC);\n\tpreempt_disable();\n\tif (cmpxchg(&huge_zero_page, NULL, zero_page)) {\n\t\tpreempt_enable();\n\t\t__free_pages(zero_page, compound_order(zero_page));\n\t\tgoto retry;\n\t}\n\n\t/* We take additional reference here. It will be put back by shrinker */\n\tatomic_set(&huge_zero_refcount, 2);\n\tpreempt_enable();\n\treturn READ_ONCE(huge_zero_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "huge_zero_page"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "MMF_HUGE_ZERO_PAGE",
            "&mm->flags"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstruct page *huge_zero_page;\n\nstruct page *mm_get_huge_zero_page(struct mm_struct *mm)\n{\n\tif (test_bit(MMF_HUGE_ZERO_PAGE, &mm->flags))\n\t\treturn READ_ONCE(huge_zero_page);\n\n\tif (!get_huge_zero_page())\n\t\treturn NULL;\n\n\tif (test_and_set_bit(MMF_HUGE_ZERO_PAGE, &mm->flags))\n\t\tput_huge_zero_page();\n\n\treturn READ_ONCE(huge_zero_page);\n}"
  },
  {
    "function_name": "put_huge_zero_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "92-99",
    "snippet": "static void put_huge_zero_page(void)\n{\n\t/*\n\t * Counter should never go to zero here. Only shrinker can put\n\t * last reference.\n\t */\n\tBUG_ON(atomic_dec_and_test(&huge_zero_refcount));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t huge_zero_refcount;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_dec_and_test(&huge_zero_refcount)"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&huge_zero_refcount"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic atomic_t huge_zero_refcount;\n\nstatic void put_huge_zero_page(void)\n{\n\t/*\n\t * Counter should never go to zero here. Only shrinker can put\n\t * last reference.\n\t */\n\tBUG_ON(atomic_dec_and_test(&huge_zero_refcount));\n}"
  },
  {
    "function_name": "get_huge_zero_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
    "lines": "65-90",
    "snippet": "static struct page *get_huge_zero_page(void)\n{\n\tstruct page *zero_page;\nretry:\n\tif (likely(atomic_inc_not_zero(&huge_zero_refcount)))\n\t\treturn READ_ONCE(huge_zero_page);\n\n\tzero_page = alloc_pages((GFP_TRANSHUGE | __GFP_ZERO) & ~__GFP_MOVABLE,\n\t\t\tHPAGE_PMD_ORDER);\n\tif (!zero_page) {\n\t\tcount_vm_event(THP_ZERO_PAGE_ALLOC_FAILED);\n\t\treturn NULL;\n\t}\n\tcount_vm_event(THP_ZERO_PAGE_ALLOC);\n\tpreempt_disable();\n\tif (cmpxchg(&huge_zero_page, NULL, zero_page)) {\n\t\tpreempt_enable();\n\t\t__free_pages(zero_page, compound_order(zero_page));\n\t\tgoto retry;\n\t}\n\n\t/* We take additional reference here. It will be put back by shrinker */\n\tatomic_set(&huge_zero_refcount, 2);\n\tpreempt_enable();\n\treturn READ_ONCE(huge_zero_page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/oom.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/migrate.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mman.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/dax.h>",
      "#include <linux/swapops.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/shrinker.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t huge_zero_refcount;",
      "struct page *huge_zero_page"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "huge_zero_page"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&huge_zero_refcount",
            "2"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "zero_page",
            "compound_order(zero_page)"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "__free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4430-4438",
          "snippet": "void __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "zero_page"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&huge_zero_page",
            "NULL",
            "zero_page"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "note_cmpxchg_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1992-2014",
          "snippet": "static inline void note_cmpxchg_failure(const char *n,\n\t\tconst struct kmem_cache *s, unsigned long tid)\n{\n#ifdef SLUB_DEBUG_CMPXCHG\n\tunsigned long actual_tid = __this_cpu_read(s->cpu_slab->tid);\n\n\tpr_info(\"%s %s: cmpxchg redo \", n, s->name);\n\n#ifdef CONFIG_PREEMPT\n\tif (tid_to_cpu(tid) != tid_to_cpu(actual_tid))\n\t\tpr_warn(\"due to cpu change %d -> %d\\n\",\n\t\t\ttid_to_cpu(tid), tid_to_cpu(actual_tid));\n\telse\n#endif\n\tif (tid_to_event(tid) != tid_to_event(actual_tid))\n\t\tpr_warn(\"due to cpu running other code. Event %ld->%ld\\n\",\n\t\t\ttid_to_event(tid), tid_to_event(actual_tid));\n\telse\n\t\tpr_warn(\"for unknown reason: actual=%lx was=%lx target=%lx\\n\",\n\t\t\tactual_tid, tid, next_tid(tid));\n#endif\n\tstat(s, CMPXCHG_DOUBLE_CPU_FAIL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void note_cmpxchg_failure(const char *n,\n\t\tconst struct kmem_cache *s, unsigned long tid)\n{\n#ifdef SLUB_DEBUG_CMPXCHG\n\tunsigned long actual_tid = __this_cpu_read(s->cpu_slab->tid);\n\n\tpr_info(\"%s %s: cmpxchg redo \", n, s->name);\n\n#ifdef CONFIG_PREEMPT\n\tif (tid_to_cpu(tid) != tid_to_cpu(actual_tid))\n\t\tpr_warn(\"due to cpu change %d -> %d\\n\",\n\t\t\ttid_to_cpu(tid), tid_to_cpu(actual_tid));\n\telse\n#endif\n\tif (tid_to_event(tid) != tid_to_event(actual_tid))\n\t\tpr_warn(\"due to cpu running other code. Event %ld->%ld\\n\",\n\t\t\ttid_to_event(tid), tid_to_event(actual_tid));\n\telse\n\t\tpr_warn(\"for unknown reason: actual=%lx was=%lx target=%lx\\n\",\n\t\t\tactual_tid, tid, next_tid(tid));\n#endif\n\tstat(s, CMPXCHG_DOUBLE_CPU_FAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "THP_ZERO_PAGE_ALLOC"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "THP_ZERO_PAGE_ALLOC_FAILED"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages",
          "args": [
            "(GFP_TRANSHUGE | __GFP_ZERO) & ~__GFP_MOVABLE",
            "HPAGE_PMD_ORDER"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_pages_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4594-4601",
          "snippet": "void *alloc_pages_exact(size_t size, gfp_t gfp_mask)\n{\n\tunsigned int order = get_order(size);\n\tunsigned long addr;\n\n\taddr = __get_free_pages(gfp_mask, order);\n\treturn make_alloc_exact(addr, order, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\n\nvoid *alloc_pages_exact(size_t size, gfp_t gfp_mask)\n{\n\tunsigned int order = get_order(size);\n\tunsigned long addr;\n\n\taddr = __get_free_pages(gfp_mask, order);\n\treturn make_alloc_exact(addr, order, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "huge_zero_page"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "atomic_inc_not_zero(&huge_zero_refcount)"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_not_zero",
          "args": [
            "&huge_zero_refcount"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic atomic_t huge_zero_refcount;\nstruct page *huge_zero_page;\n\nstatic struct page *get_huge_zero_page(void)\n{\n\tstruct page *zero_page;\nretry:\n\tif (likely(atomic_inc_not_zero(&huge_zero_refcount)))\n\t\treturn READ_ONCE(huge_zero_page);\n\n\tzero_page = alloc_pages((GFP_TRANSHUGE | __GFP_ZERO) & ~__GFP_MOVABLE,\n\t\t\tHPAGE_PMD_ORDER);\n\tif (!zero_page) {\n\t\tcount_vm_event(THP_ZERO_PAGE_ALLOC_FAILED);\n\t\treturn NULL;\n\t}\n\tcount_vm_event(THP_ZERO_PAGE_ALLOC);\n\tpreempt_disable();\n\tif (cmpxchg(&huge_zero_page, NULL, zero_page)) {\n\t\tpreempt_enable();\n\t\t__free_pages(zero_page, compound_order(zero_page));\n\t\tgoto retry;\n\t}\n\n\t/* We take additional reference here. It will be put back by shrinker */\n\tatomic_set(&huge_zero_refcount, 2);\n\tpreempt_enable();\n\treturn READ_ONCE(huge_zero_page);\n}"
  }
]